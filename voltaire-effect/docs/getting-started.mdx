---
title: Getting Started
description: Install and start using voltaire-effect
---

## Install

<CodeGroup>
```bash pnpm
pnpm add voltaire-effect @tevm/voltaire effect
```

```bash npm
npm install voltaire-effect @tevm/voltaire effect
```

```bash yarn
yarn add voltaire-effect @tevm/voltaire effect
```

```bash bun
bun add voltaire-effect @tevm/voltaire effect
```
</CodeGroup>

<Info>
voltaire-effect requires **Effect** 3.x and **Voltaire** 0.x. TypeScript 5.4+ recommended.
</Info>

<Note>
Runtime support:
- **Browser/WASM:** `BrowserTransport` (EIP-1193) or HTTP; native HD wallet is unavailable.
- **Node/Bun:** Full transport support + HD wallet (native FFI).
</Note>

## First Program

Fetch the latest block number:

```typescript
import { Effect } from 'effect'
import { getBlockNumber, Provider, HttpTransport } from 'voltaire-effect'

const program = Effect.gen(function* () {
  return yield* getBlockNumber()
}).pipe(
  Effect.provide(Provider),
  Effect.provide(HttpTransport('https://eth.llamarpc.com'))
)

const blockNumber = await Effect.runPromise(program)
console.log(`Block: ${blockNumber}`)
```

## Schema Validation

Validate and parse input:

```typescript
import * as Address from 'voltaire-effect/primitives/Address'
import * as S from 'effect/Schema'

// Decode from hex string
const addr = S.decodeSync(Address.Hex)('0x742d35Cc6634C0532925a3b844Bc9e7595f251e3')

// Returns actual Voltaire branded type - use directly
Address.equals(addr, addr) // true
Address.isZero(addr) // false
Address.toHex(addr)  // "0x742d35cc..."
```

<Note>
Most APIs accept `AddressInput` (either a branded `AddressType` or a `0x` hex string). Decode user input at boundaries, then pass branded types internally. See [Branded Types](/concepts/branded-types).
</Note>

## Effect-Based Validation

Handle parse errors gracefully:

```typescript
import * as Address from 'voltaire-effect/primitives/Address'
import * as S from 'effect/Schema'
import * as Effect from 'effect/Effect'

const parseAddress = (input: string) =>
  S.decode(Address.Hex)(input).pipe(
    Effect.catchTag('ParseError', () => 
      Effect.succeed(Address.zero())  // Fallback to zero address
    )
  )
```

## Checksummed Addresses

EIP-55 checksumming requires the Keccak hash service:

```typescript
import * as Address from 'voltaire-effect/primitives/Address'
import * as S from 'effect/Schema'
import * as Effect from 'effect/Effect'
import { KeccakLive } from 'voltaire-effect/crypto/Keccak256'

const addr = S.decodeSync(Address.Hex)('0x742d35Cc6634C0532925a3b844Bc9e7595f251e3')

// Encode to checksummed (requires KeccakService)
const checksummed = await Effect.runPromise(
  S.encode(Address.Checksummed)(addr).pipe(Effect.provide(KeccakLive))
)
// "0x742d35Cc6634C0532925a3b844Bc9e7595f251e3"
```

## Read Contract

```typescript
import { Effect } from 'effect'
import { Contract, Provider, HttpTransport } from 'voltaire-effect'

const erc20 = [
  { type: 'function', name: 'balanceOf', inputs: [{ name: 'account', type: 'address' }], 
    outputs: [{ type: 'uint256' }], stateMutability: 'view' }
] as const

const getBalance = Effect.gen(function* () {
  const usdc = yield* Contract('0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48', erc20)
  return yield* usdc.read.balanceOf('0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045')
}).pipe(
  Effect.provide(Provider),
  Effect.provide(HttpTransport('https://eth.llamarpc.com'))
)

const balance = await Effect.runPromise(getBalance)
```

## Timeout & Retry

Per-request overrides and transport configuration use Effect-native Duration and Schedule:

```typescript
import { Effect, Schedule } from 'effect'
import { getBalance, Provider, HttpTransport, withTimeout, withRetrySchedule } from 'voltaire-effect'

// Per-request timeout
getBalance(addr).pipe(withTimeout("5 seconds"))

// Per-request retry schedule
getBalance(addr).pipe(
  withRetrySchedule(Schedule.exponential("500 millis").pipe(
    Schedule.jittered,
    Schedule.compose(Schedule.recurs(3))
  ))
)

// Transport-level defaults
HttpTransport({
  url: 'https://eth.llamarpc.com',
  timeout: '30 seconds',
  retrySchedule: Schedule.exponential('500 millis').pipe(
    Schedule.jittered,
    Schedule.compose(Schedule.recurs(5))
  )
})
```

## Next Steps

<CardGroup cols={2}>
  <Card title="Effect Primer" icon="graduation-cap" href="/concepts/effect-primer">
    5-minute Effect.ts intro for Ethereum devs
  </Card>
  <Card title="Layers" icon="layer-group" href="/layers">
    Schema, Effect, and Service layers explained
  </Card>
  <Card title="Cheatsheet" icon="bolt" href="/cheatsheet">
    Quick reference for all patterns
  </Card>
  <Card title="Examples" icon="code" href="/examples/index">
    Copy-paste solutions for common tasks
  </Card>
</CardGroup>

## Related

- [Effect Getting Started](https://effect.website/docs/getting-started/introduction/) — Official Effect documentation
- [Voltaire Docs](https://voltaire.tevm.sh) — Core primitives and crypto
- [Why voltaire-effect?](/why) — Trade-offs and comparisons
- [Troubleshooting](/troubleshooting) — Common issues and solutions
- [Migrating from viem](/guides/migrating-from-viem) — Step-by-step migration guide
- [Migrating from ethers](/guides/migrating-from-ethers) — Step-by-step migration guide
