---
title: Transport
description: Effect-based JSON-RPC transport for Ethereum
---

## Quick Start

```typescript
import { TransportService, HttpTransport } from 'voltaire-effect'
import { Effect } from 'effect'

const program = Effect.gen(function* () {
  const transport = yield* TransportService
  const blockNumber = yield* transport.request<string>('eth_blockNumber', [])
  return BigInt(blockNumber)
}).pipe(
  Effect.provide(HttpTransport('https://eth.llamarpc.com'))
)
```

## HttpTransport

```typescript
import { Schedule } from 'effect'

// Simple
HttpTransport('https://eth.llamarpc.com')

// With Effect Duration and Schedule
HttpTransport({
  url: 'https://eth.llamarpc.com',
  headers: { 'X-Api-Key': 'secret' },
  timeout: '60 seconds',  // Effect Duration (default: "30 seconds")
  retrySchedule: Schedule.exponential('500 millis').pipe(
    Schedule.jittered,
    Schedule.compose(Schedule.recurs(5))
  )
})
```

<Note>
`timeout` accepts any Effect `DurationInput` (strings, numbers in ms, or `Duration`). Use strings for readability.
</Note>

## Per-Request Overrides

Use FiberRef-based helpers for scoped overrides:

```typescript
import { getBalance, getBlockNumber, withTimeout, withRetrySchedule, withoutCache, withTracing } from 'voltaire-effect'
import { Schedule } from 'effect'

// Override timeout for a single call
const balance = yield* getBalance(addr).pipe(
  withTimeout('5 seconds')
)

// Custom retry schedule
const block = yield* getBlockNumber().pipe(
  withRetrySchedule(Schedule.recurs(1))
)

// Disable caching
const fresh = yield* getBlockNumber().pipe(withoutCache)

// Enable tracing
const traced = yield* getBalance(addr).pipe(withTracing())
```

## Request Batching

Combine multiple JSON-RPC requests into a single HTTP call for better performance.

```typescript
import { HttpTransport, TransportService } from 'voltaire-effect'
import { Effect } from 'effect'

const transport = HttpTransport({
  url: 'https://eth.llamarpc.com',
  batch: {
    batchSize: 50,    // Max requests per batch (default: 100)
    wait: 10          // Wait time in ms before flushing (default: 0)
  }
})

// Requests made concurrently are automatically batched
const program = Effect.gen(function* () {
  const t = yield* TransportService
  const [blockNumber, chainId, gasPrice] = yield* Effect.all([
    t.request<string>('eth_blockNumber'),
    t.request<string>('eth_chainId'),
    t.request<string>('eth_gasPrice')
  ])
  return { blockNumber, chainId, gasPrice }
}).pipe(Effect.provide(transport))
```

### How Batching Works

- Requests are queued and sent together when `batchSize` is reached or after `wait` ms
- Each request in the batch is matched to its response by ID
- If one request fails, only that request fails (others still succeed)
- Network/HTTP errors fail the entire batch

## WebSocketTransport

```typescript
import { WebSocketTransport } from 'voltaire-effect'

program.pipe(
  Effect.provide(WebSocketTransport('wss://eth.llamarpc.com'))
)
```

## BrowserTransport

Uses `window.ethereum` ([EIP-1193](https://eips.ethereum.org/EIPS/eip-1193)).

```typescript
import { BrowserTransport } from 'voltaire-effect'

const program = Effect.gen(function* () {
  const transport = yield* TransportService
  const accounts = yield* transport.request<string[]>('eth_accounts', [])
  return accounts[0]
}).pipe(
  Effect.provide(BrowserTransport)
)
```

## Testing

```typescript
import { TestTransport, TransportError } from 'voltaire-effect'

const mockResponses = new Map([
  ['eth_blockNumber', '0x1234'],
  ['eth_chainId', '0x1'],
])

program.pipe(Effect.provide(TestTransport(mockResponses)))

// Mock errors
const errorResponses = new Map([
  ['eth_call', new TransportError({ code: -32000, message: 'execution reverted' })],
])
```

## Error Handling

```typescript
import { TransportError } from 'voltaire-effect'

program.pipe(
  Effect.catchTag("TransportError", (e) => 
    Effect.succeed(`Error ${e.code}: ${e.message}`)
  )
)
```

Error codes: `-32700` parse, `-32600` invalid request, `-32601` method not found, `-32602` invalid params, `-32603` internal, `-32000` to `-32099` server errors.

## Thread Safety

All transport implementations are fiber-safe:
- **HttpTransport**: Stateless per request, safe for concurrent use
- **WebSocketTransport**: Uses atomic `Ref.update` for pending request map, safe for concurrent use
- **BrowserTransport**: Delegates to `window.ethereum`, concurrent safety depends on wallet

Fire many requests in parallel without coordination:

```typescript
const requests = Array.from({ length: 100 }, () =>
  transport.request<string>('eth_blockNumber', [])
)
const results = yield* Effect.all(requests, { concurrency: 'unbounded' })
```

## Service Interface

```typescript
class TransportService extends Context.Tag("TransportService")<
  TransportService,
  {
    readonly request: <T>(method: string, params?: unknown[]) => Effect.Effect<T, TransportError>
  }
>() {}

class TransportError extends Error {
  readonly _tag = "TransportError"
  readonly code: number
  readonly message: string
  readonly data?: unknown
}
```

## See Also

- [Provider Service](/services/provider) — Uses TransportService for RPC calls
- [Signer Service](/services/signer) — Uses TransportService for transaction broadcast
- [EIP-1193](https://eips.ethereum.org/EIPS/eip-1193) — Ethereum Provider JavaScript API
- [JSON-RPC Spec](https://www.jsonrpc.org/specification) — JSON-RPC 2.0 specification
