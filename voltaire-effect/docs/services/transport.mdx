---
title: Transport
description: Effect-based JSON-RPC transport for Ethereum
---

## Quick Start

```typescript
import { TransportService, HttpTransport } from 'voltaire-effect/services'
import { Effect } from 'effect'

const program = Effect.gen(function* () {
  const transport = yield* TransportService
  const blockNumber = yield* transport.request<string>('eth_blockNumber', [])
  return BigInt(blockNumber)
}).pipe(
  Effect.provide(HttpTransport('https://eth.llamarpc.com'))
)
```

## HttpTransport

```typescript
// Simple
HttpTransport('https://eth.example.com')

// With options
HttpTransport({
  url: 'https://eth.example.com',
  headers: { 'X-Api-Key': 'secret' },
  timeout: 60000,      // default: 30000ms
  retries: 5,          // default: 3
  retryDelay: 1000     // default: 1000ms
})
```

## Request Batching

Combine multiple JSON-RPC requests into a single HTTP call for better performance.

```typescript
import { HttpTransport, TransportService } from 'voltaire-effect/services'
import { Effect } from 'effect'

const transport = HttpTransport({
  url: 'https://eth.example.com',
  batch: {
    batchSize: 50,    // Max requests per batch (default: 100)
    wait: 10          // Wait time in ms before flushing (default: 0)
  }
})

// Requests made concurrently are automatically batched
const program = Effect.gen(function* () {
  const t = yield* TransportService
  const [blockNumber, chainId, gasPrice] = yield* Effect.all([
    t.request<string>('eth_blockNumber'),
    t.request<string>('eth_chainId'),
    t.request<string>('eth_gasPrice')
  ])
  return { blockNumber, chainId, gasPrice }
}).pipe(Effect.provide(transport))
```

### How Batching Works

- Requests are queued and sent together when `batchSize` is reached or after `wait` ms
- Each request in the batch is matched to its response by ID
- If one request fails, only that request fails (others still succeed)
- Network/HTTP errors fail the entire batch

## WebSocketTransport

```typescript
import { WebSocketTransport } from 'voltaire-effect/services'

program.pipe(
  Effect.provide(WebSocketTransport('wss://eth.example.com'))
)
```

## BrowserTransport

Uses `window.ethereum` (EIP-1193).

```typescript
import { BrowserTransport } from 'voltaire-effect/services'

const program = Effect.gen(function* () {
  const transport = yield* TransportService
  const accounts = yield* transport.request<string[]>('eth_accounts', [])
  return accounts[0]
}).pipe(
  Effect.provide(BrowserTransport)
)
```

## Testing

```typescript
import { TestTransport, TransportError } from 'voltaire-effect/services'

const mockResponses = new Map([
  ['eth_blockNumber', '0x1234'],
  ['eth_chainId', '0x1'],
])

program.pipe(Effect.provide(TestTransport(mockResponses)))

// Mock errors
const errorResponses = new Map([
  ['eth_call', new TransportError({ code: -32000, message: 'execution reverted' })],
])
```

## Error Handling

```typescript
import { TransportError } from 'voltaire-effect/services'

program.pipe(
  Effect.catchTag("TransportError", (e) => 
    Effect.succeed(`Error ${e.code}: ${e.message}`)
  )
)
```

Error codes: `-32700` parse, `-32600` invalid request, `-32601` method not found, `-32602` invalid params, `-32603` internal, `-32000` to `-32099` server errors.

## Thread Safety

All transport implementations are fiber-safe:
- **HttpTransport**: Stateless per request, safe for concurrent use
- **WebSocketTransport**: Uses atomic `Ref.update` for pending request map, safe for concurrent use
- **BrowserTransport**: Delegates to `window.ethereum`, concurrent safety depends on wallet

Fire many requests in parallel without coordination:

```typescript
const requests = Array.from({ length: 100 }, () =>
  transport.request<string>('eth_blockNumber', [])
)
const results = yield* Effect.all(requests, { concurrency: 'unbounded' })
```

## Service Interface

```typescript
class TransportService extends Context.Tag("TransportService")<
  TransportService,
  {
    readonly request: <T>(method: string, params?: unknown[]) => Effect.Effect<T, TransportError>
  }
>() {}

class TransportError extends Error {
  readonly _tag = "TransportError"
  readonly code: number
  readonly message: string
  readonly data?: unknown
}
```
