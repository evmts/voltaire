---
title: Provider Service
description: Read-only blockchain operations with Effect.ts
---

## Quick Start

```typescript
import { Effect } from 'effect'
import { ProviderService, Provider, HttpTransport } from 'voltaire-effect/services'

const program = Effect.gen(function* () {
  const provider = yield* ProviderService
  const blockNum = yield* provider.getBlockNumber()
  const balance = yield* provider.getBalance('0x1234567890123456789012345678901234567890')
  return { blockNum, balance }
}).pipe(
  Effect.provide(Provider),
  Effect.provide(HttpTransport('https://eth.llamarpc.com'))
)
```

## Layer Composition

`Provider` is a Layer that requires `TransportService`:

```typescript
import * as Layer from 'effect/Layer'

// Provider depends on Transport
const Provider: Layer.Layer<ProviderService, never, TransportService>

// Compose layers
const FullProvider = Provider.pipe(
  Layer.provide(HttpTransport('https://eth.llamarpc.com'))
)

// Use in program
const program = myEffect.pipe(Effect.provide(FullProvider))
```

## Block Queries

```typescript
const provider = yield* ProviderService

const blockNum = yield* provider.getBlockNumber()
const block = yield* provider.getBlock({ blockTag: 'latest', includeTransactions: true })
const blockByHash = yield* provider.getBlock({ blockHash: '0x...' })
```

## Account State

```typescript
const balance = yield* provider.getBalance('0x1234...', 'latest')
const nonce = yield* provider.getTransactionCount('0x1234...')
const code = yield* provider.getCode('0x1234...')
const slot = yield* provider.getStorageAt('0x1234...', '0x0')
```

## Transactions

```typescript
const tx = yield* provider.getTransaction('0x...')
const receipt = yield* provider.getTransactionReceipt('0x...')
const confirmed = yield* provider.waitForTransactionReceipt('0x...', {
  confirmations: 3,
  timeout: 60000
})
```

## Read Contract

Type-safe contract reads without creating a Contract instance:

```typescript
import { readContract } from 'voltaire-effect/services'

const erc20Abi = [
  {
    type: 'function',
    name: 'balanceOf',
    stateMutability: 'view',
    inputs: [{ name: 'account', type: 'address' }],
    outputs: [{ type: 'uint256' }]
  }
] as const

const balance = yield* readContract({
  address: '0x6B175474E89094C44Da98b954EecdEfaE6E286AB',
  abi: erc20Abi,
  functionName: 'balanceOf',
  args: ['0x1234567890123456789012345678901234567890']
})
// balance is bigint
```

### Multi-Return Functions

```typescript
const pairAbi = [
  {
    type: 'function',
    name: 'getReserves',
    stateMutability: 'view',
    inputs: [],
    outputs: [
      { name: 'reserve0', type: 'uint112' },
      { name: 'reserve1', type: 'uint112' },
      { name: 'blockTimestampLast', type: 'uint32' }
    ]
  }
] as const

const [reserve0, reserve1, timestamp] = yield* readContract({
  address: pairAddress,
  abi: pairAbi,
  functionName: 'getReserves'
})
```

### Block Tag

```typescript
const balance = yield* readContract({
  address: tokenAddress,
  abi: erc20Abi,
  functionName: 'balanceOf',
  args: [account],
  blockTag: 'finalized'
})
```

## Call & Estimate

```typescript
const result = yield* provider.call({
  to: '0x1234567890123456789012345678901234567890',
  data: '0x...'
})

const gas = yield* provider.estimateGas({
  to: '0x1234567890123456789012345678901234567890',
  data: '0x...',
  value: 1000000000000000000n
})
```

## multicall

Batches multiple contract reads into a single RPC call using the Multicall3 contract at `0xcA11bde05977b3631167028862bE2a173976CA11`. Reduces network overhead by 10-100x.

```typescript
import { multicall } from 'voltaire-effect/services'

const erc20Abi = [
  {
    type: 'function',
    name: 'balanceOf',
    stateMutability: 'view',
    inputs: [{ name: 'account', type: 'address' }],
    outputs: [{ type: 'uint256' }]
  }
] as const

const results = yield* multicall({
  contracts: [
    {
      address: '0x6B175474E89094C44Da98b954EecdEfaE6E286AB',
      abi: erc20Abi,
      functionName: 'balanceOf',
      args: ['0x1234567890123456789012345678901234567890']
    },
    {
      address: '0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48',
      abi: erc20Abi,
      functionName: 'balanceOf',
      args: ['0x1234567890123456789012345678901234567890']
    }
  ]
})
// results: [{ status: 'success', result: 1000n }, { status: 'success', result: 500n }]
```

### allowFailure Mode

By default, `allowFailure` is `true` and results include status:

```typescript
const results = yield* multicall({
  contracts: [...],
  allowFailure: true  // default
})

for (const r of results) {
  if (r.status === 'success') {
    console.log(r.result)
  } else {
    console.log('Call failed:', r.error)
  }
}
```

Set `allowFailure: false` to throw on any failure and get unwrapped results:

```typescript
const results = yield* multicall({
  contracts: [...],
  allowFailure: false
})
// results: [1000n, 500n] - throws if any call fails
```

### Block Tag

```typescript
const results = yield* multicall({
  contracts: [...],
  blockTag: 'finalized'
})
```

## simulateContract

Simulates a contract write function before sending. Returns both the decoded result and a prepared transaction request.

```typescript
import { simulateContract } from 'voltaire-effect/services'

const { result, request } = yield* simulateContract({
  address: tokenAddress,
  abi: erc20Abi,
  functionName: 'transfer',
  args: [recipient, amount],
  account: senderAddress
})

// Check if transfer would succeed
if (result === false) {
  throw new Error('Transfer would fail')
}

// Send the transaction using the prepared request
const hash = yield* signer.sendTransaction({
  to: request.to,
  data: request.data,
  value: request.value
})
```

### Account Simulation

Pass `account` to simulate from a specific sender address (affects `msg.sender` in the call):

```typescript
const { result } = yield* simulateContract({
  address: contractAddress,
  abi,
  functionName: 'restrictedFunction',
  account: ownerAddress  // Simulate as owner
})
```

### Use Case: Validate Before Sending

simulateContract is essential for validating writes before spending gas:

```typescript
import { Effect } from 'effect'
import { simulateContract, ProviderError } from 'voltaire-effect/services'

const safeTransfer = Effect.gen(function* () {
  const { result, request } = yield* simulateContract({
    address: tokenAddress,
    abi: erc20Abi,
    functionName: 'transfer',
    args: [recipient, amount],
    account: sender
  })
  
  if (!result) {
    return yield* Effect.fail(new Error('Transfer would fail'))
  }
  
  return request
}).pipe(
  Effect.catchTag('ProviderError', (e) => {
    // Contract reverted - extract revert reason
    return Effect.fail(new Error(`Simulation failed: ${e.message}`))
  })
)
```

## Event Logs

```typescript
const logs = yield* provider.getLogs({
  address: '0x1234567890123456789012345678901234567890',
  topics: ['0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef'],
  fromBlock: '0x100000',
  toBlock: 'latest'
})
```

## Gas Pricing

```typescript
const gasPrice = yield* provider.getGasPrice()
const priorityFee = yield* provider.getMaxPriorityFeePerGas()
const feeHistory = yield* provider.getFeeHistory(10, 'latest', [25, 50, 75])
```

## Error Handling

```typescript
import { ProviderError } from 'voltaire-effect/services'

program.pipe(
  Effect.catchTag('ProviderError', (e) => {
    console.error('RPC failed:', e.message)
    return Effect.succeed(0n)
  })
)
```

## Service Interface

```typescript
type AddressInput = AddressType | `0x${string}`
type HashInput = HashType | `0x${string}`

type ProviderShape = {
  readonly getBlockNumber: () => Effect.Effect<bigint, ProviderError>
  readonly getBlock: (args?: GetBlockArgs) => Effect.Effect<BlockType, ProviderError>
  readonly getBlockTransactionCount: (args: GetBlockTransactionCountArgs) => Effect.Effect<bigint, ProviderError>
  readonly getBalance: (address: AddressInput, blockTag?: BlockTag) => Effect.Effect<bigint, ProviderError>
  readonly getTransactionCount: (address: AddressInput, blockTag?: BlockTag) => Effect.Effect<bigint, ProviderError>
  readonly getCode: (address: AddressInput, blockTag?: BlockTag) => Effect.Effect<HexType | `0x${string}`, ProviderError>
  readonly getStorageAt: (address: AddressInput, slot: HashInput, blockTag?: BlockTag) => Effect.Effect<HexType | `0x${string}`, ProviderError>
  readonly getTransaction: (hash: HashInput) => Effect.Effect<TransactionType, ProviderError>
  readonly getTransactionReceipt: (hash: HashInput) => Effect.Effect<ReceiptType, ProviderError>
  readonly waitForTransactionReceipt: (hash: HashInput, opts?: { 
    confirmations?: number
    timeout?: number 
  }) => Effect.Effect<ReceiptType, ProviderError>
  readonly call: (tx: CallRequest, blockTag?: BlockTag) => Effect.Effect<HexType | `0x${string}`, ProviderError>
  readonly estimateGas: (tx: CallRequest) => Effect.Effect<bigint, ProviderError>
  readonly createAccessList: (tx: CallRequest) => Effect.Effect<AccessListType, ProviderError>
  readonly getLogs: (filter: LogFilter) => Effect.Effect<LogType[], ProviderError>
  readonly getChainId: () => Effect.Effect<number, ProviderError>
  readonly getGasPrice: () => Effect.Effect<bigint, ProviderError>
  readonly getMaxPriorityFeePerGas: () => Effect.Effect<bigint, ProviderError>
  readonly getFeeHistory: (
    blockCount: number, 
    newestBlock: BlockTag, 
    rewardPercentiles: number[]
  ) => Effect.Effect<FeeHistoryType, ProviderError>
}

// Block identifier - named tag or hex block number
type BlockTag = 'latest' | 'earliest' | 'pending' | 'safe' | 'finalized' | `0x${string}`

// Block args - XOR: use blockTag OR blockHash, never both
type GetBlockArgs =
  | { blockTag?: BlockTag; includeTransactions?: boolean; blockHash?: never }
  | { blockHash: HashInput; includeTransactions?: boolean; blockTag?: never }

// Block tx count args - XOR: use blockTag OR blockHash, never both
type GetBlockTransactionCountArgs =
  | { blockTag?: BlockTag; blockHash?: never }
  | { blockHash: HashInput; blockTag?: never }

// Log filter - XOR: use blockHash OR fromBlock/toBlock, never both
type LogFilter =
  | { blockHash: HashInput; fromBlock?: never; toBlock?: never; address?: ...; topics?: ... }
  | { blockHash?: never; fromBlock?: BlockTag; toBlock?: BlockTag; address?: ...; topics?: ... }

// Block type with nullable fields for pending blocks
interface BlockType {
  number: string | null               // null for pending blocks
  hash: string | null                 // null for pending blocks
  parentHash: string
  // ... other header fields
  baseFeePerGas?: string              // EIP-1559 (optional)
  withdrawals?: WithdrawalType[]      // EIP-4895 (optional)
  withdrawalsRoot?: string            // EIP-4895 (optional)
  blobGasUsed?: string                // EIP-4844 (optional)
  excessBlobGas?: string              // EIP-4844 (optional)
  parentBeaconBlockRoot?: string      // EIP-4788 (optional)
}

// Transaction type with nullable fields for pending txs
interface TransactionType {
  hash: string
  blockHash: string | null            // null if pending
  blockNumber: string | null          // null if pending
  transactionIndex: string | null     // null if pending
  to: string | null                   // null for contract creation
  // ... other fields
  maxFeePerBlobGas?: string           // EIP-4844 (optional)
  blobVersionedHashes?: string[]      // EIP-4844 (optional)
  yParity?: string                    // EIP-2930+ (optional)
}
```

## Chain-Specific Providers

Use Layer composition for L2-specific features:

```typescript
import { OpStackActionsService, OpStackActions } from 'voltaire-effect/services'

// Compose OP Stack extension with base Provider
const OpStackProvider = Layer.merge(Provider, OpStackActions)

const program = Effect.gen(function* () {
  const provider = yield* ProviderService
  const opStack = yield* OpStackActionsService
  
  const block = yield* provider.getBlockNumber()
  const l1BaseFee = yield* opStack.getL1BaseFee()
  
  return { block, l1BaseFee }
}).pipe(
  Effect.provide(OpStackProvider),
  Effect.provide(HttpTransport('https://mainnet.optimism.io'))
)
```
