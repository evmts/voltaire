---
title: Secp256k1
description: ECDSA signing for Ethereum transactions
---

Sign messages, recover public keys, verify signatures.

```typescript
import { Secp256k1Service, Secp256k1Live } from 'voltaire-effect/crypto'
import { Effect } from 'effect'

const result = await Effect.runPromise(
  Effect.gen(function* () {
    const secp = yield* Secp256k1Service
    const signature = yield* secp.sign(messageHash, privateKey)
    const publicKey = yield* secp.recover(signature, messageHash)
    const isValid = yield* secp.verify(signature, messageHash, publicKey)
    return { signature, publicKey, isValid }
  }).pipe(Effect.provide(Secp256k1Live))
)
```

## Error Handling

```typescript
program.pipe(
  Effect.catchTag('InvalidPrivateKeyError', (e) => ...),
  Effect.catchTag('CryptoError', (e) => ...)
)
```

## Testing

```typescript
import { Secp256k1Test } from 'voltaire-effect/crypto'
myProgram.pipe(Effect.provide(Secp256k1Test))
```

## Interface

```typescript
interface Secp256k1ServiceShape {
  readonly sign: (
    messageHash: HashType,
    privateKey: Uint8Array,
    options?: { extraEntropy?: boolean | Uint8Array }
  ) => Effect.Effect<Secp256k1SignatureType, InvalidPrivateKeyError | CryptoError>

  readonly recover: (
    signature: Secp256k1SignatureType,
    messageHash: HashType
  ) => Effect.Effect<Secp256k1PublicKeyType, InvalidSignatureError>

  readonly verify: (
    signature: Secp256k1SignatureType,
    messageHash: HashType,
    publicKey: Secp256k1PublicKeyType
  ) => Effect.Effect<boolean, InvalidSignatureError>
}
```
