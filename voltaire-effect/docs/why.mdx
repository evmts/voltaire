---
title: Why voltaire-effect?
description: Typed errors, composable workflows, and testable Ethereum code
---

[Voltaire](https://voltaire.tevm.sh) gives you branded types and high-performance crypto. voltaire-effect adds [Effect.ts](https://effect.website/docs/getting-started/introduction/): typed errors, composable pipelines, and dependency injection.

## Typed Errors

Exceptions are invisible. Effect Schema makes decode failures explicit and typed.

```typescript
import * as S from 'effect/Schema'
import * as Address from 'voltaire-effect/primitives/Address'

// Schema decode - errors are typed ParseError
const result = S.decodeEither(Address.Hex)(input)
// Either<AddressType, ParseError>
```

The error type is in the signature. No `catch (e: unknown)`. No manual narrowing.

## Composability

Chain operations with `pipe`, use `Effect.gen` for async/await-like syntax.

```typescript
import * as Effect from 'effect/Effect'
import * as S from 'effect/Schema'

const program = Effect.gen(function* () {
  const addr = yield* S.decode(Address.Hex)(input)
  const balance = yield* provider.getBalance(addr)
  return { addr, balance }
})
```

Errors short-circuit. Dependencies flow through. No ceremony.

## Testability

Services are injected, not imported. Swap `ProviderLive` for `ProviderTest` without touching business logic.

```typescript
// Production
Effect.runPromise(program.pipe(Effect.provide(MainLayer)))

// Test - same code, different wiring
Effect.runPromise(program.pipe(Effect.provide(TestLayer)))
```

No mocking frameworks. No module interception. Just provide different layers.

## Schema Validation

Decode at boundaries, trust internally. Schema decodes directly to Voltaire's branded types.

```typescript
import * as S from 'effect/Schema'
import * as Address from 'voltaire-effect/primitives/Address'
import * as Uint from 'voltaire-effect/primitives/Uint'

const UserInput = S.Struct({
  to: Address.Hex,
  value: Uint.Uint256,
})
// Decoding validates AND returns branded Voltaire types
```

One decode call. Full validation. Real types out.

## Retry, Timeout, Fallback

Built into Effect. No external libraries.

```typescript
import { Effect, Schedule, Duration } from 'effect'

provider.getBlockNumber().pipe(
  Effect.retry(Schedule.exponential('100 millis').pipe(Schedule.recurs(5))),
  Effect.timeout(Duration.seconds(10)),
  Effect.orElse(() => fallbackProvider.getBlockNumber())
)
```

## Before/After

```typescript
// Without Effect: exceptions, untyped errors, hard to test
try {
  const addr = parseAddress(input)
  const balance = await provider.getBalance(addr)
  return { addr, balance }
} catch (e) {
  // What type is e? Could be anything.
}

// With Effect: typed errors, composable, testable
const program = Effect.gen(function* () {
  const addr = yield* S.decode(Address.Hex)(input)
  const balance = yield* provider.getBalance(addr)
  return { addr, balance }
}).pipe(
  Effect.catchTag("ParseError", () => Effect.succeed(fallback))
)
```

## Trade-offs

**voltaire-effect adds:**
- ~15KB for Effect runtime
- New mental model (services, layers, generators)
- Slightly more verbose simple cases

**You get:**
- Typed errors everywhere
- Zero-cost retries, timeouts, concurrency
- Swappable dependencies without mocking
- Composable operations that short-circuit on failure

Use [base Voltaire](https://voltaire.tevm.sh) for scripts and small tools. Use voltaire-effect when you want the type system to track your errors.

## See Also

- [Comparisons](/comparisons) — Detailed comparison with viem, ethers, and base Voltaire
- [Effect Error Management](https://effect.website/docs/error-management/two-error-types/) — How Effect handles errors
- [Effect Services](https://effect.website/docs/requirements-management/services/) — Dependency injection in Effect
