---
title: Why voltaire-effect?
description: Typed errors, composable workflows, and testable Ethereum code
---

Voltaire gives you branded types and high-performance crypto. voltaire-effect adds Effect.ts: typed errors, composable pipelines, and dependency injection.

## Typed Errors

Exceptions are invisible. Effect Schema makes decode failures explicit and typed.

```typescript
import * as S from 'effect/Schema'
import * as Address from 'voltaire-effect/primitives/Address'

// Schema decode - errors are typed ParseError
const result = S.decodeEither(Address.Hex)(input)
// Either<AddressType, ParseError>
```

## Composability

Chain operations with `pipe`, use `Effect.gen` for async/await-like syntax.

```typescript
import * as Effect from 'effect/Effect'
import * as S from 'effect/Schema'

const program = Effect.gen(function* () {
  const addr = yield* S.decode(Address.Hex)(input)
  const balance = yield* Provider.getBalance(addr)
  return { addr, balance }
})
```

## Testability

Services are injected, not imported. Swap `ProviderLive` for `ProviderTest` without touching business logic.

```typescript
// Production
Effect.runPromise(program.pipe(Effect.provide(ProviderLive)))

// Test
Effect.runPromise(program.pipe(Effect.provide(ProviderTest)))
```

## Schema Validation

Decode at boundaries, trust internally. Schema decodes directly to Voltaire's branded types.

```typescript
import * as S from 'effect/Schema'
import * as Address from 'voltaire-effect/primitives/Address'
import * as Uint from 'voltaire-effect/primitives/Uint'

const UserInput = S.Struct({
  to: Address.Hex,
  value: Uint.Uint256,
})
// Decoding validates AND returns branded Voltaire types
```

## Before/After

```typescript
// Without Effect: exceptions, untyped errors, hard to test
try {
  const addr = parseAddress(input)
  const balance = await provider.getBalance(addr)
  return { addr, balance }
} catch (e) {
  // What type is e? Could be anything.
}

// With Effect: typed errors, composable, testable
const program = Effect.gen(function* () {
  const addr = yield* S.decode(Address.Hex)(input)
  const balance = yield* Provider.getBalance(addr)
  return { addr, balance }
}).pipe(
  Effect.catchTag("ParseError", () => Effect.succeed(fallback))
)
```
