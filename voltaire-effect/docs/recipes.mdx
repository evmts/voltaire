---
title: Recipes
description: Copy-paste solutions for common Ethereum tasks
---

Ready-to-use patterns for common Ethereum operations. Each recipe is self-contained with all imports. See [Examples](/examples/index) for more detailed tutorials.

<Tip>
These recipes assume you have installed `voltaire-effect @tevm/voltaire effect`. See [Getting Started](/getting-started) for setup.
</Tip>

## Check If Address Is Contract

```typescript
import { Effect } from 'effect'
import { getCode, Provider, HttpTransport } from 'voltaire-effect'

const isContract = (address: string) => Effect.gen(function* () {
  const code = yield* getCode(address, 'latest')
  return code !== '0x' && code.length > 2
}).pipe(
  Effect.provide(Provider),
  Effect.provide(HttpTransport('https://eth.llamarpc.com'))
)
```

## Get Token Balance (ERC-20)

```typescript
import { Effect } from 'effect'
import { Contract, Provider, HttpTransport } from 'voltaire-effect'

const erc20Abi = [
  { type: 'function', name: 'balanceOf', inputs: [{ name: 'account', type: 'address' }], 
    outputs: [{ type: 'uint256' }], stateMutability: 'view' },
  { type: 'function', name: 'decimals', inputs: [], 
    outputs: [{ type: 'uint8' }], stateMutability: 'view' }
] as const

const getTokenBalance = (token: string, user: string) => Effect.gen(function* () {
  const contract = yield* Contract(token, erc20Abi)
  const [balance, decimals] = yield* Effect.all([
    contract.read.balanceOf(user),
    contract.read.decimals()
  ])
  return { raw: balance, formatted: Number(balance) / 10 ** decimals }
}).pipe(
  Effect.provide(Provider),
  Effect.provide(HttpTransport('https://eth.llamarpc.com'))
)
```

<Warning>
Production note: avoid `Number(balance)` for arbitrary ERC-20 balances. Use bigint-safe formatting (e.g., Formatter or Denomination helpers).
</Warning>

## Approve and Transfer ERC-20

```typescript
import { Effect } from 'effect'
import { Contract, Signer, LocalAccount, Provider, HttpTransport } from 'voltaire-effect'
import { Secp256k1Live, KeccakLive } from 'voltaire-effect/crypto'

const approveAndTransfer = (
  token: string, 
  spender: string, 
  recipient: string, 
  amount: bigint, 
  privateKey: Uint8Array
) => Effect.gen(function* () {
  const contract = yield* Contract(token, [
    { type: 'function', name: 'approve', inputs: [
      { name: 'spender', type: 'address' }, { name: 'amount', type: 'uint256' }
    ], outputs: [{ type: 'bool' }], stateMutability: 'nonpayable' },
    { type: 'function', name: 'transfer', inputs: [
      { name: 'to', type: 'address' }, { name: 'amount', type: 'uint256' }
    ], outputs: [{ type: 'bool' }], stateMutability: 'nonpayable' }
  ] as const)

  const approveHash = yield* contract.write.approve(spender, amount)
  const transferHash = yield* contract.write.transfer(recipient, amount)
  
  return { approveHash, transferHash }
}).pipe(
  Effect.provide(Signer.Live),
  Effect.provide(LocalAccount(privateKey)),
  Effect.provide(Provider),
  Effect.provide(HttpTransport('https://eth.llamarpc.com')),
  Effect.provide(Secp256k1Live),
  Effect.provide(KeccakLive)
)
```

## Wait For Transaction With Timeout

```typescript
import { Effect } from 'effect'
import { waitForTransactionReceipt, Provider, HttpTransport, withTimeout } from 'voltaire-effect'

const waitForTx = (txHash: string, confirmations = 1, timeout = "120 seconds") =>
  Effect.gen(function* () {
    return yield* waitForTransactionReceipt(txHash, { confirmations })
  }).pipe(
    withTimeout(timeout),
    Effect.catchTag('TimeoutException', () =>
      Effect.fail(new Error(`Transaction ${txHash} not confirmed`))
    ),
    Effect.provide(Provider),
    Effect.provide(HttpTransport('https://eth.llamarpc.com'))
  )
```

## Batch Multiple Balance Checks

```typescript
import { Effect } from 'effect'
import { multicall, Provider, HttpTransport } from 'voltaire-effect'

const erc20Abi = [
  { type: 'function', name: 'balanceOf', inputs: [{ name: 'account', type: 'address' }], 
    outputs: [{ type: 'uint256' }], stateMutability: 'view' }
] as const

const getBalances = (token: string, users: string[]) => Effect.gen(function* () {
  const results = yield* multicall({
    contracts: users.map(user => ({
      address: token,
      abi: erc20Abi,
      functionName: 'balanceOf',
      args: [user]
    })),
    allowFailure: false
  })
  return results as bigint[]
}).pipe(
  Effect.provide(Provider),
  Effect.provide(HttpTransport('https://eth.llamarpc.com'))
)
```

## Sign and Verify Message

```typescript
import { Effect } from 'effect'
import { Hex, Address } from '@tevm/voltaire'
import { Secp256k1Service, KeccakService, Secp256k1Live, KeccakLive } from 'voltaire-effect/crypto'

const signAndVerify = (message: string, privateKey: Uint8Array) => Effect.gen(function* () {
  const keccak = yield* KeccakService
  const secp = yield* Secp256k1Service

  // Hash the message with Ethereum prefix
  const prefix = `\x19Ethereum Signed Message:\n${message.length}`
  const prefixedMessage = new TextEncoder().encode(prefix + message)
  const messageHash = yield* keccak.hash(prefixedMessage)

  // Sign
  const signature = yield* secp.sign(messageHash, privateKey)

  // Recover signer
  const publicKey = yield* secp.recover(signature, messageHash)
  
  // Verify
  const isValid = yield* secp.verify(signature, messageHash, publicKey)

  return { signature, publicKey, isValid }
}).pipe(
  Effect.provide(Secp256k1Live),
  Effect.provide(KeccakLive)
)
```

## Derive Address From Private Key

```typescript
import { Effect } from 'effect'
import { Address } from '@tevm/voltaire'
import { Secp256k1Service, KeccakService, Secp256k1Live, KeccakLive } from 'voltaire-effect/crypto'

const getAddress = (privateKey: Uint8Array) => Effect.gen(function* () {
  const secp = yield* Secp256k1Service
  const keccak = yield* KeccakService

  const publicKey = yield* secp.getPublicKey(privateKey)
  const hash = yield* keccak.hash(publicKey.slice(1)) // Remove 0x04 prefix
  const addressBytes = hash.slice(-20)
  
  return Address.fromBytes(addressBytes)
}).pipe(
  Effect.provide(Secp256k1Live),
  Effect.provide(KeccakLive)
)
```

## Parse and Decode Transaction

```typescript
import { Effect } from 'effect'
import { Transaction, Rlp, Hex } from '@tevm/voltaire'

const decodeRawTx = (rawTx: string) => Effect.gen(function* () {
  const bytes = Hex.toBytes(Hex.fromHex(rawTx))
  const tx = Transaction.parse(bytes)
  
  return {
    type: tx.type,
    to: tx.to ? Address.toHex(tx.to) : null,
    value: tx.value,
    data: Hex.fromBytes(tx.data),
    nonce: tx.nonce,
    gasLimit: tx.gasLimit
  }
})
```

## Fallback RPC Provider

```typescript
import { Effect } from 'effect'
import { getBlockNumber, Provider, HttpTransport } from 'voltaire-effect'

const providers = [
  'https://eth.llamarpc.com',
  'https://cloudflare-eth.com',
  'https://rpc.ankr.com/eth'
]

const withFallback = <A>(operation: Effect.Effect<A, any, any>) =>
  providers.reduce(
    (acc, url, i) => i === 0
      ? operation.pipe(
          Effect.provide(Provider),
          Effect.provide(HttpTransport(url))
        )
      : acc.pipe(
          Effect.orElse(() =>
            operation.pipe(
              Effect.provide(Provider),
              Effect.provide(HttpTransport(url))
            )
          )
        ),
    Effect.fail(new Error('All providers failed')) as Effect.Effect<A, any, any>
  )

// Usage
const blockNum = await Effect.runPromise(
  withFallback(getBlockNumber())
)
```

<Note>
Production note: the `Effect.Effect<A, any, any>` cast erases error typing. Prefer a typed error union when you want compile-time guarantees.
</Note>

## Retry With Exponential Backoff

```typescript
import { Effect, Schedule } from 'effect'
import { getBalance, withRetrySchedule } from 'voltaire-effect'

// Per-request retry schedule
const withExponentialRetry = withRetrySchedule(
  Schedule.exponential('500 millis').pipe(
    Schedule.jittered,
    Schedule.compose(Schedule.recurs(5))
  )
)

// Usage
getBalance(addr).pipe(withExponentialRetry)
```

## Stream Recent Blocks

```typescript
import { Effect, Stream } from 'effect'
import { makeBlockStream, HttpTransport } from 'voltaire-effect/services'

const streamBlocks = (count: number) => Effect.gen(function* () {
  const blockStream = yield* makeBlockStream()
  
  const blocks = yield* Stream.runCollect(
    blockStream.watch({ include: 'header' }).pipe(
      Stream.take(count)
    )
  )
  
  return blocks.toArray()
}).pipe(
  Effect.provide(HttpTransport('https://eth.llamarpc.com'))
)
```

## Estimate Gas With Buffer

```typescript
import { Effect } from 'effect'
import { estimateGas, Provider, HttpTransport } from 'voltaire-effect'

const estimateWithBuffer = (tx: { to: string; data: string; value?: bigint }, buffer = 1.2) =>
  Effect.gen(function* () {
    const estimate = yield* estimateGas(tx)
    return BigInt(Math.ceil(Number(estimate) * buffer))
  }).pipe(
    Effect.provide(Provider),
    Effect.provide(HttpTransport('https://eth.llamarpc.com'))
  )
```

<Note>
Production note: `Number(estimate)` is fine for small gas limits; use bigint-safe math if you need exactness.
</Note>

## See Also

- [Examples](/examples/index) — Detailed tutorials with explanations
- [Cheatsheet](/cheatsheet) — Quick reference patterns
- [Troubleshooting](/troubleshooting) — Common issues and solutions
- [Provider Service](/services/provider) — All provider methods
- [Signer Service](/services/signer) — Transaction signing
- [Multicall](/services/multicall) — Batch RPC calls
- [ERC Standards](/standards) — Token standard utilities
- [Effect Documentation](https://effect.website/docs/getting-started/introduction/) — Official Effect.ts docs

## Check NFT Ownership

```typescript
import { Effect } from 'effect'
import { Contract, Provider, HttpTransport } from 'voltaire-effect'

const erc721Abi = [
  { type: 'function', name: 'ownerOf', inputs: [{ name: 'tokenId', type: 'uint256' }], 
    outputs: [{ type: 'address' }], stateMutability: 'view' }
] as const

const isOwner = (nft: string, tokenId: bigint, address: string) => Effect.gen(function* () {
  const contract = yield* Contract(nft, erc721Abi)
  const owner = yield* contract.read.ownerOf(tokenId)
  return owner.toLowerCase() === address.toLowerCase()
}).pipe(
  Effect.catchTag('ContractCallError', () => Effect.succeed(false)),
  Effect.provide(Provider),
  Effect.provide(HttpTransport('https://eth.llamarpc.com'))
)
```
