---
title: Recipes
description: Copy-paste solutions for common Ethereum tasks
---

## Check If Address Is Contract

```typescript
import { Effect } from 'effect'
import { ProviderService, Provider, HttpTransport } from 'voltaire-effect/services'

const isContract = (address: string) => Effect.gen(function* () {
  const provider = yield* ProviderService
  const code = yield* provider.getCode(address, 'latest')
  return code !== '0x' && code.length > 2
}).pipe(
  Effect.provide(Provider),
  Effect.provide(HttpTransport('https://eth.llamarpc.com'))
)
```

## Get Token Balance (ERC-20)

```typescript
import { Effect } from 'effect'
import { Contract, Provider, HttpTransport } from 'voltaire-effect/services'

const erc20Abi = [
  { type: 'function', name: 'balanceOf', inputs: [{ name: 'account', type: 'address' }], 
    outputs: [{ type: 'uint256' }], stateMutability: 'view' },
  { type: 'function', name: 'decimals', inputs: [], 
    outputs: [{ type: 'uint8' }], stateMutability: 'view' }
] as const

const getTokenBalance = (token: string, user: string) => Effect.gen(function* () {
  const contract = yield* Contract(token, erc20Abi)
  const [balance, decimals] = yield* Effect.all([
    contract.read.balanceOf(user),
    contract.read.decimals()
  ])
  return { raw: balance, formatted: Number(balance) / 10 ** decimals }
}).pipe(
  Effect.provide(Provider),
  Effect.provide(HttpTransport('https://eth.llamarpc.com'))
)
```

## Approve and Transfer ERC-20

```typescript
import { Effect } from 'effect'
import { Contract, Signer, LocalAccount, Provider, HttpTransport } from 'voltaire-effect/services'
import { Secp256k1Live, KeccakLive } from 'voltaire-effect/crypto'

const approveAndTransfer = (
  token: string, 
  spender: string, 
  recipient: string, 
  amount: bigint, 
  privateKey: Uint8Array
) => Effect.gen(function* () {
  const contract = yield* Contract(token, [
    { type: 'function', name: 'approve', inputs: [
      { name: 'spender', type: 'address' }, { name: 'amount', type: 'uint256' }
    ], outputs: [{ type: 'bool' }], stateMutability: 'nonpayable' },
    { type: 'function', name: 'transfer', inputs: [
      { name: 'to', type: 'address' }, { name: 'amount', type: 'uint256' }
    ], outputs: [{ type: 'bool' }], stateMutability: 'nonpayable' }
  ] as const)

  const approveHash = yield* contract.write.approve(spender, amount)
  const transferHash = yield* contract.write.transfer(recipient, amount)
  
  return { approveHash, transferHash }
}).pipe(
  Effect.provide(Signer.Live),
  Effect.provide(LocalAccount(privateKey)),
  Effect.provide(Provider),
  Effect.provide(HttpTransport('https://eth.llamarpc.com')),
  Effect.provide(Secp256k1Live),
  Effect.provide(KeccakLive)
)
```

## Wait For Transaction With Timeout

```typescript
import { Effect, Duration } from 'effect'
import { ProviderService, Provider, HttpTransport } from 'voltaire-effect/services'

const waitForTx = (txHash: string, confirmations = 1, timeoutSec = 120) => 
  Effect.gen(function* () {
    const provider = yield* ProviderService
    return yield* provider.waitForTransactionReceipt(txHash, { 
      confirmations, 
      timeout: timeoutSec * 1000 
    })
  }).pipe(
    Effect.timeout(Duration.seconds(timeoutSec)),
    Effect.catchTag('TimeoutException', () => 
      Effect.fail(new Error(`Transaction ${txHash} not confirmed in ${timeoutSec}s`))
    ),
    Effect.provide(Provider),
    Effect.provide(HttpTransport('https://eth.llamarpc.com'))
  )
```

## Batch Multiple Balance Checks

```typescript
import { Effect } from 'effect'
import { multicall, Provider, HttpTransport } from 'voltaire-effect/services'

const erc20Abi = [
  { type: 'function', name: 'balanceOf', inputs: [{ name: 'account', type: 'address' }], 
    outputs: [{ type: 'uint256' }], stateMutability: 'view' }
] as const

const getBalances = (token: string, users: string[]) => Effect.gen(function* () {
  const results = yield* multicall({
    contracts: users.map(user => ({
      address: token,
      abi: erc20Abi,
      functionName: 'balanceOf',
      args: [user]
    })),
    allowFailure: false
  })
  return results as bigint[]
}).pipe(
  Effect.provide(Provider),
  Effect.provide(HttpTransport('https://eth.llamarpc.com'))
)
```

## Sign and Verify Message

```typescript
import { Effect } from 'effect'
import { Hex, Address } from '@tevm/voltaire'
import { Secp256k1Service, KeccakService, Secp256k1Live, KeccakLive } from 'voltaire-effect/crypto'

const signAndVerify = (message: string, privateKey: Uint8Array) => Effect.gen(function* () {
  const keccak = yield* KeccakService
  const secp = yield* Secp256k1Service

  // Hash the message with Ethereum prefix
  const prefix = `\x19Ethereum Signed Message:\n${message.length}`
  const prefixedMessage = new TextEncoder().encode(prefix + message)
  const messageHash = yield* keccak.hash(prefixedMessage)

  // Sign
  const signature = yield* secp.sign(messageHash, privateKey)

  // Recover signer
  const publicKey = yield* secp.recover(signature, messageHash)
  
  // Verify
  const isValid = yield* secp.verify(signature, messageHash, publicKey)

  return { signature, publicKey, isValid }
}).pipe(
  Effect.provide(Secp256k1Live),
  Effect.provide(KeccakLive)
)
```

## Derive Address From Private Key

```typescript
import { Effect } from 'effect'
import { Address } from '@tevm/voltaire'
import { Secp256k1Service, KeccakService, Secp256k1Live, KeccakLive } from 'voltaire-effect/crypto'

const getAddress = (privateKey: Uint8Array) => Effect.gen(function* () {
  const secp = yield* Secp256k1Service
  const keccak = yield* KeccakService

  const publicKey = yield* secp.getPublicKey(privateKey)
  const hash = yield* keccak.hash(publicKey.slice(1)) // Remove 0x04 prefix
  const addressBytes = hash.slice(-20)
  
  return Address.fromBytes(addressBytes)
}).pipe(
  Effect.provide(Secp256k1Live),
  Effect.provide(KeccakLive)
)
```

## Parse and Decode Transaction

```typescript
import { Effect } from 'effect'
import { Transaction, Rlp, Hex } from '@tevm/voltaire'

const decodeRawTx = (rawTx: string) => Effect.gen(function* () {
  const bytes = Hex.toBytes(Hex.fromHex(rawTx))
  const tx = Transaction.parse(bytes)
  
  return {
    type: tx.type,
    to: tx.to ? Address.toHex(tx.to) : null,
    value: tx.value,
    data: Hex.fromBytes(tx.data),
    nonce: tx.nonce,
    gasLimit: tx.gasLimit
  }
})
```

## Fallback RPC Provider

```typescript
import { Effect } from 'effect'
import { ProviderService, Provider, HttpTransport } from 'voltaire-effect/services'

const providers = [
  'https://eth.llamarpc.com',
  'https://cloudflare-eth.com',
  'https://rpc.ankr.com/eth'
]

const withFallback = <A>(operation: (p: typeof ProviderService.Type) => Effect.Effect<A, any, any>) =>
  providers.reduce(
    (acc, url, i) => i === 0 
      ? Effect.gen(function* () {
          const provider = yield* ProviderService
          return yield* operation(provider)
        }).pipe(
          Effect.provide(Provider),
          Effect.provide(HttpTransport(url))
        )
      : acc.pipe(
          Effect.orElse(() => 
            Effect.gen(function* () {
              const provider = yield* ProviderService
              return yield* operation(provider)
            }).pipe(
              Effect.provide(Provider),
              Effect.provide(HttpTransport(url))
            )
          )
        ),
    Effect.fail(new Error('All providers failed')) as Effect.Effect<A, any, any>
  )

// Usage
const blockNum = await Effect.runPromise(
  withFallback(p => p.getBlockNumber())
)
```

## Retry With Exponential Backoff

```typescript
import { Effect, Schedule } from 'effect'

const retryConfig = Schedule.exponential('100 millis').pipe(
  Schedule.compose(Schedule.recurs(5)),
  Schedule.jittered
)

const robustCall = <A, E, R>(effect: Effect.Effect<A, E, R>) =>
  effect.pipe(
    Effect.retry(retryConfig),
    Effect.catchAll(e => Effect.fail(new Error(`Failed after retries: ${e}`)))
  )
```

## Stream Recent Blocks

```typescript
import { Effect, Stream } from 'effect'
import { BlockStreamService, BlockStream, HttpTransport } from 'voltaire-effect/services'

const streamBlocks = (count: number) => Effect.gen(function* () {
  const blockStream = yield* BlockStreamService
  
  const blocks = yield* Stream.runCollect(
    blockStream.watch({ include: 'header' }).pipe(
      Stream.take(count)
    )
  )
  
  return blocks.toArray()
}).pipe(
  Effect.provide(BlockStream),
  Effect.provide(HttpTransport('https://eth.llamarpc.com'))
)
```

## Estimate Gas With Buffer

```typescript
import { Effect } from 'effect'
import { ProviderService, Provider, HttpTransport } from 'voltaire-effect/services'

const estimateWithBuffer = (tx: { to: string; data: string; value?: bigint }, buffer = 1.2) =>
  Effect.gen(function* () {
    const provider = yield* ProviderService
    const estimate = yield* provider.estimateGas(tx)
    return BigInt(Math.ceil(Number(estimate) * buffer))
  }).pipe(
    Effect.provide(Provider),
    Effect.provide(HttpTransport('https://eth.llamarpc.com'))
  )
```

## Check NFT Ownership

```typescript
import { Effect } from 'effect'
import { Contract, Provider, HttpTransport } from 'voltaire-effect/services'

const erc721Abi = [
  { type: 'function', name: 'ownerOf', inputs: [{ name: 'tokenId', type: 'uint256' }], 
    outputs: [{ type: 'address' }], stateMutability: 'view' }
] as const

const isOwner = (nft: string, tokenId: bigint, address: string) => Effect.gen(function* () {
  const contract = yield* Contract(nft, erc721Abi)
  const owner = yield* contract.read.ownerOf(tokenId)
  return owner.toLowerCase() === address.toLowerCase()
}).pipe(
  Effect.catchTag('ContractCallError', () => Effect.succeed(false)),
  Effect.provide(Provider),
  Effect.provide(HttpTransport('https://eth.llamarpc.com'))
)
```
