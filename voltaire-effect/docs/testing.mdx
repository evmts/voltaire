---
title: Testing
description: Mock services and test Effect programs
---

[Effect's service model](https://effect.website/docs/requirements-management/services/) makes testing straightforward. Swap production layers for test layers.

<Tip>
See the [Effect Testing Guide](https://effect.website/docs/guides/testing/) for comprehensive testing patterns.
</Tip>

## Testing Schema Validation

Schema decode is pure. Test directly:

```typescript
import * as S from 'effect/Schema'
import * as Address from 'voltaire-effect/primitives/Address'
import { describe, it, expect } from 'vitest'

describe('Address schema', () => {
  it('decodes valid hex', () => {
    const addr = S.decodeSync(Address.Hex)(
      '0x742d35Cc6634C0532925a3b844Bc9e7595f251e3'
    )
    expect(addr.length).toBe(20)
  })

  it('rejects invalid hex', () => {
    expect(() => S.decodeSync(Address.Hex)('invalid')).toThrow()
  })
})
```

## Testing with Either

Use `decodeEither` to test error cases without throwing:

```typescript
import * as S from 'effect/Schema'
import * as Either from 'effect/Either'

it('returns Left for invalid input', () => {
  const result = S.decodeEither(Address.Hex)('0x123')
  expect(Either.isLeft(result)).toBe(true)
})
```

## Mocking Services

Create test layers that return controlled values:

```typescript
import * as Effect from 'effect/Effect'
import * as Layer from 'effect/Layer'
import { ProviderService } from 'voltaire-effect'

const ProviderTest = Layer.succeed(ProviderService, {
  getBlock: (tag) => Effect.succeed({
    number: 12345n,
    hash: '0x...',
    transactions: []
  }),
  getBalance: (addr) => Effect.succeed(1000000000000000000n),
  getTransactionCount: (addr) => Effect.succeed(5n)
})
```

Use in tests:

```typescript
import * as Effect from 'effect/Effect'

it('fetches balance', async () => {
  const program = Effect.gen(function* () {
    const provider = yield* ProviderService
    return yield* provider.getBalance(testAddress)
  })

  const result = await Effect.runPromise(
    program.pipe(Effect.provide(ProviderTest))
  )

  expect(result).toBe(1000000000000000000n)
})
```

## Testing Error Paths

Mock services that fail:

```typescript
import { TransportError } from 'voltaire-effect'

const ProviderFailing = Layer.succeed(ProviderService, {
  getBlock: () =>
    Effect.fail(new TransportError({ code: -32000, message: "timeout" })),
  getBalance: () =>
    Effect.fail(new TransportError({ code: -32000, message: "timeout" }))
})

it('handles provider errors', async () => {
  const program = Effect.gen(function* () {
    const provider = yield* ProviderService
    return yield* provider.getBalance(testAddress)
  }).pipe(
    Effect.catchTag("TransportError", () => Effect.succeed(0n))
  )

  const result = await Effect.runPromise(
    program.pipe(Effect.provide(ProviderFailing))
  )

  expect(result).toBe(0n)
})
```

## Testing Crypto

Mock crypto services for deterministic tests:

```typescript
import * as Layer from 'effect/Layer'
import { KeccakService } from 'voltaire-effect/crypto/Keccak256'

const KeccakTest = Layer.succeed(KeccakService, {
  hash: (data) => Effect.succeed(new Uint8Array(32).fill(0xab))
})

it('uses keccak service', async () => {
  const program = Effect.gen(function* () {
    const keccak = yield* KeccakService
    return yield* keccak.hash(new Uint8Array([1, 2, 3]))
  })

  const result = await Effect.runPromise(
    program.pipe(Effect.provide(KeccakTest))
  )

  expect(result[0]).toBe(0xab)
})
```

## CryptoLive and CryptoTest

Use `CryptoLive` for production and `CryptoTest` for deterministic unit tests:

```typescript
import { CryptoLive, CryptoTest } from 'voltaire-effect'
import { KeccakService, Secp256k1Service } from 'voltaire-effect/crypto'

// CryptoLive bundles: Keccak256, Secp256k1, SHA256, Blake2, Ripemd160, 
// BLS12-381, Ed25519, P256, KZG, HDWallet, BN254, BIP-39, HMAC, EIP-712,
// ChaCha20Poly1305, Keystore

const program = Effect.gen(function* () {
  const keccak = yield* KeccakService
  const secp = yield* Secp256k1Service
  // All crypto services available
})

// Production
await Effect.runPromise(program.pipe(Effect.provide(CryptoLive)))

// Testing (deterministic outputs)
await Effect.runPromise(program.pipe(Effect.provide(CryptoTest)))
```

## Composing Test Layers

Combine multiple test layers:

```typescript
import * as Layer from 'effect/Layer'

const TestLayer = Layer.mergeAll(
  ProviderTest,
  KeccakTest,
  Secp256k1Test
)

const result = await Effect.runPromise(
  program.pipe(Effect.provide(TestLayer))
)
```

## Integration Tests

Use live layers for integration tests:

```typescript
import * as Layer from 'effect/Layer'
import { HttpTransport, Provider, ProviderService } from 'voltaire-effect'
import { KeccakLive } from 'voltaire-effect/crypto/Keccak256'

const IntegrationLayer = Layer.mergeAll(
  Provider.pipe(Layer.provide(HttpTransport('https://eth.llamarpc.com'))),
  KeccakLive
)

it('fetches real block', async () => {
  const program = Effect.gen(function* () {
    const provider = yield* ProviderService
    return yield* provider.getBlock('latest')
  })

  const block = await Effect.runPromise(
    program.pipe(Effect.provide(IntegrationLayer))
  )

  expect(block.number).toBeGreaterThan(0n)
})
```

## See Also

- [Effect Testing](https://effect.website/docs/guides/testing/) — Official Effect testing guide
- [Dependency Injection](/concepts/dependency-injection) — How services work
- [Layers](/layers) — Layer composition patterns
- [Crypto](/crypto/index) — CryptoLive and CryptoTest layers
- [Debugging](/guides/debugging) — Debug Effect programs
- [Troubleshooting](/troubleshooting) — Common issues and solutions
