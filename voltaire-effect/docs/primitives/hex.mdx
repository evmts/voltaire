---
title: Hex
description: Effect-based schemas for Ethereum hex string handling
---

Hex strings are ubiquitous in Ethereum—addresses, transaction data, storage slots, and more. This module provides validation, conversion, and manipulation.

```typescript
import * as Hex from 'voltaire-effect/primitives/Hex'
import * as S from 'effect/Schema'

const hex = S.decodeSync(Hex.String)('0xdeadbeef')
```

## Schemas

### Hex.String

Validates hex strings with or without `0x` prefix. Returns branded `HexType`.

```typescript
import * as Hex from 'voltaire-effect/primitives/Hex'
import * as S from 'effect/Schema'

S.decodeSync(Hex.String)('0xdeadbeef')  // ✓
S.decodeSync(Hex.String)('deadbeef')    // ✓ (adds 0x)
S.decodeSync(Hex.String)('0xDEADBEEF')  // ✓ (case-insensitive)
S.decodeSync(Hex.String)('not-hex')     // ✗ ParseError
```

### Hex.Bytes

Validates and converts to/from `Uint8Array`:

```typescript
const bytes = S.decodeSync(Hex.Bytes)(new Uint8Array([0xde, 0xad]))
const hex = S.encodeSync(Hex.Bytes)(bytes)  // "0xdead"
```

## Constructors

### from

Creates hex from string, bytes, or number:

```typescript
import * as Hex from 'voltaire-effect/primitives/Hex'

Hex.from('0xdeadbeef')              // "0xdeadbeef"
Hex.from('deadbeef')                // "0xdeadbeef"
Hex.from(new Uint8Array([1, 2, 3])) // "0x010203"
```

### fromBytes

Infallible. Creates hex from bytes:

```typescript
const hex = Hex.fromBytes(new Uint8Array([0xde, 0xad, 0xbe, 0xef]))
// "0xdeadbeef"
```

### fromString

Creates hex from UTF-8 string:

```typescript
const hex = Hex.fromString('hello')
// "0x68656c6c6f"
```

### fromHex

Parse existing hex string:

```typescript
const hex = Hex.fromHex('0xdeadbeef')
```

### fromNumber

Convert number to hex:

```typescript
Hex.fromNumber(255)      // "0xff"
Hex.fromNumber(256)      // "0x100"
Hex.fromNumber(0)        // "0x0"
```

### fromBigInt

Convert bigint to hex:

```typescript
Hex.fromBigInt(1000000000000000000n)  // "0xde0b6b3a7640000"
```

## Conversion

### toBytes

Convert hex to bytes:

```typescript
const bytes = Hex.toBytes(Hex.fromHex('0xdeadbeef'))
// Uint8Array(4) [222, 173, 190, 239]
```

### toString

Decode hex as UTF-8 string:

```typescript
const str = Hex.toString(Hex.fromHex('0x68656c6c6f'))
// "hello"
```

### toNumber

Convert hex to number:

```typescript
const num = Hex.toNumber(Hex.fromHex('0xff'))
// 255
```

### toBigInt

Convert hex to bigint:

```typescript
const big = Hex.toBigInt(Hex.fromHex('0xde0b6b3a7640000'))
// 1000000000000000000n
```

## Utilities

### size

Returns byte length:

```typescript
Hex.size('0xdeadbeef')  // 4
Hex.size('0x')          // 0
```

### slice

Extract portion of hex:

```typescript
Hex.slice(hex, 0, 4)   // First 4 bytes
Hex.slice(hex, 4)      // From byte 4 to end
```

### padLeft / padRight

Pad to specified byte length:

```typescript
Hex.padLeft('0xff', 32)   // "0x00000000...ff" (32 bytes)
Hex.padRight('0xff', 32)  // "0xff00000000..." (32 bytes)
```

### concat

Concatenate hex values:

```typescript
Hex.concat('0xdead', '0xbeef')  // "0xdeadbeef"
```

### isEqual

Compare hex values:

```typescript
Hex.isEqual('0xdead', '0xDEAD')  // true (case-insensitive)
```

## Common Patterns

### Encode Function Calldata

```typescript
import * as Hex from 'voltaire-effect/primitives/Hex'

// Combine selector + encoded args
const selector = '0xa9059cbb'  // transfer(address,uint256)
const encodedArgs = '0x000000000000000000000000...'
const calldata = Hex.concat(selector, encodedArgs)
```

### Parse RPC Response

```typescript
import * as Hex from 'voltaire-effect/primitives/Hex'

const rpcResult = '0x0000000000000000000000000000000000000000000000000de0b6b3a7640000'
const value = Hex.toBigInt(rpcResult)  // 1000000000000000000n (1 ETH)
```

### Zero-Pad Address

```typescript
const address = '0x742d35Cc6634C0532925a3b844Bc9e7595f251e3'
const padded = Hex.padLeft(address, 32)  // 32-byte ABI encoding
```

## Error Handling

Decode operations throw `InvalidFormatError` for invalid input:

```typescript
import { Effect } from 'effect'
import * as S from 'effect/Schema'

S.decode(Hex.String)('not-hex').pipe(
  Effect.catchTag('ParseError', (e) =>
    Effect.succeed('0x')  // Fallback
  )
)
```

## Types

```typescript
// Branded hex string type
type HexType = `0x${string}` & { readonly __brand: 'Hex' }
```

## See Also

- [Bytes](/primitives/bytes) — Raw byte arrays
- [Bytes32](/primitives/bytes32) — Fixed 32-byte values
- [Address](/primitives/address) — 20-byte addresses
- [Hash](/primitives/hash) — 32-byte hashes
- [Voltaire Hex](https://voltaire.tevm.sh/primitives/hex) — Core Hex documentation
- [Effect Schema](https://effect.website/docs/schema/introduction/) — Effect Schema validation
