---
title: Address
description: Effect-based schemas and functions for Ethereum addresses with EIP-55 checksum support
---

Ethereum addresses are 20-byte identifiers for accounts and contracts. This module provides [Effect Schema](https://effect.website/docs/schema/introduction/) validation and pure functions for address manipulation.

```typescript
import * as Address from 'voltaire-effect/primitives/Address'
import * as S from 'effect/Schema'

// Decode from hex string
const addr = S.decodeSync(Address.Hex)('0x742d35Cc6634C0532925a3b844Bc9e7595f251e3')

// Use pure functions directly
Address.isZero(addr)        // false
Address.isValid('0x...')    // true
```

## Schemas

### Address.Hex

Validates hex string, returns branded `AddressType` (Uint8Array).

```typescript
const addr = S.decodeSync(Address.Hex)(
  '0x742d35Cc6634C0532925a3b844Bc9e7595f251e3'
)

// Encode back to lowercase hex
const hex = S.encodeSync(Address.Hex)(addr)
// "0x742d35cc6634c0532925a3b844bc9e7595f251e3"
```

### Address.Bytes

Validates 20-byte Uint8Array.

```typescript
const addr = S.decodeSync(Address.Bytes)(new Uint8Array(20))
```

### Address.Checksummed

Encodes to [EIP-55](https://eips.ethereum.org/EIPS/eip-55) checksummed format. Requires `KeccakService`.

```typescript
import * as Effect from 'effect/Effect'
import { KeccakLive } from 'voltaire-effect/crypto/Keccak256'

const checksummed = await Effect.runPromise(
  S.encode(Address.Checksummed)(addr).pipe(Effect.provide(KeccakLive))
)
// "0x742d35Cc6634C0532925a3b844Bc9e7595f251e3"
```

## Pure Functions

All functions work directly on `AddressType` values.

### Comparison

```typescript
// Check equality
Address.equals(addr1, addr2)      // boolean

// Compare for ordering (-1, 0, 1)
Address.compare(addr1, addr2)     // -1 | 0 | 1

// Ordering predicates
Address.lessThan(addr1, addr2)    // boolean
Address.greaterThan(addr1, addr2) // boolean
```

### Validation

```typescript
// Check if a value is a valid address (any format)
Address.isValid('0x742d35Cc6634C0532925a3b844Bc9e7595f251e3')  // true
Address.isValid('0x123')  // false (wrong length)

// Check if checksummed string has valid checksum
Address.isValidChecksum('0x742d35Cc6634C0532925a3b844Bc9e7595f251e3')  // true
Address.isValidChecksum('0x742d35cc6634c0532925a3b844bc9e7595f251e3')  // false

// Check if address is zero address
Address.isZero(addr)  // boolean
```

### Conversion

```typescript
// Clone address (new Uint8Array)
const copy = Address.clone(addr)

// Get raw bytes
const bytes = Address.toBytes(addr)  // Uint8Array

// Convert to U256 (bigint)
const num = Address.toU256(addr)  // bigint

// Hex string formats
Address.toLowercase(addr)  // "0x742d35cc6634c0532925a3b844bc9e7595f251e3"
Address.toUppercase(addr)  // "0x742D35CC6634C0532925A3B844BC9E7595F251E3"
Address.toShortHex(addr)   // "0x742d...51e3" (truncated for display)

// ABI encoding (32 bytes, left-padded with zeros)
const abiEncoded = Address.toAbiEncoded(addr)  // Uint8Array(32)
```

## Usage Examples

### Parse and Validate User Input

```typescript
import * as Address from 'voltaire-effect/primitives/Address'
import * as S from 'effect/Schema'
import * as Effect from 'effect/Effect'

const parseAddress = (input: string) =>
  S.decode(Address.Hex)(input).pipe(
    Effect.catchTag('ParseError', () =>
      Effect.fail(new Error('Invalid Ethereum address'))
    )
  )
```

### Compare Addresses in Sorting

```typescript
const addresses = [addr1, addr2, addr3]
const sorted = addresses.toSorted(Address.compare)
```

### Check for Zero Address

```typescript
const transfer = (to: AddressType, amount: bigint) =>
  Effect.gen(function* () {
    if (Address.isZero(to)) {
      return yield* Effect.fail(new Error('Cannot transfer to zero address'))
    }
    // ... proceed with transfer
  })
```

### Display Truncated Address

```typescript
// For UI display
const display = Address.toShortHex(addr)  // "0x742d...51e3"
```

## Type Declaration

```typescript
import type { AddressType } from 'voltaire-effect/primitives/Address'

function transfer(to: AddressType, amount: bigint) {
  // Type-safe address handling
}
```

## Errors

- `ParseError` — Invalid format, hex, or byte length during Schema decode

## See Also

- [PublicKey](/primitives/publickey) — Derive address from public key
- [PrivateKey](/primitives/privatekey) — Generate addresses from private keys
- [ENS](/primitives/ens) — Resolve ENS names to addresses
- [Brand](/primitives/brand) — Nominal address string type
- [Keccak256](/crypto/keccak256) — Hash function for checksumming
- [Voltaire Address](https://voltaire.tevm.sh/primitives/address) — Core Address documentation
- [EIP-55](https://eips.ethereum.org/EIPS/eip-55) — Mixed-case checksum address encoding
