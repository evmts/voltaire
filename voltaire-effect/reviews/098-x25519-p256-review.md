# Review 098: X25519 and P256 Crypto Modules

**Date**: 2026-01-25  
**Reviewer**: Claude AI  
**Status**: ‚ö†Ô∏è Issues Found

## Summary

Deep review of X25519 key exchange and P256 signing modules in voltaire-effect.

---

## 1. Key Generation: Proper Randomness ‚úÖ

### X25519
- **Source**: [`generateSecretKey.js`](file:///Users/williamcory/voltaire/src/crypto/X25519/generateSecretKey.js#L20-L21)
- Uses `crypto.getRandomValues()` correctly
- Proper 32-byte key generation

### P256
- **Source**: [`randomPrivateKey.js`](file:///Users/williamcory/voltaire/src/crypto/P256/randomPrivateKey.js#L18-L52)
- Uses `crypto.getRandomValues()` with validation loop
- Validates key is in range `1 <= key < CURVE_ORDER`
- Throws if crypto unavailable (good)

---

## 2. Key Exchange: X25519 ECDH Correctness ‚úÖ

- **Implementation**: [`computeSecret.ts`](file:///Users/williamcory/voltaire/voltaire-effect/src/crypto/X25519/computeSecret.ts)
- Delegates to `X25519.scalarmult()` from voltaire
- Tests verify ECDH property: `computeSecret(alice.secret, bob.public) === computeSecret(bob.secret, alice.public)`
- Error types properly defined for invalid keys

---

## 3. Signing: P256 ECDSA Correctness ‚úÖ

- **Sign**: [`sign.ts`](file:///Users/williamcory/voltaire/voltaire-effect/src/crypto/P256/sign.ts)
- **Verify**: [`verify.ts`](file:///Users/williamcory/voltaire/voltaire-effect/src/crypto/P256/verify.ts)
- Tests verify:
  - Deterministic signatures (RFC 6979)
  - Sign/verify round-trip
  - Wrong hash returns false
  - Wrong public key returns false

---

## 4. Service Patterns: Live vs Test Layers ‚ö†Ô∏è

### X25519 ‚úÖ
| Layer | File | Status |
|-------|------|--------|
| `X25519Live` | [`X25519Live.ts`](file:///Users/williamcory/voltaire/voltaire-effect/src/crypto/X25519/X25519Live.ts) | ‚úÖ Exists |
| `X25519Test` | [`X25519Test.ts`](file:///Users/williamcory/voltaire/voltaire-effect/src/crypto/X25519/X25519Test.ts) | ‚úÖ Exists |

### P256 ‚ùå Missing Test Layer
| Layer | File | Status |
|-------|------|--------|
| `P256Live` | [`P256Live.ts`](file:///Users/williamcory/voltaire/voltaire-effect/src/crypto/P256/P256Live.ts) | ‚úÖ Exists |
| `P256Test` | N/A | ‚ùå **Missing** |

**Issue**: P256 has no test layer. Docs reference `P256Test` but it doesn't exist:
```typescript
// docs/crypto/p256.mdx references:
import { P256Test } from 'voltaire-effect/crypto'
```

---

## 5. Error Handling ‚úÖ

### X25519
- `InvalidSecretKeyError` - wrong key length
- `InvalidPublicKeyError` - wrong key length
- `X25519Error` - generic crypto failures
- Effect wrapping via `Effect.try()`

### P256
- `InvalidPrivateKeyError` - invalid key
- `InvalidPublicKeyError` - invalid public key  
- `P256Error` - signing failures
- Effect wrapping via `Effect.try()`

---

## 6. Test Coverage ‚ö†Ô∏è

### X25519 (200 lines) ‚úÖ Good
| Test | Coverage |
|------|----------|
| generateKeyPair | ‚úÖ Generates valid 32-byte keys |
| generateKeyPair uniqueness | ‚úÖ Different each call |
| getPublicKey | ‚úÖ Derives correctly |
| getPublicKey invalid | ‚úÖ Fails on wrong length |
| computeSecret | ‚úÖ ECDH property verified |
| computeSecret invalid secret | ‚úÖ Error on bad secret |
| computeSecret invalid public | ‚úÖ Error on bad public |
| X25519Service via Live | ‚úÖ All operations |
| X25519Test mock | ‚úÖ Returns zero-filled arrays |

### P256 (121 lines) ‚ö†Ô∏è Missing Edge Cases
| Test | Coverage |
|------|----------|
| sign | ‚úÖ Produces r,s signature |
| sign deterministic | ‚úÖ RFC 6979 verified |
| sign invalid key | ‚úÖ Fails on wrong length |
| verify valid | ‚úÖ Returns true |
| verify wrong hash | ‚úÖ Returns false |
| verify wrong pubkey | ‚úÖ Returns false |
| P256Service sign | ‚úÖ Works via layer |
| P256Service verify | ‚úÖ Works via layer |
| **P256Test mock** | ‚ùå **Missing** |
| **verify invalid pubkey format** | ‚ùå **Missing** |
| **sign with zero key** | ‚ùå **Missing** |

---

## 7. Branded Types for Keys ‚ùå

### X25519 - No Branded Types
```typescript
// SecretKey.ts
export type SecretKey = Uint8Array;  // No brand!

// PublicKey.ts  
export type PublicKey = Uint8Array;  // No brand!
```

**Issue**: Plain `Uint8Array` allows accidentally swapping secret/public keys.

### P256 - No Branded Types
```typescript
// P256PrivateKeyType.ts
export type P256PrivateKeyType = Uint8Array;  // No brand!

// P256PublicKeyType.ts
export type P256PublicKeyType = Uint8Array;  // No brand!
```

**Issue**: Same problem - types don't prevent key confusion.

### Signature Type ‚úÖ (Partial)
```typescript
// P256SignatureType.ts - Uses branded HashType for r,s
export type P256SignatureType = {
  r: HashType;  // Branded
  s: HashType;  // Branded
};
```

---

## Issues Summary

| # | Severity | Issue | Location |
|---|----------|-------|----------|
| 1 | üî¥ High | **P256Test layer missing** | `voltaire-effect/src/crypto/P256/` |
| 2 | üü° Medium | **X25519 no branded types** | `src/crypto/X25519/SecretKey.ts` |
| 3 | üü° Medium | **P256 no branded types** | `src/crypto/P256/P256PrivateKeyType.ts` |
| 4 | üü¢ Low | **P256 missing edge case tests** | `P256.test.ts` |

---

## Recommended Fixes

### 1. Add P256Test Layer (High Priority)

```typescript
// P256Test.ts
import * as Effect from "effect/Effect";
import * as Layer from "effect/Layer";
import { P256Service } from "./P256Service.js";

export const P256Test = Layer.succeed(P256Service, {
  sign: (_messageHash, _privateKey) =>
    Effect.succeed({
      r: new Uint8Array(32) as any,
      s: new Uint8Array(32) as any,
    }),
  verify: (_signature, _messageHash, _publicKey) =>
    Effect.succeed(true),
});
```

### 2. Add Branded Types (Medium Priority)

```typescript
// X25519 SecretKey.ts
export type SecretKey = Uint8Array & { readonly __tag: "X25519SecretKey" };

// X25519 PublicKey.ts
export type PublicKey = Uint8Array & { readonly __tag: "X25519PublicKey" };

// P256PrivateKeyType.ts
export type P256PrivateKeyType = Uint8Array & { readonly __tag: "P256PrivateKey" };

// P256PublicKeyType.ts
export type P256PublicKeyType = Uint8Array & { readonly __tag: "P256PublicKey" };
```

### 3. Add Missing P256 Edge Case Tests

```typescript
it("fails verify with malformed public key", async () => {
  const sig = await Effect.runPromise(P256Effect.sign(testMessageHash, testPrivateKey));
  const exit = await Effect.runPromiseExit(
    P256Effect.verify(sig, testMessageHash, new Uint8Array(16))
  );
  expect(Exit.isFailure(exit)).toBe(true);
});
```

---

## Code Quality

| Aspect | X25519 | P256 |
|--------|--------|------|
| JSDoc | ‚úÖ Excellent | ‚úÖ Excellent |
| Effect wrapping | ‚úÖ Correct | ‚úÖ Correct |
| Error types | ‚úÖ Typed | ‚úÖ Typed |
| Service pattern | ‚úÖ Complete | ‚ö†Ô∏è Missing Test |
| Module exports | ‚úÖ Clean | ‚úÖ Clean |

---

## Security Notes

1. ‚úÖ Both use `crypto.getRandomValues()` for CSPRNG
2. ‚úÖ P256 validates key is in valid range
3. ‚úÖ X25519 clamping done in underlying implementation
4. ‚ö†Ô∏è No explicit memory clearing of secret keys (see review 038)
5. ‚úÖ RFC 6979 deterministic signatures (P256)
