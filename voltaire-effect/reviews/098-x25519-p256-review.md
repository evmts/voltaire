# Review 098: X25519 and P256 Crypto Modules

<issue>
<metadata>
priority: P1
files: [
  "voltaire-effect/src/crypto/X25519/X25519Service.ts",
  "voltaire-effect/src/crypto/X25519/X25519Live.ts",
  "voltaire-effect/src/crypto/X25519/X25519Test.ts",
  "voltaire-effect/src/crypto/X25519/computeSecret.ts",
  "voltaire-effect/src/crypto/X25519/index.ts",
  "voltaire-effect/src/crypto/X25519/X25519.test.ts",
  "voltaire-effect/src/crypto/P256/P256Service.ts",
  "voltaire-effect/src/crypto/P256/P256Live.ts",
  "voltaire-effect/src/crypto/P256/sign.ts",
  "voltaire-effect/src/crypto/P256/verify.ts",
  "voltaire-effect/src/crypto/P256/index.ts",
  "voltaire-effect/src/crypto/P256/P256.test.ts",
  "src/crypto/X25519/generateSecretKey.js",
  "src/crypto/P256/randomPrivateKey.js"
]
reviews: ["045-fix-ed25519-missing-branded-types.md"]
</metadata>

<module_overview>
<purpose>
X25519 key exchange (ECDH) and P256 signing (ECDSA) modules with Effect service pattern. X25519 enables secure key agreement for encryption. P256 provides NIST-curve signatures for compatibility with traditional systems and WebAuthn.
</purpose>
<current_status>
**MOSTLY CORRECT** with key generation using proper CSPRNG. X25519 has complete Live/Test layer symmetry. P256 is **missing P256Test layer** and both modules lack **branded types** for key type safety.
</current_status>
</module_overview>

<findings>
<critical>
### 1. P256Test Layer Missing (P0)

**Location**: `voltaire-effect/src/crypto/P256/`

P256 has `P256Live` but no `P256Test` layer. Documentation references `P256Test` but it doesn't exist:

```typescript
// docs/crypto/p256.mdx references:
import { P256Test } from 'voltaire-effect/crypto'  // ❌ Doesn't exist!
```

**Impact**:
- Tests cannot mock P256 operations
- CryptoTest layer missing P256 (see issue 096)
- Doc examples are broken

</critical>
<high>
### 2. X25519 Keys Not Branded (P1)

**Location**: `src/crypto/X25519/SecretKey.ts`, `PublicKey.ts`

```typescript
// Current - plain Uint8Array allows key confusion
export type SecretKey = Uint8Array;
export type PublicKey = Uint8Array;

// Bug waiting to happen:
computeSecret(publicKey, secretKey)  // Swapped! No type error.
```

**Impact**: Accidentally swapping secret/public keys compiles but produces wrong results or security vulnerabilities.

### 3. P256 Keys Not Branded (P1)

**Location**: `src/crypto/P256/P256PrivateKeyType.ts`, `P256PublicKeyType.ts`

```typescript
// Current - same issue
export type P256PrivateKeyType = Uint8Array;
export type P256PublicKeyType = Uint8Array;
```

### 4. P256 Missing Edge Case Tests (P1)

**Location**: `P256.test.ts`

| Test | Coverage |
|------|----------|
| sign | ✅ Produces r,s signature |
| sign deterministic | ✅ RFC 6979 verified |
| sign invalid key | ✅ Fails on wrong length |
| verify valid | ✅ Returns true |
| verify wrong hash | ✅ Returns false |
| verify wrong pubkey | ✅ Returns false |
| **P256Test mock** | ❌ **Missing** |
| **verify invalid pubkey format** | ❌ **Missing** |
| **sign with zero key** | ❌ **Missing** |

</high>
<medium>
### 5. No Memory Clearing for Secret Keys (P2)

**Location**: Both X25519 and P256 modules

Related to review 038 - secret keys are not cleared from memory after use. While JavaScript makes this difficult, a `SecureKey` wrapper with explicit clear could help.

### 6. P256 Signature Not Branded (P2)

**Location**: `P256SignatureType.ts`

```typescript
// Current - partial branding
export type P256SignatureType = {
  r: HashType;  // Branded
  s: HashType;  // Branded
};
// But the object itself isn't branded
```

</medium>
</findings>

<effect_improvements>
### Create P256Test Layer

```typescript
// P256Test.ts
import * as Effect from "effect/Effect";
import * as Layer from "effect/Layer";
import { P256Service } from "./P256Service.js";
import type { P256SignatureType } from "./P256SignatureType.js";

export const P256Test = Layer.succeed(P256Service, {
  sign: (_messageHash, _privateKey) =>
    Effect.succeed({
      r: new Uint8Array(32) as any,
      s: new Uint8Array(32) as any,
    } as P256SignatureType),
  verify: (_signature, _messageHash, _publicKey) =>
    Effect.succeed(true),
  getPublicKey: (_privateKey) =>
    Effect.succeed(new Uint8Array(65) as any),
});
```

### Add Branded Types

```typescript
// X25519 SecretKey.ts
declare const secretKeyBrand: unique symbol;
export type SecretKey = Uint8Array & { readonly [secretKeyBrand]: "X25519SecretKey" };

// X25519 PublicKey.ts
declare const publicKeyBrand: unique symbol;
export type PublicKey = Uint8Array & { readonly [publicKeyBrand]: "X25519PublicKey" };

// P256PrivateKeyType.ts
declare const privateKeyBrand: unique symbol;
export type P256PrivateKeyType = Uint8Array & { readonly [privateKeyBrand]: "P256PrivateKey" };

// P256PublicKeyType.ts
declare const publicKeyBrand: unique symbol;
export type P256PublicKeyType = Uint8Array & { readonly [publicKeyBrand]: "P256PublicKey" };
```

### Add Key Validation Constructors

```typescript
// X25519 SecretKey.ts
export const from = (bytes: Uint8Array): SecretKey => {
  if (bytes.length !== 32) {
    throw new InvalidSecretKeyError(`Expected 32 bytes, got ${bytes.length}`);
  }
  return bytes as SecretKey;
};

// Effect-wrapped version
export const fromEffect = (bytes: Uint8Array): Effect.Effect<SecretKey, InvalidSecretKeyError> =>
  Effect.try({
    try: () => from(bytes),
    catch: (e) => e as InvalidSecretKeyError,
  });
```
</effect_improvements>

<viem_comparison>
**viem/ox Approach**:
- Uses branded types for secp256k1 keys
- `PrivateKey` and `PublicKey` are distinct types
- Validation at construction time

**@noble/curves Approach**:
- Pure functions without branding
- Relies on runtime validation
- No Effect integration

**voltaire-effect Advantage**:
- Effect service pattern for dependency injection
- Easy test mocking with *Test layers
- Can add branded types for compile-time safety

**Gap**: Missing branded types that viem has.
</viem_comparison>

<implementation>
<refactoring_steps>
1. **Create P256Test layer** - Mock implementation for testing
2. **Add P256Test to CryptoTest** - Complete the layer set
3. **Brand X25519 SecretKey type** - Add unique symbol brand
4. **Brand X25519 PublicKey type** - Add unique symbol brand
5. **Brand P256PrivateKeyType** - Add unique symbol brand
6. **Brand P256PublicKeyType** - Add unique symbol brand
7. **Add key validation constructors** - `from()` and `fromEffect()`
8. **Add missing P256 edge case tests** - Invalid pubkey, zero key
9. **Export P256Test from index** - Make available to consumers
</refactoring_steps>
<new_patterns>
```typescript
// Pattern: Branded key type with constructor
declare const brand: unique symbol;
export type SecretKey = Uint8Array & { readonly [brand]: "X25519SecretKey" };

export const SecretKey = {
  from: (bytes: Uint8Array): SecretKey => {
    if (bytes.length !== 32) throw new InvalidSecretKeyError();
    return bytes as SecretKey;
  },
  fromEffect: (bytes: Uint8Array): Effect.Effect<SecretKey, InvalidSecretKeyError> =>
    Effect.try({ try: () => SecretKey.from(bytes), catch: (e) => e as InvalidSecretKeyError }),
  generate: (): Effect.Effect<SecretKey, never, never> =>
    Effect.sync(() => {
      const bytes = new Uint8Array(32);
      crypto.getRandomValues(bytes);
      return bytes as SecretKey;
    }),
};

// Pattern: Compile-time prevention of key confusion
const computeSecret = (
  secretKey: SecretKey,   // Won't accept PublicKey
  publicKey: PublicKey,   // Won't accept SecretKey
): Effect.Effect<SharedSecret, ComputeSecretError> => { ... };
```
</new_patterns>
</implementation>

<tests>
<missing_coverage>
- P256Test mock behavior verification
- P256 verify with malformed public key (not just wrong length)
- P256 sign with zero private key (should fail)
- P256 verify with point-at-infinity public key
- X25519 computeSecret with low-order points
- Branded type construction validation
- Effect error types match expected
</missing_coverage>
<test_code>
```typescript
import { describe, expect, it } from "vitest";
import * as Effect from "effect/Effect";
import * as Exit from "effect/Exit";
import { P256Test, P256Service, sign, verify } from "./index.js";

describe("P256Test layer", () => {
  it("sign returns mock signature", async () => {
    const program = Effect.gen(function* () {
      const p256 = yield* P256Service;
      return yield* p256.sign(new Uint8Array(32), new Uint8Array(32));
    });
    const result = await Effect.runPromise(program.pipe(Effect.provide(P256Test)));
    expect(result.r.length).toBe(32);
    expect(result.s.length).toBe(32);
  });

  it("verify returns true by default", async () => {
    const program = Effect.gen(function* () {
      const p256 = yield* P256Service;
      const sig = { r: new Uint8Array(32), s: new Uint8Array(32) };
      return yield* p256.verify(sig as any, new Uint8Array(32), new Uint8Array(65));
    });
    const result = await Effect.runPromise(program.pipe(Effect.provide(P256Test)));
    expect(result).toBe(true);
  });
});

describe("P256 edge cases", () => {
  it("fails verify with malformed public key", async () => {
    const sig = await Effect.runPromise(
      sign(testMessageHash, testPrivateKey).pipe(Effect.provide(P256Live))
    );
    const exit = await Effect.runPromiseExit(
      verify(sig, testMessageHash, new Uint8Array(16)).pipe(Effect.provide(P256Live))
    );
    expect(Exit.isFailure(exit)).toBe(true);
  });

  it("fails sign with zero private key", async () => {
    const zeroKey = new Uint8Array(32);  // All zeros
    const exit = await Effect.runPromiseExit(
      sign(new Uint8Array(32), zeroKey).pipe(Effect.provide(P256Live))
    );
    expect(Exit.isFailure(exit)).toBe(true);
  });
});

describe("X25519 SecretKey branded type", () => {
  it("from validates length", () => {
    expect(() => SecretKey.from(new Uint8Array(16))).toThrow();
    expect(() => SecretKey.from(new Uint8Array(32))).not.toThrow();
  });

  it("fromEffect returns Effect with error type", async () => {
    const exit = await Effect.runPromiseExit(SecretKey.fromEffect(new Uint8Array(16)));
    expect(Exit.isFailure(exit)).toBe(true);
  });
});
```
</test_code>
</tests>

<docs>
- Document branded type usage for keys
- Add security notes about key handling
- Document P256Test vs P256Live usage
- Add WebAuthn integration example for P256
</docs>

<api>
<changes>
1. `P256Test` - New test layer export
2. `SecretKey` - Add branded type with `from()`, `fromEffect()`, `generate()`
3. `PublicKey` - Add branded type with `from()`, `fromEffect()`
4. `P256PrivateKeyType` - Add branded type
5. `P256PublicKeyType` - Add branded type
6. Update CryptoTest to include P256Test
</changes>
</api>

<references>
- [RFC 7748: Elliptic Curves for Security (X25519)](https://datatracker.ietf.org/doc/html/rfc7748)
- [RFC 6979: Deterministic ECDSA](https://datatracker.ietf.org/doc/html/rfc6979)
- [NIST P-256 Curve](https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.186-5.pdf)
- [WebAuthn and P-256](https://www.w3.org/TR/webauthn-2/)
- [X25519 implementation](file:///Users/williamcory/voltaire/voltaire-effect/src/crypto/X25519/computeSecret.ts)
- [P256 implementation](file:///Users/williamcory/voltaire/voltaire-effect/src/crypto/P256/sign.ts)
</references>
</issue>

## Code Quality Summary

| Aspect | X25519 | P256 |
|--------|--------|------|
| JSDoc | ✅ Excellent | ✅ Excellent |
| Effect wrapping | ✅ Correct | ✅ Correct |
| Error types | ✅ Typed | ✅ Typed |
| Service pattern | ✅ Complete | ⚠️ Missing Test |
| Branded types | ❌ Missing | ❌ Missing |
| Test coverage | ✅ Good | ⚠️ Gaps |
| Key generation | ✅ CSPRNG | ✅ CSPRNG with validation |

## Security Notes

1. ✅ Both use `crypto.getRandomValues()` for CSPRNG
2. ✅ P256 validates key is in valid range (1 <= key < CURVE_ORDER)
3. ✅ X25519 clamping done in underlying implementation
4. ⚠️ No explicit memory clearing of secret keys (see review 038)
5. ✅ RFC 6979 deterministic signatures (P256) - no nonce reuse risk
6. ⚠️ No low-order point check in X25519 (potential small-subgroup attack)
