/**
 * BN254 zkSNARK Verification Pattern
 *
 * This example demonstrates the structure of Groth16 zkSNARK verification
 * using BN254 pairings. Groth16 is the most widely used zkSNARK system in
 * Ethereum (used by Zcash, Tornado Cash, zkSync, etc.).
 *
 * Verification Equation:
 *   e(A, B) = e(alpha, beta) * e(sum_i(pub_i * L_i), gamma) * e(C, delta)
 *
 * Where:
 *   - (A, B, C) are the proof elements
 *   - (alpha, beta, gamma, delta) are verification key elements
 *   - L_i are verification key points for each public input
 *   - pub_i are the public inputs to the circuit
 *
 * This is computed as a pairing check:
 *   e(-A, B) * e(alpha, beta) * e(IC, gamma) * e(C, delta) = 1
 *
 * Where IC = vk.ic[0] + sum(pub[i] * vk.ic[i+1])
 */

import { BN254 } from "@tevm/voltaire";

const { G1, G2, Pairing, Fr } = BN254;

console.log("=== zkSNARK Verification Structure ===\n");

// Simulated verification key (in real use, this comes from trusted setup)
interface VerificationKey {
	alpha: ReturnType<typeof G1.generator>;
	beta: ReturnType<typeof G2.generator>;
	gamma: ReturnType<typeof G2.generator>;
	delta: ReturnType<typeof G2.generator>;
	ic: ReturnType<typeof G1.generator>[]; // One more than number of public inputs
}

// Simulated proof (in real use, this comes from the prover)
interface Proof {
	a: ReturnType<typeof G1.generator>;
	b: ReturnType<typeof G2.generator>;
	c: ReturnType<typeof G1.generator>;
}

// Create mock verification key
// In reality, these would be specific points from the trusted setup
const g1 = G1.generator();
const g2 = G2.generator();

const vk: VerificationKey = {
	alpha: G1.mul(g1, 123n), // alpha_G1
	beta: G2.mul(g2, 456n), // beta_G2
	gamma: G2.mul(g2, 789n), // gamma_G2
	delta: G2.mul(g2, 101n), // delta_G2
	ic: [
		G1.mul(g1, 111n), // ic[0] - constant term
		G1.mul(g1, 222n), // ic[1] - for pub[0]
		G1.mul(g1, 333n), // ic[2] - for pub[1]
	],
};

// Create mock proof
const proof: Proof = {
	a: G1.mul(g1, 777n),
	b: G2.mul(g2, 888n),
	c: G1.mul(g1, 999n),
};

// Public inputs (the values the verifier knows)
const publicInputs = [
	12345n, // First public input
	67890n, // Second public input
];

console.log("Verification Key Structure:");
console.log(
	"  alpha (G1): point at",
	G1.toAffine(vk.alpha).x.toString().slice(0, 20) + "...",
);
console.log("  beta (G2): defined");
console.log("  gamma (G2): defined");
console.log("  delta (G2): defined");
console.log("  ic: array of", vk.ic.length, "G1 points\n");

console.log("Proof Structure:");
console.log("  A (G1): point defined");
console.log("  B (G2): point defined");
console.log("  C (G1): point defined\n");

console.log("Public Inputs:", publicInputs, "\n");

// Step 1: Compute IC (linear combination of ic points with public inputs)
console.log("Step 1: Compute IC = ic[0] + sum(pub[i] * ic[i+1])");
let ic = vk.ic[0];
for (let i = 0; i < publicInputs.length; i++) {
	const scalar = Fr.mod(publicInputs[i]); // Reduce to scalar field
	const term = G1.mul(vk.ic[i + 1], scalar);
	ic = G1.add(ic, term);
}
console.log("  IC computed: G1 point defined\n");

// Step 2: Prepare pairing check inputs
console.log("Step 2: Prepare pairing pairs");
console.log("  Pair 1: (-A, B)");
console.log("  Pair 2: (alpha, beta)");
console.log("  Pair 3: (IC, gamma)");
console.log("  Pair 4: (C, delta)\n");

const negA = G1.negate(proof.a);
const pairs: Array<[typeof g1, typeof g2]> = [
	[negA, proof.b], // e(-A, B)
	[vk.alpha, vk.beta], // e(alpha, beta)
	[ic, vk.gamma], // e(IC, gamma)
	[proof.c, vk.delta], // e(C, delta)
];

// Step 3: Execute pairing check
console.log("Step 3: Execute pairing check");
console.log(
	"  Verifying: e(-A,B) * e(alpha,beta) * e(IC,gamma) * e(C,delta) = 1",
);
const isValid = Pairing.pairingCheck(pairs);
console.log("  Result:", isValid, "\n");

// Note about this example
console.log("Note:");
console.log("  This example uses mock data, so the proof does NOT verify.");
console.log("  In a real zkSNARK system:");
console.log("  1. The verification key comes from a trusted setup ceremony");
console.log("  2. The proof is generated by a prover with witness data");
console.log("  3. Valid proofs WILL pass the pairing check\n");

// Cost analysis
console.log("Ethereum Gas Costs (EIP-1108 prices):");
console.log("  bn256Add: 150 gas");
console.log("  bn256ScalarMul: 6,000 gas");
console.log("  bn256Pairing base: 45,000 gas");
console.log("  bn256Pairing per pair: 34,000 gas");
console.log("  4-pair verification: 45,000 + 4*34,000 = 181,000 gas");
