import {
	Bytes,
	Bytes1,
	Bytes4,
	Bytes8,
	Bytes16,
	Bytes32,
	Bytes64,
	Hex,
} from "@tevm/voltaire";

// === Generic Bytes ===
// Create from array
const bytes = Bytes([0x01, 0x02, 0x03, 0x04, 0x05]);

// Create zero bytes
const zeros = Bytes.zero(16);

// Random bytes
const random = Bytes.random(32);

// === Bytes1 (1 byte) ===
// Opcodes, flags, single values
const opcode = Bytes1.from([0x60]); // PUSH1

// === Bytes4 (4 bytes) ===
// Function selectors
const transferSelector = Bytes4.from([0xa9, 0x05, 0x9c, 0xbb]);

// From hex
const approveSelector = Bytes4.fromHex("0x095ea7b3");

// === Bytes8 (8 bytes) ===
// Timestamps, chain IDs
const timestamp = Bytes8.from([0x00, 0x00, 0x00, 0x00, 0x65, 0x9a, 0x12, 0x34]);

// === Bytes16 (16 bytes) ===
// UUIDs, compact identifiers
const uuid = Bytes16.random();

// === Bytes32 (32 bytes) ===
// Hashes, storage keys, private keys
const storageKey = Bytes32.from([
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
]);

// Zero hash
const zeroHash = Bytes32.zero();

// Random 32 bytes (like a private key)
const randomKey = Bytes32.random();

// === Bytes64 (64 bytes) ===
// Signatures (r + s), public keys
const signature = Bytes64.from([
	// r (32 bytes)
	0x12, 0x34, 0x56, 0x78, 0x90, 0xab, 0xcd, 0xef, 0x12, 0x34, 0x56, 0x78, 0x90,
	0xab, 0xcd, 0xef, 0x12, 0x34, 0x56, 0x78, 0x90, 0xab, 0xcd, 0xef, 0x12, 0x34,
	0x56, 0x78, 0x90, 0xab, 0xcd, 0xef,
	// s (32 bytes)
	0xfe, 0xdc, 0xba, 0x09, 0x87, 0x65, 0x43, 0x21, 0xfe, 0xdc, 0xba, 0x09, 0x87,
	0x65, 0x43, 0x21, 0xfe, 0xdc, 0xba, 0x09, 0x87, 0x65, 0x43, 0x21, 0xfe, 0xdc,
	0xba, 0x09, 0x87, 0x65, 0x43, 0x21,
]);

// === Operations ===
// Equality check
const a = Bytes32.from(new Array(32).fill(0x01));
const b = Bytes32.from(new Array(32).fill(0x01));

// Concatenation
const concat = Bytes.concat(transferSelector, storageKey);

// Slicing
const sliced = concat.slice(0, 4);
