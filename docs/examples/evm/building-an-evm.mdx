---
title: Building a Minimal EVM
description: Learn EVM internals by building a simple interpreter with Voltaire primitives
---

Build a minimal Ethereum Virtual Machine interpreter using Voltaire's primitives. This example implements ~30 core opcodes with gas metering, stack management, and control flow.

## What You'll Build

A functional EVM interpreter supporting:
- **Arithmetic**: ADD, MUL, SUB, DIV, MOD, LT, GT, EQ, ISZERO
- **Bitwise**: AND, OR, XOR, NOT
- **Stack**: PUSH1-32, POP, DUP1, SWAP1
- **Memory**: MLOAD, MSTORE, MSTORE8, MSIZE
- **Control**: STOP, JUMP, JUMPI, JUMPDEST, RETURN, REVERT
- **Environment**: PC, GAS, CODESIZE, CODECOPY

## EVM Architecture Overview

The EVM is a stack-based virtual machine with:

| Component | Description |
|-----------|-------------|
| **Stack** | LIFO storage for 256-bit values (max 1024 items) |
| **Memory** | Byte-addressable, dynamically expanding |
| **Gas** | Execution cost tracking |
| **PC** | Program counter pointing to current opcode |

## Implementation

### State Type

```typescript
import { Opcode } from "voltaire/primitives";
import * as Hex from "voltaire/primitives/Hex";
import * as Keccak256 from "voltaire/crypto/Keccak256";

type EvmState = {
  stack: bigint[];           // Max 1024 items
  memory: Map<number, number>; // Sparse byte storage
  memorySize: number;        // Current size (32-byte aligned)
  pc: number;                // Program counter
  gas: bigint;               // Remaining gas
  bytecode: Uint8Array;      // Raw bytecode
  stopped: boolean;          // Execution halted
  output: Uint8Array;        // Return data
  validJumpDests: Set<number>; // Precomputed JUMPDEST positions
};
```

### Creating State

Use Voltaire's `Opcode.jumpDests()` to precompute valid jump destinations:

```typescript
import { Opcode } from "voltaire/primitives";
import * as Keccak256 from "voltaire/crypto/Keccak256";

function createState(bytecode: Uint8Array, gas: bigint): EvmState {
  // Use Voltaire's jumpDests to find valid JUMPDEST positions
  const validJumpDests = Opcode.jumpDests(bytecode);

  // Hash bytecode for identification
  const codeHash = Keccak256.hash(bytecode);

  return {
    stack: [],
    memory: new Map(),
    memorySize: 0,
    pc: 0,
    gas,
    bytecode,
    stopped: false,
    output: new Uint8Array(0),
    validJumpDests,
  };
}
```

### Stack Operations

```typescript
const MAX_STACK_SIZE = 1024;
const UINT256_MAX = 2n ** 256n;

function stackPush(state: EvmState, value: bigint): void {
  if (state.stack.length >= MAX_STACK_SIZE) {
    throw new Error("Stack overflow");
  }
  // Modular arithmetic for uint256
  state.stack.push(((value % UINT256_MAX) + UINT256_MAX) % UINT256_MAX);
}

function stackPop(state: EvmState): bigint {
  if (state.stack.length === 0) {
    throw new Error("Stack underflow");
  }
  return state.stack.pop()!;
}
```

### Memory Expansion Cost

Memory costs grow quadratically: `3n + nÂ²/512` where n = words:

```typescript
function memoryExpansionCost(currentBytes: number, newBytes: number): bigint {
  if (newBytes <= currentBytes) return 0n;

  const currentWords = Math.ceil(currentBytes / 32);
  const newWords = Math.ceil(newBytes / 32);

  const currentCost = currentWords * 3 + Math.floor(currentWords ** 2 / 512);
  const newCost = newWords * 3 + Math.floor(newWords ** 2 / 512);

  return BigInt(newCost - currentCost);
}
```

### Opcode Execution

Use Voltaire's `Opcode` constants and utilities:

```typescript
import { Opcode } from "voltaire/primitives";

function executeOpcode(state: EvmState, opcode: number): void {
  switch (opcode) {
    case Opcode.STOP:
      state.stopped = true;
      break;

    case Opcode.ADD: {
      const a = stackPop(state);
      const b = stackPop(state);
      stackPush(state, a + b);
      break;
    }

    case Opcode.JUMP: {
      const dest = Number(stackPop(state));
      if (!state.validJumpDests.has(dest)) {
        throw new Error(`Invalid jump destination: ${dest}`);
      }
      state.pc = dest - 1; // -1 because step() will increment
      break;
    }

    // Handle PUSH1-PUSH32
    default:
      if (Opcode.isPush(opcode)) {
        const size = Opcode.getPushSize(opcode)!;
        let value = 0n;
        for (let i = 0; i < size; i++) {
          value = (value << 8n) | BigInt(state.bytecode[state.pc + 1 + i] ?? 0);
        }
        stackPush(state, value);
        state.pc += size;
      }
  }
}
```

### Gas Metering

Use `Opcode.getGasCost()` for per-opcode costs:

```typescript
function step(state: EvmState): void {
  if (state.stopped || state.pc >= state.bytecode.length) return;

  const opcode = state.bytecode[state.pc];

  // Get gas cost from Voltaire
  const gasCost = BigInt(Opcode.getGasCost(opcode) ?? 0);
  if (gasCost > state.gas) {
    throw new Error("Out of gas");
  }
  state.gas -= gasCost;

  executeOpcode(state, opcode);

  if (!state.stopped) {
    state.pc++;
  }
}
```

### Main Execution Loop

```typescript
import * as Hex from "voltaire/primitives/Hex";

function execute(bytecodeHex: string, gas = 100000n) {
  const bytecode = Hex.toBytes(Hex.from(bytecodeHex));
  const state = createState(bytecode, gas);
  const initialGas = gas;

  while (!state.stopped && state.pc < state.bytecode.length) {
    step(state);
  }

  return {
    success: true,
    output: state.output,
    gasUsed: initialGas - state.gas,
    finalStack: state.stack,
  };
}
```

## Running Examples

### Simple Addition

```typescript
// PUSH1 2, PUSH1 3, ADD, STOP
const result = execute("0x60026003010000");
console.log(result.finalStack); // [5n]
console.log(result.gasUsed);    // 9n (3 + 3 + 3 + 0)
```

### Loop Counting to 5

```typescript
// counter = 0
// loop: counter++; if counter < 5 goto loop
const bytecode = "0x60005b600101806005106002570000";
const result = execute(bytecode);
console.log(result.finalStack); // [5n]
```

### Return Computed Value

```typescript
// Compute 2*3+4 = 10, store at memory[0], return 32 bytes
const bytecode = "0x60026003026004016000526020600060f3";
const result = execute(bytecode);
console.log(result.output[31]); // 10
```

## Voltaire Primitives Used

| Primitive | Usage |
|-----------|-------|
| `Opcode.STOP`, `Opcode.ADD`, etc. | Opcode constants |
| `Opcode.getGasCost(opcode)` | Gas cost per opcode |
| `Opcode.getName(opcode)` | Opcode name for debugging |
| `Opcode.isPush(opcode)` | Check if PUSH opcode |
| `Opcode.getPushSize(opcode)` | Get PUSH immediate size |
| `Opcode.jumpDests(bytecode)` | Find valid JUMPDEST positions |
| `Hex.from(str)` | Parse hex string |
| `Hex.toBytes(hex)` | Convert to bytes |
| `Keccak256.hash(bytes)` | Hash bytecode |
| `Address.from(str)` | Create execution context |

## Debugging with Trace

```typescript
import { traceExecution } from "./simple-evm";

const { steps, result } = traceExecution("0x600160020100");

for (const step of steps) {
  console.log(`${step.pc}: ${step.opcodeName} gas=${step.gasCost}`);
}
// 0: PUSH1 gas=3
// 2: PUSH1 gas=3
// 4: ADD gas=3
// 5: STOP gas=0
```

## Extending the EVM

Ideas for extending this implementation:

1. **Storage**: Add SLOAD/SSTORE with a key-value store
2. **Calls**: Implement CALL, DELEGATECALL, STATICCALL
3. **Creates**: Add CREATE/CREATE2 for contract deployment
4. **Precompiles**: Route calls to 0x01-0x09 to crypto functions
5. **Logs**: Implement LOG0-LOG4 for event emission

## Source Code

Full implementation: [examples/evm/simple-evm.ts](https://github.com/evmts/voltaire/blob/main/examples/evm/simple-evm.ts)

## Resources

- [EVM Opcodes Reference](https://www.evm.codes)
- [Ethereum Yellow Paper](https://ethereum.github.io/yellowpaper/paper.pdf)
- [Voltaire Opcode Documentation](/primitives/opcode)
