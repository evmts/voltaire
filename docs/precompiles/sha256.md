# SHA256 (0x02)

**WARNING: This documentation was AI-generated and may contain inaccuracies. Always verify against the source code.**

## Address and EIP Reference

- **Address:** `0x0000000000000000000000000000000000000002`
- **Available since:** Frontier (first Ethereum release)
- **EIP:** Part of Ethereum Yellow Paper

## Purpose

Computes the SHA-256 cryptographic hash of arbitrary input data. SHA-256 is widely used in Bitcoin and other cryptographic systems.

## Audit Status

âœ… AUDITED - Production Ready

This implementation uses Zig's standard library `std.crypto.hash.sha2.Sha256`, which is:
- Part of Zig's audited standard library crypto module
- Based on FIPS 180-4 specification
- Suitable for production use
- Used in Ethereum precompile 0x02

Last verified: Zig 0.15.1 standard library

## Gas Cost

**Dynamic:**
- Base gas: 60
- Per-word gas: 12 (where word = 32 bytes)
- Formula: `60 + 12 * ceil(input_length / 32)`

## API Reference

### Function Signature

```zig
pub fn execute(
    allocator: std.mem.Allocator,
    input: []const u8,
    gas_limit: u64,
) PrecompileError!PrecompileResult
```

## Input Format

Accepts arbitrary-length input data (any byte sequence).

## Output Format

Always returns exactly 32 bytes containing the SHA-256 hash.

| Offset | Length | Field | Description |
|--------|--------|-------|-------------|
| 0      | 32     | hash  | SHA-256 hash of the input |

## Example Usage

```zig
const std = @import("std");
const precompiles = @import("precompiles");
const sha256 = precompiles.sha256;

const input = "hello world";
const result = try sha256.execute(allocator, input, 1000000);
defer result.deinit(allocator);

// result.output contains the 32-byte SHA-256 hash
std.debug.print("Hash: {x}\n", .{std.fmt.fmtSliceHexLower(result.output)});
```

## Example with Empty Input

```zig
// SHA-256 of empty string
const result = try sha256.execute(allocator, &[_]u8{}, 1000000);
defer result.deinit(allocator);

// Expected output:
// e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855
```

## Implementation Details

1. **Gas Calculation:** Computed as `BASE_GAS + PER_WORD_GAS * num_words` where `num_words = (input.len + 31) / 32`
2. **Hash Computation:** Uses hardware-accelerated SHA-256 implementation via `crypto.SHA256_Accel`
3. **Performance:** Optimized with AVX2/AVX-512 instructions on supported platforms

## Error Conditions

- **OutOfGas:** Insufficient gas provided for the input size

## Gas Cost Examples

| Input Size | Words | Gas Cost |
|------------|-------|----------|
| 0 bytes    | 0     | 60       |
| 1 byte     | 1     | 72       |
| 32 bytes   | 1     | 72       |
| 33 bytes   | 2     | 84       |
| 64 bytes   | 2     | 84       |
| 1024 bytes | 32    | 444      |

## Testing Considerations

Test cases should include:
- Empty input (known output vector)
- Single byte input
- Various input sizes (1, 31, 32, 33, 64 bytes)
- Large inputs (>1KB)
- Out of gas scenarios
- Known SHA-256 test vectors from NIST

## Known Test Vectors

```zig
// Empty string
input: ""
output: e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855

// "abc"
input: "abc"
output: ba7816bf8f01cfea414140de5dae2223b00361a396177a9cb410ff61f20015ad
```

## Security Notes

- Implementation uses well-tested SHA-256 algorithm
- Hardware acceleration provides constant-time guarantees on supported platforms
- No known vulnerabilities in the cryptographic primitive itself
