---
title: Multiplatform
description: Works everywhere - TypeScript, Zig, and any language with C-FFI
---

Works everywhere. TypeScript, Zig, any language with C-FFI.

## Installation by Language

<Tabs>
<Tab title="TypeScript/JavaScript">

```bash
npm install tevm
# or: bun add tevm / pnpm add tevm / yarn add tevm
```

</Tab>

<Tab title="Zig">

<Warning>
**Important:** Voltaire requires native C/Rust libraries that must be built before use. `zig fetch` alone will not work because the Rust crypto wrappers (`libcrypto_wrappers.a`) are built at compile time via Cargo.
</Warning>

**Option 1: Git Submodule (Recommended)**

Add as a git submodule in your project:

```bash
git submodule add https://github.com/evmts/voltaire.git lib/voltaire
cd lib/voltaire
zig build  # Builds Rust/C dependencies via Cargo
```

Then in your `build.zig`:

```zig
const voltaire = b.dependency("voltaire", .{
    .target = target,
    .optimize = optimize,
});

// Add modules to your executable/library
exe.root_module.addImport("primitives", voltaire.module("primitives"));
exe.root_module.addImport("crypto", voltaire.module("crypto"));

// Link required native libraries
exe.linkLibrary(voltaire.artifact("blst"));
exe.linkLibrary(voltaire.artifact("c_kzg"));
```

And in your `build.zig.zon`:

```zig
.dependencies = .{
    .voltaire = .{ .path = "lib/voltaire" },
},
```

**Option 2: Build from Source**

Clone and build once, then reference by path:

```bash
git clone https://github.com/evmts/voltaire.git
cd voltaire
zig build  # Requires Cargo/Rust installed
```

**Prerequisites for Zig builds:**
- [Zig 0.15.1+](https://ziglang.org/download/)
- [Rust/Cargo](https://rustup.rs/) - Required for native crypto wrappers

</Tab>

<Tab title="C-FFI">

Build the C library:

```bash
git clone https://github.com/evmts/voltaire.git
cd voltaire
zig build -Dwith-c-api=true
```

This produces:
- `zig-out/lib/libprimitives_c.a` (static library)
- `zig-out/lib/libprimitives_c.dylib` (dynamic library, macOS)
- `zig-out/include/primitives.h` (C header)

Link against the library and include the header in your project.

</Tab>
</Tabs>

<CardGroup cols={2}>
  <Card title="First Class Support" icon="star">
    TypeScript, Zig, and C - fully supported with complete APIs and documentation
  </Card>
  <Card title="C-FFI Support" icon="globe">
    Swift, Go, Python, Kotlin, and any language with foreign function interface support
  </Card>
</CardGroup>

<Warning>
C-FFI bindings require manual memory management. Always call corresponding `_free` functions to prevent leaks.
</Warning>

## Consistent API

The Tevm API is consistent across all languages.

<Tabs>
<Tab title="TypeScript">

```typescript
import { Address } from 'tevm';

function main() {
  const address = Address('0x742d35Cc6634C0532925a3b844Bc9e7595f51e3e');

  address.toChecksummed();
  address.toHex();
  address.isZero();
  address.equals(otherAddress);
}
```

</Tab>

<Tab title="Zig">

```zig
const Address = @import("primitives").Address;

pub fn main() !void {
    const address = try Address.fromHex("0x742d35Cc6634C0532925a3b844Bc9e7595f51e3e");

    _ = address.toChecksummed();
    _ = address.toHex();
    _ = address.isZero();
    _ = address.equals(otherAddress);
}
```

</Tab>

<Tab title="C">

```c
#include "primitives.h"

int main() {
    Address* address = tevm_address_from_hex("0x742d35Cc6634C0532925a3b844Bc9e7595f51e3e");

    char* checksummed = tevm_address_to_checksummed(address);
    char* hex = tevm_address_to_hex(address);
    bool is_zero = tevm_address_is_zero(address);
    bool equal = tevm_address_equals(address, other_address);

    // Free memory
    tevm_string_free(checksummed);
    tevm_string_free(hex);
    tevm_address_free(address);
}
```

</Tab>

<Tab title="Swift">

```swift
import Foundation
import Tevm

// Idiomatic Swift wrapper using C-FFI
class Address {
    private let ptr: OpaquePointer

    init(_ hex: String) throws {
        guard let ptr = tevm_address_from_hex(hex) else {
            throw TevmError.invalidAddress
        }
        self.ptr = ptr
    }

    deinit {
        tevm_address_free(ptr)
    }

    func toChecksummed() -> String {
        let result = tevm_address_to_checksummed(ptr)
        defer { tevm_string_free(result) }
        return String(cString: result!)
    }

    func toHex() -> String {
        let result = tevm_address_to_hex(ptr)
        defer { tevm_string_free(result) }
        return String(cString: result!)
    }

    func isZero() -> Bool {
        return tevm_address_is_zero(ptr)
    }

    func equals(_ other: Address) -> Bool {
        return tevm_address_equals(ptr, other.ptr)
    }
}

// Usage matches TypeScript API
let address = try Address("0x742d35Cc6634C0532925a3b844Bc9e7595f51e3e")
address.toChecksummed()
address.toHex()
address.isZero()
address.equals(otherAddress)
```

</Tab>
</Tabs>

## Looking for Help

We're looking for contributors to help build idiomatic wrappers for:

- **Go** - Native bindings via cgo
- **Python** - Bindings via ctypes/cffi
- **Swift** - iOS/macOS wrapper with automatic memory management
- **Kotlin** - Android/JVM bindings

<Tip>
Interested in contributing? Check out [src/c_api.zig](https://github.com/evmts/tevm/blob/main/src/c_api.zig) for the C-FFI interface and [src/primitives.h](https://github.com/evmts/tevm/blob/main/src/primitives.h) for the generated C header. Join our [Telegram](https://t.me/+ANThR9bHDLAwMjUx) or open an issue on [GitHub](https://github.com/evmts/tevm/issues).
</Tip>
