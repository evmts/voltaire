---
title: Safe Ethereum
description: Modern type safety with branded types
---

Tevm's API is completely based around branded Ethereum types. Branded Common Ethereum types are simple data structures that represent common Ethereum primitives such as addresses, call data, keccak256 hashes, JSON-RPC requests and responses, etc., that are both strongly typed in TypeScript and also validated at runtime.

> Those who would give up type safety to gain performance deserve neither safety nor performance.
>
> — Adapted from Benjamin Franklin

## The Problem

TypeScript uses structural typing - types with same structure are interchangeable. Template literal types like `0x${string}` don't prevent type errors and provide no runtime validation:

```typescript
type Address = `0x${string}`;
type Bytecode = `0x${string}`;

function transfer(to: Address, amount: bigint) {
  // Send funds to address
}

const address: Address = "0x742d35Cc6634C0532925a3b844Bc9e7595f51e3e";
const bytecode: Bytecode = "0x60806040";

// Structural typing allows wrong types
transfer(bytecode, 100n); // ✓ Compiles - breaks downstream!

// No runtime validation
const invalid: Address = "0xnot_valid_hex"; // ✓ Compiles - invalid hex!
const wrong: Address = "0x123"; // ✓ Compiles - wrong length!

transfer(invalid, 100n); // Runtime error or lost funds
```

## The Solution

[Branded types](https://prosopo.io/blog/typescript-branding/) and strong validators.

A branded type is a native JavaScript type, like `Uint8Array` or `string`, with a compile-time-only tag that prevents mixing incompatible types that would otherwise match:

```typescript
import { Address, Bytecode, SignatureSalt } from 'tevm';

function verifySignature(addr: Address, salt: SignatureSalt) { /* ... */ }

const address = Address("0x742d35Cc6634C0532925a3b844Bc9e7595f51e3e")
const bytecode = Bytecode("0x6001")
const salt = SignatureSalt("0x1234...")

verifySignature(bytecode, salt) // ✗ Error: Type 'Bytecode' is not assignable to type 'Address'
```

Every Ethereum type is provided by Tevm. Tevm takes a data-first approach to Ethereum, thinking of Ethereum as just data that gets transformed in a stream of blocks. This allows you to focus on representing data types with strong validation, declarative transformations, and robust runtime safety.

When we think of Ethereum as just basic primitive Ethereum types, those who have Ethereum domain knowledge will find using Tevm to be intuitive and easy to get in the flow state.

The high level of type safety also makes coding with LLMs much safer than any previous Ethereum library. And that domain knowledge means that LLMs will be pre-trained on using Tevm because they can leverage their more generic Ethereum knowledge while using the Tevm API.

If something has type `AddressType`, you know it was validated at runtime to be a valid address.

## Benefits

<CardGroup cols={2}>
  <Card title="Type Safety" icon="lock">
    Can't mix Address with Hash or Bytecode. Arguments can't be swapped.
  </Card>
  <Card title="Self-Documenting" icon="book">
    Function signatures clearly show expected types instead of generic Uint8Array.
  </Card>
  <Card title="Zero Runtime Cost" icon="gauge">
    Brand field only exists in TypeScript's type checker. Zero runtime overhead.
  </Card>
  <Card title="Validated" icon="shield-check">
    Input validated at construction. No runtime validation libraries needed.
  </Card>
</CardGroup>

## Example: Casing Bugs

String-based addresses suffer from casing inconsistencies:

```typescript
const addr1 = "0x742d35cc6634c0532925a3b844bc9e7595f51e3e"; // lowercase
const addr2 = "0x742d35Cc6634C0532925a3b844Bc9e7595f51e3e"; // checksummed
const addr3 = "0x742D35CC6634C0532925A3B844BC9E7595F51E3E"; // uppercase

// All represent same address but !== in JavaScript
addr1 === addr2; // false
```

This leads to bugs when comparing addresses, using them as map keys, or validating signatures. Tevm eliminates this entire class of bugs by using `Uint8Array` as the underlying type.

<Note>
`Uint8Array` provides better performance (native byte operations without encoding/decoding) and follows Tevm's philosophy of using the simplest JavaScript data structure that correctly represents the type.
</Note>

## Validation at Construction

Factory functions validate inputs at construction, eliminating the need for runtime validation libraries like Zod:

```typescript
import { Address } from 'tevm';

// Valid inputs - all validated at construction
const addr1 = Address("0x742d35Cc6634C0532925a3b844Bc9e7595f51e3e");
const addr2 = Address(0x742d35Cc6634C0532925a3b844Bc9e7595f51e3en);
```

<Warning>
**If you see a branded type, it's validated.**

Any value with type `AddressType` has been validated to be a correct, valid address. No additional runtime checks needed.
</Warning>

All invalid inputs throw validation errors:

```typescript
// Invalid hex characters
Address("0xnot_valid_hex");
// Error: Invalid hex character

// Wrong length (too short)
Address("0x123");
// Error: Invalid address length

// Wrong byte length
Address(new Uint8Array(10));
// Error: Address must be exactly 20 bytes

// Invalid checksum
Address("0x742d35cc6634c0532925a3b844bc9e7595f51e3E"); // Invalid EIP-55
// Error: Invalid checksum
```

## Learn More

<CardGroup cols={2}>
  <Card title="Branded Types Reference" icon="book" href="/concepts/branded-types">
    Complete guide to branded types in Tevm
  </Card>
  <Card title="Address Primitive" icon="cube" href="/primitives/address">
    Complete Address API reference
  </Card>
</CardGroup>
