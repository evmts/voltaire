---
title: Branded Types
description: Modern type safety with runtime validation
---

## The Problem

TypeScript uses structural typing - types with same structure are interchangeable. Template literal types like `0x${string}` don't prevent type errors:

```typescript
type Address = `0x${string}`;
type Bytecode = `0x${string}`;

function transfer(to: Address, amount: bigint) {
  // Send funds to address
}

const address: Address = "0x742d35Cc6634C0532925a3b844Bc9e7595f51e3e";
const bytecode: Bytecode = "0x60806040";

transfer(bytecode, 100n); // ✓ Compiles - sends funds to bytecode!
```

Even worse, template literal types provide no runtime validation:

```typescript
type Address = `0x${string}`;

const invalid: Address = "0xnot_valid_hex"; // ✓ Compiles - invalid hex!
const wrong: Address = "0x123"; // ✓ Compiles - wrong length!

transfer(invalid, 100n); // Runtime error or lost funds
```

In Voltaire, if something has type `BrandedAddress`, you know it was validated at runtime to be a valid address.

## The Solution

Add compile-time-only brand field. A `BrandedAddress` is a `Uint8Array` with a compile-time-only type tag:

```typescript
declare const brand: unique symbol

type BrandedAddress = Uint8Array & { readonly [brand]: "Address" }
type BrandedBytecode = Uint8Array & { readonly [brand]: "Bytecode" }

function verifySignature(addr: BrandedAddress, hash: Uint8Array) { /* ... */ }

const address = Address("0x742d35Cc6634C0532925a3b844Bc9e7595f51e3e")
const bytecode = Bytecode("0x6001")

verifySignature(bytecode, Hash("0x1234...")) // ✗ Error: Type 'BrandedBytecode' is not assignable to type 'BrandedAddress'
```

Brand exists only in type system - erased at runtime. Values are still plain Uint8Array.

## Casing Bugs

String-based addresses suffer from casing inconsistencies:

```typescript
const addr1 = "0x742d35cc6634c0532925a3b844bc9e7595f51e3e"; // lowercase
const addr2 = "0x742d35Cc6634C0532925a3b844Bc9e7595f51e3e"; // checksummed
const addr3 = "0x742D35CC6634C0532925A3B844BC9E7595F51E3E"; // uppercase

// All represent same address but !== in JavaScript
addr1 === addr2; // false
```

This leads to bugs when comparing addresses, using them as map keys, or validating signatures. Voltaire eliminates this entire class of bugs by using `Uint8Array` as the underlying type.

Even when using hex strings, Voltaire maintains type safety through branded variants:

```typescript
import { Address } from '@tevm/voltaire';

const address = Address(0x742d35Cc6634C0532925a3b844Bc9e7595f51e3en);

// Each returns a branded hex string type
const checksummed = Address.toChecksummed(address); // ChecksumAddress
const lowercase = Address.toLowercase(address);     // LowercaseAddress
const uppercase = Address.toUppercase(address);     // UppercaseAddress
const hex = Address.toHex(address);                 // Hex

// Type-safe even with strings
function verify(addr: ChecksumAddress) { }
verify(lowercase); // ✗ Error: Type 'LowercaseAddress' is not assignable to 'ChecksumAddress'
```

<Note>
In addition to eliminating casing bugs, `Uint8Array` provides better performance (native byte operations without encoding/decoding) and follows Voltaire's philosophy of using the simplest JavaScript data structure that correctly represents the type.
</Note>

## Voltaire's Approach

All primitives use a shared `unique symbol` with string literal tags:

```typescript
declare const brand: unique symbol

type BrandedAddress = Uint8Array & { readonly [brand]: "Address" }
type BrandedHex = string & { readonly [brand]: "Hex" }

function process(addr: BrandedAddress) { /* ... */ }
const hex: BrandedHex = "0x..." as BrandedHex
process(hex) // ✗ Error
```

## Console Formatting

In Node, Bun, and browsers, branded types display formatted:

```typescript
const address = Address(0x742d35Cc6634C0532925a3b844Bc9e7595f51e3en);
console.log(address);
// Address("0x742d35cc6634c0532925a3b844bc9e7595f51e3e")
```

This makes debugging more readable while maintaining full `Uint8Array` performance.

## Validation at Construction

Factory functions validate inputs at construction, eliminating the need for runtime validation libraries like Zod:

```typescript
import { Address } from '@tevm/voltaire';

// Valid inputs - all validated at construction
const addr1 = Address("0x742d35Cc6634C0532925a3b844Bc9e7595f51e3e");
const addr2 = Address(0x742d35Cc6634C0532925a3b844Bc9e7595f51e3en);
```

<Warning>
**If you see a branded type, it's validated.**

Any value with type `BrandedAddress` has been validated to be a correct, valid address. No additional runtime checks needed.
</Warning>

All invalid inputs throw validation errors:

```typescript
// Invalid hex characters
Address("0xnot_valid_hex");
// Error: Invalid hex character

// Wrong length (too short)
Address("0x123");
// Error: Invalid address length

// Wrong byte length
Address(new Uint8Array(10));
// Error: Address must be exactly 20 bytes

// Invalid checksum
Address("0x742d35cc6634c0532925a3b844bc9e7595f51e3E"); // Invalid EIP-55
// Error: Invalid checksum
```

## Benefits of Branded Types

<CardGroup cols={2}>
  <Card title="Type Safety" icon="lock">
    Can't mix Address with Hash or Bytecode. Arguments can't be swapped.
  </Card>
  <Card title="Self-Documenting" icon="book">
    Function signatures clearly show expected types instead of generic Uint8Array.
  </Card>
  <Card title="Zero Runtime Cost" icon="gauge">
    Brand field only exists in TypeScript's type checker. Zero runtime overhead.
  </Card>
  <Card title="Validated" icon="shield-check">
    Input validated at construction. No runtime validation libraries needed.
  </Card>
</CardGroup>

## Learn More

<CardGroup cols={2}>
  <Card title="Address Primitive" icon="cube" href="/primitives/address">
    Complete Address API reference
  </Card>
  <Card title="TypeScript Branding" icon="book-open" href="https://prosopo.io/blog/typescript-branding/">
    In-depth guide to branded types (Prosopo)
  </Card>
</CardGroup>
