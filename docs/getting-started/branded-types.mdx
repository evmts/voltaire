---
title: Branded Types
description: Modern typesafety with runtime validated types using type-level tags
---

Branded types provide modern typesafety with runtime validated types without the need for a library like Zod. They use [type-level tags](https://news.ycombinator.com/item?id=40146751) that make structurally identical types distinguishable to TypeScript's type checker.

## The Problem

TypeScript uses structural typing - types with same structure are interchangeable. Template literal types like `0x${string}` don't prevent type errors:

```typescript
type Address = `0x${string}`;
type Bytecode = `0x${string}`;

function transfer(to: Address, amount: bigint) {
  // Send funds to address
}

const address: Address = "0x742d35Cc6634C0532925a3b844Bc9e7595f51e3e";
const bytecode: Bytecode = "0x60806040";

transfer(bytecode, 100n);
```

This compiles without errors but sends funds to bytecode instead of an address.

## The Solution

Add compile-time-only brand field using symbol. A `BrandedAddress` is a `Uint8Array` with a compile-time-only type tag:

```typescript
declare const brand: unique symbol

type BrandedAddress = Uint8Array & { readonly [brand]: "Address" }
type BrandedBytecode = Uint8Array & { readonly [brand]: "Bytecode" }

function verifySignature(addr: BrandedAddress, hash: Uint8Array) { /* ... */ }

const address = Address.from("0x742d35Cc6634C0532925a3b844Bc9e7595f51e3e")
const bytecode = Bytecode.from("0x6001")

verifySignature(bytecode, Hash.from("0x1234...")) // ✗ Error: Type 'BrandedBytecode' is not assignable to type 'BrandedAddress'
```

Brand exists only in type system - erased at runtime. Values are still plain Uint8Array.

### Generic Brand Type

```typescript
declare const brand: unique symbol

type Brand<T, Tag> = T & { readonly [brand]: Tag }
```

Usage:

```typescript
type BrandedAddress = Brand<Uint8Array, "Address">
type BrandedBytecode = Brand<Uint8Array, "Bytecode">
type BrandedHex = Brand<string, "Hex">
```

### Why Symbols?

Using `unique symbol` ensures:
1. **No runtime overhead** - symbols don't exist at runtime when used in type-only position
2. **No name collisions** - symbol property name can't clash with real properties
3. **Type safety** - TypeScript treats each brand as unique identifier

```typescript
// Without symbol (DON'T DO THIS)
type BrandedAddress = Uint8Array & { __brand: "Address" }

// If Uint8Array somehow had __brand property, this would conflict!
// Using symbol prevents any runtime property conflicts
```

### Voltaire's Approach

All primitives use a shared `unique symbol` with string literal tags for type branding:

```typescript
// Global brand symbol (declared once in src/brand.ts)
declare const brand: unique symbol

// BrandedAddress is Uint8Array with brand
type BrandedAddress = Uint8Array & { readonly [brand]: "Address" }

// BrandedHex is string with brand
type BrandedHex = string & { readonly [brand]: "Hex" }

// Can't mix them up
function process(addr: BrandedAddress) { /* ... */ }
const hex: BrandedHex = "0x..." as BrandedHex
process(hex) // ✗ Error
```

Runtime: just `Uint8Array` and `string`. Brand only exists in types. The `unique symbol` ensures no name collisions while string literal tags identify each type.

### Console Formatting

Despite being `Uint8Array`, branded types display formatted in most environments:

```typescript
const address = Address(0x742d35Cc6634C0532925a3b844Bc9e7595f51e3en);
console.log(address);
// Address("0x742d35cc6634c0532925a3b844bc9e7595f51e3e")
```

This formatting:
- Makes debugging more readable than raw byte arrays
- Shows the branded type name (Address, Hash, Bytecode, etc.)
- Displays data as hex string for easy inspection
- Maintains full `Uint8Array` performance and compatibility

```typescript
import { Address } from '@tevm/voltaire';

const address = Address(0x742d35Cc6634C0532925a3b844Bc9e7595f51e3en);

const checksummed = Address.toChecksummed(address);

const contractAddress = Address.fromCreate2({
  from: address,
  salt: '0x0000000000000000000000000000000000000000000000000000000000000000',
  bytecode: '0x600160010160005260206000f3'
});
```

Now the same mistake is caught at compile time:

```typescript
import { Address, Bytecode } from '@tevm/voltaire';

function transfer(to: Address, amount: bigint) { }

const address = Address(0x742d35Cc6634C0532925a3b844Bc9e7595f51e3en);
const bytecode = Bytecode("0x60806040");

transfer(bytecode, 100n);
```

## Validation at Construction

Factory functions validate then cast to branded type. `Address.from()` validates inputs at construction, eliminating the need for runtime validation libraries like Zod:

```typescript
declare const brand: unique symbol
type BrandedAddress = Uint8Array & { readonly [brand]: "Address" }

function fromUint8Array(bytes: Uint8Array): BrandedAddress {
  // Validate
  if (!Address.isValidAddress(bytes)) {
    throw new InvalidAddressError()
  }

  // Return input cast to branded type
  return bytes as BrandedAddress
}

// Create from various inputs - all validated at construction
const addr1 = Address.from("0x742d35Cc6634C0532925a3b844Bc9e7595f51e3e")
const addr2 = Address.from(0x742d35Cc6634C0532925a3b844Bc9e7595f51e3en)
// addr runtime: Uint8Array with 20 bytes
// addr compile-time: BrandedAddress (type-safe)
```

Example usage:

```typescript
import { Address } from '@tevm/voltaire';

const valid = Address("0x742d35Cc6634C0532925a3b844Bc9e7595f51e3e");

const invalid = Address("0x742d35Cc6634C0532925a3b844Bc9e7595f5");
```

Validation at construction. Brand ensures type safety throughout codebase.

## Benefits

<CardGroup cols={2}>
  <Card title="Type Safety" icon="lock">
    Can't mix Address with Hash or Bytecode. Arguments can't be swapped.
  </Card>
  <Card title="Self-Documenting" icon="book">
    Function signatures clearly show expected types instead of generic Uint8Array.
  </Card>
  <Card title="Zero Runtime Cost" icon="gauge">
    Brand field only exists in TypeScript's type checker. Zero runtime overhead.
  </Card>
  <Card title="Validated" icon="shield-check">
    Input validated at construction. No runtime validation libraries needed.
  </Card>
</CardGroup>

## Learn More

<CardGroup cols={2}>
  <Card title="Address Primitive" icon="cube" href="/primitives/address">
    Complete Address API reference
  </Card>
  <Card title="Tree-Shaking" icon="tree" href="/getting-started/tree-shaking">
    How data-first design enables tree-shaking
  </Card>
</CardGroup>
