---
title: Branded Types
description: Modern type safety with runtime validation
---

## The Problem

TypeScript uses structural typing - types with same structure are interchangeable. Template literal types like `0x${string}` don't prevent type errors:

```typescript
type Address = `0x${string}`;
type Bytecode = `0x${string}`;

function transfer(to: Address, amount: bigint) {
  // Send funds to address
}

const address: Address = "0x742d35Cc6634C0532925a3b844Bc9e7595f51e3e";
const bytecode: Bytecode = "0x60806040";

transfer(bytecode, 100n); // ✓ Compiles - sends funds to bytecode!
```

Even worse, template literal types provide no runtime validation:

```typescript
type Address = `0x${string}`;

const invalid: Address = "0xnot_valid_hex"; // ✓ Compiles - invalid hex!
const wrong: Address = "0x123"; // ✓ Compiles - wrong length!

transfer(invalid, 100n); // Runtime error or lost funds
```

In Voltaire, if something has type `BrandedAddress`, you know it was validated at runtime to be a valid address.

## The Solution

Add compile-time-only brand field. A `BrandedAddress` is a `Uint8Array` with a compile-time-only type tag:

```typescript
declare const brand: unique symbol

type BrandedAddress = Uint8Array & { readonly [brand]: "Address" }
type BrandedBytecode = Uint8Array & { readonly [brand]: "Bytecode" }

function verifySignature(addr: BrandedAddress, hash: Uint8Array) { /* ... */ }

const address = Address("0x742d35Cc6634C0532925a3b844Bc9e7595f51e3e")
const bytecode = Bytecode("0x6001")

verifySignature(bytecode, Hash("0x1234...")) // ✗ Error: Type 'BrandedBytecode' is not assignable to type 'BrandedAddress'
```

Brand exists only in type system - erased at runtime. Values are still plain Uint8Array.

## Casing Bugs

String-based addresses suffer from casing inconsistencies:

```typescript
const addr1 = "0x742d35cc6634c0532925a3b844bc9e7595f51e3e"; // lowercase
const addr2 = "0x742d35Cc6634C0532925a3b844Bc9e7595f51e3e"; // checksummed
const addr3 = "0x742D35CC6634C0532925A3B844BC9E7595F51E3E"; // uppercase

// All represent same address but !== in JavaScript
addr1 === addr2; // false
```

This leads to bugs when comparing addresses, using them as map keys, or validating signatures. Voltaire eliminates this entire class of bugs by using `Uint8Array` as the underlying type.

Even when using hex strings, Voltaire maintains type safety through branded variants:

```typescript
import { Address } from '@tevm/voltaire';

const address = Address(0x742d35Cc6634C0532925a3b844Bc9e7595f51e3en);

// Each returns a branded hex string type
const checksummed = Address.toChecksummed(address); // ChecksumAddress
const lowercase = Address.toLowercase(address);     // LowercaseAddress
const uppercase = Address.toUppercase(address);     // UppercaseAddress
const hex = Address.toHex(address);                 // Hex

// Type-safe even with strings
function verify(addr: ChecksumAddress) { }
verify(lowercase); // ✗ Error: Type 'LowercaseAddress' is not assignable to 'ChecksumAddress'
```

<Note>
In addition to eliminating casing bugs, `Uint8Array` provides better performance (native byte operations without encoding/decoding) and follows Voltaire's philosophy of using the simplest JavaScript data structure that correctly represents the type.
</Note>

## Voltaire's Approach

All primitives use a shared `unique symbol` with string literal tags:

```typescript
declare const brand: unique symbol

type BrandedAddress = Uint8Array & { readonly [brand]: "Address" }
type BrandedHex = string & { readonly [brand]: "Hex" }

function process(addr: BrandedAddress) { /* ... */ }
const hex: BrandedHex = "0x..." as BrandedHex
process(hex) // ✗ Error
```

## Console Formatting

In Node, Bun, and browsers, branded types display formatted:

```typescript
const address = Address(0x742d35Cc6634C0532925a3b844Bc9e7595f51e3en);
console.log(address);
// Address("0x742d35cc6634c0532925a3b844bc9e7595f51e3e")
```

This makes debugging more readable while maintaining full `Uint8Array` performance.

## Validation at Construction

Factory functions validate then cast to branded type. `Address.from()` validates inputs at construction, eliminating the need for runtime validation libraries like Zod:

```typescript
declare const brand: unique symbol
type BrandedAddress = Uint8Array & { readonly [brand]: "Address" }

function fromUint8Array(bytes: Uint8Array): BrandedAddress {
  // Validate
  if (!Address.isValidAddress(bytes)) {
    throw new InvalidAddressError()
  }

  // Return input cast to branded type
  return bytes as BrandedAddress
}

// Create from various inputs - all validated at construction
const addr1 = Address("0x742d35Cc6634C0532925a3b844Bc9e7595f51e3e")
const addr2 = Address(0x742d35Cc6634C0532925a3b844Bc9e7595f51e3en)
// addr runtime: Uint8Array with 20 bytes
// addr compile-time: BrandedAddress (type-safe)
```

Example usage:

```typescript
import { Address } from '@tevm/voltaire';

const valid = Address("0x742d35Cc6634C0532925a3b844Bc9e7595f51e3e");

const invalid = Address("0x742d35Cc6634C0532925a3b844Bc9e7595f5");
```

Validation at construction. Brand ensures type safety throughout codebase.

## Benefits

<CardGroup cols={2}>
  <Card title="Type Safety" icon="lock">
    Can't mix Address with Hash or Bytecode. Arguments can't be swapped.
  </Card>
  <Card title="Self-Documenting" icon="book">
    Function signatures clearly show expected types instead of generic Uint8Array.
  </Card>
  <Card title="Zero Runtime Cost" icon="gauge">
    Brand field only exists in TypeScript's type checker. Zero runtime overhead.
  </Card>
  <Card title="Validated" icon="shield-check">
    Input validated at construction. No runtime validation libraries needed.
  </Card>
</CardGroup>

## Learn More

<CardGroup cols={2}>
  <Card title="Address Primitive" icon="cube" href="/primitives/address">
    Complete Address API reference
  </Card>
</CardGroup>
