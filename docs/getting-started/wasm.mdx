---
title: Runtime Implementations
description: Choose between TypeScript, WASM, and Native FFI based on your environment
---

Voltaire provides three entrypoints with **identical APIs**. All implement the `VoltaireAPI` interface, ensuring compile-time errors if APIs diverge.

## Three Entrypoints

| Entrypoint | Import | Runtime | Use Case |
|------------|--------|---------|----------|
| **JS** | `@tevm/voltaire` | Any JS runtime | Default, universal compatibility |
| **WASM** | `@tevm/voltaire/wasm` | Browser, Node, Bun, Deno | High performance, portable |
| **Native** | `@tevm/voltaire/native` | Bun | Maximum performance via FFI |

```typescript
// All three have the SAME API
import { Address, Keccak256 } from '@tevm/voltaire'        // JS (default)
import { Address, Keccak256 } from '@tevm/voltaire/wasm'   // WASM
import { Address, Keccak256 } from '@tevm/voltaire/native' // Native FFI
```

<Note>
All three entrypoints export identical namespaces and types. Switch implementations by changing the import path - no code changes required.
</Note>

## Unified VoltaireAPI Interface

The `VoltaireAPI` interface (defined in `src/api-interface.ts`) ensures all entrypoints export:

**Primitives:** Address, Hash, Hex, Uint, Rlp, Abi, Blob, AccessList, Bytecode, Chain, Opcode, BloomFilter, Siwe, Bytes, Bytes32, StorageKey, Wei, Gwei, Ether

**Crypto:** Keccak256, SHA256, Blake2, Ripemd160, Secp256k1, Ed25519, P256, X25519, BN254, Bls12381, KZG, EIP712, ModExp

If any entrypoint is missing an export or has a type mismatch, TypeScript will error at compile time.

## Choosing an Entrypoint

| Concern | Recommendation |
|---------|----------------|
| **Universal compatibility** | JS (`@tevm/voltaire`) |
| **Browser crypto performance** | WASM (`@tevm/voltaire/wasm`) |
| **Bun/Node crypto performance** | Native (`@tevm/voltaire/native`) |
| **Serverless/Edge** | WASM (`@tevm/voltaire/wasm`) |
| **Bundle size** | JS or WASM (comparable) |
| **Debugging** | JS (`@tevm/voltaire`) |

## JS (Default)

Pure TypeScript/JavaScript. Works everywhere JavaScript runs.

<Note>
Shares peer dependencies with [Tevm](https://tevm.sh) and [Viem](https://viem.sh) for seamless integration.
</Note>

```typescript
import { Keccak256, Address, Hex } from '@tevm/voltaire'

const hash = Keccak256.hash(Hex.toBytes(Hex.fromString('hello')))
const addr = Address('0x742d35Cc6634C0532925a3b844Bc9e7595f51e3e')
```

Best for:
- Universal browser/server compatibility
- Debugging and development
- Bundle size sensitive applications
- Environments without WASM support

## WASM

WebAssembly bindings to Zig implementations. Portable high-performance.

<Note>
The WASM entrypoint exports the **same API** as JS. Switch by changing the import path.
</Note>

```typescript
import { Keccak256, Secp256k1, Hex, Address } from '@tevm/voltaire/wasm'

// Same API as JS entrypoint
const hash = Keccak256.hash(data)
const recovered = Secp256k1.recoverAddress(hash, signature)
const addr = Address('0x742d35Cc6634C0532925a3b844Bc9e7595f51e3e')

// All namespaces work identically
Secp256k1.sign(message, privateKey)
```

Best for:
- Browser applications needing crypto performance
- Serverless/edge functions (Cloudflare Workers, Vercel Edge)
- Cross-platform consistency

## Native FFI (Bun)

Direct bindings to Zig via Bun FFI. Maximum performance.

<Note>
The Native entrypoint exports the **same API** as JS. Switch by changing the import path.
</Note>

```typescript
import { Keccak256, Address, Secp256k1 } from '@tevm/voltaire/native'

// Same API as JS entrypoint
const hash = Keccak256.hash(data)
const addr = Address('0x742d35Cc6634C0532925a3b844Bc9e7595f51e3e')
const signature = Secp256k1.sign(message, privateKey)
```

<Warning>
Runtime support: Native FFI is <strong>Bun-only</strong>. In <strong>Node.js</strong>, use the JS or WASM entrypoint. Ensure the compiled `.dylib`/`.so`/`.dll` is available (run `zig build build-ts-native`).
</Warning>

Best for:
- Server-side applications with heavy crypto workloads
- CLI tools
- Maximum throughput requirements

## WASM-Accelerated Methods (`_wasm`)

Some namespaces expose WASM-accelerated methods via the `_wasm` property:

```typescript
import { Keccak256 } from '@tevm/voltaire'

// Default JS implementation
const hash1 = Keccak256.hash(data)

// WASM-accelerated (if available)
const hash2 = Keccak256._wasm.hash(data)
```

This lets you use WASM for specific hot paths without switching entrypoints entirely. Available on crypto namespaces like `Keccak256`, `Secp256k1`, `SHA256`, etc.

## Per-Module Imports

For fine-grained control, import specific implementations:

```typescript
// Keccak256 variants
import * as Keccak256 from '@tevm/voltaire/Keccak256'           // JS (default)
import * as Keccak256 from '@tevm/voltaire/Keccak256/wasm'      // WASM
import * as Keccak256 from '@tevm/voltaire/Keccak256/native'    // Native FFI
```

## Performance Considerations

<Warning>
Performance is nuanced. WASM/Native aren't always faster than TypeScript.
</Warning>

**Bridging overhead**: Crossing the JS↔WASM or JS↔FFI boundary has constant overhead (~1-10μs). For cheap operations (simple math, short string manipulation), this overhead can exceed the operation itself.

**When WASM/Native wins**:
- Cryptographic operations (keccak256, secp256k1, BLS) - 5-15x faster
- Large data encoding/decoding (RLP, ABI with big payloads)
- Batch operations that amortize bridging cost

**When JS wins**:
- Simple operations (hex encoding small values, address validation)
- Single-item operations with low computational cost
- When avoiding async overhead matters

**Bundle size**: For cryptography specifically, WASM is often *smaller* than equivalent pure-JS implementations. A full JS secp256k1 library can be 50-100KB, while WASM crypto modules are typically 20-40KB.

| Operation | JS | WASM | Native | Default |
|-----------|-----|------|--------|---------|
| keccak256 | 1x | ~5x | ~10x | JS |
| secp256k1 sign | 1x | ~8x | ~15x | JS |
| secp256k1 recover | 1x | ~8x | ~15x | JS |
| RLP encode | 1x | ~1.2x | ~1.5x | JS |
| Hex encode | 1x | ~1.1x | ~1.2x | JS |

<Tip>
Benchmark your actual workload. Default implementations are chosen for common use cases, but your specific access patterns may differ.
</Tip>
