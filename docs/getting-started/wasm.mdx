---
title: Zig-Wasm-Accelerated
description: High-performance WASM implementations built with Zig
---

Voltaire provides high-performance WASM implementations built with Zig alongside pure TypeScript implementations. WASM works in almost all JavaScript environments (Node, Bun, browsers) without any special build tools or deployment configuration.

## Dual Implementations

Every feature in Voltaire has both TypeScript and Zig implementations. This gives you flexibility to choose the right trade-off for your use case:

```typescript
import { keccak256 } from '@tevm/voltaire/crypto';        // JavaScript version
import { keccak256 } from '@tevm/voltaire/crypto/wasm';  // WASM version
```

The APIs are identical - you can swap implementations without changing your code. Start with JavaScript for simplicity, switch to WASM for performance, or mix both in the same codebase.

<Note>
Whether a method uses WASM or JavaScript under the hood is mostly transparent. The API remains consistent regardless of implementation.
</Note>

## When to Use WASM

We measure performance and bundle size for every operation in both JavaScript and WASM. Sometimes WASM is a clear winner, sometimes JavaScript is better.

### WASM is Better For:

**Cryptography** - Up to 3x faster with smaller bundle sizes:
```typescript
import { keccak256 } from '@tevm/voltaire/crypto/wasm';

// WASM: 3x faster + smaller bundle size
const hash = keccak256(data);
```

**EVM Operations** - Complex bytecode execution benefits from native performance:
```typescript
import { executeOpcode } from '@tevm/voltaire/evm/wasm';
```

**Encoding/Decoding with Crypto** - When operations involve cryptographic hashing:
```typescript
import { rlpEncode } from '@tevm/voltaire/primitives/wasm';
```

### JavaScript is Better For:

**Simple String Operations** - Native JavaScript is faster than WASM overhead:
```typescript
import { Hex } from '@tevm/voltaire/primitives';

// Pure JS: No WASM bridge overhead
const lowercase = Hex.toLowercase(hex);
```

**Small Operations** - When crossing the WASM boundary costs more than the operation itself.

## Performance

Keccak256 is a prime example where WASM wins on both metrics:

| Implementation | Bundle Size | Performance | Recommendation |
|----------------|-------------|-------------|----------------|
| JavaScript | Larger | Baseline | Development |
| WASM | **Smaller** | **3x faster** | âœ… Production |

We highly recommend using WASM for:
- Cryptographic operations
- EVM bytecode execution
- RLP encoding with hashing
- Any performance-critical path

## Zero Configuration

WASM implementations work out of the box in:
- Node.js
- Bun
- Browsers (Chrome, Firefox, Safari, Edge)
- Edge runtimes (Cloudflare Workers, Vercel Edge)

No webpack configuration, no bundler plugins, no deployment changes required.
