---
title: Zig-Wasm-Accelerated
description: High-performance WASM implementations built with Zig
---

Voltaire provides high-performance WASM implementations built with Zig alongside pure TypeScript implementations. WASM works in almost all JavaScript environments (Node, Bun, browsers) without any special build tools or deployment configuration.

## Dual Implementations

Every feature in Voltaire has both TypeScript and Zig implementations. This gives you flexibility to choose the right trade-off for your use case:

```typescript
import { keccak256 } from '@tevm/voltaire/crypto';        // JavaScript version
import { keccak256 } from '@tevm/voltaire/crypto/wasm';  // WASM version
```

The APIs are identical - you can swap implementations without changing your code. Start with JavaScript for simplicity, switch to WASM for performance, or mix both in the same codebase.

<Note>
Whether a method uses WASM or JavaScript under the hood is mostly transparent. The API remains consistent regardless of implementation.
</Note>

## When to Use WASM

We measure performance and bundle size for every operation in both JavaScript and WASM. Sometimes WASM is a clear winner, sometimes JavaScript is better.

### WASM is Better For:

**Cryptography** - Up to 3x faster with smaller bundle sizes:
```typescript
import { keccak256 } from '@tevm/voltaire/crypto/wasm';

// WASM: 3x faster + smaller bundle size
const hash = keccak256(data);
```

**EVM Operations** - Complex bytecode execution benefits from native performance:
```typescript
import { executeOpcode } from '@tevm/voltaire/evm/wasm';
```

**Encoding/Decoding with Crypto** - When operations involve cryptographic hashing:
```typescript
import { rlpEncode } from '@tevm/voltaire/primitives/wasm';
```

### JavaScript is Better For:

**Simple String Operations** - Native JavaScript is faster than WASM overhead:
```typescript
import { Hex } from '@tevm/voltaire/primitives';

// Pure JS: No WASM bridge overhead
const lowercase = Hex.toLowercase(hex);
```

**Small Operations** - When crossing the WASM boundary costs more than the operation itself.

## Performance

By default, Voltaire uses JavaScript implementations to maximize compatibility. You can opt into WASM for better performance and smaller bundle sizes when it makes sense for your use case.

<Note>
**No guarantees** - Default implementations and recommendations may change as we optimize. Always benchmark for your specific use case.
</Note>

### Benchmarks

Performance and bundle size comparison across implementations:

| Operation | JS Performance | WASM Performance | JS Bundle | WASM Bundle | Recommendation |
|-----------|----------------|------------------|-----------|-------------|----------------|
| **Cryptography** |
| keccak256 | _TBD_ | _TBD_ | _TBD_ | _TBD_ | WASM |
| secp256k1 sign | _TBD_ | _TBD_ | _TBD_ | _TBD_ | WASM |
| secp256k1 verify | _TBD_ | _TBD_ | _TBD_ | _TBD_ | WASM |
| secp256k1 recover | _TBD_ | _TBD_ | _TBD_ | _TBD_ | WASM |
| BLS12-381 sign | _TBD_ | _TBD_ | _TBD_ | _TBD_ | WASM |
| BLS12-381 verify | _TBD_ | _TBD_ | _TBD_ | _TBD_ | WASM |
| BLS12-381 aggregate | _TBD_ | _TBD_ | _TBD_ | _TBD_ | WASM |
| sha256 | _TBD_ | _TBD_ | _TBD_ | _TBD_ | WASM |
| ripemd160 | _TBD_ | _TBD_ | _TBD_ | _TBD_ | WASM |
| **Encoding** |
| RLP encode | _TBD_ | _TBD_ | _TBD_ | _TBD_ | JavaScript |
| RLP decode | _TBD_ | _TBD_ | _TBD_ | _TBD_ | JavaScript |
| ABI encode | _TBD_ | _TBD_ | _TBD_ | _TBD_ | JavaScript |
| ABI decode | _TBD_ | _TBD_ | _TBD_ | _TBD_ | JavaScript |
| **EVM** |
| Opcode execution | _TBD_ | _TBD_ | _TBD_ | _TBD_ | WASM |
| Bytecode analysis | _TBD_ | _TBD_ | _TBD_ | _TBD_ | WASM |
| **Primitives** |
| Address checksum | _TBD_ | _TBD_ | _TBD_ | _TBD_ | JavaScript |
| Hex encode | _TBD_ | _TBD_ | _TBD_ | _TBD_ | JavaScript |
| Hex decode | _TBD_ | _TBD_ | _TBD_ | _TBD_ | JavaScript |

**General recommendations:**
- **Cryptographic operations**: WASM typically 2-3x faster with smaller bundles
- **EVM operations**: WASM for complex bytecode execution
- **Simple encoding**: JavaScript avoids WASM bridge overhead
- **String operations**: JavaScript for native performance

## Zero Configuration

WASM implementations work out of the box in:
- Node.js
- Bun
- Browsers (Chrome, Firefox, Safari, Edge)
- Edge runtimes (Cloudflare Workers, Vercel Edge)

No webpack configuration, no bundler plugins, no deployment changes required.
