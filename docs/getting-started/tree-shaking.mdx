---
title: Tree-Shakeable
description: Data-first design enables maximum tree-shakeability and bundle optimization
---

Import only what you need - unused code automatically excluded from bundles.

## Data-First Design

Voltaire takes a **data-first approach** to Ethereum primitives. Core types are validated [branded types](/getting-started/branded-types) that separate data from operations, enabling maximum tree-shakeability.

**Data comes first.** Ethereum primitives are represented using the most idiomatic data type for each language:

<Tabs>
<Tab title="TypeScript">

- **Addresses** → 20-byte `Uint8Array`
- **Hashes** → 32-byte `Uint8Array`
- **Bytecode** → Variable-length `Uint8Array`
- **Hex strings** → Tagged `string`

These [branded types](/getting-started/branded-types) provide TypeScript safety with minimal runtime overhead. Methods operate on these types rather than encapsulating them in classes.

</Tab>

</Tabs>

## API Architecture

Voltaire provides a tree-shakeable API architecture for TypeScript built on data-first principles.

## How Classes Avoid Coupling

Voltaire's Class API uses `Object.setPrototypeOf()` to add methods without encapsulating data:

```typescript
// Factory function creates instance
export function Address(value) {
  const result = BrandedAddress(value);
  Object.setPrototypeOf(result, Address.prototype);
  return result;
}

// Instance method delegates to functional implementation
Address.prototype.toChecksummed = function() {
  return BrandedAddress.toChecksummed(this);
};

// Static method delegates to functional implementation
Address.toChecksummed = BrandedAddress.toChecksummed;
```

This architecture:
- Keeps data and operations decoupled
- Single source of truth in functional implementation
- Classes are thin wrappers over functional code
- Enables multiple API styles without duplicating logic

## Bundle Size Impact

For bundle-size sensitive applications, import only the functions you need:

```typescript
// Import specific functions (tree-shakeable)
import { fromHex, toChecksummed, isZero } from '@tevm/voltaire/Address';

const addr = fromHex('0x742d35Cc6634C0532925a3b844Bc9e7595f51e3e');
const checksummed = toChecksummed(addr);
```

Compared to importing the full class:

```typescript
// Class API imports entire prototype
import { Address } from '@tevm/voltaire';

const addr = Address('0x742d35Cc6634C0532925a3b844Bc9e7595f51e3e');
const checksummed = addr.toChecksummed();
```

Importing specific functions can save 2-5 KB per primitive in production bundles.

<Tip>
Importing from `@tevm/voltaire/Address` instead of `@tevm/voltaire` enables tree-shaking. For example, avoiding `toChecksummed()` excludes the entire keccak256 implementation (~50kb).
</Tip>

## Tree-Shaking with Class API

The Class API enables tree-shaking by importing only what you need:

```typescript
// Import specific functions (tree-shakeable)
import { fromHex, toChecksummed, calculateCreateAddress } from '@tevm/voltaire/Address';

const pipeline = (hex, nonce) =>
  toChecksummed(
    calculateCreateAddress(
      fromHex(hex),
      nonce
    )
  );
```

For method chaining, use the full imports:

```typescript
// Method chaining
import { Address } from '@tevm/voltaire';

const addr = Address('0x742d35Cc6634C0532925a3b844Bc9e7595f51e3e');
const checksummed = addr.toChecksummed();
```

## Performance

The Class API has negligible performance overhead:

- **Direct function imports**: Best for tree-shaking and bundle size
- **Class instances**: Prototype lookup adds ~0.5ns per method call (negligible)
- **Memory**: Class API uses ~100 bytes more per primitive type (prototype chain)

For typical applications, performance differences are unmeasurable. Choose based on code style and bundle size requirements.
