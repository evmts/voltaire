---
title: Effect.ts Integration
description: Functional, composable, type-safe APIs with Effect.ts
---

[Effect.ts](https://effect.website) is a functional programming library for TypeScript that brings powerful abstractions for building robust applications. Voltaire provides Effect.ts APIs as a first-class alternative to the vanilla TypeScript API.

## Why Effect.ts?

<CardGroup cols={3}>
  <Card title="Maximum Type-Safety" icon="shield-check">
    Errors are typed and handled explicitly in function signatures. No uncaught exceptions.
  </Card>
  <Card title="Composable & Testable" icon="puzzle-piece">
    Programs compose naturally. Dependencies injected through context for easy testing.
  </Card>
  <Card title="Rich Ecosystem" icon="cubes">
    Extensive standard library with streaming, scheduling, resource management, and more.
  </Card>
</CardGroup>

## Perfect for Robust Applications

Effect.ts shines in production environments where reliability matters:

- **Error handling** - All failure modes explicit in types
- **Dependency injection** - Services injected via Effect context
- **Testability** - Easy to mock services and test pure logic
- **Composability** - Small functions compose into complex programs
- **Resource safety** - Automatic cleanup with acquire/release patterns
- **Observability** - Built-in tracing, metrics, and logging

These capabilities make Effect ideal for backend services, blockchain infrastructure, and any application where correctness is critical.

## Effect.ts APIs

Voltaire treats Effect.ts as its own language with separate APIs. Currently implemented for:

- **Address** - Full Effect.ts API with service-based crypto operations

Additional primitives coming soon - looking for contributors!

## Example: Address with Effect.ts

The `AddressSchema` primitive demonstrates Effect.ts integration. Compare vanilla vs Effect approaches:

### Vanilla TypeScript API

```typescript
import * as Address from '@tevm/voltaire/Address';

// Simple operations - no crypto needed
const address = Address.from("0x742d35Cc6634C0532925a3b844Bc9e7595f51e3e");
const hex = Address.toHex(address);

// Crypto operations throw on error
try {
  const checksummed = Address.toChecksummed(address);
} catch (error) {
  // Error handling not explicit in types
  console.error('Checksum failed:', error);
}
```

### Effect.ts API with Schema

```typescript
import * as Effect from "effect/Effect";
import { AddressSchema, ChecksumAddress } from '@tevm/voltaire/primitives/Address/effect';
import { AddressServicesLive } from '@tevm/voltaire/primitives/Address/effect-layers';

// Create address with typed errors
const program = Effect.gen(function* () {
  // All errors explicit in type signature
  const address = yield* AddressSchema.fromHex(
    "0x742d35Cc6634C0532925a3b844Bc9e7595f51e3e"
  );

  // Crypto operations require service injection
  const checksummed = yield* address.toChecksummed();

  return checksummed;
});

// Provide crypto services and run
const result = await Effect.runPromise(
  program.pipe(Effect.provide(AddressServicesLive))
);
```

### Effect.ts API with Branded Types

```typescript
import { AddressBrand, ChecksumAddressBrand } from '@tevm/voltaire/primitives/Address/effect';

// Refined brand with validation
const bytes = new Uint8Array(20);
const addressBrand = AddressBrand(bytes); // Validates 20-byte length

// Nominal brand (no validation)
const checksumStr = "0x742d35Cc6634c0532925a3b844bc9e7595F251E3";
const checksumBrand = ChecksumAddressBrand(checksumStr);

// Zero-cost construction from brands
const schema = AddressSchema.fromBranded(addressBrand);
const checksumSchema = ChecksumAddress.fromBranded(checksumBrand);

// Access branded values
const brand = schema.branded; // Type: AddressBrand
```

## Effect Branded Types

Voltaire primitives provide Effect brands for compile-time type safety:

```typescript
import * as Brand from "effect/Brand";
import { AddressBrand, ChecksumAddressBrand } from '@tevm/voltaire/primitives/Address/effect';

// Refined brand - validates at construction
const validBytes = new Uint8Array(20);
const address: AddressBrand = AddressBrand(validBytes); // ✓ Passes

const invalidBytes = new Uint8Array(19);
AddressBrand(invalidBytes); // ✗ Throws: Expected 20 bytes, got 19

// Nominal brand - no runtime validation
const checksumStr = "0x742d35Cc6634c0532925a3b844bc9e7595F251E3";
const checksum: ChecksumAddressBrand = ChecksumAddressBrand(checksumStr);

// Type-safe at compile time
function processAddress(addr: AddressBrand) {
  // addr is guaranteed to be 20-byte Uint8Array
}

processAddress(address); // ✓ Type-safe
processAddress(validBytes); // ✗ Type error: not branded
```

Effect brands provide:
- **Zero runtime overhead** - Just type-level tags
- **Compile-time safety** - Prevents mixing incompatible types
- **Optional validation** - Refined brands validate, nominal brands don't
- **Interop** - Works with Effect ecosystem (Schema, Data, Match)

## Service-Based Architecture

Effect.ts APIs use services for crypto operations, enabling dependency injection:

```typescript
import * as Effect from "effect/Effect";
import { AddressSchema } from '@tevm/voltaire/primitives/Address/effect';
import { AddressServicesLive } from '@tevm/voltaire/primitives/Address/effect-layers';

// Program declares service dependencies in types
const deriveAddress = (privateKey: Uint8Array) =>
  Effect.gen(function* () {
    // Services injected via context
    const address = yield* AddressSchema.fromPrivateKey(privateKey);
    const checksummed = yield* address.toChecksummed();
    return checksummed;
  });

// Type signature shows all dependencies:
// Effect<Checksummed, FromPrivateKeyErrors | ToChecksummedErrors, Secp256k1Service | Keccak256Service>

// Provide all services at once
const result = await Effect.runPromise(
  deriveAddress(privateKey).pipe(
    Effect.provide(AddressServicesLive)
  )
);
```

## Typed Error Handling

All failure modes explicit in function signatures:

```typescript
import * as Effect from "effect/Effect";
import { AddressSchema } from '@tevm/voltaire/primitives/Address/effect';
import {
  InvalidHexFormatError,
  InvalidAddressLengthError
} from '@tevm/voltaire/primitives/Address/effect-errors';

const program = AddressSchema.fromHex("0x742d");

// Type: Effect<AddressSchema, FromHexErrors>
// FromHexErrors = InvalidHexFormatError | InvalidAddressLengthError | ...

// Handle specific errors
const handled = program.pipe(
  Effect.catchTag("InvalidHexFormatError", (error) =>
    Effect.succeed(AddressSchema.zero())
  ),
  Effect.catchTag("InvalidAddressLengthError", (error) =>
    Effect.fail(new CustomError(error))
  )
);
```

## Composable Operations

Effects compose naturally:

```typescript
import * as Effect from "effect/Effect";
import { AddressSchema } from '@tevm/voltaire/primitives/Address/effect';
import { AddressServicesLive } from '@tevm/voltaire/primitives/Address/effect-layers';

// Compose multiple operations
const deployContract = (deployer: Uint8Array, nonce: bigint, initCode: Uint8Array) =>
  Effect.gen(function* () {
    // Create deployer address
    const deployerAddr = yield* AddressSchema.fromBytes(deployer);

    // Calculate CREATE address
    const contractAddr = yield* deployerAddr.calculateCreateAddress(nonce);

    // Calculate CREATE2 address for comparison
    const salt = new Uint8Array(32);
    const create2Addr = yield* deployerAddr.calculateCreate2Address(salt, initCode);

    return { create: contractAddr, create2: create2Addr };
  });

// Run with all required services (Keccak256 + RlpEncoder)
const result = await Effect.runPromise(
  deployContract(deployer, 0n, bytecode).pipe(
    Effect.provide(AddressServicesLive)
  )
);
```

## Effect Schema Integration

`AddressSchema` extends `Schema.Class` for automatic encoding/decoding:

```typescript
import * as Schema from "effect/Schema";
import { AddressSchema, AddressBrand } from '@tevm/voltaire/primitives/Address/effect';

// Schema automatically validates
const TransferSchema = Schema.Struct({
  to: Schema.instanceOf(AddressSchema),
  from: Schema.instanceOf(AddressSchema),
  value: Schema.BigIntFromSelf
});

// Parse and validate
const transfer = Schema.decodeUnknownSync(TransferSchema)({
  to: AddressSchema.fromHex("0x742d35Cc6634C0532925a3b844Bc9e7595f51e3e"),
  from: AddressSchema.fromHex("0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045"),
  value: 1000000000000000000n
});

// Access underlying branded types
const toBrand: AddressBrand = transfer.to.branded;
const fromBrand: AddressBrand = transfer.from.branded;

// Zero-cost construction from brands
const quickTransfer = {
  to: AddressSchema.fromBranded(toBrand),
  from: AddressSchema.fromBranded(fromBrand),
  value: 2000000000000000000n
};
```

## Source Code

See the complete Effect.ts implementation:

[`src/primitives/Address/effect.ts`](https://github.com/evmts/voltaire/blob/main/src/primitives/Address/effect.ts)

Key features demonstrated:
- **Effect Schema** - `Schema.Class` with automatic validation
- **Effect Brands** - Refined (`AddressBrand`) and nominal (`ChecksumAddressBrand`) brands
- **Service-based crypto** - Keccak256, Secp256k1, RLP with dependency injection
- **Typed errors** - All failure modes explicit in function signatures
- **Composable methods** - fromPrivateKey, toChecksummed, calculateCreateAddress, etc.
- **Effect generators** - Clean async/error handling with Effect.gen
- **Zero-cost interop** - `.branded` getter and `.fromBranded()` for efficient construction

## Contributing

**We're looking for contributors to add Effect.ts support across Voltaire.**

Effect.ts is treated as a first-class API alongside the vanilla TypeScript API. Each primitive should have:

1. **Schema Classes** - Extend `Schema.Class` with validation
2. **Effect Brands** - Use `Brand.refined()` for validated types, `Brand.nominal()` for nominal types
3. **Service Definitions** - Interfaces for crypto/encoding operations
4. **Layer Implementations** - Default service implementations
5. **Error Types** - Tagged errors for each failure mode
6. **Composable Methods** - Operations that use Effect.gen
7. **Brand Interop** - `.branded` getter and `.fromBranded()` static method

Priority primitives for Effect.ts support:
- **Signature** - Sign/verify with typed errors
- **Transaction** - Encode/decode with RLP service
- **Hash** - Hashing with Keccak256 service
- **Bytecode** - Analysis with composable validation

See [`src/primitives/Address/effect.ts`](https://github.com/evmts/voltaire/blob/main/src/primitives/Address/effect.ts) as the reference implementation.

**Interested in contributing?** Open an issue or PR at [github.com/evmts/voltaire](https://github.com/evmts/voltaire).

## Learn More

<CardGroup cols={3}>
  <Card title="Effect.ts Docs" icon="book" href="https://effect.website/docs/introduction">
    Official Effect.ts documentation
  </Card>
  <Card title="Address Effect API" icon="cube" href="/primitives/address">
    Complete Address reference with Effect.ts examples
  </Card>
  <Card title="Effect Schema" icon="shield-check" href="https://effect.website/docs/schema/introduction">
    Schema validation with Effect.ts
  </Card>
</CardGroup>
