---
title: Keccak256
description: Ethereum's primary hashing algorithm for addresses, topics, and function selectors
---

# Keccak256

Keccak256 is a **cryptographic one-way hash function** based on the sponge construction that produces a fixed 32-byte digest from arbitrary-length input.

## Overview

**Mainnet-critical algorithm** - Used in Ethereum execution layer for transaction hashing, address derivation (last 20 bytes of hash), function selectors (first 4 bytes), event topics, and Merkle Patricia tree state roots.

Voltaire provides Keccak256 as a **namespace with multiple implementation variants**:
- `Keccak256` - Default pure TypeScript (auto-selected)
- `Keccak256.noble` - Explicit @noble/hashes reference
- `Keccak256.wasm` - WASM implementation
- `Keccak256.native` - Assembly-optimized (Node.js/Bun/Deno FFI)
- `Keccak256.accel` - SIMD/AVX2 hardware acceleration (x86-64)

All variants share the same data-first API and return `BrandedHash` type.

Keccak256 is fundamental to Ethereum's security model:
- **Address derivation**: Computing Ethereum addresses from public keys (last 20 bytes of Keccak256(publicKey))
- **Function selectors**: First 4 bytes of Keccak256(signature) identify contract methods
- **Event topics**: Keccak256(eventSignature) creates indexed event identifiers
- **Merkle Patricia trees**: Hashing transaction and state trie nodes
- **Contract addresses**: CREATE and CREATE2 address calculation

<Warning title="SHA-3 vs Keccak Distinction">
Ethereum uses the original Keccak-256 algorithm (pre-NIST), NOT the finalized SHA-3 standard. They differ in padding scheme: SHA-3 uses `0x06` padding while Keccak uses `0x01`. Do not use SHA-3 libraries for Ethereum - they will produce incorrect results. Use Keccak-256 specifically.
</Warning>

## Implementation Variants

Voltaire provides four Keccak256 implementations, each optimized for different use cases:

### 1. Default (Pure TypeScript)
Uses @noble/hashes - zero native dependencies, maximum compatibility.

```typescript
import { Keccak256 } from '@tevm/voltaire/crypto/Keccak256';

const hash = Keccak256.hash(data);
// Pure TypeScript, ~100-200 MB/s
// Works everywhere: browsers, Node.js, Deno, Bun, edge workers
```

**When to use:**
- Universal compatibility required
- No build complexity
- Default choice for most applications
- Trust in @noble/hashes battle-tested implementation

### 2. WASM Implementation
Compiled from Zig's stdlib Keccak256 via unified loader (ReleaseSmall).

```typescript
import { Keccak256Wasm } from '@tevm/voltaire/crypto/keccak256.wasm';

await Keccak256Wasm.init();
const hash = Keccak256Wasm.hash(data);
// WASM, ~200-400 MB/s
// 2-4x faster than pure JS
```

**When to use:**
- Need better performance than pure JS
- Browser/edge environments
- Acceptable init() overhead
- Bundled as part of Voltaire primitives.wasm

### 3. Native Assembly (keccak-asm)
Platform-optimized assembly via keccak-asm Rust crate with FFI bindings.

```typescript
import { Keccak256Native } from '@tevm/voltaire/native/crypto/keccak256';

const hash = Keccak256Native.hash(data);
// Assembly-optimized, ~500-1000 MB/s
// x86-64: AVX2/SSE2 instructions
// ARM: NEON instructions
```

**When to use:**
- Node.js, Bun, or Deno with native modules
- Maximum throughput required
- Processing large volumes of data
- 3-10x faster than pure JavaScript

### 4. Hardware Acceleration (SIMD/AVX2)
SIMD-accelerated implementation using AVX2 vector operations (x86-64 only).

```typescript
import { Keccak256Accel } from '@tevm/voltaire/native/crypto/keccak256-accel';

const hash = Keccak256Accel.hash(data);
// SIMD/AVX2, ~800+ MB/s (x86-64 only)
// Auto-detects CPU features, falls back to software
```

**When to use:**
- x86-64 processors with AVX2 support
- EVM node implementations
- High-throughput blockchain applications
- CPU feature detection at runtime

## Implementation Selection Guide

Choose the right implementation based on your environment and performance needs:

| Environment | Recommended | Why |
|------------|-------------|-----|
| **Browser** | Keccak256 (default) | Universal compatibility, zero setup |
| **Browser + Performance** | Keccak256Wasm | 2-4x faster, small bundle overhead |
| **Node.js/Bun/Deno** | Keccak256Native | 3-10x faster with native FFI |
| **High-throughput** | Keccak256Accel | Maximum performance on x86-64 AVX2 |
| **Edge Workers** | Keccak256 or Keccak256Wasm | Depends on WASM support |
| **Universal Library** | Keccak256 (default) | Works everywhere |

### Performance Comparison

Typical throughput on modern hardware (M1 Pro, i7-12700K):

| Implementation | Small (32B) | Medium (256B) | Large (4KB) | Platform |
|---------------|-------------|---------------|-------------|----------|
| **Keccak256** (noble) | ~150 MB/s | ~180 MB/s | ~200 MB/s | Universal |
| **Keccak256Wasm** | ~300 MB/s | ~350 MB/s | ~400 MB/s | WASM |
| **Keccak256Native** | ~600 MB/s | ~800 MB/s | ~1000 MB/s | x86-64/ARM |
| **Keccak256Accel** | ~700 MB/s | ~850 MB/s | ~1100 MB/s | x86-64 AVX2 |

*Benchmarks vary by CPU, input size, and runtime environment.*

## Dependency Injection Pattern

All implementations share the same data-first API, enabling runtime algorithm selection:

```typescript
import { Keccak256 } from '@tevm/voltaire/crypto/Keccak256';
import { Keccak256Wasm } from '@tevm/voltaire/crypto/keccak256.wasm';
import { Keccak256Native } from '@tevm/voltaire/native/crypto/keccak256';

// All have identical API
const hash1 = Keccak256.hash(data);
const hash2 = Keccak256Wasm.hash(data);
const hash3 = Keccak256Native.hash(data);

// Dynamic selection based on environment
function selectImplementation() {
  // Check for native FFI support
  if (typeof process !== 'undefined' && process.versions?.node) {
    return Keccak256Native;
  }
  // Check for WASM support
  if (typeof WebAssembly !== 'undefined') {
    return Keccak256Wasm;
  }
  // Fallback to pure JS
  return Keccak256;
}

const impl = selectImplementation();
const result = impl.hash(data);
```

## Quick Start

<Tabs>
<Tab title="Basic Hashing">
```typescript
import { Keccak256 } from '@tevm/voltaire/crypto/keccak256';
import { Hex } from '@tevm/voltaire/primitives/Hex';

// Hash bytes
const data = Hex.toBytes('0x0102030405');
const hash = Keccak256.hash(data);
// Uint8Array(32) [...]

// Hash string (UTF-8 encoded)
const stringHash = Keccak256.hashString('hello');
// Uint8Array(32) [...]

// Hash hex string
const hexHash = Keccak256.hashHex('0x1234abcd');
// Uint8Array(32) [...]
```
</Tab>

<Tab title="Ethereum Functions">
```typescript
import { Keccak256 } from '@tevm/voltaire/crypto/keccak256';

// Compute function selector
const selector = Keccak256.selector('transfer(address,uint256)');
// Uint8Array(4) [0xa9, 0x05, 0x9c, 0xbb]

// Compute event topic
const topic = Keccak256.topic('Transfer(address,address,uint256)');
// Uint8Array(32) [full 32-byte hash]

// Calculate contract address (CREATE)
import { Address } from '@tevm/voltaire/primitives/Address';

const deployerAddress = Address('0x742d35Cc6634C0532925a3b844Bc9e7595f51e3e');
const nonce = 5n;
const contractAddr = Keccak256.contractAddress(deployerAddress, nonce);
// Uint8Array(20) [contract address]

// Calculate contract address (CREATE2)
import { Bytes32 } from '@tevm/voltaire/primitives/Bytes32';
import { Bytecode } from '@tevm/voltaire/primitives/Bytecode';

const salt = Bytes32('0x0000000000000000000000000000000000000000000000000000000000000001');
const initCode = Bytecode('0x60806040523480156100105760006000fd5b50610015565b60c3806100236000396000f3fe');
const create2Addr = Keccak256.create2Address(deployerAddress, salt, initCode);
// Uint8Array(20) [deterministic contract address]
```
</Tab>

<Tab title="Multiple Chunks">
```typescript
import { Keccak256 } from '@tevm/voltaire/crypto/keccak256';
import { Hex } from '@tevm/voltaire/primitives/Hex';

// Hash multiple data chunks (equivalent to concatenating them first)
const chunk1 = Hex.toBytes('0x010203');
const chunk2 = Hex.toBytes('0x040506');
const chunk3 = Hex.toBytes('0x070809');

const hash = Keccak256.hashMultiple([chunk1, chunk2, chunk3]);
// Same as: Keccak256.hash(Hex.toBytes('0x010203040506070809'))
```
</Tab>
</Tabs>

## API Reference

### `Keccak256.hash(data: Uint8Array): BrandedHash`

Hash arbitrary bytes with Keccak-256.

**Parameters:**
- `data`: Input data to hash (Uint8Array)

**Returns:** 32-byte hash (BrandedHash extends Uint8Array)

**Example:**
```typescript
import { Hex } from '@tevm/voltaire/primitives/Hex';

const hash = Keccak256.hash(Hex.toBytes('0x010203'));
console.log(hash.length); // 32
```

---

### `Keccak256.hashString(str: string): BrandedHash`

Hash UTF-8 string with Keccak-256.

String is UTF-8 encoded before hashing using TextEncoder.

**Parameters:**
- `str`: String to hash

**Returns:** 32-byte hash (BrandedHash)

**Example:**
```typescript
const hash = Keccak256.hashString('hello');
// Equivalent to: Keccak256.hash(new TextEncoder().encode('hello'))
```

---

### `Keccak256.hashHex(hex: string): BrandedHash`

Hash hex-encoded string with Keccak-256.

Hex string is decoded to bytes before hashing. Supports both "0x"-prefixed and unprefixed hex.

**Parameters:**
- `hex`: Hex string to hash

**Returns:** 32-byte hash (BrandedHash)

**Example:**
```typescript
const hash = Keccak256.hashHex('0x1234');
```

---

### `Keccak256.hashMultiple(chunks: readonly Uint8Array[]): BrandedHash`

Hash multiple data chunks in sequence.

Equivalent to hashing the concatenation of all chunks, but can be more efficient for pre-chunked data.

**Parameters:**
- `chunks`: Array of data chunks to hash

**Returns:** 32-byte hash (BrandedHash)

**Example:**
```typescript
import { Hex } from '@tevm/voltaire/primitives/Hex';

const hash = Keccak256.hashMultiple([
  Hex.toBytes('0x0102'),
  Hex.toBytes('0x0304'),
  Hex.toBytes('0x0506')
]);
```

---

### `Keccak256.selector(signature: string): Uint8Array`

Compute function selector (first 4 bytes of Keccak-256 hash).

Used in Ethereum to identify contract functions in transaction calldata. The function selector is the first 4 bytes of the Keccak-256 hash of the function signature.

**Parameters:**
- `signature`: Function signature string (e.g., "transfer(address,uint256)")

**Returns:** 4-byte selector

**Example:**
```typescript
const selector = Keccak256.selector('transfer(address,uint256)');
// Uint8Array(4) [0xa9, 0x05, 0x9c, 0xbb]

// Used in transaction calldata:
// 0xa9059cbb + ABI-encoded parameters
```

---

### `Keccak256.topic(signature: string): BrandedHash`

Compute event topic (32-byte Keccak-256 hash).

Used for Ethereum event signatures in logs. Topics are the full 32-byte hash of the event signature.

**Parameters:**
- `signature`: Event signature string (e.g., "Transfer(address,address,uint256)")

**Returns:** 32-byte topic (BrandedHash)

**Example:**
```typescript
const topic = Keccak256.topic('Transfer(address,address,uint256)');
// Full 32-byte hash used in logs.topics[0]
```

---

### `Keccak256.contractAddress(sender: Uint8Array, nonce: bigint): Uint8Array`

Compute contract address from deployer and nonce (CREATE).

Uses CREATE formula: `address = keccak256(rlp([sender, nonce]))[12:]`

**Parameters:**
- `sender`: Deployer address (20 bytes)
- `nonce`: Transaction nonce

**Returns:** Contract address (20 bytes)

**Throws:** Error if sender is not 20 bytes

**Example:**
```typescript
import { Address } from '@tevm/voltaire/primitives/Address';

const deployer = Address('0x742d35Cc6634C0532925a3b844Bc9e7595f51e3e');
const nonce = 5n;
const contractAddr = Keccak256.contractAddress(deployer, nonce);
```

---

### `Keccak256.create2Address(deployer: Uint8Array, salt: Uint8Array | bigint, initCode: Uint8Array): Uint8Array`

Compute contract address using CREATE2.

Uses CREATE2 formula: `address = keccak256(0xff ++ sender ++ salt ++ keccak256(initCode))[12:]`

This allows deterministic contract addresses independent of nonce.

**Parameters:**
- `deployer`: Deployer address (20 bytes)
- `salt`: 32-byte salt (or bigint converted to 32 bytes)
- `initCode`: Contract initialization bytecode

**Returns:** Contract address (20 bytes)

**Example:**
```typescript
import { Address } from '@tevm/voltaire/primitives/Address';
import { Bytes32 } from '@tevm/voltaire/primitives/Bytes32';
import { Bytecode } from '@tevm/voltaire/primitives/Bytecode';

const deployer = Address('0x742d35Cc6634C0532925a3b844Bc9e7595f51e3e');
const salt = Bytes32('0x0000000000000000000000000000000000000000000000000000000000000001');
const initCode = Bytecode('0x60806040523480156100105760006000fd5b50610015565b60c3806100236000396000f3fe');
const create2Addr = Keccak256.create2Address(deployer, salt, initCode);
```

## Constants

```typescript
Keccak256.DIGEST_SIZE  // 32 - Output size in bytes
Keccak256.RATE         // 136 - Rate in bytes (1088 bits)
Keccak256.STATE_SIZE   // 25 - State size (25 u64 words)
```

## Test Vectors

Known Keccak256 test vectors for validation:

```typescript
// Empty string
Keccak256.hashString("")
// 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470

// "abc"
Keccak256.hashString("abc")
// 0x4e03657aea45a94fc7d47ba826c8d667c0d1e6e33a64a036ec44f58fa12d6c45

// "hello"
Keccak256.hashString("hello")
// 0x1c8aff950685c2ed4bc3174f3472287b56d9517b9c948127319a09a7a36deac8

// "The quick brown fox jumps over the lazy dog"
Keccak256.hashString("The quick brown fox jumps over the lazy dog")
// 0x4d741b6f1eb29cb2a9b9911c82f56fa8d73b04959d3d9d222895df6c0b28aa15

// transfer(address,uint256) selector
Keccak256.selector("transfer(address,uint256)")
// Uint8Array(4) [0xa9, 0x05, 0x9c, 0xbb]
```

## Security Considerations

### Collision Resistance
Keccak256 provides strong collision resistance with 128-bit security. Finding two inputs that produce the same hash is computationally infeasible.

### Preimage Resistance
Given a hash output, finding an input that produces that hash requires ~2^256 operations, making it practically impossible.

### Second Preimage Resistance
Given an input and its hash, finding a different input with the same hash requires ~2^256 operations.

### Ethereum-Specific Notes
- **Deterministic**: Same input always produces same output
- **One-way**: Hash output cannot be reversed to recover input
- **Avalanche effect**: Small input changes cause large output changes
- **Constant-time**: Implementation avoids timing side-channels

## Performance

### Performance Comparison
Typical throughput on modern hardware (varies by platform and CPU):

| Implementation | Throughput | Use Case |
|---------------|-----------|----------|
| Native/Assembly | ~500-1000 MB/s | Node.js/Bun/Deno with FFI |
| WASM (Unified/Standalone) | ~200-400 MB/s | Browsers, edge workers |
| Pure JS (@noble) | ~100-200 MB/s | Universal compatibility |

Hardware acceleration provides 3-10x speedup over pure JavaScript. WASM offers 2-4x improvement with broader compatibility than native bindings.

## Implementation Details

### Pure TypeScript (Default)
Uses @noble/hashes Keccak-256 implementation:
```typescript
import { keccak_256 } from "@noble/hashes/sha3.js";

export function hash(data: Uint8Array): BrandedHash {
  return keccak_256(data) as BrandedHash;
}
```

**Characteristics:**
- Zero native dependencies
- Constant-time implementation
- Runs everywhere (Node.js, browsers, Deno, Bun, edge)
- ~100-200 MB/s throughput

### WASM Variants
Compiled from Zig's stdlib Keccak-256 implementation.

**Unified WASM** (`keccak256.wasm`):
- Part of main primitives.wasm bundle
- Includes all Voltaire primitives and crypto
- Requires init() before use

**Standalone WASM** (`keccak256.standalone`):
- Only Keccak-256 implementation
- ~3KB bundle size
- Ideal for minimal deployments
- Independent memory management

```typescript
// Unified
import { Keccak256Wasm } from '@tevm/voltaire/crypto/keccak256.wasm';
await Keccak256Wasm.init();
const hash = Keccak256Wasm.hash(data);

// Standalone
import { Keccak256Standalone } from '@tevm/voltaire/crypto/keccak256.standalone';
await Keccak256Standalone.init();
const hash = Keccak256Standalone.hash(data);
```

### Native/Assembly
Uses keccak-asm Rust crate with platform-optimized assembly.

**Characteristics:**
- x86-64: AVX2/SSE2 instructions
- ARM: NEON instructions
- ~500-1000 MB/s throughput
- Requires FFI bindings (Node.js, Bun, Deno native modules)

Implementation in Zig (`keccak_asm.zig`):
```zig
pub fn keccak256(data: []const u8, out_hash: *[32]u8) !void {
    if (builtin.target.cpu.arch == .wasm32) {
        // WASM: use standard library
        std.crypto.hash.sha3.Keccak256.hash(data, out_hash, .{});
        return;
    }
    // Native: use assembly-optimized C wrapper
    const result = c.keccak256(data.ptr, data.len, out_hash, 32);
    try keccakResultToError(result);
}
```

## Related

- [Hash Primitive](/primitives/hash) - 32-byte hash type used by Keccak256
- [Address](/primitives/address) - Address derivation uses Keccak256
- [SHA256](/crypto/sha256) - Alternative hash function
- [RIPEMD160](/crypto/ripemd160) - Used in Bitcoin address derivation
- [Blake2](/crypto/blake2) - High-performance alternative hash
