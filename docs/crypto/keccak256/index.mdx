---
title: Keccak256
description: Ethereum's primary hashing algorithm for addresses, topics, and function selectors
---

# Keccak256

Ethereum's primary cryptographic hash function (SHA-3 variant)

## Overview

Keccak256 is the cryptographic hash function used throughout Ethereum. It produces a 32-byte (256-bit) digest from arbitrary-length input data. While standardized SHA-3 uses different padding than Keccak, Ethereum adopted the original Keccak specification before SHA-3 finalization.

Keccak256 is fundamental to Ethereum's security model, used for:
- **Address derivation**: Computing Ethereum addresses from public keys (last 20 bytes of Keccak256(publicKey))
- **Function selectors**: First 4 bytes of Keccak256(signature) identify contract methods
- **Event topics**: Keccak256(eventSignature) creates indexed event identifiers
- **Merkle trees**: Hashing transaction and state trie nodes
- **Contract addresses**: CREATE and CREATE2 address calculation

The implementation uses @noble/hashes in TypeScript and hardware-accelerated assembly (keccak-asm) in Zig for optimal performance.

## Quick Start

<Tabs>
<Tab title="Basic Hashing">
```typescript
import { Keccak256 } from '@tevm/voltaire/crypto/keccak256';

// Hash bytes
const data = new Uint8Array([1, 2, 3, 4, 5]);
const hash = Keccak256.hash(data);
// Uint8Array(32) [...]

// Hash string (UTF-8 encoded)
const stringHash = Keccak256.hashString('hello');
// Uint8Array(32) [...]

// Hash hex string
const hexHash = Keccak256.hashHex('0x1234abcd');
// Uint8Array(32) [...]
```
</Tab>

<Tab title="Ethereum Functions">
```typescript
import { Keccak256 } from '@tevm/voltaire/crypto/keccak256';

// Compute function selector
const selector = Keccak256.selector('transfer(address,uint256)');
// Uint8Array(4) [0xa9, 0x05, 0x9c, 0xbb]

// Compute event topic
const topic = Keccak256.topic('Transfer(address,address,uint256)');
// Uint8Array(32) [full 32-byte hash]

// Calculate contract address (CREATE)
const deployerAddress = Address.from('0x742d35Cc6634C0532925a3b844Bc9e7595f51e3e');
const nonce = 5n;
const contractAddr = Keccak256.contractAddress(deployerAddress, nonce);
// Uint8Array(20) [contract address]

// Calculate contract address (CREATE2)
const salt = Bytes32.from('0x0000000000000000000000000000000000000000000000000000000000000001');
const initCode = Bytecode.from('0x60806040523480156100105760006000fd5b50610015565b60c3806100236000396000f3fe');
const create2Addr = Keccak256.create2Address(deployerAddress, salt, initCode);
// Uint8Array(20) [deterministic contract address]
```
</Tab>

<Tab title="Multiple Chunks">
```typescript
import { Keccak256 } from '@tevm/voltaire/crypto/keccak256';

// Hash multiple data chunks (equivalent to concatenating them first)
const chunk1 = new Uint8Array([1, 2, 3]);
const chunk2 = new Uint8Array([4, 5, 6]);
const chunk3 = new Uint8Array([7, 8, 9]);

const hash = Keccak256.hashMultiple([chunk1, chunk2, chunk3]);
// Same as: Keccak256.hash(new Uint8Array([1,2,3,4,5,6,7,8,9]))
```
</Tab>
</Tabs>

## API Reference

### `Keccak256.hash(data: Uint8Array): BrandedHash`

Hash arbitrary bytes with Keccak-256.

**Parameters:**
- `data`: Input data to hash (Uint8Array)

**Returns:** 32-byte hash (BrandedHash extends Uint8Array)

**Example:**
```typescript
const hash = Keccak256.hash(new Uint8Array([1, 2, 3]));
console.log(hash.length); // 32
```

---

### `Keccak256.hashString(str: string): BrandedHash`

Hash UTF-8 string with Keccak-256.

String is UTF-8 encoded before hashing using TextEncoder.

**Parameters:**
- `str`: String to hash

**Returns:** 32-byte hash (BrandedHash)

**Example:**
```typescript
const hash = Keccak256.hashString('hello');
// Equivalent to: Keccak256.hash(new TextEncoder().encode('hello'))
```

---

### `Keccak256.hashHex(hex: string): BrandedHash`

Hash hex-encoded string with Keccak-256.

Hex string is decoded to bytes before hashing. Supports both "0x"-prefixed and unprefixed hex.

**Parameters:**
- `hex`: Hex string to hash

**Returns:** 32-byte hash (BrandedHash)

**Example:**
```typescript
const hash = Keccak256.hashHex('0x1234');
```

---

### `Keccak256.hashMultiple(chunks: readonly Uint8Array[]): BrandedHash`

Hash multiple data chunks in sequence.

Equivalent to hashing the concatenation of all chunks, but can be more efficient for pre-chunked data.

**Parameters:**
- `chunks`: Array of data chunks to hash

**Returns:** 32-byte hash (BrandedHash)

**Example:**
```typescript
const hash = Keccak256.hashMultiple([
  new Uint8Array([1, 2]),
  new Uint8Array([3, 4]),
  new Uint8Array([5, 6])
]);
```

---

### `Keccak256.selector(signature: string): Uint8Array`

Compute function selector (first 4 bytes of Keccak-256 hash).

Used in Ethereum to identify contract functions in transaction calldata. The function selector is the first 4 bytes of the Keccak-256 hash of the function signature.

**Parameters:**
- `signature`: Function signature string (e.g., "transfer(address,uint256)")

**Returns:** 4-byte selector

**Example:**
```typescript
const selector = Keccak256.selector('transfer(address,uint256)');
// Uint8Array(4) [0xa9, 0x05, 0x9c, 0xbb]

// Used in transaction calldata:
// 0xa9059cbb + ABI-encoded parameters
```

---

### `Keccak256.topic(signature: string): BrandedHash`

Compute event topic (32-byte Keccak-256 hash).

Used for Ethereum event signatures in logs. Topics are the full 32-byte hash of the event signature.

**Parameters:**
- `signature`: Event signature string (e.g., "Transfer(address,address,uint256)")

**Returns:** 32-byte topic (BrandedHash)

**Example:**
```typescript
const topic = Keccak256.topic('Transfer(address,address,uint256)');
// Full 32-byte hash used in logs.topics[0]
```

---

### `Keccak256.contractAddress(sender: Uint8Array, nonce: bigint): Uint8Array`

Compute contract address from deployer and nonce (CREATE).

Uses CREATE formula: `address = keccak256(rlp([sender, nonce]))[12:]`

**Parameters:**
- `sender`: Deployer address (20 bytes)
- `nonce`: Transaction nonce

**Returns:** Contract address (20 bytes)

**Throws:** Error if sender is not 20 bytes

**Example:**
```typescript
const deployer = Address.from('0x742d35Cc6634C0532925a3b844Bc9e7595f51e3e');
const nonce = 5n;
const contractAddr = Keccak256.contractAddress(deployer, nonce);
```

---

### `Keccak256.create2Address(deployer: Uint8Array, salt: Uint8Array | bigint, initCode: Uint8Array): Uint8Array`

Compute contract address using CREATE2.

Uses CREATE2 formula: `address = keccak256(0xff ++ sender ++ salt ++ keccak256(initCode))[12:]`

This allows deterministic contract addresses independent of nonce.

**Parameters:**
- `deployer`: Deployer address (20 bytes)
- `salt`: 32-byte salt (or bigint converted to 32 bytes)
- `initCode`: Contract initialization bytecode

**Returns:** Contract address (20 bytes)

**Example:**
```typescript
const deployer = Address.from('0x742d35Cc6634C0532925a3b844Bc9e7595f51e3e');
const salt = Bytes32.from('0x0000000000000000000000000000000000000000000000000000000000000001');
const initCode = Bytecode.from('0x60806040523480156100105760006000fd5b50610015565b60c3806100236000396000f3fe');
const create2Addr = Keccak256.create2Address(deployer, salt, initCode);
```

## Constants

```typescript
Keccak256.DIGEST_SIZE  // 32 - Output size in bytes
Keccak256.RATE         // 136 - Rate in bytes (1088 bits)
Keccak256.STATE_SIZE   // 25 - State size (25 u64 words)
```

## Test Vectors

Known Keccak256 test vectors for validation:

```typescript
// Empty string
Keccak256.hashString("")
// 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470

// "abc"
Keccak256.hashString("abc")
// 0x4e03657aea45a94fc7d47ba826c8d667c0d1e6e33a64a036ec44f58fa12d6c45

// "hello"
Keccak256.hashString("hello")
// 0x1c8aff950685c2ed4bc3174f3472287b56d9517b9c948127319a09a7a36deac8

// "The quick brown fox jumps over the lazy dog"
Keccak256.hashString("The quick brown fox jumps over the lazy dog")
// 0x4d741b6f1eb29cb2a9b9911c82f56fa8d73b04959d3d9d222895df6c0b28aa15

// transfer(address,uint256) selector
Keccak256.selector("transfer(address,uint256)")
// Uint8Array(4) [0xa9, 0x05, 0x9c, 0xbb]
```

## Security Considerations

### Collision Resistance
Keccak256 provides strong collision resistance with 128-bit security. Finding two inputs that produce the same hash is computationally infeasible.

### Preimage Resistance
Given a hash output, finding an input that produces that hash requires ~2^256 operations, making it practically impossible.

### Second Preimage Resistance
Given an input and its hash, finding a different input with the same hash requires ~2^256 operations.

### Ethereum-Specific Notes
- **Not SHA-3**: Ethereum uses the original Keccak specification, which differs from finalized SHA-3 in padding
- **Deterministic**: Same input always produces same output
- **One-way**: Hash output cannot be reversed to recover input
- **Avalanche effect**: Small input changes cause large output changes

<Warning title="SHA-3 vs Keccak">
Ethereum uses the original Keccak-256 algorithm, NOT NIST's finalized SHA-3. They differ in padding scheme. Do not use SHA-3 libraries for Ethereum - use Keccak-256 specifically.
</Warning>

## Performance

### Hardware Acceleration
- **TypeScript**: Uses @noble/hashes (pure JS, constant-time)
- **Zig/Native**: Uses keccak-asm with optimized assembly for x86-64 and ARM
- **WASM**: Available via keccak256.wasm.ts for browser environments

### Benchmarks
Typical performance (varies by platform):
- Native (Zig): ~500-1000 MB/s
- WASM: ~200-400 MB/s
- Pure JS: ~100-200 MB/s

Hardware acceleration provides 3-10x speedup over pure JavaScript depending on platform.

## Implementation Details

### TypeScript Implementation
Uses @noble/hashes pure TypeScript Keccak-256 implementation:
```typescript
import { keccak_256 } from "@noble/hashes/sha3.js";

export function hash(data: Uint8Array): BrandedHash {
  return keccak_256(data) as BrandedHash;
}
```

### Zig Implementation
Zig implementation uses hardware-accelerated assembly via Rust's keccak-asm crate:
- **x86-64**: Uses vectorized instructions (AVX2/SHA extensions when available)
- **ARM**: Uses NEON SIMD instructions
- **Fallback**: Optimized software implementation

### WASM
Available via `keccak256.wasm.ts` for browser environments. Compiled from Zig with wasm32-wasi target.

```typescript
import { Keccak256Wasm } from '@tevm/voltaire/crypto/keccak256.wasm';
await Keccak256Wasm.init();
const hash = Keccak256Wasm.hash(data);
```

## Related

- [Hash Primitive](/primitives/hash) - 32-byte hash type used by Keccak256
- [Address](/primitives/address) - Address derivation uses Keccak256
- [SHA256](/crypto/sha256) - Alternative hash function
- [RIPEMD160](/crypto/ripemd160) - Used in Bitcoin address derivation
- [Blake2](/crypto/blake2) - High-performance alternative hash
