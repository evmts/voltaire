---
title: BLS12-381
description: Pairing-friendly elliptic curve for Ethereum 2.0 consensus, signature aggregation, and EIP-2537 precompiles
---

# BLS12-381

Pairing-friendly elliptic curve designed for Ethereum 2.0 consensus layer signatures, efficient signature aggregation, and polynomial commitments. BLS12-381 provides 128-bit security with optimal performance for blockchain applications.

## Overview

BLS12-381 is a Barreto-Lynn-Scott pairing-friendly curve specifically designed for blockchain use cases requiring signature aggregation and zero-knowledge proofs. Named after its designers and 381-bit prime field, it has become the standard for Ethereum's proof-of-stake consensus.

### Why BLS12-381?

**Security**: 128-bit security level (comparable to 3072-bit RSA or 256-bit ECDSA)

**Efficiency**: Fastest pairing computation among comparable security curves

**Adoption**: Standard across major blockchains (Ethereum 2.0, Zcash, Filecoin, Chia)

**Signature Aggregation**: Unique property enabling compact validator signatures

### Ethereum Use Cases

- **Validator Signatures**: Aggregate thousands of validator signatures into 96 bytes
- **Sync Committees**: Light client proofs with compact signature aggregation
- **Cross-Chain Bridges**: Trustless interoperability with zkSNARK integration
- **Polynomial Commitments**: KZG commitments for data availability (EIP-4844)
- **Future DeFi**: Privacy-preserving protocols and zero-knowledge proofs

## Mathematical Foundation

### Curve Equation

**G1 (base field Fp)**:
```
y² = x³ + 4
```

**G2 (extension field Fp2)**:
```
y² = x³ + 4(1 + i)
```

### Field Parameters

**Base Field Modulus (p)**: 381-bit prime
```
p = 0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab
```

**Scalar Field Modulus (r)**: 255-bit prime (curve order)
```
r = 0x73eda753299d7d483339d80809a1d80553bda402fffe5bfeffffffff00000001
```

**Embedding Degree**: k = 12

**Extension Tower**: Fp → Fp2 → Fp6 → Fp12

### Pairing Function

**Optimal Ate Pairing**: `e: G1 × G2 → GT`

**Properties**:
- **Bilinearity**: `e(aP, bQ) = e(P, Q)^(ab)`
- **Non-degeneracy**: `e(G1, G2) ≠ 1` (identity in GT)
- **Efficiency**: ~1-2ms computation on modern CPUs

**Pairing Check**:
```
e(P1, Q1) · e(P2, Q2) · ... · e(Pn, Qn) = 1
```

## Quick Start

```typescript
import { bls12_381 } from '@tevm/voltaire/crypto';

// G1 point addition (signatures)
const g1Point1 = Hex.toBytes('0x17f1d3a73197d7942695638c4fa9ac0fc3688c4f9774b905a14e3a3f171bac586c55e83ff97a1aeffb3af00adb22c6bb');
const g1Point2 = Hex.toBytes('0x08b3f481e3aaa0f1a09e30ed741d8ae4fcf5e095d5d00af600db18cb2c04b3edd03cc744a2888ae40caa232946c5e7e1');
const g1Input = new Uint8Array([...g1Point1, new Uint8Array(80), ...g1Point2, new Uint8Array(80)]);  // 256 bytes padded
const g1Output = new Uint8Array(128);
await bls12_381.g1Add(g1Input, g1Output);

// G2 scalar multiplication (public keys)
const g2Point = Hex.toBytes('0x024aa2b2f08f0a91260805272dc51051c6e47ad4fa403b02b4510b647ae3d1770bac0326a805bbefd48056c8c121bdb8');
const scalar = Hex.toBytes('0x0000000000000000000000000000000000000000000000000000000000000002');
const g2Input = new Uint8Array([...g2Point, new Uint8Array(224), ...scalar]);  // 288 bytes
const g2Output = new Uint8Array(256);
await bls12_381.g2Mul(g2Input, g2Output);

// Pairing check (signature verification)
const pairingInput = new Uint8Array([...g1Point1, new Uint8Array(80), ...g2Point, new Uint8Array(224)]);  // Pairs
const pairingOutput = Bytes32();
await bls12_381.pairing(pairingInput, pairingOutput);

// Result: pairingOutput[31] === 0x01 means verification passed
```

## Documentation

### Core Concepts

- [**Signatures**](./signatures) - BLS signature scheme, aggregation, batch verification
- [**Pairing**](./pairing) - Bilinear pairing operation, optimal ate pairing algorithm
- [**G1 Operations**](./g1-operations) - Point addition, scalar multiplication, MSM
- [**G2 Operations**](./g2-operations) - Extension field operations, public key handling

### Advanced Topics

- [**Aggregation**](./aggregation) - Signature and key aggregation strategies
- [**Test Vectors**](./test-vectors) - Official test vectors, edge cases, validation
- [**Precompiles**](./precompiles) - EIP-2537 precompiled contracts
- [**Performance**](./performance) - Benchmarks, optimizations, comparison

### Implementation

- [**Usage Patterns**](./usage-patterns) - Ethereum validators, sync committees, zkSNARKs
- [**Security**](./security) - Side-channel resistance, rogue key attacks, best practices

## Point Formats

### G1 Points (48 bytes compressed, 96 bytes uncompressed)

**Uncompressed Format** (128 bytes padded for precompiles):
```
| x-coordinate | y-coordinate |
|   64 bytes   |   64 bytes   |
```

**Compressed Format** (48 bytes):
- MSB indicates compression + sign of y-coordinate
- Remaining 381 bits encode x-coordinate

### G2 Points (96 bytes compressed, 192 bytes uncompressed)

**Uncompressed Format** (256 bytes padded for precompiles):
```
| x.c0 | x.c1 | y.c0 | y.c1 |
|  64  |  64  |  64  |  64  |
```

**Compressed Format** (96 bytes):
- First 48 bytes: x.c1 (with compression flags)
- Second 48 bytes: x.c0

## Implementation Status

### Native (Production)

**Library**: BLST (Supranational)
- Audited by Trail of Bits, NCC Group
- Assembly-optimized for x86_64, ARM64
- Constant-time, side-channel resistant
- Used in all major Ethereum clients

**Location**: `lib/blst/`

### WASM (Limited)

**Status**: Not supported (BLST requires native compilation)

**Alternatives**:
- @noble/curves (pure TypeScript, ~10x slower)
- Stub implementation (returns errors)

## Security Level

**Target Security**: 128 bits (classical), 64 bits (quantum)

**Attack Complexity**:
- Discrete log on G1/G2: ~2^128 operations
- Pairing inversion: Computationally infeasible
- MOV attack: Prevented by embedding degree 12

**Recommended Until**: 2030+ (NIST guidelines)

## EIP-2537 Precompiles

**Status**: Proposed (pending activation)

**Precompile Addresses** (0x0b - 0x13):
- G1 operations: ADD, MUL, MSM
- G2 operations: ADD, MUL, MSM
- Pairing check
- Hash-to-curve mappings

**Gas Costs**:
- G1 addition: 500 gas
- Pairing base: 115,000 gas
- Pairing per pair: 23,000 gas

[See full precompile documentation →](./precompiles)

## Performance

**Native (BLST on x86_64)**:
- G1 addition: ~15 μs
- G1 multiplication: ~80 μs
- G2 multiplication: ~200 μs
- Pairing (single): ~1.2 ms
- Pairing check (2 pairs): ~2 ms
- MSM (100 G1 points): ~8 ms

**Comparison to BN254**:
- Pairing: ~2x slower
- Security: 128-bit vs 100-bit
- Future-proof: Better long-term security

[See detailed benchmarks →](./performance)

## Related

- [KZG Commitments](/crypto/kzg) - Polynomial commitments using BLS12-381
- [BN254](/crypto/bn254) - Alternative pairing curve (zkSNARKs)
- [Precompiles: BLS12-381](/precompiles/bls12-381) - EIP-2537 implementation

## References

- [EIP-2537: BLS12-381 Precompiles](https://eips.ethereum.org/EIPS/eip-2537)
- [BLST Library](https://github.com/supranational/blst)
- [BLS Signatures Spec](https://github.com/ethereum/consensus-specs)
- [Pairing-Friendly Curves (IETF Draft)](https://datatracker.ietf.org/doc/draft-irtf-cfrg-pairing-friendly-curves/)
- [Hash to Curve (RFC 9380)](https://datatracker.ietf.org/doc/rfc9380/)
