---
title: BIP-39 Mnemonic Phrases
description: Mnemonic seed phrase generation and recovery
---

## Overview

BIP-39 (Bitcoin Improvement Proposal 39) defines a standard for generating and using mnemonic phrases (12-24 word sequences) for deterministic wallet generation. These human-readable phrases are easier to back up and restore than raw binary seeds.

Key features:
- **Human-readable**: 12-24 common English words
- **Deterministic**: Same mnemonic always produces same seed
- **Checksum**: Last word validates entire phrase
- **Passphrase support**: Optional additional security layer
- **Multi-language**: Support for multiple wordlists

## Quick Start

```typescript
import * as Bip39 from '@tevm/voltaire/crypto/bip39';

// Generate 12-word mnemonic (128-bit entropy)
const mnemonic12 = Bip39.generateMnemonic(128);
// "abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon about"

// Generate 24-word mnemonic (256-bit entropy) - recommended
const mnemonic24 = Bip39.generateMnemonic(256);

// Validate mnemonic
const isValid = Bip39.validateMnemonic(mnemonic12);
console.log(isValid); // true

// Convert to seed (async)
const seed = await Bip39.mnemonicToSeed(mnemonic12, 'optional passphrase');
console.log(seed); // Uint8Array(64)

// Convert to seed (sync)
const seedSync = Bip39.mnemonicToSeedSync(mnemonic12, 'optional passphrase');
```

## API Reference

### Generation

#### `generateMnemonic(strength?: 128 | 160 | 192 | 224 | 256, wordlist?: string[]): string`

Generates a cryptographically secure mnemonic phrase.

**Parameters:**
- `strength` - Entropy bits (default: 256)
  - 128 bits = 12 words
  - 160 bits = 15 words
  - 192 bits = 18 words
  - 224 bits = 21 words
  - 256 bits = 24 words
- `wordlist` - Optional custom wordlist (default: English)

```typescript
// 12-word mnemonic (128-bit security)
const mnemonic12 = Bip39.generateMnemonic(128);

// 24-word mnemonic (256-bit security, recommended)
const mnemonic24 = Bip39.generateMnemonic(256);

// Default (256-bit)
const mnemonic = Bip39.generateMnemonic();
```

#### `entropyToMnemonic(entropy: Uint8Array, wordlist?: string[]): string`

Converts raw entropy to mnemonic phrase.

```typescript
const entropy = crypto.getRandomValues(Bytes32()); // 256 bits
const mnemonic = Bip39.entropyToMnemonic(entropy);
```

### Validation

#### `validateMnemonic(mnemonic: string, wordlist?: string[]): boolean`

Validates mnemonic phrase (checksum + word existence).

```typescript
const isValid = Bip39.validateMnemonic('abandon abandon abandon...');
if (!isValid) {
  console.error('Invalid mnemonic phrase');
}
```

#### `assertValidMnemonic(mnemonic: string, wordlist?: string[]): void`

Validates and throws on invalid mnemonic.

```typescript
try {
  Bip39.assertValidMnemonic(userProvidedMnemonic);
  // Proceed with valid mnemonic
} catch (error) {
  console.error('Invalid mnemonic:', error.message);
}
```

### Seed Derivation

#### `mnemonicToSeed(mnemonic: string, passphrase?: string): Promise<Uint8Array>`

Converts mnemonic to 64-byte seed using PBKDF2 (async, 2048 iterations).

```typescript
// Without passphrase
const seed = await Bip39.mnemonicToSeed(mnemonic);

// With passphrase (BIP-39 standard)
const seed = await Bip39.mnemonicToSeed(mnemonic, 'my secure passphrase');
```

#### `mnemonicToSeedSync(mnemonic: string, passphrase?: string): Uint8Array`

Synchronous version of `mnemonicToSeed`.

```typescript
const seed = Bip39.mnemonicToSeedSync(mnemonic);
```

### Utilities

#### `getWordCount(entropyBits: number): number`

Returns word count for given entropy bits.

```typescript
Bip39.getWordCount(128); // 12
Bip39.getWordCount(256); // 24
```

#### `getEntropyBits(wordCount: number): number`

Returns entropy bits for given word count.

```typescript
Bip39.getEntropyBits(12); // 128
Bip39.getEntropyBits(24); // 256
```

### Constants

```typescript
Bip39.ENTROPY_128  // 128 bits = 12 words
Bip39.ENTROPY_160  // 160 bits = 15 words
Bip39.ENTROPY_192  // 192 bits = 18 words
Bip39.ENTROPY_224  // 224 bits = 21 words
Bip39.ENTROPY_256  // 256 bits = 24 words
Bip39.SEED_LENGTH  // 64 bytes
```

## Entropy and Word Count

BIP-39 uses entropy + checksum to generate mnemonics:

| Entropy (bits) | Checksum (bits) | Total (bits) | Words |
|----------------|-----------------|--------------|-------|
| 128            | 4               | 132          | 12    |
| 160            | 5               | 165          | 15    |
| 192            | 6               | 198          | 18    |
| 224            | 7               | 231          | 21    |
| 256            | 8               | 264          | 24    |

**Formula:** `words = (entropy_bits + checksum_bits) / 11`

The checksum ensures the last word validates the entire phrase.

## Wordlist

BIP-39 uses a standardized 2048-word English wordlist by default:
- All words are 3-8 characters
- First 4 letters are unique
- No similar-looking words
- Common, easy-to-spell words

**Example words:** abandon, ability, able, about, above, absent, absorb, abstract...

**Other languages supported** (via `@scure/bip39`):
- Chinese (Simplified/Traditional)
- Czech
- French
- Italian
- Japanese
- Korean
- Portuguese
- Spanish

```typescript
import { wordlist as english } from '@scure/bip39/wordlists/english.js';
import { wordlist as spanish } from '@scure/bip39/wordlists/spanish.js';

const mnemonicES = Bip39.generateMnemonic(256, spanish);
```

## Passphrase (BIP-39 Extension)

An optional passphrase adds an additional security layer:

```typescript
const mnemonic = Bip39.generateMnemonic(256);

// Same mnemonic, different passphrases = different seeds
const seed1 = await Bip39.mnemonicToSeed(mnemonic, 'password123');
const seed2 = await Bip39.mnemonicToSeed(mnemonic, 'different');
// seed1 !== seed2

// No passphrase (equivalent to empty string)
const seed3 = await Bip39.mnemonicToSeed(mnemonic);
const seed4 = await Bip39.mnemonicToSeed(mnemonic, '');
// seed3 === seed4
```

**Use cases:**
- **Plausible deniability**: Different passphrases unlock different wallets from same mnemonic
- **Additional security**: Attacker needs both mnemonic AND passphrase
- **Two-factor**: Store mnemonic and passphrase separately

**Warning:** Forgetting passphrase means **permanent loss of funds**. No recovery possible.

## PBKDF2 Derivation

BIP-39 uses PBKDF2-HMAC-SHA512 to derive seed from mnemonic:

```
seed = PBKDF2(
  password: mnemonic (normalized to NFKD),
  salt: "mnemonic" + passphrase (normalized to NFKD),
  iterations: 2048,
  hash: SHA-512,
  outputLength: 64 bytes
)
```

**Why PBKDF2?**
- Slow derivation resists brute-force attacks
- Standardized, widely supported
- 2048 iterations balance security vs performance

## Security

### Critical Warnings

**1. Never transmit mnemonics unencrypted**
```typescript
// DANGEROUS - Never do this
fetch('https://api.example.com', {
  body: JSON.stringify({ mnemonic })
});

// SAFE - Only transmit seed-derived public data
const seed = await Bip39.mnemonicToSeed(mnemonic);
const hdKey = HDWallet.fromSeed(seed);
const publicKey = HDWallet.getPublicKey(hdKey);
```

**2. Store mnemonics encrypted**
```typescript
import * as AesGcm from '@tevm/voltaire/crypto/aesgcm';

// Encrypt before storage
const key = await AesGcm.generateKey(256);
const nonce = AesGcm.generateNonce();
const encryptedMnemonic = await AesGcm.encrypt(
  new TextEncoder().encode(mnemonic),
  key,
  nonce
);
// Store: encryptedMnemonic + nonce (never store raw mnemonic)
```

**3. Validate user-provided mnemonics**
```typescript
function importWallet(userMnemonic: string) {
  // Always validate before using
  if (!Bip39.validateMnemonic(userMnemonic)) {
    throw new Error('Invalid mnemonic phrase. Please check for typos.');
  }

  const seed = await Bip39.mnemonicToSeed(userMnemonic);
  // Proceed with seed...
}
```

**4. Use 24-word mnemonics for high-value wallets**
```typescript
// Recommended for significant funds
const mnemonic = Bip39.generateMnemonic(256); // 24 words = 256-bit security

// Acceptable for low-value wallets
const mnemonic12 = Bip39.generateMnemonic(128); // 12 words = 128-bit security
```

**5. Never reuse mnemonics across applications**

Each application/purpose should have its own mnemonic:
```typescript
// Bad
const mnemonic = Bip39.generateMnemonic();
const ethWallet = createEthWallet(mnemonic);
const btcWallet = createBtcWallet(mnemonic); // Same mnemonic

// Good
const ethMnemonic = Bip39.generateMnemonic();
const btcMnemonic = Bip39.generateMnemonic();
const ethWallet = createEthWallet(ethMnemonic);
const btcWallet = createBtcWallet(btcMnemonic);
```

### Best Practices

1. **Secure generation**: Use cryptographically secure randomness
   - `Bip39.generateMnemonic()` uses `crypto.getRandomValues()`
   - Never use `Math.random()` or user-provided "randomness"

2. **Offline generation**: Generate mnemonics on air-gapped devices for cold storage

3. **Physical backups**: Write mnemonic on paper, store in fireproof safe
   - Consider metal backups (fire/water resistant)
   - Split storage for high-value wallets

4. **Verify backups**: Always verify written mnemonic by restoring a test wallet

5. **Passphrases**: If using passphrases, back them up separately and securely

6. **Word order matters**: Changing word order invalidates mnemonic

7. **Checksum validation**: Last word is partially a checksum - validates entire phrase

## Common Errors

### Invalid Mnemonic

```typescript
// Invalid word
Bip39.validateMnemonic('abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon xyz');
// false - "xyz" not in wordlist

// Wrong word count
Bip39.validateMnemonic('abandon abandon abandon');
// false - must be 12, 15, 18, 21, or 24 words

// Invalid checksum
Bip39.validateMnemonic('abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon');
// false - checksum invalid
```

### Entropy Length

```typescript
// Wrong entropy length
const badEntropy = new Uint8Array(20); // 160 bits, but wrong
Bip39.entropyToMnemonic(badEntropy); // Error

// Correct
const goodEntropy = Bytes32(); // 256 bits
Bip39.entropyToMnemonic(goodEntropy); // Valid 24-word mnemonic
```

## Integration with HD Wallets

BIP-39 is typically used with BIP-32 (HD Wallets) for deterministic key generation:

```typescript
import * as Bip39 from '@tevm/voltaire/crypto/bip39';
import * as HDWallet from '@tevm/voltaire/crypto/hdwallet';

// 1. Generate mnemonic
const mnemonic = Bip39.generateMnemonic(256);

// 2. Derive seed
const seed = await Bip39.mnemonicToSeed(mnemonic);

// 3. Create HD wallet root
const root = HDWallet.fromSeed(seed);

// 4. Derive accounts (BIP-44)
const eth0 = HDWallet.deriveEthereum(root, 0, 0); // m/44'/60'/0'/0/0
const eth1 = HDWallet.deriveEthereum(root, 0, 1); // m/44'/60'/0'/0/1

// 5. Get keys
const privateKey0 = HDWallet.getPrivateKey(eth0);
const publicKey0 = HDWallet.getPublicKey(eth0);
```

**Flow:**
1. **Mnemonic** (human-readable backup)
2. **Seed** (64 bytes via PBKDF2)
3. **Root key** (master private key)
4. **Derived keys** (unlimited addresses from root)

## Implementation Notes

- Uses `@scure/bip39` by Paul Miller (audited, widely-used)
- PBKDF2-HMAC-SHA512 with 2048 iterations
- NFKD normalization for mnemonic and passphrase
- Constant-time checksum verification
- Support for multiple wordlists

## Test Vectors

BIP-39 test vectors for verification:

```typescript
// From BIP-39 spec
const testMnemonic = 'abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon about';
const testSeed = await Bip39.mnemonicToSeed(testMnemonic, 'TREZOR');

// Expected seed (hex):
// 0c1e24e5...c6e8bc39 (64 bytes)
```

## References

- [BIP-39 Specification](https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki)
- [English Wordlist](https://github.com/bitcoin/bips/blob/master/bip-0039/english.txt)
- [@scure/bip39 Library](https://github.com/paulmillr/scure-bip39)
- [Ian Coleman BIP-39 Tool](https://iancoleman.io/bip39/) (for testing, NOT for real funds)
