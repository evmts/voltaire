---
title: EIP-712 Typed Data Signing
description: Ethereum structured data signing and verification
---

## Overview

EIP-712 provides a standard for signing typed structured data, enabling human-readable signatures for dApp interactions. It defines a secure method for hashing and signing complex structured data rather than arbitrary byte strings, improving security and user experience.

Key features:
- **Type-safe signing**: Define and enforce data schemas
- **Human-readable**: Users see what they're signing (vs raw hex)
- **Domain separation**: Prevents cross-contract/chain replay attacks
- **Nested types**: Support for complex data structures

## Quick Start

```typescript
import * as EIP712 from '@tevm/voltaire/crypto/eip712';
import { Address } from '@tevm/voltaire/primitives/address';

// Define typed data structure
const typedData = {
  domain: {
    name: 'MyDApp',
    version: '1',
    chainId: 1n,
    verifyingContract: Address('0x742d35Cc6634C0532925a3b844Bc9e7595f251e3')
  },
  types: {
    Person: [
      { name: 'name', type: 'string' },
      { name: 'wallet', type: 'address' }
    ],
    Mail: [
      { name: 'from', type: 'Person' },
      { name: 'to', type: 'Person' },
      { name: 'contents', type: 'string' }
    ]
  },
  primaryType: 'Mail',
  message: {
    from: { name: 'Alice', wallet: Address('0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826') },
    to: { name: 'Bob', wallet: Address('0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB') },
    contents: 'Hello, Bob!'
  }
};

// Hash typed data (ready for signing)
const hash = EIP712.hashTypedData(typedData);

// Sign with private key
const privateKey = new Uint8Array(32); // Your private key
const signature = EIP712.signTypedData(typedData, privateKey);

// Verify signature
const address = EIP712.recoverAddress(signature, typedData);
const isValid = EIP712.verifyTypedData(signature, typedData, address);
```

## API Styles

Voltaire provides two ways to use EIP-712:

### Standard API (Recommended)

Crypto dependencies auto-injected - simplest for most use cases:

```typescript
import * as EIP712 from '@tevm/voltaire/crypto/eip712';

const hash = EIP712.hashTypedData(typedData);
const signature = EIP712.signTypedData(typedData, privateKey);
```

### Factory API (Advanced)

Tree-shakeable with explicit crypto dependencies. Useful for custom crypto implementations or minimal bundle size:

```typescript
import { HashTypedData, HashDomain, HashStruct, EncodeData,
         HashType, EncodeValue } from '@tevm/voltaire/crypto/eip712';
import { hash as keccak256 } from '@tevm/voltaire/crypto/keccak256';
import { sign as secp256k1Sign } from '@tevm/voltaire/crypto/secp256k1';

// Build from bottom up (handle circular dependencies)
const hashType = HashType({ keccak256 });
let hashStruct;
const encodeValue = EncodeValue({
  keccak256,
  hashStruct: (...args) => hashStruct(...args)
});
const encodeData = EncodeData({ hashType, encodeValue });
hashStruct = HashStruct({ keccak256, encodeData });

const hashDomain = HashDomain({ hashStruct });
const hashTypedData = HashTypedData({ keccak256, hashDomain, hashStruct });

// Use factories
const hash = hashTypedData(typedData);
```

**Factory dependencies:**
- All hash/encode methods: `keccak256`
- `signTypedData`: `hashTypedData` + `secp256k1.sign`
- `recoverAddress`: `keccak256` + `secp256k1.recoverPublicKey` + `hashTypedData`
- `verifyTypedData`: `recoverAddress`

## API Reference

### Core Functions

#### `hashTypedData(typedData: TypedData): Uint8Array`

Hashes typed data according to EIP-712 specification. Returns 32-byte hash ready for signing.

```typescript
const hash = EIP712.hashTypedData({
  domain: { name: 'MyApp', version: '1', chainId: 1n },
  types: { Message: [{ name: 'content', type: 'string' }] },
  primaryType: 'Message',
  message: { content: 'Hello!' }
});
```

#### `signTypedData(typedData: TypedData, privateKey: Uint8Array): Signature`

Signs typed data with ECDSA (secp256k1). Returns signature object with `r`, `s`, `v` components.

```typescript
const signature = EIP712.signTypedData(typedData, privateKey);
// signature.r: Uint8Array(32)
// signature.s: Uint8Array(32)
// signature.v: 27 | 28
```

#### `verifyTypedData(signature: Signature, typedData: TypedData, address: Address): boolean`

Verifies signature matches expected signer address.

```typescript
const valid = EIP712.verifyTypedData(signature, typedData, expectedAddress);
```

#### `recoverAddress(signature: Signature, typedData: TypedData): Address`

Recovers signer's Ethereum address from signature.

```typescript
const signer = EIP712.recoverAddress(signature, typedData);
```

### Type Encoding

#### `encodeType(primaryType: string, types: TypeDefinitions): string`

Generates canonical type encoding string (includes nested types alphabetically).

```typescript
const types = {
  Person: [
    { name: 'name', type: 'string' },
    { name: 'wallet', type: 'address' }
  ]
};
const encoded = EIP712.encodeType('Person', types);
// "Person(string name,address wallet)"
```

#### `hashType(primaryType: string, types: TypeDefinitions): Uint8Array`

Returns keccak256 hash of type encoding.

```typescript
const typeHash = EIP712.hashType('Person', types);
```

#### `encodeValue(type: string, value: any, types: TypeDefinitions): Uint8Array`

Encodes a single value according to its type (returns 32 bytes).

```typescript
// Primitive types
EIP712.encodeValue('uint256', 42n, types);
EIP712.encodeValue('address', address, types);
EIP712.encodeValue('bool', true, types);

// Dynamic types (encoded as hash)
EIP712.encodeValue('string', 'Hello', types);
EIP712.encodeValue('bytes', new Uint8Array([1,2,3]), types);

// Fixed bytes (left-aligned)
EIP712.encodeValue('bytes4', new Uint8Array([0xab, 0xcd, 0xef, 0x12]), types);

// Arrays (encoded as hash of concatenated elements)
EIP712.encodeValue('uint256[]', [1n, 2n, 3n], types);

// Custom structs (encoded as hash)
EIP712.encodeValue('Person', { name: 'Alice', wallet: address }, types);
```

#### `encodeData(primaryType: string, message: Message, types: TypeDefinitions): Uint8Array`

Encodes complete message data (typeHash + encoded field values).

```typescript
const encoded = EIP712.encodeData('Person',
  { name: 'Alice', wallet: address },
  types
);
```

#### `hashStruct(primaryType: string, message: Message, types: TypeDefinitions): Uint8Array`

Hashes encoded struct data.

```typescript
const structHash = EIP712.hashStruct('Person', message, types);
```

### Domain

#### `EIP712.Domain.hash(domain: Domain): Uint8Array`

Hashes domain separator (used internally by `hashTypedData`).

```typescript
const domainHash = EIP712.Domain.hash({
  name: 'MyApp',
  version: '1',
  chainId: 1n,
  verifyingContract: address,
  salt: saltBytes
});
```

### Utilities

#### `validate(typedData: TypedData): void`

Validates typed data structure. Throws on invalid data.

```typescript
EIP712.validate(typedData); // Throws if invalid
```

#### `format(typedData: TypedData): string`

Formats typed data for human-readable display.

```typescript
const display = EIP712.format(typedData);
console.log(display);
```

## Type System

EIP-712 supports all Solidity types:

### Elementary Types
- **Integers**: `uint8` through `uint256` (8-bit increments), `int8` through `int256`
- **Address**: `address` (20 bytes)
- **Boolean**: `bool`
- **Fixed bytes**: `bytes1` through `bytes32`
- **Dynamic bytes**: `bytes`
- **String**: `string`

### Reference Types
- **Arrays**: `type[]` (dynamic), `type[N]` (fixed-size)
- **Structs**: Custom named types

### Encoding Rules
1. **Atomic types** (uint, int, address, bool, fixed bytes): Encoded in 32 bytes
2. **Dynamic types** (string, bytes, arrays): Hashed with keccak256
3. **Structs**: Recursively encoded and hashed
4. **Arrays**: Elements encoded, concatenated, then hashed

```typescript
// Elementary types
{ name: 'id', type: 'uint256' }       // 32 bytes, right-aligned
{ name: 'addr', type: 'address' }     // 32 bytes, right-aligned (12-byte pad)
{ name: 'flag', type: 'bool' }        // 32 bytes, 0 or 1
{ name: 'data', type: 'bytes4' }      // 32 bytes, left-aligned

// Dynamic types (become hashes)
{ name: 'text', type: 'string' }      // keccak256(text)
{ name: 'data', type: 'bytes' }       // keccak256(data)

// Arrays (concatenate then hash)
{ name: 'ids', type: 'uint256[]' }    // keccak256(encode(ids[0]) + encode(ids[1]) + ...)

// Nested structs
types: {
  Person: [
    { name: 'name', type: 'string' },
    { name: 'wallet', type: 'address' }
  ],
  Mail: [
    { name: 'from', type: 'Person' },  // hashStruct(Person, from)
    { name: 'to', type: 'Person' }     // hashStruct(Person, to)
  ]
}
```

## Domain Separator

The domain separator prevents signature replay across different contracts, chains, or application versions:

```typescript
const domain = {
  name: 'Ether Mail',           // DApp name
  version: '1',                 // Version
  chainId: 1n,                  // Ethereum Mainnet
  verifyingContract: address,   // Contract address
  salt: saltBytes               // Additional entropy (optional)
};
```

**Why domain matters:**
- Signatures are bound to specific contract/chain
- Prevents cross-contract replay attacks
- Enables safe signature portability
- User sees what app/contract they're authorizing

## Use Cases

### MetaMask eth_signTypedData_v4

EIP-712 is the standard for MetaMask's typed data signing:

```typescript
// User sees structured data instead of hex blob
await ethereum.request({
  method: 'eth_signTypedData_v4',
  params: [address, JSON.stringify(typedData)]
});
```

### ERC-2612 Permit (Gasless Approvals)

Allow token approvals via signatures (no gas required):

```typescript
const permit = {
  domain: {
    name: 'USD Coin',
    version: '1',
    chainId: 1n,
    verifyingContract: usdcAddress
  },
  types: {
    Permit: [
      { name: 'owner', type: 'address' },
      { name: 'spender', type: 'address' },
      { name: 'value', type: 'uint256' },
      { name: 'nonce', type: 'uint256' },
      { name: 'deadline', type: 'uint256' }
    ]
  },
  primaryType: 'Permit',
  message: {
    owner: ownerAddress,
    spender: spenderAddress,
    value: 1000000n,        // 1 USDC
    nonce: 0n,
    deadline: 1700000000n
  }
};

const signature = EIP712.signTypedData(permit, privateKey);
// Submit signature to contract's permit() function
```

### Meta-Transactions (Gasless Transactions)

Users sign transaction intent, relayer pays gas:

```typescript
const forwardRequest = {
  domain: {
    name: 'MinimalForwarder',
    version: '0.0.1',
    chainId: 1n,
    verifyingContract: forwarderAddress
  },
  types: {
    ForwardRequest: [
      { name: 'from', type: 'address' },
      { name: 'to', type: 'address' },
      { name: 'value', type: 'uint256' },
      { name: 'gas', type: 'uint256' },
      { name: 'nonce', type: 'uint256' },
      { name: 'data', type: 'bytes' }
    ]
  },
  primaryType: 'ForwardRequest',
  message: {
    from: userAddress,
    to: targetContract,
    value: 0n,
    gas: 100000n,
    nonce: 0n,
    data: encodedCalldata
  }
};

const signature = EIP712.signTypedData(forwardRequest, privateKey);
// Relayer submits to forwarder contract
```

### DAO Voting

Off-chain voting with on-chain verification:

```typescript
const vote = {
  domain: { name: 'MyDAO', version: '1', chainId: 1n },
  types: {
    Vote: [
      { name: 'proposalId', type: 'uint256' },
      { name: 'support', type: 'bool' },
      { name: 'voter', type: 'address' }
    ]
  },
  primaryType: 'Vote',
  message: {
    proposalId: 42n,
    support: true,
    voter: voterAddress
  }
};
```

### NFT Marketplace Orders

Off-chain order books with on-chain settlement:

```typescript
const order = {
  domain: { name: 'NFTMarket', version: '1', chainId: 1n },
  types: {
    Order: [
      { name: 'maker', type: 'address' },
      { name: 'taker', type: 'address' },
      { name: 'nftContract', type: 'address' },
      { name: 'tokenId', type: 'uint256' },
      { name: 'price', type: 'uint256' },
      { name: 'expiry', type: 'uint256' }
    ]
  },
  primaryType: 'Order',
  message: { /* order details */ }
};
```

## Security

### Best Practices

1. **Always validate typed data** before signing:
```typescript
EIP712.validate(typedData); // Throws on invalid structure
```

2. **Include domain separator** to prevent replay:
```typescript
domain: {
  name: 'YourApp',
  version: '1',
  chainId: 1n,
  verifyingContract: contractAddress
}
```

3. **Verify recovered address** matches expected signer:
```typescript
const recovered = EIP712.recoverAddress(signature, typedData);
if (!Address.equals(recovered, expectedSigner)) {
  throw new Error('Invalid signer');
}
```

4. **Use nonces** to prevent replay attacks:
```typescript
types: {
  Message: [
    { name: 'content', type: 'string' },
    { name: 'nonce', type: 'uint256' },  // Increment per signature
    { name: 'deadline', type: 'uint256' } // Time limit
  ]
}
```

### Common Vulnerabilities

**Signature Malleability**: EIP-712 uses low-s canonicalization. Always verify `s` value.

**Replay Attacks**: Without domain separator + nonce, signatures can be replayed on other contracts/chains.

**Type Confusion**: Ensure types match between frontend and contract exactly.

**Missing Validation**: Always call `validate()` before signing user-provided data.

## Implementation Notes

- Uses native secp256k1 signatures (deterministic, RFC 6979)
- Keccak256 for all hashing operations
- Compatible with eth_signTypedData_v4 (MetaMask)
- Follows EIP-712 specification exactly
- Type encoding includes nested types alphabetically

## References

- [EIP-712 Specification](https://eips.ethereum.org/EIPS/eip-712)
- [ERC-2612 (Permit)](https://eips.ethereum.org/EIPS/eip-2612)
- [MetaMask Signing Guide](https://docs.metamask.io/wallet/how-to/sign-data/)
