---
title: Usage Patterns
description: Common recipes for blockchain interactions
---

<Warning>
TypeScript-oriented. In Zig, build JSON and post with `std.http.Client`; use `primitives.AbiEncoding` for calldata and result decoding. Zig-native recipes will be added.
</Warning>

# Usage Patterns

Practical recipes for common blockchain interaction patterns.

## Getting Account State

```zig
import * as Rpc from 'tevm/jsonrpc';
import * as Address from 'tevm/Address';

async function getAccountState(
  provider: Provider,
  address: Address.AddressType
) {
  // Create requests
  const balanceReq = Rpc.Eth.GetBalanceRequest(address, 'latest');
  const nonceReq = Rpc.Eth.GetTransactionCountRequest(address, 'latest');
  const codeReq = Rpc.Eth.GetCodeRequest(address, 'latest');

  const [balance, nonce, code] = await Promise.all([
    provider.request(balanceReq),
    provider.request(nonceReq),
    provider.request(codeReq)
  ]);

  if (balance.error || nonce.error || code.error) {
    return null;
  }

  return {
    balance: BigInt(balance.result),
    nonce: Number(nonce.result),
    isContract: code.result !== '0x'
  };
}
```

## Monitoring Contract Events

```zig
import * as Address from 'tevm/Address';
import * as Hash from 'tevm/Hash';

const contractAddress = Address('0x...');
const transferSig = Hash(
  '0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef'
);

for await (const log of provider.events.logs({
  address: contractAddress,
  topics: [transferSig]
})) {
  console.log('Transfer in block:', log.blockNumber);
  console.log('From:', log.topics[1]);
  console.log('To:', log.topics[2]);
}
```

## Waiting for Transaction Confirmation

```zig
import * as Rpc from 'tevm/jsonrpc';
import * as Hash from 'tevm/Hash';

async function waitForConfirmation(
  provider: Provider,
  txHash: Hash.HashType,
  confirmations: number = 3
): Promise<void> {
  const request = Rpc.Eth.GetTransactionReceiptRequest(txHash);
  const receiptRes = await provider.request(request);

  if (receiptRes.error || !receiptRes.result) {
    throw new Error('Transaction not found');
  }

  const targetBlock = BigInt(receiptRes.result.blockNumber) + BigInt(confirmations);

  for await (const block of provider.events.newHeads()) {
    if (BigInt(block.number) >= targetBlock) {
      break;
    }
  }
}
```

## Estimating Gas with Buffer

```zig
import * as Rpc from 'tevm/jsonrpc';
import * as Address from 'tevm/Address';
import * as Hex from 'tevm/Hex';

async function estimateGasWithBuffer(
  provider: Provider,
  params: {
    from: Address.AddressType;
    to: Address.AddressType;
    data: Hex.HexType;
  }
): Promise<bigint | null> {
  const request = Rpc.Eth.EstimateGasRequest(params);
  const response = await provider.request(request);

  if (response.error) {
    return null;
  }

  const estimate = BigInt(response.result);
  return estimate * 120n / 100n; // Add 20% buffer
}
```

## Related

- [Getting Started](/jsonrpc-provider/getting-started) - Installation and basics
- [Method API](/jsonrpc-provider/method-api) - Method patterns
- [Events](/jsonrpc-provider/events) - Event subscriptions
