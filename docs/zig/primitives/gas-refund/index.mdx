---
title: GasRefund
description: Gas refunds after transaction execution
---

# GasRefund

`GasRefund` represents gas refunded after transaction execution. Post-London (EIP-3529), refunds are capped at `gasUsed / 5`.

## Type Definition (Zig)

```zig
// Gas refunds are integers (u256). Post-London cap: refund <= gasUsed / 5.
```

## Gas Refund Mechanics

### Pre-London (Before EIP-3529)

Large refunds were possible from:

- **SSTORE clear**: 15,000 gas (clearing storage slot)
- **SELFDESTRUCT**: 24,000 gas (destroying contract)

**Problem**: Caused "gas tokens" - exploiting refunds for profit.

### Post-London (EIP-3529)

Refunds significantly reduced:

- **Cap**: Maximum refund = `gasUsed / 5` (20% of gas used)
- **SSTORE clear**: Still generates 15,000 refund, but capped
- **SELFDESTRUCT**: No longer gives refund

**Effect**: Eliminated gas token exploits, simplified gas economics.

## API

### Cap Function

```zig
fn cappedRefund(refund: u256, gas_used: u256) u256 {
    const cap = gas_used / 5;
    return if (refund < cap) refund else cap;
}
```

### Conversions

#### Hex

```zig
// Convert refund to hex
const Hex = @import("primitives").Hex;
const hex = Hex.bytesToHexFixed(32, std.mem.toBytes(refund));
```

### Comparisons

#### Equality

```zig
const eq = (refund1 == refund2);
```

### Utilities

#### Apply Cap

```zig
const refund: u256 = 15000; // SSTORE clear
const gas_used: u256 = 50000;
const capped = cappedRefund(refund, gas_used); // 10000
```

Post-London enforcement: `min(refund, gasUsed / 5)`

## Usage Examples

### Calculate Effective Gas Cost

```zig
const gas_used: u256 = 60000;
const gas_price: u256 = 20_000_000_000; // 20 gwei
const total_refund: u256 = 30000; // 2 × 15000
const capped = cappedRefund(total_refund, gas_used); // 12000
const gross_cost = gas_used * gas_price;
const refund_value = capped * gas_price;
const net_cost = gross_cost - refund_value;
```

### Compare Pre/Post London

```zig
const pre_london: u256 = 15000;
const gas_used: u256 = 50000;
const post_london = cappedRefund(pre_london, gas_used); // 10000
const reduction = pre_london - post_london; // 5000
```

### Multiple Storage Clears

```zig
// Transaction clears 5 slots
const total_refund: u256 = 5 * 15000;
const gas_used: u256 = 100000;
const capped = cappedRefund(total_refund, gas_used); // 20000
// Refund lost: total_refund - capped
```

## Refund Sources

### SSTORE Operations

| Operation | Gas Cost | Refund (Pre-London) | Refund (Post-London) |
|-----------|----------|---------------------|---------------------|
| Zero → Non-zero | 20,000 | 0 | 0 |
| Non-zero → Non-zero | 5,000 | 0 | 0 |
| Non-zero → Zero | 5,000 | 15,000 | Capped at gasUsed/5 |
| Non-zero → Same | 100 (warm) | 0 | 0 |

### SELFDESTRUCT

| Era | Gas Cost | Refund |
|-----|----------|--------|
| Pre-London | 5,000 | 24,000 |
| Post-London | 5,000 | 0 |

## EIP-3529 Rationale

### Problems with Old Refund System

1. **Gas Tokens**: Exploited refunds for profit
   - Store data when gas cheap
   - Clear data when gas expensive
   - Get refund at high gas price

2. **Block Variability**: Large refunds caused unpredictable block gas usage

3. **Complexity**: Made gas economics hard to reason about

### Post-3529 Benefits

1. **No Gas Tokens**: Capped refunds eliminate exploit
2. **Predictable Costs**: Users pay closer to actual gas used
3. **Simpler Economics**: Easier to estimate transaction costs
4. **Faster State Growth**: Reduced incentive to keep unnecessary storage

## Refund Cap Formula

```
effectiveRefund = min(totalRefund, gasUsed / 5)
```

Where:
- `totalRefund`: Sum of all refunds from SSTORE operations
- `gasUsed`: Actual gas consumed by transaction
- Division rounds down (integer division)

## Usage Patterns

### Check if Refund is Capped

```zig
import { GasRefund } from '@tevm/primitives';

function isRefundCapped(refund: bigint, gasUsed: bigint): boolean {
  const refundObj = GasRefund.from(refund);
  const capped = GasRefund.cappedRefund(refundObj, gasUsed);
  return GasRefund.toBigInt(capped) < refund;
}

const refund = 15000n;
const gasUsed = 50000n;
console.log(isRefundCapped(refund, gasUsed)); // true
```

### Calculate Maximum Possible Refund

```zig
import { GasRefund } from '@tevm/primitives';

function maxRefund(gasUsed: bigint): bigint {
  return gasUsed / 5n;
}

const gasUsed = 100000n;
console.log(`Max refund: ${maxRefund(gasUsed)}`); // 20000
```

## London Hard Fork

**Date**: August 5, 2021 (Block 12,965,000)

**Changes**:
- EIP-3529: Refund reduction
- EIP-1559: Fee market change
- EIP-3198: BASEFEE opcode
- EIP-3541: Reject new contracts starting with 0xEF

**Impact**: Most transactions now have zero or minimal refunds.

## See Also

- [GasUsed](/primitives/gas-used) - Actual gas consumed
- [GasEstimate](/primitives/gas-estimate) - Estimate gas before execution
- [EIP-3529](https://eips.ethereum.org/EIPS/eip-3529) - Reduction in refunds
- [EIP-2929](https://eips.ethereum.org/EIPS/eip-2929) - Gas cost increases
- [Yellow Paper Section 6](https://ethereum.github.io/yellowpaper/paper.pdf) - Execution model
