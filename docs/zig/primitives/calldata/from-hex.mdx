---
title: fromHex
description: Create CallData from hex string
---

Creates CallData from a hex-encoded string. Specialized constructor for hex input with explicit validation.

## Signature

<Tabs>
<Tab title="Namespace">

```zig
function fromHex(hex: string): CallDataType
```

</Tab>
<Tab title="Class">

```zig
CallData.fromHex(hex: string): CallDataType
```

</Tab>
</Tabs>

## Parameters

- **hex** - Hex-encoded string (with or without `0x` prefix)

## Returns

`CallDataType` - Branded Uint8Array representing transaction calldata

## Examples

<Tabs>
<Tab title="Basic Usage">

```zig
import { CallData } from 'tevm';

// With 0x prefix
const calldata1 = CallData.fromHex("0xa9059cbb...");

// Without 0x prefix
const calldata2 = CallData.fromHex("a9059cbb...");

console.log(CallData.toHex(calldata1));
// "0xa9059cbb..."
```

</Tab>
<Tab title="Transaction Data">

```zig
import { CallData } from 'tevm';

const txData = "0xa9059cbb" +
  "00000000000000000000000070997970c51812dc3a010c7d01b50e0d17dc79c8" +
  "0000000000000000000000000000000000000000000000000de0b6b3a7640000";

const calldata = CallData.fromHex(txData);

console.log("Selector:", CallData.getSelector(calldata));
console.log("Size:", calldata.length, "bytes");
// Size: 68 bytes (4 + 32 + 32)
```

</Tab>
<Tab title="Namespace API">

```zig
import * as CallData from 'tevm/CallData';

const calldata = CallData.fromHex("0xa9059cbb...");
const selector = CallData.getSelector(calldata);
```

</Tab>
</Tabs>

## Validation

Validates hex string format:

```zig
import { CallData } from 'tevm';

// Invalid hex characters
try {
  CallData.fromHex("0xGGGG");
} catch (error) {
  console.error("Invalid hex string");
}

// Odd length hex (must be byte-aligned)
try {
  CallData.fromHex("0xa9059c"); // 6 chars = 3 bytes = odd nibbles
} catch (error) {
  console.error("Hex must have even length");
}

// Too short (must be at least 4 bytes for selector)
try {
  CallData.fromHex("0xa905");
} catch (error) {
  console.error("CallData must be at least 4 bytes");
}
```

## Comparison with from()

`fromHex` is more explicit but less flexible than `from`:

```zig
import { CallData } from 'tevm';

// from() - Universal constructor
const calldata1 = CallData("0xa9059cbb...");
const calldata2 = CallData(new Uint8Array([0xa9, 0x05]));

// fromHex() - Hex string only
const calldata3 = CallData.fromHex("0xa9059cbb...");
const calldata4 = CallData.fromHex(bytes); // ‚ùå Type error
```

Use `fromHex` when:
- Input is always hex string
- You want explicit type checking
- Code clarity is prioritized

Use `from` when:
- Input type varies
- Maximum flexibility needed
- Writing generic functions

## Use Cases

### Parse Raw Transaction

```zig
import { CallData } from 'tevm';

interface RawTransaction {
  data: string; // Hex string
}

function parseTxData(tx: RawTransaction) {
  const calldata = CallData.fromHex(tx.data);

  return {
    selector: CallData.getSelector(calldata),
    size: calldata.length,
  };
}
```

### Validate Hex Input

```zig
import { CallData } from 'tevm';

function isValidCallDataHex(hex: string): boolean {
  try {
    CallData.fromHex(hex);
    return true;
  } catch {
    return false;
  }
}

console.log(isValidCallDataHex("0xa9059cbb")); // true
console.log(isValidCallDataHex("0xGGGG")); // false
```

### Type-Safe API

```zig
import { CallData } from 'tevm';

// Enforce hex string input at API boundary
export function decodeCallData(hex: string) {
  const calldata = CallData.fromHex(hex); // Explicit hex validation
  return CallData.decode(calldata, abi);
}
```

## Related

- [from](/primitives/calldata/from) - Universal constructor
- [fromBytes](/primitives/calldata/from-bytes) - From Uint8Array
- [toHex](/primitives/calldata/to-hex) - Convert to hex string
- [isValid](/primitives/calldata/is-valid) - Validate input
