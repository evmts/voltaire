# Ethereum Primitives & Cryptography for Zig

Zig 0.15.1+ | github.com/evmts/voltaire | Mission-critical crypto - zero error tolerance

## Critical: Zig 0.15.1 ArrayList

```zig
// ✅ CORRECT - UNMANAGED
var list = std.ArrayList(T){};
defer list.deinit(allocator);
try list.append(allocator, item);

// ❌ WRONG - old API
var list = std.ArrayList(T).init(allocator);  // No init()!
list.deinit();  // Missing allocator
```

## Modules

**primitives:** Uint256, Address, Hex, RLP, ABI, Transactions (Legacy/2930/1559/4844/7702), Logs, AccessList, Bytecode, Opcodes, Hardforks, MPT

**crypto:**
- Production: Keccak-256, secp256k1 (@noble), EIP-712 (@noble), BLS12-381 (BLST), BN254 (Arkworks+@noble), KZG (c-kzg-4844), SHA256, RIPEMD160, Blake2
- ⚠️ Unaudited: Pure Zig secp256k1, BN254, ModExp

**precompiles:** 0x01-0x13

C libs: blst, c-kzg-4844, arkworks

## Usage

Import: `@import("primitives")`, `@import("crypto")`

build.zig.zon:
```zig
.dependencies = .{
    .primitives = .{ .url = "github.com/evmts/voltaire/archive/<commit>.tar.gz", .hash = "<hash>" },
}
```

build.zig:
```zig
const p = b.dependency("primitives", .{ .target = target, .optimize = optimize });
exe.root_module.addImport("primitives", p.module("primitives"));
exe.root_module.addImport("crypto", p.module("crypto"));
```

## API

### Address (Zig)
```zig
const a = try Address.fromHex("0xa0cf...");  // fromU256/fromBytes/fromPublicKey
const hex = a.toHex();  // [42]u8, toU256/toChecksumHex
const valid = Address.isValid(hex) / .isValidChecksum(hex) / .zero();
const create = try Address.calculateCreateAddress(alloc, deployer, nonce);  // CREATE2
```

### Hex (Zig)
```zig
const ok = Hex.isHex("0x1234");  // needs 0x
const b = try Hex.hexToBytes(alloc, "0x12"); defer alloc.free(b);
const h = try Hex.bytesToHex(alloc, &b); defer alloc.free(h);
const v = try Hex.hexToU256("0xdead") / .u256ToHex(alloc, v);
const pad = try Hex.padLeft(alloc, &b, 32);  // trimLeftZeros (no alloc)
```

### RLP (Zig)
```zig
const enc = try Rlp.encode(alloc, val); defer alloc.free(enc);
const dec = try Rlp.decode(alloc, enc, false); defer dec.data.deinit(alloc);
switch (dec.data) { .String => |s| {}, .List => |l| {} }
// Stream: Rlp.decode(alloc, data, true)
```

### ABI (Zig)
```zig
const sel = abi.computeSelector("transfer(address,uint256)");
const params = [_]abi.AbiValue{ abi.addressValue(r), abi.uint256_value(a) };
const data = try abi.encodeFunctionData(alloc, sel, &params); defer alloc.free(data);
const types = [_]abi.AbiType{ .address, .uint256 };
const res = try abi.decodeFunctionData(alloc, data, &types);  // cleanup params
const packed = try abi.encodePacked(alloc, &values);  // no padding
```

**ABI (TS):** `Abi.Function.{getSelector,encodeParams,decodeResult}`, `Abi.Event.{getSelector,encodeTopics,decodeLog}`, `Abi.{encodeParameters,decodeParameters,encodePacked}`

### Keccak-256 (Zig)
```zig
const h = HashUtils.keccak256("hello") / .fromHex("0x12...");
const hex = HashUtils.toHex(h);  // [66]u8
const msg = try HashUtils.eip191HashMessage("Sign", alloc);
const eq = HashUtils.equal(h1, h2);  // constant-time
const sel = HashUtils.selectorFromSignature("transfer(address,uint256)");
```

**Keccak (TS):** `Keccak256.{hash,hashString,hashHex}`, `Hash.{toHex,fromHex,fromBytes,equals,isZero}`

### secp256k1 (⚠️ Zig UNAUDITED - use @noble for prod)
```zig
const priv = try Crypto.unaudited_randomPrivateKey();
const pub = try Crypto.unaudited_getPublicKey(priv);
const addr = Crypto.publicKeyToAddress(pub);
const sig = try Crypto.unaudited_signMessage("Hi", priv) / .unaudited_signHash(h, priv);
const ok = try Crypto.unaudited_verifyMessage(m, sig, addr);
const rec = try Crypto.unaudited_recoverAddress(h, sig);
sig.isValid();  // r,s,v check. sig.toBytes() = [65]u8
```

**secp256k1 (TS @noble):** `Secp256k1.{generatePrivateKey,derivePublicKey,publicKeyToAddress,sign,signMessage,verify,verifyMessage,recover,recoverAddress}`, `Signature.{toBytes,toCompact,fromBytes,fromCompact,isCanonical,normalize}`

### Uint256 (Zig)
```zig
const v = try Uint256.fromInt(42) / .max() / .zero();
// Arithmetic: try a.{add,sub,mul,div,mod,pow}(b)
// Bitwise: a.{bitAnd,bitOr,xor,bitNot,shl,shr}(b/bits)
// Compare: a.{eq,lt,gt}(b)
const bytes = v.toBytes();  // [32]u8 BE. fromBytes/toHex/fromHex
```

**Uint256 (TS):** `Uint256.{MAX,ZERO,ONE,from,fromHex,fromBytes}`, `.{plus,minus,times,div,mod,and,or,xor,not,shl,shr,eq,lt,gt,toHex,toBytes,toBigInt}`

### AccessList (EIP-2930)
```zig
// AccessListItem = { address, storage_keys }. Gas: 2400/addr, 1900/key
const cost = AccessList.calculateGasCost(al) / .calculateGasSavings(al);
const has = AccessList.isAddressInAccessList(al, a) / .isStorageKeyInAccessList(al, a, k);
const dup = try AccessList.deduplicateAccessList(alloc, al);
```

**AccessList (TS):** `.{gasCost,gasSavings,includesAddress,includesStorageKey,deduplicate,merge,difference,serialize,deserialize}`

### Authorization (EIP-7702)
```zig
// struct: chain_id, address, nonce, v, r, s. Gas: 25000/empty, 12500/base
const auth = Authorization.create(chain, addr, nonce);
const gas = Authorization.calculateGasCost(auths, empty_ct);
const enc = try Authorization.encodeList(alloc, auths);
```

**Authorization (TS):** `.{create,signingHash,sign,authority,isValid,validate,gasCost,serialize,deserialize}`

### Blob (EIP-4844)
```zig
// 131072 bytes, max 6/tx, 131072 gas/blob
const h = Blob.commitmentToVersionedHash(c) / .isValidVersionedHash(h);
const price = Blob.calculateBlobGasPrice(excess);
const blob = try Blob.encodeBlobData(alloc, data);
```

**Blob (TS):** `.{fromData,toData,commitmentToVersionedHash,isValidVersionedHash,calculateGas,estimateBlobCount,calculateGasPrice,calculateExcessGas,isValid}`

### FeeMarket (EIP-1559)
```zig
// MIN_BASE_FEE=7, DENOM=8
const next = FeeMarket.nextBaseFee(parent_fee, used, target);
const res = FeeMarket.getEffectiveGasPrice(base, max, priority);  // .effective_gas_price, .miner_fee
const tgt = FeeMarket.getGasTarget(limit);
```

**FeeMarket (TS):** `.{calculateNextBaseFee,getEffectiveGasPrice,getGasTarget}`

### Transactions

**Zig API:**
```zig
pub const TransactionType = enum(u8) {
    legacy = 0,
    eip2930 = 1,
    eip1559 = 2,
    eip4844 = 3,
    eip7702 = 4
};

// Legacy
const tx = LegacyTransaction{
    .nonce = 0,
    .gas_price = 20_000_000_000,  // 20 gwei
    .gas_limit = 21000,
    .to = recipient,
    .value = 1_000_000_000_000_000_000,  // 1 ETH
    .data = &[_]u8{},
    .v = 0, .r = [_]u8{0} ** 32, .s = [_]u8{0} ** 32,
};

const encoded = try Transaction.encodeLegacyForSigning(allocator, tx, chain_id);
defer allocator.free(encoded);

const signed = try Transaction.signLegacyTransaction(allocator, tx, private_key, chain_id);
const hash = try Transaction.computeLegacyTransactionHash(allocator, signed);
const tx_type = Transaction.detectTransactionType(raw_data);

// EIP-1559
const eip1559 = Eip1559Transaction{
    .chain_id = 1,
    .nonce = 0,
    .max_priority_fee_per_gas = 2_000_000_000,  // 2 gwei tip
    .max_fee_per_gas = 30_000_000_000,  // 30 gwei max
    .gas_limit = 21000,
    .to = recipient,
    .value = amount,
    .data = &[_]u8{},
    .access_list = &[_]AccessListItem{},
    .v = 0, .r = [_]u8{0} ** 32, .s = [_]u8{0} ** 32,
};
const encoded = try Transaction.encodeEip1559ForSigning(allocator, eip1559);

// EIP-4844 (Blob transactions)
const eip4844 = Eip4844Transaction{
    .chain_id = 1,
    .nonce = 0,
    .max_priority_fee_per_gas = 2_000_000_000,
    .max_fee_per_gas = 30_000_000_000,
    .max_fee_per_blob_gas = 1_000_000,
    .gas_limit = 21000,
    .to = recipient,
    .value = 0,
    .data = &[_]u8{},
    .access_list = &[_]AccessListItem{},
    .blob_versioned_hashes = &[_]VersionedHash{},
    .v = 0, .r = [_]u8{0} ** 32, .s = [_]u8{0} ** 32,
};
const blob_hash = try Transaction.computeEip4844TransactionHash(allocator, eip4844);

// EIP-7702 (Set code transactions)
const eip7702 = Eip7702Transaction{
    .chain_id = 1,
    .nonce = 0,
    .max_priority_fee_per_gas = 2_000_000_000,
    .max_fee_per_gas = 30_000_000_000,
    .gas_limit = 100000,
    .to = recipient,
    .value = 0,
    .data = &[_]u8{},
    .access_list = &[_]AccessListItem{},
    .authorization_list = &[_]Authorization{},
    .v = 0, .r = [_]u8{0} ** 32, .s = [_]u8{0} ** 32,
};
const auth_hash = try Transaction.computeEip7702TransactionHash(allocator, eip7702);
```

**TypeScript API:**
```typescript
import { Transaction } from '@tevm/voltaire';

type Transaction = Transaction.Legacy | Transaction.EIP2930 | Transaction.EIP1559 |
                   Transaction.EIP4844 | Transaction.EIP7702;

// Type detection
const type = Transaction.getType(tx);
const isLegacy = Transaction.isLegacy(tx);
const isEIP4844 = Transaction.isEIP4844(tx);

// Serialization
const serialized = Transaction.serialize(tx);
const deserialized = Transaction.deserialize(data);
const forSigning = Transaction.serializeForSigning(tx);

// Hashing
const hash = Transaction.hash(tx);
const signingHash = Transaction.signingHash(tx);

// Signing
const signed = Transaction.sign(tx, privateKey);
const sender = Transaction.recoverSender(signedTx);

// Type-specific operations
namespace Transaction.Legacy {
    function serialize(tx: Legacy): Hex;
    function hash(tx: Legacy): Hash;
    function sign(tx: Legacy, key: Uint8Array): Legacy;
}

namespace Transaction.EIP4844 {
    function serialize(tx: EIP4844): Hex;
    function hash(tx: EIP4844): Hash;
    function getBlobVersionedHashes(tx: EIP4844): Hash[];
    function calculateBlobGas(tx: EIP4844): bigint;
}

namespace Transaction.EIP7702 {
    function serialize(tx: EIP7702): Hex;
    function hash(tx: EIP7702): Hash;
    function getAuthorizationList(tx: EIP7702): Authorization[];
}
```

### Hash (Advanced Operations)

**Zig API:**
```zig
pub const Hash = [32]u8;
pub const ZERO_HASH: Hash = [_]u8{0} ** 32;
pub const EMPTY_KECCAK256: Hash;

// Construction
const hash = HashUtils.keccak256(data);
const from_hex = try HashUtils.fromHex("0x1234...");
const from_u256 = HashUtils.fromU256(value);

// Conversion
const hex = HashUtils.toHex(hash);  // [66]u8 with 0x prefix
const u256 = HashUtils.toU256(hash);

// Comparison (constant-time)
const is_equal = HashUtils.equal(hash1, hash2);
const is_zero = HashUtils.isZero(hash);
const order = HashUtils.compare(hash1, hash2);
const is_less = HashUtils.lessThan(hash1, hash2);
const is_greater = HashUtils.greaterThan(hash1, hash2);

// Bitwise operations
const xor_result = HashUtils.xor(hash1, hash2);
const and_result = HashUtils.bitAnd(hash1, hash2);
const or_result = HashUtils.bitOr(hash1, hash2);
const not_result = HashUtils.bitNot(hash);

// Ethereum-specific
const selector = HashUtils.selectorFromSignature("transfer(address,uint256)");  // [4]u8
const msg_hash = try HashUtils.eip191HashMessage("Sign this", allocator);
```

**TypeScript API:**
```typescript
import { Hash } from '@tevm/voltaire';

// Constants
const SIZE = 32;
const ZERO: Hash;
const EMPTY_KECCAK256: Hash;

// Construction
const hash = Hash.fromHex('0x...');
const fromBytes = Hash.fromBytes(bytes);
const fromString = Hash.fromString('hello');
const keccak = Hash.keccak256(data);
const keccakString = Hash.keccak256String('hello');
const keccakHex = Hash.keccak256Hex('0x1234');

// Conversion
const hex = Hash.toHex.call(hash);
const bytes = Hash.toBytes.call(hash);
const bigint = Hash.toBigInt.call(hash);

// Comparison
const isEqual = Hash.equals.call(hash1, hash2);
const isZero = Hash.isZero.call(hash);
const cmp = Hash.compare(hash1, hash2);
const less = Hash.lessThan(hash1, hash2);
const greater = Hash.greaterThan(hash1, hash2);

// Bitwise
const xor = Hash.xor.call(hash1, hash2);
const and = Hash.and.call(hash1, hash2);
const or = Hash.or.call(hash1, hash2);
const not = Hash.not.call(hash);
```

### KZG Commitments (EIP-4844)

**Zig API (via c-kzg-4844):**
```zig
pub const BYTES_PER_BLOB = 131072;
pub const BYTES_PER_COMMITMENT = 48;
pub const BYTES_PER_PROOF = 48;
pub const FIELD_ELEMENTS_PER_BLOB = 4096;

pub const Blob = [BYTES_PER_BLOB]u8;
pub const KZGCommitment = [48]u8;
pub const KZGProof = [48]u8;
pub const Bytes32 = [32]u8;

// Initialization (required before use)
try Kzg.loadTrustedSetupFile("trusted_setup.txt", 0);
defer Kzg.freeTrustedSetup() catch {};

// Commitment operations
const commitment = try Kzg.blobToKzgCommitment(&blob);
const proof_result = try Kzg.computeKZGProof(&blob, &z_point);
// proof_result.proof, proof_result.y

// Verification
const is_valid = try Kzg.verifyKZGProof(&commitment, &z, &y, &proof);

// Point evaluation precompile (0x0a)
const blob_valid = try Kzg.verifyBlobKzgProof(&blob, &commitment, &proof);
```

**TypeScript API:**
```typescript
import { Kzg } from '@tevm/voltaire';

// Constants
const BYTES_PER_BLOB = 131072;
const BYTES_PER_COMMITMENT = 48;
const BYTES_PER_PROOF = 48;

type Blob = Uint8Array;  // 131072 bytes
type Commitment = Uint8Array;  // 48 bytes
type Proof = Uint8Array;  // 48 bytes

// Initialization (loads trusted setup)
await Kzg.loadTrustedSetup();  // Uses default path
await Kzg.loadTrustedSetup('/path/to/trusted_setup.txt');
Kzg.freeTrustedSetup();

// Commitment operations
const commitment = Kzg.blobToCommitment(blob);
const { proof, y } = Kzg.computeProof(blob, z);
const isValid = Kzg.verifyProof(commitment, z, y, proof);

// Batch operations
const commitments = Kzg.blobsToCommitments(blobs);
const batchValid = Kzg.verifyBlobKzgProofBatch(blobs, commitments, proofs);

// Point evaluation precompile (0x0a)
const blobValid = Kzg.verifyBlobKzgProof(blob, commitment, proof);
```

### BN254 (alt_bn128) — Comprehensive

**Zig API (⚠️ Pure Zig UNAUDITED — use Arkworks for production):**
```zig
// Field Elements
pub const FpMont = @import("bn254/FpMont.zig");  // Base field Fp
pub const Fp2Mont = @import("bn254/Fp2Mont.zig");  // Extension field Fp2
pub const Fp6Mont = @import("bn254/Fp6Mont.zig");  // Fp6 for pairing
pub const Fp12Mont = @import("bn254/Fp12Mont.zig");  // Fp12 for pairing result
pub const Fr = @import("bn254/Fr.zig").Fr;  // Scalar field

// Curve Groups
pub const G1 = @import("bn254/G1.zig");  // Curve over Fp
pub const G2 = @import("bn254/G2.zig");  // Curve over Fp2

// G1 Operations
const g1_zero = G1.zero();
const g1_generator = G1.generator();
const g1_point = try G1.fromAffine(x, y);
const g1_sum = try G1.add(p1, p2);
const g1_double = try G1.double(p);
const g1_scalar_mul = try G1.multiply(p, scalar);
const on_curve = G1.isOnCurve(p);
const in_subgroup = G1.isInSubgroup(p);

// G2 Operations (similar API)
const g2_zero = G2.zero();
const g2_generator = G2.generator();
const g2_point = try G2.fromAffine(x, y);  // x, y are Fp2 elements
const g2_sum = try G2.add(p1, p2);

// Pairing
const pairing_result = try bn254.pairing(g1_points, g2_points);  // bool

// Precompile Operations (0x06, 0x07, 0x08)
const result = try bn254.bn254Add(&input_128_bytes, output);
const result = try bn254.bn254Mul(&input_96_bytes, output);
const valid = try bn254.bn254Pairing(input_bytes);  // Variable length
```

**TypeScript Pure API (✅ AUDITED via @noble/curves):**
```typescript
import { Bn254 } from '@tevm/voltaire';

// Field Elements
namespace Bn254.Fp {
    function from(value: bigint): Fp;
    function add(a: Fp, b: Fp): Fp;
    function mul(a: Fp, b: Fp): Fp;
    function inv(a: Fp): Fp;
    function sub(a: Fp, b: Fp): Fp;
    function square(a: Fp): Fp;
    function isZero(a: Fp): boolean;
    function equals(a: Fp, b: Fp): boolean;
}

namespace Bn254.Fp2 {
    type Fp2 = { c0: Fp; c1: Fp };  // c0 + c1*u

    function from(c0: bigint, c1: bigint): Fp2;
    function add(a: Fp2, b: Fp2): Fp2;
    function mul(a: Fp2, b: Fp2): Fp2;
    function inv(a: Fp2): Fp2;
    function square(a: Fp2): Fp2;
    function isZero(a: Fp2): boolean;
}

// G1 Operations (curve over Fp)
namespace Bn254.G1 {
    type Point = { x: Fp; y: Fp; z: Fp };  // Projective coordinates

    const ZERO: Point;  // Point at infinity
    const GENERATOR: Point;

    // Construction
    function fromAffine(x: bigint, y: bigint): Point;
    function toAffine(point: Point): { x: bigint; y: bigint };

    // Operations
    function add(a: Point, b: Point): Point;
    function double(point: Point): Point;
    function multiply(point: Point, scalar: bigint): Point;
    function multiplyUnsafe(point: Point, scalar: bigint): Point;  // Faster, no checks
    function negate(point: Point): Point;

    // Validation
    function isZero(point: Point): boolean;
    function equals(a: Point, b: Point): boolean;
    function isOnCurve(point: Point): boolean;
    function isInSubgroup(point: Point): boolean;

    // Serialization
    function toBytes(point: Point): Uint8Array;  // 64 bytes (x || y)
    function fromBytes(bytes: Uint8Array): Point;
    function toHex(point: Point): Hex;
    function fromHex(hex: Hex): Point;
}

// G2 Operations (curve over Fp2)
namespace Bn254.G2 {
    type Point = { x: Fp2; y: Fp2; z: Fp2 };

    const ZERO: Point;
    const GENERATOR: Point;

    // Construction
    function fromAffine(x: [bigint, bigint], y: [bigint, bigint]): Point;
    function toAffine(point: Point): { x: [bigint, bigint]; y: [bigint, bigint] };

    // Operations (same as G1)
    function add(a: Point, b: Point): Point;
    function double(point: Point): Point;
    function multiply(point: Point, scalar: bigint): Point;
    function negate(point: Point): Point;

    // Validation
    function isZero(point: Point): boolean;
    function equals(a: Point, b: Point): boolean;
    function isOnCurve(point: Point): boolean;
    function isInSubgroup(point: Point): boolean;

    // Serialization
    function toBytes(point: Point): Uint8Array;  // 128 bytes
    function fromBytes(bytes: Uint8Array): Point;
}

// Pairing
function pairing(g1Points: G1.Point[], g2Points: G2.Point[]): boolean;

// Precompile Interface (matches Ethereum precompiles 0x06, 0x07, 0x08)
function ecAdd(p1: G1.Point, p2: G1.Point): G1.Point;  // 0x06
function ecMul(point: G1.Point, scalar: bigint): G1.Point;  // 0x07
function ecPairing(pairs: Array<[G1.Point, G2.Point]>): boolean;  // 0x08
```

**TypeScript Arkworks API (✅ PRODUCTION — Rust via FFI):**
```typescript
import { Bn254Ark } from '@tevm/voltaire/bn254-ark';

// Same interface as pure TypeScript, but calls Arkworks Rust library
// Significantly faster for production use
// All G1/G2/pairing operations available with identical API

// Example usage (API identical to pure TS):
const sum = Bn254Ark.G1.add(p1, p2);  // Uses Arkworks
const result = Bn254Ark.pairing(g1Points, g2Points);  // Arkworks pairing
```

### EIP-712 (⚠️ UNAUDITED)

**Zig API:**
```zig
const domain = try Eip712.create_domain(allocator, "MyDApp", "1.0.0", 1, null);
defer {
    var mut_domain = domain;
    mut_domain.deinit(allocator);
}

var typed_data = try Eip712.create_simple_typed_data(allocator, domain, "Transfer");
defer typed_data.deinit(allocator);

const props = [_]Eip712.TypeProperty{
    .{ .name = "from", .type = "address" },
    .{ .name = "to", .type = "address" },
    .{ .name = "amount", .type = "uint256" },
};
try typed_data.types.put(allocator, "Transfer", &props);

const hash = try Eip712.unaudited_hashTypedData(allocator, &typed_data);
const signature = try Eip712.unaudited_signTypedData(allocator, &typed_data, private_key);
const recovered = try Eip712.unaudited_recoverTypedDataAddress(allocator, &typed_data, signature);
```

**TypeScript API:**
```typescript
import { Eip712 } from '@tevm/voltaire';

type Domain = {
    name?: string;
    version?: string;
    chainId?: number;
    verifyingContract?: Address;
    salt?: Hash;
};

type TypedData<T = Record<string, any>> = {
    domain: Domain;
    types: Record<string, Array<{ name: string; type: string }>>;
    primaryType: string;
    message: T;
};

// Hashing
const domainHash = Eip712.hashDomain(domain);
const structHash = Eip712.hashStruct(typedData, 'Transfer', message);
const typedDataHash = Eip712.hashTypedData(typedData);

// Signing/Verification
const signature = Eip712.sign(typedData, privateKey);
const isValid = Eip712.verify(typedData, signature, address);
const recovered = Eip712.recoverAddress(typedData, signature);

// Encoding
const typeString = Eip712.encodeType(typedData, 'Transfer');
const encoded = Eip712.encodeData(typedData, 'Transfer', message);

// Validation
Eip712.validateTypedData(typedData);  // Throws on invalid
const valid = Eip712.isValidTypedData(typedData);
```

---

## TypeScript/JavaScript API

<ts_overview>
The library provides TypeScript bindings in two forms:
1. **Pure TypeScript** (no dependencies) - primitives, ABI, numeric, bytecode, opcodes, gas, logs
2. **Bun FFI wrappers** (requires native lib) - Keccak-256, EIP-191

Install: `npm install @tevm/voltaire` or `bun add @tevm/voltaire`
</ts_overview>

### ABI Encoding/Decoding (Pure TypeScript)

```typescript
import {
  encodeAbiParameters,
  decodeAbiParameters,
  encodeFunctionData,
  decodeFunctionData,
  encodeEventTopics,
  encodePacked,
  computeSelector,
  uint256Value,
  addressValue,
  bytesValue
} from '@tevm/voltaire';

// Basic encoding
const encoded = encodeAbiParameters(
  [{ type: 'address' }, { type: 'uint256' }],
  ['0xa0Ee7A142d267C1f36714E4a8F75612F20a79720', 1000000000000000000n]
);

// Decoding
const [address, amount] = decodeAbiParameters(
  [{ type: 'address' }, { type: 'uint256' }],
  encoded
);

// Function data
const calldata = encodeFunctionData(
  'transfer(address,uint256)',
  [{ type: 'address' }, { type: 'uint256' }],
  ['0x1234...', 1000n]
);

const { selector, parameters } = decodeFunctionData(
  [{ type: 'address' }, { type: 'uint256' }],
  calldata
);

// Event topics
const topics = encodeEventTopics(
  'Transfer(address,address,uint256)',
  [{ type: 'address', indexed: true }, { type: 'address', indexed: true }, { type: 'uint256' }],
  ['0xfrom...', '0xto...', null]  // null = not indexed
);

// Packed encoding (for keccak256)
const packed = encodePacked(
  [{ type: 'address' }, { type: 'uint256' }],
  ['0x1234...', 42n]
);

// Compute function selector
const selector = computeSelector('transfer(address,uint256)');  // 0xa9059cbb

// Type-safe value helpers
const params = [
  addressValue('0x1234...'),
  uint256Value(1000n),
  bytesValue(new Uint8Array([1, 2, 3]))
];
```

### Numeric Conversions (Pure TypeScript)

```typescript
import {
  parseEther,
  formatEther,
  parseGwei,
  formatGwei,
  parseUnits,
  formatUnits,
  gweiToWei,
  weiToGwei,
  etherToWei,
  weiToEther
} from '@tevm/voltaire';

// Parse string to wei
const oneEth = parseEther('1.0');  // 1000000000000000000n
const gasPrice = parseGwei('20');  // 20000000000n
const custom = parseUnits('1.5', 6);  // 1500000n (6 decimals)

// Format wei to string
const ethStr = formatEther(1000000000000000000n);  // "1.0"
const gweiStr = formatGwei(20000000000n);  // "20"
const customStr = formatUnits(1500000n, 6);  // "1.5"

// Direct conversions
const wei1 = gweiToWei(20n);  // 20000000000n
const gwei1 = weiToGwei(20000000000n);  // 20n
const wei2 = etherToWei(1n);  // 1000000000000000000n
const eth1 = weiToEther(1000000000000000000n);  // 1n
```

### Keccak-256 (Bun FFI - Requires Native Lib)

```typescript
import { keccak256, keccak256Empty } from '@tevm/voltaire';

// Hash string or Uint8Array
const hash1 = keccak256('hello world');
const hash2 = keccak256(new Uint8Array([1, 2, 3]));

// Pre-computed empty hash constant
const emptyHash = keccak256Empty;  // Hash of empty input

// Returns Uint8Array (32 bytes)
```

### EIP-191 Personal Message (Bun FFI - Requires Native Lib)

```typescript
import { hashMessage } from '@tevm/voltaire';

// Hash message with EIP-191 prefix
const msgHash = hashMessage('Sign this message');
// Adds prefix: "\x19Ethereum Signed Message:\n{length}{message}"

// Returns Uint8Array (32 bytes)
```

### Bytecode Analysis (Pure TypeScript)

```typescript
import {
  analyzeJumpDestinations,
  validateBytecode,
  isValidJumpDest,
  isBytecodeBoundary
} from '@tevm/voltaire';

const bytecode = new Uint8Array([0x60, 0x80, 0x60, 0x40, 0x5b]); // PUSH1 0x80, PUSH1 0x40, JUMPDEST

// Analyze all valid JUMPDEST positions
const jumpDests = analyzeJumpDestinations(bytecode);  // Set { 4 }

// Validate bytecode structure
const isValid = validateBytecode(bytecode);  // true

// Check specific position
const canJump = isValidJumpDest(bytecode, 4);  // true
const isBoundary = isBytecodeBoundary(bytecode, 2);  // true
```

### Opcode Utilities (Pure TypeScript)

```typescript
import { Opcode, isPush, isDup, isSwap, isStateModifying } from '@tevm/voltaire';

// Check opcode types
isPush(Opcode.PUSH1);  // true
isDup(Opcode.DUP1);  // true
isSwap(Opcode.SWAP1);  // true
isStateModifying(Opcode.SSTORE);  // true

// Gas costs and stack operations available
```

### Gas Calculations (Pure TypeScript)

```typescript
import {
  calculateNextBaseFee,
  calculateIntrinsicGas,
  calculateMemoryGasCost
} from '@tevm/voltaire';

// EIP-1559 base fee calculation
const nextBaseFee = calculateNextBaseFee(
  1000000000n,  // current base fee
  15000000,     // gas used
  15000000      // gas target
);

// Transaction intrinsic gas
const intrinsicGas = calculateIntrinsicGas(
  new Uint8Array([1, 2, 3]),  // calldata
  false,  // not contract creation
  []      // access list
);

// Memory expansion gas
const memoryGas = calculateMemoryGasCost(1024);  // bytes
```

### Hardfork Utilities (Pure TypeScript)

```typescript
import { Hardfork, isAtLeast, isBefore } from '@tevm/voltaire';

// Version comparisons
isAtLeast(Hardfork.LONDON, Hardfork.BERLIN);  // true
isBefore(Hardfork.BERLIN, Hardfork.LONDON);  // true

// Supported: FRONTIER, HOMESTEAD, DAO, TANGERINE, SPURIOUS, BYZANTIUM,
// CONSTANTINOPLE, PETERSBURG, ISTANBUL, MUIR_GLACIER, BERLIN, LONDON,
// ARROW_GLACIER, GRAY_GLACIER, PARIS, SHANGHAI, CANCUN, PRAGUE
```

### SIWE (Sign-In with Ethereum) (Pure TypeScript)

```typescript
import { parseSiweMessage, validateSiweMessage } from '@tevm/voltaire';

const message = `example.com wants you to sign in with your Ethereum account:
0x1234567890123456789012345678901234567890

Sign in to Example

URI: https://example.com
Version: 1
Chain ID: 1
Nonce: 32891757
Issued At: 2023-01-01T00:00:00Z`;

// Parse SIWE message
const parsed = parseSiweMessage(message);

// Validate message structure and expiration
const isValid = validateSiweMessage(parsed);
```

### Event Logs (Pure TypeScript)

```typescript
import { parseEventLog, filterLogsByTopics } from '@tevm/voltaire';

// Parse event log
const log = parseEventLog(
  'Transfer(address,address,uint256)',
  logData  // { topics: [...], data: '0x...' }
);

// Filter logs by topics
const filtered = filterLogsByTopics(logs, [
  '0x...',  // topic0 (event signature)
  '0x...',  // topic1
  null      // any topic2
]);
```

<ts_status>
**Implementation Status:**
- ✅ Fully implemented: All primitives, all crypto modules use audited libraries (@noble, c-kzg-4844)
- ✅ WASM bindings: Available for performance-critical primitives (see WASM section below)

**Requirements:**
- Pure TypeScript modules work in any JS environment (Node.js, Bun, Deno, browsers)
- WASM modules provide optional performance boost, fallback to TypeScript if unavailable
- Build WASM: `zig build` → creates WebAssembly modules
</ts_status>

---

## WASM Bindings

<wasm_overview>
The library provides WebAssembly bindings for performance-critical operations. WASM modules are colocated with TypeScript implementations (e.g., `address.ts` + `address.wasm.ts` in same directory).

**Architecture:**
- TypeScript implementations are primary (always available)
- WASM modules are performance optimization layer
- Automatic fallback if WASM unavailable
- Zero-copy operations where possible

**Available WASM modules** (all in `src/` directories):
</wasm_overview>

<wasm_primitives>
### Primitives WASM

- **`address.wasm.ts`**: Address operations (checksum, CREATE/CREATE2 addresses)
- **`bytecode.wasm.ts`**: Bytecode analysis (JUMPDEST detection, opcode parsing)
- **`hash.wasm.ts`**: SHA256, RIPEMD160, BLAKE2b hash functions
- **`hex.wasm.ts`**: Hex encoding/decoding
- **`rlp.wasm.ts`**: RLP encoding/decoding
- **`transaction.wasm.ts`**: Transaction type detection
- **`uint256.wasm.ts`**: U256 operations
- **`wallet.wasm.ts`**: Key generation, public key compression
- **`abi.wasm.ts`**: ABI encoding/decoding (awaiting C API layer)

**Usage Pattern:**
```typescript
import { isWasmAvailable, addressFromHexWasm } from '@tevm/voltaire';

// Check availability
if (isWasmAvailable()) {
    const addr = addressFromHexWasm('0x...');  // Fast WASM path
} else {
    const addr = Address.fromHex('0x...');  // TypeScript fallback
}
```
</wasm_primitives>

<wasm_crypto>
### Crypto WASM

- **`blake2.wasm.ts`**: BLAKE2b with variable output lengths
- **`bn254.wasm.ts`**: BN254 curve operations (G1, G2, pairing) - **Pure TS only**
- **`bn254.ark.ts`**: BN254 via Arkworks Rust library (audited, production-ready)
- **`eip712.wasm.ts`**: EIP-712 typed data hashing
- **`keccak256.wasm.ts`**: Keccak-256 with hardware acceleration detection
- **`ripemd160.wasm.ts`**: RIPEMD-160 hash
- **`secp256k1.wasm.ts`**: ECDSA operations (sign, verify, recover)
- **`sha256.wasm.ts`**: SHA-256 with hardware acceleration

**BN254 Implementations:**
1. **Pure TypeScript** (`bn254.ts`): Field arithmetic, curve ops, pairing - complete, audited by @noble
2. **Pure Zig** (`bn254_c.zig`): Native implementation - ⚠️ UNAUDITED, use for testing only
3. **Arkworks** (`bn254.ark.ts` + `bn254_ark_c.zig`): Rust library via FFI - audited, production-ready

**Usage:**
```typescript
import { Bn254 } from '@tevm/voltaire';  // Pure TS (always available)
import { bn254AddWasm } from '@tevm/voltaire';  // WASM (faster, optional)
import { bn254AddArk } from '@tevm/voltaire';  // Arkworks (fastest, requires native)

// Automatic selection based on availability
const result = Bn254.G1.add(point1, point2);  // Uses best available
```
</wasm_crypto>

---

## Memory Patterns

```zig
// Same scope: defer allocator.destroy(thing);
// Ownership transfer: errdefer allocator.destroy(thing);
// GPA setup:
var gpa = std.heap.GeneralPurposeAllocator(.{}){};
defer _ = gpa.deinit();
const allocator = gpa.allocator();
```

---

## Security Requirements

<crypto_safety>
**Constant-time ops required. All crypto must:**
- Validate inputs (sig components, curve points)
- Never panic (return errors)
- Clear sensitive memory
- No timing leaks (no early returns in comparisons)

```zig
// ✅ Constant-time compare
var result: u8 = 0;
for (a, b) |byte_a, byte_b| { result |= byte_a ^ byte_b; }
return result == 0;
// ❌ if (byte_a != byte_b) return false;  // Leaks timing
```
</crypto_safety>

<unaudited_functions>
**Unaudited (DO NOT use in prod):** All `unaudited_*` functions, all `Eip712.unaudited_*`, RIPEMD160, Blake2, ModExp, pure Zig BN254
**Audited libs:** BLS12-381 (BLST), KZG (c-kzg-4844), BN254 (Arkworks), SHA256
</unaudited_functions>

---

## Documentation

<docs_base_url>
Base: https://github.com/evmts/voltaire/blob/main/docs
</docs_base_url>

<main_docs>
- [Documentation Overview](https://github.com/evmts/voltaire/blob/main/docs/DOCUMENTATION.md)
- [README](https://github.com/evmts/voltaire/blob/main/docs/README.md)
</main_docs>

<crypto_docs>
**Cryptography:**
- [Crypto Module](https://github.com/evmts/voltaire/blob/main/docs/crypto/crypto.zig.md)
- [Hash Utils](https://github.com/evmts/voltaire/blob/main/docs/crypto/hash.zig.md)
- [Hash Algorithms](https://github.com/evmts/voltaire/blob/main/docs/crypto/hash_algorithms.zig.md)
- [secp256k1](https://github.com/evmts/voltaire/blob/main/docs/crypto/secp256k1.zig.md)
</crypto_docs>

<primitives_docs>
**Primitives:**
- [Event Logs](https://github.com/evmts/voltaire/blob/main/docs/primitives/logs.md)
- [Hardforks](https://github.com/evmts/voltaire/blob/main/docs/primitives/hardfork.md)
- [Sign-In with Ethereum (SIWE)](https://github.com/evmts/voltaire/blob/main/docs/primitives/siwe.md)
</primitives_docs>

<precompiles_docs>
**Precompiles:**
- [Overview](https://github.com/evmts/voltaire/blob/main/docs/precompiles/README.md)
- [Common Types](https://github.com/evmts/voltaire/blob/main/docs/precompiles/common.md)
- [Utils](https://github.com/evmts/voltaire/blob/main/docs/precompiles/utils.md)
- [ECRecover (0x01)](https://github.com/evmts/voltaire/blob/main/docs/precompiles/ecrecover.md)
- [SHA256 (0x02)](https://github.com/evmts/voltaire/blob/main/docs/precompiles/sha256.md)
- [RIPEMD160 (0x03)](https://github.com/evmts/voltaire/blob/main/docs/precompiles/ripemd160.md)
- [Identity (0x04)](https://github.com/evmts/voltaire/blob/main/docs/precompiles/identity.md)
- [ModExp (0x05)](https://github.com/evmts/voltaire/blob/main/docs/precompiles/modexp.md)
- [BN254 Add (0x06)](https://github.com/evmts/voltaire/blob/main/docs/precompiles/bn254_add.md)
- [BN254 Mul (0x07)](https://github.com/evmts/voltaire/blob/main/docs/precompiles/bn254_mul.md)
- [BN254 Pairing (0x08)](https://github.com/evmts/voltaire/blob/main/docs/precompiles/bn254_pairing.md)
- [Blake2F (0x09)](https://github.com/evmts/voltaire/blob/main/docs/precompiles/blake2f.md)
- [Point Evaluation (0x0a)](https://github.com/evmts/voltaire/blob/main/docs/precompiles/point_evaluation.md)
- [BLS12-381 G1 Add (0x0b)](https://github.com/evmts/voltaire/blob/main/docs/precompiles/bls12_g1_add.md)
- [BLS12-381 G1 Mul (0x0c)](https://github.com/evmts/voltaire/blob/main/docs/precompiles/bls12_g1_mul.md)
- [BLS12-381 G1 MSM (0x0d)](https://github.com/evmts/voltaire/blob/main/docs/precompiles/bls12_g1_msm.md)
- [BLS12-381 G2 Add (0x0e)](https://github.com/evmts/voltaire/blob/main/docs/precompiles/bls12_g2_add.md)
- [BLS12-381 G2 Mul (0x0f)](https://github.com/evmts/voltaire/blob/main/docs/precompiles/bls12_g2_mul.md)
- [BLS12-381 G2 MSM (0x10)](https://github.com/evmts/voltaire/blob/main/docs/precompiles/bls12_g2_msm.md)
- [BLS12-381 Pairing (0x11)](https://github.com/evmts/voltaire/blob/main/docs/precompiles/bls12_pairing.md)
- [BLS12-381 Map Fp to G1 (0x12)](https://github.com/evmts/voltaire/blob/main/docs/precompiles/bls12_map_fp_to_g1.md)
- [BLS12-381 Map Fp2 to G2 (0x13)](https://github.com/evmts/voltaire/blob/main/docs/precompiles/bls12_map_fp2_to_g2.md)
</precompiles_docs>

<benchmarking_docs>
**Benchmarking & Performance:**
- [BENCHMARKING.md](https://github.com/evmts/voltaire/blob/main/BENCHMARKING.md) — How to run benchmarks
- [BENCHMARK_RESULTS.md](https://github.com/evmts/voltaire/blob/main/BENCHMARK_RESULTS.md) — TypeScript/FFI performance comparisons
- [ZIG_BENCHMARK_RESULTS.md](https://github.com/evmts/voltaire/blob/main/ZIG_BENCHMARK_RESULTS.md) — Native Zig performance data
</benchmarking_docs>

<examples_docs>
**Examples:**
- [Examples Overview](https://github.com/evmts/voltaire/blob/main/examples/README.md) — Zig and TypeScript examples
- [TypeScript Examples](https://github.com/evmts/voltaire/blob/main/examples/typescript/) — Organized TypeScript examples
</examples_docs>

<external_resources>
**External Resources:**
- [Zig 0.15.1 Docs](https://ziglang.org/documentation/0.15.1/)
- [Ethereum EIPs](https://eips.ethereum.org/)
- [Repository](https://github.com/evmts/voltaire)
</external_resources>
