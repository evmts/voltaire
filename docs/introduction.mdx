---
title: What is Tevm?
description: Modern general-purpose Ethereum library for TypeScript
---

Tevm is a modern general-purpose Ethereum library. Type-safe primitives, WASM-accelerated performance, and designed for AI-assisted development.

## Simple, Intuitive API

Tevm's API mirrors Ethereum specifications. Each primitive is a simple constructor:

```typescript
// Types map one-to-one with Ethereum specs
import {
  Address, Keccak256, Bytes32, Wei, Gwei, Ether,
  Transaction, PrivateKey, Signer, Bytecode, Opcode,
  Rlp, Abi, FeeMarket, AccessList, Blob,
  Secp256k1, Sha256, Kzg,
  Chain, Hardfork, Rpc
} from "tevm";

// Addresses
const address: Address = Address("0x742d35Cc6634C0532925a3b844Bc9e7595f51e3e");
const addressHex = address.toHex();          // "0x742d35cc..."
const checksummed = address.toChecksummed(); // "0x742d35Cc..."

// Hashes and bytes
const hash: Keccak256 = Keccak256("0x1234");
const bytes: Bytes32 = Bytes32("0x" + "0".repeat(64));
const bytesHex: Bytes32.Hex = bytes.toHex();

// Numbers and denominations
const value: Wei = Wei(1000000000000000000n);
const inEther = value.toEther();  // 1n (type: Ether)
const inGwei = value.toGwei();    // 1000000000n (type: Gwei)

// Bytecode and opcodes
const code = Bytecode("0x6080604052");
const analysis = code.analyze();
const pushOp = Opcode.PUSH1;                 // 0x60

// Transactions
const tx = Transaction({
  to: address,
  value: value,
  data: bytes,
  gasLimit: 21000n
});

// Private keys and signatures
const privateKey: PrivateKey = PrivateKey.random();
const signer = Signer.fromPrivateKey(privateKey);
const signature: Secp256k1.Signature = signer.sign(hash);
const recovered: Address = signer.recover(hash);

// RLP encoding
const encoded = Rlp([address, value]);
const decoded = Rlp.decode(encoded);

// ABI encoding
const funcSig = Abi.encodeParams("transfer(address,uint256)", [address, value]);
const encoded = funcSig.toAbiEncoded();

// Fee market (EIP-1559)
const baseFee = FeeMarket.BaseFee(/* ... */);

// Access lists (EIP-2930)
const accessList = AccessList([{
  address: address,
  storageKeys: [bytes]
}]);

// Blobs (EIP-4844)
const blob = Blob(131072); // 128KB
const commitment = Kzg.Commitment(blob);

// Cryptography
const keccak = Keccak256.hashString("hello");
const sha = Sha256.hashString("world");

// Chain configuration
const chain = Chain.mainnet;
const hardfork = Hardfork.cancun;

// JSON-RPC requests
const balanceRequest = Rpc.Eth.GetBalanceRequest(address, "latest");
```

## What's Included

<Card title="Highly Customizable JSON-RPC Provider" icon="network-wired" href="/jsonrpc-provider" horizontal />
<Card title="Type-Safe and Feature-Full Ethereum Primitives" icon="cube" href="/primitives/abi" horizontal />
<Card title="High Performance Cryptography" icon="lock" href="/crypto/comparison" horizontal />
<Card title="Advanced Bytecode and EVM Capabilities" icon="bolt" href="/evm" horizontal />
<Card title="ENS (Ethereum Name Service)" icon="globe" href="/primitives/ens" horizontal />
<Card title="Sign-in with Ethereum" icon="user-shield" href="/primitives/siwe" horizontal />

## What's Unique?

- **[Branded Types](/getting-started/branded-types)** - Runtime-validated TypeScript types. Prevents passing hex strings where addresses are expected, address casing errors, and type confusion.
- **[WASM-Accelerated](/getting-started/wasm)** - High-performance implementations for cryptography, encoding, and EVM execution written in Zig.
- **[LLM-Optimized](/getting-started/llm-optimized)** - API mirrors the Ethereum specification. Lots of time has been put into polishing the [MCP server](/mcp) and [llms.txt](/llms.txt) along with the docs themselves.
- **[Multiplatform](/getting-started/multiplatform)** - Works everywhere: TypeScript in Node.js, browsers, serverless, and any language with C-FFI support. Consistent API across TypeScript, Zig, and C-FFI environments.
- **[Powerful Features](/getting-started/powerful-features)** - Features common to all general-purpose Ethereum libraries, plus unique ones exclusive to Tevm such as EVM execution and bytecode analysis.

