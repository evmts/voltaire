---
title: What is Voltaire?
description: Modern general-purpose Ethereum library for TypeScript, Zig, C, and Swift
---

Voltaire is a modern general-purpose Ethereum library for TypeScript, Zig, C, and Swift. Type-safe primitives, WASM-accelerated performance, and designed for AI-assisted development.

<Tip>
**For application development**, we recommend [voltaire-effect](/services/overview) — Effect.ts integration with typed errors, composable operations, and production-ready contract interactions.
</Tip>

## Production-Ready Contract Interactions

Define your contracts once, use them everywhere with full type safety:

```typescript
import { Effect } from 'effect'
import {
  ContractRegistryService,
  makeContractRegistry,
  Provider,
  HttpTransport
} from 'voltaire-effect'

const Contracts = makeContractRegistry({
  USDC: { abi: erc20Abi, address: '0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48' },
  WETH: { abi: erc20Abi, address: '0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2' },
})

const program = Effect.gen(function* () {
  const { USDC, WETH } = yield* ContractRegistryService
  const usdcBalance = yield* USDC.read.balanceOf(userAddress)
  const wethBalance = yield* WETH.read.balanceOf(userAddress)
  return { usdcBalance, wethBalance }
}).pipe(
  Effect.provide(Contracts),
  Effect.provide(Provider),
  Effect.provide(HttpTransport('https://eth.llamarpc.com'))
)
```

<Note>
Want to explore the primitives directly? Open the [Playground](https://playground.tevm.sh).
</Note>

## Simple, Intuitive API

Voltaire's API mirrors Ethereum specifications:

```typescript
import { Address, Wei, Gwei, Ether } from '@tevm/voltaire';
import { Hex } from '@tevm/voltaire/Hex';
import { Bytes32 } from '@tevm/voltaire/Bytes32';
import { Rlp } from '@tevm/voltaire/Rlp';
import { Abi } from '@tevm/voltaire/Abi';
import { Keccak256 } from '@tevm/voltaire/Keccak256';

// Addresses - branded Uint8Array with type safety
const addr = Address('0x742d35Cc6634C0532925a3b844Bc9e7595f51e3e');
console.log(addr.toHex());        // "0x742d35cc..."
console.log(addr.toChecksummed()); // "0x742d35Cc..."

// Denominations - type-safe ETH value handling
const value = Wei(1000000000000000000n);
console.log(Wei.toEther(value));  // "1"
console.log(Wei.toGwei(value));   // "1000000000"

// Type safety prevents denomination confusion
// ❌ This won't compile - Wei and Gwei are incompatible types
// const confusion: WeiType = someGweiValue; // Type Error!

// Fixed-size bytes
const hash = Bytes32('0x' + '12'.repeat(32));
console.log(hash.toHex());

// Keccak256 hashing
const messageHash = Keccak256('hello');
const selector = Keccak256.selector('transfer(address,uint256)');
// Uint8Array(4) [0xa9, 0x05, 0x9c, 0xbb]

// RLP encoding
const encoded = Rlp.encode([addr, Hex.fromNumber(42n)]);
const decoded = Rlp.decode(encoded);

// ABI encoding
const transferAbi = {
  type: 'function',
  name: 'transfer',
  inputs: [
    { type: 'address', name: 'to' },
    { type: 'uint256', name: 'amount' }
  ],
  outputs: [{ type: 'bool' }],
  stateMutability: 'nonpayable'
} as const;

const calldata = Abi.Function.encodeParams(transferAbi, [
  '0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045',
  1000000000000000000n
]);
```

## What's Included

<Card title="Highly Customizable JSON-RPC Provider" icon="network-wired" href="/jsonrpc-provider" horizontal />
<Card title="Type-Safe and Feature-Full Ethereum Primitives" icon="cube" href="/primitives/abi" horizontal />
<Card title="High Performance Cryptography" icon="lock" href="/crypto/comparison" horizontal />
<Card title="Advanced Bytecode and EVM Capabilities" icon="bolt" href="/evm" horizontal />
<Card title="ENS (Ethereum Name Service)" icon="globe" href="/primitives/ens" horizontal />
<Card title="Sign-in with Ethereum" icon="user-shield" href="/primitives/siwe" horizontal />

## What's Unique?

- **[Branded Types](/getting-started/branded-types)** - Runtime-validated TypeScript types. Prevents passing hex strings where addresses are expected, address casing errors, and type confusion.
- **[High-Performance](/getting-started/wasm)** - Optimized implementations balancing performance and bundle size. For example, Keccak256 is both faster and smaller than pure JavaScript alternatives.
- **[LLM-Optimized](/getting-started/llm-optimized)** - API mirrors the Ethereum specification. Lots of time has been put into polishing the [MCP server](/model-context-protocol) and [llms.txt](/llms.txt) along with the docs themselves.
- **[Multiplatform](/getting-started/multiplatform)** - Works everywhere: TypeScript in Node.js, browsers, serverless, and any language with C-FFI support. Consistent API across TypeScript, Zig, and C-FFI environments.
  <Tip>Native FFI is currently supported on <strong>Bun</strong>. In <strong>Node.js</strong>, use the regular TypeScript API or WASM.</Tip>
- **[Skills](/concepts/skills)** - Higher-level abstractions as copyable implementations, not rigid library exports. Like shadcn/ui for Ethereum—copy a provider, contract wrapper, or React integration into your codebase and customize it for your needs.
