---
title: C SDK
description: Low-level C bindings for the Guillotine EVM
---

import { Callout } from 'vocs/components'

# C SDK

C bindings for the Guillotine Ethereum Virtual Machine implementation in Zig.

<Callout type="warning">
**Experimental/PoC**: This SDK is a vibecoded proof-of-concept. APIs are unstable and may change. We're looking for early users to try it and tell us what APIs you want.

- **Maturity**: Experimental proof-of-concept
- **API stability**: Unstable; breaking changes expected
- **Feedback**: [GitHub Issues](https://github.com/evmts/Guillotine/issues) or [Telegram](https://t.me/+ANThR9bHDLAwMjUx)
</Callout>

## Overview

Guillotine provides C bindings through `src/root_c.zig`, allowing you to integrate the EVM into C/C++ applications or any language with FFI support.

## Building from Source

::::steps
### Prerequisites

Ensure you have:
- Zig compiler (0.14.1 or later)
- Git (for submodules)
- C compiler (for linking)

### Clone and Initialize

```bash
git clone https://github.com/evmts/Guillotine.git
cd Guillotine
git submodule update --init --recursive
```

### Build the Library

For a **shared library** (.so/.dylib/.dll):
```bash
zig build-lib -dynamic src/root_c.zig -femit-bin=libguillotine.so
```

For a **static library** (.a/.lib):
```bash
zig build-lib src/root_c.zig -femit-bin=libguillotine.a
```

Using the build system:
```bash
zig build
# The library will be in zig-out/lib/
```
::::

## Quick Start

### Basic Example

```c filename="example.c" showLineNumbers
#include <guillotine.h>
#include <stdio.h>

int main() {
    // Initialize the library
    if (evm_init() != 0) {
        fprintf(stderr, "Failed to initialize EVM\n");
        return -1;
    }

    // Create an EVM frame
    uint8_t bytecode[] = {
        0x60, 0x05,  // PUSH1 5
        0x60, 0x0A,  // PUSH1 10
        0x01,        // ADD
        0x00         // STOP
    };

    void* frame = evm_frame_create(bytecode, sizeof(bytecode), 1000000);
    if (!frame) {
        fprintf(stderr, "Failed to create frame\n");
        return -1;
    }

    // Execute the bytecode
    int result = evm_frame_execute(frame);
    if (result == 0) {
        printf("Execution successful\n");
    }

    // Clean up
    evm_frame_destroy(frame);
    evm_cleanup();
    
    return 0;
}
```

### Compilation

```bash
# Compile with static library
gcc example.c -L./zig-out/lib -lguillotine -o example

# Compile with shared library
gcc example.c -L./zig-out/lib -lguillotine -Wl,-rpath,./zig-out/lib -o example

# Run
./example
```

## API Reference

### Core Modules

The C API exposes functionality from several modules:

| Module | Header | Description |
|--------|--------|-------------|
| **Frame API** | `frame_c.zig` | EVM execution frame management |
| **Stack API** | `stack_c.zig` | Stack operations |
| **Memory API** | `memory_c.zig` | Memory management |
| **Bytecode API** | `bytecode_c.zig` | Bytecode handling and analysis |
| **Precompiles API** | `precompiles_c.zig` | Precompiled contracts |
| **Hardfork API** | `hardfork_c.zig` | Fork configuration |

### Initialization

```c
// Initialize the EVM library
int evm_init(void);

// Clean up resources
void evm_cleanup(void);
```

### Frame Operations

```c
// Create a new execution frame
void* evm_frame_create(
    const uint8_t* bytecode,
    size_t bytecode_len,
    uint64_t gas_limit
);

// Execute frame
int evm_frame_execute(void* frame);

// Get execution result
int evm_frame_get_result(
    void* frame,
    uint8_t* output,
    size_t* output_len,
    uint64_t* gas_used
);

// Destroy frame
void evm_frame_destroy(void* frame);
```

### Stack Operations

```c
// Create stack
void* evm_stack_create(void);

// Push operations
int evm_stack_push_u64(void* stack, uint64_t value);
int evm_stack_push_u256(void* stack, const uint8_t data[32]);

// Pop operations
int evm_stack_pop_u64(void* stack, uint64_t* value);
int evm_stack_pop_u256(void* stack, uint8_t data[32]);

// Stack info
size_t evm_stack_size(void* stack);
int evm_stack_peek(void* stack, size_t index, uint8_t data[32]);

// Cleanup
void evm_stack_destroy(void* stack);
```

### Memory Operations

```c
// Create memory
void* evm_memory_create(size_t initial_size);

// Write operations
int evm_memory_write_u8(void* memory, size_t offset, uint8_t value);
int evm_memory_write_u256(void* memory, size_t offset, const uint8_t data[32]);
int evm_memory_write_bytes(
    void* memory,
    size_t offset,
    const uint8_t* data,
    size_t len
);

// Read operations
int evm_memory_read_u8(void* memory, size_t offset, uint8_t* value);
int evm_memory_read_u256(void* memory, size_t offset, uint8_t data[32]);
int evm_memory_read_bytes(
    void* memory,
    size_t offset,
    uint8_t* data,
    size_t len
);

// Memory info
size_t evm_memory_size(void* memory);

// Cleanup
void evm_memory_destroy(void* memory);
```

### Error Codes

```c
#define EVM_SUCCESS           0
#define EVM_ERROR_OOM        -1  // Out of memory
#define EVM_ERROR_INVALID    -2  // Invalid parameter
#define EVM_ERROR_OVERFLOW   -3  // Stack overflow
#define EVM_ERROR_UNDERFLOW  -4  // Stack underflow
#define EVM_ERROR_GAS        -5  // Out of gas
#define EVM_ERROR_REVERT     -6  // Execution reverted
#define EVM_ERROR_OPCODE     -7  // Invalid opcode
#define EVM_ERROR_JUMP       -8  // Invalid jump
```

## Advanced Usage

### Complete EVM Execution

```c filename="full_evm.c"
#include <guillotine.h>
#include <string.h>
#include <stdlib.h>

typedef struct {
    void* frame;
    void* stack;
    void* memory;
    uint64_t gas_remaining;
} EVMContext;

EVMContext* evm_context_create(
    const uint8_t* bytecode,
    size_t bytecode_len,
    uint64_t gas_limit
) {
    EVMContext* ctx = malloc(sizeof(EVMContext));
    if (!ctx) return NULL;
    
    ctx->frame = evm_frame_create(bytecode, bytecode_len, gas_limit);
    ctx->stack = evm_stack_create();
    ctx->memory = evm_memory_create(0);
    ctx->gas_remaining = gas_limit;
    
    if (!ctx->frame || !ctx->stack || !ctx->memory) {
        evm_context_destroy(ctx);
        return NULL;
    }
    
    return ctx;
}

void evm_context_destroy(EVMContext* ctx) {
    if (!ctx) return;
    
    if (ctx->frame) evm_frame_destroy(ctx->frame);
    if (ctx->stack) evm_stack_destroy(ctx->stack);
    if (ctx->memory) evm_memory_destroy(ctx->memory);
    
    free(ctx);
}

int evm_context_execute(EVMContext* ctx) {
    return evm_frame_execute(ctx->frame);
}
```

### Bytecode Analysis

```c filename="analyze.c"
#include <guillotine.h>

typedef struct {
    size_t size;
    uint32_t num_jumpdests;
    uint32_t num_push_ops;
    bool has_invalid_opcodes;
} CBytecodeStats;

void analyze_bytecode(const uint8_t* code, size_t code_len) {
    void* bytecode = evm_bytecode_create(code, code_len);
    if (!bytecode) {
        printf("Failed to create bytecode object\n");
        return;
    }
    
    CBytecodeStats stats;
    if (evm_bytecode_get_stats(bytecode, &stats) == 0) {
        printf("Bytecode Analysis:\n");
        printf("  Size: %zu bytes\n", stats.size);
        printf("  Jump destinations: %u\n", stats.num_jumpdests);
        printf("  Push operations: %u\n", stats.num_push_ops);
        printf("  Has invalid opcodes: %s\n", 
               stats.has_invalid_opcodes ? "yes" : "no");
    }
    
    evm_bytecode_destroy(bytecode);
}
```

### Memory Management

All created objects must be properly destroyed to avoid memory leaks:

```c
// Pattern 1: Simple cleanup
void* obj = evm_something_create();
// Use object
evm_something_destroy(obj);

// Pattern 2: Error handling
void* obj = evm_something_create();
if (!obj) {
    // Handle error
    return -1;
}
// Use object
evm_something_destroy(obj);

// Pattern 3: Multiple resources
void* frame = NULL;
void* stack = NULL;
void* memory = NULL;

frame = evm_frame_create(bytecode, len, gas);
if (!frame) goto cleanup;

stack = evm_stack_create();
if (!stack) goto cleanup;

memory = evm_memory_create(0);
if (!memory) goto cleanup;

// Use resources

cleanup:
    if (memory) evm_memory_destroy(memory);
    if (stack) evm_stack_destroy(stack);
    if (frame) evm_frame_destroy(frame);
```

## Configuration

The EVM can be configured through `src/evm_config.zig`:

```zig filename="evm_config.zig"
const EvmConfig = struct {
    // Hardfork settings
    eips: Eips = Eips{ .hardfork = Hardfork.CANCUN },
    
    // Execution limits
    max_call_depth: u11 = 1024,
    max_input_size: u18 = 131072,  // 128 KB
    
    // Feature flags
    enable_precompiles: bool = true,
    enable_fusion: bool = true,
    
    // Stack and memory
    stack_size: u12 = 1024,
    memory_limit: u64 = 0xFFFFFF,
};
```

To build with custom configuration, modify `evm_config.zig` before building.

## Language Bindings

The C API can be used from various languages:

:::code-group

```python [Python]
import ctypes

# Load the library
lib = ctypes.CDLL('./libguillotine.so')

# Define function signatures
lib.evm_init.restype = ctypes.c_int
lib.evm_frame_create.argtypes = [
    ctypes.POINTER(ctypes.c_uint8),
    ctypes.c_size_t,
    ctypes.c_uint64
]
lib.evm_frame_create.restype = ctypes.c_void_p

# Use the library
if lib.evm_init() == 0:
    bytecode = bytes([0x60, 0x05, 0x60, 0x0A, 0x01, 0x00])
    frame = lib.evm_frame_create(bytecode, len(bytecode), 1000000)
    # ...
```

```javascript [Node.js]
const ffi = require('ffi-napi');

// Define the library interface
const lib = ffi.Library('./libguillotine', {
    'evm_init': ['int', []],
    'evm_frame_create': ['pointer', ['pointer', 'size_t', 'uint64']],
    'evm_frame_execute': ['int', ['pointer']],
    'evm_frame_destroy': ['void', ['pointer']],
    'evm_cleanup': ['void', []]
});

// Use the library
if (lib.evm_init() === 0) {
    const bytecode = Buffer.from([0x60, 0x05, 0x60, 0x0A, 0x01, 0x00]);
    const frame = lib.evm_frame_create(bytecode, bytecode.length, 1000000);
    // ...
}
```

```go [Go]
// #cgo LDFLAGS: -L. -lguillotine
// #include <guillotine.h>
import "C"
import "unsafe"

func main() {
    if C.evm_init() != 0 {
        panic("Failed to initialize EVM")
    }
    defer C.evm_cleanup()
    
    bytecode := []byte{0x60, 0x05, 0x60, 0x0A, 0x01, 0x00}
    frame := C.evm_frame_create(
        (*C.uint8_t)(unsafe.Pointer(&bytecode[0])),
        C.size_t(len(bytecode)),
        C.uint64_t(1000000),
    )
    defer C.evm_frame_destroy(frame)
    // ...
}
```

:::

## Testing

The library includes test functions for verification:

```c filename="test.c"
#include <guillotine.h>
#include <assert.h>

void run_tests() {
    // Test simple execution
    assert(evm_test_simple_execution() == 0);
    printf("‚úì Simple execution test passed\n");
    
    // Test stack operations
    assert(evm_test_stack_operations() == 0);
    printf("‚úì Stack operations test passed\n");
    
    // Test memory operations
    assert(evm_test_memory_operations() == 0);
    printf("‚úì Memory operations test passed\n");
    
    // Test integration
    assert(evm_test_integration() == 0);
    printf("‚úì Integration test passed\n");
    
    printf("\nAll tests passed!\n");
}

int main() {
    if (evm_init() != 0) {
        fprintf(stderr, "Failed to initialize EVM\n");
        return -1;
    }
    
    run_tests();
    
    evm_cleanup();
    return 0;
}
```

## Performance Considerations

<div style={{ display: 'grid', gridTemplateColumns: 'repeat(auto-fit, minmax(250px, 1fr))', gap: '1rem', marginBottom: '2rem' }}>
  <div style={{
    padding: '1rem',
    background: 'var(--vocs-color_background2)',
    border: '1px solid var(--vocs-color_border)',
    borderRadius: '8px'
  }}>
    <h4 style={{ marginTop: 0, color: '#10B981' }}>‚úÖ Do</h4>
    <ul style={{ margin: 0 }}>
      <li>Use static linking when possible</li>
      <li>Batch operations to reduce FFI overhead</li>
      <li>Enable bytecode fusion</li>
      <li>Reuse objects when possible</li>
    </ul>
  </div>
  
  <div style={{
    padding: '1rem',
    background: 'var(--vocs-color_background2)',
    border: '1px solid var(--vocs-color_border)',
    borderRadius: '8px'
  }}>
    <h4 style={{ marginTop: 0, color: '#EF4444' }}>‚ùå Don't</h4>
    <ul style={{ margin: 0 }}>
      <li>Forget to check return values</li>
      <li>Mix create/destroy from different threads</li>
      <li>Ignore memory cleanup</li>
      <li>Use excessive stack allocations</li>
    </ul>
  </div>
</div>

## Troubleshooting

:::details[Undefined symbols when linking]
**Solution**: Ensure you're linking against the correct libraries:
```bash
gcc your_program.c -L. -lguillotine -lc
```
:::

:::details[Segmentation faults]
**Solution**: Always check return values and ensure proper initialization:
```c
if (evm_init() != 0) {
    // Handle initialization failure
}

void* frame = evm_frame_create(...);
if (!frame) {
    // Handle creation failure
}
```
:::

:::details[Memory leaks]
**Solution**: Use valgrind to verify proper cleanup:
```bash
valgrind --leak-check=full ./your_program
```
Ensure all created objects are destroyed.
:::

## Examples

Check the `examples/` directory for complete examples:

- `examples/c/basic.c` - Basic EVM execution
- `examples/c/contract.c` - Contract deployment and calling
- `examples/c/analysis.c` - Bytecode analysis
- `examples/c/benchmark.c` - Performance benchmarking

## Next Steps

<div style={{ display: 'grid', gridTemplateColumns: 'repeat(2, 1fr)', gap: '1rem', marginTop: '2rem' }}>
  <a href="/sdks/python" style={{
    display: 'block',
    padding: '1.5rem',
    background: 'linear-gradient(135deg, rgba(59, 130, 246, 0.1), rgba(37, 99, 235, 0.05))',
    border: '1px solid rgba(59, 130, 246, 0.3)',
    borderRadius: '12px',
    textDecoration: 'none'
  }}>
    <h3 style={{ margin: '0 0 0.5rem 0' }}>üêç Python SDK</h3>
    <p style={{ margin: 0, color: 'var(--vocs-color_text2)' }}>
      High-level Python bindings via CFFI
    </p>
  </a>
  
  <a href="/sdks/rust" style={{
    display: 'block',
    padding: '1.5rem',
    background: 'linear-gradient(135deg, rgba(234, 88, 12, 0.1), rgba(220, 38, 38, 0.05))',
    border: '1px solid rgba(234, 88, 12, 0.3)',
    borderRadius: '12px',
    textDecoration: 'none'
  }}>
    <h3 style={{ margin: '0 0 0.5rem 0' }}>ü¶Ä Rust SDK</h3>
    <p style={{ margin: 0, color: 'var(--vocs-color_text2)' }}>
      Safe Rust wrapper with zero-copy FFI
    </p>
  </a>
</div>

## Support

<Callout type="info">
  **Need help?**
  - üìñ Browse [examples](https://github.com/evmts/Guillotine/tree/main/examples/c)
  - üí¨ Join our [Telegram community](https://t.me/+ANThR9bHDLAwMjUx)
  - üêõ Report [issues on GitHub](https://github.com/evmts/Guillotine/issues)
</Callout>