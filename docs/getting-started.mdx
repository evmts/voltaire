---
title: Getting Started
description: Learn the core patterns and architecture of Voltaire
---

# Getting Started

Voltaire is a modern Ethereum library built with performance, type safety, and tree-shaking as first-class priorities. This guide will teach you the core concepts and patterns that make Voltaire different.

## Prerequisites

- **Node.js:** 18.x or higher (20.x recommended)
- **Package Manager:** npm, bun, pnpm, or yarn
- **Knowledge:** Familiarity with JavaScript/TypeScript and basic Ethereum concepts (addresses, transactions, signatures)

<Tip>
New to Ethereum? Check out [ethereum.org/developers](https://ethereum.org/en/developers/) for fundamentals.
</Tip>

## Installation

<Tabs>
  <Tab title="npm">
    ```bash
    npm install @tevm/voltaire
    ```
  </Tab>
  <Tab title="bun">
    ```bash
    bun add @tevm/voltaire
    ```
  </Tab>
  <Tab title="pnpm">
    ```bash
    pnpm add @tevm/voltaire
    ```
  </Tab>
  <Tab title="yarn">
    ```bash
    yarn add @tevm/voltaire
    ```
  </Tab>
</Tabs>

## Quick Start (5 Minutes)

Let's build a simple example that demonstrates Voltaire's core capabilities: hashing, signing, and address validation.

### 1. Create a new file `example.ts`

<Tabs>
  <Tab title="Node.js/Bun">
    ```typescript
    import { Keccak256, Secp256k1, Address } from "@tevm/voltaire";

    // Hash a message
    const message = "Welcome to Voltaire";
    const messageHash = Keccak256.hash(message);
    console.log("Message hash:", messageHash);

    // Generate a keypair (using crypto.getRandomValues or similar)
    const privateKey = crypto.getRandomValues(new Uint8Array(32));
    const publicKey = Secp256k1.derivePublicKey(privateKey);

    // Sign the hash
    const signature = Secp256k1.sign(messageHash, privateKey);

    // Recover the signer's address
    const recoveredPublicKey = Secp256k1.recoverPublicKey(signature, messageHash);
    const signerAddress = Address.fromPublicKey(recoveredPublicKey);
    console.log("Signer address:", Address.toChecksummed(signerAddress));

    // Verify the signature
    const isValid = Secp256k1.verify(signature, messageHash, publicKey);
    console.log("Signature valid:", isValid);
    ```
  </Tab>
  <Tab title="Browser (Vite)">
    ```typescript
    import { Keccak256, Secp256k1, Address } from "@tevm/voltaire";

    // Hash a message
    const message = "Welcome to Voltaire";
    const messageHash = Keccak256.hash(message);
    document.body.innerHTML += `<p>Hash: ${messageHash}</p>`;

    // Generate a keypair (using crypto.getRandomValues or similar)
    const privateKey = crypto.getRandomValues(new Uint8Array(32));
    const publicKey = Secp256k1.derivePublicKey(privateKey);

    // Sign and verify
    const signature = Secp256k1.sign(messageHash, privateKey);
    const recoveredPublicKey = Secp256k1.recoverPublicKey(signature, messageHash);
    const signerAddress = Address.fromPublicKey(recoveredPublicKey);

    document.body.innerHTML += `
      <p>Signer: ${Address.toChecksummed(signerAddress)}</p>
      <p>Valid: ${Secp256k1.verify(signature, messageHash, publicKey)}</p>
    `;
    ```
  </Tab>
</Tabs>

### 2. Run the example

<Tabs>
  <Tab title="Node.js">
    ```bash
    tsx example.ts
    ```
  </Tab>
  <Tab title="Bun">
    ```bash
    bun run example.ts
    ```
  </Tab>
  <Tab title="Browser (Vite)">
    ```bash
    npm run dev
    ```
  </Tab>
</Tabs>

### 3. See the output

```
Message hash: Uint8Array(32) [...]
Signer address: 0xA0Cf798816D4b9b9866b5330EEa46A18382f251e
Signature valid: true
```

You've just hashed data, signed a message, and recovered an Ethereum address using Voltaire.

## Core Architecture

Voltaire uses a **data-first architecture** with two complementary APIs:

1. **Branded Types with Namespaced Methods** — Tree-shakeable, zero-overhead primitives
2. **Class APIs** — Convenient wrappers for familiar OOP patterns

Both APIs operate on the same underlying data, giving you flexibility to choose based on your needs.

## Branded Types Pattern

At the core of Voltaire are **branded primitives** — native JavaScript types (Uint8Array, bigint, string) with TypeScript brands for type safety.

### What is a Branded Type?

A branded type is a primitive with a compile-time tag that prevents mixing incompatible values:

```typescript
// Branded type definition
type Address = Uint8Array & { readonly __tag: "Address" };
type Hash = Uint8Array & { readonly __brand: symbol };
type Uint = bigint & { readonly __brand: symbol };

// These prevent accidents like:
const address: Address = someHash; // ❌ Type error
const hash: Hash = someAddress;     // ❌ Type error
```

**Benefits:**
- **Zero runtime overhead** — Just primitives at runtime
- **Type safety** — Compiler prevents mixing incompatible types
- **Serialization** — Natural JSON serialization (no classes to unwrap)
- **Interop** — Works seamlessly with other libraries

### Namespaced Methods

Methods are organized in namespaces that match the type they operate on:

```typescript
import { BrandedAddress } from "@tevm/voltaire/Address";

// Methods are namespaced by type
const addr = BrandedAddress.fromHex("0xa0cf798816d4b9b9866b5330eea46a18382f251e");
const hex = BrandedAddress.toHex(addr);
const checksummed = BrandedAddress.toChecksummed(addr);
const isZero = BrandedAddress.isZero(addr);
```

**Tree-Shaking:** Only the specific functions you import are bundled.

## Class API Pattern

For familiar OOP ergonomics, Voltaire provides class wrappers:

```typescript
import { Address } from "@tevm/voltaire";

// Constructor accepts multiple formats
const addr = new Address("0xa0cf798816d4b9b9866b5330eea46a18382f251e");

// Instance methods
addr.toHex();           // "0xa0cf..."
addr.toChecksummed();   // "0xA0Cf..."
addr.isZero();          // false
addr.equals(other);     // boolean

// Static methods
Address.fromHex("0x...");
Address.fromBytes(bytes);
Address.zero();
```

**Under the Hood:** Class instances are just branded Uint8Arrays with methods attached to the prototype. Zero overhead.

## Choosing an API Style

<Tabs>
  <Tab title="Class API">

**Use when:**
- You prefer OOP patterns
- You want familiar method chaining
- Bundle size isn't critical
- You're prototyping quickly

```typescript
import { Address, Hash, Uint } from "@tevm/voltaire";

const addr = new Address("0xa0cf798816d4b9b9866b5330eea46a18382f251e");
const checksum = addr.toChecksummed();

const a = Uint.from(100n);
const b = Uint.from(200n);
const sum = Uint.plus(a, b);
```

  </Tab>
  <Tab title="Branded Types">

**Use when:**
- Bundle size matters (tree-shaking)
- You want zero runtime overhead
- You need maximum performance
- You're building a library

```typescript
import { BrandedAddress } from "@tevm/voltaire/Address";
import { BrandedUint } from "@tevm/voltaire/Uint";

const addr = BrandedAddress.fromHex("0xa0cf798816d4b9b9866b5330eea46a18382f251e");
const checksum = BrandedAddress.toChecksummed(addr);

const a = BrandedUint.from(100n);
const b = BrandedUint.from(200n);
const sum = BrandedUint.plus(a, b);
```

  </Tab>
</Tabs>

**You can mix both styles** — they operate on the same data:

```typescript
import { Address } from "@tevm/voltaire";
import { BrandedAddress } from "@tevm/voltaire/Address";

const addr1 = new Address("0x...");
const addr2 = BrandedAddress.fromHex("0x...");

// Both work together
BrandedAddress.equals(addr1, addr2); // ✅ Works
addr1.equals(addr2);                  // ✅ Works
```

## Method Naming Convention

Voltaire follows consistent naming patterns across all types:

### Construction
- `Type.from(value)` — Universal constructor (accepts multiple formats)
- `Type.fromHex(hex)` — From hex string
- `Type.fromBytes(bytes)` — From byte array
- `Type.fromNumber(n)` — From number/bigint
- `Type.zero()` — Zero value

### Conversion
- `Type.toHex(value)` — To hex string
- `Type.toBytes(value)` — To byte array
- `Type.toNumber(value)` — To number/bigint

### Validation
- `Type.isValid(value)` — Check if value is valid
- `Type.is(value)` — Type guard
- `Type.isZero(value)` — Check if zero

### Comparison
- `Type.equals(a, b)` — Equality check
- `Type.compare(a, b)` — Comparison for sorting

## Quick Examples

### Working with Addresses

```typescript
import { Address } from "@tevm/voltaire";

// Create from hex
const addr = Address.from("0xa0cf798816d4b9b9866b5330eea46a18382f251e");

// EIP-55 checksumming
const checksummed = addr.toChecksummed();
console.log(checksummed); // "0xA0Cf798816D4b9b9866b5330EEa46A18382f251e"

// Check if zero
const isZero = addr.isZero(); // false

// Calculate contract addresses
const deployer = Address.from("0x742d35Cc6634C0532925a3b844Bc9e7595f0bEb2");
const contractAddr = deployer.calculateCreateAddress(0n);
```

### Working with Hashes

```typescript
import { Keccak256, Hash } from "@tevm/voltaire";

// Hash data
const data = new Uint8Array([1, 2, 3]);
const hash = Keccak256.hash(data);

// Convert to hex
const hex = Hash.toHex(hash);

// Constant-time comparison
const hash2 = Keccak256.hash(data);
Hash.equals(hash, hash2); // true
```

### Working with Uint256

```typescript
import { Uint } from "@tevm/voltaire";

// Create from various formats
const a = Uint.from(100n);
const b = Uint.from("0xff");
const c = Uint.fromHex("0x200");

// Arithmetic (wrapping on overflow)
const sum = Uint.plus(a, b);      // 100 + 255 = 355
const product = Uint.times(a, b); // 100 * 255 = 25500
const quotient = Uint.dividedBy(product, b); // 25500 / 255 = 100

// Comparison
Uint.greaterThan(sum, a); // true
Uint.lessThan(a, b);      // true

// Convert to hex
const hex = Uint.toHex(sum); // "0x0000...0163"
```

### Working with Transactions

```typescript
import { Transaction } from "@tevm/voltaire";

// EIP-1559 transaction
const tx: Transaction.EIP1559 = {
  type: 2,
  chainId: 1n,
  nonce: 0n,
  maxFeePerGas: 30000000000n,
  maxPriorityFeePerGas: 1000000000n,
  gasLimit: 21000n,
  to: recipientAddress,
  value: 1000000000000000000n,
  data: new Uint8Array(),
  accessList: [],
  r: signature.r,
  s: signature.s,
  v: signature.v,
};

// Serialize
const serialized = Transaction.serialize(tx);

// Hash
const txHash = Transaction.hash(tx);

// Recover sender
const sender = Transaction.from(tx);
```

## Type Safety

Voltaire provides opt-in type safety through branded types:

```typescript
import type { BrandedAddress } from "@tevm/voltaire/Address";
import type { BrandedHash } from "@tevm/voltaire/Hash";

function processAddress(addr: BrandedAddress) {
  // TypeScript ensures addr is a valid Address
}

function processHash(hash: BrandedHash) {
  // TypeScript ensures hash is a valid Hash
}

// Type errors prevent mistakes
const addr = Address.fromHex("0x...");
const hash = Keccak256.hash(data);

processAddress(addr);  // ✅ OK
processAddress(hash);  // ❌ Type error
processHash(hash);     // ✅ OK
processHash(addr);     // ❌ Type error
```

## Performance

Voltaire is optimized for performance:

- **Zero overhead abstractions** — Branded types compile to primitives
- **Tree-shaking** — Only bundle what you use
- **WASM acceleration** — Optional Zig-compiled WASM for minimal bundle impact and maximum performance
- **Native browser methods** — Uses native toHex/toBase64 when available
- **Constant-time operations** — Security-critical comparisons are constant-time

## First Real Task: Sign a Transaction (15 Minutes)

Now let's build something practical: create and sign an EIP-1559 transaction.

### 1. Create a transaction

```typescript
import { Transaction, Address } from "@tevm/voltaire";

const tx = {
  type: 2, // EIP-1559
  chainId: 1n, // Ethereum mainnet
  nonce: 0n,
  maxFeePerGas: 30_000_000_000n, // 30 gwei
  maxPriorityFeePerGas: 1_000_000_000n, // 1 gwei
  gasLimit: 21_000n,
  to: Address.from("0x742d35Cc6634C0532925a3b844Bc9e7595f0bEb2"),
  value: 1_000_000_000_000_000_000n, // 1 ether
  data: new Uint8Array(),
};
```

### 2. Sign the transaction

```typescript
import { Secp256k1 } from "@tevm/voltaire";

// Your private key (NEVER share or commit this!)
const privateKey = "0x...";

// Sign
const signedTx = Transaction.sign(tx, privateKey);
console.log("Signed transaction:", signedTx);
```

### 3. Serialize for broadcasting

```typescript
import { Hash } from "@tevm/voltaire";

// Serialize to RLP-encoded bytes
const serialized = Transaction.serialize(signedTx);

// Convert to hex for RPC
const txHex = Hash.toHex(serialized);
console.log("Transaction hex:", txHex);

// You can now send this via eth_sendRawTransaction
```

### 4. Verify the signature

```typescript
// Recover the sender address
const sender = Transaction.recoverSender(signedTx);
console.log("Sender address:", Address.toChecksummed(sender));

// Calculate transaction hash
const txHash = Transaction.hash(signedTx);
console.log("Transaction hash:", Hash.toHex(txHash));
```

<Warning>
**Never** use real private keys in test code. Always use test networks (Sepolia, Holesky) or local development chains.
</Warning>

## Troubleshooting

### Common Issues

#### Import errors: "Cannot find module"

Make sure you're using the correct import paths:

```typescript
// ✅ Correct
import { Address } from "@tevm/voltaire";
import { BrandedAddress } from "@tevm/voltaire/Address";

// ❌ Wrong
import { Address } from "@tevm/voltaire/primitives/Address";
```

Check your `tsconfig.json` has `"moduleResolution": "bundler"` or `"node16"`.

#### Type errors with branded types

If you get type errors like "Type 'Uint8Array' is not assignable to type 'BrandedAddress'", you need to construct the branded type properly:

```typescript
// ❌ Won't work
const addr: BrandedAddress = new Uint8Array(20);

// ✅ Correct
const addr = Address.from("0x...");
// or
const addr = BrandedAddress.fromHex("0x...");
```

#### WASM initialization errors

If using WASM modules, make sure to await initialization:

```typescript
import { Keccak256Wasm } from "@tevm/voltaire/crypto/keccak256.wasm";

// Must initialize before use
await Keccak256Wasm.init();

// Now you can use it
const hash = Keccak256Wasm.hash(data);
```

#### Bundle size is too large

Use tree-shakeable imports to reduce bundle size:

```typescript
// ❌ Imports entire Address class (~18 KB)
import { Address } from "@tevm/voltaire";

// ✅ Only imports specific functions (~500 bytes)
import { fromHex, toChecksummed } from "@tevm/voltaire/Address";
```

## Migration Guides

### From ethers.js

<Tabs>
  <Tab title="Addresses">
    ```typescript
    // ethers
    import { getAddress } from "ethers";
    const addr = getAddress("0xa0cf...");

    // Voltaire
    import { Address } from "@tevm/voltaire";
    const addr = Address.from("0xa0cf...");
    const checksum = addr.toChecksummed();
    ```
  </Tab>

  <Tab title="Hashing">
    ```typescript
    // ethers
    import { keccak256, toUtf8Bytes } from "ethers";
    const hash = keccak256(toUtf8Bytes("hello"));

    // Voltaire
    import { Keccak256 } from "@tevm/voltaire";
    const hash = Keccak256.hash("hello");
    ```
  </Tab>

  <Tab title="Signing">
    ```typescript
    // ethers
    import { Wallet } from "ethers";
    const wallet = new Wallet(privateKey);
    const sig = await wallet.signMessage("hello");

    // Voltaire
    import { Keccak256, Secp256k1 } from "@tevm/voltaire";
    const hash = Keccak256.hash("hello");
    const sig = Secp256k1.sign(hash, privateKey);
    ```
  </Tab>

  <Tab title="Transactions">
    ```typescript
    // ethers
    import { Wallet } from "ethers";
    const wallet = new Wallet(privateKey);
    const tx = await wallet.signTransaction({
      to: "0x...",
      value: parseEther("1.0"),
      // ...
    });

    // Voltaire
    import { Transaction } from "@tevm/voltaire";
    const signed = Transaction.sign({
      type: 2,
      to: Address.from("0x..."),
      value: Uint.from("1 ether"),
      // ...
    }, privateKey);
    const serialized = Transaction.serialize(signed);
    ```
  </Tab>
</Tabs>

### From viem

<Tabs>
  <Tab title="Addresses">
    ```typescript
    // viem
    import { getAddress } from "viem";
    const addr = getAddress("0xa0cf...");

    // Voltaire
    import { Address } from "@tevm/voltaire";
    const addr = Address.from("0xa0cf...");
    ```
  </Tab>

  <Tab title="Hashing">
    ```typescript
    // viem
    import { keccak256 } from "viem";
    const hash = keccak256("0x...");

    // Voltaire
    import { Keccak256 } from "@tevm/voltaire";
    const hash = Keccak256.hash("0x...");
    ```
  </Tab>

  <Tab title="ABI Encoding">
    ```typescript
    // viem
    import { encodeFunctionData } from "viem";
    const data = encodeFunctionData({
      abi: [...],
      functionName: "transfer",
      args: [address, amount],
    });

    // Voltaire
    import { Abi } from "@tevm/voltaire";
    const data = Abi.encodeFunction(
      { name: "transfer", inputs: [...] },
      [address, amount]
    );
    ```
  </Tab>
</Tabs>

### From web3.js

<Tabs>
  <Tab title="Addresses">
    ```typescript
    // web3.js
    import { toChecksumAddress } from "web3-utils";
    const addr = toChecksumAddress("0xa0cf...");

    // Voltaire
    import { Address } from "@tevm/voltaire";
    const addr = Address.from("0xa0cf...");
    const checksum = addr.toChecksummed();
    ```
  </Tab>

  <Tab title="Hashing">
    ```typescript
    // web3.js
    import { sha3 } from "web3-utils";
    const hash = sha3("hello");

    // Voltaire
    import { Keccak256 } from "@tevm/voltaire";
    const hash = Keccak256.hash("hello");
    ```
  </Tab>
</Tabs>

## Next Steps

### Core Primitives
Deep dive into Address, Hash, Uint, Transaction, RLP, ABI.

[Explore primitives →](/primitives/address)

### Cryptography
Learn Keccak-256, secp256k1, EIP-712, BIP-39, HD Wallets.

[View crypto docs →](/crypto/keccak256)

### Branded Types
Understand the branded type pattern for type safety.

[Read guide →](/concepts/branded-types)

### WASM Acceleration
Optimize performance with Zig-compiled WASM modules.

[View benchmarks →](/wasm/)

### API Overview
Learn universal patterns and design philosophy.

[Read overview →](/overview/)

### Zig API
Use Voltaire in native Zig applications.

[View Zig docs →](/zig/)

## Design Principles

1. **Simple data structures** — Built on native JavaScript primitives (Uint8Array, bigint, string)
2. **Close-to-spec APIs** — Minimal abstraction over Ethereum primitives
3. **Built for humans and LLMs** — APIs and documentation designed for both developers and AI assistants
4. **Performance first** — Zero-overhead abstractions and optional WASM
5. **Type safety** — Branded types prevent common mistakes
6. **Tree-shakeable** — Pay only for what you use
7. **Multi-language** — TypeScript and Zig implementations
