---
title: Address
description: 20-byte Ethereum address with EIP-55 checksumming
---

import { Tabs, TabItem, Code } from '@astrojs/starlight/components';

# Address

20-byte Ethereum address with EIP-55 checksumming support.

<Tabs syncKey="view">
  <TabItem label="Documentation">

## Overview

The Address primitive represents a 20-byte Ethereum address. It's implemented as a branded `Uint8Array` with zero overhead, supporting both tree-shakeable namespaced methods and optional class-based instances.

**Type:** `Address` (branded `Uint8Array` with 20 bytes)

## Architecture

Voltaire uses a **data-first architecture** with two layers:

1. **BrandedAddress**: Tree-shakeable namespace with branded types
2. **Address Class**: Optional convenience wrapper extending `Uint8Array`

```typescript
// BrandedAddress - Tree-shakeable
import { BrandedAddress } from "@tevm/voltaire/Address";
const addr = BrandedAddress.fromHex("0x...");
const hex = BrandedAddress.toHex(addr);

// Address Class - Convenience
import { Address } from "@tevm/voltaire";
const addr = new Address("0x...");
const hex = addr.toHex();
```

## Constants

- `Address.SIZE` — 20 bytes

## Creation

### Universal Constructor

```typescript
new Address(value: string | Uint8Array | number | bigint): Address
```

Accepts hex strings, byte arrays, or numeric values.

```typescript
import { Address } from "@tevm/voltaire";

const addr1 = new Address("0xa0cf798816d4b9b9866b5330eea46a18382f251e");
const addr2 = new Address(new Uint8Array(20));
const addr3 = new Address(0x123n);
```

### Specific Constructors

#### `Address.from(value)`

Alias for universal constructor. Accepts multiple formats.

#### `Address.fromHex(hex)`

```typescript
fromHex(hex: string): Address
```

Parse hex string (with or without `0x` prefix).

```typescript
const addr = Address.fromHex("0xa0cf798816d4b9b9866b5330eea46a18382f251e");
```

**Throws:** `InvalidAddressError` if not 40 hex characters

#### `Address.fromBytes(bytes)`

```typescript
fromBytes(bytes: Uint8Array): Address
```

Create from 20-byte array.

```typescript
const bytes = new Uint8Array(20);
const addr = Address.fromBytes(bytes);
```

**Throws:** `InvalidAddressError` if length ≠ 20

#### `Address.fromNumber(n)`

```typescript
fromNumber(n: number | bigint): Address
```

Create from numeric value, left-padded to 20 bytes.

```typescript
const addr = Address.fromNumber(0x123n);
```

#### `Address.fromPublicKey(x, y)`

```typescript
fromPublicKey(x: Uint8Array, y: Uint8Array): Address
```

Derive address from secp256k1 public key coordinates. Takes Keccak-256 hash of `x || y`, returns last 20 bytes.

```typescript
const addr = Address.fromPublicKey(xCoord, yCoord);
```

#### `Address.fromAbiEncoded(bytes)`

```typescript
fromAbiEncoded(bytes: Uint8Array): Address
```

Decode from 32-byte ABI encoding (12 zero bytes + 20 address bytes).

```typescript
const abiEncoded = new Uint8Array(32); // [0,0,...,0, address bytes...]
const addr = Address.fromAbiEncoded(abiEncoded);
```

#### `Address.fromBase64(b64)`

```typescript
fromBase64(b64: string): Address
```

Decode from base64 string.

#### `Address.zero()`

```typescript
zero(): Address
```

Returns zero address (`0x0000...0000`).

```typescript
const zero = Address.zero();
```

## Conversion

#### `Address.toHex(addr)`

```typescript
toHex(addr: Address): string
```

Returns lowercase hex string with `0x` prefix.

```typescript
const hex = Address.toHex(addr); // "0xa0cf..."
```

#### `Address.toChecksummed(addr)`

```typescript
toChecksummed(addr: Address): string
```

Returns EIP-55 checksummed hex string.

```typescript
const checksummed = Address.toChecksummed(addr); // "0xA0Cf..."
```

#### `Address.toLowercase(addr)`

```typescript
toLowercase(addr: Address): string
```

Returns lowercase hex without `0x` prefix.

#### `Address.toUppercase(addr)`

```typescript
toUppercase(addr: Address): string
```

Returns uppercase hex without `0x` prefix.

#### `Address.toU256(addr)`

```typescript
toU256(addr: Address): bigint
```

Converts to uint256 bigint.

```typescript
const n = Address.toU256(addr);
```

#### `Address.toAbiEncoded(addr)`

```typescript
toAbiEncoded(addr: Address): Uint8Array
```

Returns 32-byte ABI-encoded format.

#### `Address.toShortHex(addr, prefix?, suffix?)`

```typescript
toShortHex(addr: Address, prefix?: number, suffix?: number): string
```

Returns abbreviated format (default: `0x1234...5678`).

```typescript
const short = Address.toShortHex(addr); // "0xa0cf...251e"
const custom = Address.toShortHex(addr, 6, 6); // "0xa0cf79...82f251e"
```

#### `Address.format(addr)`

```typescript
format(addr: Address): string
```

Returns checksummed hex (alias for `toChecksummed`).

## Validation

#### `Address.isValid(value)`

```typescript
isValid(value: unknown): boolean
```

Validates if value is valid address format.

```typescript
Address.isValid("0xa0cf..."); // true
Address.isValid("invalid"); // false
```

#### `Address.isValidChecksum(hex)`

```typescript
isValidChecksum(hex: string): boolean
```

Validates EIP-55 checksum correctness.

```typescript
Address.isValidChecksum("0xA0Cf798816D4b9b9866b5330EEa46A18382f251e"); // true
```

#### `Address.isZero(addr)`

```typescript
isZero(addr: Address): boolean
```

Checks if all bytes are zero.

```typescript
const zero = Address.zero();
Address.isZero(zero); // true
```

#### `Address.is(value)`

```typescript
is(value: unknown): value is Address
```

Type guard checking if value is Address instance.

## Comparison

#### `Address.equals(a, b)`

```typescript
equals(a: Address, b: Address): boolean
```

Constant-time equality comparison.

```typescript
Address.equals(addr1, addr2);
```

#### `Address.compare(a, b)`

```typescript
compare(a: Address, b: Address): -1 | 0 | 1
```

Lexicographic comparison for sorting.

**Returns:**
- `-1` if a < b
- `0` if a === b
- `1` if a > b

#### `Address.lessThan(a, b)`

```typescript
lessThan(a: Address, b: Address): boolean
```

#### `Address.greaterThan(a, b)`

```typescript
greaterThan(a: Address, b: Address): boolean
```

## Contract Addresses

#### `Address.calculateCreateAddress(from, nonce)`

```typescript
calculateCreateAddress(from: Address, nonce: bigint): Address
```

Calculates contract address from CREATE opcode. RLP-encodes `[address, nonce]`, takes Keccak-256 hash, returns last 20 bytes.

```typescript
const deployer = Address.fromHex("0x...");
const contractAddr = Address.calculateCreateAddress(deployer, 0n);
```

#### `Address.calculateCreate2Address(from, salt, initCode)`

```typescript
calculateCreate2Address(
  from: Address,
  salt: Uint8Array,
  initCode: Uint8Array
): Address
```

Calculates contract address from CREATE2 opcode.

**Formula:** `keccak256(0xff ++ address ++ salt ++ keccak256(initCode))`

```typescript
const salt = new Uint8Array(32);
const initCode = new Uint8Array([0x60, 0x80, ...]); // bytecode
const addr = Address.calculateCreate2Address(deployer, salt, initCode);
```

## Instance Methods

All static methods available as instance methods:

```typescript
const addr = new Address("0xa0cf798816d4b9b9866b5330eea46a18382f251e");

// Conversion
addr.toHex(); // "0xa0cf..."
addr.toChecksummed(); // "0xA0Cf..."
addr.toU256(); // 915...n
addr.toAbiEncoded(); // Uint8Array(32)
addr.toShortHex(); // "0xa0cf...251e"

// Validation
addr.isZero(); // false

// Comparison
addr.equals(other); // boolean
addr.lessThan(other); // boolean
addr.greaterThan(other); // boolean
addr.compare(other); // -1 | 0 | 1

// Contract addresses
addr.calculateCreateAddress(1n); // Address
addr.calculateCreate2Address(salt, initCode); // Address
```

## Examples

### Basic Usage

```typescript
import { Address } from "@tevm/voltaire";

// Create
const addr = new Address("0xa0cf798816d4b9b9866b5330eea46a18382f251e");

// Format
console.log(addr.toChecksummed());
console.log(Address.toShortHex(addr)); // "0xa0cf...251e"

// Validate
if (Address.isValid(userInput)) {
  const addr = new Address(userInput);
}
```

### Contract Deployment

```typescript
import { Address } from "@tevm/voltaire";

const deployer = Address.fromHex("0x742d35Cc6634C0532925a3b844Bc9e7595f0bEb2");

// CREATE
const nonce = 5n;
const createAddr = Address.calculateCreateAddress(deployer, nonce);

// CREATE2
const salt = new Uint8Array(32);
const initCode = new Uint8Array([...]); // your bytecode
const create2Addr = Address.calculateCreate2Address(deployer, salt, initCode);
```

### Tree-Shakeable Usage

```typescript
import { BrandedAddress } from "@tevm/voltaire/Address";

// Only imports the specific functions you use
const addr = BrandedAddress.fromHex("0x...");
const hex = BrandedAddress.toHex(addr);
const checksummed = BrandedAddress.toChecksummed(addr);
```

## Performance

- Zero allocation for branded type
- Constant-time equality checks
- Native browser methods where available (toHex, toBase64)
- Tree-shakeable - only pay for what you use

  </TabItem>
  <TabItem label="Source Code" icon="seti:typescript">

View the implementation:

- [Address.js](https://github.com/evmts/voltaire/blob/main/src/primitives/Address/index.ts) - Class factory
- [BrandedAddress](https://github.com/evmts/voltaire/tree/main/src/primitives/Address/BrandedAddress) - Core implementation
- [address.zig](https://github.com/evmts/voltaire/blob/main/src/primitives/address.zig) - Zig implementation

### Key Files

**Type Definition:**
```typescript
// BrandedAddress.ts
export type BrandedAddress = Uint8Array & {
  readonly __tag: "Address";
  toHex(this: BrandedAddress): BrandedHex;
  toChecksummed(this: BrandedAddress): Checksummed;
  // ... other methods
};
```

**Constructor Pattern:**
```typescript
// index.ts
export function Address(value) {
  const result = BrandedAddress.from(value);
  Object.setPrototypeOf(result, Address.prototype);
  return result;
}

// Static methods delegate to BrandedAddress
Address.toHex = BrandedAddress.toHex;
Address.fromHex = (value) => {
  const result = BrandedAddress.fromHex(value);
  Object.setPrototypeOf(result, Address.prototype);
  return result;
};

// Instance methods
Address.prototype.toHex = function() {
  return BrandedAddress.toHex(this);
};
```

### Repository Structure

```
src/primitives/Address/
├── index.ts                    # Address class factory
├── BrandedAddress/
│   ├── index.ts               # Namespace exports
│   ├── BrandedAddress.ts      # Type definition
│   ├── from.ts                # Universal constructor
│   ├── fromHex.ts             # Hex parser
│   ├── toHex.ts               # Hex formatter
│   ├── toChecksummed.ts       # EIP-55 checksum
│   ├── equals.ts              # Constant-time equality
│   ├── calculateCreate*.ts    # Contract address calculation
│   └── *.test.ts              # Test files
└── address.zig                 # Zig implementation
```

  </TabItem>
</Tabs>

## See Also

- [Hash](/primitives/hash) - 32-byte hash type
- [Hex](/primitives/hex) - Hexadecimal encoding
- [Keccak256](/crypto/keccak256) - For deriving addresses
