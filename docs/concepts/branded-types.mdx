---
title: Branded Types
description: Type-level tags for nominal typing in TypeScript
---

# Branded Types

Branded types provide runtime validated types without the need for a library like Zod. They use type-level tags that make structurally identical types distinguishable to TypeScript's type checker.

## The Problem

TypeScript uses structural typing - types with same structure are interchangeable:

```typescript
type BrandedAddress = Uint8Array
type BrandedBytecode = Uint8Array

function verifySignature(addr: BrandedAddress, hash: Uint8Array) { /* ... */ }

const bytecode: BrandedBytecode = new Uint8Array([0x60, 0x01])
verifySignature(bytecode, new Uint8Array(32)) // ✓ TypeScript allows this (both are Uint8Array)
```

This compiles but is logically wrong - bytecode shouldn't be accepted as an address.

## The Solution

Add compile-time-only brand field using symbol:

```typescript
declare const brand: unique symbol

type BrandedAddress = Uint8Array & { readonly [brand]: "Address" }
type BrandedBytecode = Uint8Array & { readonly [brand]: "Bytecode" }

function verifySignature(addr: BrandedAddress, hash: Uint8Array) { /* ... */ }

const bytecode: BrandedBytecode = new Uint8Array([0x60, 0x01]) as BrandedBytecode
verifySignature(bytecode, new Uint8Array(32)) // ✗ Error: Type 'BrandedBytecode' is not assignable to type 'BrandedAddress'
```

Brand exists only in type system - erased at runtime. Values are still plain Uint8Array.

## Generic Brand Type

```typescript
declare const brand: unique symbol

type Brand<T, Tag> = T & { readonly [brand]: Tag }
```

Usage:

```typescript
type BrandedAddress = Brand<Uint8Array, "Address">
type BrandedBytecode = Brand<Uint8Array, "Bytecode">
type BrandedHex = Brand<string, "Hex">
```

## Why Symbols?

Using `unique symbol` ensures:
1. **No runtime overhead** - symbols don't exist at runtime when used in type-only position
2. **No name collisions** - symbol property name can't clash with real properties
3. **Type safety** - TypeScript treats each brand as unique identifier

```typescript
// Without symbol (DON'T DO THIS)
type BrandedAddress = Uint8Array & { __brand: "Address" }

// If Uint8Array somehow had __brand property, this would conflict!
const addr = new Uint8Array(20)
addr.__brand = "Address" // runtime __brand field conflicts!
```

## Voltaire's Approach

All primitives use branded types:

```typescript
// BrandedAddress is Uint8Array with brand
type BrandedAddress = Uint8Array & { readonly __tag: "Address" }

// BrandedHex is string with brand
type BrandedHex = string & { readonly __tag: "Hex" }

// Can't mix them up
function process(addr: BrandedAddress) { /* ... */ }
const hex: BrandedHex = "0x..." as BrandedHex
process(hex) // ✗ Error
```

Runtime: just `Uint8Array` and `string`. Brand only exists in types.

## Creating Branded Values

Use factory functions that perform validation and cast:

```typescript
type BrandedAddress = Uint8Array & { readonly __tag: "Address" }

function fromHex(hex: string): BrandedAddress {
  // Validate hex format
  if (!hex.startsWith("0x") || hex.length !== 42) {
    throw new Error("Invalid address")
  }

  // Parse to Uint8Array
  const bytes = new Uint8Array(20)
  // ... parsing logic ...

  // Cast to branded type
  return bytes as BrandedAddress
}

const addr = fromHex("0x742d35Cc6634C0532925a3b844Bc9e7595f51e3e")
// addr runtime: Uint8Array(20)
// addr compile-time: BrandedAddress
```

Validation happens once at construction. Brand ensures type safety throughout codebase.

## Benefits

### Type Safety

```typescript
type BrandedAddress = Uint8Array & { readonly __tag: "Address" }
type BrandedHash = Uint8Array & { readonly __tag: "Hash" }

function verifySignature(addr: BrandedAddress, hash: BrandedHash) { /* ... */ }

const addr = Address.fromHex("0x...")
const hash = Hash.fromHex("0x...")

verifySignature(addr, hash)    // ✓ correct
verifySignature(hash, addr)    // ✗ Error: arguments swapped
```

### Self-Documenting

```typescript
// Without brands
function transfer(from: Uint8Array, to: Uint8Array, amount: bigint) { /* ... */ }

// With brands
function transfer(from: BrandedAddress, to: BrandedAddress, amount: BrandedU256) { /* ... */ }
// Clear: expects addresses and U256, not arbitrary byte arrays
```

### Zero Runtime Cost

```typescript
const addr: BrandedAddress = Address.fromHex("0x...")
console.log(addr) // Uint8Array(20) [116, 45, 53, ...]
console.log(addr.__tag) // undefined (brand doesn't exist at runtime)
```

Brand field only exists in TypeScript's type checker. Compiled JavaScript contains zero branding overhead.

## Variants with Multiple Brands

Types can have multiple brand properties:

```typescript
type Checksummed = string & {
  readonly __tag: "Hex"
  readonly __variant: "Address"
  readonly __checksummed: true
}

type Lowercase = string & {
  readonly __tag: "Hex"
  readonly __variant: "Address"
  readonly __lowercase: true
}
```

Different combinations create incompatible types:

```typescript
const checksummed: Checksummed = "0x742d35Cc..." as Checksummed
const lowercase: Lowercase = "0x742d35cc..." as Lowercase

function display(addr: Checksummed) { /* ... */ }
display(checksummed) // ✓
display(lowercase)   // ✗ Error
```

## Common Patterns

### Validation Functions

```typescript
function isValidAddress(value: unknown): value is BrandedAddress {
  return value instanceof Uint8Array && value.length === 20
}

if (isValidAddress(data)) {
  // data is BrandedAddress here
  processAddress(data)
}
```

### Conversion Functions

```typescript
function addressToHex(addr: BrandedAddress): BrandedHex {
  const hex = "0x" + Array.from(addr, b => b.toString(16).padStart(2, "0")).join("")
  return hex as BrandedHex
}
```

### Unwrapping (Rarely Needed)

```typescript
type Unbrand<T> = T extends infer U & { [brand]: any } ? U : T

const addr: BrandedAddress = /* ... */
const plain: Uint8Array = addr as Unbrand<BrandedAddress>
```

Usually unnecessary - branded types already compatible with underlying type operations.

## Related

- [Address](/primitives/address/) - Uses `BrandedAddress` type
- [Hex](/primitives/hex/) - Uses `BrandedHex` type
- [BrandedAddress](/primitives/address/branded-address) - Tree-shakeable branded API
