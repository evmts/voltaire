---
title: Branded Types
description: Type-level tags for nominal typing in TypeScript
---

# Branded Types

Branded types provide runtime validated types without the need for a library like Zod. They use type-level tags that make structurally identical types distinguishable to TypeScript's type checker.

## The Problem

TypeScript uses structural typing - types with same structure are interchangeable:

```typescript
type BrandedAddress = Uint8Array
type BrandedBytecode = Uint8Array

function verifySignature(addr: BrandedAddress, hash: Uint8Array) { /* ... */ }

const bytecode: BrandedBytecode = new Uint8Array([0x60, 0x01])
verifySignature(bytecode, new Uint8Array(32)) // ✓ TypeScript allows this (both are Uint8Array)
```

This compiles but is logically wrong - bytecode shouldn't be accepted as an address.

## The Solution

Add compile-time-only brand field using symbol:

```typescript
declare const brand: unique symbol

type BrandedAddress = Uint8Array & { readonly [brand]: "Address" }
type BrandedBytecode = Uint8Array & { readonly [brand]: "Bytecode" }

function verifySignature(addr: BrandedAddress, hash: Uint8Array) { /* ... */ }

const bytecode: BrandedBytecode = new Uint8Array([0x60, 0x01]) as BrandedBytecode
verifySignature(bytecode, new Uint8Array(32)) // ✗ Error: Type 'BrandedBytecode' is not assignable to type 'BrandedAddress'
```

Brand exists only in type system - erased at runtime. Values are still plain Uint8Array.

## Generic Brand Type

```typescript
declare const brand: unique symbol

type Brand<T, Tag> = T & { readonly [brand]: Tag }
```

Usage:

```typescript
type BrandedAddress = Brand<Uint8Array, "Address">
type BrandedBytecode = Brand<Uint8Array, "Bytecode">
type BrandedHex = Brand<string, "Hex">
```

## Why Symbols?

Using `unique symbol` ensures:
1. **No runtime overhead** - symbols don't exist at runtime when used in type-only position
2. **No name collisions** - symbol property name can't clash with real properties
3. **Type safety** - TypeScript treats each brand as unique identifier

```typescript
// Without symbol (DON'T DO THIS)
type BrandedAddress = Uint8Array & { __brand: "Address" }

// If Uint8Array somehow had __brand property, this would conflict!
const addr = new Uint8Array(20)
addr.__brand = "Address" // runtime __brand field conflicts!
```

## Voltaire's Approach

All primitives use branded types:

```typescript
// BrandedAddress is Uint8Array with brand
type BrandedAddress = Uint8Array & { readonly __tag: "Address" }

// BrandedHex is string with brand
type BrandedHex = string & { readonly __tag: "Hex" }

// Can't mix them up
function process(addr: BrandedAddress) { /* ... */ }
const hex: BrandedHex = "0x..." as BrandedHex
process(hex) // ✗ Error
```

Runtime: just `Uint8Array` and `string`. Brand only exists in types.

## How Branded Values Are Created

Factory functions validate then cast to branded type:

```typescript
type BrandedAddress = Uint8Array & { readonly __tag: "Address" }

function fromUint8Array(bytes: Uint8Array): BrandedAddress {
  // Validate
  if (!Address.isValidAddress(bytes)) {
    throw new InvalidAddressError()
  }

  // Return input cast to branded type
  return bytes as BrandedAddress
}

const bytes = new Uint8Array(20)
const addr = fromUint8Array(bytes)
// addr runtime: same Uint8Array reference
// addr compile-time: BrandedAddress
```

Validation at construction. Brand ensures type safety throughout codebase.

## Benefits

### Type Safety

```typescript
type BrandedAddress = Uint8Array & { readonly __tag: "Address" }
type BrandedHash = Uint8Array & { readonly __tag: "Hash" }

function verifySignature(addr: BrandedAddress, hash: BrandedHash) { /* ... */ }

const addr = Address.fromHex("0x...")
const hash = Hash.fromHex("0x...")

verifySignature(addr, hash)    // ✓ correct
verifySignature(hash, addr)    // ✗ Error: arguments swapped
```

### Self-Documenting

```typescript
// Without brands
function transfer(from: Uint8Array, to: Uint8Array, amount: bigint) { /* ... */ }

// With brands
function transfer(from: BrandedAddress, to: BrandedAddress, amount: BrandedU256) { /* ... */ }
// Clear: expects addresses and U256, not arbitrary byte arrays
```

### Zero Runtime Cost

```typescript
const addr: BrandedAddress = Address.fromHex("0x...")
console.log(addr) // Uint8Array(20) [116, 45, 53, ...]
console.log(addr.__tag) // undefined (brand doesn't exist at runtime)
```

Brand field only exists in TypeScript's type checker. Compiled JavaScript contains zero branding overhead.

## Variants with Multiple Brands

String-based types can have variant discriminators for different formats. Address hex strings share the same base brand `Symbol("AddressHex")` but use additional discriminators for case variants:

```typescript
// All variants have __brand = Symbol("AddressHex")
// Additional discriminators specify exact format

type AddressChecksummed = string & {
  readonly __brand: unique symbol  // Symbol("AddressHex")
  readonly __checksummed: true
}

type AddressLowercase = string & {
  readonly __brand: unique symbol  // Symbol("AddressHex")
  readonly __lowercase: true
}

type AddressUppercase = string & {
  readonly __brand: unique symbol  // Symbol("AddressHex")
  readonly __uppercase: true
}

type AddressHex = string & {
  readonly __brand: unique symbol  // Symbol("AddressHex")
  // No discriminator = generic/unknown case format (could be mixed)
}
```

TypeScript distinguishes these as separate types despite sharing the same brand symbol:

```typescript
const checksummed: AddressChecksummed = "0x742d35Cc..." as AddressChecksummed
const lowercase: AddressLowercase = "0x742d35cc..." as AddressLowercase
const unknown: AddressHex = "0x742D35cc..." as AddressHex  // Mixed case

function requireChecksummed(addr: AddressChecksummed) { /* ... */ }
requireChecksummed(checksummed) // ✓ Correct
requireChecksummed(lowercase)   // ✗ Error: __lowercase !== __checksummed
requireChecksummed(unknown)     // ✗ Error: no __checksummed discriminator
```

This allows APIs to require specific formats (e.g., EIP-55 checksummed) while accepting generic hex in other contexts.
