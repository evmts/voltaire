---
title: Branded Types Reference
description: Complete guide to using branded types in Voltaire
---

Voltaire uses branded types to provide compile-time type safety with zero runtime overhead. This guide explains how branded types work and how to use them effectively.

## Type Hierarchy

Voltaire provides three levels of types for each primitive:

### 1. Branded Type (Strictest)

The base branded type - a validated, immutable value:

```typescript
import type { AddressType } from '@tevm/voltaire/Address';

type AddressType = Uint8Array & { readonly [brand]: "Address" };
```

**Use when:**
- You have a validated address and want type safety
- You need maximum strictness
- You want to ensure the value came from Voltaire's validators

**Properties:**
- Runtime: Plain `Uint8Array` (20 bytes)
- Validation: Already validated during construction
- Methods: None (use namespace functions)
- Overhead: Zero

**Example:**

```typescript
import { fromHex, toHex, equals } from '@tevm/voltaire/Address'
import type { AddressType } from '@tevm/voltaire/Address'

const addr: AddressType = fromHex('0x742d35Cc6634C0532925a3b844Bc9e7595f51e3e')
const hex = toHex(addr)
const same = equals(addr, addr) // true
```

### 2. Namespace API (Most Convenient)

Data-first functions with namespace access:

```typescript
import { Address } from '@tevm/voltaire'

const addr = Address('0x742d35Cc6634C0532925a3b844Bc9e7595f51e3e')
Address.toHex(addr)       // Namespace function
Address.isZero(addr)      // Namespace function
Address.equals(addr, other)  // Namespace function
```

**Use when:**
- You want consistent API across all entrypoints
- You prefer explicit data-first style
- Bundle size is not a primary concern

**Properties:**
- Runtime: `Uint8Array` (20 bytes)
- Validation: Validated during construction
- Methods: Available as `Address.method(addr)`
- Overhead: Minimal

**Example:**

```typescript
import { Address } from '@tevm/voltaire'

const addr = Address('0x742d35Cc6634C0532925a3b844Bc9e7595f51e3e')

// Functions available via namespace
const hex = Address.toHex(addr)
const checksummed = Address.toChecksummed(addr)
const isZero = Address.isZero(addr)

// Still a Uint8Array
console.log(addr instanceof Uint8Array) // true
console.log(addr.length) // 20
```

### 3. Input Type (Loosest)

**Note:** Voltaire does not currently export `AddressLike` union types. The `Address()` constructor and `from()` functions accept multiple input types:

```typescript
import { Address } from '@tevm/voltaire'

// Accepts: string | Uint8Array | number | bigint
Address('0x742d35Cc6634C0532925a3b844Bc9e7595f51e3e')  // hex string
Address(new Uint8Array(20))                            // bytes
Address(0x742d35Cc6634C0532925a3b844Bc9e7595f51e3en)  // bigint
```

For function parameters accepting flexible input, use the same union:

```typescript
function process(input: string | Uint8Array | number | bigint) {
  const addr = Address(input)
  // Now you have a validated AddressType
}
```

## API Patterns

### Namespace API (Default)

```typescript
import { Address } from '@tevm/voltaire'

// Constructor accepts multiple formats
const addr = Address('0x742d35Cc6634C0532925a3b844Bc9e7595f51e3e')

// Namespace functions (data-first)
Address.toHex(addr)           // "0x742d35cc6634c0532925a3b844bc9e7595f51e3e"
Address.toChecksummed(addr)   // "0x742d35Cc6634C0532925a3b844Bc9e7595f51e3e"
Address.isZero(addr)          // false
Address.equals(addr, other)   // boolean

// Static constructors
Address.fromHex('0x...')
Address.fromBytes(bytes)
Address.zero()
```

**Pros:**
- Consistent across all 3 entrypoints (JS, WASM, Native)
- Explicit data flow
- Method discovery via autocomplete

**Cons:**
- Imports entire namespace
- Must pass value as first argument

### Tree-Shakeable Imports

```typescript
import { fromHex, toHex, toChecksummed, equals } from '@tevm/voltaire/Address'

// Direct function calls
const addr = fromHex('0x742d35Cc6634C0532925a3b844Bc9e7595f51e3e')
toHex(addr)           // "0x742d35cc..."
toChecksummed(addr)   // "0x742d35Cc..."
equals(addr, other)   // boolean
```

**Pros:**
- Tree-shakeable (only bundle what you use)
- Minimal bundle impact
- Functional programming friendly

**Cons:**
- More verbose imports
- Less discoverable

### Minimal Example (Optimal Bundle Size)

```typescript
import { fromHex, toHex, equals } from '@tevm/voltaire/Address'

const addr = fromHex('0x742d35Cc6634C0532925a3b844Bc9e7595f51e3e')
const hex = toHex(addr)
const same = equals(addr, addr)

// Only these 3 functions in bundle (~500 bytes)
// Unused methods excluded (toChecksummed, calculateCreateAddress, etc.)
```

## Brand Symbol

All branded types use a shared `brand` symbol:

```typescript
import { brand } from '@tevm/voltaire/brand'

// This is what makes it "branded"
type AddressType = Uint8Array & { readonly [brand]: 'Address' }
type HashType = Uint8Array & { readonly [brand]: 'Hash' }
```

The `brand` symbol:
- `unique symbol` - TypeScript ensures uniqueness
- Compile-time only - erased at runtime
- Shared across all primitives - consistent pattern

## Type Variants

### Hierarchical Types with Boolean Flags

Some types have specialized variants using boolean flags:

```typescript
// Base hex type
type Hex = string & { readonly [brand]: 'Hex' }

// Variants with additional flags
type ChecksumAddress = Hex & { readonly checksum: true }
type LowercaseHex = Hex & { readonly lowercase: true }
type UppercaseHex = Hex & { readonly uppercase: true }
```

**Example:**

```typescript
import { Address } from '@tevm/voltaire'

const addr = Address('0x742d35Cc6634C0532925a3b844Bc9e7595f51e3e')

const checksummed = Address.toChecksummed(addr) // ChecksumAddress
const lowercase = Address.toLowercase(addr)     // LowercaseHex
const uppercase = Address.toUppercase(addr)     // UppercaseHex

// Type system enforces correctness
function requireChecksum(hex: ChecksumAddress) { }

requireChecksum(checksummed)  // Valid
requireChecksum(lowercase)    // Error: missing checksum flag
```

## Validation

All branded types are validated at construction:

```typescript
import { Address } from '@tevm/voltaire'

// Valid - creates AddressType
Address('0x742d35Cc6634C0532925a3b844Bc9e7595f51e3e')

// Invalid - throws error
Address('0xnot_valid')        // Error: Invalid hex
Address('0x123')              // Error: Invalid length
Address(new Uint8Array(10))   // Error: Must be 20 bytes
```

**If you have a `AddressType`, it's valid.** No need for runtime validation libraries like Zod.

## Console Formatting

Branded types display formatted in console:

```typescript
const addr = Address(0x742d35Cc6634C0532925a3b844Bc9e7595f51e3en)
console.log(addr)
// Address("0x742d35cc6634c0532925a3b844bc9e7595f51e3e")
```

This improves debugging while maintaining full `Uint8Array` performance.

## Comparison Table

| Feature | Namespace API | Tree-Shakeable Imports |
|---------|---------------|------------------------|
| Import | `import { Address }` | `import { fromHex, toHex }` |
| Bundle Size | ~18 KB | ~500 bytes (3 functions) |
| Syntax | `Address.toHex(addr)` | `toHex(addr)` |
| Type | AddressType | AddressType |
| Tree-shaking | Partial | Full |
| Entrypoint consistency | All 3 (JS, WASM, Native) | All 3 (JS, WASM, Native) |

## Migration Guide

### From String Types

```typescript
// Before - unsafe
type Address = `0x${string}`
const addr: Address = '0x123' // No validation

// After - safe
import { Address } from '@tevm/voltaire'
const addr = Address('0x123') // Throws error
```

### From Generic Uint8Array

```typescript
// Before - no type safety
function transfer(to: Uint8Array, amount: bigint) { }
const hash = keccak256(data)
transfer(hash, 100n) // Compiles but wrong!

// After - type safe
import type { AddressType } from '@tevm/voltaire/Address'
function transfer(to: AddressType, amount: bigint) { }
const hash = keccak256(data)
transfer(hash, 100n) // Type error
```

## Best Practices

### Use Branded Types for Function Parameters

```typescript
import type { AddressType } from '@tevm/voltaire/Address'
import type { HashType } from '@tevm/voltaire/Hash'

// Good - explicit types
function verify(addr: AddressType, hash: HashType) {
  // addr and hash cannot be swapped
}

// Bad - generic types
function verify(addr: Uint8Array, hash: Uint8Array) {
  // Easy to swap arguments
}
```

### Use Namespace API for Application Code

```typescript
import { Address, Hash } from '@tevm/voltaire'

const addr = Address('0x...')
const hash = Hash('0x...')

// Namespace functions
const result = Address.toChecksummed(addr)
```

### Use Tree-Shakeable for Libraries

```typescript
import { fromHex, toHex } from '@tevm/voltaire/Address'

// Minimal bundle impact
export function formatAddress(input: string) {
  const addr = fromHex(input)
  return toHex(addr)
}
```

### Validate at Boundaries

```typescript
import { Address } from '@tevm/voltaire'
import type { AddressType } from '@tevm/voltaire/Address'

// Validate external input at boundary
export function processRequest(req: { to: string, amount: string }) {
  const to = Address(req.to) // Validate here
  return transfer(to, BigInt(req.amount))
}

// Internal functions trust the type
function transfer(to: AddressType, amount: bigint) {
  // No validation needed - type guarantees it's valid
}
```

## Learn More

<CardGroup cols={2}>
  <Card title="Why Branded Types?" icon="lightbulb" href="/getting-started/branded-types">
    Benefits and motivation for branded types
  </Card>
  <Card title="Address Primitive" icon="cube" href="/primitives/address">
    Complete Address API reference
  </Card>
  <Card title="TypeScript Branding" icon="book-open" href="https://prosopo.io/blog/typescript-branding/">
    In-depth guide to branded types (Prosopo)
  </Card>
</CardGroup>
