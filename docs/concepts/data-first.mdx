---
title: Data-First Ethereum
description: Voltaire's data-first approach to Ethereum primitives with branded types, tree-shakeable functions, and optional classes
---

# Data-First Ethereum

Voltaire takes a **data-first approach** to Ethereum primitives. Core types are validated [branded types](/concepts/branded-types) that separate data from operations, enabling maximum tree-shakeability and flexibility.

## Philosophy

**Data comes first.** We represent Ethereum primitives using the most idiomatic data type for each language that closely matches what the data actually is:

- **Addresses** → 20-byte `Uint8Array`
- **Hashes** → 32-byte `Uint8Array`
- **Bytecode** → Variable-length `Uint8Array`
- **Hex strings** → Tagged `string`

These branded types provide TypeScript safety with minimal runtime overhead. Methods operate on these types rather than encapsulating them in classes.

## Three API Styles

Voltaire offers three ways to work with primitives, ordered by bundle size optimization:

### 1. Tree-Shakeable Functions (Most Optimal)

Import only the functions you need. Best for bundle size.

```typescript
import { fromHex, toHex, equals } from '@tevm/voltaire/BrandedBytecode'

const code = fromHex("0x60016002")
const hex = toHex(code)
const same = equals(code, code)
```

**Benefits:**
- Maximum tree-shakeability (only imports used functions)
- Smallest possible bundle size
- Functional programming style (data separate from methods)
- No prototype pollution

**Trade-offs:**
- More verbose imports
- No method chaining
- Less discoverable (need to know function names)

### 2. Namespace API (Balanced)

Import namespace once, access all methods. Good balance of convenience and tree-shakeability.

```typescript
import { Bytecode } from '@tevm/voltaire'

const code = Bytecode.fromHex("0x60016002")
const hex = Bytecode.toHex(code)
const same = Bytecode.equals(code, code)
```

**Benefits:**
- Single import statement
- Clear namespace (Bytecode.method)
- Still tree-shakeable at function level
- Discoverable via autocomplete

**Trade-offs:**
- Imports entire namespace object
- No method chaining
- Slightly larger than individual function imports

### 3. Class API (Most Convenient)

Object-oriented style with method chaining. **Recommended for most users.**

```typescript
import { Bytecode } from '@tevm/voltaire'

const code = Bytecode.fromHex("0x60016002")
const hex = code.toHex()
const same = code.equals(code)

// Method chaining
const runtime = Bytecode.fromHex("0x...")
  .stripMetadata()
  .extractRuntime()
```

**Benefits:**
- Most convenient and ergonomic
- Method chaining support
- Familiar OOP patterns
- IDE autocomplete on instances
- Relatively tree-shakeable (classes rarely depend on each other)

**Trade-offs:**
- Larger bundle than function imports
- Prototype methods (see warning below)

<Warning>
**Destructuring Warning**

Class methods are attached to the prototype. Don't destructure without binding:

```typescript
const code = Bytecode.fromHex("0x6001")

// ❌ Don't do this - loses `this` binding
const { toHex } = code
toHex() // Error: Cannot read property of undefined

// ✅ Do this instead
const toHex = code.toHex.bind(code)
toHex() // Works

// ✅ Or just use it directly
code.toHex() // Works
```
</Warning>

## Pattern Comparison

<Tabs>
  <Tab title="Tree-Shakeable">
```typescript
import {
  fromHex,
  analyze,
  stripMetadata
} from '@tevm/voltaire/BrandedBytecode'

const code = fromHex("0x608060405260043610...")
const analysis = analyze(code)
const stripped = stripMetadata(code)

// Most optimal bundle size
// Bundle includes: fromHex, analyze, stripMetadata only
```
  </Tab>

  <Tab title="Namespace">
```typescript
import { Bytecode } from '@tevm/voltaire'

const code = Bytecode.fromHex("0x608060405260043610...")
const analysis = Bytecode.analyze(code)
const stripped = Bytecode.stripMetadata(code)

// Good balance
// Bundle includes: Bytecode namespace + used methods
```
  </Tab>

  <Tab title="Class">
```typescript
import { Bytecode } from '@tevm/voltaire'

const code = Bytecode.fromHex("0x608060405260043610...")
const analysis = code.analyze()
const stripped = code.stripMetadata()

// Most convenient
// Bundle includes: Bytecode class + all instance methods
```
  </Tab>
</Tabs>

## Extensibility

Classes can be extended with custom methods by modifying the prototype:

```typescript
import { Bytecode } from '@tevm/voltaire'

// Add custom method
Bytecode.prototype.countPushOpcodes = function() {
  return this.parseInstructions()
    .filter(inst => inst.opcode >= 0x60 && inst.opcode <= 0x7f)
    .length
}

// Extend TypeScript interface
declare module '@tevm/voltaire' {
  interface Bytecode {
    countPushOpcodes(): number
  }
}

// Use custom method
const code = Bytecode.fromHex("0x60016002")
console.log(code.countPushOpcodes()) // 2
```

This allows domain-specific extensions without forking the library.

## When to Use Each Style

### Use Tree-Shakeable Functions When:
- Building production apps where bundle size is critical
- Only need a few specific operations
- Prefer functional programming style
- Building libraries that import Voltaire

### Use Namespace API When:
- Want clear organization (Address.fromHex, Hash.keccak256)
- Need multiple operations from same primitive
- Prefer explicit imports without classes

### Use Class API When:
- Prototyping or developing applications (recommended default)
- Value convenience over minimal bundle size
- Like method chaining
- Want familiar OOP patterns
- Bundle size difference is acceptable (usually a few KB)

<Tip>
**Recommendation**

**Start with the Class API** for development. If bundle size becomes an issue, profile your bundle and switch specific hot paths to tree-shakeable functions.
</Tip>

## Implementation Details

All three styles operate on the same underlying branded types:

```typescript
// All three produce the same runtime value
const a = fromHex("0x6001")           // Tree-shakeable
const b = Bytecode.fromHex("0x6001")  // Namespace
const c = Bytecode.fromHex("0x6001")  // Class (same namespace method)

// Runtime: all are Uint8Array with __tag brand
console.log(a instanceof Uint8Array) // true
console.log(b instanceof Uint8Array) // true
console.log(c instanceof Uint8Array) // true
console.log(c instanceof Bytecode)   // true (prototype set)
```

Classes use `Object.setPrototypeOf` to attach methods without copying data:

```typescript
function Bytecode(value) {
  const result = BrandedBytecode.from(value)
  Object.setPrototypeOf(result, Bytecode.prototype) // Attach methods
  return result // Still a Uint8Array at runtime
}
```

## Multi-Language Support

The data-first pattern extends to other languages:

**Zig:** Functions operate on slices
```zig
const code = try Bytecode.fromHex(allocator, "0x6001");
const analysis = try Bytecode.analyze(allocator, code);
```

**Rust:** Functions operate on borrows
```rust
let code = Bytecode::from_hex("0x6001")?;
let analysis = bytecode::analyze(&code)?;
```

Each language uses idiomatic patterns while maintaining the same data-first philosophy.

## Related Patterns

### Branded Types
Type-safe wrappers with zero runtime overhead.

[Learn about branded types →](/concepts/branded-types)

### Tree-Shaking
How Voltaire enables minimal bundle sizes.

[View tree-shaking docs →](/concepts/branded-types#tree-shaking)

## Examples Across Primitives

The pattern is consistent across all primitives:

<Tabs>
  <Tab title="Address">
```typescript
// Tree-shakeable
import { fromHex, toChecksummed } from '@tevm/voltaire/BrandedAddress'
const addr = fromHex("0x742d35Cc6634C0532925a3b844Bc9e7595f51e3e")
const checksum = toChecksummed(addr)

// Class
import { Address } from '@tevm/voltaire'
const addr = Address.fromHex("0x742d35Cc6634C0532925a3b844Bc9e7595f51e3e")
const checksum = addr.toChecksummed()
```
  </Tab>

  <Tab title="Hash">
```typescript
// Tree-shakeable
import { keccak256, toHex } from '@tevm/voltaire/BrandedHash'
const hash = keccak256("hello")
const hex = toHex(hash)

// Class
import { Hash } from '@tevm/voltaire'
const hash = Hash.keccak256("hello")
const hex = hash.toHex()
```
  </Tab>

  <Tab title="Bytecode">
```typescript
// Tree-shakeable
import { fromHex, analyze } from '@tevm/voltaire/BrandedBytecode'
const code = fromHex("0x6001")
const result = analyze(code)

// Class
import { Bytecode } from '@tevm/voltaire'
const code = Bytecode.fromHex("0x6001")
const result = code.analyze()
```
  </Tab>
</Tabs>
