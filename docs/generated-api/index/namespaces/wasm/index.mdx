---
description: Auto-generated TypeScript API documentation from source code
title: Generated API Reference
---

[**@tevm/voltaire**](../../../index.mdx)

***

[@tevm/voltaire](../../../index.mdx) / [index](../../index.mdx) / wasm

# wasm

## Namespaces

- [Blake2Wasm](namespaces/Blake2Wasm.mdx)
- [Bn254Wasm](namespaces/Bn254Wasm/index.mdx)
- [Ed25519Wasm](namespaces/Ed25519Wasm.mdx)
- [Eip712Wasm](namespaces/Eip712Wasm/index.mdx)
- [P256Wasm](namespaces/P256Wasm.mdx)
- [Ripemd160Wasm](namespaces/Ripemd160Wasm.mdx)
- [Secp256k1Wasm](namespaces/Secp256k1Wasm/index.mdx)
- [Sha256Wasm](namespaces/Sha256Wasm.mdx)
- [X25519Wasm](namespaces/X25519Wasm.mdx)

## Enumerations

### TransactionType

Defined in: [src/primitives/Transaction/Transaction.wasm.ts:11](https://github.com/evmts/voltaire/blob/c23bdec42e80cac8af3a4130b0c4c180becd2ad0/src/primitives/Transaction/Transaction.wasm.ts#L11)

Transaction type enumeration

#### Enumeration Members

##### EIP1559

> **EIP1559**: `2`

Defined in: [src/primitives/Transaction/Transaction.wasm.ts:17](https://github.com/evmts/voltaire/blob/c23bdec42e80cac8af3a4130b0c4c180becd2ad0/src/primitives/Transaction/Transaction.wasm.ts#L17)

EIP-1559 fee market transaction

##### EIP2930

> **EIP2930**: `1`

Defined in: [src/primitives/Transaction/Transaction.wasm.ts:15](https://github.com/evmts/voltaire/blob/c23bdec42e80cac8af3a4130b0c4c180becd2ad0/src/primitives/Transaction/Transaction.wasm.ts#L15)

EIP-2930 access list transaction

##### EIP4844

> **EIP4844**: `3`

Defined in: [src/primitives/Transaction/Transaction.wasm.ts:19](https://github.com/evmts/voltaire/blob/c23bdec42e80cac8af3a4130b0c4c180becd2ad0/src/primitives/Transaction/Transaction.wasm.ts#L19)

EIP-4844 blob transaction

##### EIP7702

> **EIP7702**: `4`

Defined in: [src/primitives/Transaction/Transaction.wasm.ts:21](https://github.com/evmts/voltaire/blob/c23bdec42e80cac8af3a4130b0c4c180becd2ad0/src/primitives/Transaction/Transaction.wasm.ts#L21)

EIP-7702 set code transaction

##### Legacy

> **Legacy**: `0`

Defined in: [src/primitives/Transaction/Transaction.wasm.ts:13](https://github.com/evmts/voltaire/blob/c23bdec42e80cac8af3a4130b0c4c180becd2ad0/src/primitives/Transaction/Transaction.wasm.ts#L13)

Legacy transaction (pre-EIP-2718)

## Interfaces

### ParsedSignature

Defined in: [src/crypto/signature.wasm.js:18](https://github.com/evmts/voltaire/blob/c23bdec42e80cac8af3a4130b0c4c180becd2ad0/src/crypto/signature.wasm.js#L18)

#### Properties

##### r

> **r**: `Uint8Array`\<`ArrayBufferLike`\>

Defined in: [src/crypto/signature.wasm.js:12](https://github.com/evmts/voltaire/blob/c23bdec42e80cac8af3a4130b0c4c180becd2ad0/src/crypto/signature.wasm.js#L12)

R component (32 bytes)

##### s

> **s**: `Uint8Array`\<`ArrayBufferLike`\>

Defined in: [src/crypto/signature.wasm.js:13](https://github.com/evmts/voltaire/blob/c23bdec42e80cac8af3a4130b0c4c180becd2ad0/src/crypto/signature.wasm.js#L13)

S component (32 bytes)

##### v

> **v**: `number`

Defined in: [src/crypto/signature.wasm.js:14](https://github.com/evmts/voltaire/blob/c23bdec42e80cac8af3a4130b0c4c180becd2ad0/src/crypto/signature.wasm.js#L14)

Recovery ID (0, 1, 27, or 28)

## Type Aliases

### ParsedSignature

> **ParsedSignature** = `undefined`

Defined in: [src/crypto/signature.wasm.js:18](https://github.com/evmts/voltaire/blob/c23bdec42e80cac8af3a4130b0c4c180becd2ad0/src/crypto/signature.wasm.js#L18)

ParsedSignature type

## Variables

### Abi

> `const` **Abi**: *typeof* [`Abi`](../../index.mdx#abi) = `AbiJS`

Defined in: [src/wasm/index.ts:234](https://github.com/evmts/voltaire/blob/c23bdec42e80cac8af3a4130b0c4c180becd2ad0/src/wasm/index.ts#L234)

***

### AccessList

> `const` **AccessList**: `object` = `AccessListJS`

Defined in: [src/wasm/index.ts:236](https://github.com/evmts/voltaire/blob/c23bdec42e80cac8af3a4130b0c4c180becd2ad0/src/wasm/index.ts#L236)

#### Type Declaration

##### ADDRESS\_COST

> **ADDRESS\_COST**: `bigint`

Gas cost per address in access list (EIP-2930)

##### addressCount()

> **addressCount**: (`list`) => `number`

###### Parameters

###### list

[`BrandedAccessList`](../BrandedAccessList.mdx#brandedaccesslist)

###### Returns

`number`

##### assertValid()

> **assertValid**: (`list`) => `void`

###### Parameters

###### list

[`BrandedAccessList`](../BrandedAccessList.mdx#brandedaccesslist)

###### Returns

`void`

##### COLD\_ACCOUNT\_ACCESS\_COST

> **COLD\_ACCOUNT\_ACCESS\_COST**: `bigint`

Cold account access cost (pre-EIP-2930)

##### COLD\_STORAGE\_ACCESS\_COST

> **COLD\_STORAGE\_ACCESS\_COST**: `bigint`

Cold storage access cost (pre-EIP-2930)

##### create()

> **create**: () => [`BrandedAccessList`](../BrandedAccessList.mdx#brandedaccesslist)

###### Returns

[`BrandedAccessList`](../BrandedAccessList.mdx#brandedaccesslist)

##### deduplicate()

> **deduplicate**: (`list`) => [`BrandedAccessList`](../BrandedAccessList.mdx#brandedaccesslist)

###### Parameters

###### list

[`BrandedAccessList`](../BrandedAccessList.mdx#brandedaccesslist)

###### Returns

[`BrandedAccessList`](../BrandedAccessList.mdx#brandedaccesslist)

##### from()

> **from**: (`value`) => [`BrandedAccessList`](../BrandedAccessList.mdx#brandedaccesslist)

###### Parameters

###### value

`Uint8Array`\<`ArrayBufferLike`\> | readonly [`Item`](../BrandedAccessList.mdx#item)[]

###### Returns

[`BrandedAccessList`](../BrandedAccessList.mdx#brandedaccesslist)

##### fromBytes()

> **fromBytes**: (`bytes`) => [`BrandedAccessList`](../BrandedAccessList.mdx#brandedaccesslist)

###### Parameters

###### bytes

`Uint8Array`

###### Returns

[`BrandedAccessList`](../BrandedAccessList.mdx#brandedaccesslist)

##### gasCost()

> **gasCost**: (`list`) => `bigint`

###### Parameters

###### list

[`BrandedAccessList`](../BrandedAccessList.mdx#brandedaccesslist)

###### Returns

`bigint`

##### gasSavings()

> **gasSavings**: (`list`) => `bigint`

###### Parameters

###### list

[`BrandedAccessList`](../BrandedAccessList.mdx#brandedaccesslist)

###### Returns

`bigint`

##### hasSavings()

> **hasSavings**: (`list`) => `boolean`

###### Parameters

###### list

[`BrandedAccessList`](../BrandedAccessList.mdx#brandedaccesslist)

###### Returns

`boolean`

##### includesAddress()

> **includesAddress**: (`list`, `address`) => `boolean`

###### Parameters

###### list

[`BrandedAccessList`](../BrandedAccessList.mdx#brandedaccesslist)

###### address

[`AddressType`](../../../primitives/Address.mdx#addresstype)

###### Returns

`boolean`

##### includesStorageKey()

> **includesStorageKey**: (`list`, `address`, `storageKey`) => `boolean`

###### Parameters

###### list

[`BrandedAccessList`](../BrandedAccessList.mdx#brandedaccesslist)

###### address

[`AddressType`](../../../primitives/Address.mdx#addresstype)

###### storageKey

[`HashType`](../HashType-2.mdx#hashtype)

###### Returns

`boolean`

##### is()

> **is**: (`value`) => `value is BrandedAccessList`

###### Parameters

###### value

`unknown`

###### Returns

`value is BrandedAccessList`

##### isEmpty()

> **isEmpty**: (`list`) => `boolean`

###### Parameters

###### list

[`BrandedAccessList`](../BrandedAccessList.mdx#brandedaccesslist)

###### Returns

`boolean`

##### isItem()

> **isItem**: (`value`) => `value is Item`

###### Parameters

###### value

`unknown`

###### Returns

`value is Item`

##### keysFor()

> **keysFor**: (`list`, `address`) => readonly [`HashType`](../HashType-2.mdx#hashtype)[] \| `undefined`

###### Parameters

###### list

[`BrandedAccessList`](../BrandedAccessList.mdx#brandedaccesslist)

###### address

[`AddressType`](../../../primitives/Address.mdx#addresstype)

###### Returns

readonly [`HashType`](../HashType-2.mdx#hashtype)[] \| `undefined`

##### merge()

> **merge**: (...`accessLists`) => [`BrandedAccessList`](../BrandedAccessList.mdx#brandedaccesslist)

###### Parameters

###### accessLists

...[`BrandedAccessList`](../BrandedAccessList.mdx#brandedaccesslist)[]

###### Returns

[`BrandedAccessList`](../BrandedAccessList.mdx#brandedaccesslist)

##### STORAGE\_KEY\_COST

> **STORAGE\_KEY\_COST**: `bigint`

Gas cost per storage key in access list (EIP-2930)

##### storageKeyCount()

> **storageKeyCount**: (`list`) => `number`

###### Parameters

###### list

[`BrandedAccessList`](../BrandedAccessList.mdx#brandedaccesslist)

###### Returns

`number`

##### toBytes()

> **toBytes**: (`list`) => `Uint8Array`

###### Parameters

###### list

[`BrandedAccessList`](../BrandedAccessList.mdx#brandedaccesslist)

###### Returns

`Uint8Array`

##### WARM\_STORAGE\_ACCESS\_COST

> **WARM\_STORAGE\_ACCESS\_COST**: `bigint`

Warm storage access cost (post-EIP-2929)

##### withAddress()

> **withAddress**: (`list`, `address`) => [`BrandedAccessList`](../BrandedAccessList.mdx#brandedaccesslist)

###### Parameters

###### list

[`BrandedAccessList`](../BrandedAccessList.mdx#brandedaccesslist)

###### address

[`AddressType`](../../../primitives/Address.mdx#addresstype)

###### Returns

[`BrandedAccessList`](../BrandedAccessList.mdx#brandedaccesslist)

##### withStorageKey()

> **withStorageKey**: (`list`, `address`, `storageKey`) => [`BrandedAccessList`](../BrandedAccessList.mdx#brandedaccesslist)

###### Parameters

###### list

[`BrandedAccessList`](../BrandedAccessList.mdx#brandedaccesslist)

###### address

[`AddressType`](../../../primitives/Address.mdx#addresstype)

###### storageKey

[`HashType`](../HashType-2.mdx#hashtype)

###### Returns

[`BrandedAccessList`](../BrandedAccessList.mdx#brandedaccesslist)

***

### Address

> `const` **Address**: *typeof* [`Address`](../../../primitives/Address.mdx#address) = `AddressJS`

Defined in: [src/wasm/index.ts:229](https://github.com/evmts/voltaire/blob/c23bdec42e80cac8af3a4130b0c4c180becd2ad0/src/wasm/index.ts#L229)

***

### Blake2

> `const` **Blake2**: (`input`, `outputLength?`) => [`Blake2Hash`](../../index.mdx#blake2hash) & `object` & `object`

Defined in: [src/wasm/index.ts:172](https://github.com/evmts/voltaire/blob/c23bdec42e80cac8af3a4130b0c4c180becd2ad0/src/wasm/index.ts#L172)

Blake2 with WASM acceleration

#### Type Declaration

##### from()

> **from**: (`input`, `outputLength?`) => [`Blake2Hash`](../../index.mdx#blake2hash)

Hash input with BLAKE2b (constructor pattern)

Auto-detects input type and hashes accordingly:
- Uint8Array: hash directly
- string: UTF-8 encode then hash

###### Parameters

###### input

Data to hash

`string` | `Uint8Array`\<`ArrayBufferLike`\>

###### outputLength?

`number` = `64`

Output length in bytes (1-64, default 64)

###### Returns

[`Blake2Hash`](../../index.mdx#blake2hash)

BLAKE2b hash

###### See

https://voltaire.tevm.sh/crypto/blake2 for crypto documentation

###### Since

0.0.0

###### Throws

If outputLength is invalid

###### Example

```javascript
import { Blake2Hash } from './crypto/Blake2/index.js';

const hash1 = Blake2Hash.from("hello");              // String, 64 bytes
const hash2 = Blake2Hash.from("hello", 32);          // String, 32 bytes
const hash3 = Blake2Hash.from(uint8array);           // Bytes, 64 bytes
const hash4 = Blake2Hash.from(uint8array, 48);       // Bytes, 48 bytes
```

##### fromString()

> **fromString**: (`str`, `outputLength?`) => [`Blake2Hash`](../../index.mdx#blake2hash) = `hashString`

Hash string with BLAKE2b (convenience function)

###### Parameters

###### str

`string`

Input string to hash

###### outputLength?

`number` = `64`

Output length in bytes (1-64, default 64)

###### Returns

[`Blake2Hash`](../../index.mdx#blake2hash)

BLAKE2b hash

###### See

https://voltaire.tevm.sh/crypto for crypto documentation

###### Since

0.0.0

###### Throws

If outputLength is invalid

###### Example

```javascript
import * as Blake2 from './crypto/Blake2/index.js';
const hash = Blake2.hashString("hello world");
const hash48 = Blake2.hashString("hello world", 48);
```

##### hash()

> **hash**: (`data`, `outputLength?`) => [`Blake2Hash`](../../index.mdx#blake2hash)

Hash data with BLAKE2b

###### Parameters

###### data

Input data to hash (Uint8Array or string)

`string` | `Uint8Array`\<`ArrayBufferLike`\>

###### outputLength?

`number` = `64`

Output length in bytes (1-64, default 64)

###### Returns

[`Blake2Hash`](../../index.mdx#blake2hash)

BLAKE2b hash

###### See

https://voltaire.tevm.sh/crypto for crypto documentation

###### Since

0.0.0

###### Throws

If outputLength is invalid

###### Example

```javascript
import * as Blake2 from './crypto/Blake2/index.js';
const hash = Blake2.hash(new Uint8Array([1, 2, 3]));
const hash32 = Blake2.hash("hello", 32);
```

##### hashString()

> **hashString**: (`str`, `outputLength?`) => [`Blake2Hash`](../../index.mdx#blake2hash)

Hash string with BLAKE2b (convenience function)

###### Parameters

###### str

`string`

Input string to hash

###### outputLength?

`number` = `64`

Output length in bytes (1-64, default 64)

###### Returns

[`Blake2Hash`](../../index.mdx#blake2hash)

BLAKE2b hash

###### See

https://voltaire.tevm.sh/crypto for crypto documentation

###### Since

0.0.0

###### Throws

If outputLength is invalid

###### Example

```javascript
import * as Blake2 from './crypto/Blake2/index.js';
const hash = Blake2.hashString("hello world");
const hash48 = Blake2.hashString("hello world", 48);
```

##### SIZE

> **SIZE**: `number`

#### Type Declaration

##### \_wasm

> **\_wasm**: *typeof* [`Blake2Wasm`](namespaces/Blake2Wasm.mdx) = `Blake2Wasm`

***

### Blob

> `const` **Blob**: *typeof* [`Blob`](../../index.mdx#blob) = `BlobJS`

Defined in: [src/wasm/index.ts:235](https://github.com/evmts/voltaire/blob/c23bdec42e80cac8af3a4130b0c4c180becd2ad0/src/wasm/index.ts#L235)

***

### BloomFilter

> `const` **BloomFilter**: *typeof* [`BloomFilter`](../../index.mdx#bloomfilter) = `BloomFilterJS`

Defined in: [src/wasm/index.ts:240](https://github.com/evmts/voltaire/blob/c23bdec42e80cac8af3a4130b0c4c180becd2ad0/src/wasm/index.ts#L240)

***

### Bls12381

> `const` **Bls12381**: `object` = `Bls12381JS`

Defined in: [src/wasm/index.ts:253](https://github.com/evmts/voltaire/blob/c23bdec42e80cac8af3a4130b0c4c180becd2ad0/src/wasm/index.ts#L253)

#### Type Declaration

##### aggregate()

> **aggregate**: (`signatures`) => `Uint8Array`\<`ArrayBufferLike`\>

Aggregate multiple BLS signatures into one

The aggregated signature can be verified against an aggregated public key
(when all signers signed the same message) or via batch verification
(when signers signed different messages).

###### Parameters

###### signatures

`Uint8Array`\<`ArrayBufferLike`\>[]

Array of compressed G1 signatures (48 bytes each)

###### Returns

`Uint8Array`\<`ArrayBufferLike`\>

Aggregated signature (48 bytes compressed G1)

###### Throws

If aggregation fails or no signatures provided

###### Example

```javascript
import { Bls12381 } from './crypto/Bls12381/index.js';

const message = new TextEncoder().encode('Vote for proposal');

const pk1 = Bls12381.randomPrivateKey();
const pk2 = Bls12381.randomPrivateKey();

const sig1 = Bls12381.sign(message, pk1);
const sig2 = Bls12381.sign(message, pk2);

const aggSig = Bls12381.aggregate([sig1, sig2]);
```

##### aggregatePublicKeys()

> **aggregatePublicKeys**: (`publicKeys`) => `Uint8Array`\<`ArrayBufferLike`\>

Aggregate multiple public keys into one

Used when multiple signers sign the same message and you want
to verify against a single aggregated public key.

###### Parameters

###### publicKeys

`Uint8Array`\<`ArrayBufferLike`\>[]

Array of compressed G2 public keys (96 bytes each)

###### Returns

`Uint8Array`\<`ArrayBufferLike`\>

Aggregated public key (96 bytes compressed G2)

###### Throws

If aggregation fails or no public keys provided

###### Example

```javascript
import { Bls12381 } from './crypto/Bls12381/index.js';

const pk1 = Bls12381.randomPrivateKey();
const pk2 = Bls12381.randomPrivateKey();

const pubKey1 = Bls12381.derivePublicKey(pk1);
const pubKey2 = Bls12381.derivePublicKey(pk2);

const aggPubKey = Bls12381.aggregatePublicKeys([pubKey1, pubKey2]);
```

##### aggregateVerify()

> **aggregateVerify**: (`aggregatedSignature`, `message`, `publicKeys`) => `boolean`

Verify an aggregated signature where all signers signed the same message

This is the most common case in Ethereum consensus - multiple validators
sign the same block/attestation.

###### Parameters

###### aggregatedSignature

`Uint8Array`\<`ArrayBufferLike`\>

Aggregated signature (96 bytes)

###### message

`Uint8Array`\<`ArrayBufferLike`\>

The message that was signed by all parties

###### publicKeys

`Uint8Array`\<`ArrayBufferLike`\>[]

Public keys of all signers (48 bytes each)

###### Returns

`boolean`

True if the aggregated signature is valid

###### Example

```javascript
import { Bls12381 } from './crypto/Bls12381/index.js';

const message = new TextEncoder().encode('Block attestation');

const pk1 = Bls12381.randomPrivateKey();
const pk2 = Bls12381.randomPrivateKey();
const pubKey1 = Bls12381.derivePublicKey(pk1);
const pubKey2 = Bls12381.derivePublicKey(pk2);

const sig1 = Bls12381.sign(message, pk1);
const sig2 = Bls12381.sign(message, pk2);
const aggSig = Bls12381.aggregate([sig1, sig2]);

const isValid = Bls12381.aggregateVerify(aggSig, message, [pubKey1, pubKey2]);
console.log(isValid); // true
```

##### batchVerify()

> **batchVerify**: (`aggregatedSignature`, `messages`, `publicKeys`) => `boolean`

Verify an aggregated signature where each signer signed a different message

Uses multi-pairing verification: product of e(pk_i, H(msg_i)) == e(G1, aggSig)

###### Parameters

###### aggregatedSignature

`Uint8Array`\<`ArrayBufferLike`\>

Aggregated signature (96 bytes)

###### messages

`Uint8Array`\<`ArrayBufferLike`\>[]

Messages that were signed (one per signer)

###### publicKeys

`Uint8Array`\<`ArrayBufferLike`\>[]

Public keys (one per signer, same order as messages)

###### Returns

`boolean`

True if the aggregated signature is valid

###### Throws

If messages and publicKeys have different lengths

###### Example

```javascript
import { Bls12381 } from './crypto/Bls12381/index.js';

const pk1 = Bls12381.randomPrivateKey();
const pk2 = Bls12381.randomPrivateKey();
const pubKey1 = Bls12381.derivePublicKey(pk1);
const pubKey2 = Bls12381.derivePublicKey(pk2);

const msg1 = new TextEncoder().encode('Message 1');
const msg2 = new TextEncoder().encode('Message 2');

const sig1 = Bls12381.sign(msg1, pk1);
const sig2 = Bls12381.sign(msg2, pk2);
const aggSig = Bls12381.aggregate([sig1, sig2]);

const isValid = Bls12381.batchVerify(aggSig, [msg1, msg2], [pubKey1, pubKey2]);
console.log(isValid); // true
```

##### derivePublicKey()

> **derivePublicKey**: (`privateKey`) => `Uint8Array`\<`ArrayBufferLike`\>

Derive a BLS12-381 public key from a private key

Public key = privateKey * G2_generator

###### Parameters

###### privateKey

`Uint8Array`\<`ArrayBufferLike`\>

32-byte private key (scalar in Fr)

###### Returns

`Uint8Array`\<`ArrayBufferLike`\>

Compressed G2 public key (96 bytes)

###### Throws

If private key is invalid

###### Example

```javascript
import { Bls12381 } from './crypto/Bls12381/index.js';

const privateKey = Bls12381.randomPrivateKey();
const publicKey = Bls12381.derivePublicKey(privateKey);
console.log(publicKey.length); // 96
```

##### derivePublicKeyPoint()

> **derivePublicKeyPoint**: (`privateKey`) => [`Bls12381G1PointType`](../../index.mdx#bls12381g1pointtype)

Derive a BLS12-381 public key as a G1 point (uncompressed)

###### Parameters

###### privateKey

`Uint8Array`\<`ArrayBufferLike`\>

32-byte private key

###### Returns

[`Bls12381G1PointType`](../../index.mdx#bls12381g1pointtype)

Public key as G1 point

###### Throws

If private key is invalid

##### fastAggregateVerify()

> **fastAggregateVerify**: (`aggregatedSignature`, `message`, `aggregatedPublicKey`) => `boolean`

Fast aggregate verify (same message case)

Optimized for the common case where all signers signed the same message.
This is faster than aggregateVerify when you already have the aggregated public key.

###### Parameters

###### aggregatedSignature

`Uint8Array`\<`ArrayBufferLike`\>

Aggregated signature (96 bytes)

###### message

`Uint8Array`\<`ArrayBufferLike`\>

The message that was signed

###### aggregatedPublicKey

`Uint8Array`\<`ArrayBufferLike`\>

Pre-computed aggregated public key (48 bytes)

###### Returns

`boolean`

True if valid

##### Fp

> **Fp**: `__module`

##### Fp2

> **Fp2**: `__module`

##### Fr

> **Fr**: `__module`

##### G1

> **G1**: `__module`

##### G2

> **G2**: `__module`

##### isValidPrivateKey()

> **isValidPrivateKey**: (`privateKey`) => `boolean`

Check if a private key is valid

A valid private key must be:
- 32 bytes
- Non-zero
- Less than the curve order (Fr modulus)

###### Parameters

###### privateKey

`Uint8Array`\<`ArrayBufferLike`\>

Private key to validate

###### Returns

`boolean`

True if valid

###### Example

```javascript
import { Bls12381 } from './crypto/Bls12381/index.js';

const pk = Bls12381.randomPrivateKey();
console.log(Bls12381.isValidPrivateKey(pk)); // true

const invalid = new Uint8Array(32); // all zeros
console.log(Bls12381.isValidPrivateKey(invalid)); // false
```

##### Pairing

> **Pairing**: `__module`

BLS12-381 Pairing Operations

Optimal Ate pairing implementation for BLS12-381.
e: G1 x G2 -> GT

NOTE: Full pairing implementation requires Fp6, Fp12 tower extensions
and Miller loop computation. For production use, the native blst
library should be used via the Zig FFI bindings.

This module provides the interface and simplified implementations
for testing and educational purposes.

###### See

https://hackmd.io/@benjaminion/bls12-381 for pairing details

###### Since

0.0.0

##### randomPrivateKey()

> **randomPrivateKey**: () => `Uint8Array`\<`ArrayBufferLike`\>

Generate a random BLS12-381 private key

Uses cryptographically secure random number generation.
The key is guaranteed to be valid (non-zero and less than curve order).

###### Returns

`Uint8Array`\<`ArrayBufferLike`\>

32-byte private key

###### Example

```javascript
import { Bls12381 } from './crypto/Bls12381/index.js';

const privateKey = Bls12381.randomPrivateKey();
const publicKey = Bls12381.derivePublicKey(privateKey);
```

##### sign()

> **sign**: (`message`, `privateKey`) => `Uint8Array`\<`ArrayBufferLike`\>

Sign a message using BLS12-381

Uses the Ethereum consensus "short signatures" scheme:
- Signature = privateKey * H(message) where H maps to G1
- Signatures are 48 bytes (compressed G1 point)

###### Parameters

###### message

`Uint8Array`\<`ArrayBufferLike`\>

Message to sign

###### privateKey

`Uint8Array`\<`ArrayBufferLike`\>

32-byte private key (scalar in Fr)

###### Returns

`Uint8Array`\<`ArrayBufferLike`\>

Signature as compressed G1 point (48 bytes)

###### Throws

If private key is invalid

###### Throws

If signing fails

###### Example

```javascript
import { Bls12381 } from './crypto/Bls12381/index.js';

const privateKey = Bls12381.randomPrivateKey();
const message = new TextEncoder().encode('Hello, Ethereum!');
const signature = Bls12381.sign(message, privateKey);
```

##### signPoint()

> **signPoint**: (`messagePoint`, `privateKey`) => [`Bls12381G2PointType`](../../index.mdx#bls12381g2pointtype)

Sign a pre-hashed message (G2 point) using BLS12-381

For advanced use when you have already hashed the message to G2.

###### Parameters

###### messagePoint

[`Bls12381G2PointType`](../../index.mdx#bls12381g2pointtype)

Message as G2 point

###### privateKey

`Uint8Array`\<`ArrayBufferLike`\>

32-byte private key (scalar in Fr)

###### Returns

[`Bls12381G2PointType`](../../index.mdx#bls12381g2pointtype)

Signature as G2 point (projective)

###### Throws

If private key is invalid

###### Throws

If signing fails

##### verify()

> **verify**: (`signature`, `message`, `publicKey`) => `boolean`

Verify a BLS12-381 signature

Uses pairing check for verification.

###### Parameters

###### signature

`Uint8Array`\<`ArrayBufferLike`\>

Compressed G1 signature (48 bytes)

###### message

`Uint8Array`\<`ArrayBufferLike`\>

Original message that was signed

###### publicKey

`Uint8Array`\<`ArrayBufferLike`\>

Compressed G2 public key (96 bytes)

###### Returns

`boolean`

True if signature is valid

###### Throws

If verification fails due to invalid inputs

###### Example

```javascript
import { Bls12381 } from './crypto/Bls12381/index.js';

const privateKey = Bls12381.randomPrivateKey();
const publicKey = Bls12381.derivePublicKey(privateKey);
const message = new TextEncoder().encode('Hello!');
const signature = Bls12381.sign(message, privateKey);

const isValid = Bls12381.verify(signature, message, publicKey);
console.log(isValid); // true
```

##### verifyPoint()

> **verifyPoint**: (`signaturePoint`, `messagePoint`, `publicKeyPoint`) => `boolean`

Verify a BLS signature with pre-computed points (advanced)

For use when you have already deserialized the points.

###### Parameters

###### signaturePoint

[`Bls12381G2PointType`](../../index.mdx#bls12381g2pointtype)

Signature as G2 point

###### messagePoint

[`Bls12381G2PointType`](../../index.mdx#bls12381g2pointtype)

Message hash as G2 point

###### publicKeyPoint

[`Bls12381G1PointType`](../../index.mdx#bls12381g1pointtype)

Public key as G1 point

###### Returns

`boolean`

True if signature is valid

***

### BN254

> `const` **BN254**: `object` & `object`

Defined in: [src/wasm/index.ts:214](https://github.com/evmts/voltaire/blob/c23bdec42e80cac8af3a4130b0c4c180becd2ad0/src/wasm/index.ts#L214)

BN254 with WASM acceleration

#### Type Declaration

##### deserializeG1()

> **deserializeG1**: (`bytes`) => `G1PointType`

Deserialize G1 point from bytes

###### Parameters

###### bytes

`Uint8Array`\<`ArrayBufferLike`\>

64-byte serialization

###### Returns

`G1PointType`

G1 point

###### See

https://voltaire.tevm.sh/crypto for BN254 cryptography documentation

###### Since

0.0.0

###### Throws

If bytes length is invalid (must be 64 bytes)

###### Example

```javascript
import { deserializeG1 } from './crypto/bn254/deserializeG1.js';
const bytes = new Uint8Array(64);
const point = deserializeG1(bytes);
```

##### deserializeG2()

> **deserializeG2**: (`bytes`) => `G2PointType`

Deserialize G2 point from bytes

###### Parameters

###### bytes

`Uint8Array`\<`ArrayBufferLike`\>

128-byte serialization

###### Returns

`G2PointType`

G2 point

###### See

https://voltaire.tevm.sh/crypto for BN254 cryptography documentation

###### Since

0.0.0

###### Throws

If bytes length is invalid (must be 128 bytes)

###### Example

```javascript
import { deserializeG2 } from './crypto/bn254/deserializeG2.js';
const bytes = new Uint8Array(128);
const point = deserializeG2(bytes);
```

##### Fp

> **Fp**: `__module`

##### Fp2

> **Fp2**: `__module`

##### Fr

> **Fr**: `__module`

##### G1

> **G1**: `__module`

##### G2

> **G2**: `__module`

##### Pairing

> **Pairing**: `__module`

##### serializeG1()

> **serializeG1**: (`point`) => `Uint8Array`\<`ArrayBufferLike`\>

Serialize G1 point to bytes (64 bytes: x || y)

###### Parameters

###### point

`G1PointType`

G1 point

###### Returns

`Uint8Array`\<`ArrayBufferLike`\>

64-byte serialization

###### See

https://voltaire.tevm.sh/crypto for BN254 cryptography documentation

###### Since

0.0.0

###### Throws

###### Example

```javascript
import { serializeG1 } from './crypto/bn254/serializeG1.js';
import * as G1 from './crypto/bn254/G1/index.js';
const point = G1.generator();
const bytes = serializeG1(point);
```

##### serializeG2()

> **serializeG2**: (`point`) => `Uint8Array`\<`ArrayBufferLike`\>

Serialize G2 point to bytes (128 bytes: x.c0 || x.c1 || y.c0 || y.c1)

###### Parameters

###### point

`G2PointType`

G2 point

###### Returns

`Uint8Array`\<`ArrayBufferLike`\>

128-byte serialization

###### See

https://voltaire.tevm.sh/crypto for BN254 cryptography documentation

###### Since

0.0.0

###### Throws

###### Example

```javascript
import { serializeG2 } from './crypto/bn254/serializeG2.js';
import * as G2 from './crypto/bn254/G2/index.js';
const point = G2.generator();
const bytes = serializeG2(point);
```

#### Type Declaration

##### \_wasm

> **\_wasm**: *typeof* [`Bn254Wasm`](namespaces/Bn254Wasm/index.mdx) = `Bn254Wasm`

***

### Bytecode

> `const` **Bytecode**: *typeof* [`Bytecode`](../../index.mdx#bytecode) = `BytecodeJS`

Defined in: [src/wasm/index.ts:237](https://github.com/evmts/voltaire/blob/c23bdec42e80cac8af3a4130b0c4c180becd2ad0/src/wasm/index.ts#L237)

***

### Bytes

> `const` **Bytes**: *typeof* [`Bytes`](../../index.mdx#bytes) = `BytesJS`

Defined in: [src/wasm/index.ts:242](https://github.com/evmts/voltaire/blob/c23bdec42e80cac8af3a4130b0c4c180becd2ad0/src/wasm/index.ts#L242)

***

### Bytes32

> `const` **Bytes32**: *typeof* [`Bytes32`](../../index.mdx#bytes32) = `Bytes32JS`

Defined in: [src/wasm/index.ts:243](https://github.com/evmts/voltaire/blob/c23bdec42e80cac8af3a4130b0c4c180becd2ad0/src/wasm/index.ts#L243)

***

### Chain

> `const` **Chain**: *typeof* [`Chain`](../../index.mdx#chain-1) = `ChainJS`

Defined in: [src/wasm/index.ts:238](https://github.com/evmts/voltaire/blob/c23bdec42e80cac8af3a4130b0c4c180becd2ad0/src/wasm/index.ts#L238)

***

### Ed25519

> `const` **Ed25519**: `object` & `object`

Defined in: [src/wasm/index.ts:193](https://github.com/evmts/voltaire/blob/c23bdec42e80cac8af3a4130b0c4c180becd2ad0/src/wasm/index.ts#L193)

Ed25519 with WASM acceleration

#### Type Declaration

##### derivePublicKey()

> **derivePublicKey**: (`secretKey`) => `PublicKey`

Derive Ed25519 public key from secret key.

###### Parameters

###### secretKey

`SecretKey`

32-byte Ed25519 secret key (seed)

###### Returns

`PublicKey`

32-byte Ed25519 public key

###### See

https://voltaire.tevm.sh/crypto for crypto documentation

###### Since

0.0.0

###### Throws

If secret key length is invalid or derivation fails

###### Example

```javascript
import * as Ed25519 from './crypto/Ed25519/index.js';
const secretKey = new Uint8Array(32); // Your secret key
const publicKey = Ed25519.derivePublicKey(secretKey);
```

##### keypairFromSeed()

> **keypairFromSeed**: (`seed`) => `object`

Generate Ed25519 keypair from seed deterministically.

###### Parameters

###### seed

`Seed`

32-byte seed for deterministic keypair generation

###### Returns

`object`

Object containing 32-byte secretKey and 32-byte publicKey

###### publicKey

> **publicKey**: `PublicKey`

###### secretKey

> **secretKey**: `SecretKey`

###### See

https://voltaire.tevm.sh/crypto for crypto documentation

###### Since

0.0.0

###### Throws

If seed length is not 32 bytes

###### Throws

If keypair generation fails

###### Example

```javascript
import * as Ed25519 from './crypto/Ed25519/index.js';
const seed = crypto.getRandomValues(new Uint8Array(32));
const keypair = Ed25519.keypairFromSeed(seed);
console.log(keypair.publicKey); // Uint8Array(32)
```

##### PUBLIC\_KEY\_SIZE

> **PUBLIC\_KEY\_SIZE**: `32`

Ed25519 public key size in bytes.

###### See

https://voltaire.tevm.sh/crypto for crypto documentation

###### Since

0.0.0

###### Example

```javascript
import { PUBLIC_KEY_SIZE } from './crypto/Ed25519/constants.js';
const publicKey = new Uint8Array(PUBLIC_KEY_SIZE);
```

##### SECRET\_KEY\_SIZE

> **SECRET\_KEY\_SIZE**: `32`

Ed25519 secret key size in bytes.

###### See

https://voltaire.tevm.sh/crypto for crypto documentation

###### Since

0.0.0

###### Example

```javascript
import { SECRET_KEY_SIZE } from './crypto/Ed25519/constants.js';
const secretKey = new Uint8Array(SECRET_KEY_SIZE);
```

##### SEED\_SIZE

> **SEED\_SIZE**: `32`

Ed25519 seed size in bytes.

###### See

https://voltaire.tevm.sh/crypto for crypto documentation

###### Since

0.0.0

###### Example

```javascript
import { SEED_SIZE } from './crypto/Ed25519/constants.js';
const seed = crypto.getRandomValues(new Uint8Array(SEED_SIZE));
```

##### sign()

> **sign**: (`message`, `secretKey`) => `Signature`

Sign message with Ed25519 secret key.

Produces deterministic signatures using EdDSA.

###### Parameters

###### message

`Uint8Array`\<`ArrayBufferLike`\>

Message bytes to sign (any length)

###### secretKey

`SecretKey`

32-byte Ed25519 secret key

###### Returns

`Signature`

64-byte Ed25519 signature

###### See

https://voltaire.tevm.sh/crypto for crypto documentation

###### Since

0.0.0

###### Throws

If secret key length is not 32 bytes

###### Throws

If signing operation fails

###### Example

```javascript
import * as Ed25519 from './crypto/Ed25519/index.js';
const message = new TextEncoder().encode('Hello, world!');
const signature = Ed25519.sign(message, secretKey);
```

##### SIGNATURE\_SIZE

> **SIGNATURE\_SIZE**: `64`

Ed25519 signature size in bytes.

###### See

https://voltaire.tevm.sh/crypto for crypto documentation

###### Since

0.0.0

###### Example

```javascript
import { SIGNATURE_SIZE } from './crypto/Ed25519/constants.js';
const signature = new Uint8Array(SIGNATURE_SIZE);
```

##### validatePublicKey()

> **validatePublicKey**: (`publicKey`) => `boolean`

Validate Ed25519 public key format and curve membership.

###### Parameters

###### publicKey

`PublicKey`

Ed25519 public key to validate

###### Returns

`boolean`

True if public key is valid and on curve, false otherwise

###### See

https://voltaire.tevm.sh/crypto for crypto documentation

###### Since

0.0.0

###### Throws

###### Example

```javascript
import * as Ed25519 from './crypto/Ed25519/index.js';
const isValid = Ed25519.validatePublicKey(publicKey);
if (!isValid) console.log('Invalid public key');
```

##### validateSecretKey()

> **validateSecretKey**: (`secretKey`) => `boolean`

Validate Ed25519 secret key format.

Checks length and attempts public key derivation.

###### Parameters

###### secretKey

`SecretKey`

Ed25519 secret key to validate

###### Returns

`boolean`

True if secret key is valid (32 bytes and can derive public key), false otherwise

###### See

https://voltaire.tevm.sh/crypto for crypto documentation

###### Since

0.0.0

###### Throws

###### Example

```javascript
import * as Ed25519 from './crypto/Ed25519/index.js';
const isValid = Ed25519.validateSecretKey(secretKey);
if (!isValid) console.log('Invalid secret key');
```

##### validateSeed()

> **validateSeed**: (`seed`) => `boolean`

Validate Ed25519 seed format.

Checks if seed has correct 32-byte length.

###### Parameters

###### seed

`Seed`

Ed25519 seed to validate

###### Returns

`boolean`

True if seed is exactly 32 bytes, false otherwise

###### See

https://voltaire.tevm.sh/crypto for crypto documentation

###### Since

0.0.0

###### Throws

###### Example

```javascript
import * as Ed25519 from './crypto/Ed25519/index.js';
const seed = crypto.getRandomValues(new Uint8Array(32));
const isValid = Ed25519.validateSeed(seed); // true
```

##### verify()

> **verify**: (`signature`, `message`, `publicKey`) => `boolean`

Verify Ed25519 signature.

Returns false on verification failure instead of throwing.

###### Parameters

###### signature

`Signature`

64-byte Ed25519 signature to verify

###### message

`Uint8Array`\<`ArrayBufferLike`\>

Original message bytes that were signed

###### publicKey

`PublicKey`

32-byte Ed25519 public key

###### Returns

`boolean`

True if signature is cryptographically valid, false otherwise

###### See

https://voltaire.tevm.sh/crypto for crypto documentation

###### Since

0.0.0

###### Throws

If public key length is not 32 bytes

###### Throws

If signature length is not 64 bytes

###### Example

```javascript
import * as Ed25519 from './crypto/Ed25519/index.js';
const valid = Ed25519.verify(signature, message, publicKey);
if (valid) console.log('Signature verified');
```

#### Type Declaration

##### \_wasm

> **\_wasm**: *typeof* [`Ed25519Wasm`](namespaces/Ed25519Wasm.mdx) = `Ed25519Wasm`

***

### EIP712

> `const` **EIP712**: `object` & `object`

Defined in: [src/wasm/index.ts:221](https://github.com/evmts/voltaire/blob/c23bdec42e80cac8af3a4130b0c4c180becd2ad0/src/wasm/index.ts#L221)

EIP712 with WASM acceleration

#### Type Declaration

##### Domain

> **Domain**: `object`

###### Domain.hash()

> **hash**: (`domain`) => [`HashType`](../HashType-2.mdx#hashtype) = `hashDomain`

###### Parameters

###### domain

`Domain`

###### Returns

[`HashType`](../HashType-2.mdx#hashtype)

##### encodeData()

> **encodeData**: (`primaryType`, `data`, `types`) => `Uint8Array`

###### Parameters

###### primaryType

`string`

###### data

`Message`

###### types

`TypeDefinitions`

###### Returns

`Uint8Array`

##### EncodeData()

> **EncodeData**: (`deps`) => (`primaryType`, `data`, `types`) => `Uint8Array`

Factory: Encode struct data according to EIP-712.

###### Parameters

###### deps

Crypto dependencies

###### encodeValue

(`type`, `value`, `types`) => `Uint8Array`

Encode value function

###### hashType

(`primaryType`, `types`) => [`HashType`](../HashType-2.mdx#hashtype)

Hash type function

###### Returns

Function that encodes data

> (`primaryType`, `data`, `types`): `Uint8Array`

###### Parameters

###### primaryType

`string`

###### data

`Message`

###### types

`TypeDefinitions`

###### Returns

`Uint8Array`

###### See

https://voltaire.tevm.sh/crypto for crypto documentation

###### Since

0.0.0

###### Throws

If primaryType is not found in types

###### Throws

If required field is missing from data

###### Example

```javascript
import { EncodeData } from './crypto/EIP712/encodeData.js';
import { HashType } from './hashType.js';
import { EncodeValue } from './encodeValue.js';
import { hash as keccak256 } from '../Keccak256/hash.js';
const hashType = HashType({ keccak256 });
const encodeValue = EncodeValue({ keccak256, hashStruct });
const encodeData = EncodeData({ hashType, encodeValue });
const types = { Person: [{ name: 'name', type: 'string' }, { name: 'wallet', type: 'address' }] };
const encoded = encodeData('Person', { name: 'Alice', wallet: '0x...' }, types);
```

##### encodeType()

> **encodeType**: (`primaryType`, `types`) => `string`

Encode type string for EIP-712 hashing.

Produces type encoding like "Mail(Person from,Person to,string contents)Person(string name,address wallet)"

###### Parameters

###### primaryType

`string`

Primary type name to encode

###### types

`TypeDefinitions`

Type definitions mapping

###### Returns

`string`

Encoded type string with primary type followed by referenced types in alphabetical order

###### See

https://voltaire.tevm.sh/crypto for crypto documentation

###### Since

0.0.0

###### Throws

If primaryType or any referenced type is not found

###### Example

```javascript
import * as EIP712 from './crypto/EIP712/index.js';
const types = { Mail: [{ name: 'from', type: 'Person' }], Person: [{ name: 'name', type: 'string' }] };
const typeString = EIP712.encodeType('Mail', types);
// Returns: "Mail(Person from)Person(string name)"
```

##### encodeValue()

> **encodeValue**: (`type`, `value`, `types`) => `Uint8Array`

###### Parameters

###### type

`string`

###### value

`MessageValue`

###### types

`TypeDefinitions`

###### Returns

`Uint8Array`

##### EncodeValue()

> **EncodeValue**: (`deps`) => (`type`, `value`, `types`) => `Uint8Array`

Factory: Encode single value to 32 bytes according to EIP-712.

Handles primitive types, arrays, strings, bytes, and custom structs.
Addresses must be pre-validated BrandedAddress types.

###### Parameters

###### deps

Crypto dependencies

###### hashStruct

(`type`, `data`, `types`) => [`HashType`](../HashType-2.mdx#hashtype)

Hash struct function

###### keccak256

(`data`) => `Uint8Array`

Keccak256 hash function

###### Returns

Function that encodes value

> (`type`, `value`, `types`): `Uint8Array`

###### Parameters

###### type

`string`

###### value

`MessageValue`

###### types

`TypeDefinitions`

###### Returns

`Uint8Array`

###### See

https://voltaire.tevm.sh/crypto for crypto documentation

###### Since

0.0.0

###### Throws

If type is unsupported or value format is invalid

###### Example

```javascript
import { EncodeValue } from './crypto/EIP712/encodeValue.js';
import { hash as keccak256 } from '../Keccak256/hash.js';
import { HashStruct } from './hashStruct.js';
const hashStruct = HashStruct({ keccak256, encodeData });
const encodeValue = EncodeValue({ keccak256, hashStruct });
const encoded = encodeValue('uint256', 42n, types);
```

##### format()

> **format**: (`typedData`) => `string`

Format typed data for human-readable display.

###### Parameters

###### typedData

`TypedData`

Typed data to format

###### Returns

`string`

Human-readable multi-line string representation

###### See

https://voltaire.tevm.sh/crypto for crypto documentation

###### Since

0.0.0

###### Throws

###### Example

```javascript
import * as EIP712 from './crypto/EIP712/index.js';
const formatted = EIP712.format(typedData);
console.log(formatted);
```

##### HashDomain()

> **HashDomain**: (`deps`) => (`domain`) => [`HashType`](../HashType-2.mdx#hashtype)

Factory: Hash EIP-712 domain separator.

Only includes fields that are defined in the domain object.

###### Parameters

###### deps

Crypto dependencies

###### hashStruct

(`primaryType`, `data`, `types`) => [`HashType`](../HashType-2.mdx#hashtype)

Hash struct function

###### Returns

Function that hashes domain

> (`domain`): [`HashType`](../HashType-2.mdx#hashtype)

###### Parameters

###### domain

`Domain`

###### Returns

[`HashType`](../HashType-2.mdx#hashtype)

###### See

https://voltaire.tevm.sh/crypto for crypto documentation

###### Since

0.0.0

###### Throws

If domain type encoding fails

###### Example

```javascript
import { Hash as HashDomain } from './crypto/EIP712/Domain/hash.js';
import { HashStruct } from '../hashStruct.js';
import { hash as keccak256 } from '../../Keccak256/hash.js';
const hashStruct = HashStruct({ keccak256, encodeData });
const hashDomain = HashDomain({ hashStruct });
const domain = { name: 'MyApp', version: '1', chainId: 1n };
const domainHash = hashDomain(domain);
```

##### hashStruct()

> **hashStruct**: (`primaryType`, `data`, `types`) => [`HashType`](../HashType-2.mdx#hashtype)

###### Parameters

###### primaryType

`string`

###### data

`Message`

###### types

`TypeDefinitions`

###### Returns

[`HashType`](../HashType-2.mdx#hashtype)

##### HashStruct()

> **HashStruct**: (`deps`) => (`primaryType`, `data`, `types`) => [`HashType`](../HashType-2.mdx#hashtype)

Factory: Hash struct according to EIP-712 specification.

Computes keccak256 of the encoded struct data.

###### Parameters

###### deps

Crypto dependencies

###### encodeData

(`primaryType`, `data`, `types`) => `Uint8Array`

Encode data function

###### keccak256

(`data`) => `Uint8Array`

Keccak256 hash function

###### Returns

Function that hashes struct

> (`primaryType`, `data`, `types`): [`HashType`](../HashType-2.mdx#hashtype)

###### Parameters

###### primaryType

`string`

###### data

`Message`

###### types

`TypeDefinitions`

###### Returns

[`HashType`](../HashType-2.mdx#hashtype)

###### See

https://voltaire.tevm.sh/crypto for crypto documentation

###### Since

0.0.0

###### Throws

If type is not found

###### Throws

If message data is invalid

###### Example

```javascript
import { HashStruct } from './crypto/EIP712/hashStruct.js';
import { hash as keccak256 } from '../Keccak256/hash.js';
import { EncodeData } from './encodeData.js';
const encodeData = EncodeData({ hashType, encodeValue });
const hashStruct = HashStruct({ keccak256, encodeData });
const types = { Person: [{ name: 'name', type: 'string' }] };
const hash = hashStruct('Person', { name: 'Alice' }, types);
```

##### hashType()

> **hashType**: (`primaryType`, `types`) => [`HashType`](../HashType-2.mdx#hashtype)

###### Parameters

###### primaryType

`string`

###### types

`TypeDefinitions`

###### Returns

[`HashType`](../HashType-2.mdx#hashtype)

##### HashType()

> **HashType**: (`deps`) => (`primaryType`, `types`) => [`HashType`](../HashType-2.mdx#hashtype)

Factory: Hash type string according to EIP-712.

Computes keccak256 of the encoded type string.

###### Parameters

###### deps

Crypto dependencies

###### keccak256

(`data`) => `Uint8Array`

Keccak256 hash function

###### Returns

Function that hashes type string

> (`primaryType`, `types`): [`HashType`](../HashType-2.mdx#hashtype)

###### Parameters

###### primaryType

`string`

###### types

`TypeDefinitions`

###### Returns

[`HashType`](../HashType-2.mdx#hashtype)

###### See

https://voltaire.tevm.sh/crypto for crypto documentation

###### Since

0.0.0

###### Throws

If type is not found

###### Example

```javascript
import { HashType } from './crypto/EIP712/hashType.js';
import { hash as keccak256 } from '../Keccak256/hash.js';
const hashType = HashType({ keccak256 });
const types = { Mail: [{ name: 'contents', type: 'string' }] };
const typeHash = hashType('Mail', types);
```

##### hashTypedData()

> **hashTypedData**: (`typedData`) => [`HashType`](../HashType-2.mdx#hashtype)

###### Parameters

###### typedData

`TypedData`

###### Returns

[`HashType`](../HashType-2.mdx#hashtype)

##### HashTypedData()

> **HashTypedData**: (`deps`) => (`typedData`) => [`HashType`](../HashType-2.mdx#hashtype)

Factory: Hash typed data according to EIP-712 specification.

Computes: keccak256("\x19\x01" ‖ domainSeparator ‖ hashStruct(message))

###### Parameters

###### deps

Crypto dependencies

###### hashDomain

(`domain`) => [`HashType`](../HashType-2.mdx#hashtype)

Hash domain function

###### hashStruct

(`primaryType`, `data`, `types`) => [`HashType`](../HashType-2.mdx#hashtype)

Hash struct function

###### keccak256

(`data`) => `Uint8Array`

Keccak256 hash function

###### Returns

Function that hashes typed data

> (`typedData`): [`HashType`](../HashType-2.mdx#hashtype)

###### Parameters

###### typedData

`TypedData`

###### Returns

[`HashType`](../HashType-2.mdx#hashtype)

###### See

https://voltaire.tevm.sh/crypto for crypto documentation

###### Since

0.0.0

###### Throws

If types are not found

###### Throws

If message data is invalid

###### Example

```javascript
import { HashTypedData } from './crypto/EIP712/hashTypedData.js';
import { hash as keccak256 } from '../Keccak256/hash.js';
import { Hash as HashDomain } from './Domain/hash.js';
import { HashStruct } from './hashStruct.js';
const hashDomain = HashDomain({ hashStruct });
const hashStruct = HashStruct({ keccak256, encodeData });
const hashTypedData = HashTypedData({ keccak256, hashDomain, hashStruct });
const hash = hashTypedData(typedData);
```

##### recoverAddress()

> **recoverAddress**: (`signature`, `typedData`) => [`AddressType`](../../../primitives/Address.mdx#addresstype)

###### Parameters

###### signature

`Signature`

###### typedData

`TypedData`

###### Returns

[`AddressType`](../../../primitives/Address.mdx#addresstype)

##### RecoverAddress()

> **RecoverAddress**: (`deps`) => (`signature`, `typedData`) => [`AddressType`](../../../primitives/Address.mdx#addresstype)

Factory: Recover Ethereum address from EIP-712 typed data signature.

Uses ECDSA public key recovery to determine the signer's address.

###### Parameters

###### deps

Crypto dependencies

###### hashTypedData

(`typedData`) => [`HashType`](../HashType-2.mdx#hashtype)

Hash typed data function

###### keccak256

(`data`) => `Uint8Array`

Keccak256 hash function

###### recoverPublicKey

(`signature`, `hash`, `recoveryBit`) => `Uint8Array`

Secp256k1 public key recovery function

###### Returns

Function that recovers address

> (`signature`, `typedData`): [`AddressType`](../../../primitives/Address.mdx#addresstype)

###### Parameters

###### signature

`Signature`

###### typedData

`TypedData`

###### Returns

[`AddressType`](../../../primitives/Address.mdx#addresstype)

###### See

https://voltaire.tevm.sh/crypto for crypto documentation

###### Since

0.0.0

###### Throws

If signature recovery fails or public key format is invalid

###### Example

```javascript
import { RecoverAddress } from './crypto/EIP712/recoverAddress.js';
import { hash as keccak256 } from '../Keccak256/hash.js';
import { recoverPublicKey } from '../Secp256k1/recoverPublicKey.js';
import { HashTypedData } from './hashTypedData.js';
const hashTypedData = HashTypedData({ keccak256, hashDomain, hashStruct });
const recoverAddress = RecoverAddress({ keccak256, recoverPublicKey, hashTypedData });
const address = recoverAddress(signature, typedData);
```

##### signTypedData()

> **signTypedData**: (`typedData`, `privateKey`) => `Signature`

###### Parameters

###### typedData

`any`

###### privateKey

`any`

###### Returns

`Signature`

##### SignTypedData()

> **SignTypedData**: (`deps`) => (`typedData`, `privateKey`) => `Signature`

Factory: Sign EIP-712 typed data with ECDSA private key.

Produces a signature that can be verified against the signer's address.

###### Parameters

###### deps

Crypto dependencies

###### hashTypedData

(`typedData`) => [`HashType`](../HashType-2.mdx#hashtype)

Hash typed data function

###### sign

(`hash`, `privateKey`) => `Signature`

Secp256k1 sign function

###### Returns

Function that signs typed data

> (`typedData`, `privateKey`): `Signature`

###### Parameters

###### typedData

`TypedData`

###### privateKey

`Uint8Array`

###### Returns

`Signature`

###### See

https://voltaire.tevm.sh/crypto for crypto documentation

###### Since

0.0.0

###### Throws

If private key length is invalid or signing fails

###### Example

```javascript
import { SignTypedData } from './crypto/EIP712/signTypedData.js';
import { HashTypedData } from './hashTypedData.js';
import { sign } from '../Secp256k1/sign.js';
import { hash as keccak256 } from '../Keccak256/hash.js';
const hashTypedData = HashTypedData({ keccak256, hashDomain, hashStruct });
const signTypedData = SignTypedData({ hashTypedData, sign });
const privateKey = new Uint8Array(32);
const signature = signTypedData(typedData, privateKey);
```

##### validate()

> **validate**: (`typedData`) => `void`

Validate typed data structure against EIP-712 specification.

Checks domain, types, primaryType, and message structure.

###### Parameters

###### typedData

`TypedData`

Typed data to validate

###### Returns

`void`

###### See

https://voltaire.tevm.sh/crypto for crypto documentation

###### Since

0.0.0

###### Throws

If structure is invalid or missing required fields

###### Example

```javascript
import * as EIP712 from './crypto/EIP712/index.js';
EIP712.validate(typedData); // Throws if invalid
```

##### verifyTypedData()

> **verifyTypedData**: (`signature`, `typedData`, `address`) => `boolean`

###### Parameters

###### signature

`Signature`

###### typedData

`TypedData`

###### address

[`AddressType`](../../../primitives/Address.mdx#addresstype)

###### Returns

`boolean`

##### VerifyTypedData()

> **VerifyTypedData**: (`deps`) => (`signature`, `typedData`, `address`) => `boolean`

Factory: Verify EIP-712 typed data signature against expected signer address.

Uses constant-time comparison to prevent timing attacks.

###### Parameters

###### deps

Crypto dependencies

###### recoverAddress

(`signature`, `typedData`) => [`AddressType`](../../../primitives/Address.mdx#addresstype)

Recover address function

###### Returns

Function that verifies signature

> (`signature`, `typedData`, `address`): `boolean`

###### Parameters

###### signature

`Signature`

###### typedData

`TypedData`

###### address

[`AddressType`](../../../primitives/Address.mdx#addresstype)

###### Returns

`boolean`

###### See

https://voltaire.tevm.sh/crypto for crypto documentation

###### Since

0.0.0

###### Throws

###### Example

```javascript
import { VerifyTypedData } from './crypto/EIP712/verifyTypedData.js';
import { RecoverAddress } from './recoverAddress.js';
import { hash as keccak256 } from '../Keccak256/hash.js';
import { recoverPublicKey } from '../Secp256k1/recoverPublicKey.js';
const recoverAddress = RecoverAddress({ keccak256, recoverPublicKey, hashTypedData });
const verifyTypedData = VerifyTypedData({ recoverAddress });
const valid = verifyTypedData(signature, typedData, signerAddress);
```

#### Type Declaration

##### \_wasm

> **\_wasm**: *typeof* [`Eip712Wasm`](namespaces/Eip712Wasm/index.mdx) = `Eip712Wasm`

***

### Ether

> `const` **Ether**: `EtherConstructor` = `EtherJS`

Defined in: [src/wasm/index.ts:247](https://github.com/evmts/voltaire/blob/c23bdec42e80cac8af3a4130b0c4c180becd2ad0/src/wasm/index.ts#L247)

***

### Gwei

> `const` **Gwei**: `GweiConstructor` = `GweiJS`

Defined in: [src/wasm/index.ts:246](https://github.com/evmts/voltaire/blob/c23bdec42e80cac8af3a4130b0c4c180becd2ad0/src/wasm/index.ts#L246)

***

### Hash

> `const` **Hash**: `HashConstructor` = `HashJS`

Defined in: [src/wasm/index.ts:230](https://github.com/evmts/voltaire/blob/c23bdec42e80cac8af3a4130b0c4c180becd2ad0/src/wasm/index.ts#L230)

***

### Hex

> `const` **Hex**: *typeof* [`Hex`](../../index.mdx#hex) = `HexJS`

Defined in: [src/wasm/index.ts:231](https://github.com/evmts/voltaire/blob/c23bdec42e80cac8af3a4130b0c4c180becd2ad0/src/wasm/index.ts#L231)

***

### Keccak256

> `const` **Keccak256**: (`input`) => [`Keccak256Hash`](../../index.mdx#keccak256hash) & `object` & `object`

Defined in: [src/wasm/index.ts:157](https://github.com/evmts/voltaire/blob/c23bdec42e80cac8af3a4130b0c4c180becd2ad0/src/wasm/index.ts#L157)

Keccak256 with WASM acceleration
Falls back to JS implementation, but WASM methods available via `_wasm`

#### Type Declaration

##### contractAddress()

> **contractAddress**: (`sender`, `nonce`) => `Uint8Array`\<`ArrayBufferLike`\>

Compute contract address from deployer and nonce

Uses CREATE formula: keccak256(rlp([sender, nonce]))[12:]

###### Parameters

###### sender

`Uint8Array`\<`ArrayBufferLike`\>

Deployer address (20 bytes)

###### nonce

`bigint`

Transaction nonce

###### Returns

`Uint8Array`\<`ArrayBufferLike`\>

Contract address (20 bytes)

###### See

https://voltaire.tevm.sh/crypto for crypto documentation

###### Since

0.0.0

###### Throws

If sender is not 20 bytes

###### Example

```javascript
import * as Keccak256 from './crypto/Keccak256/index.js';
const sender = new Uint8Array(20);
const address = Keccak256.contractAddress(sender, 0n);
```

##### create2Address()

> **create2Address**: (`sender`, `salt`, `initCodeHash`) => `Uint8Array`\<`ArrayBufferLike`\>

Compute CREATE2 address

Uses CREATE2 formula: keccak256(0xff ++ sender ++ salt ++ keccak256(init_code))[12:]

###### Parameters

###### sender

`Uint8Array`\<`ArrayBufferLike`\>

Deployer address (20 bytes)

###### salt

`Uint8Array`\<`ArrayBufferLike`\>

32-byte salt

###### initCodeHash

`Uint8Array`\<`ArrayBufferLike`\>

Hash of initialization code

###### Returns

`Uint8Array`\<`ArrayBufferLike`\>

Contract address (20 bytes)

###### See

https://voltaire.tevm.sh/crypto for crypto documentation

###### Since

0.0.0

###### Throws

If sender is not 20 bytes

###### Throws

If salt is not 32 bytes

###### Throws

If initCodeHash is not 32 bytes

###### Example

```javascript
import * as Keccak256 from './crypto/Keccak256/index.js';
const sender = new Uint8Array(20);
const salt = new Uint8Array(32);
const initCodeHash = new Uint8Array(32);
const address = Keccak256.create2Address(sender, salt, initCodeHash);
```

##### DIGEST\_SIZE

> **DIGEST\_SIZE**: `number`

Digest size in bytes (32 bytes = 256 bits)

###### Since

0.0.0

##### from()

> **from**: (`input`) => [`Keccak256Hash`](../../index.mdx#keccak256hash)

Hash input with Keccak-256 (constructor pattern)

Auto-detects input type and hashes accordingly:
- Uint8Array: hash directly
- string starting with 0x: parse as hex
- string: UTF-8 encode then hash

###### Parameters

###### input

Data to hash

`string` | `Uint8Array`\<`ArrayBufferLike`\>

###### Returns

[`Keccak256Hash`](../../index.mdx#keccak256hash)

32-byte hash

###### See

https://voltaire.tevm.sh/crypto/keccak256 for crypto documentation

###### Since

0.0.0

###### Throws

If hex string is invalid

###### Example

```javascript
import { Keccak256Hash } from './crypto/Keccak256/index.js';

const hash1 = Keccak256Hash.from("0x1234");      // Hex
const hash2 = Keccak256Hash.from("hello");       // String
const hash3 = Keccak256Hash.from(uint8array);    // Bytes
```

##### fromHex()

> **fromHex**: (`hex`) => [`Keccak256Hash`](../../index.mdx#keccak256hash) = `hashHex`

Hash hex string with Keccak-256

###### Parameters

###### hex

`string`

Hex string to hash (with or without 0x prefix)

###### Returns

[`Keccak256Hash`](../../index.mdx#keccak256hash)

32-byte hash

###### See

https://voltaire.tevm.sh/crypto for crypto documentation

###### Since

0.0.0

###### Throws

If hex string is invalid or has odd length

###### Example

```javascript
import { Keccak256Hash } from './crypto/Keccak256/index.js';
const hash = Keccak256Hash.fromHex('0x1234abcd');
```

##### fromString()

> **fromString**: (`str`) => [`Keccak256Hash`](../../index.mdx#keccak256hash) = `hashString`

Hash string with Keccak-256

String is UTF-8 encoded before hashing.

###### Parameters

###### str

`string`

String to hash

###### Returns

[`Keccak256Hash`](../../index.mdx#keccak256hash)

32-byte hash

###### See

https://voltaire.tevm.sh/crypto for crypto documentation

###### Since

0.0.0

###### Throws

###### Example

```javascript
import { Keccak256Hash } from './crypto/Keccak256/index.js';
const hash = Keccak256Hash.fromString('hello');
```

##### fromTopic()

> **fromTopic**: (`signature`) => [`Keccak256Hash`](../../index.mdx#keccak256hash) = `topic`

Compute event topic (32-byte Keccak-256 hash)

Used for Ethereum event signatures.

###### Parameters

###### signature

`string`

Event signature string

###### Returns

[`Keccak256Hash`](../../index.mdx#keccak256hash)

32-byte topic

###### See

https://voltaire.tevm.sh/crypto for crypto documentation

###### Since

0.0.0

###### Throws

###### Example

```javascript
import { Keccak256Hash } from './crypto/Keccak256/index.js';
const topic = Keccak256Hash.fromTopic('Transfer(address,address,uint256)');
```

##### hash()

> **hash**: (`data`) => [`Keccak256Hash`](../../index.mdx#keccak256hash)

Hash data with Keccak-256

###### Parameters

###### data

`Uint8Array`\<`ArrayBufferLike`\>

Data to hash

###### Returns

[`Keccak256Hash`](../../index.mdx#keccak256hash)

32-byte hash

###### See

https://voltaire.tevm.sh/crypto for crypto documentation

###### Since

0.0.0

###### Throws

###### Example

```javascript
import { Keccak256Hash } from './crypto/Keccak256/index.js';
const hash = Keccak256Hash.from(data);
```

##### hashHex()

> **hashHex**: (`hex`) => [`Keccak256Hash`](../../index.mdx#keccak256hash)

Hash hex string with Keccak-256

###### Parameters

###### hex

`string`

Hex string to hash (with or without 0x prefix)

###### Returns

[`Keccak256Hash`](../../index.mdx#keccak256hash)

32-byte hash

###### See

https://voltaire.tevm.sh/crypto for crypto documentation

###### Since

0.0.0

###### Throws

If hex string is invalid or has odd length

###### Example

```javascript
import { Keccak256Hash } from './crypto/Keccak256/index.js';
const hash = Keccak256Hash.fromHex('0x1234abcd');
```

##### hashMultiple()

> **hashMultiple**: (`chunks`) => [`Keccak256Hash`](../../index.mdx#keccak256hash)

Hash multiple data chunks in sequence

Equivalent to hashing the concatenation of all chunks.

###### Parameters

###### chunks

readonly `Uint8Array`\<`ArrayBufferLike`\>[]

Array of data chunks to hash

###### Returns

[`Keccak256Hash`](../../index.mdx#keccak256hash)

32-byte hash

###### See

https://voltaire.tevm.sh/crypto for crypto documentation

###### Since

0.0.0

###### Throws

###### Example

```javascript
import { Keccak256Hash } from './crypto/Keccak256/index.js';
const hash = Keccak256Hash.from(combined);
```

##### hashString()

> **hashString**: (`str`) => [`Keccak256Hash`](../../index.mdx#keccak256hash)

Hash string with Keccak-256

String is UTF-8 encoded before hashing.

###### Parameters

###### str

`string`

String to hash

###### Returns

[`Keccak256Hash`](../../index.mdx#keccak256hash)

32-byte hash

###### See

https://voltaire.tevm.sh/crypto for crypto documentation

###### Since

0.0.0

###### Throws

###### Example

```javascript
import { Keccak256Hash } from './crypto/Keccak256/index.js';
const hash = Keccak256Hash.fromString('hello');
```

##### RATE

> **RATE**: `number`

Rate in bytes for Keccak256 (136 bytes = 1088 bits)

###### Since

0.0.0

##### selector()

> **selector**: (`signature`) => `Uint8Array`\<`ArrayBufferLike`\>

Compute function selector (first 4 bytes of Keccak-256 hash)

Used for Ethereum function signatures.

###### Parameters

###### signature

`string`

Function signature string

###### Returns

`Uint8Array`\<`ArrayBufferLike`\>

4-byte selector

###### See

https://voltaire.tevm.sh/crypto for crypto documentation

###### Since

0.0.0

###### Throws

###### Example

```javascript
import * as Keccak256 from './crypto/Keccak256/index.js';
const selector = Keccak256.selector('transfer(address,uint256)');
// Uint8Array(4) [0xa9, 0x05, 0x9c, 0xbb]
```

##### STATE\_SIZE

> **STATE\_SIZE**: `number`

State size (25 u64 words = 1600 bits)

###### Since

0.0.0

##### topic()

> **topic**: (`signature`) => [`Keccak256Hash`](../../index.mdx#keccak256hash)

Compute event topic (32-byte Keccak-256 hash)

Used for Ethereum event signatures.

###### Parameters

###### signature

`string`

Event signature string

###### Returns

[`Keccak256Hash`](../../index.mdx#keccak256hash)

32-byte topic

###### See

https://voltaire.tevm.sh/crypto for crypto documentation

###### Since

0.0.0

###### Throws

###### Example

```javascript
import { Keccak256Hash } from './crypto/Keccak256/index.js';
const topic = Keccak256Hash.fromTopic('Transfer(address,address,uint256)');
```

#### Type Declaration

##### \_wasm

> **\_wasm**: `object` = `Keccak256Wasm`

###### \_wasm.contractAddress()

> **contractAddress**: (`sender`, `nonce`) => `Uint8Array`

Compute CREATE contract address

###### Parameters

###### sender

`Uint8Array`

Sender address (20 bytes)

###### nonce

`bigint`

Transaction nonce

###### Returns

`Uint8Array`

Contract address (20 bytes)

###### \_wasm.create2Address()

> **create2Address**: (`sender`, `salt`, `initCodeHash`) => `Uint8Array`

Compute CREATE2 contract address

###### Parameters

###### sender

`Uint8Array`

Sender address (20 bytes)

###### salt

`Uint8Array`

Salt (32 bytes)

###### initCodeHash

`Uint8Array`

Init code hash (32 bytes)

###### Returns

`Uint8Array`

Contract address (20 bytes)

###### \_wasm.DIGEST\_SIZE

> **DIGEST\_SIZE**: `number` = `32`

###### \_wasm.hash()

> **hash**: (`data`) => [`HashType`](../HashType-2.mdx#hashtype)

Hash bytes using Keccak256

###### Parameters

###### data

`Uint8Array`

Input bytes to hash

###### Returns

[`HashType`](../HashType-2.mdx#hashtype)

32-byte Keccak256 hash

###### \_wasm.hashHex()

> **hashHex**: (`hex`) => [`HashType`](../HashType-2.mdx#hashtype)

Hash a hex string

###### Parameters

###### hex

`string`

Hex string to hash (with or without 0x prefix)

###### Returns

[`HashType`](../HashType-2.mdx#hashtype)

32-byte Keccak256 hash

###### \_wasm.hashMultiple()

> **hashMultiple**: (`chunks`) => [`HashType`](../HashType-2.mdx#hashtype)

Hash multiple byte arrays in sequence

###### Parameters

###### chunks

`Uint8Array`\<`ArrayBufferLike`\>[]

Array of byte arrays to hash

###### Returns

[`HashType`](../HashType-2.mdx#hashtype)

32-byte Keccak256 hash

###### \_wasm.hashString()

> **hashString**: (`str`) => [`HashType`](../HashType-2.mdx#hashtype)

Hash a UTF-8 string

###### Parameters

###### str

`string`

String to hash

###### Returns

[`HashType`](../HashType-2.mdx#hashtype)

32-byte Keccak256 hash

###### \_wasm.init()

> **init**: () => `Promise`\<`void`\>

Initialize WASM module (must be called before using any functions)

###### Returns

`Promise`\<`void`\>

###### \_wasm.isReady()

> **isReady**: () => `boolean`

Check if WASM is initialized

###### Returns

`boolean`

###### \_wasm.RATE

> **RATE**: `number` = `136`

###### \_wasm.selector()

> **selector**: (`signature`) => `Uint8Array`

Compute function selector (first 4 bytes of hash)

###### Parameters

###### signature

`string`

Function signature string (e.g., "transfer(address,uint256)")

###### Returns

`Uint8Array`

4-byte function selector

###### \_wasm.STATE\_SIZE

> **STATE\_SIZE**: `number` = `25`

###### \_wasm.topic()

> **topic**: (`signature`) => [`HashType`](../HashType-2.mdx#hashtype)

Compute event topic (full 32-byte hash)

###### Parameters

###### signature

`string`

Event signature string (e.g., "Transfer(address,address,uint256)")

###### Returns

[`HashType`](../HashType-2.mdx#hashtype)

32-byte event topic as HashType

***

### Keccak256Wasm

> `const` **Keccak256Wasm**: `object`

Defined in: [src/crypto/keccak256.wasm.ts:238](https://github.com/evmts/voltaire/blob/c23bdec42e80cac8af3a4130b0c4c180becd2ad0/src/crypto/keccak256.wasm.ts#L238)

#### Type Declaration

##### contractAddress()

> **contractAddress**: (`sender`, `nonce`) => `Uint8Array`

Compute CREATE contract address

###### Parameters

###### sender

`Uint8Array`

Sender address (20 bytes)

###### nonce

`bigint`

Transaction nonce

###### Returns

`Uint8Array`

Contract address (20 bytes)

##### create2Address()

> **create2Address**: (`sender`, `salt`, `initCodeHash`) => `Uint8Array`

Compute CREATE2 contract address

###### Parameters

###### sender

`Uint8Array`

Sender address (20 bytes)

###### salt

`Uint8Array`

Salt (32 bytes)

###### initCodeHash

`Uint8Array`

Init code hash (32 bytes)

###### Returns

`Uint8Array`

Contract address (20 bytes)

##### DIGEST\_SIZE

> **DIGEST\_SIZE**: `number` = `32`

##### hash()

> **hash**: (`data`) => [`HashType`](../HashType-2.mdx#hashtype)

Hash bytes using Keccak256

###### Parameters

###### data

`Uint8Array`

Input bytes to hash

###### Returns

[`HashType`](../HashType-2.mdx#hashtype)

32-byte Keccak256 hash

##### hashHex()

> **hashHex**: (`hex`) => [`HashType`](../HashType-2.mdx#hashtype)

Hash a hex string

###### Parameters

###### hex

`string`

Hex string to hash (with or without 0x prefix)

###### Returns

[`HashType`](../HashType-2.mdx#hashtype)

32-byte Keccak256 hash

##### hashMultiple()

> **hashMultiple**: (`chunks`) => [`HashType`](../HashType-2.mdx#hashtype)

Hash multiple byte arrays in sequence

###### Parameters

###### chunks

`Uint8Array`\<`ArrayBufferLike`\>[]

Array of byte arrays to hash

###### Returns

[`HashType`](../HashType-2.mdx#hashtype)

32-byte Keccak256 hash

##### hashString()

> **hashString**: (`str`) => [`HashType`](../HashType-2.mdx#hashtype)

Hash a UTF-8 string

###### Parameters

###### str

`string`

String to hash

###### Returns

[`HashType`](../HashType-2.mdx#hashtype)

32-byte Keccak256 hash

##### init()

> **init**: () => `Promise`\<`void`\>

Initialize WASM module (must be called before using any functions)

###### Returns

`Promise`\<`void`\>

##### isReady()

> **isReady**: () => `boolean`

Check if WASM is initialized

###### Returns

`boolean`

##### RATE

> **RATE**: `number` = `136`

##### selector()

> **selector**: (`signature`) => `Uint8Array`

Compute function selector (first 4 bytes of hash)

###### Parameters

###### signature

`string`

Function signature string (e.g., "transfer(address,uint256)")

###### Returns

`Uint8Array`

4-byte function selector

##### STATE\_SIZE

> **STATE\_SIZE**: `number` = `25`

##### topic()

> **topic**: (`signature`) => [`HashType`](../HashType-2.mdx#hashtype)

Compute event topic (full 32-byte hash)

###### Parameters

###### signature

`string`

Event signature string (e.g., "Transfer(address,address,uint256)")

###### Returns

[`HashType`](../HashType-2.mdx#hashtype)

32-byte event topic as HashType

***

### KZG

> `const` **KZG**: *typeof* [`KZG`](../../index.mdx#kzg) = `KZGJS`

Defined in: [src/wasm/index.ts:254](https://github.com/evmts/voltaire/blob/c23bdec42e80cac8af3a4130b0c4c180becd2ad0/src/wasm/index.ts#L254)

***

### ModExp

> `const` **ModExp**: (`base`, `exp`, `modulus`) => `bigint` & `object` = `ModExpJS`

Defined in: [src/wasm/index.ts:255](https://github.com/evmts/voltaire/blob/c23bdec42e80cac8af3a4130b0c4c180becd2ad0/src/wasm/index.ts#L255)

#### Type Declaration

##### calculateGas()

> **calculateGas**: (`baseLen`, `expLen`, `modLen`, `expHead`) => `bigint`

Calculate gas cost for MODEXP operation per EIP-2565

Gas formula: max(200, floor(mult_complexity * iteration_count / 3))

###### Parameters

###### baseLen

`bigint`

Length of base in bytes

###### expLen

`bigint`

Length of exponent in bytes

###### modLen

`bigint`

Length of modulus in bytes

###### expHead

`bigint`

First 32 bytes of exponent as BigInt (for leading zeros calc)

###### Returns

`bigint`

Gas cost

###### See

https://eips.ethereum.org/EIPS/eip-2565

###### Since

0.0.0

###### Example

```javascript
import { ModExp } from './crypto/ModExp/index.js';

// Calculate gas for 2^3 mod 5
const gas = ModExp.calculateGas(1n, 1n, 1n, 3n);
console.log(gas); // 200n (minimum)
```

##### modexp()

> **modexp**: (`base`, `exp`, `modulus`) => `bigint`

Modular exponentiation: base^exp mod modulus

Computes arbitrary-precision modular exponentiation using native BigInt.
Used by MODEXP precompile (0x05) per EIP-198.

WARNING: This implementation is for general use. For cryptographic
applications, consider timing attack resistance.

###### Parameters

###### base

`bigint`

Base value

###### exp

`bigint`

Exponent value

###### modulus

`bigint`

Modulus value (must be > 0)

###### Returns

`bigint`

Result of base^exp mod modulus

###### See

https://eips.ethereum.org/EIPS/eip-198

###### Since

0.0.0

###### Throws

If modulus is zero

###### Example

```javascript
import { ModExp } from './crypto/ModExp/index.js';

// Compute 2^10 mod 1000 = 24
const result = ModExp.modexp(2n, 10n, 1000n);
console.log(result); // 24n

// RSA verification: signature^e mod n
const verified = ModExp.modexp(signature, e, n);
```

##### modexpBytes()

> **modexpBytes**: (`baseBytes`, `expBytes`, `modBytes`) => `Uint8Array`\<`ArrayBufferLike`\>

Modular exponentiation with byte array inputs/outputs

Computes base^exp mod modulus where inputs are big-endian byte arrays.
Output is padded to modulus length per EIP-198 spec.

###### Parameters

###### baseBytes

`Uint8Array`\<`ArrayBufferLike`\>

Base as big-endian bytes

###### expBytes

`Uint8Array`\<`ArrayBufferLike`\>

Exponent as big-endian bytes

###### modBytes

`Uint8Array`\<`ArrayBufferLike`\>

Modulus as big-endian bytes

###### Returns

`Uint8Array`\<`ArrayBufferLike`\>

Result as big-endian bytes, padded to modulus length

###### See

https://eips.ethereum.org/EIPS/eip-198

###### Since

0.0.0

###### Throws

If modulus is zero

###### Example

```javascript
import { ModExp } from './crypto/ModExp/index.js';

const base = new Uint8Array([0x02]); // 2
const exp = new Uint8Array([0x03]);  // 3
const mod = new Uint8Array([0x05]);  // 5

const result = ModExp.modexpBytes(base, exp, mod);
console.log(result); // Uint8Array([0x03]) = 3
```

***

### Opcode

> `const` **Opcode**: *typeof* [`Opcode`](../../index.mdx#opcode) = `OpcodeJS`

Defined in: [src/wasm/index.ts:239](https://github.com/evmts/voltaire/blob/c23bdec42e80cac8af3a4130b0c4c180becd2ad0/src/wasm/index.ts#L239)

***

### P256

> `const` **P256**: `P256Constructor` & `object`

Defined in: [src/wasm/index.ts:200](https://github.com/evmts/voltaire/blob/c23bdec42e80cac8af3a4130b0c4c180becd2ad0/src/wasm/index.ts#L200)

P256 with WASM acceleration

#### Type Declaration

##### \_wasm

> **\_wasm**: *typeof* [`P256Wasm`](namespaces/P256Wasm.mdx) = `P256Wasm`

***

### Ripemd160

> `const` **Ripemd160**: (`input`) => [`Ripemd160Hash`](../../index.mdx#ripemd160hash) & `object` & `object`

Defined in: [src/wasm/index.ts:179](https://github.com/evmts/voltaire/blob/c23bdec42e80cac8af3a4130b0c4c180becd2ad0/src/wasm/index.ts#L179)

Ripemd160 with WASM acceleration

#### Type Declaration

##### from()

> **from**: (`input`) => [`Ripemd160Hash`](../../index.mdx#ripemd160hash)

Hash input with RIPEMD160 (constructor pattern)

Auto-detects input type and hashes accordingly:
- Uint8Array: hash directly
- string: UTF-8 encode then hash

###### Parameters

###### input

Data to hash

`string` | `Uint8Array`\<`ArrayBufferLike`\>

###### Returns

[`Ripemd160Hash`](../../index.mdx#ripemd160hash)

20-byte hash

###### See

https://voltaire.tevm.sh/crypto/ripemd160 for crypto documentation

###### Since

0.0.0

###### Throws

###### Example

```javascript
import { Ripemd160Hash } from './crypto/Ripemd160/index.js';

const hash1 = Ripemd160Hash.from("hello");           // String
const hash2 = Ripemd160Hash.from(uint8array);        // Bytes
```

##### fromHex()

> **fromHex**: (`hex`) => [`Ripemd160Hash`](../../index.mdx#ripemd160hash) = `hashHex`

Compute RIPEMD160 hash of hex string (without 0x prefix)

###### Parameters

###### hex

`string`

Hex string (with or without 0x prefix)

###### Returns

[`Ripemd160Hash`](../../index.mdx#ripemd160hash)

20-byte hash

###### See

https://voltaire.tevm.sh/crypto for crypto documentation

###### Since

0.0.0

###### Throws

###### Example

```javascript
import { Ripemd160 } from './crypto/Ripemd160/index.js';
const hash = Ripemd160.hashHex("0xdeadbeef");
console.log(hash.length); // 20
```

##### fromString()

> **fromString**: (`str`) => [`Ripemd160Hash`](../../index.mdx#ripemd160hash) = `hashString`

Compute RIPEMD160 hash of UTF-8 string

###### Parameters

###### str

`string`

Input string

###### Returns

[`Ripemd160Hash`](../../index.mdx#ripemd160hash)

20-byte hash

###### See

https://voltaire.tevm.sh/crypto for crypto documentation

###### Since

0.0.0

###### Throws

###### Example

```javascript
import { Ripemd160 } from './crypto/Ripemd160/index.js';
const hash = Ripemd160.hashString("hello");
console.log(hash.length); // 20
```

##### hash()

> **hash**: (`data`) => [`Ripemd160Hash`](../../index.mdx#ripemd160hash)

Compute RIPEMD160 hash (20 bytes)

###### Parameters

###### data

Input data (Uint8Array or string)

`string` | `Uint8Array`\<`ArrayBufferLike`\>

###### Returns

[`Ripemd160Hash`](../../index.mdx#ripemd160hash)

20-byte hash

###### See

https://voltaire.tevm.sh/crypto for crypto documentation

###### Since

0.0.0

###### Throws

###### Example

```javascript
import { Ripemd160 } from './crypto/Ripemd160/index.js';
const hash = Ripemd160.hash(new Uint8Array([1, 2, 3]));
console.log(hash.length); // 20
```

##### hashHex()

> **hashHex**: (`hex`) => [`Ripemd160Hash`](../../index.mdx#ripemd160hash)

Compute RIPEMD160 hash of hex string (without 0x prefix)

###### Parameters

###### hex

`string`

Hex string (with or without 0x prefix)

###### Returns

[`Ripemd160Hash`](../../index.mdx#ripemd160hash)

20-byte hash

###### See

https://voltaire.tevm.sh/crypto for crypto documentation

###### Since

0.0.0

###### Throws

###### Example

```javascript
import { Ripemd160 } from './crypto/Ripemd160/index.js';
const hash = Ripemd160.hashHex("0xdeadbeef");
console.log(hash.length); // 20
```

##### hashString()

> **hashString**: (`str`) => [`Ripemd160Hash`](../../index.mdx#ripemd160hash)

Compute RIPEMD160 hash of UTF-8 string

###### Parameters

###### str

`string`

Input string

###### Returns

[`Ripemd160Hash`](../../index.mdx#ripemd160hash)

20-byte hash

###### See

https://voltaire.tevm.sh/crypto for crypto documentation

###### Since

0.0.0

###### Throws

###### Example

```javascript
import { Ripemd160 } from './crypto/Ripemd160/index.js';
const hash = Ripemd160.hashString("hello");
console.log(hash.length); // 20
```

##### HEX\_SIZE

> **HEX\_SIZE**: `number`

Size of RIPEMD160 hash in hex characters (without 0x prefix)

###### See

https://voltaire.tevm.sh/crypto for crypto documentation

###### Since

0.0.0

###### Throws

###### Example

```javascript
import { HEX_SIZE } from './crypto/Ripemd160/index.js';
console.log(HEX_SIZE); // 40
```

##### SIZE

> **SIZE**: `number`

Size of RIPEMD160 hash in bytes (160 bits)

###### See

https://voltaire.tevm.sh/crypto for crypto documentation

###### Since

0.0.0

###### Throws

###### Example

```javascript
import { SIZE } from './crypto/Ripemd160/index.js';
console.log(SIZE); // 20
```

#### Type Declaration

##### \_wasm

> **\_wasm**: *typeof* [`Ripemd160Wasm`](namespaces/Ripemd160Wasm.mdx) = `Ripemd160Wasm`

***

### Rlp

> `const` **Rlp**: *typeof* [`Rlp`](../../index.mdx#rlp) = `RlpJS`

Defined in: [src/wasm/index.ts:233](https://github.com/evmts/voltaire/blob/c23bdec42e80cac8af3a4130b0c4c180becd2ad0/src/wasm/index.ts#L233)

***

### Secp256k1

> `const` **Secp256k1**: `object` & `object`

Defined in: [src/wasm/index.ts:186](https://github.com/evmts/voltaire/blob/c23bdec42e80cac8af3a4130b0c4c180becd2ad0/src/wasm/index.ts#L186)

Secp256k1 with WASM acceleration

#### Type Declaration

##### addPoints()

> **addPoints**: (`pubKey1`, `pubKey2`) => `Secp256k1PublicKeyType`

Add two secp256k1 public key points

Performs elliptic curve point addition: P1 + P2.
Used in ERC-5564 stealth address generation.

###### Parameters

###### pubKey1

`Secp256k1PublicKeyType`

First 64-byte uncompressed public key

###### pubKey2

`Secp256k1PublicKeyType`

Second 64-byte uncompressed public key

###### Returns

`Secp256k1PublicKeyType`

Result 64-byte uncompressed public key

###### See

 - https://voltaire.tevm.sh/crypto for crypto documentation
 - https://eips.ethereum.org/EIPS/eip-5564 for ERC-5564 stealth addresses

###### Since

0.0.0

###### Throws

If either public key is invalid

###### Throws

If point addition fails

###### Example

```javascript
import * as Secp256k1 from './crypto/Secp256k1/index.js';
const pubKey1 = Secp256k1.derivePublicKey(privateKey1);
const pubKey2 = Secp256k1.derivePublicKey(privateKey2);
const sum = Secp256k1.addPoints(pubKey1, pubKey2);
console.log(sum.length); // 64
```

##### createKeyPair()

> **createKeyPair**: () => `object`

Generate a new secp256k1 key pair

###### Returns

`object`

Key pair with 32-byte private key and 65-byte uncompressed public key

###### privateKey

> **privateKey**: `Uint8Array`

###### publicKey

> **publicKey**: `Uint8Array`

###### Example

```javascript
import { Secp256k1 } from './crypto/Secp256k1/index.js';
const { privateKey, publicKey } = Secp256k1.createKeyPair();
```

##### CURVE\_ORDER

> **CURVE\_ORDER**: `bigint`

secp256k1 curve order (number of points on the curve)

###### See

https://voltaire.tevm.sh/crypto for crypto documentation

###### Since

0.0.0

###### Throws

###### Example

```javascript
import { CURVE_ORDER } from './crypto/Secp256k1/index.js';
console.log(CURVE_ORDER); // 0xffffffffffff...
```

##### derivePublicKey()

> **derivePublicKey**: (`privateKey`) => `Secp256k1PublicKeyType`

Derive public key from private key

Computes the public key point from a private key using scalar
multiplication on the secp256k1 curve.

###### Parameters

###### privateKey

`PrivateKeyType`

32-byte private key

###### Returns

`Secp256k1PublicKeyType`

64-byte uncompressed public key

###### See

https://voltaire.tevm.sh/crypto for crypto documentation

###### Since

0.0.0

###### Throws

If private key is invalid

###### Example

```javascript
import * as Secp256k1 from './crypto/Secp256k1/index.js';
import * as PrivateKey from './primitives/PrivateKey/index.js';
const privateKey = PrivateKey.from(new Uint8Array(32));
const publicKey = Secp256k1.derivePublicKey(privateKey);
console.log(publicKey.length); // 64
```

##### ecdh()

> **ecdh**: (`privateKey`, `publicKey`) => `Uint8Array`\<`ArrayBufferLike`\>

Perform ECDH key exchange

Computes shared secret from your private key and their public key.
Returns the x-coordinate of the shared point (32 bytes).

###### Parameters

###### privateKey

`PrivateKeyType`

Your 32-byte private key

###### publicKey

`Secp256k1PublicKeyType`

Their 64-byte uncompressed public key

###### Returns

`Uint8Array`\<`ArrayBufferLike`\>

32-byte shared secret (x-coordinate)

###### See

 - https://voltaire.tevm.sh/crypto for crypto documentation
 - https://eips.ethereum.org/EIPS/eip-5564 for ERC-5564 stealth addresses

###### Since

0.0.0

###### Throws

If private key is invalid

###### Throws

If public key is invalid

###### Throws

If ECDH computation fails

###### Example

```javascript
import * as Secp256k1 from './crypto/Secp256k1/index.js';
const myPrivateKey = new Uint8Array(32);
const theirPublicKey = Secp256k1.derivePublicKey(theirPrivateKey);
const sharedSecret = Secp256k1.ecdh(myPrivateKey, theirPublicKey);
console.log(sharedSecret.length); // 32
```

##### getSharedSecret()

> **getSharedSecret**: (`privateKey`, `publicKey`) => `Uint8Array`\<`ArrayBufferLike`\> = `ecdh`

Perform ECDH key exchange

Computes shared secret from your private key and their public key.
Returns the x-coordinate of the shared point (32 bytes).

###### Parameters

###### privateKey

`PrivateKeyType`

Your 32-byte private key

###### publicKey

`Secp256k1PublicKeyType`

Their 64-byte uncompressed public key

###### Returns

`Uint8Array`\<`ArrayBufferLike`\>

32-byte shared secret (x-coordinate)

###### See

 - https://voltaire.tevm.sh/crypto for crypto documentation
 - https://eips.ethereum.org/EIPS/eip-5564 for ERC-5564 stealth addresses

###### Since

0.0.0

###### Throws

If private key is invalid

###### Throws

If public key is invalid

###### Throws

If ECDH computation fails

###### Example

```javascript
import * as Secp256k1 from './crypto/Secp256k1/index.js';
const myPrivateKey = new Uint8Array(32);
const theirPublicKey = Secp256k1.derivePublicKey(theirPrivateKey);
const sharedSecret = Secp256k1.ecdh(myPrivateKey, theirPublicKey);
console.log(sharedSecret.length); // 32
```

##### isValidPrivateKey()

> **isValidPrivateKey**: (`privateKey`) => `boolean`

Validate private key

Checks that the private key is within valid range [1, n-1] where n
is the curve order.

###### Parameters

###### privateKey

`Uint8Array`\<`ArrayBufferLike`\>

32-byte private key

###### Returns

`boolean`

true if private key is valid, false otherwise

###### See

https://voltaire.tevm.sh/crypto for crypto documentation

###### Since

0.0.0

###### Throws

###### Example

```javascript
import * as Secp256k1 from './crypto/Secp256k1/index.js';
const privateKey = new Uint8Array(32);
const valid = Secp256k1.isValidPrivateKey(privateKey);
```

##### isValidPublicKey()

> **isValidPublicKey**: (`publicKey`) => `publicKey is Secp256k1PublicKeyType`

Validate public key

Checks that the public key is a valid point on the secp256k1 curve.

###### Parameters

###### publicKey

`Uint8Array`\<`ArrayBufferLike`\>

64-byte uncompressed public key

###### Returns

`publicKey is Secp256k1PublicKeyType`

true if public key is valid, false otherwise

###### See

https://voltaire.tevm.sh/crypto for crypto documentation

###### Since

0.0.0

###### Throws

###### Example

```javascript
import * as Secp256k1 from './crypto/Secp256k1/index.js';
const publicKey = new Uint8Array(64);
if (Secp256k1.isValidPublicKey(publicKey)) {
  const branded = publicKey; // now Secp256k1PublicKeyType
}
```

##### isValidSignature()

> **isValidSignature**: (`signature`) => `boolean`

Validate signature components

Checks that r and s are within valid range [1, n-1] where n is the
curve order. Also enforces low-s values to prevent malleability.

###### Parameters

###### signature

`Secp256k1SignatureType`

ECDSA signature to validate (r and s are HashType)

###### Returns

`boolean`

true if signature is valid, false otherwise

###### See

https://voltaire.tevm.sh/crypto for crypto documentation

###### Since

0.0.0

###### Throws

###### Example

```javascript
import * as Secp256k1 from './crypto/Secp256k1/index.js';
import * as Hash from './primitives/Hash/index.js';
const signature = { r: Hash.from(new Uint8Array(32)), s: Hash.from(new Uint8Array(32)), v: 27 };
const valid = Secp256k1.isValidSignature(signature);
```

##### PRIVATE\_KEY\_SIZE

> **PRIVATE\_KEY\_SIZE**: `number`

Private key size in bytes

###### See

https://voltaire.tevm.sh/crypto for crypto documentation

###### Since

0.0.0

###### Throws

###### Example

```javascript
import { PRIVATE_KEY_SIZE } from './crypto/Secp256k1/index.js';
console.log(PRIVATE_KEY_SIZE); // 32
```

##### PrivateKey

> **PrivateKey**: `__module` = `PrivateKeyMethods`

##### PUBLIC\_KEY\_SIZE

> **PUBLIC\_KEY\_SIZE**: `number`

Uncompressed public key size in bytes (64 bytes, no prefix)

###### See

https://voltaire.tevm.sh/crypto for crypto documentation

###### Since

0.0.0

###### Throws

###### Example

```javascript
import { PUBLIC_KEY_SIZE } from './crypto/Secp256k1/index.js';
console.log(PUBLIC_KEY_SIZE); // 64
```

##### PublicKey

> **PublicKey**: `__module` = `PublicKeyMethods`

##### randomPrivateKey()

> **randomPrivateKey**: () => `Uint8Array`\<`ArrayBufferLike`\>

Generate a cryptographically secure random secp256k1 private key

###### Returns

`Uint8Array`\<`ArrayBufferLike`\>

32-byte private key

###### Example

```javascript
import { Secp256k1 } from './crypto/Secp256k1/index.js';
const privateKey = Secp256k1.randomPrivateKey();
const publicKey = Secp256k1.derivePublicKey(privateKey);
```

##### recoverPublicKey()

> **recoverPublicKey**: (`signature`, `messageHash`) => `Secp256k1PublicKeyType`

Recover public key from signature and message hash

Uses the recovery id (v) to recover the exact public key that created
the signature. This is what enables Ethereum's address recovery from
transaction signatures.

###### Parameters

###### signature

ECDSA signature components

###### r

`Uint8Array`\<`ArrayBufferLike`\>

32-byte signature component r

###### s

`Uint8Array`\<`ArrayBufferLike`\>

32-byte signature component s

###### v

`number`

Recovery id (27/28 or 0/1)

###### messageHash

[`HashType`](../HashType-2.mdx#hashtype)

32-byte message hash that was signed

###### Returns

`Secp256k1PublicKeyType`

64-byte uncompressed public key

###### See

https://voltaire.tevm.sh/crypto for crypto documentation

###### Since

0.0.0

###### Throws

If signature or recovery fails

###### Example

```javascript
import * as Secp256k1 from './crypto/Secp256k1/index.js';
import * as Hash from './primitives/Hash/index.js';
const messageHash = Hash.keccak256String('Hello');
const recovered = Secp256k1.recoverPublicKey(
  { r: rBytes, s: sBytes, v: 27 },
  messageHash
);
```

##### recoverPublicKeyFromHash()

> **recoverPublicKeyFromHash**: (`signature`, `hash`) => `Secp256k1PublicKeyType`

Recover public key from signature and pre-hashed message

This is the hash-level API that operates directly on a 32-byte hash.
Use this when you need custom hashing schemes or interop with other libraries.
For standard Ethereum signing, use recoverPublicKey() instead.

Uses the recovery id (v) to recover the exact public key that created
the signature. This is what enables Ethereum's address recovery from
transaction signatures.

###### Parameters

###### signature

ECDSA signature components

###### r

`Uint8Array`\<`ArrayBufferLike`\>

32-byte signature component r

###### s

`Uint8Array`\<`ArrayBufferLike`\>

32-byte signature component s

###### v

`number`

Recovery id (27/28 or 0/1)

###### hash

[`HashType`](../HashType-2.mdx#hashtype)

32-byte hash that was signed (pre-hashed message)

###### Returns

`Secp256k1PublicKeyType`

64-byte uncompressed public key

###### See

https://voltaire.tevm.sh/crypto for crypto documentation

###### Since

0.0.0

###### Throws

If signature or recovery fails

###### Throws

If hash is not 32 bytes

###### Example

```javascript
import * as Secp256k1 from './crypto/Secp256k1/index.js';
import * as Hash from './primitives/Hash/index.js';

// Recover public key from a pre-hashed message (hash-level API)
const hash = Hash.keccak256String('Hello');
const recovered = Secp256k1.recoverPublicKeyFromHash(
  { r: rBytes, s: sBytes, v: 27 },
  hash
);

// For comparison, recoverPublicKey() hashes internally (message-level API)
const recovered2 = Secp256k1.recoverPublicKey(
  { r: rBytes, s: sBytes, v: 27 },
  messageHash
);
```

##### scalarMultiply()

> **scalarMultiply**: (`scalar`) => `Secp256k1PublicKeyType`

Multiply generator point by scalar

Performs scalar multiplication: scalar * G (generator point).
Used in ERC-5564 stealth address generation.

###### Parameters

###### scalar

`Uint8Array`\<`ArrayBufferLike`\>

32-byte scalar value

###### Returns

`Secp256k1PublicKeyType`

Result 64-byte uncompressed public key

###### See

 - https://voltaire.tevm.sh/crypto for crypto documentation
 - https://eips.ethereum.org/EIPS/eip-5564 for ERC-5564 stealth addresses

###### Since

0.0.0

###### Throws

If scalar multiplication fails

###### Example

```javascript
import * as Secp256k1 from './crypto/Secp256k1/index.js';
const scalar = new Uint8Array(32);
scalar[31] = 5; // scalar = 5
const result = Secp256k1.scalarMultiply(scalar);
console.log(result.length); // 64
```

##### sign()

> **sign**: (`messageHash`, `privateKey`) => `Secp256k1SignatureType`

Sign a message hash with a private key

Uses deterministic ECDSA (RFC 6979) for signature generation.
Returns signature with Ethereum-compatible v value (27 or 28).

###### Parameters

###### messageHash

[`HashType`](../HashType-2.mdx#hashtype)

32-byte message hash to sign

###### privateKey

`PrivateKeyType`

32-byte private key

###### Returns

`Secp256k1SignatureType`

ECDSA signature with r, s, v components

###### See

https://voltaire.tevm.sh/crypto for crypto documentation

###### Since

0.0.0

###### Throws

If private key is invalid

###### Throws

If signing fails

###### Example

```javascript
import * as Secp256k1 from './crypto/Secp256k1/index.js';
import * as Hash from './primitives/Hash/index.js';
import * as PrivateKey from './primitives/PrivateKey/index.js';
const messageHash = Hash.keccak256String('Hello!');
const privateKey = PrivateKey.from(new Uint8Array(32));
const signature = Secp256k1.sign(messageHash, privateKey);
```

##### Signature

> **Signature**: `__module` = `SignatureMethods`

##### SIGNATURE\_COMPONENT\_SIZE

> **SIGNATURE\_COMPONENT\_SIZE**: `number`

Signature component size in bytes (r and s are each 32 bytes)

###### See

https://voltaire.tevm.sh/crypto for crypto documentation

###### Since

0.0.0

###### Throws

###### Example

```javascript
import { SIGNATURE_COMPONENT_SIZE } from './crypto/Secp256k1/index.js';
console.log(SIGNATURE_COMPONENT_SIZE); // 32
```

##### signHash()

> **signHash**: (`hash`, `privateKey`) => `Secp256k1SignatureType`

Sign a pre-hashed message with a private key

This is the hash-level API that operates directly on a 32-byte hash.
Use this when you need custom hashing schemes or interop with other libraries.
For standard Ethereum signing, use sign() instead.

Uses deterministic ECDSA (RFC 6979) for signature generation.
Returns signature with Ethereum-compatible v value (27 or 28).

###### Parameters

###### hash

[`HashType`](../HashType-2.mdx#hashtype)

32-byte hash to sign (pre-hashed message)

###### privateKey

`PrivateKeyType`

32-byte private key

###### Returns

`Secp256k1SignatureType`

ECDSA signature with r, s, v components

###### See

https://voltaire.tevm.sh/crypto for crypto documentation

###### Since

0.0.0

###### Throws

If private key is invalid

###### Throws

If signing fails or hash is not 32 bytes

###### Example

```javascript
import * as Secp256k1 from './crypto/Secp256k1/index.js';
import * as Hash from './primitives/Hash/index.js';
import * as PrivateKey from './primitives/PrivateKey/index.js';

// Sign a pre-hashed message (hash-level API)
const hash = Hash.keccak256String('Hello!');
const privateKey = PrivateKey.from(new Uint8Array(32));
const signature = Secp256k1.signHash(hash, privateKey);

// For comparison, sign() hashes internally (message-level API)
const signature2 = Secp256k1.sign(Hash.keccak256String('Hello!'), privateKey);
```

##### verify()

> **verify**: (`signature`, `messageHash`, `publicKey`) => `boolean`

Verify an ECDSA signature

###### Parameters

###### signature

`Secp256k1SignatureType`

ECDSA signature with r, s, v components (r and s are HashType)

###### messageHash

[`HashType`](../HashType-2.mdx#hashtype)

32-byte message hash that was signed

###### publicKey

`Secp256k1PublicKeyType`

64-byte uncompressed public key

###### Returns

`boolean`

true if signature is valid, false otherwise

###### See

https://voltaire.tevm.sh/crypto for crypto documentation

###### Since

0.0.0

###### Throws

If signature v is invalid

###### Example

```javascript
import * as Secp256k1 from './crypto/Secp256k1/index.js';
import * as Hash from './primitives/Hash/index.js';
const r = Hash.from(rBytes);
const s = Hash.from(sBytes);
const valid = Secp256k1.verify({ r, s, v: 27 }, messageHash, publicKey);
```

##### verifyHash()

> **verifyHash**: (`signature`, `hash`, `publicKey`) => `boolean`

Verify an ECDSA signature against a pre-hashed message

This is the hash-level API that operates directly on a 32-byte hash.
Use this when you need custom hashing schemes or interop with other libraries.
For standard Ethereum signing, use verify() instead.

###### Parameters

###### signature

`Secp256k1SignatureType`

ECDSA signature with r, s, v components (r and s are HashType)

###### hash

[`HashType`](../HashType-2.mdx#hashtype)

32-byte hash that was signed (pre-hashed message)

###### publicKey

`Secp256k1PublicKeyType`

64-byte uncompressed public key

###### Returns

`boolean`

true if signature is valid, false otherwise

###### See

https://voltaire.tevm.sh/crypto for crypto documentation

###### Since

0.0.0

###### Throws

If hash is not 32 bytes

###### Example

```javascript
import * as Secp256k1 from './crypto/Secp256k1/index.js';
import * as Hash from './primitives/Hash/index.js';

// Verify a signature against a pre-hashed message (hash-level API)
const hash = Hash.keccak256String('Hello!');
const valid = Secp256k1.verifyHash({ r, s, v: 27 }, hash, publicKey);

// For comparison, verify() hashes internally (message-level API)
const valid2 = Secp256k1.verify({ r, s, v: 27 }, messageHash, publicKey);
```

#### Type Declaration

##### \_wasm

> **\_wasm**: *typeof* [`Secp256k1Wasm`](namespaces/Secp256k1Wasm/index.mdx) = `Secp256k1Wasm`

***

### SHA256

> `const` **SHA256**: (`input`) => [`SHA256Hash`](../../index.mdx#sha256hash) & `object` & `object`

Defined in: [src/wasm/index.ts:165](https://github.com/evmts/voltaire/blob/c23bdec42e80cac8af3a4130b0c4c180becd2ad0/src/wasm/index.ts#L165)

SHA256 with WASM acceleration

#### Type Declaration

##### BLOCK\_SIZE

> **BLOCK\_SIZE**: `number`

SHA256 block size in bytes

###### See

https://voltaire.tevm.sh/crypto for crypto documentation

###### Since

0.0.0

###### Throws

###### Example

```javascript
import { BLOCK_SIZE } from './crypto/SHA256/index.js';
console.log(BLOCK_SIZE); // 64
```

##### create()

> **create**: () => `object`

Incremental hasher for streaming data

###### Returns

`object`

Hasher instance

###### digest()

> **digest**: () => `Uint8Array`

###### Returns

`Uint8Array`

###### update()

> **update**: (`data`) => `void`

###### Parameters

###### data

`Uint8Array`

###### Returns

`void`

###### See

https://voltaire.tevm.sh/crypto for crypto documentation

###### Since

0.0.0

###### Throws

###### Example

```javascript
import { SHA256 } from './crypto/SHA256/index.js';
const hasher = SHA256.create();
hasher.update(new Uint8Array([1, 2, 3]));
hasher.update(new Uint8Array([4, 5, 6]));
const hash = hasher.digest();
```

##### from()

> **from**: (`input`) => [`SHA256Hash`](../../index.mdx#sha256hash)

Hash input with SHA256 (constructor pattern)

Auto-detects input type and hashes accordingly:
- Uint8Array: hash directly
- string starting with 0x: parse as hex
- string: UTF-8 encode then hash

###### Parameters

###### input

Data to hash

`string` | `Uint8Array`\<`ArrayBufferLike`\>

###### Returns

[`SHA256Hash`](../../index.mdx#sha256hash)

32-byte hash

###### See

https://voltaire.tevm.sh/crypto/sha256 for crypto documentation

###### Since

0.0.0

###### Throws

###### Example

```javascript
import { SHA256Hash } from './crypto/SHA256/index.js';

const hash1 = SHA256Hash.from("0x1234");      // Hex
const hash2 = SHA256Hash.from("hello");       // String
const hash3 = SHA256Hash.from(uint8array);    // Bytes
```

##### fromHex()

> **fromHex**: (`hex`) => [`SHA256Hash`](../../index.mdx#sha256hash) = `hashHex`

Compute SHA256 hash of hex string (without 0x prefix)

###### Parameters

###### hex

`string`

Hex string (with or without 0x prefix)

###### Returns

[`SHA256Hash`](../../index.mdx#sha256hash)

32-byte hash

###### See

https://voltaire.tevm.sh/crypto for crypto documentation

###### Since

0.0.0

###### Throws

###### Example

```javascript
import { SHA256 } from './crypto/SHA256/index.js';
const hash = SHA256.hashHex("0xdeadbeef");
console.log(hash.length); // 32
```

##### fromString()

> **fromString**: (`str`) => [`SHA256Hash`](../../index.mdx#sha256hash) = `hashString`

Compute SHA256 hash of UTF-8 string

###### Parameters

###### str

`string`

Input string

###### Returns

[`SHA256Hash`](../../index.mdx#sha256hash)

32-byte hash

###### See

https://voltaire.tevm.sh/crypto for crypto documentation

###### Since

0.0.0

###### Throws

###### Example

```javascript
import { SHA256 } from './crypto/SHA256/index.js';
const hash = SHA256.hashString("hello world");
console.log(hash.length); // 32
```

##### hash()

> **hash**: (`data`) => [`SHA256Hash`](../../index.mdx#sha256hash)

Compute SHA256 hash of input data

###### Parameters

###### data

`Uint8Array`\<`ArrayBufferLike`\>

Input data as Uint8Array

###### Returns

[`SHA256Hash`](../../index.mdx#sha256hash)

32-byte hash

###### See

https://voltaire.tevm.sh/crypto for crypto documentation

###### Since

0.0.0

###### Throws

###### Example

```javascript
import { SHA256Hash } from './crypto/SHA256/index.js';
const hash = SHA256Hash.from(new Uint8Array([1, 2, 3]));
console.log(hash.length); // 32
```

##### hashHex()

> **hashHex**: (`hex`) => [`SHA256Hash`](../../index.mdx#sha256hash)

Compute SHA256 hash of hex string (without 0x prefix)

###### Parameters

###### hex

`string`

Hex string (with or without 0x prefix)

###### Returns

[`SHA256Hash`](../../index.mdx#sha256hash)

32-byte hash

###### See

https://voltaire.tevm.sh/crypto for crypto documentation

###### Since

0.0.0

###### Throws

###### Example

```javascript
import { SHA256 } from './crypto/SHA256/index.js';
const hash = SHA256.hashHex("0xdeadbeef");
console.log(hash.length); // 32
```

##### hashString()

> **hashString**: (`str`) => [`SHA256Hash`](../../index.mdx#sha256hash)

Compute SHA256 hash of UTF-8 string

###### Parameters

###### str

`string`

Input string

###### Returns

[`SHA256Hash`](../../index.mdx#sha256hash)

32-byte hash

###### See

https://voltaire.tevm.sh/crypto for crypto documentation

###### Since

0.0.0

###### Throws

###### Example

```javascript
import { SHA256 } from './crypto/SHA256/index.js';
const hash = SHA256.hashString("hello world");
console.log(hash.length); // 32
```

##### OUTPUT\_SIZE

> **OUTPUT\_SIZE**: `number`

SHA256 output size in bytes (256 bits / 8)

###### See

https://voltaire.tevm.sh/crypto for crypto documentation

###### Since

0.0.0

###### Throws

###### Example

```javascript
import { OUTPUT_SIZE } from './crypto/SHA256/index.js';
console.log(OUTPUT_SIZE); // 32
```

##### toHex()

> **toHex**: (`hash`) => `string`

Convert hash output to hex string

###### Parameters

###### hash

`Uint8Array`\<`ArrayBufferLike`\>

Hash bytes

###### Returns

`string`

Hex string with 0x prefix

###### See

https://voltaire.tevm.sh/crypto for crypto documentation

###### Since

0.0.0

###### Throws

###### Example

```javascript
import { SHA256 } from './crypto/SHA256/index.js';
const hash = SHA256.hash(new Uint8Array([1, 2, 3]));
const hexStr = SHA256.toHex(hash);
console.log(hexStr); // "0x..."
```

#### Type Declaration

##### \_wasm

> **\_wasm**: *typeof* [`Sha256Wasm`](namespaces/Sha256Wasm.mdx) = `Sha256Wasm`

***

### Siwe

> `const` **Siwe**: *typeof* [`Siwe`](../../index.mdx#siwe) = `SiweJS`

Defined in: [src/wasm/index.ts:241](https://github.com/evmts/voltaire/blob/c23bdec42e80cac8af3a4130b0c4c180becd2ad0/src/wasm/index.ts#L241)

***

### StorageKey

> `const` **StorageKey**: `object` = `StorageKeyJS`

Defined in: [src/wasm/index.ts:244](https://github.com/evmts/voltaire/blob/c23bdec42e80cac8af3a4130b0c4c180becd2ad0/src/wasm/index.ts#L244)

#### Type Declaration

##### create()

> **create**: (`address`, `slot`) => [`StorageKeyType`](../BrandedStorageKey.mdx#storagekeytype)

###### Parameters

###### address

[`AddressType`](../../../primitives/Address.mdx#addresstype)

###### slot

`bigint`

###### Returns

[`StorageKeyType`](../BrandedStorageKey.mdx#storagekeytype)

##### equals()

> **equals**: (`a`, `b`) => `boolean`

###### Parameters

###### a

[`StorageKeyLike`](../BrandedStorageKey.mdx#storagekeylike)

###### b

[`StorageKeyLike`](../BrandedStorageKey.mdx#storagekeylike)

###### Returns

`boolean`

##### from()

> **from**: (`value`) => [`StorageKeyType`](../BrandedStorageKey.mdx#storagekeytype)

###### Parameters

###### value

[`StorageKeyLike`](../BrandedStorageKey.mdx#storagekeylike)

###### Returns

[`StorageKeyType`](../BrandedStorageKey.mdx#storagekeytype)

##### fromString()

> **fromString**: (`str`) => [`StorageKeyType`](../BrandedStorageKey.mdx#storagekeytype) \| `undefined`

###### Parameters

###### str

`string`

###### Returns

[`StorageKeyType`](../BrandedStorageKey.mdx#storagekeytype) \| `undefined`

##### hashCode()

> **hashCode**: (`key`) => `number`

###### Parameters

###### key

[`StorageKeyLike`](../BrandedStorageKey.mdx#storagekeylike)

###### Returns

`number`

##### is()

> **is**: (`value`) => `value is StorageKeyType`

###### Parameters

###### value

`unknown`

###### Returns

`value is StorageKeyType`

##### toString()

> **toString**: (`key`) => `string`

###### Parameters

###### key

[`StorageKeyLike`](../BrandedStorageKey.mdx#storagekeylike)

###### Returns

`string`

***

### Uint

> `const` **Uint**: *typeof* [`Uint`](../../index.mdx#uint) = `UintJS`

Defined in: [src/wasm/index.ts:232](https://github.com/evmts/voltaire/blob/c23bdec42e80cac8af3a4130b0c4c180becd2ad0/src/wasm/index.ts#L232)

***

### wasmAPI

> `const` **wasmAPI**: `object`

Defined in: [src/wasm/index.ts:264](https://github.com/evmts/voltaire/blob/c23bdec42e80cac8af3a4130b0c4c180becd2ad0/src/wasm/index.ts#L264)

#### Type Declaration

##### Abi

> **Abi**: *typeof* [`Abi`](../../index.mdx#abi)

##### AccessList

> **AccessList**: `object`

###### AccessList.ADDRESS\_COST

> **ADDRESS\_COST**: `bigint`

Gas cost per address in access list (EIP-2930)

###### AccessList.addressCount()

> **addressCount**: (`list`) => `number`

###### Parameters

###### list

[`BrandedAccessList`](../BrandedAccessList.mdx#brandedaccesslist)

###### Returns

`number`

###### AccessList.assertValid()

> **assertValid**: (`list`) => `void`

###### Parameters

###### list

[`BrandedAccessList`](../BrandedAccessList.mdx#brandedaccesslist)

###### Returns

`void`

###### AccessList.COLD\_ACCOUNT\_ACCESS\_COST

> **COLD\_ACCOUNT\_ACCESS\_COST**: `bigint`

Cold account access cost (pre-EIP-2930)

###### AccessList.COLD\_STORAGE\_ACCESS\_COST

> **COLD\_STORAGE\_ACCESS\_COST**: `bigint`

Cold storage access cost (pre-EIP-2930)

###### AccessList.create()

> **create**: () => [`BrandedAccessList`](../BrandedAccessList.mdx#brandedaccesslist)

###### Returns

[`BrandedAccessList`](../BrandedAccessList.mdx#brandedaccesslist)

###### AccessList.deduplicate()

> **deduplicate**: (`list`) => [`BrandedAccessList`](../BrandedAccessList.mdx#brandedaccesslist)

###### Parameters

###### list

[`BrandedAccessList`](../BrandedAccessList.mdx#brandedaccesslist)

###### Returns

[`BrandedAccessList`](../BrandedAccessList.mdx#brandedaccesslist)

###### AccessList.from()

> **from**: (`value`) => [`BrandedAccessList`](../BrandedAccessList.mdx#brandedaccesslist)

###### Parameters

###### value

`Uint8Array`\<`ArrayBufferLike`\> | readonly [`Item`](../BrandedAccessList.mdx#item)[]

###### Returns

[`BrandedAccessList`](../BrandedAccessList.mdx#brandedaccesslist)

###### AccessList.fromBytes()

> **fromBytes**: (`bytes`) => [`BrandedAccessList`](../BrandedAccessList.mdx#brandedaccesslist)

###### Parameters

###### bytes

`Uint8Array`

###### Returns

[`BrandedAccessList`](../BrandedAccessList.mdx#brandedaccesslist)

###### AccessList.gasCost()

> **gasCost**: (`list`) => `bigint`

###### Parameters

###### list

[`BrandedAccessList`](../BrandedAccessList.mdx#brandedaccesslist)

###### Returns

`bigint`

###### AccessList.gasSavings()

> **gasSavings**: (`list`) => `bigint`

###### Parameters

###### list

[`BrandedAccessList`](../BrandedAccessList.mdx#brandedaccesslist)

###### Returns

`bigint`

###### AccessList.hasSavings()

> **hasSavings**: (`list`) => `boolean`

###### Parameters

###### list

[`BrandedAccessList`](../BrandedAccessList.mdx#brandedaccesslist)

###### Returns

`boolean`

###### AccessList.includesAddress()

> **includesAddress**: (`list`, `address`) => `boolean`

###### Parameters

###### list

[`BrandedAccessList`](../BrandedAccessList.mdx#brandedaccesslist)

###### address

[`AddressType`](../../../primitives/Address.mdx#addresstype)

###### Returns

`boolean`

###### AccessList.includesStorageKey()

> **includesStorageKey**: (`list`, `address`, `storageKey`) => `boolean`

###### Parameters

###### list

[`BrandedAccessList`](../BrandedAccessList.mdx#brandedaccesslist)

###### address

[`AddressType`](../../../primitives/Address.mdx#addresstype)

###### storageKey

[`HashType`](../HashType-2.mdx#hashtype)

###### Returns

`boolean`

###### AccessList.is()

> **is**: (`value`) => `value is BrandedAccessList`

###### Parameters

###### value

`unknown`

###### Returns

`value is BrandedAccessList`

###### AccessList.isEmpty()

> **isEmpty**: (`list`) => `boolean`

###### Parameters

###### list

[`BrandedAccessList`](../BrandedAccessList.mdx#brandedaccesslist)

###### Returns

`boolean`

###### AccessList.isItem()

> **isItem**: (`value`) => `value is Item`

###### Parameters

###### value

`unknown`

###### Returns

`value is Item`

###### AccessList.keysFor()

> **keysFor**: (`list`, `address`) => readonly [`HashType`](../HashType-2.mdx#hashtype)[] \| `undefined`

###### Parameters

###### list

[`BrandedAccessList`](../BrandedAccessList.mdx#brandedaccesslist)

###### address

[`AddressType`](../../../primitives/Address.mdx#addresstype)

###### Returns

readonly [`HashType`](../HashType-2.mdx#hashtype)[] \| `undefined`

###### AccessList.merge()

> **merge**: (...`accessLists`) => [`BrandedAccessList`](../BrandedAccessList.mdx#brandedaccesslist)

###### Parameters

###### accessLists

...[`BrandedAccessList`](../BrandedAccessList.mdx#brandedaccesslist)[]

###### Returns

[`BrandedAccessList`](../BrandedAccessList.mdx#brandedaccesslist)

###### AccessList.STORAGE\_KEY\_COST

> **STORAGE\_KEY\_COST**: `bigint`

Gas cost per storage key in access list (EIP-2930)

###### AccessList.storageKeyCount()

> **storageKeyCount**: (`list`) => `number`

###### Parameters

###### list

[`BrandedAccessList`](../BrandedAccessList.mdx#brandedaccesslist)

###### Returns

`number`

###### AccessList.toBytes()

> **toBytes**: (`list`) => `Uint8Array`

###### Parameters

###### list

[`BrandedAccessList`](../BrandedAccessList.mdx#brandedaccesslist)

###### Returns

`Uint8Array`

###### AccessList.WARM\_STORAGE\_ACCESS\_COST

> **WARM\_STORAGE\_ACCESS\_COST**: `bigint`

Warm storage access cost (post-EIP-2929)

###### AccessList.withAddress()

> **withAddress**: (`list`, `address`) => [`BrandedAccessList`](../BrandedAccessList.mdx#brandedaccesslist)

###### Parameters

###### list

[`BrandedAccessList`](../BrandedAccessList.mdx#brandedaccesslist)

###### address

[`AddressType`](../../../primitives/Address.mdx#addresstype)

###### Returns

[`BrandedAccessList`](../BrandedAccessList.mdx#brandedaccesslist)

###### AccessList.withStorageKey()

> **withStorageKey**: (`list`, `address`, `storageKey`) => [`BrandedAccessList`](../BrandedAccessList.mdx#brandedaccesslist)

###### Parameters

###### list

[`BrandedAccessList`](../BrandedAccessList.mdx#brandedaccesslist)

###### address

[`AddressType`](../../../primitives/Address.mdx#addresstype)

###### storageKey

[`HashType`](../HashType-2.mdx#hashtype)

###### Returns

[`BrandedAccessList`](../BrandedAccessList.mdx#brandedaccesslist)

##### Address

> **Address**: *typeof* [`Address`](../../../primitives/Address.mdx#address)

##### Blake2

> **Blake2**: (`input`, `outputLength?`) => [`Blake2Hash`](../../index.mdx#blake2hash) & `object` & `object`

Blake2 with WASM acceleration

###### Type Declaration

###### from()

> **from**: (`input`, `outputLength?`) => [`Blake2Hash`](../../index.mdx#blake2hash)

Hash input with BLAKE2b (constructor pattern)

Auto-detects input type and hashes accordingly:
- Uint8Array: hash directly
- string: UTF-8 encode then hash

###### Parameters

###### input

Data to hash

`string` | `Uint8Array`\<`ArrayBufferLike`\>

###### outputLength?

`number` = `64`

Output length in bytes (1-64, default 64)

###### Returns

[`Blake2Hash`](../../index.mdx#blake2hash)

BLAKE2b hash

###### See

https://voltaire.tevm.sh/crypto/blake2 for crypto documentation

###### Since

0.0.0

###### Throws

If outputLength is invalid

###### Example

```javascript
import { Blake2Hash } from './crypto/Blake2/index.js';

const hash1 = Blake2Hash.from("hello");              // String, 64 bytes
const hash2 = Blake2Hash.from("hello", 32);          // String, 32 bytes
const hash3 = Blake2Hash.from(uint8array);           // Bytes, 64 bytes
const hash4 = Blake2Hash.from(uint8array, 48);       // Bytes, 48 bytes
```

###### fromString()

> **fromString**: (`str`, `outputLength?`) => [`Blake2Hash`](../../index.mdx#blake2hash) = `hashString`

Hash string with BLAKE2b (convenience function)

###### Parameters

###### str

`string`

Input string to hash

###### outputLength?

`number` = `64`

Output length in bytes (1-64, default 64)

###### Returns

[`Blake2Hash`](../../index.mdx#blake2hash)

BLAKE2b hash

###### See

https://voltaire.tevm.sh/crypto for crypto documentation

###### Since

0.0.0

###### Throws

If outputLength is invalid

###### Example

```javascript
import * as Blake2 from './crypto/Blake2/index.js';
const hash = Blake2.hashString("hello world");
const hash48 = Blake2.hashString("hello world", 48);
```

###### hash()

> **hash**: (`data`, `outputLength?`) => [`Blake2Hash`](../../index.mdx#blake2hash)

Hash data with BLAKE2b

###### Parameters

###### data

Input data to hash (Uint8Array or string)

`string` | `Uint8Array`\<`ArrayBufferLike`\>

###### outputLength?

`number` = `64`

Output length in bytes (1-64, default 64)

###### Returns

[`Blake2Hash`](../../index.mdx#blake2hash)

BLAKE2b hash

###### See

https://voltaire.tevm.sh/crypto for crypto documentation

###### Since

0.0.0

###### Throws

If outputLength is invalid

###### Example

```javascript
import * as Blake2 from './crypto/Blake2/index.js';
const hash = Blake2.hash(new Uint8Array([1, 2, 3]));
const hash32 = Blake2.hash("hello", 32);
```

###### hashString()

> **hashString**: (`str`, `outputLength?`) => [`Blake2Hash`](../../index.mdx#blake2hash)

Hash string with BLAKE2b (convenience function)

###### Parameters

###### str

`string`

Input string to hash

###### outputLength?

`number` = `64`

Output length in bytes (1-64, default 64)

###### Returns

[`Blake2Hash`](../../index.mdx#blake2hash)

BLAKE2b hash

###### See

https://voltaire.tevm.sh/crypto for crypto documentation

###### Since

0.0.0

###### Throws

If outputLength is invalid

###### Example

```javascript
import * as Blake2 from './crypto/Blake2/index.js';
const hash = Blake2.hashString("hello world");
const hash48 = Blake2.hashString("hello world", 48);
```

###### SIZE

> **SIZE**: `number`

###### Type Declaration

###### \_wasm

> **\_wasm**: *typeof* [`Blake2Wasm`](namespaces/Blake2Wasm.mdx) = `Blake2Wasm`

##### Blob

> **Blob**: *typeof* [`Blob`](../../index.mdx#blob)

##### BloomFilter

> **BloomFilter**: *typeof* [`BloomFilter`](../../index.mdx#bloomfilter)

##### Bls12381

> **Bls12381**: `object`

###### Bls12381.aggregate()

> **aggregate**: (`signatures`) => `Uint8Array`\<`ArrayBufferLike`\>

Aggregate multiple BLS signatures into one

The aggregated signature can be verified against an aggregated public key
(when all signers signed the same message) or via batch verification
(when signers signed different messages).

###### Parameters

###### signatures

`Uint8Array`\<`ArrayBufferLike`\>[]

Array of compressed G1 signatures (48 bytes each)

###### Returns

`Uint8Array`\<`ArrayBufferLike`\>

Aggregated signature (48 bytes compressed G1)

###### Throws

If aggregation fails or no signatures provided

###### Example

```javascript
import { Bls12381 } from './crypto/Bls12381/index.js';

const message = new TextEncoder().encode('Vote for proposal');

const pk1 = Bls12381.randomPrivateKey();
const pk2 = Bls12381.randomPrivateKey();

const sig1 = Bls12381.sign(message, pk1);
const sig2 = Bls12381.sign(message, pk2);

const aggSig = Bls12381.aggregate([sig1, sig2]);
```

###### Bls12381.aggregatePublicKeys()

> **aggregatePublicKeys**: (`publicKeys`) => `Uint8Array`\<`ArrayBufferLike`\>

Aggregate multiple public keys into one

Used when multiple signers sign the same message and you want
to verify against a single aggregated public key.

###### Parameters

###### publicKeys

`Uint8Array`\<`ArrayBufferLike`\>[]

Array of compressed G2 public keys (96 bytes each)

###### Returns

`Uint8Array`\<`ArrayBufferLike`\>

Aggregated public key (96 bytes compressed G2)

###### Throws

If aggregation fails or no public keys provided

###### Example

```javascript
import { Bls12381 } from './crypto/Bls12381/index.js';

const pk1 = Bls12381.randomPrivateKey();
const pk2 = Bls12381.randomPrivateKey();

const pubKey1 = Bls12381.derivePublicKey(pk1);
const pubKey2 = Bls12381.derivePublicKey(pk2);

const aggPubKey = Bls12381.aggregatePublicKeys([pubKey1, pubKey2]);
```

###### Bls12381.aggregateVerify()

> **aggregateVerify**: (`aggregatedSignature`, `message`, `publicKeys`) => `boolean`

Verify an aggregated signature where all signers signed the same message

This is the most common case in Ethereum consensus - multiple validators
sign the same block/attestation.

###### Parameters

###### aggregatedSignature

`Uint8Array`\<`ArrayBufferLike`\>

Aggregated signature (96 bytes)

###### message

`Uint8Array`\<`ArrayBufferLike`\>

The message that was signed by all parties

###### publicKeys

`Uint8Array`\<`ArrayBufferLike`\>[]

Public keys of all signers (48 bytes each)

###### Returns

`boolean`

True if the aggregated signature is valid

###### Example

```javascript
import { Bls12381 } from './crypto/Bls12381/index.js';

const message = new TextEncoder().encode('Block attestation');

const pk1 = Bls12381.randomPrivateKey();
const pk2 = Bls12381.randomPrivateKey();
const pubKey1 = Bls12381.derivePublicKey(pk1);
const pubKey2 = Bls12381.derivePublicKey(pk2);

const sig1 = Bls12381.sign(message, pk1);
const sig2 = Bls12381.sign(message, pk2);
const aggSig = Bls12381.aggregate([sig1, sig2]);

const isValid = Bls12381.aggregateVerify(aggSig, message, [pubKey1, pubKey2]);
console.log(isValid); // true
```

###### Bls12381.batchVerify()

> **batchVerify**: (`aggregatedSignature`, `messages`, `publicKeys`) => `boolean`

Verify an aggregated signature where each signer signed a different message

Uses multi-pairing verification: product of e(pk_i, H(msg_i)) == e(G1, aggSig)

###### Parameters

###### aggregatedSignature

`Uint8Array`\<`ArrayBufferLike`\>

Aggregated signature (96 bytes)

###### messages

`Uint8Array`\<`ArrayBufferLike`\>[]

Messages that were signed (one per signer)

###### publicKeys

`Uint8Array`\<`ArrayBufferLike`\>[]

Public keys (one per signer, same order as messages)

###### Returns

`boolean`

True if the aggregated signature is valid

###### Throws

If messages and publicKeys have different lengths

###### Example

```javascript
import { Bls12381 } from './crypto/Bls12381/index.js';

const pk1 = Bls12381.randomPrivateKey();
const pk2 = Bls12381.randomPrivateKey();
const pubKey1 = Bls12381.derivePublicKey(pk1);
const pubKey2 = Bls12381.derivePublicKey(pk2);

const msg1 = new TextEncoder().encode('Message 1');
const msg2 = new TextEncoder().encode('Message 2');

const sig1 = Bls12381.sign(msg1, pk1);
const sig2 = Bls12381.sign(msg2, pk2);
const aggSig = Bls12381.aggregate([sig1, sig2]);

const isValid = Bls12381.batchVerify(aggSig, [msg1, msg2], [pubKey1, pubKey2]);
console.log(isValid); // true
```

###### Bls12381.derivePublicKey()

> **derivePublicKey**: (`privateKey`) => `Uint8Array`\<`ArrayBufferLike`\>

Derive a BLS12-381 public key from a private key

Public key = privateKey * G2_generator

###### Parameters

###### privateKey

`Uint8Array`\<`ArrayBufferLike`\>

32-byte private key (scalar in Fr)

###### Returns

`Uint8Array`\<`ArrayBufferLike`\>

Compressed G2 public key (96 bytes)

###### Throws

If private key is invalid

###### Example

```javascript
import { Bls12381 } from './crypto/Bls12381/index.js';

const privateKey = Bls12381.randomPrivateKey();
const publicKey = Bls12381.derivePublicKey(privateKey);
console.log(publicKey.length); // 96
```

###### Bls12381.derivePublicKeyPoint()

> **derivePublicKeyPoint**: (`privateKey`) => [`Bls12381G1PointType`](../../index.mdx#bls12381g1pointtype)

Derive a BLS12-381 public key as a G1 point (uncompressed)

###### Parameters

###### privateKey

`Uint8Array`\<`ArrayBufferLike`\>

32-byte private key

###### Returns

[`Bls12381G1PointType`](../../index.mdx#bls12381g1pointtype)

Public key as G1 point

###### Throws

If private key is invalid

###### Bls12381.fastAggregateVerify()

> **fastAggregateVerify**: (`aggregatedSignature`, `message`, `aggregatedPublicKey`) => `boolean`

Fast aggregate verify (same message case)

Optimized for the common case where all signers signed the same message.
This is faster than aggregateVerify when you already have the aggregated public key.

###### Parameters

###### aggregatedSignature

`Uint8Array`\<`ArrayBufferLike`\>

Aggregated signature (96 bytes)

###### message

`Uint8Array`\<`ArrayBufferLike`\>

The message that was signed

###### aggregatedPublicKey

`Uint8Array`\<`ArrayBufferLike`\>

Pre-computed aggregated public key (48 bytes)

###### Returns

`boolean`

True if valid

###### Bls12381.Fp

> **Fp**: `__module`

###### Bls12381.Fp2

> **Fp2**: `__module`

###### Bls12381.Fr

> **Fr**: `__module`

###### Bls12381.G1

> **G1**: `__module`

###### Bls12381.G2

> **G2**: `__module`

###### Bls12381.isValidPrivateKey()

> **isValidPrivateKey**: (`privateKey`) => `boolean`

Check if a private key is valid

A valid private key must be:
- 32 bytes
- Non-zero
- Less than the curve order (Fr modulus)

###### Parameters

###### privateKey

`Uint8Array`\<`ArrayBufferLike`\>

Private key to validate

###### Returns

`boolean`

True if valid

###### Example

```javascript
import { Bls12381 } from './crypto/Bls12381/index.js';

const pk = Bls12381.randomPrivateKey();
console.log(Bls12381.isValidPrivateKey(pk)); // true

const invalid = new Uint8Array(32); // all zeros
console.log(Bls12381.isValidPrivateKey(invalid)); // false
```

###### Bls12381.Pairing

> **Pairing**: `__module`

BLS12-381 Pairing Operations

Optimal Ate pairing implementation for BLS12-381.
e: G1 x G2 -> GT

NOTE: Full pairing implementation requires Fp6, Fp12 tower extensions
and Miller loop computation. For production use, the native blst
library should be used via the Zig FFI bindings.

This module provides the interface and simplified implementations
for testing and educational purposes.

###### See

https://hackmd.io/@benjaminion/bls12-381 for pairing details

###### Since

0.0.0

###### Bls12381.randomPrivateKey()

> **randomPrivateKey**: () => `Uint8Array`\<`ArrayBufferLike`\>

Generate a random BLS12-381 private key

Uses cryptographically secure random number generation.
The key is guaranteed to be valid (non-zero and less than curve order).

###### Returns

`Uint8Array`\<`ArrayBufferLike`\>

32-byte private key

###### Example

```javascript
import { Bls12381 } from './crypto/Bls12381/index.js';

const privateKey = Bls12381.randomPrivateKey();
const publicKey = Bls12381.derivePublicKey(privateKey);
```

###### Bls12381.sign()

> **sign**: (`message`, `privateKey`) => `Uint8Array`\<`ArrayBufferLike`\>

Sign a message using BLS12-381

Uses the Ethereum consensus "short signatures" scheme:
- Signature = privateKey * H(message) where H maps to G1
- Signatures are 48 bytes (compressed G1 point)

###### Parameters

###### message

`Uint8Array`\<`ArrayBufferLike`\>

Message to sign

###### privateKey

`Uint8Array`\<`ArrayBufferLike`\>

32-byte private key (scalar in Fr)

###### Returns

`Uint8Array`\<`ArrayBufferLike`\>

Signature as compressed G1 point (48 bytes)

###### Throws

If private key is invalid

###### Throws

If signing fails

###### Example

```javascript
import { Bls12381 } from './crypto/Bls12381/index.js';

const privateKey = Bls12381.randomPrivateKey();
const message = new TextEncoder().encode('Hello, Ethereum!');
const signature = Bls12381.sign(message, privateKey);
```

###### Bls12381.signPoint()

> **signPoint**: (`messagePoint`, `privateKey`) => [`Bls12381G2PointType`](../../index.mdx#bls12381g2pointtype)

Sign a pre-hashed message (G2 point) using BLS12-381

For advanced use when you have already hashed the message to G2.

###### Parameters

###### messagePoint

[`Bls12381G2PointType`](../../index.mdx#bls12381g2pointtype)

Message as G2 point

###### privateKey

`Uint8Array`\<`ArrayBufferLike`\>

32-byte private key (scalar in Fr)

###### Returns

[`Bls12381G2PointType`](../../index.mdx#bls12381g2pointtype)

Signature as G2 point (projective)

###### Throws

If private key is invalid

###### Throws

If signing fails

###### Bls12381.verify()

> **verify**: (`signature`, `message`, `publicKey`) => `boolean`

Verify a BLS12-381 signature

Uses pairing check for verification.

###### Parameters

###### signature

`Uint8Array`\<`ArrayBufferLike`\>

Compressed G1 signature (48 bytes)

###### message

`Uint8Array`\<`ArrayBufferLike`\>

Original message that was signed

###### publicKey

`Uint8Array`\<`ArrayBufferLike`\>

Compressed G2 public key (96 bytes)

###### Returns

`boolean`

True if signature is valid

###### Throws

If verification fails due to invalid inputs

###### Example

```javascript
import { Bls12381 } from './crypto/Bls12381/index.js';

const privateKey = Bls12381.randomPrivateKey();
const publicKey = Bls12381.derivePublicKey(privateKey);
const message = new TextEncoder().encode('Hello!');
const signature = Bls12381.sign(message, privateKey);

const isValid = Bls12381.verify(signature, message, publicKey);
console.log(isValid); // true
```

###### Bls12381.verifyPoint()

> **verifyPoint**: (`signaturePoint`, `messagePoint`, `publicKeyPoint`) => `boolean`

Verify a BLS signature with pre-computed points (advanced)

For use when you have already deserialized the points.

###### Parameters

###### signaturePoint

[`Bls12381G2PointType`](../../index.mdx#bls12381g2pointtype)

Signature as G2 point

###### messagePoint

[`Bls12381G2PointType`](../../index.mdx#bls12381g2pointtype)

Message hash as G2 point

###### publicKeyPoint

[`Bls12381G1PointType`](../../index.mdx#bls12381g1pointtype)

Public key as G1 point

###### Returns

`boolean`

True if signature is valid

##### BN254

> **BN254**: `object` & `object`

BN254 with WASM acceleration

###### Type Declaration

###### deserializeG1()

> **deserializeG1**: (`bytes`) => `G1PointType`

Deserialize G1 point from bytes

###### Parameters

###### bytes

`Uint8Array`\<`ArrayBufferLike`\>

64-byte serialization

###### Returns

`G1PointType`

G1 point

###### See

https://voltaire.tevm.sh/crypto for BN254 cryptography documentation

###### Since

0.0.0

###### Throws

If bytes length is invalid (must be 64 bytes)

###### Example

```javascript
import { deserializeG1 } from './crypto/bn254/deserializeG1.js';
const bytes = new Uint8Array(64);
const point = deserializeG1(bytes);
```

###### deserializeG2()

> **deserializeG2**: (`bytes`) => `G2PointType`

Deserialize G2 point from bytes

###### Parameters

###### bytes

`Uint8Array`\<`ArrayBufferLike`\>

128-byte serialization

###### Returns

`G2PointType`

G2 point

###### See

https://voltaire.tevm.sh/crypto for BN254 cryptography documentation

###### Since

0.0.0

###### Throws

If bytes length is invalid (must be 128 bytes)

###### Example

```javascript
import { deserializeG2 } from './crypto/bn254/deserializeG2.js';
const bytes = new Uint8Array(128);
const point = deserializeG2(bytes);
```

###### Fp

> **Fp**: `__module`

###### Fp2

> **Fp2**: `__module`

###### Fr

> **Fr**: `__module`

###### G1

> **G1**: `__module`

###### G2

> **G2**: `__module`

###### Pairing

> **Pairing**: `__module`

###### serializeG1()

> **serializeG1**: (`point`) => `Uint8Array`\<`ArrayBufferLike`\>

Serialize G1 point to bytes (64 bytes: x || y)

###### Parameters

###### point

`G1PointType`

G1 point

###### Returns

`Uint8Array`\<`ArrayBufferLike`\>

64-byte serialization

###### See

https://voltaire.tevm.sh/crypto for BN254 cryptography documentation

###### Since

0.0.0

###### Throws

###### Example

```javascript
import { serializeG1 } from './crypto/bn254/serializeG1.js';
import * as G1 from './crypto/bn254/G1/index.js';
const point = G1.generator();
const bytes = serializeG1(point);
```

###### serializeG2()

> **serializeG2**: (`point`) => `Uint8Array`\<`ArrayBufferLike`\>

Serialize G2 point to bytes (128 bytes: x.c0 || x.c1 || y.c0 || y.c1)

###### Parameters

###### point

`G2PointType`

G2 point

###### Returns

`Uint8Array`\<`ArrayBufferLike`\>

128-byte serialization

###### See

https://voltaire.tevm.sh/crypto for BN254 cryptography documentation

###### Since

0.0.0

###### Throws

###### Example

```javascript
import { serializeG2 } from './crypto/bn254/serializeG2.js';
import * as G2 from './crypto/bn254/G2/index.js';
const point = G2.generator();
const bytes = serializeG2(point);
```

###### Type Declaration

###### \_wasm

> **\_wasm**: *typeof* [`Bn254Wasm`](namespaces/Bn254Wasm/index.mdx) = `Bn254Wasm`

##### Bytecode

> **Bytecode**: *typeof* [`Bytecode`](../../index.mdx#bytecode)

##### Bytes

> **Bytes**: *typeof* [`Bytes`](../../index.mdx#bytes)

##### Bytes32

> **Bytes32**: *typeof* [`Bytes32`](../../index.mdx#bytes32)

##### Chain

> **Chain**: *typeof* [`Chain`](../../index.mdx#chain-1)

##### Ed25519

> **Ed25519**: `object` & `object`

Ed25519 with WASM acceleration

###### Type Declaration

###### derivePublicKey()

> **derivePublicKey**: (`secretKey`) => `PublicKey`

Derive Ed25519 public key from secret key.

###### Parameters

###### secretKey

`SecretKey`

32-byte Ed25519 secret key (seed)

###### Returns

`PublicKey`

32-byte Ed25519 public key

###### See

https://voltaire.tevm.sh/crypto for crypto documentation

###### Since

0.0.0

###### Throws

If secret key length is invalid or derivation fails

###### Example

```javascript
import * as Ed25519 from './crypto/Ed25519/index.js';
const secretKey = new Uint8Array(32); // Your secret key
const publicKey = Ed25519.derivePublicKey(secretKey);
```

###### keypairFromSeed()

> **keypairFromSeed**: (`seed`) => `object`

Generate Ed25519 keypair from seed deterministically.

###### Parameters

###### seed

`Seed`

32-byte seed for deterministic keypair generation

###### Returns

`object`

Object containing 32-byte secretKey and 32-byte publicKey

###### publicKey

> **publicKey**: `PublicKey`

###### secretKey

> **secretKey**: `SecretKey`

###### See

https://voltaire.tevm.sh/crypto for crypto documentation

###### Since

0.0.0

###### Throws

If seed length is not 32 bytes

###### Throws

If keypair generation fails

###### Example

```javascript
import * as Ed25519 from './crypto/Ed25519/index.js';
const seed = crypto.getRandomValues(new Uint8Array(32));
const keypair = Ed25519.keypairFromSeed(seed);
console.log(keypair.publicKey); // Uint8Array(32)
```

###### PUBLIC\_KEY\_SIZE

> **PUBLIC\_KEY\_SIZE**: `32`

Ed25519 public key size in bytes.

###### See

https://voltaire.tevm.sh/crypto for crypto documentation

###### Since

0.0.0

###### Example

```javascript
import { PUBLIC_KEY_SIZE } from './crypto/Ed25519/constants.js';
const publicKey = new Uint8Array(PUBLIC_KEY_SIZE);
```

###### SECRET\_KEY\_SIZE

> **SECRET\_KEY\_SIZE**: `32`

Ed25519 secret key size in bytes.

###### See

https://voltaire.tevm.sh/crypto for crypto documentation

###### Since

0.0.0

###### Example

```javascript
import { SECRET_KEY_SIZE } from './crypto/Ed25519/constants.js';
const secretKey = new Uint8Array(SECRET_KEY_SIZE);
```

###### SEED\_SIZE

> **SEED\_SIZE**: `32`

Ed25519 seed size in bytes.

###### See

https://voltaire.tevm.sh/crypto for crypto documentation

###### Since

0.0.0

###### Example

```javascript
import { SEED_SIZE } from './crypto/Ed25519/constants.js';
const seed = crypto.getRandomValues(new Uint8Array(SEED_SIZE));
```

###### sign()

> **sign**: (`message`, `secretKey`) => `Signature`

Sign message with Ed25519 secret key.

Produces deterministic signatures using EdDSA.

###### Parameters

###### message

`Uint8Array`\<`ArrayBufferLike`\>

Message bytes to sign (any length)

###### secretKey

`SecretKey`

32-byte Ed25519 secret key

###### Returns

`Signature`

64-byte Ed25519 signature

###### See

https://voltaire.tevm.sh/crypto for crypto documentation

###### Since

0.0.0

###### Throws

If secret key length is not 32 bytes

###### Throws

If signing operation fails

###### Example

```javascript
import * as Ed25519 from './crypto/Ed25519/index.js';
const message = new TextEncoder().encode('Hello, world!');
const signature = Ed25519.sign(message, secretKey);
```

###### SIGNATURE\_SIZE

> **SIGNATURE\_SIZE**: `64`

Ed25519 signature size in bytes.

###### See

https://voltaire.tevm.sh/crypto for crypto documentation

###### Since

0.0.0

###### Example

```javascript
import { SIGNATURE_SIZE } from './crypto/Ed25519/constants.js';
const signature = new Uint8Array(SIGNATURE_SIZE);
```

###### validatePublicKey()

> **validatePublicKey**: (`publicKey`) => `boolean`

Validate Ed25519 public key format and curve membership.

###### Parameters

###### publicKey

`PublicKey`

Ed25519 public key to validate

###### Returns

`boolean`

True if public key is valid and on curve, false otherwise

###### See

https://voltaire.tevm.sh/crypto for crypto documentation

###### Since

0.0.0

###### Throws

###### Example

```javascript
import * as Ed25519 from './crypto/Ed25519/index.js';
const isValid = Ed25519.validatePublicKey(publicKey);
if (!isValid) console.log('Invalid public key');
```

###### validateSecretKey()

> **validateSecretKey**: (`secretKey`) => `boolean`

Validate Ed25519 secret key format.

Checks length and attempts public key derivation.

###### Parameters

###### secretKey

`SecretKey`

Ed25519 secret key to validate

###### Returns

`boolean`

True if secret key is valid (32 bytes and can derive public key), false otherwise

###### See

https://voltaire.tevm.sh/crypto for crypto documentation

###### Since

0.0.0

###### Throws

###### Example

```javascript
import * as Ed25519 from './crypto/Ed25519/index.js';
const isValid = Ed25519.validateSecretKey(secretKey);
if (!isValid) console.log('Invalid secret key');
```

###### validateSeed()

> **validateSeed**: (`seed`) => `boolean`

Validate Ed25519 seed format.

Checks if seed has correct 32-byte length.

###### Parameters

###### seed

`Seed`

Ed25519 seed to validate

###### Returns

`boolean`

True if seed is exactly 32 bytes, false otherwise

###### See

https://voltaire.tevm.sh/crypto for crypto documentation

###### Since

0.0.0

###### Throws

###### Example

```javascript
import * as Ed25519 from './crypto/Ed25519/index.js';
const seed = crypto.getRandomValues(new Uint8Array(32));
const isValid = Ed25519.validateSeed(seed); // true
```

###### verify()

> **verify**: (`signature`, `message`, `publicKey`) => `boolean`

Verify Ed25519 signature.

Returns false on verification failure instead of throwing.

###### Parameters

###### signature

`Signature`

64-byte Ed25519 signature to verify

###### message

`Uint8Array`\<`ArrayBufferLike`\>

Original message bytes that were signed

###### publicKey

`PublicKey`

32-byte Ed25519 public key

###### Returns

`boolean`

True if signature is cryptographically valid, false otherwise

###### See

https://voltaire.tevm.sh/crypto for crypto documentation

###### Since

0.0.0

###### Throws

If public key length is not 32 bytes

###### Throws

If signature length is not 64 bytes

###### Example

```javascript
import * as Ed25519 from './crypto/Ed25519/index.js';
const valid = Ed25519.verify(signature, message, publicKey);
if (valid) console.log('Signature verified');
```

###### Type Declaration

###### \_wasm

> **\_wasm**: *typeof* [`Ed25519Wasm`](namespaces/Ed25519Wasm.mdx) = `Ed25519Wasm`

##### EIP712

> **EIP712**: `object` & `object`

EIP712 with WASM acceleration

###### Type Declaration

###### Domain

> **Domain**: `object`

###### Domain.hash()

> **hash**: (`domain`) => [`HashType`](../HashType-2.mdx#hashtype) = `hashDomain`

###### Parameters

###### domain

`Domain`

###### Returns

[`HashType`](../HashType-2.mdx#hashtype)

###### encodeData()

> **encodeData**: (`primaryType`, `data`, `types`) => `Uint8Array`

###### Parameters

###### primaryType

`string`

###### data

`Message`

###### types

`TypeDefinitions`

###### Returns

`Uint8Array`

###### EncodeData()

> **EncodeData**: (`deps`) => (`primaryType`, `data`, `types`) => `Uint8Array`

Factory: Encode struct data according to EIP-712.

###### Parameters

###### deps

Crypto dependencies

###### encodeValue

(`type`, `value`, `types`) => `Uint8Array`

Encode value function

###### hashType

(`primaryType`, `types`) => [`HashType`](../HashType-2.mdx#hashtype)

Hash type function

###### Returns

Function that encodes data

> (`primaryType`, `data`, `types`): `Uint8Array`

###### Parameters

###### primaryType

`string`

###### data

`Message`

###### types

`TypeDefinitions`

###### Returns

`Uint8Array`

###### See

https://voltaire.tevm.sh/crypto for crypto documentation

###### Since

0.0.0

###### Throws

If primaryType is not found in types

###### Throws

If required field is missing from data

###### Example

```javascript
import { EncodeData } from './crypto/EIP712/encodeData.js';
import { HashType } from './hashType.js';
import { EncodeValue } from './encodeValue.js';
import { hash as keccak256 } from '../Keccak256/hash.js';
const hashType = HashType({ keccak256 });
const encodeValue = EncodeValue({ keccak256, hashStruct });
const encodeData = EncodeData({ hashType, encodeValue });
const types = { Person: [{ name: 'name', type: 'string' }, { name: 'wallet', type: 'address' }] };
const encoded = encodeData('Person', { name: 'Alice', wallet: '0x...' }, types);
```

###### encodeType()

> **encodeType**: (`primaryType`, `types`) => `string`

Encode type string for EIP-712 hashing.

Produces type encoding like "Mail(Person from,Person to,string contents)Person(string name,address wallet)"

###### Parameters

###### primaryType

`string`

Primary type name to encode

###### types

`TypeDefinitions`

Type definitions mapping

###### Returns

`string`

Encoded type string with primary type followed by referenced types in alphabetical order

###### See

https://voltaire.tevm.sh/crypto for crypto documentation

###### Since

0.0.0

###### Throws

If primaryType or any referenced type is not found

###### Example

```javascript
import * as EIP712 from './crypto/EIP712/index.js';
const types = { Mail: [{ name: 'from', type: 'Person' }], Person: [{ name: 'name', type: 'string' }] };
const typeString = EIP712.encodeType('Mail', types);
// Returns: "Mail(Person from)Person(string name)"
```

###### encodeValue()

> **encodeValue**: (`type`, `value`, `types`) => `Uint8Array`

###### Parameters

###### type

`string`

###### value

`MessageValue`

###### types

`TypeDefinitions`

###### Returns

`Uint8Array`

###### EncodeValue()

> **EncodeValue**: (`deps`) => (`type`, `value`, `types`) => `Uint8Array`

Factory: Encode single value to 32 bytes according to EIP-712.

Handles primitive types, arrays, strings, bytes, and custom structs.
Addresses must be pre-validated BrandedAddress types.

###### Parameters

###### deps

Crypto dependencies

###### hashStruct

(`type`, `data`, `types`) => [`HashType`](../HashType-2.mdx#hashtype)

Hash struct function

###### keccak256

(`data`) => `Uint8Array`

Keccak256 hash function

###### Returns

Function that encodes value

> (`type`, `value`, `types`): `Uint8Array`

###### Parameters

###### type

`string`

###### value

`MessageValue`

###### types

`TypeDefinitions`

###### Returns

`Uint8Array`

###### See

https://voltaire.tevm.sh/crypto for crypto documentation

###### Since

0.0.0

###### Throws

If type is unsupported or value format is invalid

###### Example

```javascript
import { EncodeValue } from './crypto/EIP712/encodeValue.js';
import { hash as keccak256 } from '../Keccak256/hash.js';
import { HashStruct } from './hashStruct.js';
const hashStruct = HashStruct({ keccak256, encodeData });
const encodeValue = EncodeValue({ keccak256, hashStruct });
const encoded = encodeValue('uint256', 42n, types);
```

###### format()

> **format**: (`typedData`) => `string`

Format typed data for human-readable display.

###### Parameters

###### typedData

`TypedData`

Typed data to format

###### Returns

`string`

Human-readable multi-line string representation

###### See

https://voltaire.tevm.sh/crypto for crypto documentation

###### Since

0.0.0

###### Throws

###### Example

```javascript
import * as EIP712 from './crypto/EIP712/index.js';
const formatted = EIP712.format(typedData);
console.log(formatted);
```

###### HashDomain()

> **HashDomain**: (`deps`) => (`domain`) => [`HashType`](../HashType-2.mdx#hashtype)

Factory: Hash EIP-712 domain separator.

Only includes fields that are defined in the domain object.

###### Parameters

###### deps

Crypto dependencies

###### hashStruct

(`primaryType`, `data`, `types`) => [`HashType`](../HashType-2.mdx#hashtype)

Hash struct function

###### Returns

Function that hashes domain

> (`domain`): [`HashType`](../HashType-2.mdx#hashtype)

###### Parameters

###### domain

`Domain`

###### Returns

[`HashType`](../HashType-2.mdx#hashtype)

###### See

https://voltaire.tevm.sh/crypto for crypto documentation

###### Since

0.0.0

###### Throws

If domain type encoding fails

###### Example

```javascript
import { Hash as HashDomain } from './crypto/EIP712/Domain/hash.js';
import { HashStruct } from '../hashStruct.js';
import { hash as keccak256 } from '../../Keccak256/hash.js';
const hashStruct = HashStruct({ keccak256, encodeData });
const hashDomain = HashDomain({ hashStruct });
const domain = { name: 'MyApp', version: '1', chainId: 1n };
const domainHash = hashDomain(domain);
```

###### hashStruct()

> **hashStruct**: (`primaryType`, `data`, `types`) => [`HashType`](../HashType-2.mdx#hashtype)

###### Parameters

###### primaryType

`string`

###### data

`Message`

###### types

`TypeDefinitions`

###### Returns

[`HashType`](../HashType-2.mdx#hashtype)

###### HashStruct()

> **HashStruct**: (`deps`) => (`primaryType`, `data`, `types`) => [`HashType`](../HashType-2.mdx#hashtype)

Factory: Hash struct according to EIP-712 specification.

Computes keccak256 of the encoded struct data.

###### Parameters

###### deps

Crypto dependencies

###### encodeData

(`primaryType`, `data`, `types`) => `Uint8Array`

Encode data function

###### keccak256

(`data`) => `Uint8Array`

Keccak256 hash function

###### Returns

Function that hashes struct

> (`primaryType`, `data`, `types`): [`HashType`](../HashType-2.mdx#hashtype)

###### Parameters

###### primaryType

`string`

###### data

`Message`

###### types

`TypeDefinitions`

###### Returns

[`HashType`](../HashType-2.mdx#hashtype)

###### See

https://voltaire.tevm.sh/crypto for crypto documentation

###### Since

0.0.0

###### Throws

If type is not found

###### Throws

If message data is invalid

###### Example

```javascript
import { HashStruct } from './crypto/EIP712/hashStruct.js';
import { hash as keccak256 } from '../Keccak256/hash.js';
import { EncodeData } from './encodeData.js';
const encodeData = EncodeData({ hashType, encodeValue });
const hashStruct = HashStruct({ keccak256, encodeData });
const types = { Person: [{ name: 'name', type: 'string' }] };
const hash = hashStruct('Person', { name: 'Alice' }, types);
```

###### hashType()

> **hashType**: (`primaryType`, `types`) => [`HashType`](../HashType-2.mdx#hashtype)

###### Parameters

###### primaryType

`string`

###### types

`TypeDefinitions`

###### Returns

[`HashType`](../HashType-2.mdx#hashtype)

###### HashType()

> **HashType**: (`deps`) => (`primaryType`, `types`) => [`HashType`](../HashType-2.mdx#hashtype)

Factory: Hash type string according to EIP-712.

Computes keccak256 of the encoded type string.

###### Parameters

###### deps

Crypto dependencies

###### keccak256

(`data`) => `Uint8Array`

Keccak256 hash function

###### Returns

Function that hashes type string

> (`primaryType`, `types`): [`HashType`](../HashType-2.mdx#hashtype)

###### Parameters

###### primaryType

`string`

###### types

`TypeDefinitions`

###### Returns

[`HashType`](../HashType-2.mdx#hashtype)

###### See

https://voltaire.tevm.sh/crypto for crypto documentation

###### Since

0.0.0

###### Throws

If type is not found

###### Example

```javascript
import { HashType } from './crypto/EIP712/hashType.js';
import { hash as keccak256 } from '../Keccak256/hash.js';
const hashType = HashType({ keccak256 });
const types = { Mail: [{ name: 'contents', type: 'string' }] };
const typeHash = hashType('Mail', types);
```

###### hashTypedData()

> **hashTypedData**: (`typedData`) => [`HashType`](../HashType-2.mdx#hashtype)

###### Parameters

###### typedData

`TypedData`

###### Returns

[`HashType`](../HashType-2.mdx#hashtype)

###### HashTypedData()

> **HashTypedData**: (`deps`) => (`typedData`) => [`HashType`](../HashType-2.mdx#hashtype)

Factory: Hash typed data according to EIP-712 specification.

Computes: keccak256("\x19\x01" ‖ domainSeparator ‖ hashStruct(message))

###### Parameters

###### deps

Crypto dependencies

###### hashDomain

(`domain`) => [`HashType`](../HashType-2.mdx#hashtype)

Hash domain function

###### hashStruct

(`primaryType`, `data`, `types`) => [`HashType`](../HashType-2.mdx#hashtype)

Hash struct function

###### keccak256

(`data`) => `Uint8Array`

Keccak256 hash function

###### Returns

Function that hashes typed data

> (`typedData`): [`HashType`](../HashType-2.mdx#hashtype)

###### Parameters

###### typedData

`TypedData`

###### Returns

[`HashType`](../HashType-2.mdx#hashtype)

###### See

https://voltaire.tevm.sh/crypto for crypto documentation

###### Since

0.0.0

###### Throws

If types are not found

###### Throws

If message data is invalid

###### Example

```javascript
import { HashTypedData } from './crypto/EIP712/hashTypedData.js';
import { hash as keccak256 } from '../Keccak256/hash.js';
import { Hash as HashDomain } from './Domain/hash.js';
import { HashStruct } from './hashStruct.js';
const hashDomain = HashDomain({ hashStruct });
const hashStruct = HashStruct({ keccak256, encodeData });
const hashTypedData = HashTypedData({ keccak256, hashDomain, hashStruct });
const hash = hashTypedData(typedData);
```

###### recoverAddress()

> **recoverAddress**: (`signature`, `typedData`) => [`AddressType`](../../../primitives/Address.mdx#addresstype)

###### Parameters

###### signature

`Signature`

###### typedData

`TypedData`

###### Returns

[`AddressType`](../../../primitives/Address.mdx#addresstype)

###### RecoverAddress()

> **RecoverAddress**: (`deps`) => (`signature`, `typedData`) => [`AddressType`](../../../primitives/Address.mdx#addresstype)

Factory: Recover Ethereum address from EIP-712 typed data signature.

Uses ECDSA public key recovery to determine the signer's address.

###### Parameters

###### deps

Crypto dependencies

###### hashTypedData

(`typedData`) => [`HashType`](../HashType-2.mdx#hashtype)

Hash typed data function

###### keccak256

(`data`) => `Uint8Array`

Keccak256 hash function

###### recoverPublicKey

(`signature`, `hash`, `recoveryBit`) => `Uint8Array`

Secp256k1 public key recovery function

###### Returns

Function that recovers address

> (`signature`, `typedData`): [`AddressType`](../../../primitives/Address.mdx#addresstype)

###### Parameters

###### signature

`Signature`

###### typedData

`TypedData`

###### Returns

[`AddressType`](../../../primitives/Address.mdx#addresstype)

###### See

https://voltaire.tevm.sh/crypto for crypto documentation

###### Since

0.0.0

###### Throws

If signature recovery fails or public key format is invalid

###### Example

```javascript
import { RecoverAddress } from './crypto/EIP712/recoverAddress.js';
import { hash as keccak256 } from '../Keccak256/hash.js';
import { recoverPublicKey } from '../Secp256k1/recoverPublicKey.js';
import { HashTypedData } from './hashTypedData.js';
const hashTypedData = HashTypedData({ keccak256, hashDomain, hashStruct });
const recoverAddress = RecoverAddress({ keccak256, recoverPublicKey, hashTypedData });
const address = recoverAddress(signature, typedData);
```

###### signTypedData()

> **signTypedData**: (`typedData`, `privateKey`) => `Signature`

###### Parameters

###### typedData

`any`

###### privateKey

`any`

###### Returns

`Signature`

###### SignTypedData()

> **SignTypedData**: (`deps`) => (`typedData`, `privateKey`) => `Signature`

Factory: Sign EIP-712 typed data with ECDSA private key.

Produces a signature that can be verified against the signer's address.

###### Parameters

###### deps

Crypto dependencies

###### hashTypedData

(`typedData`) => [`HashType`](../HashType-2.mdx#hashtype)

Hash typed data function

###### sign

(`hash`, `privateKey`) => `Signature`

Secp256k1 sign function

###### Returns

Function that signs typed data

> (`typedData`, `privateKey`): `Signature`

###### Parameters

###### typedData

`TypedData`

###### privateKey

`Uint8Array`

###### Returns

`Signature`

###### See

https://voltaire.tevm.sh/crypto for crypto documentation

###### Since

0.0.0

###### Throws

If private key length is invalid or signing fails

###### Example

```javascript
import { SignTypedData } from './crypto/EIP712/signTypedData.js';
import { HashTypedData } from './hashTypedData.js';
import { sign } from '../Secp256k1/sign.js';
import { hash as keccak256 } from '../Keccak256/hash.js';
const hashTypedData = HashTypedData({ keccak256, hashDomain, hashStruct });
const signTypedData = SignTypedData({ hashTypedData, sign });
const privateKey = new Uint8Array(32);
const signature = signTypedData(typedData, privateKey);
```

###### validate()

> **validate**: (`typedData`) => `void`

Validate typed data structure against EIP-712 specification.

Checks domain, types, primaryType, and message structure.

###### Parameters

###### typedData

`TypedData`

Typed data to validate

###### Returns

`void`

###### See

https://voltaire.tevm.sh/crypto for crypto documentation

###### Since

0.0.0

###### Throws

If structure is invalid or missing required fields

###### Example

```javascript
import * as EIP712 from './crypto/EIP712/index.js';
EIP712.validate(typedData); // Throws if invalid
```

###### verifyTypedData()

> **verifyTypedData**: (`signature`, `typedData`, `address`) => `boolean`

###### Parameters

###### signature

`Signature`

###### typedData

`TypedData`

###### address

[`AddressType`](../../../primitives/Address.mdx#addresstype)

###### Returns

`boolean`

###### VerifyTypedData()

> **VerifyTypedData**: (`deps`) => (`signature`, `typedData`, `address`) => `boolean`

Factory: Verify EIP-712 typed data signature against expected signer address.

Uses constant-time comparison to prevent timing attacks.

###### Parameters

###### deps

Crypto dependencies

###### recoverAddress

(`signature`, `typedData`) => [`AddressType`](../../../primitives/Address.mdx#addresstype)

Recover address function

###### Returns

Function that verifies signature

> (`signature`, `typedData`, `address`): `boolean`

###### Parameters

###### signature

`Signature`

###### typedData

`TypedData`

###### address

[`AddressType`](../../../primitives/Address.mdx#addresstype)

###### Returns

`boolean`

###### See

https://voltaire.tevm.sh/crypto for crypto documentation

###### Since

0.0.0

###### Throws

###### Example

```javascript
import { VerifyTypedData } from './crypto/EIP712/verifyTypedData.js';
import { RecoverAddress } from './recoverAddress.js';
import { hash as keccak256 } from '../Keccak256/hash.js';
import { recoverPublicKey } from '../Secp256k1/recoverPublicKey.js';
const recoverAddress = RecoverAddress({ keccak256, recoverPublicKey, hashTypedData });
const verifyTypedData = VerifyTypedData({ recoverAddress });
const valid = verifyTypedData(signature, typedData, signerAddress);
```

###### Type Declaration

###### \_wasm

> **\_wasm**: *typeof* [`Eip712Wasm`](namespaces/Eip712Wasm/index.mdx) = `Eip712Wasm`

##### Ether

> **Ether**: `EtherConstructor`

##### Gwei

> **Gwei**: `GweiConstructor`

##### Hash

> **Hash**: `HashConstructor`

##### Hex

> **Hex**: *typeof* [`Hex`](../../index.mdx#hex)

##### Keccak256

> **Keccak256**: (`input`) => [`Keccak256Hash`](../../index.mdx#keccak256hash) & `object` & `object`

Keccak256 with WASM acceleration
Falls back to JS implementation, but WASM methods available via `_wasm`

###### Type Declaration

###### contractAddress()

> **contractAddress**: (`sender`, `nonce`) => `Uint8Array`\<`ArrayBufferLike`\>

Compute contract address from deployer and nonce

Uses CREATE formula: keccak256(rlp([sender, nonce]))[12:]

###### Parameters

###### sender

`Uint8Array`\<`ArrayBufferLike`\>

Deployer address (20 bytes)

###### nonce

`bigint`

Transaction nonce

###### Returns

`Uint8Array`\<`ArrayBufferLike`\>

Contract address (20 bytes)

###### See

https://voltaire.tevm.sh/crypto for crypto documentation

###### Since

0.0.0

###### Throws

If sender is not 20 bytes

###### Example

```javascript
import * as Keccak256 from './crypto/Keccak256/index.js';
const sender = new Uint8Array(20);
const address = Keccak256.contractAddress(sender, 0n);
```

###### create2Address()

> **create2Address**: (`sender`, `salt`, `initCodeHash`) => `Uint8Array`\<`ArrayBufferLike`\>

Compute CREATE2 address

Uses CREATE2 formula: keccak256(0xff ++ sender ++ salt ++ keccak256(init_code))[12:]

###### Parameters

###### sender

`Uint8Array`\<`ArrayBufferLike`\>

Deployer address (20 bytes)

###### salt

`Uint8Array`\<`ArrayBufferLike`\>

32-byte salt

###### initCodeHash

`Uint8Array`\<`ArrayBufferLike`\>

Hash of initialization code

###### Returns

`Uint8Array`\<`ArrayBufferLike`\>

Contract address (20 bytes)

###### See

https://voltaire.tevm.sh/crypto for crypto documentation

###### Since

0.0.0

###### Throws

If sender is not 20 bytes

###### Throws

If salt is not 32 bytes

###### Throws

If initCodeHash is not 32 bytes

###### Example

```javascript
import * as Keccak256 from './crypto/Keccak256/index.js';
const sender = new Uint8Array(20);
const salt = new Uint8Array(32);
const initCodeHash = new Uint8Array(32);
const address = Keccak256.create2Address(sender, salt, initCodeHash);
```

###### DIGEST\_SIZE

> **DIGEST\_SIZE**: `number`

Digest size in bytes (32 bytes = 256 bits)

###### Since

0.0.0

###### from()

> **from**: (`input`) => [`Keccak256Hash`](../../index.mdx#keccak256hash)

Hash input with Keccak-256 (constructor pattern)

Auto-detects input type and hashes accordingly:
- Uint8Array: hash directly
- string starting with 0x: parse as hex
- string: UTF-8 encode then hash

###### Parameters

###### input

Data to hash

`string` | `Uint8Array`\<`ArrayBufferLike`\>

###### Returns

[`Keccak256Hash`](../../index.mdx#keccak256hash)

32-byte hash

###### See

https://voltaire.tevm.sh/crypto/keccak256 for crypto documentation

###### Since

0.0.0

###### Throws

If hex string is invalid

###### Example

```javascript
import { Keccak256Hash } from './crypto/Keccak256/index.js';

const hash1 = Keccak256Hash.from("0x1234");      // Hex
const hash2 = Keccak256Hash.from("hello");       // String
const hash3 = Keccak256Hash.from(uint8array);    // Bytes
```

###### fromHex()

> **fromHex**: (`hex`) => [`Keccak256Hash`](../../index.mdx#keccak256hash) = `hashHex`

Hash hex string with Keccak-256

###### Parameters

###### hex

`string`

Hex string to hash (with or without 0x prefix)

###### Returns

[`Keccak256Hash`](../../index.mdx#keccak256hash)

32-byte hash

###### See

https://voltaire.tevm.sh/crypto for crypto documentation

###### Since

0.0.0

###### Throws

If hex string is invalid or has odd length

###### Example

```javascript
import { Keccak256Hash } from './crypto/Keccak256/index.js';
const hash = Keccak256Hash.fromHex('0x1234abcd');
```

###### fromString()

> **fromString**: (`str`) => [`Keccak256Hash`](../../index.mdx#keccak256hash) = `hashString`

Hash string with Keccak-256

String is UTF-8 encoded before hashing.

###### Parameters

###### str

`string`

String to hash

###### Returns

[`Keccak256Hash`](../../index.mdx#keccak256hash)

32-byte hash

###### See

https://voltaire.tevm.sh/crypto for crypto documentation

###### Since

0.0.0

###### Throws

###### Example

```javascript
import { Keccak256Hash } from './crypto/Keccak256/index.js';
const hash = Keccak256Hash.fromString('hello');
```

###### fromTopic()

> **fromTopic**: (`signature`) => [`Keccak256Hash`](../../index.mdx#keccak256hash) = `topic`

Compute event topic (32-byte Keccak-256 hash)

Used for Ethereum event signatures.

###### Parameters

###### signature

`string`

Event signature string

###### Returns

[`Keccak256Hash`](../../index.mdx#keccak256hash)

32-byte topic

###### See

https://voltaire.tevm.sh/crypto for crypto documentation

###### Since

0.0.0

###### Throws

###### Example

```javascript
import { Keccak256Hash } from './crypto/Keccak256/index.js';
const topic = Keccak256Hash.fromTopic('Transfer(address,address,uint256)');
```

###### hash()

> **hash**: (`data`) => [`Keccak256Hash`](../../index.mdx#keccak256hash)

Hash data with Keccak-256

###### Parameters

###### data

`Uint8Array`\<`ArrayBufferLike`\>

Data to hash

###### Returns

[`Keccak256Hash`](../../index.mdx#keccak256hash)

32-byte hash

###### See

https://voltaire.tevm.sh/crypto for crypto documentation

###### Since

0.0.0

###### Throws

###### Example

```javascript
import { Keccak256Hash } from './crypto/Keccak256/index.js';
const hash = Keccak256Hash.from(data);
```

###### hashHex()

> **hashHex**: (`hex`) => [`Keccak256Hash`](../../index.mdx#keccak256hash)

Hash hex string with Keccak-256

###### Parameters

###### hex

`string`

Hex string to hash (with or without 0x prefix)

###### Returns

[`Keccak256Hash`](../../index.mdx#keccak256hash)

32-byte hash

###### See

https://voltaire.tevm.sh/crypto for crypto documentation

###### Since

0.0.0

###### Throws

If hex string is invalid or has odd length

###### Example

```javascript
import { Keccak256Hash } from './crypto/Keccak256/index.js';
const hash = Keccak256Hash.fromHex('0x1234abcd');
```

###### hashMultiple()

> **hashMultiple**: (`chunks`) => [`Keccak256Hash`](../../index.mdx#keccak256hash)

Hash multiple data chunks in sequence

Equivalent to hashing the concatenation of all chunks.

###### Parameters

###### chunks

readonly `Uint8Array`\<`ArrayBufferLike`\>[]

Array of data chunks to hash

###### Returns

[`Keccak256Hash`](../../index.mdx#keccak256hash)

32-byte hash

###### See

https://voltaire.tevm.sh/crypto for crypto documentation

###### Since

0.0.0

###### Throws

###### Example

```javascript
import { Keccak256Hash } from './crypto/Keccak256/index.js';
const hash = Keccak256Hash.from(combined);
```

###### hashString()

> **hashString**: (`str`) => [`Keccak256Hash`](../../index.mdx#keccak256hash)

Hash string with Keccak-256

String is UTF-8 encoded before hashing.

###### Parameters

###### str

`string`

String to hash

###### Returns

[`Keccak256Hash`](../../index.mdx#keccak256hash)

32-byte hash

###### See

https://voltaire.tevm.sh/crypto for crypto documentation

###### Since

0.0.0

###### Throws

###### Example

```javascript
import { Keccak256Hash } from './crypto/Keccak256/index.js';
const hash = Keccak256Hash.fromString('hello');
```

###### RATE

> **RATE**: `number`

Rate in bytes for Keccak256 (136 bytes = 1088 bits)

###### Since

0.0.0

###### selector()

> **selector**: (`signature`) => `Uint8Array`\<`ArrayBufferLike`\>

Compute function selector (first 4 bytes of Keccak-256 hash)

Used for Ethereum function signatures.

###### Parameters

###### signature

`string`

Function signature string

###### Returns

`Uint8Array`\<`ArrayBufferLike`\>

4-byte selector

###### See

https://voltaire.tevm.sh/crypto for crypto documentation

###### Since

0.0.0

###### Throws

###### Example

```javascript
import * as Keccak256 from './crypto/Keccak256/index.js';
const selector = Keccak256.selector('transfer(address,uint256)');
// Uint8Array(4) [0xa9, 0x05, 0x9c, 0xbb]
```

###### STATE\_SIZE

> **STATE\_SIZE**: `number`

State size (25 u64 words = 1600 bits)

###### Since

0.0.0

###### topic()

> **topic**: (`signature`) => [`Keccak256Hash`](../../index.mdx#keccak256hash)

Compute event topic (32-byte Keccak-256 hash)

Used for Ethereum event signatures.

###### Parameters

###### signature

`string`

Event signature string

###### Returns

[`Keccak256Hash`](../../index.mdx#keccak256hash)

32-byte topic

###### See

https://voltaire.tevm.sh/crypto for crypto documentation

###### Since

0.0.0

###### Throws

###### Example

```javascript
import { Keccak256Hash } from './crypto/Keccak256/index.js';
const topic = Keccak256Hash.fromTopic('Transfer(address,address,uint256)');
```

###### Type Declaration

###### \_wasm

> **\_wasm**: `object` = `Keccak256Wasm`

###### \_wasm.contractAddress()

> **contractAddress**: (`sender`, `nonce`) => `Uint8Array`

Compute CREATE contract address

###### Parameters

###### sender

`Uint8Array`

Sender address (20 bytes)

###### nonce

`bigint`

Transaction nonce

###### Returns

`Uint8Array`

Contract address (20 bytes)

###### \_wasm.create2Address()

> **create2Address**: (`sender`, `salt`, `initCodeHash`) => `Uint8Array`

Compute CREATE2 contract address

###### Parameters

###### sender

`Uint8Array`

Sender address (20 bytes)

###### salt

`Uint8Array`

Salt (32 bytes)

###### initCodeHash

`Uint8Array`

Init code hash (32 bytes)

###### Returns

`Uint8Array`

Contract address (20 bytes)

###### \_wasm.DIGEST\_SIZE

> **DIGEST\_SIZE**: `number` = `32`

###### \_wasm.hash()

> **hash**: (`data`) => [`HashType`](../HashType-2.mdx#hashtype)

Hash bytes using Keccak256

###### Parameters

###### data

`Uint8Array`

Input bytes to hash

###### Returns

[`HashType`](../HashType-2.mdx#hashtype)

32-byte Keccak256 hash

###### \_wasm.hashHex()

> **hashHex**: (`hex`) => [`HashType`](../HashType-2.mdx#hashtype)

Hash a hex string

###### Parameters

###### hex

`string`

Hex string to hash (with or without 0x prefix)

###### Returns

[`HashType`](../HashType-2.mdx#hashtype)

32-byte Keccak256 hash

###### \_wasm.hashMultiple()

> **hashMultiple**: (`chunks`) => [`HashType`](../HashType-2.mdx#hashtype)

Hash multiple byte arrays in sequence

###### Parameters

###### chunks

`Uint8Array`\<`ArrayBufferLike`\>[]

Array of byte arrays to hash

###### Returns

[`HashType`](../HashType-2.mdx#hashtype)

32-byte Keccak256 hash

###### \_wasm.hashString()

> **hashString**: (`str`) => [`HashType`](../HashType-2.mdx#hashtype)

Hash a UTF-8 string

###### Parameters

###### str

`string`

String to hash

###### Returns

[`HashType`](../HashType-2.mdx#hashtype)

32-byte Keccak256 hash

###### \_wasm.init()

> **init**: () => `Promise`\<`void`\>

Initialize WASM module (must be called before using any functions)

###### Returns

`Promise`\<`void`\>

###### \_wasm.isReady()

> **isReady**: () => `boolean`

Check if WASM is initialized

###### Returns

`boolean`

###### \_wasm.RATE

> **RATE**: `number` = `136`

###### \_wasm.selector()

> **selector**: (`signature`) => `Uint8Array`

Compute function selector (first 4 bytes of hash)

###### Parameters

###### signature

`string`

Function signature string (e.g., "transfer(address,uint256)")

###### Returns

`Uint8Array`

4-byte function selector

###### \_wasm.STATE\_SIZE

> **STATE\_SIZE**: `number` = `25`

###### \_wasm.topic()

> **topic**: (`signature`) => [`HashType`](../HashType-2.mdx#hashtype)

Compute event topic (full 32-byte hash)

###### Parameters

###### signature

`string`

Event signature string (e.g., "Transfer(address,address,uint256)")

###### Returns

[`HashType`](../HashType-2.mdx#hashtype)

32-byte event topic as HashType

##### KZG

> **KZG**: *typeof* [`KZG`](../../index.mdx#kzg)

##### ModExp

> **ModExp**: (`base`, `exp`, `modulus`) => `bigint` & `object`

###### Type Declaration

###### calculateGas()

> **calculateGas**: (`baseLen`, `expLen`, `modLen`, `expHead`) => `bigint`

Calculate gas cost for MODEXP operation per EIP-2565

Gas formula: max(200, floor(mult_complexity * iteration_count / 3))

###### Parameters

###### baseLen

`bigint`

Length of base in bytes

###### expLen

`bigint`

Length of exponent in bytes

###### modLen

`bigint`

Length of modulus in bytes

###### expHead

`bigint`

First 32 bytes of exponent as BigInt (for leading zeros calc)

###### Returns

`bigint`

Gas cost

###### See

https://eips.ethereum.org/EIPS/eip-2565

###### Since

0.0.0

###### Example

```javascript
import { ModExp } from './crypto/ModExp/index.js';

// Calculate gas for 2^3 mod 5
const gas = ModExp.calculateGas(1n, 1n, 1n, 3n);
console.log(gas); // 200n (minimum)
```

###### modexp()

> **modexp**: (`base`, `exp`, `modulus`) => `bigint`

Modular exponentiation: base^exp mod modulus

Computes arbitrary-precision modular exponentiation using native BigInt.
Used by MODEXP precompile (0x05) per EIP-198.

WARNING: This implementation is for general use. For cryptographic
applications, consider timing attack resistance.

###### Parameters

###### base

`bigint`

Base value

###### exp

`bigint`

Exponent value

###### modulus

`bigint`

Modulus value (must be > 0)

###### Returns

`bigint`

Result of base^exp mod modulus

###### See

https://eips.ethereum.org/EIPS/eip-198

###### Since

0.0.0

###### Throws

If modulus is zero

###### Example

```javascript
import { ModExp } from './crypto/ModExp/index.js';

// Compute 2^10 mod 1000 = 24
const result = ModExp.modexp(2n, 10n, 1000n);
console.log(result); // 24n

// RSA verification: signature^e mod n
const verified = ModExp.modexp(signature, e, n);
```

###### modexpBytes()

> **modexpBytes**: (`baseBytes`, `expBytes`, `modBytes`) => `Uint8Array`\<`ArrayBufferLike`\>

Modular exponentiation with byte array inputs/outputs

Computes base^exp mod modulus where inputs are big-endian byte arrays.
Output is padded to modulus length per EIP-198 spec.

###### Parameters

###### baseBytes

`Uint8Array`\<`ArrayBufferLike`\>

Base as big-endian bytes

###### expBytes

`Uint8Array`\<`ArrayBufferLike`\>

Exponent as big-endian bytes

###### modBytes

`Uint8Array`\<`ArrayBufferLike`\>

Modulus as big-endian bytes

###### Returns

`Uint8Array`\<`ArrayBufferLike`\>

Result as big-endian bytes, padded to modulus length

###### See

https://eips.ethereum.org/EIPS/eip-198

###### Since

0.0.0

###### Throws

If modulus is zero

###### Example

```javascript
import { ModExp } from './crypto/ModExp/index.js';

const base = new Uint8Array([0x02]); // 2
const exp = new Uint8Array([0x03]);  // 3
const mod = new Uint8Array([0x05]);  // 5

const result = ModExp.modexpBytes(base, exp, mod);
console.log(result); // Uint8Array([0x03]) = 3
```

##### Opcode

> **Opcode**: *typeof* [`Opcode`](../../index.mdx#opcode)

##### P256

> **P256**: `P256Constructor` & `object`

P256 with WASM acceleration

###### Type Declaration

###### \_wasm

> **\_wasm**: *typeof* [`P256Wasm`](namespaces/P256Wasm.mdx) = `P256Wasm`

##### Ripemd160

> **Ripemd160**: (`input`) => [`Ripemd160Hash`](../../index.mdx#ripemd160hash) & `object` & `object`

Ripemd160 with WASM acceleration

###### Type Declaration

###### from()

> **from**: (`input`) => [`Ripemd160Hash`](../../index.mdx#ripemd160hash)

Hash input with RIPEMD160 (constructor pattern)

Auto-detects input type and hashes accordingly:
- Uint8Array: hash directly
- string: UTF-8 encode then hash

###### Parameters

###### input

Data to hash

`string` | `Uint8Array`\<`ArrayBufferLike`\>

###### Returns

[`Ripemd160Hash`](../../index.mdx#ripemd160hash)

20-byte hash

###### See

https://voltaire.tevm.sh/crypto/ripemd160 for crypto documentation

###### Since

0.0.0

###### Throws

###### Example

```javascript
import { Ripemd160Hash } from './crypto/Ripemd160/index.js';

const hash1 = Ripemd160Hash.from("hello");           // String
const hash2 = Ripemd160Hash.from(uint8array);        // Bytes
```

###### fromHex()

> **fromHex**: (`hex`) => [`Ripemd160Hash`](../../index.mdx#ripemd160hash) = `hashHex`

Compute RIPEMD160 hash of hex string (without 0x prefix)

###### Parameters

###### hex

`string`

Hex string (with or without 0x prefix)

###### Returns

[`Ripemd160Hash`](../../index.mdx#ripemd160hash)

20-byte hash

###### See

https://voltaire.tevm.sh/crypto for crypto documentation

###### Since

0.0.0

###### Throws

###### Example

```javascript
import { Ripemd160 } from './crypto/Ripemd160/index.js';
const hash = Ripemd160.hashHex("0xdeadbeef");
console.log(hash.length); // 20
```

###### fromString()

> **fromString**: (`str`) => [`Ripemd160Hash`](../../index.mdx#ripemd160hash) = `hashString`

Compute RIPEMD160 hash of UTF-8 string

###### Parameters

###### str

`string`

Input string

###### Returns

[`Ripemd160Hash`](../../index.mdx#ripemd160hash)

20-byte hash

###### See

https://voltaire.tevm.sh/crypto for crypto documentation

###### Since

0.0.0

###### Throws

###### Example

```javascript
import { Ripemd160 } from './crypto/Ripemd160/index.js';
const hash = Ripemd160.hashString("hello");
console.log(hash.length); // 20
```

###### hash()

> **hash**: (`data`) => [`Ripemd160Hash`](../../index.mdx#ripemd160hash)

Compute RIPEMD160 hash (20 bytes)

###### Parameters

###### data

Input data (Uint8Array or string)

`string` | `Uint8Array`\<`ArrayBufferLike`\>

###### Returns

[`Ripemd160Hash`](../../index.mdx#ripemd160hash)

20-byte hash

###### See

https://voltaire.tevm.sh/crypto for crypto documentation

###### Since

0.0.0

###### Throws

###### Example

```javascript
import { Ripemd160 } from './crypto/Ripemd160/index.js';
const hash = Ripemd160.hash(new Uint8Array([1, 2, 3]));
console.log(hash.length); // 20
```

###### hashHex()

> **hashHex**: (`hex`) => [`Ripemd160Hash`](../../index.mdx#ripemd160hash)

Compute RIPEMD160 hash of hex string (without 0x prefix)

###### Parameters

###### hex

`string`

Hex string (with or without 0x prefix)

###### Returns

[`Ripemd160Hash`](../../index.mdx#ripemd160hash)

20-byte hash

###### See

https://voltaire.tevm.sh/crypto for crypto documentation

###### Since

0.0.0

###### Throws

###### Example

```javascript
import { Ripemd160 } from './crypto/Ripemd160/index.js';
const hash = Ripemd160.hashHex("0xdeadbeef");
console.log(hash.length); // 20
```

###### hashString()

> **hashString**: (`str`) => [`Ripemd160Hash`](../../index.mdx#ripemd160hash)

Compute RIPEMD160 hash of UTF-8 string

###### Parameters

###### str

`string`

Input string

###### Returns

[`Ripemd160Hash`](../../index.mdx#ripemd160hash)

20-byte hash

###### See

https://voltaire.tevm.sh/crypto for crypto documentation

###### Since

0.0.0

###### Throws

###### Example

```javascript
import { Ripemd160 } from './crypto/Ripemd160/index.js';
const hash = Ripemd160.hashString("hello");
console.log(hash.length); // 20
```

###### HEX\_SIZE

> **HEX\_SIZE**: `number`

Size of RIPEMD160 hash in hex characters (without 0x prefix)

###### See

https://voltaire.tevm.sh/crypto for crypto documentation

###### Since

0.0.0

###### Throws

###### Example

```javascript
import { HEX_SIZE } from './crypto/Ripemd160/index.js';
console.log(HEX_SIZE); // 40
```

###### SIZE

> **SIZE**: `number`

Size of RIPEMD160 hash in bytes (160 bits)

###### See

https://voltaire.tevm.sh/crypto for crypto documentation

###### Since

0.0.0

###### Throws

###### Example

```javascript
import { SIZE } from './crypto/Ripemd160/index.js';
console.log(SIZE); // 20
```

###### Type Declaration

###### \_wasm

> **\_wasm**: *typeof* [`Ripemd160Wasm`](namespaces/Ripemd160Wasm.mdx) = `Ripemd160Wasm`

##### Rlp

> **Rlp**: *typeof* [`Rlp`](../../index.mdx#rlp)

##### Secp256k1

> **Secp256k1**: `object` & `object`

Secp256k1 with WASM acceleration

###### Type Declaration

###### addPoints()

> **addPoints**: (`pubKey1`, `pubKey2`) => `Secp256k1PublicKeyType`

Add two secp256k1 public key points

Performs elliptic curve point addition: P1 + P2.
Used in ERC-5564 stealth address generation.

###### Parameters

###### pubKey1

`Secp256k1PublicKeyType`

First 64-byte uncompressed public key

###### pubKey2

`Secp256k1PublicKeyType`

Second 64-byte uncompressed public key

###### Returns

`Secp256k1PublicKeyType`

Result 64-byte uncompressed public key

###### See

 - https://voltaire.tevm.sh/crypto for crypto documentation
 - https://eips.ethereum.org/EIPS/eip-5564 for ERC-5564 stealth addresses

###### Since

0.0.0

###### Throws

If either public key is invalid

###### Throws

If point addition fails

###### Example

```javascript
import * as Secp256k1 from './crypto/Secp256k1/index.js';
const pubKey1 = Secp256k1.derivePublicKey(privateKey1);
const pubKey2 = Secp256k1.derivePublicKey(privateKey2);
const sum = Secp256k1.addPoints(pubKey1, pubKey2);
console.log(sum.length); // 64
```

###### createKeyPair()

> **createKeyPair**: () => `object`

Generate a new secp256k1 key pair

###### Returns

`object`

Key pair with 32-byte private key and 65-byte uncompressed public key

###### privateKey

> **privateKey**: `Uint8Array`

###### publicKey

> **publicKey**: `Uint8Array`

###### Example

```javascript
import { Secp256k1 } from './crypto/Secp256k1/index.js';
const { privateKey, publicKey } = Secp256k1.createKeyPair();
```

###### CURVE\_ORDER

> **CURVE\_ORDER**: `bigint`

secp256k1 curve order (number of points on the curve)

###### See

https://voltaire.tevm.sh/crypto for crypto documentation

###### Since

0.0.0

###### Throws

###### Example

```javascript
import { CURVE_ORDER } from './crypto/Secp256k1/index.js';
console.log(CURVE_ORDER); // 0xffffffffffff...
```

###### derivePublicKey()

> **derivePublicKey**: (`privateKey`) => `Secp256k1PublicKeyType`

Derive public key from private key

Computes the public key point from a private key using scalar
multiplication on the secp256k1 curve.

###### Parameters

###### privateKey

`PrivateKeyType`

32-byte private key

###### Returns

`Secp256k1PublicKeyType`

64-byte uncompressed public key

###### See

https://voltaire.tevm.sh/crypto for crypto documentation

###### Since

0.0.0

###### Throws

If private key is invalid

###### Example

```javascript
import * as Secp256k1 from './crypto/Secp256k1/index.js';
import * as PrivateKey from './primitives/PrivateKey/index.js';
const privateKey = PrivateKey.from(new Uint8Array(32));
const publicKey = Secp256k1.derivePublicKey(privateKey);
console.log(publicKey.length); // 64
```

###### ecdh()

> **ecdh**: (`privateKey`, `publicKey`) => `Uint8Array`\<`ArrayBufferLike`\>

Perform ECDH key exchange

Computes shared secret from your private key and their public key.
Returns the x-coordinate of the shared point (32 bytes).

###### Parameters

###### privateKey

`PrivateKeyType`

Your 32-byte private key

###### publicKey

`Secp256k1PublicKeyType`

Their 64-byte uncompressed public key

###### Returns

`Uint8Array`\<`ArrayBufferLike`\>

32-byte shared secret (x-coordinate)

###### See

 - https://voltaire.tevm.sh/crypto for crypto documentation
 - https://eips.ethereum.org/EIPS/eip-5564 for ERC-5564 stealth addresses

###### Since

0.0.0

###### Throws

If private key is invalid

###### Throws

If public key is invalid

###### Throws

If ECDH computation fails

###### Example

```javascript
import * as Secp256k1 from './crypto/Secp256k1/index.js';
const myPrivateKey = new Uint8Array(32);
const theirPublicKey = Secp256k1.derivePublicKey(theirPrivateKey);
const sharedSecret = Secp256k1.ecdh(myPrivateKey, theirPublicKey);
console.log(sharedSecret.length); // 32
```

###### getSharedSecret()

> **getSharedSecret**: (`privateKey`, `publicKey`) => `Uint8Array`\<`ArrayBufferLike`\> = `ecdh`

Perform ECDH key exchange

Computes shared secret from your private key and their public key.
Returns the x-coordinate of the shared point (32 bytes).

###### Parameters

###### privateKey

`PrivateKeyType`

Your 32-byte private key

###### publicKey

`Secp256k1PublicKeyType`

Their 64-byte uncompressed public key

###### Returns

`Uint8Array`\<`ArrayBufferLike`\>

32-byte shared secret (x-coordinate)

###### See

 - https://voltaire.tevm.sh/crypto for crypto documentation
 - https://eips.ethereum.org/EIPS/eip-5564 for ERC-5564 stealth addresses

###### Since

0.0.0

###### Throws

If private key is invalid

###### Throws

If public key is invalid

###### Throws

If ECDH computation fails

###### Example

```javascript
import * as Secp256k1 from './crypto/Secp256k1/index.js';
const myPrivateKey = new Uint8Array(32);
const theirPublicKey = Secp256k1.derivePublicKey(theirPrivateKey);
const sharedSecret = Secp256k1.ecdh(myPrivateKey, theirPublicKey);
console.log(sharedSecret.length); // 32
```

###### isValidPrivateKey()

> **isValidPrivateKey**: (`privateKey`) => `boolean`

Validate private key

Checks that the private key is within valid range [1, n-1] where n
is the curve order.

###### Parameters

###### privateKey

`Uint8Array`\<`ArrayBufferLike`\>

32-byte private key

###### Returns

`boolean`

true if private key is valid, false otherwise

###### See

https://voltaire.tevm.sh/crypto for crypto documentation

###### Since

0.0.0

###### Throws

###### Example

```javascript
import * as Secp256k1 from './crypto/Secp256k1/index.js';
const privateKey = new Uint8Array(32);
const valid = Secp256k1.isValidPrivateKey(privateKey);
```

###### isValidPublicKey()

> **isValidPublicKey**: (`publicKey`) => `publicKey is Secp256k1PublicKeyType`

Validate public key

Checks that the public key is a valid point on the secp256k1 curve.

###### Parameters

###### publicKey

`Uint8Array`\<`ArrayBufferLike`\>

64-byte uncompressed public key

###### Returns

`publicKey is Secp256k1PublicKeyType`

true if public key is valid, false otherwise

###### See

https://voltaire.tevm.sh/crypto for crypto documentation

###### Since

0.0.0

###### Throws

###### Example

```javascript
import * as Secp256k1 from './crypto/Secp256k1/index.js';
const publicKey = new Uint8Array(64);
if (Secp256k1.isValidPublicKey(publicKey)) {
  const branded = publicKey; // now Secp256k1PublicKeyType
}
```

###### isValidSignature()

> **isValidSignature**: (`signature`) => `boolean`

Validate signature components

Checks that r and s are within valid range [1, n-1] where n is the
curve order. Also enforces low-s values to prevent malleability.

###### Parameters

###### signature

`Secp256k1SignatureType`

ECDSA signature to validate (r and s are HashType)

###### Returns

`boolean`

true if signature is valid, false otherwise

###### See

https://voltaire.tevm.sh/crypto for crypto documentation

###### Since

0.0.0

###### Throws

###### Example

```javascript
import * as Secp256k1 from './crypto/Secp256k1/index.js';
import * as Hash from './primitives/Hash/index.js';
const signature = { r: Hash.from(new Uint8Array(32)), s: Hash.from(new Uint8Array(32)), v: 27 };
const valid = Secp256k1.isValidSignature(signature);
```

###### PRIVATE\_KEY\_SIZE

> **PRIVATE\_KEY\_SIZE**: `number`

Private key size in bytes

###### See

https://voltaire.tevm.sh/crypto for crypto documentation

###### Since

0.0.0

###### Throws

###### Example

```javascript
import { PRIVATE_KEY_SIZE } from './crypto/Secp256k1/index.js';
console.log(PRIVATE_KEY_SIZE); // 32
```

###### PrivateKey

> **PrivateKey**: `__module` = `PrivateKeyMethods`

###### PUBLIC\_KEY\_SIZE

> **PUBLIC\_KEY\_SIZE**: `number`

Uncompressed public key size in bytes (64 bytes, no prefix)

###### See

https://voltaire.tevm.sh/crypto for crypto documentation

###### Since

0.0.0

###### Throws

###### Example

```javascript
import { PUBLIC_KEY_SIZE } from './crypto/Secp256k1/index.js';
console.log(PUBLIC_KEY_SIZE); // 64
```

###### PublicKey

> **PublicKey**: `__module` = `PublicKeyMethods`

###### randomPrivateKey()

> **randomPrivateKey**: () => `Uint8Array`\<`ArrayBufferLike`\>

Generate a cryptographically secure random secp256k1 private key

###### Returns

`Uint8Array`\<`ArrayBufferLike`\>

32-byte private key

###### Example

```javascript
import { Secp256k1 } from './crypto/Secp256k1/index.js';
const privateKey = Secp256k1.randomPrivateKey();
const publicKey = Secp256k1.derivePublicKey(privateKey);
```

###### recoverPublicKey()

> **recoverPublicKey**: (`signature`, `messageHash`) => `Secp256k1PublicKeyType`

Recover public key from signature and message hash

Uses the recovery id (v) to recover the exact public key that created
the signature. This is what enables Ethereum's address recovery from
transaction signatures.

###### Parameters

###### signature

ECDSA signature components

###### r

`Uint8Array`\<`ArrayBufferLike`\>

32-byte signature component r

###### s

`Uint8Array`\<`ArrayBufferLike`\>

32-byte signature component s

###### v

`number`

Recovery id (27/28 or 0/1)

###### messageHash

[`HashType`](../HashType-2.mdx#hashtype)

32-byte message hash that was signed

###### Returns

`Secp256k1PublicKeyType`

64-byte uncompressed public key

###### See

https://voltaire.tevm.sh/crypto for crypto documentation

###### Since

0.0.0

###### Throws

If signature or recovery fails

###### Example

```javascript
import * as Secp256k1 from './crypto/Secp256k1/index.js';
import * as Hash from './primitives/Hash/index.js';
const messageHash = Hash.keccak256String('Hello');
const recovered = Secp256k1.recoverPublicKey(
  { r: rBytes, s: sBytes, v: 27 },
  messageHash
);
```

###### recoverPublicKeyFromHash()

> **recoverPublicKeyFromHash**: (`signature`, `hash`) => `Secp256k1PublicKeyType`

Recover public key from signature and pre-hashed message

This is the hash-level API that operates directly on a 32-byte hash.
Use this when you need custom hashing schemes or interop with other libraries.
For standard Ethereum signing, use recoverPublicKey() instead.

Uses the recovery id (v) to recover the exact public key that created
the signature. This is what enables Ethereum's address recovery from
transaction signatures.

###### Parameters

###### signature

ECDSA signature components

###### r

`Uint8Array`\<`ArrayBufferLike`\>

32-byte signature component r

###### s

`Uint8Array`\<`ArrayBufferLike`\>

32-byte signature component s

###### v

`number`

Recovery id (27/28 or 0/1)

###### hash

[`HashType`](../HashType-2.mdx#hashtype)

32-byte hash that was signed (pre-hashed message)

###### Returns

`Secp256k1PublicKeyType`

64-byte uncompressed public key

###### See

https://voltaire.tevm.sh/crypto for crypto documentation

###### Since

0.0.0

###### Throws

If signature or recovery fails

###### Throws

If hash is not 32 bytes

###### Example

```javascript
import * as Secp256k1 from './crypto/Secp256k1/index.js';
import * as Hash from './primitives/Hash/index.js';

// Recover public key from a pre-hashed message (hash-level API)
const hash = Hash.keccak256String('Hello');
const recovered = Secp256k1.recoverPublicKeyFromHash(
  { r: rBytes, s: sBytes, v: 27 },
  hash
);

// For comparison, recoverPublicKey() hashes internally (message-level API)
const recovered2 = Secp256k1.recoverPublicKey(
  { r: rBytes, s: sBytes, v: 27 },
  messageHash
);
```

###### scalarMultiply()

> **scalarMultiply**: (`scalar`) => `Secp256k1PublicKeyType`

Multiply generator point by scalar

Performs scalar multiplication: scalar * G (generator point).
Used in ERC-5564 stealth address generation.

###### Parameters

###### scalar

`Uint8Array`\<`ArrayBufferLike`\>

32-byte scalar value

###### Returns

`Secp256k1PublicKeyType`

Result 64-byte uncompressed public key

###### See

 - https://voltaire.tevm.sh/crypto for crypto documentation
 - https://eips.ethereum.org/EIPS/eip-5564 for ERC-5564 stealth addresses

###### Since

0.0.0

###### Throws

If scalar multiplication fails

###### Example

```javascript
import * as Secp256k1 from './crypto/Secp256k1/index.js';
const scalar = new Uint8Array(32);
scalar[31] = 5; // scalar = 5
const result = Secp256k1.scalarMultiply(scalar);
console.log(result.length); // 64
```

###### sign()

> **sign**: (`messageHash`, `privateKey`) => `Secp256k1SignatureType`

Sign a message hash with a private key

Uses deterministic ECDSA (RFC 6979) for signature generation.
Returns signature with Ethereum-compatible v value (27 or 28).

###### Parameters

###### messageHash

[`HashType`](../HashType-2.mdx#hashtype)

32-byte message hash to sign

###### privateKey

`PrivateKeyType`

32-byte private key

###### Returns

`Secp256k1SignatureType`

ECDSA signature with r, s, v components

###### See

https://voltaire.tevm.sh/crypto for crypto documentation

###### Since

0.0.0

###### Throws

If private key is invalid

###### Throws

If signing fails

###### Example

```javascript
import * as Secp256k1 from './crypto/Secp256k1/index.js';
import * as Hash from './primitives/Hash/index.js';
import * as PrivateKey from './primitives/PrivateKey/index.js';
const messageHash = Hash.keccak256String('Hello!');
const privateKey = PrivateKey.from(new Uint8Array(32));
const signature = Secp256k1.sign(messageHash, privateKey);
```

###### Signature

> **Signature**: `__module` = `SignatureMethods`

###### SIGNATURE\_COMPONENT\_SIZE

> **SIGNATURE\_COMPONENT\_SIZE**: `number`

Signature component size in bytes (r and s are each 32 bytes)

###### See

https://voltaire.tevm.sh/crypto for crypto documentation

###### Since

0.0.0

###### Throws

###### Example

```javascript
import { SIGNATURE_COMPONENT_SIZE } from './crypto/Secp256k1/index.js';
console.log(SIGNATURE_COMPONENT_SIZE); // 32
```

###### signHash()

> **signHash**: (`hash`, `privateKey`) => `Secp256k1SignatureType`

Sign a pre-hashed message with a private key

This is the hash-level API that operates directly on a 32-byte hash.
Use this when you need custom hashing schemes or interop with other libraries.
For standard Ethereum signing, use sign() instead.

Uses deterministic ECDSA (RFC 6979) for signature generation.
Returns signature with Ethereum-compatible v value (27 or 28).

###### Parameters

###### hash

[`HashType`](../HashType-2.mdx#hashtype)

32-byte hash to sign (pre-hashed message)

###### privateKey

`PrivateKeyType`

32-byte private key

###### Returns

`Secp256k1SignatureType`

ECDSA signature with r, s, v components

###### See

https://voltaire.tevm.sh/crypto for crypto documentation

###### Since

0.0.0

###### Throws

If private key is invalid

###### Throws

If signing fails or hash is not 32 bytes

###### Example

```javascript
import * as Secp256k1 from './crypto/Secp256k1/index.js';
import * as Hash from './primitives/Hash/index.js';
import * as PrivateKey from './primitives/PrivateKey/index.js';

// Sign a pre-hashed message (hash-level API)
const hash = Hash.keccak256String('Hello!');
const privateKey = PrivateKey.from(new Uint8Array(32));
const signature = Secp256k1.signHash(hash, privateKey);

// For comparison, sign() hashes internally (message-level API)
const signature2 = Secp256k1.sign(Hash.keccak256String('Hello!'), privateKey);
```

###### verify()

> **verify**: (`signature`, `messageHash`, `publicKey`) => `boolean`

Verify an ECDSA signature

###### Parameters

###### signature

`Secp256k1SignatureType`

ECDSA signature with r, s, v components (r and s are HashType)

###### messageHash

[`HashType`](../HashType-2.mdx#hashtype)

32-byte message hash that was signed

###### publicKey

`Secp256k1PublicKeyType`

64-byte uncompressed public key

###### Returns

`boolean`

true if signature is valid, false otherwise

###### See

https://voltaire.tevm.sh/crypto for crypto documentation

###### Since

0.0.0

###### Throws

If signature v is invalid

###### Example

```javascript
import * as Secp256k1 from './crypto/Secp256k1/index.js';
import * as Hash from './primitives/Hash/index.js';
const r = Hash.from(rBytes);
const s = Hash.from(sBytes);
const valid = Secp256k1.verify({ r, s, v: 27 }, messageHash, publicKey);
```

###### verifyHash()

> **verifyHash**: (`signature`, `hash`, `publicKey`) => `boolean`

Verify an ECDSA signature against a pre-hashed message

This is the hash-level API that operates directly on a 32-byte hash.
Use this when you need custom hashing schemes or interop with other libraries.
For standard Ethereum signing, use verify() instead.

###### Parameters

###### signature

`Secp256k1SignatureType`

ECDSA signature with r, s, v components (r and s are HashType)

###### hash

[`HashType`](../HashType-2.mdx#hashtype)

32-byte hash that was signed (pre-hashed message)

###### publicKey

`Secp256k1PublicKeyType`

64-byte uncompressed public key

###### Returns

`boolean`

true if signature is valid, false otherwise

###### See

https://voltaire.tevm.sh/crypto for crypto documentation

###### Since

0.0.0

###### Throws

If hash is not 32 bytes

###### Example

```javascript
import * as Secp256k1 from './crypto/Secp256k1/index.js';
import * as Hash from './primitives/Hash/index.js';

// Verify a signature against a pre-hashed message (hash-level API)
const hash = Hash.keccak256String('Hello!');
const valid = Secp256k1.verifyHash({ r, s, v: 27 }, hash, publicKey);

// For comparison, verify() hashes internally (message-level API)
const valid2 = Secp256k1.verify({ r, s, v: 27 }, messageHash, publicKey);
```

###### Type Declaration

###### \_wasm

> **\_wasm**: *typeof* [`Secp256k1Wasm`](namespaces/Secp256k1Wasm/index.mdx) = `Secp256k1Wasm`

##### SHA256

> **SHA256**: (`input`) => [`SHA256Hash`](../../index.mdx#sha256hash) & `object` & `object`

SHA256 with WASM acceleration

###### Type Declaration

###### BLOCK\_SIZE

> **BLOCK\_SIZE**: `number`

SHA256 block size in bytes

###### See

https://voltaire.tevm.sh/crypto for crypto documentation

###### Since

0.0.0

###### Throws

###### Example

```javascript
import { BLOCK_SIZE } from './crypto/SHA256/index.js';
console.log(BLOCK_SIZE); // 64
```

###### create()

> **create**: () => `object`

Incremental hasher for streaming data

###### Returns

`object`

Hasher instance

###### digest()

> **digest**: () => `Uint8Array`

###### Returns

`Uint8Array`

###### update()

> **update**: (`data`) => `void`

###### Parameters

###### data

`Uint8Array`

###### Returns

`void`

###### See

https://voltaire.tevm.sh/crypto for crypto documentation

###### Since

0.0.0

###### Throws

###### Example

```javascript
import { SHA256 } from './crypto/SHA256/index.js';
const hasher = SHA256.create();
hasher.update(new Uint8Array([1, 2, 3]));
hasher.update(new Uint8Array([4, 5, 6]));
const hash = hasher.digest();
```

###### from()

> **from**: (`input`) => [`SHA256Hash`](../../index.mdx#sha256hash)

Hash input with SHA256 (constructor pattern)

Auto-detects input type and hashes accordingly:
- Uint8Array: hash directly
- string starting with 0x: parse as hex
- string: UTF-8 encode then hash

###### Parameters

###### input

Data to hash

`string` | `Uint8Array`\<`ArrayBufferLike`\>

###### Returns

[`SHA256Hash`](../../index.mdx#sha256hash)

32-byte hash

###### See

https://voltaire.tevm.sh/crypto/sha256 for crypto documentation

###### Since

0.0.0

###### Throws

###### Example

```javascript
import { SHA256Hash } from './crypto/SHA256/index.js';

const hash1 = SHA256Hash.from("0x1234");      // Hex
const hash2 = SHA256Hash.from("hello");       // String
const hash3 = SHA256Hash.from(uint8array);    // Bytes
```

###### fromHex()

> **fromHex**: (`hex`) => [`SHA256Hash`](../../index.mdx#sha256hash) = `hashHex`

Compute SHA256 hash of hex string (without 0x prefix)

###### Parameters

###### hex

`string`

Hex string (with or without 0x prefix)

###### Returns

[`SHA256Hash`](../../index.mdx#sha256hash)

32-byte hash

###### See

https://voltaire.tevm.sh/crypto for crypto documentation

###### Since

0.0.0

###### Throws

###### Example

```javascript
import { SHA256 } from './crypto/SHA256/index.js';
const hash = SHA256.hashHex("0xdeadbeef");
console.log(hash.length); // 32
```

###### fromString()

> **fromString**: (`str`) => [`SHA256Hash`](../../index.mdx#sha256hash) = `hashString`

Compute SHA256 hash of UTF-8 string

###### Parameters

###### str

`string`

Input string

###### Returns

[`SHA256Hash`](../../index.mdx#sha256hash)

32-byte hash

###### See

https://voltaire.tevm.sh/crypto for crypto documentation

###### Since

0.0.0

###### Throws

###### Example

```javascript
import { SHA256 } from './crypto/SHA256/index.js';
const hash = SHA256.hashString("hello world");
console.log(hash.length); // 32
```

###### hash()

> **hash**: (`data`) => [`SHA256Hash`](../../index.mdx#sha256hash)

Compute SHA256 hash of input data

###### Parameters

###### data

`Uint8Array`\<`ArrayBufferLike`\>

Input data as Uint8Array

###### Returns

[`SHA256Hash`](../../index.mdx#sha256hash)

32-byte hash

###### See

https://voltaire.tevm.sh/crypto for crypto documentation

###### Since

0.0.0

###### Throws

###### Example

```javascript
import { SHA256Hash } from './crypto/SHA256/index.js';
const hash = SHA256Hash.from(new Uint8Array([1, 2, 3]));
console.log(hash.length); // 32
```

###### hashHex()

> **hashHex**: (`hex`) => [`SHA256Hash`](../../index.mdx#sha256hash)

Compute SHA256 hash of hex string (without 0x prefix)

###### Parameters

###### hex

`string`

Hex string (with or without 0x prefix)

###### Returns

[`SHA256Hash`](../../index.mdx#sha256hash)

32-byte hash

###### See

https://voltaire.tevm.sh/crypto for crypto documentation

###### Since

0.0.0

###### Throws

###### Example

```javascript
import { SHA256 } from './crypto/SHA256/index.js';
const hash = SHA256.hashHex("0xdeadbeef");
console.log(hash.length); // 32
```

###### hashString()

> **hashString**: (`str`) => [`SHA256Hash`](../../index.mdx#sha256hash)

Compute SHA256 hash of UTF-8 string

###### Parameters

###### str

`string`

Input string

###### Returns

[`SHA256Hash`](../../index.mdx#sha256hash)

32-byte hash

###### See

https://voltaire.tevm.sh/crypto for crypto documentation

###### Since

0.0.0

###### Throws

###### Example

```javascript
import { SHA256 } from './crypto/SHA256/index.js';
const hash = SHA256.hashString("hello world");
console.log(hash.length); // 32
```

###### OUTPUT\_SIZE

> **OUTPUT\_SIZE**: `number`

SHA256 output size in bytes (256 bits / 8)

###### See

https://voltaire.tevm.sh/crypto for crypto documentation

###### Since

0.0.0

###### Throws

###### Example

```javascript
import { OUTPUT_SIZE } from './crypto/SHA256/index.js';
console.log(OUTPUT_SIZE); // 32
```

###### toHex()

> **toHex**: (`hash`) => `string`

Convert hash output to hex string

###### Parameters

###### hash

`Uint8Array`\<`ArrayBufferLike`\>

Hash bytes

###### Returns

`string`

Hex string with 0x prefix

###### See

https://voltaire.tevm.sh/crypto for crypto documentation

###### Since

0.0.0

###### Throws

###### Example

```javascript
import { SHA256 } from './crypto/SHA256/index.js';
const hash = SHA256.hash(new Uint8Array([1, 2, 3]));
const hexStr = SHA256.toHex(hash);
console.log(hexStr); // "0x..."
```

###### Type Declaration

###### \_wasm

> **\_wasm**: *typeof* [`Sha256Wasm`](namespaces/Sha256Wasm.mdx) = `Sha256Wasm`

##### Siwe

> **Siwe**: *typeof* [`Siwe`](../../index.mdx#siwe)

##### StorageKey

> **StorageKey**: `object`

###### StorageKey.create()

> **create**: (`address`, `slot`) => [`StorageKeyType`](../BrandedStorageKey.mdx#storagekeytype)

###### Parameters

###### address

[`AddressType`](../../../primitives/Address.mdx#addresstype)

###### slot

`bigint`

###### Returns

[`StorageKeyType`](../BrandedStorageKey.mdx#storagekeytype)

###### StorageKey.equals()

> **equals**: (`a`, `b`) => `boolean`

###### Parameters

###### a

[`StorageKeyLike`](../BrandedStorageKey.mdx#storagekeylike)

###### b

[`StorageKeyLike`](../BrandedStorageKey.mdx#storagekeylike)

###### Returns

`boolean`

###### StorageKey.from()

> **from**: (`value`) => [`StorageKeyType`](../BrandedStorageKey.mdx#storagekeytype)

###### Parameters

###### value

[`StorageKeyLike`](../BrandedStorageKey.mdx#storagekeylike)

###### Returns

[`StorageKeyType`](../BrandedStorageKey.mdx#storagekeytype)

###### StorageKey.fromString()

> **fromString**: (`str`) => [`StorageKeyType`](../BrandedStorageKey.mdx#storagekeytype) \| `undefined`

###### Parameters

###### str

`string`

###### Returns

[`StorageKeyType`](../BrandedStorageKey.mdx#storagekeytype) \| `undefined`

###### StorageKey.hashCode()

> **hashCode**: (`key`) => `number`

###### Parameters

###### key

[`StorageKeyLike`](../BrandedStorageKey.mdx#storagekeylike)

###### Returns

`number`

###### StorageKey.is()

> **is**: (`value`) => `value is StorageKeyType`

###### Parameters

###### value

`unknown`

###### Returns

`value is StorageKeyType`

###### StorageKey.toString()

> **toString**: (`key`) => `string`

###### Parameters

###### key

[`StorageKeyLike`](../BrandedStorageKey.mdx#storagekeylike)

###### Returns

`string`

##### Uint

> **Uint**: *typeof* [`Uint`](../../index.mdx#uint)

##### Wei

> **Wei**: `WeiConstructor`

##### X25519

> **X25519**: `object` & `object`

X25519 with WASM acceleration

###### Type Declaration

###### derivePublicKey()

> **derivePublicKey**: (`secretKey`) => `PublicKey`

Derive public key from secret key

###### Parameters

###### secretKey

`SecretKey`

32-byte secret key

###### Returns

`PublicKey`

32-byte public key

###### See

https://voltaire.tevm.sh/crypto for crypto documentation

###### Since

0.0.0

###### Throws

If secret key is invalid

###### Example

```javascript
import { X25519 } from './crypto/X25519/index.js';
const secretKey = crypto.getRandomValues(new Uint8Array(32));
const publicKey = X25519.derivePublicKey(secretKey);
console.log(publicKey.length); // 32
```

###### generateKeypair()

> **generateKeypair**: () => `object`

Generate random keypair

Uses crypto.getRandomValues for secure random generation

###### Returns

`object`

Object with secretKey and publicKey

###### publicKey

> **publicKey**: `PublicKey`

###### secretKey

> **secretKey**: `SecretKey`

###### See

https://voltaire.tevm.sh/crypto for crypto documentation

###### Since

0.0.0

###### Throws

###### Example

```javascript
import { X25519 } from './crypto/X25519/index.js';
const keypair = X25519.generateKeypair();
console.log(keypair.secretKey.length); // 32
console.log(keypair.publicKey.length); // 32
```

###### generateSecretKey()

> **generateSecretKey**: () => `SecretKey`

Generate random secret key

Uses crypto.getRandomValues for secure random generation

###### Returns

`SecretKey`

32-byte random secret key

###### See

https://voltaire.tevm.sh/crypto for crypto documentation

###### Since

0.0.0

###### Throws

###### Example

```javascript
import { X25519 } from './crypto/X25519/index.js';
const secretKey = X25519.generateSecretKey();
const publicKey = X25519.derivePublicKey(secretKey);
console.log(secretKey.length); // 32
```

###### keypairFromSeed()

> **keypairFromSeed**: (`seed`) => `object`

Generate X25519 keypair from seed

###### Parameters

###### seed

`Uint8Array`\<`ArrayBufferLike`\>

32-byte seed for deterministic generation

###### Returns

`object`

Object with secretKey and publicKey

###### publicKey

> **publicKey**: `PublicKey`

###### secretKey

> **secretKey**: `SecretKey`

###### See

https://voltaire.tevm.sh/crypto for crypto documentation

###### Since

0.0.0

###### Throws

If seed length is invalid

###### Example

```javascript
import { X25519 } from './crypto/X25519/index.js';
const seed = crypto.getRandomValues(new Uint8Array(32));
const keypair = X25519.keypairFromSeed(seed);
console.log(keypair.secretKey.length); // 32
console.log(keypair.publicKey.length); // 32
```

###### PUBLIC\_KEY\_SIZE

> **PUBLIC\_KEY\_SIZE**: `32`

Public key size in bytes

###### See

https://voltaire.tevm.sh/crypto for crypto documentation

###### Since

0.0.0

###### Throws

###### Example

```javascript
import { PUBLIC_KEY_SIZE } from './crypto/X25519/index.js';
console.log(PUBLIC_KEY_SIZE); // 32
```

###### scalarmult()

> **scalarmult**: (`secretKey`, `publicKey`) => `SharedSecret`

Perform X25519 scalar multiplication (ECDH)

Computes shared secret from your secret key and their public key.

###### Parameters

###### secretKey

`SecretKey`

Your 32-byte secret key

###### publicKey

`PublicKey`

Their 32-byte public key

###### Returns

`SharedSecret`

32-byte shared secret

###### See

https://voltaire.tevm.sh/crypto for crypto documentation

###### Since

0.0.0

###### Throws

If secret key is invalid

###### Throws

If public key is invalid

###### Throws

If scalar multiplication fails

###### Example

```javascript
import { X25519 } from './crypto/X25519/index.js';
const mySecret = crypto.getRandomValues(new Uint8Array(32));
const theirPublic = X25519.derivePublicKey(theirSecret);
const shared = X25519.scalarmult(mySecret, theirPublic);
console.log(shared.length); // 32
```

###### SECRET\_KEY\_SIZE

> **SECRET\_KEY\_SIZE**: `32`

Secret key size in bytes

###### See

https://voltaire.tevm.sh/crypto for crypto documentation

###### Since

0.0.0

###### Throws

###### Example

```javascript
import { SECRET_KEY_SIZE } from './crypto/X25519/index.js';
console.log(SECRET_KEY_SIZE); // 32
```

###### SHARED\_SECRET\_SIZE

> **SHARED\_SECRET\_SIZE**: `32`

Shared secret size in bytes

###### See

https://voltaire.tevm.sh/crypto for crypto documentation

###### Since

0.0.0

###### Throws

###### Example

```javascript
import { SHARED_SECRET_SIZE } from './crypto/X25519/index.js';
console.log(SHARED_SECRET_SIZE); // 32
```

###### validatePublicKey()

> **validatePublicKey**: (`publicKey`) => `boolean`

Validate a public key

Checks if the public key has correct length

###### Parameters

###### publicKey

`PublicKey`

Public key to validate

###### Returns

`boolean`

True if valid, false otherwise

###### See

https://voltaire.tevm.sh/crypto for crypto documentation

###### Since

0.0.0

###### Throws

###### Example

```javascript
import { X25519 } from './crypto/X25519/index.js';
const publicKey = new Uint8Array(32);
const valid = X25519.validatePublicKey(publicKey);
```

###### validateSecretKey()

> **validateSecretKey**: (`secretKey`) => `boolean`

Validate a secret key

Checks if the secret key has correct length and can derive a public key

###### Parameters

###### secretKey

`SecretKey`

Secret key to validate

###### Returns

`boolean`

True if valid, false otherwise

###### See

https://voltaire.tevm.sh/crypto for crypto documentation

###### Since

0.0.0

###### Throws

###### Example

```javascript
import { X25519 } from './crypto/X25519/index.js';
const secretKey = new Uint8Array(32);
const valid = X25519.validateSecretKey(secretKey);
```

###### Type Declaration

###### \_wasm

> **\_wasm**: *typeof* [`X25519Wasm`](namespaces/X25519Wasm.mdx) = `X25519Wasm`

***

### Wei

> `const` **Wei**: `WeiConstructor` = `WeiJS`

Defined in: [src/wasm/index.ts:245](https://github.com/evmts/voltaire/blob/c23bdec42e80cac8af3a4130b0c4c180becd2ad0/src/wasm/index.ts#L245)

***

### X25519

> `const` **X25519**: `object` & `object`

Defined in: [src/wasm/index.ts:207](https://github.com/evmts/voltaire/blob/c23bdec42e80cac8af3a4130b0c4c180becd2ad0/src/wasm/index.ts#L207)

X25519 with WASM acceleration

#### Type Declaration

##### derivePublicKey()

> **derivePublicKey**: (`secretKey`) => `PublicKey`

Derive public key from secret key

###### Parameters

###### secretKey

`SecretKey`

32-byte secret key

###### Returns

`PublicKey`

32-byte public key

###### See

https://voltaire.tevm.sh/crypto for crypto documentation

###### Since

0.0.0

###### Throws

If secret key is invalid

###### Example

```javascript
import { X25519 } from './crypto/X25519/index.js';
const secretKey = crypto.getRandomValues(new Uint8Array(32));
const publicKey = X25519.derivePublicKey(secretKey);
console.log(publicKey.length); // 32
```

##### generateKeypair()

> **generateKeypair**: () => `object`

Generate random keypair

Uses crypto.getRandomValues for secure random generation

###### Returns

`object`

Object with secretKey and publicKey

###### publicKey

> **publicKey**: `PublicKey`

###### secretKey

> **secretKey**: `SecretKey`

###### See

https://voltaire.tevm.sh/crypto for crypto documentation

###### Since

0.0.0

###### Throws

###### Example

```javascript
import { X25519 } from './crypto/X25519/index.js';
const keypair = X25519.generateKeypair();
console.log(keypair.secretKey.length); // 32
console.log(keypair.publicKey.length); // 32
```

##### generateSecretKey()

> **generateSecretKey**: () => `SecretKey`

Generate random secret key

Uses crypto.getRandomValues for secure random generation

###### Returns

`SecretKey`

32-byte random secret key

###### See

https://voltaire.tevm.sh/crypto for crypto documentation

###### Since

0.0.0

###### Throws

###### Example

```javascript
import { X25519 } from './crypto/X25519/index.js';
const secretKey = X25519.generateSecretKey();
const publicKey = X25519.derivePublicKey(secretKey);
console.log(secretKey.length); // 32
```

##### keypairFromSeed()

> **keypairFromSeed**: (`seed`) => `object`

Generate X25519 keypair from seed

###### Parameters

###### seed

`Uint8Array`\<`ArrayBufferLike`\>

32-byte seed for deterministic generation

###### Returns

`object`

Object with secretKey and publicKey

###### publicKey

> **publicKey**: `PublicKey`

###### secretKey

> **secretKey**: `SecretKey`

###### See

https://voltaire.tevm.sh/crypto for crypto documentation

###### Since

0.0.0

###### Throws

If seed length is invalid

###### Example

```javascript
import { X25519 } from './crypto/X25519/index.js';
const seed = crypto.getRandomValues(new Uint8Array(32));
const keypair = X25519.keypairFromSeed(seed);
console.log(keypair.secretKey.length); // 32
console.log(keypair.publicKey.length); // 32
```

##### PUBLIC\_KEY\_SIZE

> **PUBLIC\_KEY\_SIZE**: `32`

Public key size in bytes

###### See

https://voltaire.tevm.sh/crypto for crypto documentation

###### Since

0.0.0

###### Throws

###### Example

```javascript
import { PUBLIC_KEY_SIZE } from './crypto/X25519/index.js';
console.log(PUBLIC_KEY_SIZE); // 32
```

##### scalarmult()

> **scalarmult**: (`secretKey`, `publicKey`) => `SharedSecret`

Perform X25519 scalar multiplication (ECDH)

Computes shared secret from your secret key and their public key.

###### Parameters

###### secretKey

`SecretKey`

Your 32-byte secret key

###### publicKey

`PublicKey`

Their 32-byte public key

###### Returns

`SharedSecret`

32-byte shared secret

###### See

https://voltaire.tevm.sh/crypto for crypto documentation

###### Since

0.0.0

###### Throws

If secret key is invalid

###### Throws

If public key is invalid

###### Throws

If scalar multiplication fails

###### Example

```javascript
import { X25519 } from './crypto/X25519/index.js';
const mySecret = crypto.getRandomValues(new Uint8Array(32));
const theirPublic = X25519.derivePublicKey(theirSecret);
const shared = X25519.scalarmult(mySecret, theirPublic);
console.log(shared.length); // 32
```

##### SECRET\_KEY\_SIZE

> **SECRET\_KEY\_SIZE**: `32`

Secret key size in bytes

###### See

https://voltaire.tevm.sh/crypto for crypto documentation

###### Since

0.0.0

###### Throws

###### Example

```javascript
import { SECRET_KEY_SIZE } from './crypto/X25519/index.js';
console.log(SECRET_KEY_SIZE); // 32
```

##### SHARED\_SECRET\_SIZE

> **SHARED\_SECRET\_SIZE**: `32`

Shared secret size in bytes

###### See

https://voltaire.tevm.sh/crypto for crypto documentation

###### Since

0.0.0

###### Throws

###### Example

```javascript
import { SHARED_SECRET_SIZE } from './crypto/X25519/index.js';
console.log(SHARED_SECRET_SIZE); // 32
```

##### validatePublicKey()

> **validatePublicKey**: (`publicKey`) => `boolean`

Validate a public key

Checks if the public key has correct length

###### Parameters

###### publicKey

`PublicKey`

Public key to validate

###### Returns

`boolean`

True if valid, false otherwise

###### See

https://voltaire.tevm.sh/crypto for crypto documentation

###### Since

0.0.0

###### Throws

###### Example

```javascript
import { X25519 } from './crypto/X25519/index.js';
const publicKey = new Uint8Array(32);
const valid = X25519.validatePublicKey(publicKey);
```

##### validateSecretKey()

> **validateSecretKey**: (`secretKey`) => `boolean`

Validate a secret key

Checks if the secret key has correct length and can derive a public key

###### Parameters

###### secretKey

`SecretKey`

Secret key to validate

###### Returns

`boolean`

True if valid, false otherwise

###### See

https://voltaire.tevm.sh/crypto for crypto documentation

###### Since

0.0.0

###### Throws

###### Example

```javascript
import { X25519 } from './crypto/X25519/index.js';
const secretKey = new Uint8Array(32);
const valid = X25519.validateSecretKey(secretKey);
```

#### Type Declaration

##### \_wasm

> **\_wasm**: *typeof* [`X25519Wasm`](namespaces/X25519Wasm.mdx) = `X25519Wasm`

## Functions

### accessListGasCost()

> **accessListGasCost**(`accessList`): `bigint`

Defined in: [src/primitives/AccessList/AccessList.wasm.ts:16](https://github.com/evmts/voltaire/blob/c23bdec42e80cac8af3a4130b0c4c180becd2ad0/src/primitives/AccessList/AccessList.wasm.ts#L16)

Calculate total gas cost for access list

#### Parameters

##### accessList

[`BrandedAccessList`](../BrandedAccessList.mdx#brandedaccesslist)

Access list to calculate cost for

#### Returns

`bigint`

Gas cost as bigint

***

### accessListGasSavings()

> **accessListGasSavings**(`accessList`): `bigint`

Defined in: [src/primitives/AccessList/AccessList.wasm.ts:26](https://github.com/evmts/voltaire/blob/c23bdec42e80cac8af3a4130b0c4c180becd2ad0/src/primitives/AccessList/AccessList.wasm.ts#L26)

Calculate gas savings from using access list

#### Parameters

##### accessList

[`BrandedAccessList`](../BrandedAccessList.mdx#brandedaccesslist)

Access list to calculate savings for

#### Returns

`bigint`

Gas savings as bigint

***

### accessListIncludesAddress()

> **accessListIncludesAddress**(`accessList`, `address`): `boolean`

Defined in: [src/primitives/AccessList/AccessList.wasm.ts:37](https://github.com/evmts/voltaire/blob/c23bdec42e80cac8af3a4130b0c4c180becd2ad0/src/primitives/AccessList/AccessList.wasm.ts#L37)

Check if address is in access list

#### Parameters

##### accessList

[`BrandedAccessList`](../BrandedAccessList.mdx#brandedaccesslist)

Access list to check

##### address

[`AddressType`](../../../primitives/Address.mdx#addresstype)

Address to look for

#### Returns

`boolean`

True if address is in list

***

### accessListIncludesStorageKey()

> **accessListIncludesStorageKey**(`accessList`, `address`, `storageKey`): `boolean`

Defined in: [src/primitives/AccessList/AccessList.wasm.ts:52](https://github.com/evmts/voltaire/blob/c23bdec42e80cac8af3a4130b0c4c180becd2ad0/src/primitives/AccessList/AccessList.wasm.ts#L52)

Check if storage key is in access list for address

#### Parameters

##### accessList

[`BrandedAccessList`](../BrandedAccessList.mdx#brandedaccesslist)

Access list to check

##### address

[`AddressType`](../../../primitives/Address.mdx#addresstype)

Address to look for

##### storageKey

[`HashType`](../HashType-2.mdx#hashtype)

Storage key to look for

#### Returns

`boolean`

True if storage key is in list for address

***

### analyzeJumpDestinations()

> **analyzeJumpDestinations**(`bytecode`): `number`[]

Defined in: [src/primitives/Bytecode/Bytecode.wasm.ts:32](https://github.com/evmts/voltaire/blob/c23bdec42e80cac8af3a4130b0c4c180becd2ad0/src/primitives/Bytecode/Bytecode.wasm.ts#L32)

Analyze bytecode to find all valid JUMPDEST locations (WASM accelerated)

#### Parameters

##### bytecode

`BrandedBytecode`

EVM bytecode

#### Returns

`number`[]

Array of valid JUMPDEST positions

#### Example

```typescript
const code = Bytecode("0x6001...");
const jumpdests = Bytecode.analyzeJumpDestinations(code);
```

***

### blake2b()

> **blake2b**(`data`): `Uint8Array`

Defined in: [src/primitives/Hash/Hash.wasm.ts:42](https://github.com/evmts/voltaire/blob/c23bdec42e80cac8af3a4130b0c4c180becd2ad0/src/primitives/Hash/Hash.wasm.ts#L42)

Compute BLAKE2b hash

#### Parameters

##### data

Input data (string or Uint8Array)

`string` | `Uint8Array`\<`ArrayBufferLike`\>

#### Returns

`Uint8Array`

64-byte BLAKE2b hash

***

### blobCalculateExcessGas()

> **blobCalculateExcessGas**(`parentExcess`, `parentUsed`): `bigint`

Defined in: [src/primitives/Blob/Blob.wasm.ts:114](https://github.com/evmts/voltaire/blob/c23bdec42e80cac8af3a4130b0c4c180becd2ad0/src/primitives/Blob/Blob.wasm.ts#L114)

Calculate excess blob gas for next block using WASM

#### Parameters

##### parentExcess

`bigint`

Parent block excess blob gas

##### parentUsed

`bigint`

Parent block blob gas used

#### Returns

`bigint`

Excess blob gas for next block

#### Example

```typescript
const excess = calculateExcessGasWasm(0n, 524288n); // Excess from 4 blobs
```

***

### blobCalculateGas()

> **blobCalculateGas**(`blobCount`): `bigint`

Defined in: [src/primitives/Blob/Blob.wasm.ts:71](https://github.com/evmts/voltaire/blob/c23bdec42e80cac8af3a4130b0c4c180becd2ad0/src/primitives/Blob/Blob.wasm.ts#L71)

Calculate blob gas for number of blobs using WASM

#### Parameters

##### blobCount

`number`

Number of blobs

#### Returns

`bigint`

Total blob gas

#### Example

```typescript
const gas = calculateGasWasm(3); // 393216n
```

***

### blobCalculateGasPrice()

> **blobCalculateGasPrice**(`excessBlobGas`): `bigint`

Defined in: [src/primitives/Blob/Blob.wasm.ts:99](https://github.com/evmts/voltaire/blob/c23bdec42e80cac8af3a4130b0c4c180becd2ad0/src/primitives/Blob/Blob.wasm.ts#L99)

Calculate blob gas price from excess blob gas using WASM

#### Parameters

##### excessBlobGas

`bigint`

Excess blob gas

#### Returns

`bigint`

Blob gas price

#### Example

```typescript
const price = calculateGasPriceWasm(0n); // 1n (MIN_BLOB_BASE_FEE)
```

***

### blobEstimateCount()

> **blobEstimateCount**(`dataSize`): `number`

Defined in: [src/primitives/Blob/Blob.wasm.ts:85](https://github.com/evmts/voltaire/blob/c23bdec42e80cac8af3a4130b0c4c180becd2ad0/src/primitives/Blob/Blob.wasm.ts#L85)

Estimate number of blobs needed for data using WASM

#### Parameters

##### dataSize

`number`

Size of data in bytes

#### Returns

`number`

Number of blobs required

#### Example

```typescript
const blobCount = estimateBlobCountWasm(200000); // 2
```

***

### blobFromData()

> **blobFromData**(`data`): `Uint8Array`

Defined in: [src/primitives/Blob/Blob.wasm.ts:26](https://github.com/evmts/voltaire/blob/c23bdec42e80cac8af3a4130b0c4c180becd2ad0/src/primitives/Blob/Blob.wasm.ts#L26)

Encode data as blob using WASM (with length prefix)

#### Parameters

##### data

`Uint8Array`

Data to encode (max ~131KB)

#### Returns

`Uint8Array`

Blob containing encoded data

#### Example

```typescript
const data = new TextEncoder().encode("Hello, blob!");
const blob = fromDataWasm(data);
```

***

### blobIsValid()

> **blobIsValid**(`blobLen`): `boolean`

Defined in: [src/primitives/Blob/Blob.wasm.ts:57](https://github.com/evmts/voltaire/blob/c23bdec42e80cac8af3a4130b0c4c180becd2ad0/src/primitives/Blob/Blob.wasm.ts#L57)

Validate blob size using WASM

#### Parameters

##### blobLen

`number`

Length to validate

#### Returns

`boolean`

true if blob is exactly 131072 bytes

#### Example

```typescript
if (!isValidWasm(blob.length)) {
  throw new Error("Invalid blob");
}
```

***

### blobToData()

> **blobToData**(`blob`): `Uint8Array`

Defined in: [src/primitives/Blob/Blob.wasm.ts:41](https://github.com/evmts/voltaire/blob/c23bdec42e80cac8af3a4130b0c4c180becd2ad0/src/primitives/Blob/Blob.wasm.ts#L41)

Extract data from blob using WASM

#### Parameters

##### blob

`Uint8Array`

Blob data (131072 bytes)

#### Returns

`Uint8Array`

Original data

#### Example

```typescript
const data = toDataWasm(blob);
const text = new TextDecoder().decode(data);
```

***

### bytesToHex()

> **bytesToHex**(`data`): `string`

Defined in: [src/primitives/Hex/Hex.wasm.ts:22](https://github.com/evmts/voltaire/blob/c23bdec42e80cac8af3a4130b0c4c180becd2ad0/src/primitives/Hex/Hex.wasm.ts#L22)

Convert bytes to hex string

#### Parameters

##### data

`Uint8Array`

Raw bytes

#### Returns

`string`

Hex string with 0x prefix

***

### compressPublicKey()

> **compressPublicKey**(`uncompressed`): `Uint8Array`\<`ArrayBufferLike`\>

Defined in: [src/crypto/wallet.wasm.js:21](https://github.com/evmts/voltaire/blob/c23bdec42e80cac8af3a4130b0c4c180becd2ad0/src/crypto/wallet.wasm.js#L21)

Compress an uncompressed public key (64 bytes) to compressed form (33 bytes)

#### Parameters

##### uncompressed

`Uint8Array`\<`ArrayBufferLike`\>

Uncompressed public key (64 bytes)

#### Returns

`Uint8Array`\<`ArrayBufferLike`\>

Compressed public key (33 bytes)

***

### detectTransactionType()

> **detectTransactionType**(`data`): [`TransactionType`](#transactiontype)

Defined in: [src/primitives/Transaction/Transaction.wasm.ts:29](https://github.com/evmts/voltaire/blob/c23bdec42e80cac8af3a4130b0c4c180becd2ad0/src/primitives/Transaction/Transaction.wasm.ts#L29)

Detect transaction type from RLP-encoded data

#### Parameters

##### data

`Uint8Array`

RLP-encoded transaction data

#### Returns

[`TransactionType`](#transactiontype)

Transaction type (0-4)

***

### eip191HashMessage()

> **eip191HashMessage**(`message`): `Promise`\<`Uint8Array`\<`ArrayBufferLike`\>\>

Defined in: [src/crypto/keccak.wasm.js:29](https://github.com/evmts/voltaire/blob/c23bdec42e80cac8af3a4130b0c4c180becd2ad0/src/crypto/keccak.wasm.js#L29)

#### Parameters

##### message

`string` | `Uint8Array`\<`ArrayBufferLike`\>

#### Returns

`Promise`\<`Uint8Array`\<`ArrayBufferLike`\>\>

***

### generatePrivateKey()

> **generatePrivateKey**(): `Uint8Array`\<`ArrayBufferLike`\>

Defined in: [src/crypto/wallet.wasm.js:12](https://github.com/evmts/voltaire/blob/c23bdec42e80cac8af3a4130b0c4c180becd2ad0/src/crypto/wallet.wasm.js#L12)

Generate a random private key (32 bytes)

#### Returns

`Uint8Array`\<`ArrayBufferLike`\>

Random private key

***

### hexToBytes()

> **hexToBytes**(`hex`): `Uint8Array`

Defined in: [src/primitives/Hex/Hex.wasm.ts:13](https://github.com/evmts/voltaire/blob/c23bdec42e80cac8af3a4130b0c4c180becd2ad0/src/primitives/Hex/Hex.wasm.ts#L13)

Convert hex string to bytes

#### Parameters

##### hex

`string`

Hex string (with or without 0x prefix)

#### Returns

`Uint8Array`

Raw bytes

***

### isBytecodeBoundary()

> **isBytecodeBoundary**(`bytecode`, `position`): `boolean`

Defined in: [src/primitives/Bytecode/Bytecode.wasm.ts:52](https://github.com/evmts/voltaire/blob/c23bdec42e80cac8af3a4130b0c4c180becd2ad0/src/primitives/Bytecode/Bytecode.wasm.ts#L52)

Check if a position is at a bytecode boundary (WASM accelerated)
Position must not be inside PUSH data

#### Parameters

##### bytecode

`BrandedBytecode`

EVM bytecode

##### position

`number`

Position to check

#### Returns

`boolean`

True if position is a valid instruction boundary

#### Example

```typescript
const code = Bytecode("0x6001...");
if (Bytecode.isBytecodeBoundary(code, 0)) {
  console.log("Valid boundary");
}
```

***

### isValidJumpDest()

> **isValidJumpDest**(`bytecode`, `position`): `boolean`

Defined in: [src/primitives/Bytecode/Bytecode.wasm.ts:74](https://github.com/evmts/voltaire/blob/c23bdec42e80cac8af3a4130b0c4c180becd2ad0/src/primitives/Bytecode/Bytecode.wasm.ts#L74)

Check if a position contains a valid JUMPDEST (WASM accelerated)

#### Parameters

##### bytecode

`BrandedBytecode`

EVM bytecode

##### position

`number`

Position to check

#### Returns

`boolean`

True if position contains JUMPDEST opcode

#### Example

```typescript
const code = Bytecode("0x5b...");  // 0x5b is JUMPDEST
if (Bytecode.isValidJumpDest(code, 0)) {
  console.log("Valid JUMPDEST");
}
```

***

### keccak256()

> **keccak256**(`data`): `Promise`\<`Uint8Array`\<`ArrayBufferLike`\>\>

Defined in: [src/crypto/keccak.wasm.js:17](https://github.com/evmts/voltaire/blob/c23bdec42e80cac8af3a4130b0c4c180becd2ad0/src/crypto/keccak.wasm.js#L17)

#### Parameters

##### data

`string` | `Uint8Array`\<`ArrayBufferLike`\>

#### Returns

`Promise`\<`Uint8Array`\<`ArrayBufferLike`\>\>

***

### ripemd160()

> **ripemd160**(`data`): `Uint8Array`

Defined in: [src/primitives/Hash/Hash.wasm.ts:28](https://github.com/evmts/voltaire/blob/c23bdec42e80cac8af3a4130b0c4c180becd2ad0/src/primitives/Hash/Hash.wasm.ts#L28)

Compute RIPEMD-160 hash

#### Parameters

##### data

Input data (string or Uint8Array)

`string` | `Uint8Array`\<`ArrayBufferLike`\>

#### Returns

`Uint8Array`

20-byte RIPEMD-160 hash

***

### rlpEncodeBytes()

> **rlpEncodeBytes**(`data`): `Uint8Array`

Defined in: [src/primitives/Rlp/Rlp.wasm.ts:13](https://github.com/evmts/voltaire/blob/c23bdec42e80cac8af3a4130b0c4c180becd2ad0/src/primitives/Rlp/Rlp.wasm.ts#L13)

Encode bytes as RLP

#### Parameters

##### data

`Uint8Array`

Data to encode

#### Returns

`Uint8Array`

RLP-encoded bytes

***

### rlpEncodeUint()

> **rlpEncodeUint**(`value`): `Uint8Array`

Defined in: [src/primitives/Rlp/Rlp.wasm.ts:23](https://github.com/evmts/voltaire/blob/c23bdec42e80cac8af3a4130b0c4c180becd2ad0/src/primitives/Rlp/Rlp.wasm.ts#L23)

Encode unsigned integer (u256) as RLP

#### Parameters

##### value

`Uint8Array`

32-byte big-endian u256 value

#### Returns

`Uint8Array`

RLP-encoded bytes

***

### rlpEncodeUintFromBigInt()

> **rlpEncodeUintFromBigInt**(`value`): `Uint8Array`

Defined in: [src/primitives/Rlp/Rlp.wasm.ts:36](https://github.com/evmts/voltaire/blob/c23bdec42e80cac8af3a4130b0c4c180becd2ad0/src/primitives/Rlp/Rlp.wasm.ts#L36)

Encode unsigned integer from bigint

#### Parameters

##### value

`bigint`

BigInt value

#### Returns

`Uint8Array`

RLP-encoded bytes

***

### rlpFromHex()

> **rlpFromHex**(`hex`): `Uint8Array`

Defined in: [src/primitives/Rlp/Rlp.wasm.ts:61](https://github.com/evmts/voltaire/blob/c23bdec42e80cac8af3a4130b0c4c180becd2ad0/src/primitives/Rlp/Rlp.wasm.ts#L61)

Convert hex string to RLP bytes

#### Parameters

##### hex

`string`

Hex string (with or without 0x prefix)

#### Returns

`Uint8Array`

RLP bytes

***

### rlpToHex()

> **rlpToHex**(`rlpData`): `string`

Defined in: [src/primitives/Rlp/Rlp.wasm.ts:51](https://github.com/evmts/voltaire/blob/c23bdec42e80cac8af3a4130b0c4c180becd2ad0/src/primitives/Rlp/Rlp.wasm.ts#L51)

Convert RLP bytes to hex string

#### Parameters

##### rlpData

`Uint8Array`

RLP-encoded data

#### Returns

`string`

Hex string with 0x prefix

***

### secp256k1PubkeyFromPrivate()

> **secp256k1PubkeyFromPrivate**(`privateKey`): `Uint8Array`\<`ArrayBufferLike`\>

Defined in: [src/crypto/signature.wasm.js:51](https://github.com/evmts/voltaire/blob/c23bdec42e80cac8af3a4130b0c4c180becd2ad0/src/crypto/signature.wasm.js#L51)

Derive public key from private key

#### Parameters

##### privateKey

`Uint8Array`\<`ArrayBufferLike`\>

Private key (32 bytes)

#### Returns

`Uint8Array`\<`ArrayBufferLike`\>

Public key (64 bytes)

***

### secp256k1RecoverAddress()

> **secp256k1RecoverAddress**(`messageHash`, `signature`): `Uint8Array`\<`ArrayBufferLike`\>

Defined in: [src/crypto/signature.wasm.js:40](https://github.com/evmts/voltaire/blob/c23bdec42e80cac8af3a4130b0c4c180becd2ad0/src/crypto/signature.wasm.js#L40)

Recover Ethereum address from signature

#### Parameters

##### messageHash

`Uint8Array`\<`ArrayBufferLike`\>

Hash of signed message

##### signature

`Uint8Array`\<`ArrayBufferLike`\>

65-byte signature (r+s+v)

#### Returns

`Uint8Array`\<`ArrayBufferLike`\>

Recovered address (20 bytes)

***

### secp256k1RecoverPubkey()

> **secp256k1RecoverPubkey**(`messageHash`, `signature`): `Uint8Array`\<`ArrayBufferLike`\>

Defined in: [src/crypto/signature.wasm.js:26](https://github.com/evmts/voltaire/blob/c23bdec42e80cac8af3a4130b0c4c180becd2ad0/src/crypto/signature.wasm.js#L26)

Recover public key from signature

#### Parameters

##### messageHash

`Uint8Array`\<`ArrayBufferLike`\>

Hash of signed message

##### signature

`Uint8Array`\<`ArrayBufferLike`\>

65-byte signature (r+s+v)

#### Returns

`Uint8Array`\<`ArrayBufferLike`\>

Recovered public key (64 bytes)

***

### secp256k1ValidateSignature()

> **secp256k1ValidateSignature**(`signature`, `messageHash`, `publicKey`): `boolean`

Defined in: [src/crypto/signature.wasm.js:62](https://github.com/evmts/voltaire/blob/c23bdec42e80cac8af3a4130b0c4c180becd2ad0/src/crypto/signature.wasm.js#L62)

Validate signature against public key

#### Parameters

##### signature

`Uint8Array`\<`ArrayBufferLike`\>

65-byte signature

##### messageHash

`Uint8Array`\<`ArrayBufferLike`\>

Hash of signed message

##### publicKey

`Uint8Array`\<`ArrayBufferLike`\>

Public key (64 bytes)

#### Returns

`boolean`

True if signature is valid

***

### sha256()

> **sha256**(`data`): `Uint8Array`

Defined in: [src/primitives/Hash/Hash.wasm.ts:14](https://github.com/evmts/voltaire/blob/c23bdec42e80cac8af3a4130b0c4c180becd2ad0/src/primitives/Hash/Hash.wasm.ts#L14)

Compute SHA-256 hash

#### Parameters

##### data

Input data (string or Uint8Array)

`string` | `Uint8Array`\<`ArrayBufferLike`\>

#### Returns

`Uint8Array`

32-byte SHA-256 hash

***

### signatureIsCanonical()

> **signatureIsCanonical**(`signature`): `boolean`

Defined in: [src/crypto/signature.wasm.js:96](https://github.com/evmts/voltaire/blob/c23bdec42e80cac8af3a4130b0c4c180becd2ad0/src/crypto/signature.wasm.js#L96)

Check if signature is in canonical form

#### Parameters

##### signature

`Uint8Array`\<`ArrayBufferLike`\>

65-byte signature

#### Returns

`boolean`

True if signature is canonical

***

### signatureNormalize()

> **signatureNormalize**(`signature`): `Uint8Array`\<`ArrayBufferLike`\>

Defined in: [src/crypto/signature.wasm.js:75](https://github.com/evmts/voltaire/blob/c23bdec42e80cac8af3a4130b0c4c180becd2ad0/src/crypto/signature.wasm.js#L75)

Normalize signature to low-s form

#### Parameters

##### signature

`Uint8Array`\<`ArrayBufferLike`\>

65-byte signature

#### Returns

`Uint8Array`\<`ArrayBufferLike`\>

Normalized signature

***

### signatureParse()

> **signatureParse**(`signature`): [`ParsedSignature`](#parsedsignature-1)

Defined in: [src/crypto/signature.wasm.js:106](https://github.com/evmts/voltaire/blob/c23bdec42e80cac8af3a4130b0c4c180becd2ad0/src/crypto/signature.wasm.js#L106)

Parse signature from bytes

#### Parameters

##### signature

`Uint8Array`\<`ArrayBufferLike`\>

65-byte signature (r+s+v)

#### Returns

[`ParsedSignature`](#parsedsignature-1)

Parsed signature object

***

### signatureSerialize()

> **signatureSerialize**(`signature`): `Uint8Array`\<`ArrayBufferLike`\>

Defined in: [src/crypto/signature.wasm.js:115](https://github.com/evmts/voltaire/blob/c23bdec42e80cac8af3a4130b0c4c180becd2ad0/src/crypto/signature.wasm.js#L115)

Serialize signature to bytes

#### Parameters

##### signature

[`ParsedSignature`](#parsedsignature-1)

Parsed signature object

#### Returns

`Uint8Array`\<`ArrayBufferLike`\>

65-byte signature (r+s+v)

***

### solidityKeccak256()

> **solidityKeccak256**(`packedData`): `Uint8Array`

Defined in: [src/primitives/Hash/Hash.wasm.ts:56](https://github.com/evmts/voltaire/blob/c23bdec42e80cac8af3a4130b0c4c180becd2ad0/src/primitives/Hash/Hash.wasm.ts#L56)

Compute Solidity-style Keccak-256 hash of tightly packed data

#### Parameters

##### packedData

`Uint8Array`

Pre-packed data bytes

#### Returns

`Uint8Array`

32-byte Keccak-256 hash

***

### soliditySha256()

> **soliditySha256**(`packedData`): `Uint8Array`

Defined in: [src/primitives/Hash/Hash.wasm.ts:67](https://github.com/evmts/voltaire/blob/c23bdec42e80cac8af3a4130b0c4c180becd2ad0/src/primitives/Hash/Hash.wasm.ts#L67)

Compute Solidity-style SHA-256 hash of tightly packed data

#### Parameters

##### packedData

`Uint8Array`

Pre-packed data bytes

#### Returns

`Uint8Array`

32-byte SHA-256 hash

***

### u256FromBigInt()

> **u256FromBigInt**(`value`): `Uint8Array`

Defined in: [src/primitives/Uint/Uint256.wasm.ts:46](https://github.com/evmts/voltaire/blob/c23bdec42e80cac8af3a4130b0c4c180becd2ad0/src/primitives/Uint/Uint256.wasm.ts#L46)

Convert bigint to U256 bytes

#### Parameters

##### value

`bigint`

BigInt value

#### Returns

`Uint8Array`

32-byte U256 value

#### Throws

If value is negative

#### Throws

If value exceeds maximum

***

### u256FromHex()

> **u256FromHex**(`hex`): `Uint8Array`

Defined in: [src/primitives/Uint/Uint256.wasm.ts:18](https://github.com/evmts/voltaire/blob/c23bdec42e80cac8af3a4130b0c4c180becd2ad0/src/primitives/Uint/Uint256.wasm.ts#L18)

Convert hex string to U256 (32-byte big-endian)

#### Parameters

##### hex

`string`

Hex string (with or without 0x prefix)

#### Returns

`Uint8Array`

32-byte U256 value

***

### u256ToBigInt()

> **u256ToBigInt**(`value`): `bigint`

Defined in: [src/primitives/Uint/Uint256.wasm.ts:70](https://github.com/evmts/voltaire/blob/c23bdec42e80cac8af3a4130b0c4c180becd2ad0/src/primitives/Uint/Uint256.wasm.ts#L70)

Convert U256 bytes to bigint

#### Parameters

##### value

`Uint8Array`

32-byte U256 value

#### Returns

`bigint`

BigInt value

#### Throws

If value is not 32 bytes

***

### u256ToHex()

> **u256ToHex**(`value`): `string`

Defined in: [src/primitives/Uint/Uint256.wasm.ts:28](https://github.com/evmts/voltaire/blob/c23bdec42e80cac8af3a4130b0c4c180becd2ad0/src/primitives/Uint/Uint256.wasm.ts#L28)

Convert U256 to hex string

#### Parameters

##### value

`Uint8Array`

32-byte U256 value (big-endian)

#### Returns

`string`

Hex string with 0x prefix

#### Throws

If value is not 32 bytes

***

### validateBytecode()

> **validateBytecode**(`bytecode`): `void`

Defined in: [src/primitives/Bytecode/Bytecode.wasm.ts:94](https://github.com/evmts/voltaire/blob/c23bdec42e80cac8af3a4130b0c4c180becd2ad0/src/primitives/Bytecode/Bytecode.wasm.ts#L94)

Validate bytecode structure (WASM accelerated)
Checks that PUSH instructions have enough data bytes

#### Parameters

##### bytecode

`BrandedBytecode`

EVM bytecode

#### Returns

`void`

#### Throws

If bytecode is invalid

#### Example

```typescript
const code = Bytecode("0x6001...");
Bytecode.validate(code);  // Throws if invalid
```

## References

### AbstractError

Re-exports [AbstractError](../../index.mdx#abstracterror)

***

### AesGcm

Re-exports [AesGcm](../../index.mdx#aesgcm)

***

### Bip39

Re-exports [Bip39](../../index.mdx#bip39)

***

### ChaCha20Poly1305

Re-exports [ChaCha20Poly1305](../../index.mdx#chacha20poly1305)

***

### CryptoError

Re-exports [CryptoError](../../index.mdx#cryptoerror)

***

### DecodingError

Re-exports [DecodingError](../../index.mdx#decodingerror)

***

### EncodingError

Re-exports [EncodingError](../../index.mdx#encodingerror)

***

### ERC1155

Re-exports [ERC1155](../ERC1155.mdx)

***

### ERC165

Re-exports [ERC165](../ERC165.mdx)

***

### ERC20

Re-exports [ERC20](../ERC20.mdx)

***

### ERC721

Re-exports [ERC721](../ERC721.mdx)

***

### evm

Re-exports [evm](../../../evm/index.mdx)

***

### HDWallet

Re-exports [HDWallet](../HDWallet.mdx)

***

### IntegerOverflowError

Re-exports [IntegerOverflowError](../../index.mdx#integeroverflowerror)

***

### IntegerUnderflowError

Re-exports [IntegerUnderflowError](../../index.mdx#integerunderflowerror)

***

### InvalidChecksumError

Re-exports [InvalidChecksumError](../../index.mdx#invalidchecksumerror)

***

### InvalidFormatError

Re-exports [InvalidFormatError](../../index.mdx#invalidformaterror)

***

### InvalidLengthError

Re-exports [InvalidLengthError](../../index.mdx#invalidlengtherror)

***

### InvalidPrivateKeyError

Re-exports [InvalidPrivateKeyError](../../index.mdx#invalidprivatekeyerror)

***

### InvalidPublicKeyError

Re-exports [InvalidPublicKeyError](../../index.mdx#invalidpublickeyerror)

***

### InvalidRangeError

Re-exports [InvalidRangeError](../../index.mdx#invalidrangeerror)

***

### InvalidSignatureError

Re-exports [InvalidSignatureError](../../index.mdx#invalidsignatureerror)

***

### InvalidSignerError

Re-exports [InvalidSignerError](../../index.mdx#invalidsignererror)

***

### InvalidSizeError

Re-exports [InvalidSizeError](../../index.mdx#invalidsizeerror)

***

### InvalidTransactionTypeError

Re-exports [InvalidTransactionTypeError](../../index.mdx#invalidtransactiontypeerror)

***

### KeccakHash

Renames and re-exports [Hash](../../index.mdx#hash)

***

### Keystore

Re-exports [Keystore](../Keystore.mdx)

***

### precompiles

Re-exports [precompiles](../precompiles.mdx)

***

### PrimitiveError

Re-exports [PrimitiveError](../../index.mdx#primitiveerror)

***

### SerializationError

Re-exports [SerializationError](../../index.mdx#serializationerror)

***

### TransactionError

Re-exports [TransactionError](../../index.mdx#transactionerror)

***

### ValidationError

Re-exports [ValidationError](../../index.mdx#validationerror)
