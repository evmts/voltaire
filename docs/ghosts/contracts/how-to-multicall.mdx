---
title: How to Multicall
description: Batch multiple contract calls into a single RPC request
---

## Goal

Execute multiple contract reads in a single RPC call using the Multicall3 contract.

## Multicall3 Contract

```typescript
import { Contract } from '@voltaire/contract';
import * as Abi from '@voltaire/primitives/Abi';

// Multicall3 is deployed at same address on all major chains
const MULTICALL3_ADDRESS = '0xcA11bde05977b3631167028862bE2a173976CA11';

const multicall3Abi = [
  {
    type: 'function',
    name: 'aggregate3',
    stateMutability: 'view',
    inputs: [{
      type: 'tuple[]',
      name: 'calls',
      components: [
        { type: 'address', name: 'target' },
        { type: 'bool', name: 'allowFailure' },
        { type: 'bytes', name: 'callData' }
      ]
    }],
    outputs: [{
      type: 'tuple[]',
      name: 'returnData',
      components: [
        { type: 'bool', name: 'success' },
        { type: 'bytes', name: 'returnData' }
      ]
    }]
  }
] as const;

const multicall = Contract({
  address: MULTICALL3_ADDRESS,
  abi: multicall3Abi,
  provider
});
```

## Batch ERC20 Reads

```typescript
import * as Abi from '@voltaire/primitives/Abi';
import * as Hex from '@voltaire/primitives/Hex';

const erc20Abi = Abi.from([
  {
    type: 'function',
    name: 'balanceOf',
    inputs: [{ type: 'address', name: 'account' }],
    outputs: [{ type: 'uint256' }]
  },
  {
    type: 'function',
    name: 'decimals',
    inputs: [],
    outputs: [{ type: 'uint8' }]
  }
]);

const usdcAddress = '0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48';
const userAddress = '0x742d35Cc6634C0532925a3b844Bc9e7595f251e3';

// Encode calls
const balanceCall = Hex.fromBytes(erc20Abi.encode('balanceOf', [userAddress]));
const decimalsCall = Hex.fromBytes(erc20Abi.encode('decimals', []));

// Execute multicall
const results = await multicall.read.aggregate3([
  { target: usdcAddress, allowFailure: false, callData: balanceCall },
  { target: usdcAddress, allowFailure: false, callData: decimalsCall }
]);

// Decode results
const [balanceResult, decimalsResult] = results;
const balance = Abi.decode(erc20Abi, 'balanceOf', Hex.toBytes(balanceResult.returnData))[0];
const decimals = Abi.decode(erc20Abi, 'decimals', Hex.toBytes(decimalsResult.returnData))[0];

console.log(`Balance: ${balance / 10n ** BigInt(decimals)} USDC`);
```

## Multiple Contracts

```typescript
const tokens = [
  '0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48', // USDC
  '0xdAC17F958D2ee523a2206206994597C13D831ec7', // USDT
  '0x6B175474E89094C44Da98b954EescdeCB5BE3830'  // DAI
];

const calls = tokens.map(token => ({
  target: token,
  allowFailure: true,
  callData: Hex.fromBytes(erc20Abi.encode('balanceOf', [userAddress]))
}));

const results = await multicall.read.aggregate3(calls);

const balances = results.map((result, i) => ({
  token: tokens[i],
  balance: result.success
    ? Abi.decode(erc20Abi, 'balanceOf', Hex.toBytes(result.returnData))[0]
    : 0n
}));
```

## Simple Parallel Calls

For simpler cases, use `Promise.all`:

```typescript
const [balance1, balance2, balance3] = await Promise.all([
  usdc.read.balanceOf(address1),
  usdc.read.balanceOf(address2),
  usdc.read.balanceOf(address3)
]);
```

<Tip>
Use Multicall3 when you need 10+ calls or want to minimize RPC requests. For 2-3 calls, `Promise.all` is simpler.
</Tip>
