---
title: '[Zig] src/crypto/keystore.zig'
source: 'src/crypto/keystore.zig'
---

> Auto-generated from Zig tests in: src/crypto/keystore.zig

### encrypt and decrypt with scrypt

```zig
test "encrypt and decrypt with scrypt" {
    const allocator = std.testing.allocator;

    const private_key = [_]u8{
        0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
        0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
        0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
        0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
    };
    const password = "test-password";

    // Use low scrypt parameters for fast tests
    var keystore = try encrypt(allocator, private_key, password, .{
        .scrypt_n = 1024,
        .scrypt_r = 1,
        .scrypt_p = 1,
    });
    defer keystore.deinit(allocator);

    const decrypted = try decrypt(allocator, keystore, password);
    try std.testing.expectEqualSlices(u8, &private_key, &decrypted);
}
```

### encrypt and decrypt with pbkdf2

```zig
test "encrypt and decrypt with pbkdf2" {
    const allocator = std.testing.allocator;

    const private_key = [_]u8{
        0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
        0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
        0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
        0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
    };
    const password = "test-password";

    // Use low iteration count for fast tests
    var keystore = try encrypt(allocator, private_key, password, .{
        .kdf = .pbkdf2,
        .pbkdf2_c = 1000,
    });
    defer keystore.deinit(allocator);

    const decrypted = try decrypt(allocator, keystore, password);
    try std.testing.expectEqualSlices(u8, &private_key, &decrypted);
}
```

### wrong password returns InvalidMac

```zig
test "wrong password returns InvalidMac" {
    const allocator = std.testing.allocator;

    const private_key = [_]u8{0xab} ** 32;

    var keystore = try encrypt(allocator, private_key, "correct-password", .{
        .scrypt_n = 1024,
        .scrypt_r = 1,
        .scrypt_p = 1,
    });
    defer keystore.deinit(allocator);

    const result = decrypt(allocator, keystore, "wrong-password");
    try std.testing.expectError(KeystoreError.InvalidMac, result);
}
```

### deterministic with fixed salt and IV

```zig
test "deterministic with fixed salt and IV" {
    const allocator = std.testing.allocator;

    const private_key = [_]u8{0x01} ** 32;
    const password = "password";
    const salt = [_]u8{0x01} ** 32;
    const iv = [_]u8{0x02} ** 16;
    const uuid = "12345678-1234-1234-1234-123456789abc".*;

    var keystore1 = try encrypt(allocator, private_key, password, .{
        .salt = salt,
        .iv = iv,
        .uuid = uuid,
        .scrypt_n = 1024,
        .scrypt_r = 1,
        .scrypt_p = 1,
    });
    defer keystore1.deinit(allocator);

    var keystore2 = try encrypt(allocator, private_key, password, .{
        .salt = salt,
        .iv = iv,
        .uuid = uuid,
        .scrypt_n = 1024,
        .scrypt_r = 1,
        .scrypt_p = 1,
    });
    defer keystore2.deinit(allocator);

    try std.testing.expectEqualSlices(u8, &keystore1.crypto_section.ciphertext, &keystore2.crypto_section.ciphertext);
    try std.testing.expectEqualSlices(u8, &keystore1.crypto_section.mac, &keystore2.crypto_section.mac);
}
```

### different salts produce different ciphertexts

```zig
test "different salts produce different ciphertexts" {
    const allocator = std.testing.allocator;

    const private_key = [_]u8{0x01} ** 32;
    const password = "password";
    const salt1 = [_]u8{0x01} ** 32;
    const salt2 = [_]u8{0x02} ** 32;

    var keystore1 = try encrypt(allocator, private_key, password, .{
        .salt = salt1,
        .scrypt_n = 1024,
        .scrypt_r = 1,
        .scrypt_p = 1,
    });
    defer keystore1.deinit(allocator);

    var keystore2 = try encrypt(allocator, private_key, password, .{
        .salt = salt2,
        .scrypt_n = 1024,
        .scrypt_r = 1,
        .scrypt_p = 1,
    });
    defer keystore2.deinit(allocator);

    const equal = std.mem.eql(u8, &keystore1.crypto_section.ciphertext, &keystore2.crypto_section.ciphertext);
    try std.testing.expect(!equal);
}
```

### different IVs produce different ciphertexts

```zig
test "different IVs produce different ciphertexts" {
    const allocator = std.testing.allocator;

    const private_key = [_]u8{0x01} ** 32;
    const password = "password";
    const salt = [_]u8{0x01} ** 32;
    const iv1 = [_]u8{0x01} ** 16;
    const iv2 = [_]u8{0x02} ** 16;

    var keystore1 = try encrypt(allocator, private_key, password, .{
        .salt = salt,
        .iv = iv1,
        .scrypt_n = 1024,
        .scrypt_r = 1,
        .scrypt_p = 1,
    });
    defer keystore1.deinit(allocator);

    var keystore2 = try encrypt(allocator, private_key, password, .{
        .salt = salt,
        .iv = iv2,
        .scrypt_n = 1024,
        .scrypt_r = 1,
        .scrypt_p = 1,
    });
    defer keystore2.deinit(allocator);

    const equal = std.mem.eql(u8, &keystore1.crypto_section.ciphertext, &keystore2.crypto_section.ciphertext);
    try std.testing.expect(!equal);

    // Both should still decrypt correctly
    const decrypted1 = try decrypt(allocator, keystore1, password);
    const decrypted2 = try decrypt(allocator, keystore2, password);
    try std.testing.expectEqualSlices(u8, &private_key, &decrypted1);
    try std.testing.expectEqualSlices(u8, &private_key, &decrypted2);
}
```

### empty password

```zig
test "empty password" {
    const allocator = std.testing.allocator;

    const private_key = [_]u8{0xab} ** 32;
    const password = "";

    var keystore = try encrypt(allocator, private_key, password, .{
        .scrypt_n = 1024,
        .scrypt_r = 1,
        .scrypt_p = 1,
    });
    defer keystore.deinit(allocator);

    const decrypted = try decrypt(allocator, keystore, password);
    try std.testing.expectEqualSlices(u8, &private_key, &decrypted);
}
```

### special characters in password

```zig
test "special characters in password" {
    const allocator = std.testing.allocator;

    const private_key = [_]u8{0xab} ** 32;
    const password = "paesewoerd!@#$%^&*()[]{}|<>?/~`";

    var keystore = try encrypt(allocator, private_key, password, .{
        .scrypt_n = 1024,
        .scrypt_r = 1,
        .scrypt_p = 1,
    });
    defer keystore.deinit(allocator);

    const decrypted = try decrypt(allocator, keystore, password);
    try std.testing.expectEqualSlices(u8, &private_key, &decrypted);
}
```

### unicode password

```zig
test "unicode password" {
    const allocator = std.testing.allocator;

    const private_key = [_]u8{0xab} ** 32;
    const password = "\xc3\xa4\xc3\xb6\xc3\xbc"; // UTF-8 encoded aou with umlauts

    var keystore = try encrypt(allocator, private_key, password, .{
        .scrypt_n = 1024,
        .scrypt_r = 1,
        .scrypt_p = 1,
    });
    defer keystore.deinit(allocator);

    const decrypted = try decrypt(allocator, keystore, password);
    try std.testing.expectEqualSlices(u8, &private_key, &decrypted);
}
```

### version must be 3

```zig
test "version must be 3" {
    const allocator = std.testing.allocator;

    const private_key = [_]u8{0xab} ** 32;

    var keystore = try encrypt(allocator, private_key, "password", .{
        .scrypt_n = 1024,
        .scrypt_r = 1,
        .scrypt_p = 1,
    });
    defer keystore.deinit(allocator);

    // Modify version
    keystore.version = 2;

    const result = decrypt(allocator, keystore, "password");
    try std.testing.expectError(KeystoreError.InvalidVersion, result);
}
```

### corrupted ciphertext fails MAC verification

```zig
test "corrupted ciphertext fails MAC verification" {
    const allocator = std.testing.allocator;

    const private_key = [_]u8{0xab} ** 32;

    var keystore = try encrypt(allocator, private_key, "password", .{
        .scrypt_n = 1024,
        .scrypt_r = 1,
        .scrypt_p = 1,
    });
    defer keystore.deinit(allocator);

    // Corrupt ciphertext
    keystore.crypto_section.ciphertext[0] ^= 0xff;

    const result = decrypt(allocator, keystore, "password");
    try std.testing.expectError(KeystoreError.InvalidMac, result);
}
```

### corrupted MAC fails verification

```zig
test "corrupted MAC fails verification" {
    const allocator = std.testing.allocator;

    const private_key = [_]u8{0xab} ** 32;

    var keystore = try encrypt(allocator, private_key, "password", .{
        .scrypt_n = 1024,
        .scrypt_r = 1,
        .scrypt_p = 1,
    });
    defer keystore.deinit(allocator);

    // Corrupt MAC
    keystore.crypto_section.mac[31] ^= 0xff;

    const result = decrypt(allocator, keystore, "password");
    try std.testing.expectError(KeystoreError.InvalidMac, result);
}
```

### AES-128-CTR is symmetric

```zig
test "AES-128-CTR is symmetric" {
    var plaintext = [_]u8{ 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08 } ++ [_]u8{0} ** 24;
    const key = [_]u8{0x01} ** 16;
    const iv = [_]u8{0x02} ** 16;

    var ciphertext: [32]u8 = undefined;
    aes128CtrEncrypt(&ciphertext, &plaintext, &key, &iv);

    // Encrypting again with same key/IV should give back original
    var decrypted: [32]u8 = undefined;
    aes128CtrEncrypt(&decrypted, &ciphertext, &key, &iv);

    try std.testing.expectEqualSlices(u8, &plaintext, &decrypted);
}
```

### constant time comparison

```zig
test "constant time comparison" {
    const a = [_]u8{0x01} ** 32;
    const b = [_]u8{0x01} ** 32;
    const c = [_]u8{0x02} ** 32;

    try std.testing.expect(constantTimeEqual(&a, &b));
    try std.testing.expect(!constantTimeEqual(&a, &c));

    // Test first byte differs
    var d = a;
    d[0] = 0xff;
    try std.testing.expect(!constantTimeEqual(&a, &d));

    // Test last byte differs
    var e = a;
    e[31] = 0xff;
    try std.testing.expect(!constantTimeEqual(&a, &e));
}
```

### computeLogN

```zig
test "computeLogN" {
    try std.testing.expectEqual(@as(?u6, 0), computeLogN(1));
    try std.testing.expectEqual(@as(?u6, 1), computeLogN(2));
    try std.testing.expectEqual(@as(?u6, 10), computeLogN(1024));
    try std.testing.expectEqual(@as(?u6, 14), computeLogN(16384));
    try std.testing.expectEqual(@as(?u6, 18), computeLogN(262144));

    // Non-powers of 2 should return null
    try std.testing.expectEqual(@as(?u6, null), computeLogN(0));
    try std.testing.expectEqual(@as(?u6, null), computeLogN(3));
    try std.testing.expectEqual(@as(?u6, null), computeLogN(1023));
}
```

### generateUuid format

```zig
test "generateUuid format" {
    var uuid: [36]u8 = undefined;
    generateUuid(&uuid);

    // Check format: 8-4-4-4-12
    try std.testing.expectEqual(@as(u8, '-'), uuid[8]);
    try std.testing.expectEqual(@as(u8, '-'), uuid[13]);
    try std.testing.expectEqual(@as(u8, '-'), uuid[18]);
    try std.testing.expectEqual(@as(u8, '-'), uuid[23]);

    // Check version (4) at position 14
    try std.testing.expect(uuid[14] == '4');

    // Check variant at position 19 (should be 8, 9, a, or b)
    const variant = uuid[19];
    try std.testing.expect(variant == '8' or variant == '9' or variant == 'a' or variant == 'b');
}
```

### bytesToHex

```zig
test "bytesToHex" {
    const bytes = [_]u8{ 0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef };
    const hex = bytesToHex(8, &bytes);
    try std.testing.expectEqualSlices(u8, "0123456789abcdef", &hex);
}
```

### hexToBytes

```zig
test "hexToBytes" {
    const hex = "0123456789abcdef".*;
    const bytes = try hexToBytes(8, &hex);
    const expected = [_]u8{ 0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef };
    try std.testing.expectEqualSlices(u8, &expected, &bytes);
}
```

### pbkdf2 round trip

```zig
test "pbkdf2 round trip" {
    const allocator = std.testing.allocator;

    const private_key = [_]u8{ 0xde, 0xad, 0xbe, 0xef } ++ [_]u8{0} ** 28;
    const password = "secure-password-123";

    var keystore = try encrypt(allocator, private_key, password, .{
        .kdf = .pbkdf2,
        .pbkdf2_c = 1000,
    });
    defer keystore.deinit(allocator);

    try std.testing.expectEqual(Kdf.pbkdf2, keystore.crypto_section.kdf);
    try std.testing.expectEqual(@as(u32, 1000), keystore.crypto_section.kdfparams.pbkdf2.c);

    const decrypted = try decrypt(allocator, keystore, password);
    try std.testing.expectEqualSlices(u8, &private_key, &decrypted);
}
```

### scrypt custom parameters

```zig
test "scrypt custom parameters" {
    const allocator = std.testing.allocator;

    const private_key = [_]u8{ 0xca, 0xfe } ** 16;
    const password = "password";

    var keystore = try encrypt(allocator, private_key, password, .{
        .kdf = .scrypt,
        .scrypt_n = 2048,
        .scrypt_r = 4,
        .scrypt_p = 2,
    });
    defer keystore.deinit(allocator);

    try std.testing.expectEqual(@as(u32, 2048), keystore.crypto_section.kdfparams.scrypt.n);
    try std.testing.expectEqual(@as(u8, 4), keystore.crypto_section.kdfparams.scrypt.r);
    try std.testing.expectEqual(@as(u8, 2), keystore.crypto_section.kdfparams.scrypt.p);

    const decrypted = try decrypt(allocator, keystore, password);
    try std.testing.expectEqualSlices(u8, &private_key, &decrypted);
}
```

### all zero private key

```zig
test "all zero private key" {
    const allocator = std.testing.allocator;

    const private_key = [_]u8{0} ** 32;
    const password = "password";

    var keystore = try encrypt(allocator, private_key, password, .{
        .scrypt_n = 1024,
        .scrypt_r = 1,
        .scrypt_p = 1,
    });
    defer keystore.deinit(allocator);

    const decrypted = try decrypt(allocator, keystore, password);
    try std.testing.expectEqualSlices(u8, &private_key, &decrypted);
}
```

### all 0xff private key

```zig
test "all 0xff private key" {
    const allocator = std.testing.allocator;

    const private_key = [_]u8{0xff} ** 32;
    const password = "password";

    var keystore = try encrypt(allocator, private_key, password, .{
        .scrypt_n = 1024,
        .scrypt_r = 1,
        .scrypt_p = 1,
    });
    defer keystore.deinit(allocator);

    const decrypted = try decrypt(allocator, keystore, password);
    try std.testing.expectEqualSlices(u8, &private_key, &decrypted);
}
```

### toJson scrypt format

```zig
test "toJson scrypt format" {
    const allocator = std.testing.allocator;

    const private_key = [_]u8{0x01} ** 32;
    const salt = [_]u8{0x02} ** 32;
    const iv = [_]u8{0x03} ** 16;
    const uuid = "12345678-1234-4234-8234-123456789abc".*;

    var keystore = try encrypt(allocator, private_key, "password", .{
        .salt = salt,
        .iv = iv,
        .uuid = uuid,
        .scrypt_n = 1024,
        .scrypt_r = 1,
        .scrypt_p = 1,
    });
    defer keystore.deinit(allocator);

    const json = try toJson(allocator, keystore);
    defer allocator.free(json);

    // Verify JSON contains expected fields
    try std.testing.expect(mem.indexOf(u8, json, "\"version\":3") != null);
    try std.testing.expect(mem.indexOf(u8, json, "\"id\":\"12345678-1234-4234-8234-123456789abc\"") != null);
    try std.testing.expect(mem.indexOf(u8, json, "\"cipher\":\"aes-128-ctr\"") != null);
    try std.testing.expect(mem.indexOf(u8, json, "\"kdf\":\"scrypt\"") != null);
    try std.testing.expect(mem.indexOf(u8, json, "\"n\":1024") != null);
    try std.testing.expect(mem.indexOf(u8, json, "\"r\":1") != null);
    try std.testing.expect(mem.indexOf(u8, json, "\"p\":1") != null);
    try std.testing.expect(mem.indexOf(u8, json, "\"dklen\":32") != null);
}
```

### toJson pbkdf2 format

```zig
test "toJson pbkdf2 format" {
    const allocator = std.testing.allocator;

    const private_key = [_]u8{0x01} ** 32;
    const salt = [_]u8{0x02} ** 32;
    const iv = [_]u8{0x03} ** 16;
    const uuid = "12345678-1234-4234-8234-123456789abc".*;

    var keystore = try encrypt(allocator, private_key, "password", .{
        .kdf = .pbkdf2,
        .salt = salt,
        .iv = iv,
        .uuid = uuid,
        .pbkdf2_c = 10000,
    });
    defer keystore.deinit(allocator);

    const json = try toJson(allocator, keystore);
    defer allocator.free(json);

    // Verify JSON contains expected fields
    try std.testing.expect(mem.indexOf(u8, json, "\"version\":3") != null);
    try std.testing.expect(mem.indexOf(u8, json, "\"kdf\":\"pbkdf2\"") != null);
    try std.testing.expect(mem.indexOf(u8, json, "\"c\":10000") != null);
    try std.testing.expect(mem.indexOf(u8, json, "\"prf\":\"hmac-sha256\"") != null);
}
```

### fromJson scrypt round trip

```zig
test "fromJson scrypt round trip" {
    const allocator = std.testing.allocator;

    const private_key = [_]u8{0xab} ** 32;
    const password = "test-password";

    var original = try encrypt(allocator, private_key, password, .{
        .scrypt_n = 1024,
        .scrypt_r = 1,
        .scrypt_p = 1,
    });
    defer original.deinit(allocator);

    // Serialize to JSON
    const json = try toJson(allocator, original);
    defer allocator.free(json);

    // Parse back
    var parsed = try fromJson(allocator, json);
    defer parsed.deinit(allocator);

    // Verify can decrypt with same password
    const decrypted = try decrypt(allocator, parsed, password);
    try std.testing.expectEqualSlices(u8, &private_key, &decrypted);
}
```

### fromJson pbkdf2 round trip

```zig
test "fromJson pbkdf2 round trip" {
    const allocator = std.testing.allocator;

    const private_key = [_]u8{0xcd} ** 32;
    const password = "another-password";

    var original = try encrypt(allocator, private_key, password, .{
        .kdf = .pbkdf2,
        .pbkdf2_c = 1000,
    });
    defer original.deinit(allocator);

    // Serialize to JSON
    const json = try toJson(allocator, original);
    defer allocator.free(json);

    // Parse back
    var parsed = try fromJson(allocator, json);
    defer parsed.deinit(allocator);

    // Verify can decrypt with same password
    const decrypted = try decrypt(allocator, parsed, password);
    try std.testing.expectEqualSlices(u8, &private_key, &decrypted);
}
```

### fromJson external keystore (scrypt)

```zig
test "fromJson external keystore (scrypt)" {
    const allocator = std.testing.allocator;

    // A valid Web3 Secret Storage JSON (simulated external keystore)
    const json =
        \\{"version":3,"id":"12345678-1234-4234-8234-123456789abc","crypto":{"cipher":"aes-128-ctr","ciphertext":"0101010101010101010101010101010101010101010101010101010101010101","cipherparams":{"iv":"01010101010101010101010101010101"},"kdf":"scrypt","kdfparams":{"dklen":32,"n":1024,"p":1,"r":1,"salt":"0202020202020202020202020202020202020202020202020202020202020202"},"mac":"0303030303030303030303030303030303030303030303030303030303030303"}}
    ;

    var parsed = try fromJson(allocator, json);
    defer parsed.deinit(allocator);

    try std.testing.expectEqual(@as(u8, 3), parsed.version);
    try std.testing.expectEqualSlices(u8, "12345678-1234-4234-8234-123456789abc", &parsed.id);
    try std.testing.expectEqual(Kdf.scrypt, parsed.crypto_section.kdf);
    try std.testing.expectEqual(@as(u32, 1024), parsed.crypto_section.kdfparams.scrypt.n);
}
```

### fromJson external keystore (pbkdf2)

```zig
test "fromJson external keystore (pbkdf2)" {
    const allocator = std.testing.allocator;

    const json =
        \\{"version":3,"id":"abcdefab-abcd-4bcd-abcd-abcdefabcdef","crypto":{"cipher":"aes-128-ctr","ciphertext":"abababababababababababababababababababababababababababababababab","cipherparams":{"iv":"cdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcd"},"kdf":"pbkdf2","kdfparams":{"c":5000,"dklen":32,"prf":"hmac-sha256","salt":"efefefefefefefefefefefefefefefefefefefefefefefefefefefefefefefef"},"mac":"1212121212121212121212121212121212121212121212121212121212121212"}}
    ;

    var parsed = try fromJson(allocator, json);
    defer parsed.deinit(allocator);

    try std.testing.expectEqual(@as(u8, 3), parsed.version);
    try std.testing.expectEqual(Kdf.pbkdf2, parsed.crypto_section.kdf);
    try std.testing.expectEqual(@as(u32, 5000), parsed.crypto_section.kdfparams.pbkdf2.c);
}
```

### fromJson invalid version

```zig
test "fromJson invalid version" {
    const allocator = std.testing.allocator;

    const json =
        \\{"version":2,"id":"12345678-1234-4234-8234-123456789abc","crypto":{"cipher":"aes-128-ctr","ciphertext":"0101010101010101010101010101010101010101010101010101010101010101","cipherparams":{"iv":"01010101010101010101010101010101"},"kdf":"scrypt","kdfparams":{"dklen":32,"n":1024,"p":1,"r":1,"salt":"0202020202020202020202020202020202020202020202020202020202020202"},"mac":"0303030303030303030303030303030303030303030303030303030303030303"}}
    ;

    const result = fromJson(allocator, json);
    try std.testing.expectError(KeystoreError.InvalidVersion, result);
}
```

### fromJson unsupported kdf

```zig
test "fromJson unsupported kdf" {
    const allocator = std.testing.allocator;

    const json =
        \\{"version":3,"id":"12345678-1234-4234-8234-123456789abc","crypto":{"cipher":"aes-128-ctr","ciphertext":"0101010101010101010101010101010101010101010101010101010101010101","cipherparams":{"iv":"01010101010101010101010101010101"},"kdf":"argon2id","kdfparams":{"dklen":32},"mac":"0303030303030303030303030303030303030303030303030303030303030303"}}
    ;

    const result = fromJson(allocator, json);
    try std.testing.expectError(KeystoreError.UnsupportedKdf, result);
}
```
