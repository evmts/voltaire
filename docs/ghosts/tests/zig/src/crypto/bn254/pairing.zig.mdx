---
title: '[Zig] src/crypto/bn254/pairing.zig'
source: 'src/crypto/bn254/pairing.zig'
---

> Auto-generated from Zig tests in: src/crypto/bn254/pairing.zig

### finalExponentiation

```zig
test "finalExponentiation" {
    const test_values = [_]Fp12Mont{
        Fp12Mont.initFromInt(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1),
        Fp12Mont.initFromInt(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12),
        Fp12Mont.initFromInt(123, 456, 789, 1011, 1213, 1415, 1617, 1819, 2021, 2223, 2425, 2627),
        Fp12Mont.initFromInt(999, 888, 777, 666, 555, 444, 333, 222, 111, 100, 99, 88),
        Fp12Mont.initFromInt(17, 23, 31, 47, 53, 61, 67, 71, 73, 79, 83, 89),
        Fp12Mont.initFromInt(2023, 2024, 2025, 2026, 2027, 2028, 2029, 2030, 2031, 2032, 2033, 2034),
        Fp12Mont.initFromInt(7, 6, 5, 4, 3, 2, 1, 0, 9, 8, 7, 6),
        Fp12Mont.initFromInt(13, 37, 73, 97, 137, 173, 197, 233, 277, 313, 337, 373),
    };

    for (test_values) |f| {
        const f_pow_r = f.pow(FR_MOD);
        const result = try finalExponentiation(&f_pow_r);
        try std.testing.expect(result.equal(&Fp12Mont.ONE));
    }
}
```

### pairing bilinearity and infinity montgomery

```zig
test "pairing bilinearity and infinity montgomery" {
    const test_cases = [_]struct { p1: u256, p2: u256, q1: u256, q2: u256, scalar: u256 }{
        .{ .p1 = 123, .p2 = 456, .q1 = 321, .q2 = 654, .scalar = 3 },
        .{ .p1 = 789, .p2 = 1011, .q1 = 987, .q2 = 1213, .scalar = 5 },
        .{ .p1 = 1337, .p2 = 2023, .q1 = 1729, .q2 = 2024, .scalar = 7 },
    };
    var i: u256 = 0;
    for (test_cases) |test_case| {
        i += 1;
        const p1 = try G1.GENERATOR.mulByInt(test_case.p1);
        const p2 = try G1.GENERATOR.mulByInt(test_case.p2);
        const q1 = G2.GENERATOR.mulByInt(test_case.q1);
        const q2 = G2.GENERATOR.mulByInt(test_case.q2);

        // Test bilinearity in first argument: e(P1 + P2, Q) = e(P1, Q) * e(P2, Q)
        const p1_plus_p2 = p1.add(&p2);
        const left_side_1 = try pairing(&p1_plus_p2, &q1);
        const e_p1_q1 = try pairing(&p1, &q1);
        const e_p2_q1 = try pairing(&p2, &q1);
        const right_side_1 = e_p1_q1.mul(&e_p2_q1);
        try std.testing.expect(left_side_1.equal(&right_side_1));

        // Test bilinearity in second argument: e(P, Q1 + Q2) = e(P, Q1) * e(P, Q2)
        const q1_plus_q2 = q1.add(&q2);
        const left_side_2 = try pairing(&p1, &q1_plus_q2);
        const e_p1_q2 = try pairing(&p1, &q2);
        const right_side_2 = e_p1_q1.mul(&e_p1_q2);
        try std.testing.expect(left_side_2.equal(&right_side_2));

        // Test scalar multiplication
        const scalar_times_p1 = try p1.mulByInt(test_case.scalar);
        const left_side_3 = try pairing(&scalar_times_p1, &q1);
        const right_side_3 = e_p1_q1.pow(test_case.scalar);
        try std.testing.expect(left_side_3.equal(&right_side_3));
    }

    //Test infinity properties
    const result_inf_gen = try pairing(&G1.INFINITY, &G2.GENERATOR);
    try std.testing.expect(result_inf_gen.equal(&Fp12Mont.ONE));

    const result_gen_inf = try pairing(&G1.GENERATOR, &G2.INFINITY);
    try std.testing.expect(result_gen_inf.equal(&Fp12Mont.ONE));

    const result_both_inf = try pairing(&G1.INFINITY, &G2.INFINITY);
    try std.testing.expect(result_both_inf.equal(&Fp12Mont.ONE));
}
```
