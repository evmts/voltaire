---
title: '[Zig] src/crypto/bn254/FpMont.zig'
source: 'src/crypto/bn254/FpMont.zig'
---

> Auto-generated from Zig tests in: src/crypto/bn254/FpMont.zig

### FpMont.init basic initialization

```zig
test "FpMont.init basic initialization" {
    const a = FpMont.init(123);
    const result = a.toStandardRepresentation();
    try std.testing.expect(result == 123);
}
```

### FpMont.init with modular reduction

```zig
test "FpMont.init with modular reduction" {
    const a = FpMont.init(curve_parameters.FP_MOD + 5);
    const result = a.toStandardRepresentation();
    try std.testing.expect(result == 5);
}
```

### FpMont.add basic addition

```zig
test "FpMont.add basic addition" {
    const a = FpMont.init(10);
    const b = FpMont.init(20);
    const result = a.add(&b);
    const result_std = result.toStandardRepresentation();
    try std.testing.expect(result_std == 30);
}
```

### FpMont.add with modular reduction

```zig
test "FpMont.add with modular reduction" {
    const a = FpMont.init(curve_parameters.FP_MOD - 1);
    const b = FpMont.init(5);
    const result = a.add(&b);
    const result_std = result.toStandardRepresentation();
    try std.testing.expect(result_std == 4);
}
```

### FpMont.add with zero

```zig
test "FpMont.add with zero" {
    const a = FpMont.init(100);
    const b = FpMont.init(0);
    const result = a.add(&b);
    const result_std = result.toStandardRepresentation();
    try std.testing.expect(result_std == 100);
}
```

### FpMont.add resulting in modulus

```zig
test "FpMont.add resulting in modulus" {
    const a = FpMont.init(curve_parameters.FP_MOD - 10);
    const b = FpMont.init(10);
    const result = a.add(&b);
    const result_std = result.toStandardRepresentation();
    try std.testing.expect(result_std == 0);
}
```

### FpMont.neg basic negation

```zig
test "FpMont.neg basic negation" {
    const a = FpMont.init(100);
    const result = a.neg();
    const result_std = result.toStandardRepresentation();
    try std.testing.expect(result_std == curve_parameters.FP_MOD - 100);
}
```

### FpMont.neg of zero

```zig
test "FpMont.neg of zero" {
    const a = FpMont.init(0);
    const result = a.neg();
    const result_std = result.toStandardRepresentation();
    try std.testing.expect(result_std == 0);
}
```

### FpMont.neg of maximum value

```zig
test "FpMont.neg of maximum value" {
    const a = FpMont.init(curve_parameters.FP_MOD - 1);
    const result = a.neg();
    const result_std = result.toStandardRepresentation();
    try std.testing.expect(result_std == 1);
}
```

### FpMont.sub basic subtraction

```zig
test "FpMont.sub basic subtraction" {
    const a = FpMont.init(50);
    const b = FpMont.init(20);
    const result = a.sub(&b);
    const result_std = result.toStandardRepresentation();
    try std.testing.expect(result_std == 30);
}
```

### FpMont.sub with underflow

```zig
test "FpMont.sub with underflow" {
    const a = FpMont.init(10);
    const b = FpMont.init(20);
    const result = a.sub(&b);
    const result_std = result.toStandardRepresentation();
    try std.testing.expect(result_std == curve_parameters.FP_MOD - 10);
}
```

### FpMont.sub with zero

```zig
test "FpMont.sub with zero" {
    const a = FpMont.init(100);
    const b = FpMont.init(0);
    const result = a.sub(&b);
    const result_std = result.toStandardRepresentation();
    try std.testing.expect(result_std == 100);
}
```

### FpMont.sub from zero

```zig
test "FpMont.sub from zero" {
    const a = FpMont.init(0);
    const b = FpMont.init(25);
    const result = a.sub(&b);
    const result_std = result.toStandardRepresentation();
    try std.testing.expect(result_std == curve_parameters.FP_MOD - 25);
}
```

### FpMont.mul basic multiplication

```zig
test "FpMont.mul basic multiplication" {
    const a = FpMont.init(6);
    const b = FpMont.init(5);
    const result = a.mul(&b);
    const result_std = result.toStandardRepresentation();
    try std.testing.expect(result_std == 30);
}
```

### FpMont.mul with zero

```zig
test "FpMont.mul with zero" {
    const a = FpMont.init(100);
    const b = FpMont.init(0);
    const result = a.mul(&b);
    const result_std = result.toStandardRepresentation();
    try std.testing.expect(result_std == 0);
}
```

### FpMont.mul with one

```zig
test "FpMont.mul with one" {
    const a = FpMont.init(123);
    const b = FpMont.init(1);
    const result = a.mul(&b);
    const result_std = result.toStandardRepresentation();
    try std.testing.expect(result_std == 123);
}
```

### FpMont.mul with modular reduction

```zig
test "FpMont.mul with modular reduction" {
    const a = FpMont.init(curve_parameters.FP_MOD - 1);
    const b = FpMont.init(2);
    const result = a.mul(&b);
    const result_std = result.toStandardRepresentation();
    try std.testing.expect(result_std == curve_parameters.FP_MOD - 2);
}
```

### FpMont.mul large values

```zig
test "FpMont.mul large values" {
    const a = FpMont.init(0x1000000000000000000000000000000000000000000000000000000000000000);
    const b = FpMont.init(0x2000000000000000000000000000000000000000000000000000000000000000);
    const result = a.mul(&b);
    const result_std = result.toStandardRepresentation();
    // This will test the modular reduction behavior with large numbers
    try std.testing.expect(result_std < curve_parameters.FP_MOD);
}
```

### FpMont.mulBySmallInt basic multiplication

```zig
test "FpMont.mulBySmallInt basic multiplication" {
    const a = FpMont.init(2);
    const result = a.mulBySmallInt(3);
    const result_std = result.toStandardRepresentation();
    try std.testing.expect(result_std == 6);
}
```

### FpMont.square basic squaring

```zig
test "FpMont.square basic squaring" {
    const a = FpMont.init(7);
    const result = a.square();
    const result_std = result.toStandardRepresentation();
    try std.testing.expect(result_std == 49);
}
```

### FpMont.pow basic power

```zig
test "FpMont.pow basic power" {
    const a = FpMont.init(2);
    const result = a.pow(3);
    const result_std = result.toStandardRepresentation();
    try std.testing.expect(result_std == 8);
}
```

### FpMont.pow to power of zero

```zig
test "FpMont.pow to power of zero" {
    const a = FpMont.init(123);
    const result = a.pow(0);
    const result_std = result.toStandardRepresentation();
    try std.testing.expect(result_std == 1);
}
```

### FpMont.pow to power of one

```zig
test "FpMont.pow to power of one" {
    const a = FpMont.init(456);
    const result = a.pow(1);
    const result_std = result.toStandardRepresentation();
    try std.testing.expect(result_std == 456);
}
```

### FpMont.pow with base zero

```zig
test "FpMont.pow with base zero" {
    const a = FpMont.init(0);
    const result = a.pow(5);
    const result_std = result.toStandardRepresentation();
    try std.testing.expect(result_std == 0);
}
```

### FpMont.pow with base one

```zig
test "FpMont.pow with base one" {
    const a = FpMont.init(1);
    const result = a.pow(100);
    const result_std = result.toStandardRepresentation();
    try std.testing.expect(result_std == 1);
}
```

### FpMont.pow large exponent

```zig
test "FpMont.pow large exponent" {
    const a = FpMont.init(3);
    const result = a.pow(10);
    const result_std = result.toStandardRepresentation();
    try std.testing.expect(result_std == 59049);
}
```

### FpMont.pow with modular reduction

```zig
test "FpMont.pow with modular reduction" {
    const a = FpMont.init(curve_parameters.FP_MOD - 1);
    const result = a.pow(2);
    const result_std = result.toStandardRepresentation();
    try std.testing.expect(result_std == 1);
}
```

### FpMont.inv basic inverse

```zig
test "FpMont.inv basic inverse" {
    const a = FpMont.init(2);
    const a_inv = try a.inv();
    const product = a.mul(&a_inv);
    const product_std = product.toStandardRepresentation();
    try std.testing.expect(product_std == 1);
}
```

### FpMont.inv of one

```zig
test "FpMont.inv of one" {
    const a = FpMont.init(1);
    const result = try a.inv();
    const result_std = result.toStandardRepresentation();
    try std.testing.expect(result_std == 1);
}
```

### FpMont.inv double inverse

```zig
test "FpMont.inv double inverse" {
    const a = FpMont.init(17);
    const a_inv = try a.inv();
    const a_double_inv = try a_inv.inv();
    const a_std = a.toStandardRepresentation();
    const a_double_inv_std = a_double_inv.toStandardRepresentation();
    try std.testing.expect(a_double_inv_std == a_std);
}
```

### FpMont.inv with known value

```zig
test "FpMont.inv with known value" {
    const a = FpMont.init(3);
    const a_inv = try a.inv();
    const product = a.mul(&a_inv);
    const product_std = product.toStandardRepresentation();
    try std.testing.expect(product_std == 1);
}
```

### FpMont.inv large value

```zig
test "FpMont.inv large value" {
    const a = FpMont.init(12345678);
    const a_inv = try a.inv();
    const product = a.mul(&a_inv);
    const product_std = product.toStandardRepresentation();
    try std.testing.expect(product_std == 1);
}
```

### FpMont.inv division by zero

```zig
test "FpMont.inv division by zero" {
    const a = FpMont.init(0);
    try std.testing.expectError(error.DivisionByZero, a.inv());
}
```

### FpMont.equal basic equality

```zig
test "FpMont.equal basic equality" {
    const a = FpMont.init(123);
    const b = FpMont.init(123);
    try std.testing.expect(a.equal(&b));
}
```

### FpMont.equal different values

```zig
test "FpMont.equal different values" {
    const a = FpMont.init(123);
    const b = FpMont.init(456);
    try std.testing.expect(!a.equal(&b));
}
```

### FpMont.mul near modulus boundary

```zig
test "FpMont.mul near modulus boundary" {
    const a = FpMont.init(curve_parameters.FP_MOD - 1);
    const b = FpMont.init(curve_parameters.FP_MOD - 1);
    const result = a.mul(&b);
    const result_std = result.toStandardRepresentation();
    try std.testing.expect(result_std == 1);
}
```

### FpMont.mul maximum values causing overflow

```zig
test "FpMont.mul maximum values causing overflow" {
    const a = FpMont.init(0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);
    const b = FpMont.init(0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);
    const result = a.mul(&b);
    const result_std = result.toStandardRepresentation();
    try std.testing.expect(result_std < curve_parameters.FP_MOD);
}
```

### FpMont.mul distributive property

```zig
test "FpMont.mul distributive property" {
    const a = FpMont.init(123);
    const b = FpMont.init(456);
    const c = FpMont.init(789);
    const left = a.mul(&b.add(&c));
    const right = a.mul(&b).add(&a.mul(&c));
    const left_std = left.toStandardRepresentation();
    const right_std = right.toStandardRepresentation();
    try std.testing.expect(left_std == right_std);
}
```

### FpMont.mul associative property

```zig
test "FpMont.mul associative property" {
    const a = FpMont.init(123);
    const b = FpMont.init(456);
    const c = FpMont.init(789);
    const left = a.mul(&b).mul(&c);
    const right = a.mul(&b.mul(&c));
    const left_std = left.toStandardRepresentation();
    const right_std = right.toStandardRepresentation();
    try std.testing.expect(left_std == right_std);
}
```

### FpMont.add modular wraparound edge case

```zig
test "FpMont.add modular wraparound edge case" {
    const a = FpMont.init(curve_parameters.FP_MOD - 1);
    const b = FpMont.init(curve_parameters.FP_MOD - 1);
    const result = a.add(&b);
    const result_std = result.toStandardRepresentation();
    try std.testing.expect(result_std == curve_parameters.FP_MOD - 2);
}
```

### FpMont.pow edge case with large exponent

```zig
test "FpMont.pow edge case with large exponent" {
    const a = FpMont.init(2);
    const result = a.pow(256);
    const result_std = result.toStandardRepresentation();
    // 2^256 mod FP_MOD should be computed correctly
    try std.testing.expect(result_std < curve_parameters.FP_MOD);
}
```

### FpMont.inv mathematical property a * a^-1 = 1

```zig
test "FpMont.inv mathematical property a * a^-1 = 1" {
    const values = [_]u256{ 2, 3, 7, 11, 13, 17, 65537, curve_parameters.FP_MOD - 1 };
    for (values) |val| {
        const a = FpMont.init(val);
        const a_inv = try a.inv();
        const product = a.mul(&a_inv);
        const product_std = product.toStandardRepresentation();
        try std.testing.expect(product_std == 1);
    }
}
```

### FpMont.addAssign basic assignment

```zig
test "FpMont.addAssign basic assignment" {
    var a = FpMont.init(10);
    const b = FpMont.init(20);
    a.addAssign(&b);
    const result_std = a.toStandardRepresentation();
    try std.testing.expect(result_std == 30);
}
```

### FpMont.subAssign basic assignment

```zig
test "FpMont.subAssign basic assignment" {
    var a = FpMont.init(50);
    const b = FpMont.init(20);
    a.subAssign(&b);
    const result_std = a.toStandardRepresentation();
    try std.testing.expect(result_std == 30);
}
```

### FpMont.mulAssign basic assignment

```zig
test "FpMont.mulAssign basic assignment" {
    var a = FpMont.init(6);
    const b = FpMont.init(5);
    a.mulAssign(&b);
    const result_std = a.toStandardRepresentation();
    try std.testing.expect(result_std == 30);
}
```

### FpMont.mulBySmallIntAssign basic assignment

```zig
test "FpMont.mulBySmallIntAssign basic assignment" {
    var a = FpMont.init(2);
    a.mulBySmallIntAssign(3);
    const result_std = a.toStandardRepresentation();
    try std.testing.expect(result_std == 6);
}
```

### FpMont.squareAssign basic assignment

```zig
test "FpMont.squareAssign basic assignment" {
    var a = FpMont.init(7);
    a.squareAssign();
    const result_std = a.toStandardRepresentation();
    try std.testing.expect(result_std == 49);
}
```

### FpMont.powAssign basic assignment

```zig
test "FpMont.powAssign basic assignment" {
    var a = FpMont.init(2);
    a.powAssign(3);
    const result_std = a.toStandardRepresentation();
    try std.testing.expect(result_std == 8);
}
```

### FpMont.negAssign basic assignment

```zig
test "FpMont.negAssign basic assignment" {
    var a = FpMont.init(100);
    a.negAssign();
    const result_std = a.toStandardRepresentation();
    try std.testing.expect(result_std == curve_parameters.FP_MOD - 100);
}
```

### FpMont.toStandardRepresentation round trip

```zig
test "FpMont.toStandardRepresentation round trip" {
    const values = [_]u256{ 0, 1, 2, 123, 456, 789, curve_parameters.FP_MOD - 1 };
    for (values) |val| {
        const mont = FpMont.init(val);
        const back_to_std = mont.toStandardRepresentation();
        try std.testing.expect(back_to_std == val);
    }
}
```

### FpMont.equal is constant-time by design

```zig
test "FpMont.equal is constant-time by design" {
    // Verify equal() uses simple value comparison (constant-time operation)
    // The implementation uses direct == comparison which is constant-time for fixed-size integers
    const a = FpMont.init(123);
    const b = FpMont.init(123);
    const c = FpMont.init(456);

    // Equal values
    try std.testing.expect(a.equal(&b));

    // Unequal values - same code path, no early return
    try std.testing.expect(!a.equal(&c));

    // Test with zero
    const zero = FpMont.ZERO;
    try std.testing.expect(zero.equal(&FpMont.init(0)));
    try std.testing.expect(!zero.equal(&a));

    // Test with max value
    const max_val = FpMont.init(curve_parameters.FP_MOD - 1);
    try std.testing.expect(max_val.equal(&FpMont.init(curve_parameters.FP_MOD - 1)));
    try std.testing.expect(!max_val.equal(&a));
}
```

### FpMont.equal returns same type for all inputs

```zig
test "FpMont.equal returns same type for all inputs" {
    // Document that equal() always returns bool without branching on comparison result internally
    // This ensures constant-time behavior
    const test_values = [_]u256{ 0, 1, 2, 100, 999, curve_parameters.FP_MOD - 1 };

    for (test_values) |val1| {
        for (test_values) |val2| {
            const a = FpMont.init(val1);
            const b = FpMont.init(val2);
            const result = a.equal(&b);

            // Result is always bool, no exceptions or early returns based on values
            try std.testing.expect(@TypeOf(result) == bool);

            // Verify symmetric property
            try std.testing.expect(a.equal(&b) == b.equal(&a));
        }
    }
}
```
