---
title: '[Zig] src/primitives/BuilderBid/builder_bid.zig'
source: 'src/primitives/BuilderBid/builder_bid.zig'
---

> Auto-generated from Zig tests in: src/primitives/BuilderBid/builder_bid.zig

### BuilderBid.from creates builder bid

```zig
test "BuilderBid.from creates builder bid" {
    const parent_hash: Hash.Hash = [_]u8{0xaa} ** 32;
    const block_hash: Hash.Hash = [_]u8{0xbb} ** 32;
    const builder_pubkey: [BLS_PUBKEY_SIZE]u8 = [_]u8{0xcc} ** BLS_PUBKEY_SIZE;
    const proposer_pubkey: [BLS_PUBKEY_SIZE]u8 = [_]u8{0xdd} ** BLS_PUBKEY_SIZE;
    const fee_recipient = Address.Address{ .bytes = [_]u8{0xee} ** 20 };
    const signature: [BLS_SIGNATURE_SIZE]u8 = [_]u8{0xff} ** BLS_SIGNATURE_SIZE;

    const bid = from(.{
        .slot = 1000000,
        .parent_hash = parent_hash,
        .block_hash = block_hash,
        .builder_pubkey = builder_pubkey,
        .proposer_pubkey = proposer_pubkey,
        .proposer_fee_recipient = fee_recipient,
        .gas_limit = 30000000,
        .gas_used = 15000000,
        .value = 100000000000000000, // 0.1 ETH
        .signature = signature,
    });

    try std.testing.expectEqual(@as(Slot.Slot, 1000000), bid.slot);
    try std.testing.expectEqual(@as(u256, 100000000000000000), bid.value);
}
```

### BuilderBid accessors work correctly

```zig
test "BuilderBid accessors work correctly" {
    const parent_hash: Hash.Hash = [_]u8{0x11} ** 32;
    const block_hash: Hash.Hash = [_]u8{0x22} ** 32;
    const builder_pubkey: [BLS_PUBKEY_SIZE]u8 = [_]u8{0x33} ** BLS_PUBKEY_SIZE;
    const proposer_pubkey: [BLS_PUBKEY_SIZE]u8 = [_]u8{0x44} ** BLS_PUBKEY_SIZE;
    const fee_recipient = Address.Address{ .bytes = [_]u8{0x55} ** 20 };
    const signature: [BLS_SIGNATURE_SIZE]u8 = [_]u8{0x66} ** BLS_SIGNATURE_SIZE;

    const bid = from(.{
        .slot = 1000000,
        .parent_hash = parent_hash,
        .block_hash = block_hash,
        .builder_pubkey = builder_pubkey,
        .proposer_pubkey = proposer_pubkey,
        .proposer_fee_recipient = fee_recipient,
        .gas_limit = 30000000,
        .gas_used = 15000000,
        .value = 100000000000000000,
        .signature = signature,
    });

    try std.testing.expectEqual(@as(Slot.Slot, 1000000), getSlot(bid));
    try std.testing.expectEqualSlices(u8, &parent_hash, &getParentHash(bid));
    try std.testing.expectEqualSlices(u8, &block_hash, &getBlockHash(bid));
    try std.testing.expectEqual(@as(u256, 100000000000000000), getValue(bid));
    try std.testing.expectEqual(@as(u256, 30000000), getGasLimit(bid));
    try std.testing.expectEqual(@as(u256, 15000000), getGasUsed(bid));
}
```

### BuilderBid.equals compares bids

```zig
test "BuilderBid.equals compares bids" {
    const parent_hash: Hash.Hash = [_]u8{0x77} ** 32;
    const block_hash: Hash.Hash = [_]u8{0x88} ** 32;
    const builder_pubkey: [BLS_PUBKEY_SIZE]u8 = [_]u8{0x99} ** BLS_PUBKEY_SIZE;
    const proposer_pubkey: [BLS_PUBKEY_SIZE]u8 = [_]u8{0xaa} ** BLS_PUBKEY_SIZE;
    const fee_recipient = Address.Address{ .bytes = [_]u8{0xbb} ** 20 };
    const signature: [BLS_SIGNATURE_SIZE]u8 = [_]u8{0xcc} ** BLS_SIGNATURE_SIZE;

    const bid1 = from(.{
        .slot = 1000000,
        .parent_hash = parent_hash,
        .block_hash = block_hash,
        .builder_pubkey = builder_pubkey,
        .proposer_pubkey = proposer_pubkey,
        .proposer_fee_recipient = fee_recipient,
        .gas_limit = 30000000,
        .gas_used = 15000000,
        .value = 100000000000000000,
        .signature = signature,
    });

    const bid2 = from(.{
        .slot = 1000000,
        .parent_hash = parent_hash,
        .block_hash = block_hash,
        .builder_pubkey = builder_pubkey,
        .proposer_pubkey = proposer_pubkey,
        .proposer_fee_recipient = fee_recipient,
        .gas_limit = 30000000,
        .gas_used = 15000000,
        .value = 200000000000000000, // Different value doesn't affect equality
        .signature = signature,
    });

    const other_block_hash: Hash.Hash = [_]u8{0xdd} ** 32;
    const bid3 = from(.{
        .slot = 1000001,
        .parent_hash = parent_hash,
        .block_hash = other_block_hash,
        .builder_pubkey = builder_pubkey,
        .proposer_pubkey = proposer_pubkey,
        .proposer_fee_recipient = fee_recipient,
        .gas_limit = 30000000,
        .gas_used = 15000000,
        .value = 100000000000000000,
        .signature = signature,
    });

    try std.testing.expect(equals(bid1, bid2));
    try std.testing.expect(!equals(bid1, bid3));
}
```

### BuilderBid.compareByValue

```zig
test "BuilderBid.compareByValue" {
    const parent_hash: Hash.Hash = [_]u8{0xee} ** 32;
    const block_hash: Hash.Hash = [_]u8{0xff} ** 32;
    const builder_pubkey: [BLS_PUBKEY_SIZE]u8 = EMPTY_PUBKEY;
    const proposer_pubkey: [BLS_PUBKEY_SIZE]u8 = EMPTY_PUBKEY;
    const fee_recipient = Address.Address{ .bytes = [_]u8{0x00} ** 20 };
    const signature: [BLS_SIGNATURE_SIZE]u8 = EMPTY_SIGNATURE;

    const low_bid = from(.{
        .slot = 1000000,
        .parent_hash = parent_hash,
        .block_hash = block_hash,
        .builder_pubkey = builder_pubkey,
        .proposer_pubkey = proposer_pubkey,
        .proposer_fee_recipient = fee_recipient,
        .gas_limit = 30000000,
        .gas_used = 15000000,
        .value = 100000000000000000, // 0.1 ETH
        .signature = signature,
    });

    const high_bid = from(.{
        .slot = 1000000,
        .parent_hash = parent_hash,
        .block_hash = block_hash,
        .builder_pubkey = builder_pubkey,
        .proposer_pubkey = proposer_pubkey,
        .proposer_fee_recipient = fee_recipient,
        .gas_limit = 30000000,
        .gas_used = 15000000,
        .value = 500000000000000000, // 0.5 ETH
        .signature = signature,
    });

    try std.testing.expect(compareByValue(low_bid, high_bid) < 0);
    try std.testing.expect(compareByValue(high_bid, low_bid) > 0);
    try std.testing.expect(compareByValue(low_bid, low_bid) == 0);
}
```

### BuilderBid.hasValue

```zig
test "BuilderBid.hasValue" {
    const parent_hash: Hash.Hash = [_]u8{0x11} ** 32;
    const block_hash: Hash.Hash = [_]u8{0x22} ** 32;
    const builder_pubkey: [BLS_PUBKEY_SIZE]u8 = EMPTY_PUBKEY;
    const proposer_pubkey: [BLS_PUBKEY_SIZE]u8 = EMPTY_PUBKEY;
    const fee_recipient = Address.Address{ .bytes = [_]u8{0x00} ** 20 };
    const signature: [BLS_SIGNATURE_SIZE]u8 = EMPTY_SIGNATURE;

    const bid_with_value = from(.{
        .slot = 1000000,
        .parent_hash = parent_hash,
        .block_hash = block_hash,
        .builder_pubkey = builder_pubkey,
        .proposer_pubkey = proposer_pubkey,
        .proposer_fee_recipient = fee_recipient,
        .gas_limit = 30000000,
        .gas_used = 15000000,
        .value = 1,
        .signature = signature,
    });

    const bid_no_value = from(.{
        .slot = 1000000,
        .parent_hash = parent_hash,
        .block_hash = block_hash,
        .builder_pubkey = builder_pubkey,
        .proposer_pubkey = proposer_pubkey,
        .proposer_fee_recipient = fee_recipient,
        .gas_limit = 30000000,
        .gas_used = 15000000,
        .value = 0,
        .signature = signature,
    });

    try std.testing.expect(hasValue(bid_with_value));
    try std.testing.expect(!hasValue(bid_no_value));
}
```

### BuilderBid.hasSignature

```zig
test "BuilderBid.hasSignature" {
    const parent_hash: Hash.Hash = [_]u8{0x33} ** 32;
    const block_hash: Hash.Hash = [_]u8{0x44} ** 32;
    const builder_pubkey: [BLS_PUBKEY_SIZE]u8 = EMPTY_PUBKEY;
    const proposer_pubkey: [BLS_PUBKEY_SIZE]u8 = EMPTY_PUBKEY;
    const fee_recipient = Address.Address{ .bytes = [_]u8{0x00} ** 20 };

    const signed_bid = from(.{
        .slot = 1000000,
        .parent_hash = parent_hash,
        .block_hash = block_hash,
        .builder_pubkey = builder_pubkey,
        .proposer_pubkey = proposer_pubkey,
        .proposer_fee_recipient = fee_recipient,
        .gas_limit = 30000000,
        .gas_used = 15000000,
        .value = 100000000000000000,
        .signature = [_]u8{0xff} ** BLS_SIGNATURE_SIZE,
    });

    const unsigned_bid = from(.{
        .slot = 1000000,
        .parent_hash = parent_hash,
        .block_hash = block_hash,
        .builder_pubkey = builder_pubkey,
        .proposer_pubkey = proposer_pubkey,
        .proposer_fee_recipient = fee_recipient,
        .gas_limit = 30000000,
        .gas_used = 15000000,
        .value = 100000000000000000,
        .signature = EMPTY_SIGNATURE,
    });

    try std.testing.expect(hasSignature(signed_bid));
    try std.testing.expect(!hasSignature(unsigned_bid));
}
```

### BuilderBid.SSZ_SIZE is correct

```zig
test "BuilderBid.SSZ_SIZE is correct" {
    // slot(8) + parent_hash(32) + block_hash(32) + builder_pubkey(48) +
    // proposer_pubkey(48) + proposer_fee_recipient(20) + gas_limit(32) +
    // gas_used(32) + value(32) + signature(96) = 380
    try std.testing.expectEqual(@as(usize, 380), SSZ_SIZE);
}
```

### BuilderBid.sszEncode produces correct size

```zig
test "BuilderBid.sszEncode produces correct size" {
    const bid = from(.{
        .slot = 1000000,
        .parent_hash = [_]u8{0xaa} ** 32,
        .block_hash = [_]u8{0xbb} ** 32,
        .builder_pubkey = [_]u8{0xcc} ** BLS_PUBKEY_SIZE,
        .proposer_pubkey = [_]u8{0xdd} ** BLS_PUBKEY_SIZE,
        .proposer_fee_recipient = Address.Address{ .bytes = [_]u8{0xee} ** 20 },
        .gas_limit = 30000000,
        .gas_used = 15000000,
        .value = 100000000000000000,
        .signature = [_]u8{0xff} ** BLS_SIGNATURE_SIZE,
    });

    const encoded = sszEncode(bid);
    try std.testing.expectEqual(@as(usize, SSZ_SIZE), encoded.len);
}
```

### BuilderBid.sszEncode slot is little-endian

```zig
test "BuilderBid.sszEncode slot is little-endian" {
    const bid = from(.{
        .slot = 0x0102030405060708,
        .parent_hash = [_]u8{0x00} ** 32,
        .block_hash = [_]u8{0x00} ** 32,
        .builder_pubkey = EMPTY_PUBKEY,
        .proposer_pubkey = EMPTY_PUBKEY,
        .proposer_fee_recipient = Address.Address{ .bytes = [_]u8{0x00} ** 20 },
        .gas_limit = 0,
        .gas_used = 0,
        .value = 0,
        .signature = EMPTY_SIGNATURE,
    });

    const encoded = sszEncode(bid);
    // First 8 bytes are slot in little-endian
    try std.testing.expectEqual(@as(u8, 0x08), encoded[0]);
    try std.testing.expectEqual(@as(u8, 0x07), encoded[1]);
    try std.testing.expectEqual(@as(u8, 0x06), encoded[2]);
    try std.testing.expectEqual(@as(u8, 0x05), encoded[3]);
    try std.testing.expectEqual(@as(u8, 0x04), encoded[4]);
    try std.testing.expectEqual(@as(u8, 0x03), encoded[5]);
    try std.testing.expectEqual(@as(u8, 0x02), encoded[6]);
    try std.testing.expectEqual(@as(u8, 0x01), encoded[7]);
}
```

### BuilderBid.sszDecode roundtrip

```zig
test "BuilderBid.sszDecode roundtrip" {
    const original = from(.{
        .slot = 1000000,
        .parent_hash = [_]u8{0xaa} ** 32,
        .block_hash = [_]u8{0xbb} ** 32,
        .builder_pubkey = [_]u8{0xcc} ** BLS_PUBKEY_SIZE,
        .proposer_pubkey = [_]u8{0xdd} ** BLS_PUBKEY_SIZE,
        .proposer_fee_recipient = Address.Address{ .bytes = [_]u8{0xee} ** 20 },
        .gas_limit = 30000000,
        .gas_used = 15000000,
        .value = 100000000000000000,
        .signature = [_]u8{0xff} ** BLS_SIGNATURE_SIZE,
    });

    const encoded = sszEncode(original);
    const decoded = try sszDecode(&encoded);

    try std.testing.expectEqual(original.slot, decoded.slot);
    try std.testing.expectEqualSlices(u8, &original.parent_hash, &decoded.parent_hash);
    try std.testing.expectEqualSlices(u8, &original.block_hash, &decoded.block_hash);
    try std.testing.expectEqualSlices(u8, &original.builder_pubkey, &decoded.builder_pubkey);
    try std.testing.expectEqualSlices(u8, &original.proposer_pubkey, &decoded.proposer_pubkey);
    try std.testing.expectEqualSlices(u8, &original.proposer_fee_recipient.bytes, &decoded.proposer_fee_recipient.bytes);
    try std.testing.expectEqual(original.gas_limit, decoded.gas_limit);
    try std.testing.expectEqual(original.gas_used, decoded.gas_used);
    try std.testing.expectEqual(original.value, decoded.value);
    try std.testing.expectEqualSlices(u8, &original.signature, &decoded.signature);
}
```

### BuilderBid.sszDecode rejects invalid length

```zig
test "BuilderBid.sszDecode rejects invalid length" {
    const short_data = [_]u8{0x00} ** 100;
    try std.testing.expectError(error.InvalidLength, sszDecode(&short_data));

    const long_data = [_]u8{0x00} ** 400;
    try std.testing.expectError(error.InvalidLength, sszDecode(&long_data));
}
```

### BuilderBid.signingRoot produces consistent hash

```zig
test "BuilderBid.signingRoot produces consistent hash" {
    const bid = from(.{
        .slot = 1000000,
        .parent_hash = [_]u8{0xaa} ** 32,
        .block_hash = [_]u8{0xbb} ** 32,
        .builder_pubkey = [_]u8{0xcc} ** BLS_PUBKEY_SIZE,
        .proposer_pubkey = [_]u8{0xdd} ** BLS_PUBKEY_SIZE,
        .proposer_fee_recipient = Address.Address{ .bytes = [_]u8{0xee} ** 20 },
        .gas_limit = 30000000,
        .gas_used = 15000000,
        .value = 100000000000000000,
        .signature = [_]u8{0xff} ** BLS_SIGNATURE_SIZE,
    });

    const root1 = signingRoot(bid);
    const root2 = signingRoot(bid);

    try std.testing.expectEqualSlices(u8, &root1, &root2);
}
```

### BuilderBid.signingRoot differs for different bids

```zig
test "BuilderBid.signingRoot differs for different bids" {
    const bid1 = from(.{
        .slot = 1000000,
        .parent_hash = [_]u8{0xaa} ** 32,
        .block_hash = [_]u8{0xbb} ** 32,
        .builder_pubkey = [_]u8{0xcc} ** BLS_PUBKEY_SIZE,
        .proposer_pubkey = [_]u8{0xdd} ** BLS_PUBKEY_SIZE,
        .proposer_fee_recipient = Address.Address{ .bytes = [_]u8{0xee} ** 20 },
        .gas_limit = 30000000,
        .gas_used = 15000000,
        .value = 100000000000000000,
        .signature = EMPTY_SIGNATURE,
    });

    const bid2 = from(.{
        .slot = 1000001, // Different slot
        .parent_hash = [_]u8{0xaa} ** 32,
        .block_hash = [_]u8{0xbb} ** 32,
        .builder_pubkey = [_]u8{0xcc} ** BLS_PUBKEY_SIZE,
        .proposer_pubkey = [_]u8{0xdd} ** BLS_PUBKEY_SIZE,
        .proposer_fee_recipient = Address.Address{ .bytes = [_]u8{0xee} ** 20 },
        .gas_limit = 30000000,
        .gas_used = 15000000,
        .value = 100000000000000000,
        .signature = EMPTY_SIGNATURE,
    });

    const root1 = signingRoot(bid1);
    const root2 = signingRoot(bid2);

    try std.testing.expect(!std.mem.eql(u8, &root1, &root2));
}
```

### BuilderBid.signingRoot ignores signature field

```zig
test "BuilderBid.signingRoot ignores signature field" {
    const bid1 = from(.{
        .slot = 1000000,
        .parent_hash = [_]u8{0xaa} ** 32,
        .block_hash = [_]u8{0xbb} ** 32,
        .builder_pubkey = [_]u8{0xcc} ** BLS_PUBKEY_SIZE,
        .proposer_pubkey = [_]u8{0xdd} ** BLS_PUBKEY_SIZE,
        .proposer_fee_recipient = Address.Address{ .bytes = [_]u8{0xee} ** 20 },
        .gas_limit = 30000000,
        .gas_used = 15000000,
        .value = 100000000000000000,
        .signature = EMPTY_SIGNATURE,
    });

    const bid2 = from(.{
        .slot = 1000000,
        .parent_hash = [_]u8{0xaa} ** 32,
        .block_hash = [_]u8{0xbb} ** 32,
        .builder_pubkey = [_]u8{0xcc} ** BLS_PUBKEY_SIZE,
        .proposer_pubkey = [_]u8{0xdd} ** BLS_PUBKEY_SIZE,
        .proposer_fee_recipient = Address.Address{ .bytes = [_]u8{0xee} ** 20 },
        .gas_limit = 30000000,
        .gas_used = 15000000,
        .value = 100000000000000000,
        .signature = [_]u8{0xff} ** BLS_SIGNATURE_SIZE, // Different signature
    });

    const root1 = signingRoot(bid1);
    const root2 = signingRoot(bid2);

    // Signing root should be the same since signature is excluded
    try std.testing.expectEqualSlices(u8, &root1, &root2);
}
```
