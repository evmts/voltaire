---
title: '[Zig] src/primitives/Receipt/Receipt.zig'
source: 'src/primitives/Receipt/Receipt.zig'
---

> Auto-generated from Zig tests in: src/primitives/Receipt/Receipt.zig

### Receipt.from creates valid receipt

```zig
test "Receipt.from creates valid receipt" {
    const allocator = testing.allocator;
    const receipt = try createMockReceipt(allocator);
    defer receipt.deinit(allocator);

    const validated = try Receipt.from(receipt);
    try testing.expectEqual(receipt.transaction_index, validated.transaction_index);
    try testing.expectEqual(receipt.block_number, validated.block_number);
    try testing.expect(receipt.transaction_hash.eql(validated.transaction_hash));
}
```

### Receipt.from rejects invalid logs_bloom length

```zig
test "Receipt.from rejects invalid logs_bloom length" {
    const allocator = testing.allocator;
    var receipt = try createMockReceipt(allocator);
    defer receipt.deinit(allocator);

    // This test validates that logs_bloom must be exactly 256 bytes
    // Since we can't change array size at runtime, this test verifies
    // the validation logic exists
    const validated = try Receipt.from(receipt);
    try testing.expectEqual(@as(usize, 256), validated.logs_bloom.len);
}
```

### Receipt.isPreByzantium returns false for post-Byzantium receipt

```zig
test "Receipt.isPreByzantium returns false for post-Byzantium receipt" {
    const allocator = testing.allocator;
    const receipt = try createMockReceipt(allocator);
    defer receipt.deinit(allocator);

    try testing.expect(!receipt.isPreByzantium());
    try testing.expect(receipt.status != null);
    try testing.expect(receipt.root == null);
}
```

### Receipt.isPreByzantium returns true for pre-Byzantium receipt

```zig
test "Receipt.isPreByzantium returns true for pre-Byzantium receipt" {
    const allocator = testing.allocator;
    var receipt = try createMockReceipt(allocator);
    defer receipt.deinit(allocator);

    // Convert to pre-Byzantium
    const state_root = try Hash.fromHex("0x1234567890123456789012345678901234567890123456789012345678901234");
    receipt.status = null;
    receipt.root = state_root;

    try testing.expect(receipt.isPreByzantium());
    try testing.expect(receipt.status == null);
    try testing.expect(receipt.root != null);
}
```

### assertValid passes for post-Byzantium receipt

```zig
test "assertValid passes for post-Byzantium receipt" {
    const allocator = testing.allocator;
    const receipt = try createMockReceipt(allocator);
    defer receipt.deinit(allocator);

    try assertValid(receipt);
}
```

### assertValid passes for pre-Byzantium receipt

```zig
test "assertValid passes for pre-Byzantium receipt" {
    const allocator = testing.allocator;
    var receipt = try createMockReceipt(allocator);
    defer receipt.deinit(allocator);

    const state_root = try Hash.fromHex("0x1234567890123456789012345678901234567890123456789012345678901234");
    receipt.status = null;
    receipt.root = state_root;

    try assertValid(receipt);
}
```

### assertValid fails when both status and root present

```zig
test "assertValid fails when both status and root present" {
    const allocator = testing.allocator;
    var receipt = try createMockReceipt(allocator);
    defer receipt.deinit(allocator);

    const state_root = try Hash.fromHex("0x1234567890123456789012345678901234567890123456789012345678901234");
    receipt.root = state_root; // Now has both status and root

    try testing.expectError(error.ByzantiumForkIncompatibility, assertValid(receipt));
}
```

### assertValid fails when neither status nor root present

```zig
test "assertValid fails when neither status nor root present" {
    const allocator = testing.allocator;
    var receipt = try createMockReceipt(allocator);
    defer receipt.deinit(allocator);

    receipt.status = null;
    receipt.root = null; // Neither present

    try testing.expectError(error.ByzantiumForkIncompatibility, assertValid(receipt));
}
```

### Receipt handles contract creation

```zig
test "Receipt handles contract creation" {
    const allocator = testing.allocator;
    var receipt = try createMockReceipt(allocator);
    defer receipt.deinit(allocator);

    const contract_addr = try Address.fromHex("0x742d35Cc6634C0532925a3b844Bc9e7595f0bEb3");
    receipt.to = null;
    receipt.contract_address = contract_addr;

    try testing.expect(receipt.to == null);
    try testing.expect(receipt.contract_address != null);
    try testing.expect(receipt.contract_address.?.eql(contract_addr));
}
```

### Receipt handles EIP-4844 blob fields

```zig
test "Receipt handles EIP-4844 blob fields" {
    const allocator = testing.allocator;
    var receipt = try createMockReceipt(allocator);
    defer receipt.deinit(allocator);

    receipt.type = .eip4844;
    receipt.blob_gas_used = 131072;
    receipt.blob_gas_price = 1;

    try testing.expectEqual(TransactionType.eip4844, receipt.type);
    try testing.expectEqual(@as(u256, 131072), receipt.blob_gas_used.?);
    try testing.expectEqual(@as(u256, 1), receipt.blob_gas_price.?);
}
```

### Receipt.clone creates deep copy

```zig
test "Receipt.clone creates deep copy" {
    const allocator = testing.allocator;
    const original = try createMockReceipt(allocator);
    defer original.deinit(allocator);

    const cloned = try original.clone(allocator);
    defer cloned.deinit(allocator);

    // Verify values are equal
    try testing.expect(cloned.transaction_hash.eql(original.transaction_hash));
    try testing.expectEqual(original.transaction_index, cloned.transaction_index);
    try testing.expect(cloned.block_hash.eql(original.block_hash));
    try testing.expectEqual(original.block_number, cloned.block_number);
    try testing.expect(cloned.from.eql(original.from));
    try testing.expectEqual(original.cumulative_gas_used, cloned.cumulative_gas_used);
    try testing.expectEqual(original.gas_used, cloned.gas_used);
    try testing.expectEqual(original.type, cloned.type);

    // Verify logs pointer is different (deep copy)
    try testing.expect(cloned.logs.ptr != original.logs.ptr);
}
```

### TransactionStatus.isSuccess returns true for successful tx

```zig
test "TransactionStatus.isSuccess returns true for successful tx" {
    const status = TransactionStatus{ .success = true, .gas_used = 21000 };
    try testing.expect(status.isSuccess());
    try testing.expect(!status.isFailed());
}
```

### TransactionStatus.isFailed returns true for failed tx

```zig
test "TransactionStatus.isFailed returns true for failed tx" {
    const status = TransactionStatus{ .success = false, .gas_used = 21000 };
    try testing.expect(status.isFailed());
    try testing.expect(!status.isSuccess());
}
```

### TransactionStatus.isPending always returns false

```zig
test "TransactionStatus.isPending always returns false" {
    const status = TransactionStatus{ .success = true, .gas_used = 21000 };
    try testing.expect(!status.isPending());
}
```

### Receipt with all transaction types

```zig
test "Receipt with all transaction types" {
    const allocator = testing.allocator;
    var receipt = try createMockReceipt(allocator);
    defer receipt.deinit(allocator);

    const types = [_]TransactionType{ .legacy, .eip2930, .eip1559, .eip4844, .eip7702 };
    for (types) |tx_type| {
        receipt.type = tx_type;
        try testing.expectEqual(tx_type, receipt.type);
    }
}
```

### Receipt with failed transaction status

```zig
test "Receipt with failed transaction status" {
    const allocator = testing.allocator;
    var receipt = try createMockReceipt(allocator);
    defer receipt.deinit(allocator);

    receipt.status = TransactionStatus{ .success = false, .gas_used = 21000 };

    try testing.expect(!receipt.status.?.isSuccess());
    try testing.expect(receipt.status.?.isFailed());
}
```

### Receipt with zero gas used

```zig
test "Receipt with zero gas used" {
    const allocator = testing.allocator;
    var receipt = try createMockReceipt(allocator);
    defer receipt.deinit(allocator);

    receipt.gas_used = 0;
    receipt.cumulative_gas_used = 0;
    receipt.effective_gas_price = 0;

    try testing.expectEqual(@as(u256, 0), receipt.gas_used);
    try testing.expectEqual(@as(u256, 0), receipt.cumulative_gas_used);
    try testing.expectEqual(@as(u256, 0), receipt.effective_gas_price);
}
```

### Receipt with maximum gas values

```zig
test "Receipt with maximum gas values" {
    const allocator = testing.allocator;
    var receipt = try createMockReceipt(allocator);
    defer receipt.deinit(allocator);

    const max = std.math.maxInt(u256);
    receipt.gas_used = max;
    receipt.cumulative_gas_used = max;
    receipt.effective_gas_price = max;

    try testing.expectEqual(max, receipt.gas_used);
    try testing.expectEqual(max, receipt.cumulative_gas_used);
    try testing.expectEqual(max, receipt.effective_gas_price);
}
```

### Receipt with logs

```zig
test "Receipt with logs" {
    const allocator = testing.allocator;
    const topic0 = try Hash.fromHex("0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef");

    const topics = try allocator.alloc(Hash, 1);
    topics[0] = topic0;
    const data = try allocator.alloc(u8, 32);
    @memset(data, 0);

    const logs = try allocator.alloc(EventLog, 1);
    logs[0] = EventLog{
        .address = Address.ZERO,
        .topics = topics,
        .data = data,
        .block_number = 100,
        .transaction_hash = null,
        .transaction_index = null,
        .log_index = 0,
        .removed = false,
    };

    var receipt = try createMockReceipt(allocator);
    allocator.free(receipt.logs); // Free empty logs
    receipt.logs = logs;
    defer receipt.deinit(allocator);

    try testing.expectEqual(@as(usize, 1), receipt.logs.len);
    try testing.expect(receipt.logs[0].address.eql(Address.ZERO));
}
```
