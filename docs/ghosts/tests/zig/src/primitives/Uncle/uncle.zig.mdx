---
title: '[Zig] src/primitives/Uncle/uncle.zig'
source: 'src/primitives/Uncle/uncle.zig'
---

> Auto-generated from Zig tests in: src/primitives/Uncle/uncle.zig

### Uncle.from creates uncle

```zig
test "Uncle.from creates uncle" {
    const parent_hash: BlockHash.BlockHash = [_]u8{0xaa} ** 32;
    const ommers_hash: Hash.Hash = [_]u8{0xbb} ** 32;
    const beneficiary = Address.Address{ .bytes = [_]u8{0xcc} ** 20 };
    const state_root: Hash.Hash = [_]u8{0xdd} ** 32;
    const txs_root: Hash.Hash = [_]u8{0xee} ** 32;
    const receipts_root: Hash.Hash = [_]u8{0xff} ** 32;
    const mix_hash: Hash.Hash = [_]u8{0x11} ** 32;

    const uncle = from(.{
        .parent_hash = parent_hash,
        .ommers_hash = ommers_hash,
        .beneficiary = beneficiary,
        .state_root = state_root,
        .transactions_root = txs_root,
        .receipts_root = receipts_root,
        .logs_bloom = EMPTY_BLOOM,
        .difficulty = 13000000000000000,
        .number = 15000000,
        .gas_limit = 30000000,
        .gas_used = 15000000,
        .timestamp = 1680000000,
        .extra_data = &[_]u8{},
        .mix_hash = mix_hash,
        .nonce = EMPTY_NONCE,
    });

    try std.testing.expectEqual(@as(BlockNumber.BlockNumber, 15000000), uncle.number);
    try std.testing.expectEqual(@as(u256, 13000000000000000), uncle.difficulty);
}
```

### Uncle accessors work correctly

```zig
test "Uncle accessors work correctly" {
    const parent_hash: BlockHash.BlockHash = [_]u8{0x22} ** 32;
    const ommers_hash: Hash.Hash = [_]u8{0x33} ** 32;
    const beneficiary = Address.Address{ .bytes = [_]u8{0x44} ** 20 };
    const state_root: Hash.Hash = [_]u8{0x55} ** 32;
    const txs_root: Hash.Hash = [_]u8{0x66} ** 32;
    const receipts_root: Hash.Hash = [_]u8{0x77} ** 32;
    const mix_hash: Hash.Hash = [_]u8{0x88} ** 32;

    const uncle = from(.{
        .parent_hash = parent_hash,
        .ommers_hash = ommers_hash,
        .beneficiary = beneficiary,
        .state_root = state_root,
        .transactions_root = txs_root,
        .receipts_root = receipts_root,
        .logs_bloom = EMPTY_BLOOM,
        .difficulty = 13000000000000000,
        .number = 15000000,
        .gas_limit = 30000000,
        .gas_used = 15000000,
        .timestamp = 1680000000,
        .extra_data = &[_]u8{},
        .mix_hash = mix_hash,
        .nonce = EMPTY_NONCE,
    });

    try std.testing.expectEqualSlices(u8, &parent_hash, &getParentHash(uncle));
    try std.testing.expectEqual(@as(BlockNumber.BlockNumber, 15000000), getNumber(uncle));
    try std.testing.expectEqual(@as(u256, 13000000000000000), getDifficulty(uncle));
    try std.testing.expectEqual(@as(u256, 1680000000), getTimestamp(uncle));
    try std.testing.expectEqual(@as(u256, 30000000), getGasLimit(uncle));
    try std.testing.expectEqual(@as(u256, 15000000), getGasUsed(uncle));
}
```

### Uncle.equals compares uncles

```zig
test "Uncle.equals compares uncles" {
    const parent_hash: BlockHash.BlockHash = [_]u8{0x99} ** 32;
    const ommers_hash: Hash.Hash = [_]u8{0xaa} ** 32;
    const beneficiary = Address.Address{ .bytes = [_]u8{0xbb} ** 20 };
    const state_root: Hash.Hash = [_]u8{0xcc} ** 32;
    const txs_root: Hash.Hash = [_]u8{0xdd} ** 32;
    const receipts_root: Hash.Hash = [_]u8{0xee} ** 32;
    const mix_hash: Hash.Hash = [_]u8{0xff} ** 32;

    const uncle1 = from(.{
        .parent_hash = parent_hash,
        .ommers_hash = ommers_hash,
        .beneficiary = beneficiary,
        .state_root = state_root,
        .transactions_root = txs_root,
        .receipts_root = receipts_root,
        .logs_bloom = EMPTY_BLOOM,
        .difficulty = 13000000000000000,
        .number = 15000000,
        .gas_limit = 30000000,
        .gas_used = 15000000,
        .timestamp = 1680000000,
        .extra_data = &[_]u8{},
        .mix_hash = mix_hash,
        .nonce = EMPTY_NONCE,
    });

    const uncle2 = from(.{
        .parent_hash = parent_hash,
        .ommers_hash = ommers_hash,
        .beneficiary = beneficiary,
        .state_root = state_root,
        .transactions_root = txs_root,
        .receipts_root = receipts_root,
        .logs_bloom = EMPTY_BLOOM,
        .difficulty = 13000000000000000,
        .number = 15000000,
        .gas_limit = 30000000,
        .gas_used = 15000000,
        .timestamp = 1680000000,
        .extra_data = &[_]u8{},
        .mix_hash = mix_hash,
        .nonce = EMPTY_NONCE,
    });

    const other_beneficiary = Address.Address{ .bytes = [_]u8{0x11} ** 20 };
    const uncle3 = from(.{
        .parent_hash = parent_hash,
        .ommers_hash = ommers_hash,
        .beneficiary = other_beneficiary,
        .state_root = state_root,
        .transactions_root = txs_root,
        .receipts_root = receipts_root,
        .logs_bloom = EMPTY_BLOOM,
        .difficulty = 13000000000000000,
        .number = 15000001,
        .gas_limit = 30000000,
        .gas_used = 15000000,
        .timestamp = 1680000012,
        .extra_data = &[_]u8{},
        .mix_hash = mix_hash,
        .nonce = EMPTY_NONCE,
    });

    try std.testing.expect(equals(uncle1, uncle2));
    try std.testing.expect(!equals(uncle1, uncle3));
}
```

### Uncle.rlpEncode produces valid RLP

```zig
test "Uncle.rlpEncode produces valid RLP" {
    const allocator = std.testing.allocator;
    const parent_hash: BlockHash.BlockHash = [_]u8{0xaa} ** 32;
    const ommers_hash: Hash.Hash = [_]u8{0xbb} ** 32;
    const beneficiary = Address.Address{ .bytes = [_]u8{0xcc} ** 20 };
    const state_root: Hash.Hash = [_]u8{0xdd} ** 32;
    const txs_root: Hash.Hash = [_]u8{0xee} ** 32;
    const receipts_root: Hash.Hash = [_]u8{0xff} ** 32;
    const mix_hash: Hash.Hash = [_]u8{0x11} ** 32;

    const uncle = from(.{
        .parent_hash = parent_hash,
        .ommers_hash = ommers_hash,
        .beneficiary = beneficiary,
        .state_root = state_root,
        .transactions_root = txs_root,
        .receipts_root = receipts_root,
        .logs_bloom = EMPTY_BLOOM,
        .difficulty = 13000000000000000,
        .number = 15000000,
        .gas_limit = 30000000,
        .gas_used = 15000000,
        .timestamp = 1680000000,
        .extra_data = &[_]u8{},
        .mix_hash = mix_hash,
        .nonce = EMPTY_NONCE,
    });

    const encoded = try rlpEncode(&uncle, allocator);
    defer allocator.free(encoded);

    // Should be a valid RLP list (starts with 0xf8 or higher for long lists)
    try std.testing.expect(encoded.len > 0);
    try std.testing.expect(encoded[0] >= 0xc0 or encoded[0] >= 0xf7);
}
```

### Uncle.hash computes deterministic hash

```zig
test "Uncle.hash computes deterministic hash" {
    const allocator = std.testing.allocator;
    const parent_hash: BlockHash.BlockHash = [_]u8{0x12} ** 32;
    const ommers_hash: Hash.Hash = [_]u8{0x34} ** 32;
    const beneficiary = Address.Address{ .bytes = [_]u8{0x56} ** 20 };
    const state_root: Hash.Hash = [_]u8{0x78} ** 32;
    const txs_root: Hash.Hash = [_]u8{0x9a} ** 32;
    const receipts_root: Hash.Hash = [_]u8{0xbc} ** 32;
    const mix_hash: Hash.Hash = [_]u8{0xde} ** 32;

    const uncle = from(.{
        .parent_hash = parent_hash,
        .ommers_hash = ommers_hash,
        .beneficiary = beneficiary,
        .state_root = state_root,
        .transactions_root = txs_root,
        .receipts_root = receipts_root,
        .logs_bloom = EMPTY_BLOOM,
        .difficulty = 1000000,
        .number = 100,
        .gas_limit = 8000000,
        .gas_used = 4000000,
        .timestamp = 1600000000,
        .extra_data = &[_]u8{},
        .mix_hash = mix_hash,
        .nonce = EMPTY_NONCE,
    });

    const hash1 = try hash(&uncle, allocator);
    const hash2 = try hash(&uncle, allocator);

    // Hash should be 32 bytes and deterministic
    try std.testing.expectEqual(@as(usize, 32), hash1.len);
    try std.testing.expect(Hash.equals(&hash1, &hash2));
}
```

### Uncle.hash different uncles have different hashes

```zig
test "Uncle.hash different uncles have different hashes" {
    const allocator = std.testing.allocator;
    const parent_hash: BlockHash.BlockHash = [_]u8{0x12} ** 32;
    const ommers_hash: Hash.Hash = [_]u8{0x34} ** 32;
    const beneficiary = Address.Address{ .bytes = [_]u8{0x56} ** 20 };
    const state_root: Hash.Hash = [_]u8{0x78} ** 32;
    const txs_root: Hash.Hash = [_]u8{0x9a} ** 32;
    const receipts_root: Hash.Hash = [_]u8{0xbc} ** 32;
    const mix_hash: Hash.Hash = [_]u8{0xde} ** 32;

    const uncle1 = from(.{
        .parent_hash = parent_hash,
        .ommers_hash = ommers_hash,
        .beneficiary = beneficiary,
        .state_root = state_root,
        .transactions_root = txs_root,
        .receipts_root = receipts_root,
        .logs_bloom = EMPTY_BLOOM,
        .difficulty = 1000000,
        .number = 100,
        .gas_limit = 8000000,
        .gas_used = 4000000,
        .timestamp = 1600000000,
        .extra_data = &[_]u8{},
        .mix_hash = mix_hash,
        .nonce = EMPTY_NONCE,
    });

    const uncle2 = from(.{
        .parent_hash = parent_hash,
        .ommers_hash = ommers_hash,
        .beneficiary = beneficiary,
        .state_root = state_root,
        .transactions_root = txs_root,
        .receipts_root = receipts_root,
        .logs_bloom = EMPTY_BLOOM,
        .difficulty = 1000000,
        .number = 101, // Different number
        .gas_limit = 8000000,
        .gas_used = 4000000,
        .timestamp = 1600000000,
        .extra_data = &[_]u8{},
        .mix_hash = mix_hash,
        .nonce = EMPTY_NONCE,
    });

    const hash1 = try hash(&uncle1, allocator);
    const hash2 = try hash(&uncle2, allocator);

    try std.testing.expect(!Hash.equals(&hash1, &hash2));
}
```

### Uncle.equalsHash compares by hash

```zig
test "Uncle.equalsHash compares by hash" {
    const allocator = std.testing.allocator;
    const parent_hash: BlockHash.BlockHash = [_]u8{0xab} ** 32;
    const ommers_hash: Hash.Hash = [_]u8{0xcd} ** 32;
    const beneficiary = Address.Address{ .bytes = [_]u8{0xef} ** 20 };
    const state_root: Hash.Hash = [_]u8{0x12} ** 32;
    const txs_root: Hash.Hash = [_]u8{0x34} ** 32;
    const receipts_root: Hash.Hash = [_]u8{0x56} ** 32;
    const mix_hash: Hash.Hash = [_]u8{0x78} ** 32;

    const uncle1 = from(.{
        .parent_hash = parent_hash,
        .ommers_hash = ommers_hash,
        .beneficiary = beneficiary,
        .state_root = state_root,
        .transactions_root = txs_root,
        .receipts_root = receipts_root,
        .logs_bloom = EMPTY_BLOOM,
        .difficulty = 500000,
        .number = 50,
        .gas_limit = 5000000,
        .gas_used = 2500000,
        .timestamp = 1500000000,
        .extra_data = &[_]u8{},
        .mix_hash = mix_hash,
        .nonce = EMPTY_NONCE,
    });

    const uncle2 = from(.{
        .parent_hash = parent_hash,
        .ommers_hash = ommers_hash,
        .beneficiary = beneficiary,
        .state_root = state_root,
        .transactions_root = txs_root,
        .receipts_root = receipts_root,
        .logs_bloom = EMPTY_BLOOM,
        .difficulty = 500000,
        .number = 50,
        .gas_limit = 5000000,
        .gas_used = 2500000,
        .timestamp = 1500000000,
        .extra_data = &[_]u8{},
        .mix_hash = mix_hash,
        .nonce = EMPTY_NONCE,
    });

    try std.testing.expect(try equalsHash(&uncle1, &uncle2, allocator));
}
```

### Uncle.fromRlp round trip

```zig
test "Uncle.fromRlp round trip" {
    const allocator = std.testing.allocator;
    const parent_hash: BlockHash.BlockHash = [_]u8{0x12} ** 32;
    const ommers_hash: Hash.Hash = [_]u8{0x34} ** 32;
    const beneficiary = Address.Address{ .bytes = [_]u8{0x56} ** 20 };
    const state_root: Hash.Hash = [_]u8{0x78} ** 32;
    const txs_root: Hash.Hash = [_]u8{0x9a} ** 32;
    const receipts_root: Hash.Hash = [_]u8{0xbc} ** 32;
    const mix_hash: Hash.Hash = [_]u8{0xde} ** 32;

    const original = from(.{
        .parent_hash = parent_hash,
        .ommers_hash = ommers_hash,
        .beneficiary = beneficiary,
        .state_root = state_root,
        .transactions_root = txs_root,
        .receipts_root = receipts_root,
        .logs_bloom = EMPTY_BLOOM,
        .difficulty = 1000000,
        .number = 100,
        .gas_limit = 8000000,
        .gas_used = 4000000,
        .timestamp = 1600000000,
        .extra_data = &[_]u8{},
        .mix_hash = mix_hash,
        .nonce = EMPTY_NONCE,
    });

    // Encode
    const encoded = try rlpEncode(&original, allocator);
    defer allocator.free(encoded);

    // Decode
    const decoded = try fromRlp(allocator, encoded);

    // Verify fields match
    try std.testing.expectEqualSlices(u8, &original.parent_hash, &decoded.parent_hash);
    try std.testing.expectEqualSlices(u8, &original.ommers_hash, &decoded.ommers_hash);
    try std.testing.expectEqualSlices(u8, &original.beneficiary.bytes, &decoded.beneficiary.bytes);
    try std.testing.expectEqualSlices(u8, &original.state_root, &decoded.state_root);
    try std.testing.expectEqual(original.difficulty, decoded.difficulty);
    try std.testing.expectEqual(original.number, decoded.number);
    try std.testing.expectEqual(original.gas_limit, decoded.gas_limit);
    try std.testing.expectEqual(original.gas_used, decoded.gas_used);
    try std.testing.expectEqual(original.timestamp, decoded.timestamp);
}
```

### Uncle.toRlp alias works

```zig
test "Uncle.toRlp alias works" {
    const allocator = std.testing.allocator;
    const parent_hash: BlockHash.BlockHash = [_]u8{0xaa} ** 32;
    const ommers_hash: Hash.Hash = [_]u8{0xbb} ** 32;
    const beneficiary = Address.Address{ .bytes = [_]u8{0xcc} ** 20 };
    const state_root: Hash.Hash = [_]u8{0xdd} ** 32;
    const txs_root: Hash.Hash = [_]u8{0xee} ** 32;
    const receipts_root: Hash.Hash = [_]u8{0xff} ** 32;
    const mix_hash: Hash.Hash = [_]u8{0x11} ** 32;

    const uncle = from(.{
        .parent_hash = parent_hash,
        .ommers_hash = ommers_hash,
        .beneficiary = beneficiary,
        .state_root = state_root,
        .transactions_root = txs_root,
        .receipts_root = receipts_root,
        .logs_bloom = EMPTY_BLOOM,
        .difficulty = 13000000000000000,
        .number = 15000000,
        .gas_limit = 30000000,
        .gas_used = 15000000,
        .timestamp = 1680000000,
        .extra_data = &[_]u8{},
        .mix_hash = mix_hash,
        .nonce = EMPTY_NONCE,
    });

    // Both should produce same output
    const encoded1 = try rlpEncode(&uncle, allocator);
    defer allocator.free(encoded1);

    const encoded2 = try toRlp(&uncle, allocator);
    defer allocator.free(encoded2);

    try std.testing.expectEqualSlices(u8, encoded1, encoded2);
}
```

### Uncle.getReward - depth 1

```zig
test "Uncle.getReward - depth 1" {
    const parent_hash: BlockHash.BlockHash = [_]u8{0x12} ** 32;
    const ommers_hash: Hash.Hash = [_]u8{0x34} ** 32;
    const beneficiary = Address.Address{ .bytes = [_]u8{0x56} ** 20 };
    const state_root: Hash.Hash = [_]u8{0x78} ** 32;
    const txs_root: Hash.Hash = [_]u8{0x9a} ** 32;
    const receipts_root: Hash.Hash = [_]u8{0xbc} ** 32;
    const mix_hash: Hash.Hash = [_]u8{0xde} ** 32;

    const uncle = from(.{
        .parent_hash = parent_hash,
        .ommers_hash = ommers_hash,
        .beneficiary = beneficiary,
        .state_root = state_root,
        .transactions_root = txs_root,
        .receipts_root = receipts_root,
        .logs_bloom = EMPTY_BLOOM,
        .difficulty = 1000000,
        .number = 10000000, // Post-Constantinople
        .gas_limit = 8000000,
        .gas_used = 4000000,
        .timestamp = 1600000000,
        .extra_data = &[_]u8{},
        .mix_hash = mix_hash,
        .nonce = EMPTY_NONCE,
    });

    // Uncle at block 10000000, included in block 10000001 (depth 1)
    // Reward = (8-1) * 2 ETH / 8 = 7/8 * 2 ETH = 1.75 ETH
    const reward = getReward(&uncle, 10000001);
    const expected: u256 = 1_750_000_000_000_000_000; // 1.75 ETH
    try std.testing.expectEqual(expected, reward);
}
```

### Uncle.getReward - depth 6 (max)

```zig
test "Uncle.getReward - depth 6 (max)" {
    const parent_hash: BlockHash.BlockHash = [_]u8{0x12} ** 32;
    const ommers_hash: Hash.Hash = [_]u8{0x34} ** 32;
    const beneficiary = Address.Address{ .bytes = [_]u8{0x56} ** 20 };
    const state_root: Hash.Hash = [_]u8{0x78} ** 32;
    const txs_root: Hash.Hash = [_]u8{0x9a} ** 32;
    const receipts_root: Hash.Hash = [_]u8{0xbc} ** 32;
    const mix_hash: Hash.Hash = [_]u8{0xde} ** 32;

    const uncle = from(.{
        .parent_hash = parent_hash,
        .ommers_hash = ommers_hash,
        .beneficiary = beneficiary,
        .state_root = state_root,
        .transactions_root = txs_root,
        .receipts_root = receipts_root,
        .logs_bloom = EMPTY_BLOOM,
        .difficulty = 1000000,
        .number = 10000000,
        .gas_limit = 8000000,
        .gas_used = 4000000,
        .timestamp = 1600000000,
        .extra_data = &[_]u8{},
        .mix_hash = mix_hash,
        .nonce = EMPTY_NONCE,
    });

    // Uncle at block 10000000, included in block 10000006 (depth 6)
    // Reward = (8-6) * 2 ETH / 8 = 2/8 * 2 ETH = 0.5 ETH
    const reward = getReward(&uncle, 10000006);
    const expected: u256 = 500_000_000_000_000_000; // 0.5 ETH
    try std.testing.expectEqual(expected, reward);
}
```

### Uncle.getReward - too old (depth > 6)

```zig
test "Uncle.getReward - too old (depth > 6)" {
    const parent_hash: BlockHash.BlockHash = [_]u8{0x12} ** 32;
    const ommers_hash: Hash.Hash = [_]u8{0x34} ** 32;
    const beneficiary = Address.Address{ .bytes = [_]u8{0x56} ** 20 };
    const state_root: Hash.Hash = [_]u8{0x78} ** 32;
    const txs_root: Hash.Hash = [_]u8{0x9a} ** 32;
    const receipts_root: Hash.Hash = [_]u8{0xbc} ** 32;
    const mix_hash: Hash.Hash = [_]u8{0xde} ** 32;

    const uncle = from(.{
        .parent_hash = parent_hash,
        .ommers_hash = ommers_hash,
        .beneficiary = beneficiary,
        .state_root = state_root,
        .transactions_root = txs_root,
        .receipts_root = receipts_root,
        .logs_bloom = EMPTY_BLOOM,
        .difficulty = 1000000,
        .number = 10000000,
        .gas_limit = 8000000,
        .gas_used = 4000000,
        .timestamp = 1600000000,
        .extra_data = &[_]u8{},
        .mix_hash = mix_hash,
        .nonce = EMPTY_NONCE,
    });

    // Uncle at block 10000000, included in block 10000007 (depth 7 - too old)
    const reward = getReward(&uncle, 10000007);
    try std.testing.expectEqual(@as(u256, 0), reward);
}
```

### Uncle.getReward - invalid (uncle >= block)

```zig
test "Uncle.getReward - invalid (uncle >= block)" {
    const parent_hash: BlockHash.BlockHash = [_]u8{0x12} ** 32;
    const ommers_hash: Hash.Hash = [_]u8{0x34} ** 32;
    const beneficiary = Address.Address{ .bytes = [_]u8{0x56} ** 20 };
    const state_root: Hash.Hash = [_]u8{0x78} ** 32;
    const txs_root: Hash.Hash = [_]u8{0x9a} ** 32;
    const receipts_root: Hash.Hash = [_]u8{0xbc} ** 32;
    const mix_hash: Hash.Hash = [_]u8{0xde} ** 32;

    const uncle = from(.{
        .parent_hash = parent_hash,
        .ommers_hash = ommers_hash,
        .beneficiary = beneficiary,
        .state_root = state_root,
        .transactions_root = txs_root,
        .receipts_root = receipts_root,
        .logs_bloom = EMPTY_BLOOM,
        .difficulty = 1000000,
        .number = 10000000,
        .gas_limit = 8000000,
        .gas_used = 4000000,
        .timestamp = 1600000000,
        .extra_data = &[_]u8{},
        .mix_hash = mix_hash,
        .nonce = EMPTY_NONCE,
    });

    // Uncle at block 10000000 cannot be included in same or earlier block
    try std.testing.expectEqual(@as(u256, 0), getReward(&uncle, 10000000));
    try std.testing.expectEqual(@as(u256, 0), getReward(&uncle, 9999999));
}
```

### Uncle.getReward - different forks

```zig
test "Uncle.getReward - different forks" {
    const parent_hash: BlockHash.BlockHash = [_]u8{0x12} ** 32;
    const ommers_hash: Hash.Hash = [_]u8{0x34} ** 32;
    const beneficiary = Address.Address{ .bytes = [_]u8{0x56} ** 20 };
    const state_root: Hash.Hash = [_]u8{0x78} ** 32;
    const txs_root: Hash.Hash = [_]u8{0x9a} ** 32;
    const receipts_root: Hash.Hash = [_]u8{0xbc} ** 32;
    const mix_hash: Hash.Hash = [_]u8{0xde} ** 32;

    // Frontier era uncle (block 100)
    const frontier_uncle = from(.{
        .parent_hash = parent_hash,
        .ommers_hash = ommers_hash,
        .beneficiary = beneficiary,
        .state_root = state_root,
        .transactions_root = txs_root,
        .receipts_root = receipts_root,
        .logs_bloom = EMPTY_BLOOM,
        .difficulty = 1000000,
        .number = 100,
        .gas_limit = 8000000,
        .gas_used = 4000000,
        .timestamp = 1600000000,
        .extra_data = &[_]u8{},
        .mix_hash = mix_hash,
        .nonce = EMPTY_NONCE,
    });

    // Depth 1 reward in Frontier era (5 ETH base)
    // Reward = 7/8 * 5 ETH = 4.375 ETH
    const frontier_reward = getReward(&frontier_uncle, 101);
    const expected_frontier: u256 = 4_375_000_000_000_000_000;
    try std.testing.expectEqual(expected_frontier, frontier_reward);

    // Byzantium era uncle
    const byzantium_uncle = from(.{
        .parent_hash = parent_hash,
        .ommers_hash = ommers_hash,
        .beneficiary = beneficiary,
        .state_root = state_root,
        .transactions_root = txs_root,
        .receipts_root = receipts_root,
        .logs_bloom = EMPTY_BLOOM,
        .difficulty = 1000000,
        .number = BYZANTIUM_BLOCK,
        .gas_limit = 8000000,
        .gas_used = 4000000,
        .timestamp = 1600000000,
        .extra_data = &[_]u8{},
        .mix_hash = mix_hash,
        .nonce = EMPTY_NONCE,
    });

    // Depth 1 reward in Byzantium era (3 ETH base)
    // Reward = 7/8 * 3 ETH = 2.625 ETH
    const byzantium_reward = getReward(&byzantium_uncle, BYZANTIUM_BLOCK + 1);
    const expected_byzantium: u256 = 2_625_000_000_000_000_000;
    try std.testing.expectEqual(expected_byzantium, byzantium_reward);
}
```

### Uncle.getNephewReward

```zig
test "Uncle.getNephewReward" {
    // Nephew reward is 1/32 of base reward

    // Constantinople era
    const nephew_post_const = getNephewReward(CONSTANTINOPLE_BLOCK + 1);
    const expected_const: u256 = BASE_REWARD_CONSTANTINOPLE / 32;
    try std.testing.expectEqual(expected_const, nephew_post_const);

    // Byzantium era
    const nephew_byz = getNephewReward(BYZANTIUM_BLOCK + 1);
    const expected_byz: u256 = BASE_REWARD_BYZANTIUM / 32;
    try std.testing.expectEqual(expected_byz, nephew_byz);

    // Frontier era
    const nephew_frontier = getNephewReward(100);
    const expected_frontier: u256 = BASE_REWARD_FRONTIER / 32;
    try std.testing.expectEqual(expected_frontier, nephew_frontier);
}
```
