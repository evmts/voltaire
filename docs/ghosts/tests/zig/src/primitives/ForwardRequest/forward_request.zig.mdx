---
title: '[Zig] src/primitives/ForwardRequest/forward_request.zig'
source: 'src/primitives/ForwardRequest/forward_request.zig'
---

> Auto-generated from Zig tests in: src/primitives/ForwardRequest/forward_request.zig

### ForwardRequest: from creates request

```zig
test "ForwardRequest: from creates request" {
    const from_addr = Address.Address{ .bytes = [_]u8{0xaa} ** 20 };
    const to_addr = Address.Address{ .bytes = [_]u8{0xbb} ** 20 };
    const data = "test data";

    const req = from(.{
        .from = from_addr,
        .to = to_addr,
        .value = 1000,
        .gas = 100000,
        .nonce = 1,
        .data = data,
        .valid_until_time = 1700000000,
    });

    try std.testing.expect(req.from.equals(from_addr));
    try std.testing.expect(req.to.equals(to_addr));
    try std.testing.expectEqual(@as(u256, 1000), req.value);
    try std.testing.expectEqual(@as(u256, 100000), req.gas);
    try std.testing.expectEqual(@as(u256, 1), req.nonce);
    try std.testing.expectEqualStrings(data, req.data);
    try std.testing.expectEqual(@as(u256, 1700000000), req.valid_until_time);
}
```

### ForwardRequest: fromFields creates request

```zig
test "ForwardRequest: fromFields creates request" {
    const from_addr = Address.Address{ .bytes = [_]u8{0x11} ** 20 };
    const to_addr = Address.Address{ .bytes = [_]u8{0x22} ** 20 };

    const req = fromFields(
        from_addr,
        to_addr,
        0,
        50000,
        5,
        "calldata",
        1800000000,
    );

    try std.testing.expect(req.from.equals(from_addr));
    try std.testing.expectEqual(@as(u256, 0), req.value);
    try std.testing.expectEqual(@as(u256, 5), req.nonce);
}
```

### ForwardRequest: structHash produces consistent result

```zig
test "ForwardRequest: structHash produces consistent result" {
    const from_addr = Address.Address{ .bytes = [_]u8{0xaa} ** 20 };
    const to_addr = Address.Address{ .bytes = [_]u8{0xbb} ** 20 };

    const req = from(.{
        .from = from_addr,
        .to = to_addr,
        .value = 0,
        .gas = 100000,
        .nonce = 1,
        .data = "test",
        .valid_until_time = 1700000000,
    });

    const hash1 = req.structHash();
    const hash2 = req.structHash();

    try std.testing.expectEqualSlices(u8, &hash1, &hash2);
}
```

### ForwardRequest: different requests produce different hashes

```zig
test "ForwardRequest: different requests produce different hashes" {
    const from_addr = Address.Address{ .bytes = [_]u8{0xaa} ** 20 };
    const to_addr = Address.Address{ .bytes = [_]u8{0xbb} ** 20 };

    const req1 = from(.{
        .from = from_addr,
        .to = to_addr,
        .value = 0,
        .gas = 100000,
        .nonce = 1,
        .data = "test1",
        .valid_until_time = 1700000000,
    });

    const req2 = from(.{
        .from = from_addr,
        .to = to_addr,
        .value = 0,
        .gas = 100000,
        .nonce = 2, // Different nonce
        .data = "test1",
        .valid_until_time = 1700000000,
    });

    const hash1 = req1.structHash();
    const hash2 = req2.structHash();

    try std.testing.expect(!std.mem.eql(u8, &hash1, &hash2));
}
```

### ForwardRequest: hash with domain produces EIP-712 hash

```zig
test "ForwardRequest: hash with domain produces EIP-712 hash" {
    const allocator = std.testing.allocator;

    const from_addr = Address.Address{ .bytes = [_]u8{0xaa} ** 20 };
    const to_addr = Address.Address{ .bytes = [_]u8{0xbb} ** 20 };

    const req = from(.{
        .from = from_addr,
        .to = to_addr,
        .value = 0,
        .gas = 100000,
        .nonce = 1,
        .data = "test",
        .valid_until_time = 1700000000,
    });

    const domain = Domain{
        .name = "GSN Relayed Transaction",
        .version = "2",
        .chain_id = 1,
        .verifying_contract = to_addr,
    };

    const hash1 = try req.hash(allocator, domain);
    const hash2 = try req.hash(allocator, domain);

    // Same request with same domain produces same hash
    try std.testing.expectEqualSlices(u8, &hash1, &hash2);
}
```

### ForwardRequest: different domains produce different hashes

```zig
test "ForwardRequest: different domains produce different hashes" {
    const allocator = std.testing.allocator;

    const from_addr = Address.Address{ .bytes = [_]u8{0xaa} ** 20 };
    const to_addr = Address.Address{ .bytes = [_]u8{0xbb} ** 20 };

    const req = from(.{
        .from = from_addr,
        .to = to_addr,
        .value = 0,
        .gas = 100000,
        .nonce = 1,
        .data = "test",
        .valid_until_time = 1700000000,
    });

    const domain1 = Domain{
        .name = "GSN v1",
        .version = "1",
        .chain_id = 1,
    };

    const domain2 = Domain{
        .name = "GSN v2",
        .version = "2",
        .chain_id = 1,
    };

    const hash1 = try req.hash(allocator, domain1);
    const hash2 = try req.hash(allocator, domain2);

    try std.testing.expect(!std.mem.eql(u8, &hash1, &hash2));
}
```

### ForwardRequest: equals identical requests

```zig
test "ForwardRequest: equals identical requests" {
    const from_addr = Address.Address{ .bytes = [_]u8{0xaa} ** 20 };
    const to_addr = Address.Address{ .bytes = [_]u8{0xbb} ** 20 };
    const data = "same data";

    const req1 = from(.{
        .from = from_addr,
        .to = to_addr,
        .value = 1000,
        .gas = 100000,
        .nonce = 1,
        .data = data,
        .valid_until_time = 1700000000,
    });

    const req2 = from(.{
        .from = from_addr,
        .to = to_addr,
        .value = 1000,
        .gas = 100000,
        .nonce = 1,
        .data = data,
        .valid_until_time = 1700000000,
    });

    try std.testing.expect(req1.equals(req2));
}
```

### ForwardRequest: equals different from addresses

```zig
test "ForwardRequest: equals different from addresses" {
    const from1 = Address.Address{ .bytes = [_]u8{0xaa} ** 20 };
    const from2 = Address.Address{ .bytes = [_]u8{0xcc} ** 20 };
    const to_addr = Address.Address{ .bytes = [_]u8{0xbb} ** 20 };

    const req1 = from(.{
        .from = from1,
        .to = to_addr,
        .value = 0,
        .gas = 100000,
        .nonce = 1,
        .data = "test",
        .valid_until_time = 1700000000,
    });

    const req2 = from(.{
        .from = from2,
        .to = to_addr,
        .value = 0,
        .gas = 100000,
        .nonce = 1,
        .data = "test",
        .valid_until_time = 1700000000,
    });

    try std.testing.expect(!req1.equals(req2));
}
```

### ForwardRequest: equals different values

```zig
test "ForwardRequest: equals different values" {
    const from_addr = Address.Address{ .bytes = [_]u8{0xaa} ** 20 };
    const to_addr = Address.Address{ .bytes = [_]u8{0xbb} ** 20 };

    const req1 = from(.{
        .from = from_addr,
        .to = to_addr,
        .value = 1000,
        .gas = 100000,
        .nonce = 1,
        .data = "test",
        .valid_until_time = 1700000000,
    });

    const req2 = from(.{
        .from = from_addr,
        .to = to_addr,
        .value = 2000, // Different value
        .gas = 100000,
        .nonce = 1,
        .data = "test",
        .valid_until_time = 1700000000,
    });

    try std.testing.expect(!req1.equals(req2));
}
```

### ForwardRequest: equals different data

```zig
test "ForwardRequest: equals different data" {
    const from_addr = Address.Address{ .bytes = [_]u8{0xaa} ** 20 };
    const to_addr = Address.Address{ .bytes = [_]u8{0xbb} ** 20 };

    const req1 = from(.{
        .from = from_addr,
        .to = to_addr,
        .value = 0,
        .gas = 100000,
        .nonce = 1,
        .data = "data1",
        .valid_until_time = 1700000000,
    });

    const req2 = from(.{
        .from = from_addr,
        .to = to_addr,
        .value = 0,
        .gas = 100000,
        .nonce = 1,
        .data = "data2", // Different data
        .valid_until_time = 1700000000,
    });

    try std.testing.expect(!req1.equals(req2));
}
```

### ForwardRequest: isExpired returns true when expired

```zig
test "ForwardRequest: isExpired returns true when expired" {
    const from_addr = Address.Address{ .bytes = [_]u8{0xaa} ** 20 };
    const to_addr = Address.Address{ .bytes = [_]u8{0xbb} ** 20 };

    const req = from(.{
        .from = from_addr,
        .to = to_addr,
        .value = 0,
        .gas = 100000,
        .nonce = 1,
        .data = "test",
        .valid_until_time = 1700000000,
    });

    // Time after validUntilTime
    try std.testing.expect(req.isExpired(1700000001));
    try std.testing.expect(!req.isValid(1700000001));
}
```

### ForwardRequest: isExpired returns false when not expired

```zig
test "ForwardRequest: isExpired returns false when not expired" {
    const from_addr = Address.Address{ .bytes = [_]u8{0xaa} ** 20 };
    const to_addr = Address.Address{ .bytes = [_]u8{0xbb} ** 20 };

    const req = from(.{
        .from = from_addr,
        .to = to_addr,
        .value = 0,
        .gas = 100000,
        .nonce = 1,
        .data = "test",
        .valid_until_time = 1700000000,
    });

    // Time before validUntilTime
    try std.testing.expect(!req.isExpired(1699999999));
    try std.testing.expect(req.isValid(1699999999));
}
```

### ForwardRequest: isExpired edge case at exact time

```zig
test "ForwardRequest: isExpired edge case at exact time" {
    const from_addr = Address.Address{ .bytes = [_]u8{0xaa} ** 20 };
    const to_addr = Address.Address{ .bytes = [_]u8{0xbb} ** 20 };

    const req = from(.{
        .from = from_addr,
        .to = to_addr,
        .value = 0,
        .gas = 100000,
        .nonce = 1,
        .data = "test",
        .valid_until_time = 1700000000,
    });

    // Exactly at validUntilTime - not expired yet
    try std.testing.expect(!req.isExpired(1700000000));
    try std.testing.expect(req.isValid(1700000000));
}
```

### ForwardRequest: getTypeString returns correct string

```zig
test "ForwardRequest: getTypeString returns correct string" {
    const expected = "ForwardRequest(address from,address to,uint256 value,uint256 gas,uint256 nonce,bytes data,uint256 validUntilTime)";
    try std.testing.expectEqualStrings(expected, ForwardRequest.getTypeString());
}
```

### ForwardRequest: FORWARD_REQUEST_TYPEHASH is correct

```zig
test "ForwardRequest: FORWARD_REQUEST_TYPEHASH is correct" {
    const type_string = ForwardRequest.getTypeString();
    var expected: [32]u8 = undefined;
    crypto.Keccak256.hash(type_string, &expected);
    try std.testing.expectEqualSlices(u8, &expected, &FORWARD_REQUEST_TYPEHASH);
}
```

### ForwardRequest: structHash with empty data

```zig
test "ForwardRequest: structHash with empty data" {
    const from_addr = Address.Address{ .bytes = [_]u8{0xaa} ** 20 };
    const to_addr = Address.Address{ .bytes = [_]u8{0xbb} ** 20 };

    const req = from(.{
        .from = from_addr,
        .to = to_addr,
        .value = 0,
        .gas = 100000,
        .nonce = 1,
        .data = "",
        .valid_until_time = 1700000000,
    });

    // Should not panic with empty data
    const hash_result = req.structHash();
    try std.testing.expectEqual(@as(usize, 32), hash_result.len);
}
```

### ForwardRequest: structHash with large value

```zig
test "ForwardRequest: structHash with large value" {
    const from_addr = Address.Address{ .bytes = [_]u8{0xaa} ** 20 };
    const to_addr = Address.Address{ .bytes = [_]u8{0xbb} ** 20 };

    const large_value: u256 = std.math.maxInt(u256);

    const req = from(.{
        .from = from_addr,
        .to = to_addr,
        .value = large_value,
        .gas = large_value,
        .nonce = large_value,
        .data = "test",
        .valid_until_time = large_value,
    });

    // Should handle max u256 values
    const hash_result = req.structHash();
    try std.testing.expectEqual(@as(usize, 32), hash_result.len);
}
```

### ForwardRequest: zero value request

```zig
test "ForwardRequest: zero value request" {
    const from_addr = Address.Address{ .bytes = [_]u8{0} ** 20 };
    const to_addr = Address.Address{ .bytes = [_]u8{0} ** 20 };

    const req = from(.{
        .from = from_addr,
        .to = to_addr,
        .value = 0,
        .gas = 0,
        .nonce = 0,
        .data = "",
        .valid_until_time = 0,
    });

    // Should handle all-zero request
    const hash_result = req.structHash();
    try std.testing.expectEqual(@as(usize, 32), hash_result.len);
}
```
