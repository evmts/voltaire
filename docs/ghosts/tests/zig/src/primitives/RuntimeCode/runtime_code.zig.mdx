---
title: '[Zig] src/primitives/RuntimeCode/runtime_code.zig'
source: 'src/primitives/RuntimeCode/runtime_code.zig'
---

> Auto-generated from Zig tests in: src/primitives/RuntimeCode/runtime_code.zig

### RuntimeCode.from - creates from bytes

```zig
test "RuntimeCode.from - creates from bytes" {
    const bytecode = [_]u8{ 0x60, 0x80, 0x60, 0x40, 0x52 };
    const code = RuntimeCode.from(&bytecode);

    try std.testing.expectEqual(@as(usize, 5), code.len());
    try std.testing.expect(!code.isEmpty());
}
```

### RuntimeCode.from - empty bytecode

```zig
test "RuntimeCode.from - empty bytecode" {
    const bytecode = [_]u8{};
    const code = RuntimeCode.from(&bytecode);

    try std.testing.expectEqual(@as(usize, 0), code.len());
    try std.testing.expect(code.isEmpty());
}
```

### RuntimeCode.fromHex - valid hex

```zig
test "RuntimeCode.fromHex - valid hex" {
    const result = try RuntimeCode.fromHex(std.testing.allocator, "0x6080604052");
    defer std.testing.allocator.free(result.bytes);

    try std.testing.expectEqual(@as(usize, 5), result.code.len());
    try std.testing.expectEqual(@as(u8, 0x60), result.code.bytes[0]);
}
```

### RuntimeCode.toHex - converts to hex string

```zig
test "RuntimeCode.toHex - converts to hex string" {
    const bytecode = [_]u8{ 0x60, 0x80 };
    const code = RuntimeCode.from(&bytecode);

    const hex = try code.toHex(std.testing.allocator);
    defer std.testing.allocator.free(hex);

    try std.testing.expectEqualStrings("0x6080", hex);
}
```

### RuntimeCode.hash - computes keccak256

```zig
test "RuntimeCode.hash - computes keccak256" {
    const bytecode = [_]u8{ 0x60, 0x80, 0x60, 0x40 };
    const code = RuntimeCode.from(&bytecode);

    const code_hash = code.hash();

    try std.testing.expectEqual(@as(usize, 32), code_hash.len);

    // Verify non-zero
    var all_zero = true;
    for (code_hash) |b| {
        if (b != 0) {
            all_zero = false;
            break;
        }
    }
    try std.testing.expect(!all_zero);
}
```

### RuntimeCode.equals - same bytecode

```zig
test "RuntimeCode.equals - same bytecode" {
    const bytecode1 = [_]u8{ 0x60, 0x80 };
    const bytecode2 = [_]u8{ 0x60, 0x80 };

    const code1 = RuntimeCode.from(&bytecode1);
    const code2 = RuntimeCode.from(&bytecode2);

    try std.testing.expect(code1.equals(code2));
}
```

### RuntimeCode.equals - different bytecode

```zig
test "RuntimeCode.equals - different bytecode" {
    const bytecode1 = [_]u8{ 0x60, 0x80 };
    const bytecode2 = [_]u8{ 0x60, 0x40 };

    const code1 = RuntimeCode.from(&bytecode1);
    const code2 = RuntimeCode.from(&bytecode2);

    try std.testing.expect(!code1.equals(code2));
}
```

### RuntimeCode.getOpcode - valid position

```zig
test "RuntimeCode.getOpcode - valid position" {
    const bytecode = [_]u8{ 0x60, 0x80, 0x60, 0x40 };
    const code = RuntimeCode.from(&bytecode);

    try std.testing.expectEqual(@as(u8, 0x60), code.getOpcode(0).?);
    try std.testing.expectEqual(@as(u8, 0x80), code.getOpcode(1).?);
    try std.testing.expectEqual(@as(u8, 0x40), code.getOpcode(3).?);
}
```

### RuntimeCode.getOpcode - out of bounds

```zig
test "RuntimeCode.getOpcode - out of bounds" {
    const bytecode = [_]u8{ 0x60, 0x80 };
    const code = RuntimeCode.from(&bytecode);

    try std.testing.expect(code.getOpcode(2) == null);
    try std.testing.expect(code.getOpcode(100) == null);
}
```

### RuntimeCode.inBounds - checks bounds correctly

```zig
test "RuntimeCode.inBounds - checks bounds correctly" {
    const bytecode = [_]u8{ 0x60, 0x80, 0x60 };
    const code = RuntimeCode.from(&bytecode);

    try std.testing.expect(code.inBounds(0));
    try std.testing.expect(code.inBounds(2));
    try std.testing.expect(!code.inBounds(3));
    try std.testing.expect(!code.inBounds(100));
}
```
