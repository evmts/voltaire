---
title: '[Zig] src/primitives/ValidatorIndex/ValidatorIndex.zig'
source: 'src/primitives/ValidatorIndex/ValidatorIndex.zig'
---

> Auto-generated from Zig tests in: src/primitives/ValidatorIndex/ValidatorIndex.zig

### ValidatorIndex.from creates index

```zig
test "ValidatorIndex.from creates index" {
    const idx = from(123456);
    try std.testing.expectEqual(123456, idx);
}
```

### ValidatorIndex.from handles zero

```zig
test "ValidatorIndex.from handles zero" {
    const idx = from(0);
    try std.testing.expectEqual(0, idx);
}
```

### ValidatorIndex.from handles max u32

```zig
test "ValidatorIndex.from handles max u32" {
    const idx = from(std.math.maxInt(u32));
    try std.testing.expectEqual(std.math.maxInt(u32), idx);
}
```

### ValidatorIndex.fromU64 converts valid u64

```zig
test "ValidatorIndex.fromU64 converts valid u64" {
    const idx = fromU64(123456);
    try std.testing.expectEqual(123456, idx.?);
}
```

### ValidatorIndex.fromU64 returns null for too large

```zig
test "ValidatorIndex.fromU64 returns null for too large" {
    const idx = fromU64(@as(u64, std.math.maxInt(u32)) + 1);
    try std.testing.expect(idx == null);
}
```

### ValidatorIndex.toNumber converts to u32

```zig
test "ValidatorIndex.toNumber converts to u32" {
    const idx = from(42);
    try std.testing.expectEqual(42, toNumber(idx));
}
```

### ValidatorIndex.toNumber is identity

```zig
test "ValidatorIndex.toNumber is identity" {
    const idx = from(123);
    try std.testing.expectEqual(idx, toNumber(idx));
}
```

### ValidatorIndex.toU64 converts to u64

```zig
test "ValidatorIndex.toU64 converts to u64" {
    const idx = from(123456);
    try std.testing.expectEqual(@as(u64, 123456), toU64(idx));
}
```

### ValidatorIndex.equals returns true for equal indexes

```zig
test "ValidatorIndex.equals returns true for equal indexes" {
    const a = from(123456);
    const b = from(123456);
    try std.testing.expect(equals(a, b));
}
```

### ValidatorIndex.equals returns false for unequal indexes

```zig
test "ValidatorIndex.equals returns false for unequal indexes" {
    const a = from(123456);
    const b = from(123457);
    try std.testing.expect(!equals(a, b));
}
```

### ValidatorIndex.equals handles zero

```zig
test "ValidatorIndex.equals handles zero" {
    const a = from(0);
    const b = from(0);
    try std.testing.expect(equals(a, b));
}
```

### ValidatorIndex.compare returns .lt for lesser

```zig
test "ValidatorIndex.compare returns .lt for lesser" {
    const a = from(100);
    const b = from(200);
    try std.testing.expectEqual(std.math.Order.lt, compare(a, b));
}
```

### ValidatorIndex.compare returns .eq for equal

```zig
test "ValidatorIndex.compare returns .eq for equal" {
    const a = from(123456);
    const b = from(123456);
    try std.testing.expectEqual(std.math.Order.eq, compare(a, b));
}
```

### ValidatorIndex.compare returns .gt for greater

```zig
test "ValidatorIndex.compare returns .gt for greater" {
    const a = from(200);
    const b = from(100);
    try std.testing.expectEqual(std.math.Order.gt, compare(a, b));
}
```

### ValidatorIndex.increment increments by one

```zig
test "ValidatorIndex.increment increments by one" {
    const idx = from(123456);
    const next = increment(idx);
    try std.testing.expectEqual(123457, next.?);
}
```

### ValidatorIndex.increment handles zero

```zig
test "ValidatorIndex.increment handles zero" {
    const idx = from(0);
    const next = increment(idx);
    try std.testing.expectEqual(1, next.?);
}
```

### ValidatorIndex.increment returns null on overflow

```zig
test "ValidatorIndex.increment returns null on overflow" {
    const idx = from(std.math.maxInt(u32));
    const next = increment(idx);
    try std.testing.expect(next == null);
}
```

### ValidatorIndex constants

```zig
test "ValidatorIndex constants" {
    try std.testing.expectEqual(@as(u32, 0), MIN);
    try std.testing.expectEqual(@as(u32, 0), ZERO);
    try std.testing.expectEqual(std.math.maxInt(u32), MAX);
}
```

### ValidatorIndex.toHex converts zero

```zig
test "ValidatorIndex.toHex converts zero" {
    const idx = from(0);
    const hex = toHex(idx);
    try std.testing.expectEqualStrings("0x0", std.mem.sliceTo(&hex, 0));
}
```

### ValidatorIndex.toHex converts single digit

```zig
test "ValidatorIndex.toHex converts single digit" {
    const idx = from(10);
    const hex = toHex(idx);
    try std.testing.expectEqualStrings("0xa", std.mem.sliceTo(&hex, 0));
}
```

### ValidatorIndex.toHex converts 255

```zig
test "ValidatorIndex.toHex converts 255" {
    const idx = from(255);
    const hex = toHex(idx);
    try std.testing.expectEqualStrings("0xff", std.mem.sliceTo(&hex, 0));
}
```

### ValidatorIndex.toHex converts typical validator index

```zig
test "ValidatorIndex.toHex converts typical validator index" {
    const idx = from(123456);
    const hex = toHex(idx);
    try std.testing.expectEqualStrings("0x1e240", std.mem.sliceTo(&hex, 0));
}
```

### ValidatorIndex.toHex converts max u32

```zig
test "ValidatorIndex.toHex converts max u32" {
    const idx = from(std.math.maxInt(u32));
    const hex = toHex(idx);
    try std.testing.expectEqualStrings("0xffffffff", std.mem.sliceTo(&hex, 0));
}
```

### ValidatorIndex.fromHex parses with 0x prefix

```zig
test "ValidatorIndex.fromHex parses with 0x prefix" {
    const idx = fromHex("0x1e240");
    try std.testing.expectEqual(123456, idx.?);
}
```

### ValidatorIndex.fromHex parses without prefix

```zig
test "ValidatorIndex.fromHex parses without prefix" {
    const idx = fromHex("1e240");
    try std.testing.expectEqual(123456, idx.?);
}
```

### ValidatorIndex.fromHex parses zero

```zig
test "ValidatorIndex.fromHex parses zero" {
    const idx = fromHex("0x0");
    try std.testing.expectEqual(0, idx.?);
}
```

### ValidatorIndex.fromHex parses uppercase

```zig
test "ValidatorIndex.fromHex parses uppercase" {
    const idx = fromHex("0x1E240");
    try std.testing.expectEqual(123456, idx.?);
}
```

### ValidatorIndex.fromHex parses max u32

```zig
test "ValidatorIndex.fromHex parses max u32" {
    const idx = fromHex("0xffffffff");
    try std.testing.expectEqual(std.math.maxInt(u32), idx.?);
}
```

### ValidatorIndex.fromHex returns null for overflow

```zig
test "ValidatorIndex.fromHex returns null for overflow" {
    const idx = fromHex("0x100000000");
    try std.testing.expect(idx == null);
}
```

### ValidatorIndex.fromHex returns null for invalid char

```zig
test "ValidatorIndex.fromHex returns null for invalid char" {
    const idx = fromHex("0x1g240");
    try std.testing.expect(idx == null);
}
```

### ValidatorIndex.fromHex returns null for empty

```zig
test "ValidatorIndex.fromHex returns null for empty" {
    const idx = fromHex("0x");
    try std.testing.expect(idx == null);
}
```

### ValidatorIndex.isZero returns true for zero

```zig
test "ValidatorIndex.isZero returns true for zero" {
    const idx = from(0);
    try std.testing.expect(isZero(idx));
}
```

### ValidatorIndex.isZero returns false for non-zero

```zig
test "ValidatorIndex.isZero returns false for non-zero" {
    const idx = from(123456);
    try std.testing.expect(!isZero(idx));
}
```

### ValidatorIndex.isZero with ZERO constant

```zig
test "ValidatorIndex.isZero with ZERO constant" {
    try std.testing.expect(isZero(ZERO));
}
```
