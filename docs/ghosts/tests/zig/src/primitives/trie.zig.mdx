---
title: '[Zig] src/primitives/trie.zig'
source: 'src/primitives/trie.zig'
---

> Auto-generated from Zig tests in: src/primitives/trie.zig

### TrieMask - initialization

```zig
test "TrieMask - initialization" {
    const testing = std.testing;

    const mask = TrieMask.init();
    try testing.expect(mask.is_empty());
    try testing.expectEqual(@as(u5, 0), mask.bit_count());
}
```

### TrieMask - set and is_set

```zig
test "TrieMask - set and is_set" {
    const testing = std.testing;

    var mask = TrieMask.init();

    mask.set(0);
    try testing.expect(mask.is_set(0));
    try testing.expect(!mask.is_set(1));
    try testing.expectEqual(@as(u5, 1), mask.bit_count());

    mask.set(15);
    try testing.expect(mask.is_set(0));
    try testing.expect(mask.is_set(15));
    try testing.expectEqual(@as(u5, 2), mask.bit_count());
}
```

### TrieMask - unset

```zig
test "TrieMask - unset" {
    const testing = std.testing;

    var mask = TrieMask.init();
    mask.set(5);
    mask.set(10);
    try testing.expectEqual(@as(u5, 2), mask.bit_count());

    mask.unset(5);
    try testing.expect(!mask.is_set(5));
    try testing.expect(mask.is_set(10));
    try testing.expectEqual(@as(u5, 1), mask.bit_count());

    mask.unset(10);
    try testing.expect(mask.is_empty());
}
```

### TrieMask - all positions

```zig
test "TrieMask - all positions" {
    const testing = std.testing;

    var mask = TrieMask.init();

    // Set all 16 positions
    for (0..16) |i| {
        mask.set(@intCast(i));
    }

    try testing.expectEqual(@as(u5, 16), mask.bit_count());

    // Verify all are set
    for (0..16) |i| {
        try testing.expect(mask.is_set(@intCast(i)));
    }

    // Unset all
    for (0..16) |i| {
        mask.unset(@intCast(i));
    }

    try testing.expect(mask.is_empty());
}
```

### keyToNibbles - basic conversion

```zig
test "keyToNibbles - basic conversion" {
    const testing = std.testing;
    const allocator = testing.allocator;

    const key = [_]u8{ 0x12, 0xAB };
    const nibbles = try keyToNibbles(allocator, &key);
    defer allocator.free(nibbles);

    try testing.expectEqual(@as(usize, 4), nibbles.len);
    try testing.expectEqual(@as(u8, 0x1), nibbles[0]);
    try testing.expectEqual(@as(u8, 0x2), nibbles[1]);
    try testing.expectEqual(@as(u8, 0xA), nibbles[2]);
    try testing.expectEqual(@as(u8, 0xB), nibbles[3]);
}
```

### keyToNibbles - empty key

```zig
test "keyToNibbles - empty key" {
    const testing = std.testing;
    const allocator = testing.allocator;

    const key = [_]u8{};
    const nibbles = try keyToNibbles(allocator, &key);
    defer allocator.free(nibbles);

    try testing.expectEqual(@as(usize, 0), nibbles.len);
}
```

### nibblesToKey - basic conversion

```zig
test "nibblesToKey - basic conversion" {
    const testing = std.testing;
    const allocator = testing.allocator;

    const nibbles = [_]u8{ 0x1, 0x2, 0xA, 0xB };
    const key = try nibblesToKey(allocator, &nibbles);
    defer allocator.free(key);

    try testing.expectEqual(@as(usize, 2), key.len);
    try testing.expectEqual(@as(u8, 0x12), key[0]);
    try testing.expectEqual(@as(u8, 0xAB), key[1]);
}
```

### nibblesToKey - odd length fails

```zig
test "nibblesToKey - odd length fails" {
    const testing = std.testing;
    const allocator = testing.allocator;

    const nibbles = [_]u8{ 0x1, 0x2, 0x3 };
    const result = nibblesToKey(allocator, &nibbles);

    try testing.expectError(TrieError.InvalidKey, result);
}
```

### keyToNibbles and nibblesToKey - round trip

```zig
test "keyToNibbles and nibblesToKey - round trip" {
    const testing = std.testing;
    const allocator = testing.allocator;

    const original = [_]u8{ 0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF };
    const nibbles = try keyToNibbles(allocator, &original);
    defer allocator.free(nibbles);

    const restored = try nibblesToKey(allocator, nibbles);
    defer allocator.free(restored);

    try testing.expectEqualSlices(u8, &original, restored);
}
```

### encodePath - even length extension

```zig
test "encodePath - even length extension" {
    const testing = std.testing;
    const allocator = testing.allocator;

    const nibbles = [_]u8{ 0x1, 0x2, 0x3, 0x4 };
    const encoded = try encodePath(allocator, &nibbles, false);
    defer allocator.free(encoded);

    try testing.expectEqual(@as(usize, 3), encoded.len);
    try testing.expectEqual(@as(u8, 0x00), encoded[0]); // Even extension prefix
    try testing.expectEqual(@as(u8, 0x12), encoded[1]);
    try testing.expectEqual(@as(u8, 0x34), encoded[2]);
}
```

### encodePath - odd length leaf

```zig
test "encodePath - odd length leaf" {
    const testing = std.testing;
    const allocator = testing.allocator;

    const nibbles = [_]u8{ 0x1, 0x2, 0x3 };
    const encoded = try encodePath(allocator, &nibbles, true);
    defer allocator.free(encoded);

    try testing.expectEqual(@as(usize, 2), encoded.len);
    try testing.expectEqual(@as(u8, 0x31), encoded[0]); // Odd leaf prefix + first nibble
    try testing.expectEqual(@as(u8, 0x23), encoded[1]);
}
```

### encodePath - empty nibbles extension

```zig
test "encodePath - empty nibbles extension" {
    const testing = std.testing;
    const allocator = testing.allocator;

    const nibbles = [_]u8{};
    const encoded = try encodePath(allocator, &nibbles, false);
    defer allocator.free(encoded);

    try testing.expectEqual(@as(usize, 1), encoded.len);
    try testing.expectEqual(@as(u8, 0x00), encoded[0]);
}
```

### encodePath - empty nibbles leaf

```zig
test "encodePath - empty nibbles leaf" {
    const testing = std.testing;
    const allocator = testing.allocator;

    const nibbles = [_]u8{};
    const encoded = try encodePath(allocator, &nibbles, true);
    defer allocator.free(encoded);

    try testing.expectEqual(@as(usize, 1), encoded.len);
    try testing.expectEqual(@as(u8, 0x20), encoded[0]);
}
```

### decodePath - even length extension

```zig
test "decodePath - even length extension" {
    const testing = std.testing;
    const allocator = testing.allocator;

    const encoded = [_]u8{ 0x00, 0x12, 0x34 };
    const result = try decodePath(allocator, &encoded);
    defer allocator.free(result.nibbles);

    try testing.expect(!result.is_leaf);
    try testing.expectEqual(@as(usize, 4), result.nibbles.len);
    try testing.expectEqual(@as(u8, 0x1), result.nibbles[0]);
    try testing.expectEqual(@as(u8, 0x2), result.nibbles[1]);
    try testing.expectEqual(@as(u8, 0x3), result.nibbles[2]);
    try testing.expectEqual(@as(u8, 0x4), result.nibbles[3]);
}
```

### decodePath - odd length leaf

```zig
test "decodePath - odd length leaf" {
    const testing = std.testing;
    const allocator = testing.allocator;

    const encoded = [_]u8{ 0x31, 0x23 };
    const result = try decodePath(allocator, &encoded);
    defer allocator.free(result.nibbles);

    try testing.expect(result.is_leaf);
    try testing.expectEqual(@as(usize, 3), result.nibbles.len);
    try testing.expectEqual(@as(u8, 0x1), result.nibbles[0]);
    try testing.expectEqual(@as(u8, 0x2), result.nibbles[1]);
    try testing.expectEqual(@as(u8, 0x3), result.nibbles[2]);
}
```

### decodePath - empty encoded fails

```zig
test "decodePath - empty encoded fails" {
    const testing = std.testing;
    const allocator = testing.allocator;

    const encoded = [_]u8{};
    const result = decodePath(allocator, &encoded);

    try testing.expectError(TrieError.InvalidPath, result);
}
```

### encodePath and decodePath - round trip

```zig
test "encodePath and decodePath - round trip" {
    const testing = std.testing;
    const allocator = testing.allocator;

    const test_cases = [_]struct {
        nibbles: []const u8,
        is_leaf: bool,
    }{
        .{ .nibbles = &[_]u8{ 0x1, 0x2, 0x3, 0x4 }, .is_leaf = false },
        .{ .nibbles = &[_]u8{ 0xA, 0xB, 0xC }, .is_leaf = true },
        .{ .nibbles = &[_]u8{0x5}, .is_leaf = false },
        .{ .nibbles = &[_]u8{}, .is_leaf = true },
    };

    for (test_cases) |tc| {
        const encoded = try encodePath(allocator, tc.nibbles, tc.is_leaf);
        defer allocator.free(encoded);

        const decoded = try decodePath(allocator, encoded);
        defer allocator.free(decoded.nibbles);

        try testing.expectEqual(tc.is_leaf, decoded.is_leaf);
        try testing.expectEqualSlices(u8, tc.nibbles, decoded.nibbles);
    }
}
```

### LeafNode - init and deinit

```zig
test "LeafNode - init and deinit" {
    const testing = std.testing;
    const allocator = testing.allocator;

    const nibbles = [_]u8{ 0x1, 0x2, 0x3 };
    const value = "test_value";

    var leaf = try LeafNode.init(allocator, &nibbles, value);
    defer leaf.deinit(allocator);

    try testing.expectEqualSlices(u8, &nibbles, leaf.nibbles);
    try testing.expectEqualStrings(value, leaf.value);
}
```

### LeafNode - clone

```zig
test "LeafNode - clone" {
    const testing = std.testing;
    const allocator = testing.allocator;

    const nibbles = [_]u8{ 0x1, 0x2, 0x3 };
    const value = "test_value";

    var leaf = try LeafNode.init(allocator, &nibbles, value);
    defer leaf.deinit(allocator);

    var cloned = try leaf.clone(allocator);
    defer cloned.deinit(allocator);

    try testing.expectEqualSlices(u8, leaf.nibbles, cloned.nibbles);
    try testing.expectEqualStrings(leaf.value, cloned.value);

    // Verify it's a deep copy (different pointers)
    try testing.expect(leaf.nibbles.ptr != cloned.nibbles.ptr);
    try testing.expect(leaf.value.ptr != cloned.value.ptr);
}
```

### ExtensionNode - init and deinit

```zig
test "ExtensionNode - init and deinit" {
    const testing = std.testing;
    const allocator = testing.allocator;

    const nibbles = [_]u8{ 0x1, 0x2 };
    const hash = [_]u8{0xAB} ** 32;

    var ext = try ExtensionNode.init(allocator, &nibbles, hash);
    defer ext.deinit(allocator);

    try testing.expectEqualSlices(u8, &nibbles, ext.nibbles);
    try testing.expectEqualSlices(u8, &hash, &ext.child_hash);
}
```

### BranchNode - init and operations

```zig
test "BranchNode - init and operations" {
    const testing = std.testing;
    const allocator = testing.allocator;

    var branch = BranchNode.init();
    defer branch.deinit(allocator);

    // Start empty
    try testing.expect(branch.is_empty());
    try testing.expect(!branch.has_single_child());

    // Add a child
    const hash1 = [_]u8{0x11} ** 32;
    branch.set_child(5, hash1);

    try testing.expect(!branch.is_empty());
    try testing.expect(branch.has_single_child());
    try testing.expectEqual(@as(?u4, 5), branch.get_single_child_index());
    try testing.expectEqual(hash1, branch.get_child(5).?);

    // Add another child
    const hash2 = [_]u8{0x22} ** 32;
    branch.set_child(10, hash2);

    try testing.expect(!branch.has_single_child());
    try testing.expectEqual(@as(?u4, null), branch.get_single_child_index());

    // Remove a child
    branch.remove_child(5);
    try testing.expect(branch.has_single_child());
    try testing.expectEqual(@as(?u4, 10), branch.get_single_child_index());
}
```

### BranchNode - with value

```zig
test "BranchNode - with value" {
    const testing = std.testing;
    const allocator = testing.allocator;

    var branch = BranchNode.init();
    defer branch.deinit(allocator);

    // Add a value
    branch.value = try allocator.dupe(u8, "branch_value");

    try testing.expect(!branch.is_empty());
    try testing.expect(!branch.has_single_child());
    try testing.expectEqualStrings("branch_value", branch.value.?);
}
```

### Node - union operations

```zig
test "Node - union operations" {
    const testing = std.testing;
    const allocator = testing.allocator;

    // Test empty node
    {
        var node = Node{ .Empty = {} };
        defer node.deinit(allocator);
        try testing.expectEqual(NodeType.Empty, node);
    }

    // Test leaf node
    {
        const nibbles = [_]u8{ 0x1, 0x2 };
        const leaf = try LeafNode.init(allocator, &nibbles, "value");
        var node = Node{ .Leaf = leaf };
        defer node.deinit(allocator);
        try testing.expectEqual(NodeType.Leaf, node);
    }

    // Test clone
    {
        const nibbles = [_]u8{ 0x1, 0x2 };
        const leaf = try LeafNode.init(allocator, &nibbles, "value");
        var node = Node{ .Leaf = leaf };
        defer node.deinit(allocator);

        var cloned = try node.clone(allocator);
        defer cloned.deinit(allocator);

        try testing.expectEqual(NodeType.Leaf, cloned);
    }
}
```

### common_prefix_length

```zig
test "common_prefix_length" {
    const testing = std.testing;

    try testing.expectEqual(@as(usize, 0), common_prefix_length(&[_]u8{ 0x1, 0x2 }, &[_]u8{ 0x3, 0x4 }));
    try testing.expectEqual(@as(usize, 2), common_prefix_length(&[_]u8{ 0x1, 0x2 }, &[_]u8{ 0x1, 0x2, 0x3 }));
    try testing.expectEqual(@as(usize, 1), common_prefix_length(&[_]u8{ 0x1, 0x2, 0x3 }, &[_]u8{ 0x1, 0x4 }));
    try testing.expectEqual(@as(usize, 0), common_prefix_length(&[_]u8{}, &[_]u8{ 0x1, 0x2 }));
}
```

### Trie - empty trie

```zig
test "Trie - empty trie" {
    const testing = std.testing;
    const allocator = testing.allocator;

    var trie = Trie.init(allocator);
    defer trie.deinit();

    try testing.expect(trie.root_hash() == null);

    const result = try trie.get(&[_]u8{ 0x12, 0x34 });
    try testing.expect(result == null);
}
```

### Trie - single insert and get

```zig
test "Trie - single insert and get" {
    const testing = std.testing;
    const allocator = testing.allocator;

    var trie = Trie.init(allocator);
    defer trie.deinit();

    const key = [_]u8{ 0x12, 0x34 };
    const value = "test_value";

    try trie.put(&key, value);

    try testing.expect(trie.root_hash() != null);

    const retrieved = try trie.get(&key);
    try testing.expect(retrieved != null);
    try testing.expectEqualStrings(value, retrieved.?);
}
```

### Trie - update existing key

```zig
test "Trie - update existing key" {
    const testing = std.testing;
    const allocator = testing.allocator;

    var trie = Trie.init(allocator);
    defer trie.deinit();

    const key = [_]u8{ 0x12, 0x34 };

    try trie.put(&key, "value1");
    try trie.put(&key, "value2");

    const retrieved = try trie.get(&key);
    try testing.expect(retrieved != null);
    try testing.expectEqualStrings("value2", retrieved.?);
}
```

### Trie - multiple inserts

```zig
test "Trie - multiple inserts" {
    const testing = std.testing;
    const allocator = testing.allocator;

    var trie = Trie.init(allocator);
    defer trie.deinit();

    try trie.put(&[_]u8{ 0x12, 0x34 }, "value1");
    try trie.put(&[_]u8{ 0x12, 0x56 }, "value2");
    try trie.put(&[_]u8{ 0xAB, 0xCD }, "value3");

    const val1 = try trie.get(&[_]u8{ 0x12, 0x34 });
    try testing.expectEqualStrings("value1", val1.?);

    const val2 = try trie.get(&[_]u8{ 0x12, 0x56 });
    try testing.expectEqualStrings("value2", val2.?);

    const val3 = try trie.get(&[_]u8{ 0xAB, 0xCD });
    try testing.expectEqualStrings("value3", val3.?);
}
```

### Trie - delete single key

```zig
test "Trie - delete single key" {
    const testing = std.testing;
    const allocator = testing.allocator;

    var trie = Trie.init(allocator);
    defer trie.deinit();

    const key = [_]u8{ 0x12, 0x34 };
    try trie.put(&key, "value");

    try trie.delete(&key);

    const retrieved = try trie.get(&key);
    try testing.expect(retrieved == null);
    try testing.expect(trie.root_hash() == null);
}
```

### Trie - delete one of multiple keys

```zig
test "Trie - delete one of multiple keys" {
    const testing = std.testing;
    const allocator = testing.allocator;

    var trie = Trie.init(allocator);
    defer trie.deinit();

    try trie.put(&[_]u8{ 0x12, 0x34 }, "value1");
    try trie.put(&[_]u8{ 0x12, 0x56 }, "value2");

    try trie.delete(&[_]u8{ 0x12, 0x34 });

    const deleted = try trie.get(&[_]u8{ 0x12, 0x34 });
    try testing.expect(deleted == null);

    const remaining = try trie.get(&[_]u8{ 0x12, 0x56 });
    try testing.expectEqualStrings("value2", remaining.?);
}
```

### Trie - clear

```zig
test "Trie - clear" {
    const testing = std.testing;
    const allocator = testing.allocator;

    var trie = Trie.init(allocator);
    defer trie.deinit();

    try trie.put(&[_]u8{ 0x12, 0x34 }, "value1");
    try trie.put(&[_]u8{ 0x56, 0x78 }, "value2");

    trie.clear();

    try testing.expect(trie.root_hash() == null);
    try testing.expect((try trie.get(&[_]u8{ 0x12, 0x34 })) == null);
}
```

### Trie - root hash changes with updates

```zig
test "Trie - root hash changes with updates" {
    const testing = std.testing;
    const allocator = testing.allocator;

    var trie = Trie.init(allocator);
    defer trie.deinit();

    const key = [_]u8{ 0x12, 0x34 };

    try testing.expect(trie.root_hash() == null);

    try trie.put(&key, "value1");
    const hash1 = trie.root_hash();
    try testing.expect(hash1 != null);

    try trie.put(&key, "value2");
    const hash2 = trie.root_hash();
    try testing.expect(hash2 != null);

    try testing.expect(!std.mem.eql(u8, &hash1.?, &hash2.?));
}
```

### Trie - root hash deterministic

```zig
test "Trie - root hash deterministic" {
    const testing = std.testing;
    const allocator = testing.allocator;

    var trie1 = Trie.init(allocator);
    defer trie1.deinit();

    var trie2 = Trie.init(allocator);
    defer trie2.deinit();

    const keys = [_][]const u8{
        &[_]u8{ 0x12, 0x34 },
        &[_]u8{ 0x56, 0x78 },
        &[_]u8{ 0xAB, 0xCD },
    };

    for (keys, 0..) |key, i| {
        const value = try std.fmt.allocPrint(allocator, "value{}", .{i});
        defer allocator.free(value);
        try trie1.put(key, value);
        try trie2.put(key, value);
    }

    const hash1 = trie1.root_hash();
    const hash2 = trie2.root_hash();

    try testing.expect(hash1 != null);
    try testing.expect(hash2 != null);
    try testing.expectEqualSlices(u8, &hash1.?, &hash2.?);
}
```

### Trie - large key handling

```zig
test "Trie - large key handling" {
    const testing = std.testing;
    const allocator = testing.allocator;

    var trie = Trie.init(allocator);
    defer trie.deinit();

    var large_key: [256]u8 = undefined;
    for (&large_key, 0..) |*byte, i| {
        byte.* = @intCast(i % 256);
    }

    const value = "test_value_for_large_key";

    try trie.put(&large_key, value);

    const retrieved = try trie.get(&large_key);
    try testing.expect(retrieved != null);
    try testing.expectEqualStrings(value, retrieved.?);
}
```

### Trie - large value handling

```zig
test "Trie - large value handling" {
    const testing = std.testing;
    const allocator = testing.allocator;

    var trie = Trie.init(allocator);
    defer trie.deinit();

    const key = [_]u8{ 0x12, 0x34 };

    const large_value = try allocator.alloc(u8, 1024);
    defer allocator.free(large_value);
    for (large_value, 0..) |*byte, i| {
        byte.* = @intCast(i % 256);
    }

    try trie.put(&key, large_value);

    const retrieved = try trie.get(&key);
    try testing.expect(retrieved != null);
    try testing.expectEqualSlices(u8, large_value, retrieved.?);
}
```

### Trie - empty key handling

```zig
test "Trie - empty key handling" {
    const testing = std.testing;
    const allocator = testing.allocator;

    var trie = Trie.init(allocator);
    defer trie.deinit();

    const empty_key = [_]u8{};
    const value = "value_for_empty_key";

    try trie.put(&empty_key, value);

    const retrieved = try trie.get(&empty_key);
    try testing.expect(retrieved != null);
    try testing.expectEqualStrings(value, retrieved.?);
}
```

### Trie - empty value handling

```zig
test "Trie - empty value handling" {
    const testing = std.testing;
    const allocator = testing.allocator;

    var trie = Trie.init(allocator);
    defer trie.deinit();

    const key = [_]u8{ 0x12, 0x34 };
    const empty_value = "";

    try trie.put(&key, empty_value);

    const retrieved = try trie.get(&key);
    try testing.expect(retrieved != null);
    try testing.expectEqualStrings(empty_value, retrieved.?);
}
```

### Trie - single nibble keys

```zig
test "Trie - single nibble keys" {
    const testing = std.testing;
    const allocator = testing.allocator;

    var trie = Trie.init(allocator);
    defer trie.deinit();

    const key1 = [_]u8{0x01};
    const key2 = [_]u8{0x02};

    try trie.put(&key1, "value1");
    try trie.put(&key2, "value2");

    const val1 = try trie.get(&key1);
    try testing.expectEqualStrings("value1", val1.?);

    const val2 = try trie.get(&key2);
    try testing.expectEqualStrings("value2", val2.?);
}
```

### Trie - keys with common prefix

```zig
test "Trie - keys with common prefix" {
    const testing = std.testing;
    const allocator = testing.allocator;

    var trie = Trie.init(allocator);
    defer trie.deinit();

    try trie.put(&[_]u8{ 0x12, 0x34, 0x56 }, "value1");
    try trie.put(&[_]u8{ 0x12, 0x34, 0x78 }, "value2");
    try trie.put(&[_]u8{ 0x12, 0x34, 0x9A }, "value3");

    const val1 = try trie.get(&[_]u8{ 0x12, 0x34, 0x56 });
    try testing.expectEqualStrings("value1", val1.?);

    const val2 = try trie.get(&[_]u8{ 0x12, 0x34, 0x78 });
    try testing.expectEqualStrings("value2", val2.?);

    const val3 = try trie.get(&[_]u8{ 0x12, 0x34, 0x9A });
    try testing.expectEqualStrings("value3", val3.?);
}
```

### Trie - key is prefix of another

```zig
test "Trie - key is prefix of another" {
    const testing = std.testing;
    const allocator = testing.allocator;

    var trie = Trie.init(allocator);
    defer trie.deinit();

    try trie.put(&[_]u8{ 0x12, 0x34 }, "short");
    try trie.put(&[_]u8{ 0x12, 0x34, 0x56 }, "long");

    const short = try trie.get(&[_]u8{ 0x12, 0x34 });
    try testing.expectEqualStrings("short", short.?);

    const long = try trie.get(&[_]u8{ 0x12, 0x34, 0x56 });
    try testing.expectEqualStrings("long", long.?);
}
```

### Trie - get non-existent key

```zig
test "Trie - get non-existent key" {
    const testing = std.testing;
    const allocator = testing.allocator;

    var trie = Trie.init(allocator);
    defer trie.deinit();

    try trie.put(&[_]u8{ 0x12, 0x34 }, "value");

    const result = try trie.get(&[_]u8{ 0x56, 0x78 });
    try testing.expect(result == null);
}
```

### Trie - delete non-existent key

```zig
test "Trie - delete non-existent key" {
    const testing = std.testing;
    const allocator = testing.allocator;

    var trie = Trie.init(allocator);
    defer trie.deinit();

    try trie.put(&[_]u8{ 0x12, 0x34 }, "value");

    try trie.delete(&[_]u8{ 0x56, 0x78 });

    const val = try trie.get(&[_]u8{ 0x12, 0x34 });
    try testing.expectEqualStrings("value", val.?);
}
```

### Trie - delete from empty trie

```zig
test "Trie - delete from empty trie" {
    const testing = std.testing;
    const allocator = testing.allocator;

    var trie = Trie.init(allocator);
    defer trie.deinit();

    try trie.delete(&[_]u8{ 0x12, 0x34 });

    try testing.expect(trie.root_hash() == null);
}
```

### Trie - multiple deletes

```zig
test "Trie - multiple deletes" {
    const testing = std.testing;
    const allocator = testing.allocator;

    var trie = Trie.init(allocator);
    defer trie.deinit();

    try trie.put(&[_]u8{ 0x12, 0x34 }, "value1");
    try trie.put(&[_]u8{ 0x56, 0x78 }, "value2");
    try trie.put(&[_]u8{ 0xAB, 0xCD }, "value3");

    try trie.delete(&[_]u8{ 0x12, 0x34 });
    try testing.expect((try trie.get(&[_]u8{ 0x12, 0x34 })) == null);
    try testing.expectEqualStrings("value2", (try trie.get(&[_]u8{ 0x56, 0x78 })).?);

    try trie.delete(&[_]u8{ 0x56, 0x78 });
    try testing.expect((try trie.get(&[_]u8{ 0x56, 0x78 })) == null);
    try testing.expectEqualStrings("value3", (try trie.get(&[_]u8{ 0xAB, 0xCD })).?);

    try trie.delete(&[_]u8{ 0xAB, 0xCD });
    try testing.expect((try trie.get(&[_]u8{ 0xAB, 0xCD })) == null);
    try testing.expect(trie.root_hash() == null);
}
```

### Trie - delete and reinsert

```zig
test "Trie - delete and reinsert" {
    const testing = std.testing;
    const allocator = testing.allocator;

    var trie = Trie.init(allocator);
    defer trie.deinit();

    const key = [_]u8{ 0x12, 0x34 };

    try trie.put(&key, "value1");
    const hash1 = trie.root_hash();

    try trie.delete(&key);
    try testing.expect(trie.root_hash() == null);

    try trie.put(&key, "value1");
    const hash2 = trie.root_hash();

    try testing.expect(hash1 != null and hash2 != null);
    try testing.expectEqualSlices(u8, &hash1.?, &hash2.?);
}
```

### Trie - many sequential inserts

```zig
test "Trie - many sequential inserts" {
    const testing = std.testing;
    const allocator = testing.allocator;

    var trie = Trie.init(allocator);
    defer trie.deinit();

    const count = 100;
    var i: usize = 0;
    while (i < count) : (i += 1) {
        var key: [4]u8 = undefined;
        key[0] = @intCast((i >> 24) & 0xFF);
        key[1] = @intCast((i >> 16) & 0xFF);
        key[2] = @intCast((i >> 8) & 0xFF);
        key[3] = @intCast(i & 0xFF);

        const value = try std.fmt.allocPrint(allocator, "value{}", .{i});
        defer allocator.free(value);

        try trie.put(&key, value);
    }

    i = 0;
    while (i < count) : (i += 1) {
        var key: [4]u8 = undefined;
        key[0] = @intCast((i >> 24) & 0xFF);
        key[1] = @intCast((i >> 16) & 0xFF);
        key[2] = @intCast((i >> 8) & 0xFF);
        key[3] = @intCast(i & 0xFF);

        const expected = try std.fmt.allocPrint(allocator, "value{}", .{i});
        defer allocator.free(expected);

        const retrieved = try trie.get(&key);
        try testing.expect(retrieved != null);
        try testing.expectEqualStrings(expected, retrieved.?);
    }
}
```

### Trie - random access pattern

```zig
test "Trie - random access pattern" {
    const testing = std.testing;
    const allocator = testing.allocator;

    var trie = Trie.init(allocator);
    defer trie.deinit();

    const keys = [_][2]u8{
        [_]u8{ 0xAB, 0xCD },
        [_]u8{ 0x12, 0x34 },
        [_]u8{ 0xFF, 0x00 },
        [_]u8{ 0x56, 0x78 },
        [_]u8{ 0x00, 0xFF },
    };

    for (keys, 0..) |key, i| {
        const value = try std.fmt.allocPrint(allocator, "value{}", .{i});
        defer allocator.free(value);
        try trie.put(&key, value);
    }

    for (keys, 0..) |key, i| {
        const expected = try std.fmt.allocPrint(allocator, "value{}", .{i});
        defer allocator.free(expected);

        const retrieved = try trie.get(&key);
        try testing.expect(retrieved != null);
        try testing.expectEqualStrings(expected, retrieved.?);
    }
}
```

### Trie - branch node creation and traversal

```zig
test "Trie - branch node creation and traversal" {
    const testing = std.testing;
    const allocator = testing.allocator;

    var trie = Trie.init(allocator);
    defer trie.deinit();

    var i: u8 = 0;
    while (i < 16) : (i += 1) {
        const key = [_]u8{ i, 0x00 };
        const value = try std.fmt.allocPrint(allocator, "value{}", .{i});
        defer allocator.free(value);
        try trie.put(&key, value);
    }

    i = 0;
    while (i < 16) : (i += 1) {
        const key = [_]u8{ i, 0x00 };
        const expected = try std.fmt.allocPrint(allocator, "value{}", .{i});
        defer allocator.free(expected);

        const retrieved = try trie.get(&key);
        try testing.expect(retrieved != null);
        try testing.expectEqualStrings(expected, retrieved.?);
    }
}
```

### Trie - extension node creation

```zig
test "Trie - extension node creation" {
    const testing = std.testing;
    const allocator = testing.allocator;

    var trie = Trie.init(allocator);
    defer trie.deinit();

    try trie.put(&[_]u8{ 0x01, 0x02, 0x03, 0x04 }, "value1");
    try trie.put(&[_]u8{ 0x01, 0x02, 0x03, 0x05 }, "value2");

    const val1 = try trie.get(&[_]u8{ 0x01, 0x02, 0x03, 0x04 });
    try testing.expectEqualStrings("value1", val1.?);

    const val2 = try trie.get(&[_]u8{ 0x01, 0x02, 0x03, 0x05 });
    try testing.expectEqualStrings("value2", val2.?);
}
```

### Trie - all node types

```zig
test "Trie - all node types" {
    const testing = std.testing;
    const allocator = testing.allocator;

    var trie = Trie.init(allocator);
    defer trie.deinit();

    try trie.put(&[_]u8{ 0x01, 0x23, 0x45 }, "leaf1");
    try trie.put(&[_]u8{ 0x01, 0x23, 0x46 }, "leaf2");
    try trie.put(&[_]u8{ 0x01, 0x24 }, "branch_value");
    try trie.put(&[_]u8{ 0x02, 0x00 }, "another_leaf");

    try testing.expectEqualStrings("leaf1", (try trie.get(&[_]u8{ 0x01, 0x23, 0x45 })).?);
    try testing.expectEqualStrings("leaf2", (try trie.get(&[_]u8{ 0x01, 0x23, 0x46 })).?);
    try testing.expectEqualStrings("branch_value", (try trie.get(&[_]u8{ 0x01, 0x24 })).?);
    try testing.expectEqualStrings("another_leaf", (try trie.get(&[_]u8{ 0x02, 0x00 })).?);
}
```

### Trie - delete with branch collapse

```zig
test "Trie - delete with branch collapse" {
    const testing = std.testing;
    const allocator = testing.allocator;

    var trie = Trie.init(allocator);
    defer trie.deinit();

    try trie.put(&[_]u8{ 0x01, 0x23 }, "value1");
    try trie.put(&[_]u8{ 0x01, 0x24 }, "value2");
    try trie.put(&[_]u8{ 0x01, 0x25 }, "value3");

    try trie.delete(&[_]u8{ 0x01, 0x23 });
    try trie.delete(&[_]u8{ 0x01, 0x24 });

    try testing.expect((try trie.get(&[_]u8{ 0x01, 0x23 })) == null);
    try testing.expect((try trie.get(&[_]u8{ 0x01, 0x24 })) == null);
    try testing.expectEqualStrings("value3", (try trie.get(&[_]u8{ 0x01, 0x25 })).?);
}
```

### Trie - memory safety with many operations

```zig
test "Trie - memory safety with many operations" {
    const testing = std.testing;
    const allocator = testing.allocator;

    var trie = Trie.init(allocator);
    defer trie.deinit();

    var i: usize = 0;
    while (i < 50) : (i += 1) {
        var key: [2]u8 = undefined;
        key[0] = @intCast((i >> 8) & 0xFF);
        key[1] = @intCast(i & 0xFF);

        const value = try std.fmt.allocPrint(allocator, "value{}", .{i});
        defer allocator.free(value);
        try trie.put(&key, value);
    }

    i = 0;
    while (i < 50) : (i += 2) {
        var key: [2]u8 = undefined;
        key[0] = @intCast((i >> 8) & 0xFF);
        key[1] = @intCast(i & 0xFF);
        try trie.delete(&key);
    }

    i = 1;
    while (i < 50) : (i += 2) {
        var key: [2]u8 = undefined;
        key[0] = @intCast((i >> 8) & 0xFF);
        key[1] = @intCast(i & 0xFF);

        const expected = try std.fmt.allocPrint(allocator, "value{}", .{i});
        defer allocator.free(expected);

        const retrieved = try trie.get(&key);
        try testing.expect(retrieved != null);
        try testing.expectEqualStrings(expected, retrieved.?);
    }
}
```

### Trie - overwrite with different length values

```zig
test "Trie - overwrite with different length values" {
    const testing = std.testing;
    const allocator = testing.allocator;

    var trie = Trie.init(allocator);
    defer trie.deinit();

    const key = [_]u8{ 0x12, 0x34 };

    try trie.put(&key, "short");
    try testing.expectEqualStrings("short", (try trie.get(&key)).?);

    try trie.put(&key, "much longer value");
    try testing.expectEqualStrings("much longer value", (try trie.get(&key)).?);

    try trie.put(&key, "x");
    try testing.expectEqualStrings("x", (try trie.get(&key)).?);
}
```

### Trie - hash_to_string and back

```zig
test "Trie - hash_to_string and back" {
    const testing = std.testing;
    const allocator = testing.allocator;

    const hash = [_]u8{0xAB} ** 32;
    const hash_str = try hash_to_string(allocator, &hash);
    defer allocator.free(hash_str);

    try testing.expectEqual(@as(usize, 64), hash_str.len);

    for (hash_str) |c| {
        try testing.expect((c >= '0' and c <= '9') or (c >= 'a' and c <= 'f'));
    }
}
```

### Trie - store and retrieve node

```zig
test "Trie - store and retrieve node" {
    const testing = std.testing;
    const allocator = testing.allocator;

    var trie = Trie.init(allocator);
    defer trie.deinit();

    const nibbles = [_]u8{ 0x1, 0x2, 0x3 };
    const leaf = try LeafNode.init(allocator, &nibbles, "test");
    const node = Node{ .Leaf = leaf };

    const hash = try trie.store_node(node);

    const retrieved = trie.get_node(hash);
    try testing.expect(retrieved != null);
}
```

### Trie - clear and reuse

```zig
test "Trie - clear and reuse" {
    const testing = std.testing;
    const allocator = testing.allocator;

    var trie = Trie.init(allocator);
    defer trie.deinit();

    try trie.put(&[_]u8{ 0x12, 0x34 }, "value1");
    try trie.put(&[_]u8{ 0x56, 0x78 }, "value2");

    trie.clear();

    try trie.put(&[_]u8{ 0xAB, 0xCD }, "value3");
    try testing.expectEqualStrings("value3", (try trie.get(&[_]u8{ 0xAB, 0xCD })).?);
    try testing.expect((try trie.get(&[_]u8{ 0x12, 0x34 })) == null);
}
```
