---
title: '[Zig] src/primitives/ContractResult/contract_result.zig'
source: 'src/primitives/ContractResult/contract_result.zig'
---

> Auto-generated from Zig tests in: src/primitives/ContractResult/contract_result.zig

### success - with data

```zig
test "success - with data" {
    const allocator = std.testing.allocator;
    const data = [_]u8{ 0x00, 0x00, 0x00, 0x01 };
    var result = try success(allocator, &data);
    defer result.deinit();

    try std.testing.expect(result.isSuccess());
    try std.testing.expect(!result.isFailure());
    try std.testing.expectEqualSlices(u8, &data, result.getData());
}
```

### success - empty data

```zig
test "success - empty data" {
    const allocator = std.testing.allocator;
    var result = try success(allocator, &[_]u8{});
    defer result.deinit();

    try std.testing.expect(result.isSuccess());
    try std.testing.expectEqual(@as(usize, 0), result.getData().len);
}
```

### failure - empty data

```zig
test "failure - empty data" {
    const allocator = std.testing.allocator;
    var result = try failure(allocator, &[_]u8{});
    defer result.deinit();

    try std.testing.expect(result.isFailure());
    try std.testing.expect(!result.isSuccess());
}
```

### failure - with panic selector

```zig
test "failure - with panic selector" {
    const allocator = std.testing.allocator;
    // Panic(uint256) with code 0x01 (assert failure)
    var data: [36]u8 = undefined;
    @memcpy(data[0..4], &PANIC_SELECTOR);
    @memset(data[4..35], 0);
    data[35] = 0x01;

    var result = try failure(allocator, &data);
    defer result.deinit();

    try std.testing.expect(result.isFailure());
    const reason = result.getRevertReason().?;
    try std.testing.expect(reason.isPanic());
    try std.testing.expectEqual(@as(?u256, 0x01), reason.getPanicCode());
}
```

### from - success

```zig
test "from - success" {
    const allocator = std.testing.allocator;
    var result = try from(allocator, true, &[_]u8{ 0x01, 0x02 });
    defer result.deinit();

    try std.testing.expect(result.isSuccess());
}
```

### from - failure

```zig
test "from - failure" {
    const allocator = std.testing.allocator;
    var result = try from(allocator, false, &[_]u8{});
    defer result.deinit();

    try std.testing.expect(result.isFailure());
}
```

### failureWithMessage - basic

```zig
test "failureWithMessage - basic" {
    const allocator = std.testing.allocator;
    var result = try failureWithMessage(allocator, "Insufficient balance");
    defer result.deinit();

    try std.testing.expect(result.isFailure());
    const reason = result.getRevertReason().?;
    try std.testing.expect(reason.isErrorMessage());
    try std.testing.expectEqualStrings("Insufficient balance", reason.getMessage().?);
}
```

### failureWithPanic - basic

```zig
test "failureWithPanic - basic" {
    const allocator = std.testing.allocator;
    var result = try failureWithPanic(allocator, 0x11); // Overflow
    defer result.deinit();

    try std.testing.expect(result.isFailure());
    const reason = result.getRevertReason().?;
    try std.testing.expect(reason.isPanic());
    try std.testing.expectEqual(@as(?u256, 0x11), reason.getPanicCode());
}
```

### unwrap - success

```zig
test "unwrap - success" {
    const allocator = std.testing.allocator;
    const data = [_]u8{ 0x01, 0x02, 0x03 };
    var result = try success(allocator, &data);
    defer result.deinit();

    const unwrapped = try unwrap(&result);
    try std.testing.expectEqualSlices(u8, &data, unwrapped);
}
```

### unwrap - failure returns error

```zig
test "unwrap - failure returns error" {
    const allocator = std.testing.allocator;
    var result = try failure(allocator, &[_]u8{});
    defer result.deinit();

    try std.testing.expectError(Error.UnwrapOnFailure, unwrap(&result));
}
```

### unwrapOr - success

```zig
test "unwrapOr - success" {
    const allocator = std.testing.allocator;
    const data = [_]u8{ 0x01, 0x02, 0x03 };
    var result = try success(allocator, &data);
    defer result.deinit();

    const unwrapped = unwrapOr(&result, &[_]u8{});
    try std.testing.expectEqualSlices(u8, &data, unwrapped);
}
```

### unwrapOr - failure returns default

```zig
test "unwrapOr - failure returns default" {
    const allocator = std.testing.allocator;
    var result = try failure(allocator, &[_]u8{});
    defer result.deinit();

    const default = [_]u8{ 0xff, 0xff };
    const unwrapped = unwrapOr(&result, &default);
    try std.testing.expectEqualSlices(u8, &default, unwrapped);
}
```

### parseRevertReason - panic

```zig
test "parseRevertReason - panic" {
    var data: [36]u8 = undefined;
    @memcpy(data[0..4], &PANIC_SELECTOR);
    @memset(data[4..35], 0);
    data[35] = 0x12; // Division by zero

    const reason = parseRevertReason(&data).?;
    try std.testing.expect(reason.isPanic());
    try std.testing.expectEqual(@as(?u256, 0x12), reason.getPanicCode());
}
```

### parseRevertReason - empty

```zig
test "parseRevertReason - empty" {
    const reason = parseRevertReason(&[_]u8{});
    try std.testing.expect(reason == null);
}
```

### parseRevertReason - short data

```zig
test "parseRevertReason - short data" {
    const data = [_]u8{ 0x01, 0x02 };
    const reason = parseRevertReason(&data).?;
    switch (reason) {
        .raw => {},
        else => try std.testing.expect(false),
    }
}
```

### parseRevertReason - custom error

```zig
test "parseRevertReason - custom error" {
    const data = [_]u8{ 0xaa, 0xbb, 0xcc, 0xdd, 0x01, 0x02 };
    const reason = parseRevertReason(&data).?;
    switch (reason) {
        .custom_error => |ce| {
            try std.testing.expectEqual([4]u8{ 0xaa, 0xbb, 0xcc, 0xdd }, ce.selector);
            try std.testing.expectEqualSlices(u8, &[_]u8{ 0x01, 0x02 }, ce.data);
        },
        else => try std.testing.expect(false),
    }
}
```

### toHex - success with data

```zig
test "toHex - success with data" {
    const allocator = std.testing.allocator;
    var result = try success(allocator, &[_]u8{ 0x12, 0x34 });
    defer result.deinit();

    const hex = try toHex(&result, allocator);
    defer allocator.free(hex);

    try std.testing.expectEqualStrings("0x1234", hex);
}
```

### toHex - empty

```zig
test "toHex - empty" {
    const allocator = std.testing.allocator;
    var result = try success(allocator, &[_]u8{});
    defer result.deinit();

    const hex = try toHex(&result, allocator);
    defer allocator.free(hex);

    try std.testing.expectEqualStrings("0x", hex);
}
```

### clone - success

```zig
test "clone - success" {
    const allocator = std.testing.allocator;
    var original = try success(allocator, &[_]u8{ 0x01, 0x02 });
    defer original.deinit();

    var copy = try clone(allocator, &original);
    defer copy.deinit();

    try std.testing.expect(copy.isSuccess());
    try std.testing.expectEqualSlices(u8, original.getData(), copy.getData());
    try std.testing.expect(original.data.ptr != copy.data.ptr);
}
```

### clone - failure

```zig
test "clone - failure" {
    const allocator = std.testing.allocator;
    var original = try failure(allocator, &[_]u8{});
    defer original.deinit();

    var copy = try clone(allocator, &original);
    defer copy.deinit();

    try std.testing.expect(copy.isFailure());
}
```
