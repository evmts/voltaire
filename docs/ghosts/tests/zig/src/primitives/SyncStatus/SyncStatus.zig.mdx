---
title: '[Zig] src/primitives/SyncStatus/SyncStatus.zig'
source: 'src/primitives/SyncStatus/SyncStatus.zig'
---

> Auto-generated from Zig tests in: src/primitives/SyncStatus/SyncStatus.zig

### SyncStatus: notSyncing creates not syncing status

```zig
test "SyncStatus: notSyncing creates not syncing status" {
    const status = notSyncing();
    try std.testing.expect(!status.isSyncing());
}
```

### SyncStatus: syncing creates syncing status

```zig
test "SyncStatus: syncing creates syncing status" {
    const status = syncing(0, 1000, 2000);
    try std.testing.expect(status.isSyncing());
}
```

### SyncStatus: isSyncing returns true when syncing

```zig
test "SyncStatus: isSyncing returns true when syncing" {
    const status = syncing(0, 500, 1000);
    try std.testing.expect(status.isSyncing());
}
```

### SyncStatus: isSyncing returns false when not syncing

```zig
test "SyncStatus: isSyncing returns false when not syncing" {
    const status = notSyncing();
    try std.testing.expect(!status.isSyncing());
}
```

### SyncStatus: getProgress returns 100 when not syncing

```zig
test "SyncStatus: getProgress returns 100 when not syncing" {
    const status = notSyncing();
    try std.testing.expectApproxEqAbs(@as(f64, 100.0), status.getProgress(), 0.001);
}
```

### SyncStatus: getProgress returns 50% at midpoint

```zig
test "SyncStatus: getProgress returns 50% at midpoint" {
    const status = syncing(0, 500, 1000);
    try std.testing.expectApproxEqAbs(@as(f64, 50.0), status.getProgress(), 0.001);
}
```

### SyncStatus: getProgress returns 0% at start

```zig
test "SyncStatus: getProgress returns 0% at start" {
    const status = syncing(0, 0, 1000);
    try std.testing.expectApproxEqAbs(@as(f64, 0.0), status.getProgress(), 0.001);
}
```

### SyncStatus: getProgress returns 100% when complete

```zig
test "SyncStatus: getProgress returns 100% when complete" {
    const status = syncing(0, 1000, 1000);
    try std.testing.expectApproxEqAbs(@as(f64, 100.0), status.getProgress(), 0.001);
}
```

### SyncStatus: getProgress handles non-zero starting block

```zig
test "SyncStatus: getProgress handles non-zero starting block" {
    const status = syncing(1000, 1500, 2000);
    // Progress: (1500-1000)/(2000-1000) = 500/1000 = 50%
    try std.testing.expectApproxEqAbs(@as(f64, 50.0), status.getProgress(), 0.001);
}
```

### SyncStatus: getProgress returns 100 when total is 0

```zig
test "SyncStatus: getProgress returns 100 when total is 0" {
    const status = syncing(1000, 1000, 1000);
    try std.testing.expectApproxEqAbs(@as(f64, 100.0), status.getProgress(), 0.001);
}
```

### SyncStatus: getStartingBlock returns block when syncing

```zig
test "SyncStatus: getStartingBlock returns block when syncing" {
    const status = syncing(1000, 1500, 2000);
    try std.testing.expectEqual(@as(?u64, 1000), status.getStartingBlock());
}
```

### SyncStatus: getStartingBlock returns null when not syncing

```zig
test "SyncStatus: getStartingBlock returns null when not syncing" {
    const status = notSyncing();
    try std.testing.expectEqual(@as(?u64, null), status.getStartingBlock());
}
```

### SyncStatus: getCurrentBlock returns block when syncing

```zig
test "SyncStatus: getCurrentBlock returns block when syncing" {
    const status = syncing(0, 1500, 2000);
    try std.testing.expectEqual(@as(?u64, 1500), status.getCurrentBlock());
}
```

### SyncStatus: getCurrentBlock returns null when not syncing

```zig
test "SyncStatus: getCurrentBlock returns null when not syncing" {
    const status = notSyncing();
    try std.testing.expectEqual(@as(?u64, null), status.getCurrentBlock());
}
```

### SyncStatus: getHighestBlock returns block when syncing

```zig
test "SyncStatus: getHighestBlock returns block when syncing" {
    const status = syncing(0, 1000, 2000);
    try std.testing.expectEqual(@as(?u64, 2000), status.getHighestBlock());
}
```

### SyncStatus: getHighestBlock returns null when not syncing

```zig
test "SyncStatus: getHighestBlock returns null when not syncing" {
    const status = notSyncing();
    try std.testing.expectEqual(@as(?u64, null), status.getHighestBlock());
}
```

### SyncStatus: getRemainingBlocks calculates correctly

```zig
test "SyncStatus: getRemainingBlocks calculates correctly" {
    const status = syncing(0, 1500, 2000);
    try std.testing.expectEqual(@as(?u64, 500), status.getRemainingBlocks());
}
```

### SyncStatus: getRemainingBlocks returns 0 when complete

```zig
test "SyncStatus: getRemainingBlocks returns 0 when complete" {
    const status = syncing(0, 2000, 2000);
    try std.testing.expectEqual(@as(?u64, 0), status.getRemainingBlocks());
}
```

### SyncStatus: getRemainingBlocks returns null when not syncing

```zig
test "SyncStatus: getRemainingBlocks returns null when not syncing" {
    const status = notSyncing();
    try std.testing.expectEqual(@as(?u64, null), status.getRemainingBlocks());
}
```

### SyncStatus: syncingWithStates includes state info

```zig
test "SyncStatus: syncingWithStates includes state info" {
    const status = syncingWithStates(0, 500, 1000, 1000000, 2000000);
    try std.testing.expect(status.isSyncing());

    switch (status) {
        .syncing => |progress| {
            try std.testing.expectEqual(@as(?u256, 1000000), progress.pulled_states);
            try std.testing.expectEqual(@as(?u256, 2000000), progress.known_states);
        },
        else => unreachable,
    }
}
```

### SyncStatus: complete workflow

```zig
test "SyncStatus: complete workflow" {
    // Node starts syncing
    var status = syncing(1000, 1000, 2000);
    try std.testing.expect(status.isSyncing());
    try std.testing.expectApproxEqAbs(@as(f64, 0.0), status.getProgress(), 0.001);
    try std.testing.expectEqual(@as(?u64, 1000), status.getRemainingBlocks());

    // Progress to 50%
    status = syncing(1000, 1500, 2000);
    try std.testing.expectApproxEqAbs(@as(f64, 50.0), status.getProgress(), 0.001);
    try std.testing.expectEqual(@as(?u64, 500), status.getRemainingBlocks());

    // Sync complete
    status = notSyncing();
    try std.testing.expect(!status.isSyncing());
    try std.testing.expectApproxEqAbs(@as(f64, 100.0), status.getProgress(), 0.001);
}
```

### SyncStatus: toJson encodes not syncing

```zig
test "SyncStatus: toJson encodes not syncing" {
    const allocator = std.testing.allocator;
    const status = notSyncing();

    const json_str = try toJson(status, allocator);
    defer allocator.free(json_str);

    try std.testing.expectEqualStrings("false", json_str);
}
```

### SyncStatus: toJson encodes syncing

```zig
test "SyncStatus: toJson encodes syncing" {
    const allocator = std.testing.allocator;
    const status = syncing(0, 1000, 2000);

    const json_str = try toJson(status, allocator);
    defer allocator.free(json_str);

    try std.testing.expect(std.mem.indexOf(u8, json_str, "\"startingBlock\":\"0x0\"") != null);
    try std.testing.expect(std.mem.indexOf(u8, json_str, "\"currentBlock\":\"0x3e8\"") != null);
    try std.testing.expect(std.mem.indexOf(u8, json_str, "\"highestBlock\":\"0x7d0\"") != null);
}
```

### SyncStatus: fromJson decodes false

```zig
test "SyncStatus: fromJson decodes false" {
    const allocator = std.testing.allocator;

    const status = try fromJson(allocator, "false");
    try std.testing.expect(!status.isSyncing());
}
```

### SyncStatus: fromJson decodes syncing object

```zig
test "SyncStatus: fromJson decodes syncing object" {
    const allocator = std.testing.allocator;
    const json_str =
        \\{"startingBlock":"0x0","currentBlock":"0x3e8","highestBlock":"0x7d0"}
    ;

    const status = try fromJson(allocator, json_str);
    try std.testing.expect(status.isSyncing());
    try std.testing.expectEqual(@as(?u64, 0), status.getStartingBlock());
    try std.testing.expectEqual(@as(?u64, 1000), status.getCurrentBlock());
    try std.testing.expectEqual(@as(?u64, 2000), status.getHighestBlock());
}
```

### SyncStatus: fromJson decodes with state info

```zig
test "SyncStatus: fromJson decodes with state info" {
    const allocator = std.testing.allocator;
    const json_str =
        \\{"startingBlock":"0x0","currentBlock":"0x1f4","highestBlock":"0x3e8","pulledStates":"0xf4240","knownStates":"0x1e8480"}
    ;

    const status = try fromJson(allocator, json_str);
    try std.testing.expect(status.isSyncing());

    switch (status) {
        .syncing => |progress| {
            try std.testing.expectEqual(@as(?u256, 1000000), progress.pulled_states);
            try std.testing.expectEqual(@as(?u256, 2000000), progress.known_states);
        },
        else => unreachable,
    }
}
```

### SyncStatus: JSON roundtrip not syncing

```zig
test "SyncStatus: JSON roundtrip not syncing" {
    const allocator = std.testing.allocator;
    const original = notSyncing();

    const json_str = try toJson(original, allocator);
    defer allocator.free(json_str);

    const decoded = try fromJson(allocator, json_str);
    try std.testing.expect(equals(original, decoded));
}
```

### SyncStatus: JSON roundtrip syncing

```zig
test "SyncStatus: JSON roundtrip syncing" {
    const allocator = std.testing.allocator;
    const original = syncing(1000, 1500, 2000);

    const json_str = try toJson(original, allocator);
    defer allocator.free(json_str);

    const decoded = try fromJson(allocator, json_str);
    try std.testing.expect(equals(original, decoded));
}
```

### SyncStatus: equals compares correctly

```zig
test "SyncStatus: equals compares correctly" {
    const status1 = syncing(0, 500, 1000);
    const status2 = syncing(0, 500, 1000);
    const status3 = syncing(0, 600, 1000);
    const status4 = notSyncing();

    try std.testing.expect(equals(status1, status2));
    try std.testing.expect(!equals(status1, status3));
    try std.testing.expect(!equals(status1, status4));
    try std.testing.expect(equals(status4, notSyncing()));
}
```
