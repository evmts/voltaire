---
title: '[Zig] src/primitives/BloomFilter/bloom_filter.zig'
source: 'src/primitives/BloomFilter/bloom_filter.zig'
---

> Auto-generated from Zig tests in: src/primitives/BloomFilter/bloom_filter.zig

### create bloom filter

```zig
test "create bloom filter" {
    var bf = try BloomFilter.init(testing.allocator, 1000, 3);
    defer bf.deinit(testing.allocator);
}
```

### add and contains

```zig
test "add and contains" {
    var bf = try BloomFilter.init(testing.allocator, 1000, 3);
    defer bf.deinit(testing.allocator);

    bf.add("foo");
    try testing.expect(bf.contains("foo"));
    try testing.expect(!bf.contains("bar"));
}
```

### multiple items

```zig
test "multiple items" {
    var bf = try BloomFilter.init(testing.allocator, 1000, 3);
    defer bf.deinit(testing.allocator);

    bf.add("foo");
    bf.add("bar");
    bf.add("baz");

    try testing.expect(bf.contains("foo"));
    try testing.expect(bf.contains("bar"));
    try testing.expect(bf.contains("baz"));
    try testing.expect(!bf.contains("qux"));
}
```

### no false negatives

```zig
test "no false negatives" {
    var bf = try BloomFilter.init(testing.allocator, 10000, 5);
    defer bf.deinit(testing.allocator);

    const items = [_][]const u8{ "a", "b", "c", "test", "hello", "world", "zig", "ethereum" };

    for (items) |item| {
        bf.add(item);
    }

    for (items) |item| {
        try testing.expect(bf.contains(item));
    }
}
```

### isEmpty - new filter

```zig
test "isEmpty - new filter" {
    var bf = try BloomFilter.init(testing.allocator, 1000, 3);
    defer bf.deinit(testing.allocator);
    try testing.expect(bf.isEmpty());
}
```

### isEmpty - after adding item

```zig
test "isEmpty - after adding item" {
    var bf = try BloomFilter.init(testing.allocator, 1000, 3);
    defer bf.deinit(testing.allocator);
    bf.add("test");
    try testing.expect(!bf.isEmpty());
}
```

### isEmpty - single bit set

```zig
test "isEmpty - single bit set" {
    var bf = try BloomFilter.init(testing.allocator, 1000, 3);
    defer bf.deinit(testing.allocator);
    bf.bits[0] = 1;
    try testing.expect(!bf.isEmpty());
}
```

### density - empty filter

```zig
test "density - empty filter" {
    var bf = try BloomFilter.init(testing.allocator, 2048, 3);
    defer bf.deinit(testing.allocator);
    const d = bf.density();
    try testing.expect(d == 0.0);
}
```

### density - after adding items

```zig
test "density - after adding items" {
    var bf = try BloomFilter.init(testing.allocator, 2048, 3);
    defer bf.deinit(testing.allocator);
    bf.add("test");
    const d = bf.density();
    try testing.expect(d > 0.0);
    try testing.expect(d < 0.01);
}
```

### density - increases with more items

```zig
test "density - increases with more items" {
    var bf = try BloomFilter.init(testing.allocator, 2048, 3);
    defer bf.deinit(testing.allocator);
    bf.add("test1");
    const d1 = bf.density();

    bf.add("test2");
    bf.add("test3");
    const d2 = bf.density();

    try testing.expect(d2 > d1);
}
```

### expectedFalsePositiveRate - calculates FPR

```zig
test "expectedFalsePositiveRate - calculates FPR" {
    var bf = try BloomFilter.init(testing.allocator, 2048, 3);
    defer bf.deinit(testing.allocator);
    const fpr = bf.expectedFalsePositiveRate(100);
    try testing.expect(fpr > 0.0);
    try testing.expect(fpr < 0.01);
}
```

### expectedFalsePositiveRate - increases with more items

```zig
test "expectedFalsePositiveRate - increases with more items" {
    var bf = try BloomFilter.init(testing.allocator, 2048, 3);
    defer bf.deinit(testing.allocator);
    const fpr1 = bf.expectedFalsePositiveRate(10);
    const fpr2 = bf.expectedFalsePositiveRate(100);
    try testing.expect(fpr2 > fpr1);
}
```

### expectedFalsePositiveRate - well-sized filter

```zig
test "expectedFalsePositiveRate - well-sized filter" {
    var bf = try BloomFilter.init(testing.allocator, 10000, 5);
    defer bf.deinit(testing.allocator);
    const fpr = bf.expectedFalsePositiveRate(100);
    try testing.expect(fpr < 0.001);
}
```

### merge - two filters

```zig
test "merge - two filters" {
    var f1 = try BloomFilter.init(testing.allocator, 2048, 3);
    defer f1.deinit(testing.allocator);
    var f2 = try BloomFilter.init(testing.allocator, 2048, 3);
    defer f2.deinit(testing.allocator);

    f1.add("test1");
    f2.add("test2");

    var merged = try BloomFilter.merge(testing.allocator, &f1, &f2);
    defer merged.deinit(testing.allocator);

    try testing.expect(merged.contains("test1"));
    try testing.expect(merged.contains("test2"));
}
```

### merge - does not mutate source filters

```zig
test "merge - does not mutate source filters" {
    var f1 = try BloomFilter.init(testing.allocator, 2048, 3);
    defer f1.deinit(testing.allocator);
    var f2 = try BloomFilter.init(testing.allocator, 2048, 3);
    defer f2.deinit(testing.allocator);

    f1.add("test1");
    f2.add("test2");

    var merged = try BloomFilter.merge(testing.allocator, &f1, &f2);
    defer merged.deinit(testing.allocator);

    try testing.expect(f1.contains("test1"));
    try testing.expect(!f1.contains("test2"));
    try testing.expect(!f2.contains("test1"));
    try testing.expect(f2.contains("test2"));
}
```

### merge - mismatched m

```zig
test "merge - mismatched m" {
    var f1 = try BloomFilter.init(testing.allocator, 2048, 3);
    defer f1.deinit(testing.allocator);
    var f2 = try BloomFilter.init(testing.allocator, 4096, 3);
    defer f2.deinit(testing.allocator);

    const result = BloomFilter.merge(testing.allocator, &f1, &f2);
    try testing.expectError(error.MismatchedParameters, result);
}
```

### merge - mismatched k

```zig
test "merge - mismatched k" {
    var f1 = try BloomFilter.init(testing.allocator, 2048, 3);
    defer f1.deinit(testing.allocator);
    var f2 = try BloomFilter.init(testing.allocator, 2048, 5);
    defer f2.deinit(testing.allocator);

    const result = BloomFilter.merge(testing.allocator, &f1, &f2);
    try testing.expectError(error.MismatchedParameters, result);
}
```

### combine - multiple filters

```zig
test "combine - multiple filters" {
    var f1 = try BloomFilter.init(testing.allocator, 2048, 3);
    defer f1.deinit(testing.allocator);
    var f2 = try BloomFilter.init(testing.allocator, 2048, 3);
    defer f2.deinit(testing.allocator);
    var f3 = try BloomFilter.init(testing.allocator, 2048, 3);
    defer f3.deinit(testing.allocator);

    f1.add("test1");
    f2.add("test2");
    f3.add("test3");

    const filters = [_]*const BloomFilter{ &f1, &f2, &f3 };
    var combined = try BloomFilter.combine(testing.allocator, &filters);
    defer combined.deinit(testing.allocator);

    try testing.expect(combined.contains("test1"));
    try testing.expect(combined.contains("test2"));
    try testing.expect(combined.contains("test3"));
}
```

### combine - empty input

```zig
test "combine - empty input" {
    const filters: []const *const BloomFilter = &.{};
    const result = BloomFilter.combine(testing.allocator, filters);
    try testing.expectError(error.EmptyFilterList, result);
}
```

### combine - mismatched parameters

```zig
test "combine - mismatched parameters" {
    var f1 = try BloomFilter.init(testing.allocator, 2048, 3);
    defer f1.deinit(testing.allocator);
    var f2 = try BloomFilter.init(testing.allocator, 4096, 3);
    defer f2.deinit(testing.allocator);

    const filters = [_]*const BloomFilter{ &f1, &f2 };
    const result = BloomFilter.combine(testing.allocator, &filters);
    try testing.expectError(error.MismatchedParameters, result);
}
```

### toHex - empty filter

```zig
test "toHex - empty filter" {
    var bf = try BloomFilter.init(testing.allocator, 64, 3);
    defer bf.deinit(testing.allocator);
    const hex = try bf.toHex(testing.allocator);
    defer testing.allocator.free(hex);

    // 64 bits = 8 bytes = 16 hex chars + "0x" = 18 chars
    try testing.expectEqual(@as(usize, 18), hex.len);
    try testing.expect(std.mem.startsWith(u8, hex, "0x"));
    try testing.expectEqualStrings("0x0000000000000000", hex);
}
```

### toHex - filter with items

```zig
test "toHex - filter with items" {
    var bf = try BloomFilter.init(testing.allocator, 64, 3);
    defer bf.deinit(testing.allocator);
    bf.add("test");
    const hex = try bf.toHex(testing.allocator);
    defer testing.allocator.free(hex);

    try testing.expectEqual(@as(usize, 18), hex.len);
    try testing.expect(std.mem.startsWith(u8, hex, "0x"));
    // Should not be all zeros
    try testing.expect(!std.mem.eql(u8, hex, "0x0000000000000000"));
}
```

### toHex - lowercase hex

```zig
test "toHex - lowercase hex" {
    var bf = try BloomFilter.init(testing.allocator, 64, 3);
    defer bf.deinit(testing.allocator);
    bf.bits[0] = 0xff;
    const hex = try bf.toHex(testing.allocator);
    defer testing.allocator.free(hex);

    // First byte should be "ff" (lowercase)
    try testing.expectEqualStrings("ff", hex[2..4]);
}
```

### fromHex - creates filter from hex string

```zig
test "fromHex - creates filter from hex string" {
    const hex = "0x0000000000000000";
    var bf = try BloomFilter.fromHex(testing.allocator, hex, 64, 3);
    defer bf.deinit(testing.allocator);

    try testing.expectEqual(@as(usize, 8), bf.bits.len);
    try testing.expectEqual(@as(usize, 64), bf.m);
    try testing.expectEqual(@as(usize, 3), bf.k);
}
```

### fromHex - recreates filter with data

```zig
test "fromHex - recreates filter with data" {
    var original = try BloomFilter.init(testing.allocator, 64, 3);
    defer original.deinit(testing.allocator);
    original.add("test");

    const hex = try original.toHex(testing.allocator);
    defer testing.allocator.free(hex);

    var restored = try BloomFilter.fromHex(testing.allocator, hex, 64, 3);
    defer restored.deinit(testing.allocator);

    try testing.expect(restored.contains("test"));
}
```

### fromHex - round-trips through hex

```zig
test "fromHex - round-trips through hex" {
    var original = try BloomFilter.init(testing.allocator, 64, 3);
    defer original.deinit(testing.allocator);
    original.add("test1");
    original.add("test2");
    original.add("test3");

    const hex = try original.toHex(testing.allocator);
    defer testing.allocator.free(hex);

    var restored = try BloomFilter.fromHex(testing.allocator, hex, 64, 3);
    defer restored.deinit(testing.allocator);

    const hex2 = try restored.toHex(testing.allocator);
    defer testing.allocator.free(hex2);

    try testing.expectEqualStrings(hex, hex2);
}
```

### fromHex - handles uppercase hex

```zig
test "fromHex - handles uppercase hex" {
    const hex = "0xFFFFFFFFFFFFFFFF";
    var bf = try BloomFilter.fromHex(testing.allocator, hex, 64, 3);
    defer bf.deinit(testing.allocator);

    for (bf.bits) |byte| {
        try testing.expectEqual(@as(u8, 0xff), byte);
    }
}
```

### fromHex - handles hex without 0x prefix

```zig
test "fromHex - handles hex without 0x prefix" {
    const hex = "0000000000000000";
    var bf = try BloomFilter.fromHex(testing.allocator, hex, 64, 3);
    defer bf.deinit(testing.allocator);

    try testing.expectEqual(@as(usize, 8), bf.bits.len);
}
```
