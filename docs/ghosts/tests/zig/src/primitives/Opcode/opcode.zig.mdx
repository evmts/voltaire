---
title: '[Zig] src/primitives/Opcode/opcode.zig'
source: 'src/primitives/Opcode/opcode.zig'
---

> Auto-generated from Zig tests in: src/primitives/Opcode/opcode.zig

### opcode enum values

```zig
test "opcode enum values" {
    try std.testing.expectEqual(@as(u8, 0x00), @intFromEnum(Opcode.STOP));
    try std.testing.expectEqual(@as(u8, 0x01), @intFromEnum(Opcode.ADD));
    try std.testing.expectEqual(@as(u8, 0x5f), @intFromEnum(Opcode.PUSH0));
    try std.testing.expectEqual(@as(u8, 0x60), @intFromEnum(Opcode.PUSH1));
    try std.testing.expectEqual(@as(u8, 0x7f), @intFromEnum(Opcode.PUSH32));
    try std.testing.expectEqual(@as(u8, 0xff), @intFromEnum(Opcode.SELFDESTRUCT));
}
```

### opcode push detection

```zig
test "opcode push detection" {
    try std.testing.expect(Opcode.PUSH0.isPush());
    try std.testing.expect(Opcode.PUSH1.isPush());
    try std.testing.expect(Opcode.PUSH16.isPush());
    try std.testing.expect(Opcode.PUSH32.isPush());

    try std.testing.expect(!Opcode.ADD.isPush());
    try std.testing.expect(!Opcode.DUP1.isPush());
    try std.testing.expect(!Opcode.STOP.isPush());
}
```

### opcode push size calculation

```zig
test "opcode push size calculation" {
    try std.testing.expectEqual(@as(u8, 0), Opcode.PUSH0.pushSize());
    try std.testing.expectEqual(@as(u8, 1), Opcode.PUSH1.pushSize());
    try std.testing.expectEqual(@as(u8, 16), Opcode.PUSH16.pushSize());
    try std.testing.expectEqual(@as(u8, 32), Opcode.PUSH32.pushSize());

    try std.testing.expectEqual(@as(u8, 0), Opcode.ADD.pushSize());
    try std.testing.expectEqual(@as(u8, 0), Opcode.DUP1.pushSize());
}
```

### opcode dup detection

```zig
test "opcode dup detection" {
    try std.testing.expect(Opcode.DUP1.isDup());
    try std.testing.expect(Opcode.DUP8.isDup());
    try std.testing.expect(Opcode.DUP16.isDup());

    try std.testing.expect(!Opcode.PUSH1.isDup());
    try std.testing.expect(!Opcode.SWAP1.isDup());
    try std.testing.expect(!Opcode.ADD.isDup());
}
```

### opcode dup position calculation

```zig
test "opcode dup position calculation" {
    try std.testing.expectEqual(@as(u8, 1), Opcode.DUP1.dupPosition());
    try std.testing.expectEqual(@as(u8, 8), Opcode.DUP8.dupPosition());
    try std.testing.expectEqual(@as(u8, 16), Opcode.DUP16.dupPosition());

    try std.testing.expectEqual(@as(u8, 0), Opcode.PUSH1.dupPosition());
    try std.testing.expectEqual(@as(u8, 0), Opcode.ADD.dupPosition());
}
```

### opcode swap detection

```zig
test "opcode swap detection" {
    try std.testing.expect(Opcode.SWAP1.isSwap());
    try std.testing.expect(Opcode.SWAP8.isSwap());
    try std.testing.expect(Opcode.SWAP16.isSwap());

    try std.testing.expect(!Opcode.DUP1.isSwap());
    try std.testing.expect(!Opcode.PUSH1.isSwap());
    try std.testing.expect(!Opcode.ADD.isSwap());
}
```

### opcode swap position calculation

```zig
test "opcode swap position calculation" {
    try std.testing.expectEqual(@as(u8, 1), Opcode.SWAP1.swapPosition());
    try std.testing.expectEqual(@as(u8, 8), Opcode.SWAP8.swapPosition());
    try std.testing.expectEqual(@as(u8, 16), Opcode.SWAP16.swapPosition());

    try std.testing.expectEqual(@as(u8, 0), Opcode.DUP1.swapPosition());
    try std.testing.expectEqual(@as(u8, 0), Opcode.ADD.swapPosition());
}
```

### opcode log detection

```zig
test "opcode log detection" {
    try std.testing.expect(Opcode.LOG0.isLog());
    try std.testing.expect(Opcode.LOG1.isLog());
    try std.testing.expect(Opcode.LOG4.isLog());

    try std.testing.expect(!Opcode.ADD.isLog());
    try std.testing.expect(!Opcode.SSTORE.isLog());
    try std.testing.expect(!Opcode.CALL.isLog());
}
```

### opcode log topics calculation

```zig
test "opcode log topics calculation" {
    try std.testing.expectEqual(@as(u8, 0), Opcode.LOG0.logTopics());
    try std.testing.expectEqual(@as(u8, 1), Opcode.LOG1.logTopics());
    try std.testing.expectEqual(@as(u8, 4), Opcode.LOG4.logTopics());

    try std.testing.expectEqual(@as(u8, 0), Opcode.ADD.logTopics());
    try std.testing.expectEqual(@as(u8, 0), Opcode.SSTORE.logTopics());
}
```

### opcode terminating detection

```zig
test "opcode terminating detection" {
    try std.testing.expect(Opcode.STOP.isTerminating());
    try std.testing.expect(Opcode.RETURN.isTerminating());
    try std.testing.expect(Opcode.REVERT.isTerminating());
    try std.testing.expect(Opcode.INVALID.isTerminating());
    try std.testing.expect(Opcode.SELFDESTRUCT.isTerminating());

    try std.testing.expect(!Opcode.ADD.isTerminating());
    try std.testing.expect(!Opcode.JUMP.isTerminating());
    try std.testing.expect(!Opcode.CALL.isTerminating());
}
```

### opcode state modifying detection

```zig
test "opcode state modifying detection" {
    try std.testing.expect(Opcode.SSTORE.isStateModifying());
    try std.testing.expect(Opcode.TSTORE.isStateModifying());
    try std.testing.expect(Opcode.LOG0.isStateModifying());
    try std.testing.expect(Opcode.LOG4.isStateModifying());
    try std.testing.expect(Opcode.CREATE.isStateModifying());
    try std.testing.expect(Opcode.CALL.isStateModifying());
    try std.testing.expect(Opcode.SELFDESTRUCT.isStateModifying());

    try std.testing.expect(!Opcode.ADD.isStateModifying());
    try std.testing.expect(!Opcode.SLOAD.isStateModifying());
    try std.testing.expect(!Opcode.STATICCALL.isStateModifying());
}
```

### opcode arithmetic detection

```zig
test "opcode arithmetic detection" {
    try std.testing.expect(Opcode.ADD.isArithmetic());
    try std.testing.expect(Opcode.MUL.isArithmetic());
    try std.testing.expect(Opcode.DIV.isArithmetic());
    try std.testing.expect(Opcode.MOD.isArithmetic());
    try std.testing.expect(Opcode.EXP.isArithmetic());
    try std.testing.expect(Opcode.SIGNEXTEND.isArithmetic());

    try std.testing.expect(!Opcode.LT.isArithmetic());
    try std.testing.expect(!Opcode.AND.isArithmetic());
    try std.testing.expect(!Opcode.PUSH1.isArithmetic());
}
```

### opcode comparison detection

```zig
test "opcode comparison detection" {
    try std.testing.expect(Opcode.LT.isComparison());
    try std.testing.expect(Opcode.GT.isComparison());
    try std.testing.expect(Opcode.EQ.isComparison());
    try std.testing.expect(Opcode.ISZERO.isComparison());

    try std.testing.expect(!Opcode.ADD.isComparison());
    try std.testing.expect(!Opcode.AND.isComparison());
    try std.testing.expect(!Opcode.PUSH1.isComparison());
}
```

### opcode bitwise detection

```zig
test "opcode bitwise detection" {
    try std.testing.expect(Opcode.AND.isBitwise());
    try std.testing.expect(Opcode.OR.isBitwise());
    try std.testing.expect(Opcode.XOR.isBitwise());
    try std.testing.expect(Opcode.NOT.isBitwise());
    try std.testing.expect(Opcode.SHL.isBitwise());
    try std.testing.expect(Opcode.SHR.isBitwise());

    try std.testing.expect(!Opcode.ADD.isBitwise());
    try std.testing.expect(!Opcode.LT.isBitwise());
    try std.testing.expect(!Opcode.PUSH1.isBitwise());
}
```

### opcode names

```zig
test "opcode names" {
    try std.testing.expectEqualStrings("ADD", Opcode.ADD.name());
    try std.testing.expectEqualStrings("PUSH1", Opcode.PUSH1.name());
    try std.testing.expectEqualStrings("DUP1", Opcode.DUP1.name());
    try std.testing.expectEqualStrings("SWAP16", Opcode.SWAP16.name());
    try std.testing.expectEqualStrings("LOG4", Opcode.LOG4.name());
    try std.testing.expectEqualStrings("SELFDESTRUCT", Opcode.SELFDESTRUCT.name());
}
```

### opcode isValid detection

```zig
test "opcode isValid detection" {
    // Valid opcodes
    try std.testing.expect(Opcode.isValid(0x01)); // ADD
    try std.testing.expect(Opcode.isValid(0x60)); // PUSH1
    try std.testing.expect(Opcode.isValid(0xff)); // SELFDESTRUCT
    try std.testing.expect(Opcode.isValid(0x00)); // STOP
    try std.testing.expect(Opcode.isValid(0x5f)); // PUSH0
    try std.testing.expect(Opcode.isValid(0x80)); // DUP1
    try std.testing.expect(Opcode.isValid(0x90)); // SWAP1
    try std.testing.expect(Opcode.isValid(0xa0)); // LOG0

    // Invalid opcodes
    try std.testing.expect(!Opcode.isValid(0x0c));
    try std.testing.expect(!Opcode.isValid(0x0d));
    try std.testing.expect(!Opcode.isValid(0x21));
    try std.testing.expect(!Opcode.isValid(0xf8));
    try std.testing.expect(!Opcode.isValid(0xfb));
}
```

### opcode isJump detection

```zig
test "opcode isJump detection" {
    try std.testing.expect(Opcode.JUMP.isJump());
    try std.testing.expect(Opcode.JUMPI.isJump());

    try std.testing.expect(!Opcode.JUMPDEST.isJump());
    try std.testing.expect(!Opcode.ADD.isJump());
    try std.testing.expect(!Opcode.PUSH1.isJump());
}
```

### opcode isJumpDestination detection

```zig
test "opcode isJumpDestination detection" {
    try std.testing.expect(Opcode.JUMPDEST.isJumpDestination());

    try std.testing.expect(!Opcode.JUMP.isJumpDestination());
    try std.testing.expect(!Opcode.JUMPI.isJumpDestination());
    try std.testing.expect(!Opcode.ADD.isJumpDestination());
}
```

### opcode pushOpcode function

```zig
test "opcode pushOpcode function" {
    try std.testing.expectEqual(Opcode.PUSH0, try Opcode.pushOpcode(0));
    try std.testing.expectEqual(Opcode.PUSH1, try Opcode.pushOpcode(1));
    try std.testing.expectEqual(Opcode.PUSH2, try Opcode.pushOpcode(2));
    try std.testing.expectEqual(Opcode.PUSH16, try Opcode.pushOpcode(16));
    try std.testing.expectEqual(Opcode.PUSH32, try Opcode.pushOpcode(32));

    // Invalid sizes should error
    try std.testing.expectError(error.InvalidPushSize, Opcode.pushOpcode(33));
    try std.testing.expectError(error.InvalidPushSize, Opcode.pushOpcode(255));
}
```

### parse simple bytecode

```zig
test "parse simple bytecode" {
    const allocator = std.testing.allocator;

    // PUSH1 0x01, PUSH1 0x02, ADD
    const bytecode = [_]u8{ 0x60, 0x01, 0x60, 0x02, 0x01 };
    const instructions = try parse(allocator, &bytecode);
    defer allocator.free(instructions);

    try std.testing.expectEqual(@as(usize, 3), instructions.len);

    try std.testing.expectEqual(Opcode.PUSH1, instructions[0].opcode);
    try std.testing.expectEqual(@as(usize, 0), instructions[0].offset);
    try std.testing.expect(instructions[0].immediate != null);
    try std.testing.expectEqualSlices(u8, &[_]u8{0x01}, instructions[0].immediate.?);

    try std.testing.expectEqual(Opcode.PUSH1, instructions[1].opcode);
    try std.testing.expectEqual(@as(usize, 2), instructions[1].offset);
    try std.testing.expectEqualSlices(u8, &[_]u8{0x02}, instructions[1].immediate.?);

    try std.testing.expectEqual(Opcode.ADD, instructions[2].opcode);
    try std.testing.expectEqual(@as(usize, 4), instructions[2].offset);
    try std.testing.expect(instructions[2].immediate == null);
}
```

### parse PUSH0

```zig
test "parse PUSH0" {
    const allocator = std.testing.allocator;

    const bytecode = [_]u8{ 0x5f, 0x01 };
    const instructions = try parse(allocator, &bytecode);
    defer allocator.free(instructions);

    try std.testing.expectEqual(@as(usize, 2), instructions.len);
    try std.testing.expectEqual(Opcode.PUSH0, instructions[0].opcode);
    try std.testing.expect(instructions[0].immediate == null);
}
```

### parse PUSH32

```zig
test "parse PUSH32" {
    const allocator = std.testing.allocator;

    var bytecode: [33]u8 = undefined;
    bytecode[0] = 0x7f; // PUSH32
    @memset(bytecode[1..], 0xff);

    const instructions = try parse(allocator, &bytecode);
    defer allocator.free(instructions);

    try std.testing.expectEqual(@as(usize, 1), instructions.len);
    try std.testing.expectEqual(Opcode.PUSH32, instructions[0].opcode);
    try std.testing.expect(instructions[0].immediate != null);
    try std.testing.expectEqual(@as(usize, 32), instructions[0].immediate.?.len);
}
```

### parse truncated PUSH data

```zig
test "parse truncated PUSH data" {
    const allocator = std.testing.allocator;

    const bytecode = [_]u8{0x60}; // PUSH1 without data
    const instructions = try parse(allocator, &bytecode);
    defer allocator.free(instructions);

    try std.testing.expectEqual(@as(usize, 1), instructions.len);
    try std.testing.expectEqual(Opcode.PUSH1, instructions[0].opcode);
    try std.testing.expect(instructions[0].immediate != null);
    try std.testing.expectEqual(@as(usize, 0), instructions[0].immediate.?.len);
}
```

### parse empty bytecode

```zig
test "parse empty bytecode" {
    const allocator = std.testing.allocator;

    const bytecode = [_]u8{};
    const instructions = try parse(allocator, &bytecode);
    defer allocator.free(instructions);

    try std.testing.expectEqual(@as(usize, 0), instructions.len);
}
```

### jumpDests finds JUMPDEST opcodes

```zig
test "jumpDests finds JUMPDEST opcodes" {
    const allocator = std.testing.allocator;

    const bytecode = [_]u8{ 0x5b, 0x60, 0x01, 0x5b };
    const dests = try jumpDests(allocator, &bytecode);
    defer allocator.free(dests);

    try std.testing.expectEqual(@as(usize, 2), dests.len);
    try std.testing.expectEqual(@as(usize, 0), dests[0]);
    try std.testing.expectEqual(@as(usize, 3), dests[1]);
}
```

### jumpDests ignores JUMPDEST in immediate data

```zig
test "jumpDests ignores JUMPDEST in immediate data" {
    const allocator = std.testing.allocator;

    const bytecode = [_]u8{ 0x60, 0x5b, 0x5b }; // PUSH1 0x5b, JUMPDEST
    const dests = try jumpDests(allocator, &bytecode);
    defer allocator.free(dests);

    try std.testing.expectEqual(@as(usize, 1), dests.len);
    try std.testing.expectEqual(@as(usize, 2), dests[0]);
}
```

### jumpDests handles bytecode with no JUMPDESTs

```zig
test "jumpDests handles bytecode with no JUMPDESTs" {
    const allocator = std.testing.allocator;

    const bytecode = [_]u8{ 0x60, 0x01, 0x60, 0x02, 0x01 };
    const dests = try jumpDests(allocator, &bytecode);
    defer allocator.free(dests);

    try std.testing.expectEqual(@as(usize, 0), dests.len);
}
```

### isValidJumpDest validates JUMPDEST locations

```zig
test "isValidJumpDest validates JUMPDEST locations" {
    const allocator = std.testing.allocator;

    const bytecode = [_]u8{ 0x5b, 0x60, 0x01, 0x5b };

    try std.testing.expect(try isValidJumpDest(allocator, &bytecode, 0));
    try std.testing.expect(try isValidJumpDest(allocator, &bytecode, 3));
}
```

### isValidJumpDest rejects non-JUMPDEST locations

```zig
test "isValidJumpDest rejects non-JUMPDEST locations" {
    const allocator = std.testing.allocator;

    const bytecode = [_]u8{ 0x5b, 0x60, 0x01, 0x5b };

    try std.testing.expect(!try isValidJumpDest(allocator, &bytecode, 1));
    try std.testing.expect(!try isValidJumpDest(allocator, &bytecode, 2));
}
```

### isValidJumpDest rejects JUMPDEST in immediate data

```zig
test "isValidJumpDest rejects JUMPDEST in immediate data" {
    const allocator = std.testing.allocator;

    const bytecode = [_]u8{ 0x60, 0x5b };
    try std.testing.expect(!try isValidJumpDest(allocator, &bytecode, 1));
}
```

### formatInstruction formats simple opcodes

```zig
test "formatInstruction formats simple opcodes" {
    const allocator = std.testing.allocator;

    const inst = Instruction{
        .offset = 0,
        .opcode = Opcode.ADD,
    };

    const formatted = try formatInstruction(allocator, inst);
    defer allocator.free(formatted);

    try std.testing.expectEqualStrings("0x0000: ADD", formatted);
}
```

### formatInstruction formats PUSH with immediate data

```zig
test "formatInstruction formats PUSH with immediate data" {
    const allocator = std.testing.allocator;

    const immediate = [_]u8{0x42};
    const inst = Instruction{
        .offset = 10,
        .opcode = Opcode.PUSH1,
        .immediate = &immediate,
    };

    const formatted = try formatInstruction(allocator, inst);
    defer allocator.free(formatted);

    try std.testing.expectEqualStrings("0x000a: PUSH1 0x42", formatted);
}
```

### disassemble bytecode to strings

```zig
test "disassemble bytecode to strings" {
    const allocator = std.testing.allocator;

    const bytecode = [_]u8{ 0x60, 0x01, 0x60, 0x02, 0x01 };
    const asm_lines = try disassemble(allocator, &bytecode);
    defer {
        for (asm_lines) |line| allocator.free(line);
        allocator.free(asm_lines);
    }

    try std.testing.expectEqual(@as(usize, 3), asm_lines.len);
    try std.testing.expectEqualStrings("0x0000: PUSH1 0x01", asm_lines[0]);
    try std.testing.expectEqualStrings("0x0002: PUSH1 0x02", asm_lines[1]);
    try std.testing.expectEqualStrings("0x0004: ADD", asm_lines[2]);
}
```
