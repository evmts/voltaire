---
title: '[Zig] src/primitives/State/state.zig'
source: 'src/primitives/State/state.zig'
---

> Auto-generated from Zig tests in: src/primitives/State/state.zig

### StorageKey.toString produces correct format

```zig
test "StorageKey.toString produces correct format" {
    const addr = [_]u8{0x01} ** 20;
    const key = StorageKey{ .address = addr, .slot = 42 };

    const str = try key.toString(std.testing.allocator);
    defer std.testing.allocator.free(str);

    // Should be 105 chars: 40 (address) + 1 (separator) + 64 (slot)
    try std.testing.expectEqual(@as(usize, 105), str.len);

    // Check separator
    try std.testing.expectEqual(@as(u8, '_'), str[40]);

    // Check format (address should be all 01s)
    try std.testing.expectEqualStrings("0101010101010101010101010101010101010101", str[0..40]);

    // Check slot hex (42 decimal = 0x2a)
    try std.testing.expect(std.mem.endsWith(u8, str[41..], "2a"));
}
```

### StorageKey.toString with zero values

```zig
test "StorageKey.toString with zero values" {
    const addr = [_]u8{0x00} ** 20;
    const key = StorageKey{ .address = addr, .slot = 0 };

    const str = try key.toString(std.testing.allocator);
    defer std.testing.allocator.free(str);

    try std.testing.expectEqual(@as(usize, 105), str.len);
    try std.testing.expectEqualStrings("0000000000000000000000000000000000000000", str[0..40]);
    try std.testing.expectEqualStrings("0000000000000000000000000000000000000000000000000000000000000000", str[41..]);
}
```

### StorageKey.toString with maximum values

```zig
test "StorageKey.toString with maximum values" {
    const addr = [_]u8{0xFF} ** 20;
    const max_slot: u256 = std.math.maxInt(u256);
    const key = StorageKey{ .address = addr, .slot = max_slot };

    const str = try key.toString(std.testing.allocator);
    defer std.testing.allocator.free(str);

    try std.testing.expectEqual(@as(usize, 105), str.len);
    try std.testing.expectEqualStrings("ffffffffffffffffffffffffffffffffffffffff", str[0..40]);
    try std.testing.expectEqualStrings("ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff", str[41..]);
}
```

### StorageKey.toString produces different strings for different keys

```zig
test "StorageKey.toString produces different strings for different keys" {
    const addr1 = [_]u8{0x01} ** 20;
    const addr2 = [_]u8{0x02} ** 20;
    const key1 = StorageKey{ .address = addr1, .slot = 42 };
    const key2 = StorageKey{ .address = addr2, .slot = 42 };

    const str1 = try key1.toString(std.testing.allocator);
    defer std.testing.allocator.free(str1);
    const str2 = try key2.toString(std.testing.allocator);
    defer std.testing.allocator.free(str2);

    try std.testing.expect(!std.mem.eql(u8, str1, str2));
}
```

### StorageKey.toString produces different strings for different slots

```zig
test "StorageKey.toString produces different strings for different slots" {
    const addr = [_]u8{0x01} ** 20;
    const key1 = StorageKey{ .address = addr, .slot = 42 };
    const key2 = StorageKey{ .address = addr, .slot = 43 };

    const str1 = try key1.toString(std.testing.allocator);
    defer std.testing.allocator.free(str1);
    const str2 = try key2.toString(std.testing.allocator);
    defer std.testing.allocator.free(str2);

    try std.testing.expect(!std.mem.eql(u8, str1, str2));
}
```

### StorageKey.fromString parses valid string

```zig
test "StorageKey.fromString parses valid string" {
    const valid_str = "0101010101010101010101010101010101010101_000000000000000000000000000000000000000000000000000000000000002a";
    const key = try StorageKey.fromString(valid_str);

    try std.testing.expectEqual(@as(u256, 0x2a), key.slot);
    try std.testing.expectEqual(@as(u8, 0x01), key.address[0]);
    try std.testing.expectEqual(@as(u8, 0x01), key.address[19]);
}
```

### StorageKey.fromString round-trip with zero values

```zig
test "StorageKey.fromString round-trip with zero values" {
    const addr = [_]u8{0x00} ** 20;
    const original = StorageKey{ .address = addr, .slot = 0 };

    const str = try original.toString(std.testing.allocator);
    defer std.testing.allocator.free(str);

    const parsed = try StorageKey.fromString(str);
    try std.testing.expect(StorageKey.eql(original, parsed));
}
```

### StorageKey.fromString round-trip with large values

```zig
test "StorageKey.fromString round-trip with large values" {
    const addr = [_]u8{0xFF} ** 20;
    const large_slot: u256 = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;
    const original = StorageKey{ .address = addr, .slot = large_slot };

    const str = try original.toString(std.testing.allocator);
    defer std.testing.allocator.free(str);

    const parsed = try StorageKey.fromString(str);
    try std.testing.expect(StorageKey.eql(original, parsed));
}
```

### StorageKey.fromString round-trip with pattern address

```zig
test "StorageKey.fromString round-trip with pattern address" {
    const addr = [20]u8{ 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0x10, 0x11, 0x12, 0x13, 0x14 };
    const original = StorageKey{ .address = addr, .slot = 123456789 };

    const str = try original.toString(std.testing.allocator);
    defer std.testing.allocator.free(str);

    const parsed = try StorageKey.fromString(str);
    try std.testing.expect(StorageKey.eql(original, parsed));
}
```

### StorageKey.fromString rejects invalid length

```zig
test "StorageKey.fromString rejects invalid length" {
    try std.testing.expectError(error.InvalidStringLength, StorageKey.fromString("short"));
    try std.testing.expectError(error.InvalidStringLength, StorageKey.fromString("0101010101010101010101010101010101010101_00000000000000000000000000000000000000000000000000000000000000"));
}
```

### StorageKey.fromString rejects missing separator

```zig
test "StorageKey.fromString rejects missing separator" {
    // String has correct length (105) but wrong separator position
    const no_sep = "0101010101010101010101010101010101010101X0000000000000000000000000000000000000000000000000000000000000000";
    try std.testing.expectError(error.InvalidSeparator, StorageKey.fromString(no_sep));
}
```

### StorageKey.fromString rejects invalid hex characters

```zig
test "StorageKey.fromString rejects invalid hex characters" {
    try std.testing.expectError(error.InvalidHexCharacter, StorageKey.fromString("ZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZ_0000000000000000000000000000000000000000000000000000000000000000"));
    try std.testing.expectError(error.InvalidHexCharacter, StorageKey.fromString("0101010101010101010101010101010101010101_ZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZ"));
}
```

### StorageKey.fromString accepts both upper and lower case hex

```zig
test "StorageKey.fromString accepts both upper and lower case hex" {
    const lower = "abcdef0123456789abcdef0123456789abcdef01_0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef";
    const upper = "ABCDEF0123456789ABCDEF0123456789ABCDEF01_0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF";

    const key_lower = try StorageKey.fromString(lower);
    const key_upper = try StorageKey.fromString(upper);

    try std.testing.expect(StorageKey.eql(key_lower, key_upper));
}
```

### StorageKey.hashCode produces consistent results

```zig
test "StorageKey.hashCode produces consistent results" {
    const addr = [_]u8{0xAB} ** 20;
    const key = StorageKey{ .address = addr, .slot = 12345 };

    const hash1 = key.hashCode();
    const hash2 = key.hashCode();

    try std.testing.expectEqual(hash1, hash2);
}
```

### StorageKey.hashCode produces different values for different addresses

```zig
test "StorageKey.hashCode produces different values for different addresses" {
    const addr1 = [_]u8{0x01} ** 20;
    const addr2 = [_]u8{0x02} ** 20;
    const key1 = StorageKey{ .address = addr1, .slot = 0 };
    const key2 = StorageKey{ .address = addr2, .slot = 0 };

    const hash1 = key1.hashCode();
    const hash2 = key2.hashCode();

    try std.testing.expect(hash1 != hash2);
}
```

### StorageKey.hashCode produces different values for different slots

```zig
test "StorageKey.hashCode produces different values for different slots" {
    const addr = [_]u8{0x01} ** 20;
    const key1 = StorageKey{ .address = addr, .slot = 42 };
    const key2 = StorageKey{ .address = addr, .slot = 43 };

    const hash1 = key1.hashCode();
    const hash2 = key2.hashCode();

    try std.testing.expect(hash1 != hash2);
}
```

### StorageKey.hashCode handles zero values

```zig
test "StorageKey.hashCode handles zero values" {
    const addr = [_]u8{0x00} ** 20;
    const key = StorageKey{ .address = addr, .slot = 0 };

    const hash_code = key.hashCode();
    // Should produce a deterministic value
    try std.testing.expectEqual(@as(i32, 0), hash_code);
}
```

### StorageKey.hashCode handles maximum values

```zig
test "StorageKey.hashCode handles maximum values" {
    const addr = [_]u8{0xFF} ** 20;
    const max_slot: u256 = std.math.maxInt(u256);
    const key = StorageKey{ .address = addr, .slot = max_slot };

    const hash_code = key.hashCode();
    // Should not crash and should produce a valid i32
    _ = hash_code;
}
```

### EMPTY_CODE_HASH is correct Keccak256 of empty bytes

```zig
test "EMPTY_CODE_HASH is correct Keccak256 of empty bytes" {
    var hasher = Keccak256.init(.{});
    hasher.update(&.{});
    var computed: [32]u8 = undefined;
    hasher.final(&computed);

    try std.testing.expectEqualSlices(u8, &EMPTY_CODE_HASH, &computed);
}
```

### EMPTY_TRIE_ROOT is correct Keccak256 of RLP null

```zig
test "EMPTY_TRIE_ROOT is correct Keccak256 of RLP null" {
    var hasher = Keccak256.init(.{});
    hasher.update(&[_]u8{0x80}); // RLP encoding of null
    var computed: [32]u8 = undefined;
    hasher.final(&computed);

    try std.testing.expectEqualSlices(u8, &EMPTY_TRIE_ROOT, &computed);
}
```

### StorageKey equality with identical keys

```zig
test "StorageKey equality with identical keys" {
    const addr = [_]u8{0x01} ** 20;
    const key1 = StorageKey{ .address = addr, .slot = 42 };
    const key2 = StorageKey{ .address = addr, .slot = 42 };

    try std.testing.expect(StorageKey.eql(key1, key2));
}
```

### StorageKey equality with different addresses

```zig
test "StorageKey equality with different addresses" {
    const addr1 = [_]u8{0x01} ** 20;
    const addr2 = [_]u8{0x02} ** 20;
    const key1 = StorageKey{ .address = addr1, .slot = 42 };
    const key2 = StorageKey{ .address = addr2, .slot = 42 };

    try std.testing.expect(!StorageKey.eql(key1, key2));
}
```

### StorageKey equality with different slots

```zig
test "StorageKey equality with different slots" {
    const addr = [_]u8{0x01} ** 20;
    const key1 = StorageKey{ .address = addr, .slot = 42 };
    const key2 = StorageKey{ .address = addr, .slot = 43 };

    try std.testing.expect(!StorageKey.eql(key1, key2));
}
```

### StorageKey equality with different addresses and slots

```zig
test "StorageKey equality with different addresses and slots" {
    const addr1 = [_]u8{0x01} ** 20;
    const addr2 = [_]u8{0x02} ** 20;
    const key1 = StorageKey{ .address = addr1, .slot = 42 };
    const key2 = StorageKey{ .address = addr2, .slot = 43 };

    try std.testing.expect(!StorageKey.eql(key1, key2));
}
```

### StorageKey with zero values

```zig
test "StorageKey with zero values" {
    const addr = [_]u8{0x00} ** 20;
    const key1 = StorageKey{ .address = addr, .slot = 0 };
    const key2 = StorageKey{ .address = addr, .slot = 0 };

    try std.testing.expect(StorageKey.eql(key1, key2));
}
```

### StorageKey with maximum u256 slot value

```zig
test "StorageKey with maximum u256 slot value" {
    const addr = [_]u8{0xFF} ** 20;
    const max_slot: u256 = std.math.maxInt(u256);
    const key1 = StorageKey{ .address = addr, .slot = max_slot };
    const key2 = StorageKey{ .address = addr, .slot = max_slot };

    try std.testing.expect(StorageKey.eql(key1, key2));
}
```

### StorageKey hash produces different values for different addresses

```zig
test "StorageKey hash produces different values for different addresses" {
    const addr1 = [_]u8{0x01} ** 20;
    const addr2 = [_]u8{0x02} ** 20;
    const key1 = StorageKey{ .address = addr1, .slot = 0 };
    const key2 = StorageKey{ .address = addr2, .slot = 0 };

    var hasher1 = std.hash.Wyhash.init(0);
    var hasher2 = std.hash.Wyhash.init(0);

    key1.hash(&hasher1);
    key2.hash(&hasher2);

    const hash1 = hasher1.final();
    const hash2 = hasher2.final();

    try std.testing.expect(hash1 != hash2);
}
```

### StorageKey hash produces different values for different slots

```zig
test "StorageKey hash produces different values for different slots" {
    const addr = [_]u8{0x01} ** 20;
    const key1 = StorageKey{ .address = addr, .slot = 0 };
    const key2 = StorageKey{ .address = addr, .slot = 1 };

    var hasher1 = std.hash.Wyhash.init(0);
    var hasher2 = std.hash.Wyhash.init(0);

    key1.hash(&hasher1);
    key2.hash(&hasher2);

    const hash1 = hasher1.final();
    const hash2 = hasher2.final();

    try std.testing.expect(hash1 != hash2);
}
```

### StorageKey hash is consistent across multiple calls

```zig
test "StorageKey hash is consistent across multiple calls" {
    const addr = [_]u8{0xAB} ** 20;
    const key = StorageKey{ .address = addr, .slot = 12345 };

    var hasher1 = std.hash.Wyhash.init(0);
    var hasher2 = std.hash.Wyhash.init(0);

    key.hash(&hasher1);
    key.hash(&hasher2);

    const hash1 = hasher1.final();
    const hash2 = hasher2.final();

    try std.testing.expectEqual(hash1, hash2);
}
```

### StorageKey hash with maximum values

```zig
test "StorageKey hash with maximum values" {
    const addr = [_]u8{0xFF} ** 20;
    const max_slot: u256 = std.math.maxInt(u256);
    const key = StorageKey{ .address = addr, .slot = max_slot };

    var hasher = std.hash.Wyhash.init(0);
    key.hash(&hasher);
    const hash_value = hasher.final();

    // Should not crash and should produce a valid hash
    try std.testing.expect(hash_value != 0 or hash_value == 0);
}
```

### StorageKey hash with minimum values

```zig
test "StorageKey hash with minimum values" {
    const addr = [_]u8{0x00} ** 20;
    const key = StorageKey{ .address = addr, .slot = 0 };

    var hasher = std.hash.Wyhash.init(0);
    key.hash(&hasher);
    const hash_value = hasher.final();

    // Should not crash and should produce a valid hash
    try std.testing.expect(hash_value != 0 or hash_value == 0);
}
```

### StorageKey in AutoHashMap basic operations

```zig
test "StorageKey in AutoHashMap basic operations" {
    var map = std.AutoHashMap(StorageKey, u256).init(std.testing.allocator);
    defer map.deinit();

    const addr = [_]u8{0x42} ** 20;
    const key = StorageKey{ .address = addr, .slot = 100 };
    const value: u256 = 999;

    try map.put(key, value);

    const retrieved = map.get(key);
    try std.testing.expect(retrieved != null);
    try std.testing.expectEqual(value, retrieved.?);
}
```

### StorageKey in AutoHashMap with multiple entries

```zig
test "StorageKey in AutoHashMap with multiple entries" {
    var map = std.AutoHashMap(StorageKey, u256).init(std.testing.allocator);
    defer map.deinit();

    const addr1 = [_]u8{0x11} ** 20;
    const addr2 = [_]u8{0x22} ** 20;
    const addr3 = [_]u8{0x33} ** 20;

    const key1 = StorageKey{ .address = addr1, .slot = 0 };
    const key2 = StorageKey{ .address = addr2, .slot = 1 };
    const key3 = StorageKey{ .address = addr3, .slot = 2 };

    try map.put(key1, 100);
    try map.put(key2, 200);
    try map.put(key3, 300);

    try std.testing.expectEqual(@as(u256, 100), map.get(key1).?);
    try std.testing.expectEqual(@as(u256, 200), map.get(key2).?);
    try std.testing.expectEqual(@as(u256, 300), map.get(key3).?);
}
```

### StorageKey in AutoHashMap overwrites value for same key

```zig
test "StorageKey in AutoHashMap overwrites value for same key" {
    var map = std.AutoHashMap(StorageKey, u256).init(std.testing.allocator);
    defer map.deinit();

    const addr = [_]u8{0x99} ** 20;
    const key = StorageKey{ .address = addr, .slot = 5 };

    try map.put(key, 111);
    try std.testing.expectEqual(@as(u256, 111), map.get(key).?);

    try map.put(key, 222);
    try std.testing.expectEqual(@as(u256, 222), map.get(key).?);
}
```

### StorageKey in AutoHashMap with same address different slots

```zig
test "StorageKey in AutoHashMap with same address different slots" {
    var map = std.AutoHashMap(StorageKey, u256).init(std.testing.allocator);
    defer map.deinit();

    const addr = [_]u8{0xAA} ** 20;

    const key0 = StorageKey{ .address = addr, .slot = 0 };
    const key1 = StorageKey{ .address = addr, .slot = 1 };
    const key2 = StorageKey{ .address = addr, .slot = 2 };

    try map.put(key0, 10);
    try map.put(key1, 20);
    try map.put(key2, 30);

    try std.testing.expectEqual(@as(u256, 10), map.get(key0).?);
    try std.testing.expectEqual(@as(u256, 20), map.get(key1).?);
    try std.testing.expectEqual(@as(u256, 30), map.get(key2).?);
}
```

### StorageKey in AutoHashMap removal

```zig
test "StorageKey in AutoHashMap removal" {
    var map = std.AutoHashMap(StorageKey, u256).init(std.testing.allocator);
    defer map.deinit();

    const addr = [_]u8{0xBB} ** 20;
    const key = StorageKey{ .address = addr, .slot = 77 };

    try map.put(key, 555);
    try std.testing.expect(map.get(key) != null);

    _ = map.remove(key);
    try std.testing.expect(map.get(key) == null);
}
```

### StorageKey in AutoHashMap with large slot numbers

```zig
test "StorageKey in AutoHashMap with large slot numbers" {
    var map = std.AutoHashMap(StorageKey, u256).init(std.testing.allocator);
    defer map.deinit();

    const addr = [_]u8{0xCC} ** 20;
    const large_slot: u256 = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;
    const key = StorageKey{ .address = addr, .slot = large_slot };

    try map.put(key, 12345);
    try std.testing.expectEqual(@as(u256, 12345), map.get(key).?);
}
```

### StorageKey memory layout is predictable

```zig
test "StorageKey memory layout is predictable" {
    const key = StorageKey{
        .address = [_]u8{0x01} ** 20,
        .slot = 42,
    };

    // Verify the struct size (20 bytes address + padding + 32 bytes u256)
    // u256 requires 16-byte alignment, so struct gets padded to 64 bytes
    try std.testing.expectEqual(64, @sizeOf(StorageKey));

    // Verify fields are accessible
    try std.testing.expectEqual(@as(u256, 42), key.slot);
    try std.testing.expectEqual(@as(u8, 0x01), key.address[0]);
    try std.testing.expectEqual(@as(u8, 0x01), key.address[19]);
}
```

### StorageKey creation with various address patterns

```zig
test "StorageKey creation with various address patterns" {
    const zero_addr = [_]u8{0x00} ** 20;
    const max_addr = [_]u8{0xFF} ** 20;
    const pattern_addr = [20]u8{ 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0x10, 0x11, 0x12, 0x13, 0x14 };

    const key1 = StorageKey{ .address = zero_addr, .slot = 0 };
    const key2 = StorageKey{ .address = max_addr, .slot = std.math.maxInt(u256) };
    const key3 = StorageKey{ .address = pattern_addr, .slot = 123456789 };

    try std.testing.expect(StorageKey.eql(key1, key1));
    try std.testing.expect(StorageKey.eql(key2, key2));
    try std.testing.expect(StorageKey.eql(key3, key3));

    try std.testing.expect(!StorageKey.eql(key1, key2));
    try std.testing.expect(!StorageKey.eql(key2, key3));
    try std.testing.expect(!StorageKey.eql(key1, key3));
}
```

### StorageKey slot ordering edge cases

```zig
test "StorageKey slot ordering edge cases" {
    const addr = [_]u8{0x55} ** 20;

    const key_slot_0 = StorageKey{ .address = addr, .slot = 0 };
    const key_slot_1 = StorageKey{ .address = addr, .slot = 1 };
    const key_slot_max_minus_1 = StorageKey{ .address = addr, .slot = std.math.maxInt(u256) - 1 };
    const key_slot_max = StorageKey{ .address = addr, .slot = std.math.maxInt(u256) };

    // Adjacent slots should not be equal
    try std.testing.expect(!StorageKey.eql(key_slot_0, key_slot_1));
    try std.testing.expect(!StorageKey.eql(key_slot_max_minus_1, key_slot_max));

    // Same keys should be equal
    const key_slot_0_dup = StorageKey{ .address = addr, .slot = 0 };
    try std.testing.expect(StorageKey.eql(key_slot_0, key_slot_0_dup));
}
```

### StorageKey address boundary differences

```zig
test "StorageKey address boundary differences" {
    const addr1 = [20]u8{ 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE };
    const addr2 = [20]u8{ 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF };

    const key1 = StorageKey{ .address = addr1, .slot = 0 };
    const key2 = StorageKey{ .address = addr2, .slot = 0 };

    // One bit difference in address should make keys unequal
    try std.testing.expect(!StorageKey.eql(key1, key2));
}
```

### StorageKey hash endianness consistency for slot

```zig
test "StorageKey hash endianness consistency for slot" {
    const addr = [_]u8{0x77} ** 20;
    const slot: u256 = 0x0102030405060708090A0B0C0D0E0F101112131415161718191A1B1C1D1E1F20;
    const key = StorageKey{ .address = addr, .slot = slot };

    // Hash the key
    var hasher = std.hash.Wyhash.init(0);
    key.hash(&hasher);
    const hash_value = hasher.final();

    // Create slot bytes manually in big-endian to verify
    var slot_bytes: [32]u8 = undefined;
    std.mem.writeInt(u256, &slot_bytes, slot, .big);

    // Verify the slot bytes are in big-endian order
    try std.testing.expectEqual(@as(u8, 0x01), slot_bytes[0]);
    try std.testing.expectEqual(@as(u8, 0x20), slot_bytes[31]);

    // Hash should be deterministic
    try std.testing.expect(hash_value != 0 or hash_value == 0);
}
```
