---
title: '[Zig] src/primitives/Permit/Permit.zig'
source: 'src/primitives/Permit/Permit.zig'
---

> Auto-generated from Zig tests in: src/primitives/Permit/Permit.zig

### Permit.init creates permit struct

```zig
test "Permit.init creates permit struct" {
    const owner = [_]u8{0x01} ** 20;
    const spender = [_]u8{0x02} ** 20;

    const permit = Permit.init(owner, spender, 1000, 0, 9999999999);

    try std.testing.expectEqualSlices(u8, &owner, &permit.owner);
    try std.testing.expectEqualSlices(u8, &spender, &permit.spender);
    try std.testing.expectEqual(@as(u256, 1000), permit.value);
    try std.testing.expectEqual(@as(u256, 0), permit.nonce);
    try std.testing.expectEqual(@as(u256, 9999999999), permit.deadline);
}
```

### Permit.equals returns true for identical permits

```zig
test "Permit.equals returns true for identical permits" {
    const owner = [_]u8{0x01} ** 20;
    const spender = [_]u8{0x02} ** 20;

    const permit1 = Permit.init(owner, spender, 1000, 0, 9999999999);
    const permit2 = Permit.init(owner, spender, 1000, 0, 9999999999);

    try std.testing.expect(permit1.equals(permit2));
}
```

### Permit.equals returns false for different permits

```zig
test "Permit.equals returns false for different permits" {
    const owner = [_]u8{0x01} ** 20;
    const spender = [_]u8{0x02} ** 20;

    const permit1 = Permit.init(owner, spender, 1000, 0, 9999999999);
    const permit2 = Permit.init(owner, spender, 2000, 0, 9999999999);

    try std.testing.expect(!permit1.equals(permit2));
}
```

### Permit.isExpired returns false for future deadline

```zig
test "Permit.isExpired returns false for future deadline" {
    const owner = [_]u8{0x01} ** 20;
    const spender = [_]u8{0x02} ** 20;

    const permit = Permit.init(owner, spender, 1000, 0, 9999999999);

    try std.testing.expect(!permit.isExpired(1000000000));
}
```

### Permit.isExpired returns true for past deadline

```zig
test "Permit.isExpired returns true for past deadline" {
    const owner = [_]u8{0x01} ** 20;
    const spender = [_]u8{0x02} ** 20;

    const permit = Permit.init(owner, spender, 1000, 0, 1000000000);

    try std.testing.expect(permit.isExpired(1000000001));
}
```

### Permit.toStructHash returns consistent hash

```zig
test "Permit.toStructHash returns consistent hash" {
    const owner = [_]u8{0x01} ** 20;
    const spender = [_]u8{0x02} ** 20;

    const permit = Permit.init(owner, spender, 1000, 0, 9999999999);

    const hash1 = permit.toStructHash();
    const hash2 = permit.toStructHash();

    try std.testing.expectEqualSlices(u8, &hash1, &hash2);
}
```

### Permit.toStructHash differs for different permits

```zig
test "Permit.toStructHash differs for different permits" {
    const owner = [_]u8{0x01} ** 20;
    const spender = [_]u8{0x02} ** 20;

    const permit1 = Permit.init(owner, spender, 1000, 0, 9999999999);
    const permit2 = Permit.init(owner, spender, 2000, 0, 9999999999);

    const hash1 = permit1.toStructHash();
    const hash2 = permit2.toStructHash();

    try std.testing.expect(!std.mem.eql(u8, &hash1, &hash2));
}
```

### PermitDomain.init creates domain struct

```zig
test "PermitDomain.init creates domain struct" {
    const contract = [_]u8{0x03} ** 20;

    const domain = PermitDomain.init("Test Token", "1", 1, contract);

    try std.testing.expectEqualStrings("Test Token", domain.name);
    try std.testing.expectEqualStrings("1", domain.version);
    try std.testing.expectEqual(@as(u64, 1), domain.chain_id);
    try std.testing.expectEqualSlices(u8, &contract, &domain.verifying_contract);
}
```

### PermitDomain.toSeparator returns consistent hash

```zig
test "PermitDomain.toSeparator returns consistent hash" {
    const contract = [_]u8{0x03} ** 20;

    const domain = PermitDomain.init("Test Token", "1", 1, contract);

    const sep1 = domain.toSeparator();
    const sep2 = domain.toSeparator();

    try std.testing.expectEqualSlices(u8, &sep1, &sep2);
}
```

### PermitDomain.toSeparator differs for different domains

```zig
test "PermitDomain.toSeparator differs for different domains" {
    const contract = [_]u8{0x03} ** 20;

    const domain1 = PermitDomain.init("Test Token", "1", 1, contract);
    const domain2 = PermitDomain.init("Other Token", "1", 1, contract);

    const sep1 = domain1.toSeparator();
    const sep2 = domain2.toSeparator();

    try std.testing.expect(!std.mem.eql(u8, &sep1, &sep2));
}
```

### computeTypedDataHash combines domain and struct hash

```zig
test "computeTypedDataHash combines domain and struct hash" {
    const domain_sep = [_]u8{0xaa} ** 32;
    const struct_hash = [_]u8{0xbb} ** 32;

    const hash = computeTypedDataHash(domain_sep, struct_hash);

    // Verify it's a valid 32-byte hash
    try std.testing.expectEqual(@as(usize, 32), hash.len);

    // Verify same inputs produce same output
    const hash2 = computeTypedDataHash(domain_sep, struct_hash);
    try std.testing.expectEqualSlices(u8, &hash, &hash2);
}
```

### DOMAIN_TYPEHASH is correctly computed

```zig
test "DOMAIN_TYPEHASH is correctly computed" {
    // Known value from EIP-712 spec
    var expected: [32]u8 = undefined;
    Keccak256.hash("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)", &expected, .{});

    try std.testing.expectEqualSlices(u8, &expected, &DOMAIN_TYPEHASH);
}
```

### PERMIT_TYPEHASH is correctly computed

```zig
test "PERMIT_TYPEHASH is correctly computed" {
    // Known value from EIP-2612 spec
    var expected: [32]u8 = undefined;
    Keccak256.hash("Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)", &expected, .{});

    try std.testing.expectEqualSlices(u8, &expected, &PERMIT_TYPEHASH);
}
```

### KnownTokens have valid configurations

```zig
test "KnownTokens have valid configurations" {
    // USDC mainnet
    try std.testing.expectEqualStrings("USD Coin", KnownTokens.USDC_MAINNET.name);
    try std.testing.expectEqual(@as(u64, 1), KnownTokens.USDC_MAINNET.chain_id);

    // DAI mainnet
    try std.testing.expectEqualStrings("Dai Stablecoin", KnownTokens.DAI_MAINNET.name);
    try std.testing.expectEqual(@as(u64, 1), KnownTokens.DAI_MAINNET.chain_id);
}
```

### Permit complete workflow

```zig
test "Permit complete workflow" {
    const owner = [_]u8{0x01} ** 20;
    const spender = [_]u8{0x02} ** 20;
    const contract = [_]u8{0x03} ** 20;

    // Create permit
    const permit = Permit.init(owner, spender, 1000, 0, 9999999999);

    // Create domain
    const domain = PermitDomain.init("Test Token", "1", 1, contract);

    // Compute hashes
    const struct_hash = permit.toStructHash();
    const domain_sep = domain.toSeparator();
    const typed_data_hash = computeTypedDataHash(domain_sep, struct_hash);

    // Verify hash is 32 bytes
    try std.testing.expectEqual(@as(usize, 32), typed_data_hash.len);

    // Verify permit is not expired
    try std.testing.expect(!permit.isExpired(1000000000));
}
```

### Permit.hash computes correct EIP-712 hash

```zig
test "Permit.hash computes correct EIP-712 hash" {
    const owner = [_]u8{0x01} ** 20;
    const spender = [_]u8{0x02} ** 20;
    const contract = [_]u8{0x03} ** 20;

    const permit = Permit.init(owner, spender, 1000, 0, 9999999999);
    const domain = PermitDomain.init("Test Token", "1", 1, contract);

    // hash() should equal computeTypedDataHash(domain.toSeparator(), permit.toStructHash())
    const hash1 = permit.hash(domain);
    const hash2 = computeTypedDataHash(domain.toSeparator(), permit.toStructHash());

    try std.testing.expectEqualSlices(u8, &hash1, &hash2);
}
```

### Permit.hash differs for different domains

```zig
test "Permit.hash differs for different domains" {
    const owner = [_]u8{0x01} ** 20;
    const spender = [_]u8{0x02} ** 20;
    const contract = [_]u8{0x03} ** 20;

    const permit = Permit.init(owner, spender, 1000, 0, 9999999999);
    const domain1 = PermitDomain.init("Token A", "1", 1, contract);
    const domain2 = PermitDomain.init("Token B", "1", 1, contract);

    const hash1 = permit.hash(domain1);
    const hash2 = permit.hash(domain2);

    try std.testing.expect(!std.mem.eql(u8, &hash1, &hash2));
}
```

### Permit.hash differs for different chain IDs

```zig
test "Permit.hash differs for different chain IDs" {
    const owner = [_]u8{0x01} ** 20;
    const spender = [_]u8{0x02} ** 20;
    const contract = [_]u8{0x03} ** 20;

    const permit = Permit.init(owner, spender, 1000, 0, 9999999999);
    const domain1 = PermitDomain.init("Token", "1", 1, contract); // Mainnet
    const domain2 = PermitDomain.init("Token", "1", 137, contract); // Polygon

    const hash1 = permit.hash(domain1);
    const hash2 = permit.hash(domain2);

    try std.testing.expect(!std.mem.eql(u8, &hash1, &hash2));
}
```

### Permit.toTypedData returns correct structure

```zig
test "Permit.toTypedData returns correct structure" {
    const owner = [_]u8{0x01} ** 20;
    const spender = [_]u8{0x02} ** 20;
    const contract = [_]u8{0x03} ** 20;

    const permit = Permit.init(owner, spender, 1000, 0, 9999999999);
    const domain = PermitDomain.init("Test Token", "1", 1, contract);

    const typed_data = permit.toTypedData(domain);

    try std.testing.expectEqualStrings("Permit", typed_data.primary_type);
    try std.testing.expectEqualStrings("Test Token", typed_data.domain.name);
    try std.testing.expect(typed_data.message.equals(permit));
    try std.testing.expectEqual(@as(usize, 5), typed_data.types.len);
}
```

### PermitTypedData.hash equals Permit.hash

```zig
test "PermitTypedData.hash equals Permit.hash" {
    const owner = [_]u8{0x01} ** 20;
    const spender = [_]u8{0x02} ** 20;
    const contract = [_]u8{0x03} ** 20;

    const permit = Permit.init(owner, spender, 1000, 0, 9999999999);
    const domain = PermitDomain.init("Test Token", "1", 1, contract);

    const typed_data = permit.toTypedData(domain);
    const hash1 = typed_data.hash();
    const hash2 = permit.hash(domain);

    try std.testing.expectEqualSlices(u8, &hash1, &hash2);
}
```

### KnownTokens UNI has valid configuration

```zig
test "KnownTokens UNI has valid configuration" {
    try std.testing.expectEqualStrings("Uniswap", KnownTokens.UNI_MAINNET.name);
    try std.testing.expectEqualStrings("1", KnownTokens.UNI_MAINNET.version);
    try std.testing.expectEqual(@as(u64, 1), KnownTokens.UNI_MAINNET.chain_id);
}
```

### KnownTokens USDT has valid configuration

```zig
test "KnownTokens USDT has valid configuration" {
    try std.testing.expectEqualStrings("Tether USD", KnownTokens.USDT_MAINNET.name);
    try std.testing.expectEqual(@as(u64, 1), KnownTokens.USDT_MAINNET.chain_id);
}
```

### KnownTokens WETH has valid configuration

```zig
test "KnownTokens WETH has valid configuration" {
    try std.testing.expectEqualStrings("Wrapped Ether", KnownTokens.WETH_MAINNET.name);
    try std.testing.expectEqual(@as(u64, 1), KnownTokens.WETH_MAINNET.chain_id);
}
```

### KnownTokens USDC_POLYGON has correct chain ID

```zig
test "KnownTokens USDC_POLYGON has correct chain ID" {
    try std.testing.expectEqualStrings("USD Coin", KnownTokens.USDC_POLYGON.name);
    try std.testing.expectEqual(@as(u64, 137), KnownTokens.USDC_POLYGON.chain_id);
}
```

### KnownTokens USDC_ARBITRUM has correct chain ID

```zig
test "KnownTokens USDC_ARBITRUM has correct chain ID" {
    try std.testing.expectEqualStrings("USD Coin", KnownTokens.USDC_ARBITRUM.name);
    try std.testing.expectEqual(@as(u64, 42161), KnownTokens.USDC_ARBITRUM.chain_id);
}
```

### Permit.hash with known USDC domain produces deterministic result

```zig
test "Permit.hash with known USDC domain produces deterministic result" {
    // Known test vector: permit for USDC mainnet
    // Owner: 0x7E5F4552091A69125d5DfCb7b8C2659029395Bdf (address from private key = 1)
    const owner = [_]u8{ 0x7e, 0x5f, 0x45, 0x52, 0x09, 0x1a, 0x69, 0x12, 0x5d, 0x5d, 0xfc, 0xb7, 0xb8, 0xc2, 0x65, 0x90, 0x29, 0x39, 0x5b, 0xdf };
    const spender = [_]u8{ 0x12, 0x34, 0x56, 0x78, 0x90, 0x12, 0x34, 0x56, 0x78, 0x90, 0x12, 0x34, 0x56, 0x78, 0x90, 0x12, 0x34, 0x56, 0x78, 0x90 };

    const permit = Permit.init(owner, spender, 1000000, 0, 1234567890);

    // Use USDC mainnet domain
    const hash1 = permit.hash(KnownTokens.USDC_MAINNET);
    const hash2 = permit.hash(KnownTokens.USDC_MAINNET);

    // Same inputs should produce same hash
    try std.testing.expectEqualSlices(u8, &hash1, &hash2);

    // Hash should be 32 bytes
    try std.testing.expectEqual(@as(usize, 32), hash1.len);
}
```

### different contracts produce different domain separators

```zig
test "different contracts produce different domain separators" {
    const usdc_sep = KnownTokens.USDC_MAINNET.toSeparator();
    const dai_sep = KnownTokens.DAI_MAINNET.toSeparator();
    const uni_sep = KnownTokens.UNI_MAINNET.toSeparator();

    try std.testing.expect(!std.mem.eql(u8, &usdc_sep, &dai_sep));
    try std.testing.expect(!std.mem.eql(u8, &usdc_sep, &uni_sep));
    try std.testing.expect(!std.mem.eql(u8, &dai_sep, &uni_sep));
}
```

### Permit.from alias works same as init

```zig
test "Permit.from alias works same as init" {
    const owner = [_]u8{0x01} ** 20;
    const spender = [_]u8{0x02} ** 20;

    const permit1 = Permit.init(owner, spender, 1000, 0, 9999999999);
    const permit2 = Permit.from(owner, spender, 1000, 0, 9999999999);

    try std.testing.expect(permit1.equals(permit2));
}
```

### PermitDetails.init creates struct

```zig
test "PermitDetails.init creates struct" {
    const token = [_]u8{0x01} ** 20;

    const details = PermitDetails.init(token, 1000, 9999999999, 0);

    try std.testing.expectEqualSlices(u8, &token, &details.token);
    try std.testing.expectEqual(@as(u256, 1000), details.amount);
    try std.testing.expectEqual(@as(u256, 9999999999), details.expiration);
    try std.testing.expectEqual(@as(u256, 0), details.nonce);
}
```

### PermitDetails.equals returns true for identical

```zig
test "PermitDetails.equals returns true for identical" {
    const token = [_]u8{0x01} ** 20;

    const d1 = PermitDetails.init(token, 1000, 9999999999, 0);
    const d2 = PermitDetails.init(token, 1000, 9999999999, 0);

    try std.testing.expect(d1.equals(d2));
}
```

### PermitDetails.equals returns false for different

```zig
test "PermitDetails.equals returns false for different" {
    const token = [_]u8{0x01} ** 20;

    const d1 = PermitDetails.init(token, 1000, 9999999999, 0);
    const d2 = PermitDetails.init(token, 2000, 9999999999, 0);

    try std.testing.expect(!d1.equals(d2));
}
```

### PermitDetails.isExpired

```zig
test "PermitDetails.isExpired" {
    const token = [_]u8{0x01} ** 20;
    const details = PermitDetails.init(token, 1000, 1000000000, 0);

    try std.testing.expect(!details.isExpired(500000000));
    try std.testing.expect(details.isExpired(1000000001));
}
```

### PermitDetails.toStructHash is deterministic

```zig
test "PermitDetails.toStructHash is deterministic" {
    const token = [_]u8{0x01} ** 20;
    const details = PermitDetails.init(token, 1000, 9999999999, 0);

    const hash1 = details.toStructHash();
    const hash2 = details.toStructHash();

    try std.testing.expectEqualSlices(u8, &hash1, &hash2);
}
```

### PermitSingle.init creates struct

```zig
test "PermitSingle.init creates struct" {
    const token = [_]u8{0x01} ** 20;
    const spender = [_]u8{0x02} ** 20;

    const details = PermitDetails.init(token, 1000, 9999999999, 0);
    const permit = PermitSingle.init(details, spender, 9999999999);

    try std.testing.expect(permit.details.equals(details));
    try std.testing.expectEqualSlices(u8, &spender, &permit.spender);
    try std.testing.expectEqual(@as(u256, 9999999999), permit.sigDeadline);
}
```

### PermitSingle.equals

```zig
test "PermitSingle.equals" {
    const token = [_]u8{0x01} ** 20;
    const spender = [_]u8{0x02} ** 20;

    const details = PermitDetails.init(token, 1000, 9999999999, 0);
    const p1 = PermitSingle.init(details, spender, 9999999999);
    const p2 = PermitSingle.init(details, spender, 9999999999);

    try std.testing.expect(p1.equals(p2));
}
```

### PermitSingle.toStructHash is deterministic

```zig
test "PermitSingle.toStructHash is deterministic" {
    const token = [_]u8{0x01} ** 20;
    const spender = [_]u8{0x02} ** 20;

    const details = PermitDetails.init(token, 1000, 9999999999, 0);
    const permit = PermitSingle.init(details, spender, 9999999999);

    const hash1 = permit.toStructHash();
    const hash2 = permit.toStructHash();

    try std.testing.expectEqualSlices(u8, &hash1, &hash2);
}
```

### PermitSingle.hash with domain

```zig
test "PermitSingle.hash with domain" {
    const token = [_]u8{0x01} ** 20;
    const spender = [_]u8{0x02} ** 20;

    const details = PermitDetails.init(token, 1000, 9999999999, 0);
    const permit = PermitSingle.init(details, spender, 9999999999);
    const domain = Permit2Domain.init(1, Permit2Contracts.MAINNET);

    const hash1 = permit.hash(domain);
    const hash2 = permit.hash(domain);

    try std.testing.expectEqualSlices(u8, &hash1, &hash2);
}
```

### PermitBatch.init creates struct

```zig
test "PermitBatch.init creates struct" {
    const token1 = [_]u8{0x01} ** 20;
    const token2 = [_]u8{0x02} ** 20;
    const spender = [_]u8{0x03} ** 20;

    const details_arr = [_]PermitDetails{
        PermitDetails.init(token1, 1000, 9999999999, 0),
        PermitDetails.init(token2, 2000, 9999999999, 1),
    };

    const batch = PermitBatch.init(&details_arr, spender, 9999999999);

    try std.testing.expectEqual(@as(usize, 2), batch.details.len);
    try std.testing.expectEqualSlices(u8, &spender, &batch.spender);
}
```

### PermitBatch.equals

```zig
test "PermitBatch.equals" {
    const token1 = [_]u8{0x01} ** 20;
    const spender = [_]u8{0x03} ** 20;

    const details_arr = [_]PermitDetails{
        PermitDetails.init(token1, 1000, 9999999999, 0),
    };

    const b1 = PermitBatch.init(&details_arr, spender, 9999999999);
    const b2 = PermitBatch.init(&details_arr, spender, 9999999999);

    try std.testing.expect(b1.equals(b2));
}
```

### PermitBatch.toStructHash is deterministic

```zig
test "PermitBatch.toStructHash is deterministic" {
    const allocator = std.testing.allocator;
    const token1 = [_]u8{0x01} ** 20;
    const spender = [_]u8{0x03} ** 20;

    const details_arr = [_]PermitDetails{
        PermitDetails.init(token1, 1000, 9999999999, 0),
    };

    const batch = PermitBatch.init(&details_arr, spender, 9999999999);

    const hash1 = try batch.toStructHash(allocator);
    const hash2 = try batch.toStructHash(allocator);

    try std.testing.expectEqualSlices(u8, &hash1, &hash2);
}
```

### PermitBatch.hash with domain

```zig
test "PermitBatch.hash with domain" {
    const allocator = std.testing.allocator;
    const token1 = [_]u8{0x01} ** 20;
    const token2 = [_]u8{0x02} ** 20;
    const spender = [_]u8{0x03} ** 20;

    const details_arr = [_]PermitDetails{
        PermitDetails.init(token1, 1000, 9999999999, 0),
        PermitDetails.init(token2, 2000, 9999999999, 1),
    };

    const batch = PermitBatch.init(&details_arr, spender, 9999999999);
    const domain = Permit2Domain.init(1, Permit2Contracts.MAINNET);

    const hash1 = try batch.hash(domain, allocator);
    const hash2 = try batch.hash(domain, allocator);

    try std.testing.expectEqualSlices(u8, &hash1, &hash2);
}
```

### Permit2Domain.toSeparator is deterministic

```zig
test "Permit2Domain.toSeparator is deterministic" {
    const domain = Permit2Domain.init(1, Permit2Contracts.MAINNET);

    const sep1 = domain.toSeparator();
    const sep2 = domain.toSeparator();

    try std.testing.expectEqualSlices(u8, &sep1, &sep2);
}
```

### Permit2Domain differs for different chains

```zig
test "Permit2Domain differs for different chains" {
    const domain1 = Permit2Domain.init(1, Permit2Contracts.MAINNET);
    const domain2 = Permit2Domain.init(137, Permit2Contracts.POLYGON);

    const sep1 = domain1.toSeparator();
    const sep2 = domain2.toSeparator();

    try std.testing.expect(!std.mem.eql(u8, &sep1, &sep2));
}
```

### PERMIT2_DOMAIN_TYPEHASH is correctly computed

```zig
test "PERMIT2_DOMAIN_TYPEHASH is correctly computed" {
    var expected: [32]u8 = undefined;
    Keccak256.hash("EIP712Domain(string name,uint256 chainId,address verifyingContract)", &expected, .{});

    try std.testing.expectEqualSlices(u8, &expected, &PERMIT2_DOMAIN_TYPEHASH);
}
```

### PERMIT_DETAILS_TYPEHASH is correctly computed

```zig
test "PERMIT_DETAILS_TYPEHASH is correctly computed" {
    var expected: [32]u8 = undefined;
    Keccak256.hash("PermitDetails(address token,uint160 amount,uint48 expiration,uint48 nonce)", &expected, .{});

    try std.testing.expectEqualSlices(u8, &expected, &PERMIT_DETAILS_TYPEHASH);
}
```

### PERMIT_SINGLE_TYPEHASH is correctly computed

```zig
test "PERMIT_SINGLE_TYPEHASH is correctly computed" {
    var expected: [32]u8 = undefined;
    Keccak256.hash("PermitSingle(PermitDetails details,address spender,uint256 sigDeadline)PermitDetails(address token,uint160 amount,uint48 expiration,uint48 nonce)", &expected, .{});

    try std.testing.expectEqualSlices(u8, &expected, &PERMIT_SINGLE_TYPEHASH);
}
```

### PERMIT_BATCH_TYPEHASH is correctly computed

```zig
test "PERMIT_BATCH_TYPEHASH is correctly computed" {
    var expected: [32]u8 = undefined;
    Keccak256.hash("PermitBatch(PermitDetails[] details,address spender,uint256 sigDeadline)PermitDetails(address token,uint160 amount,uint48 expiration,uint48 nonce)", &expected, .{});

    try std.testing.expectEqualSlices(u8, &expected, &PERMIT_BATCH_TYPEHASH);
}
```

### Permit2Contracts has correct mainnet address

```zig
test "Permit2Contracts has correct mainnet address" {
    // 0x000000000022D473030F116dDEE9F6B43aC78BA3
    const expected = [_]u8{
        0x00, 0x00, 0x00, 0x00, 0x00, 0x22, 0xD4, 0x73,
        0x03, 0x0F, 0x11, 0x6d, 0xDE, 0xE9, 0xF6, 0xB4,
        0x3a, 0xC7, 0x8B, 0xa3,
    };
    try std.testing.expectEqualSlices(u8, &expected, &Permit2Contracts.MAINNET);
}
```

### PermitSingle complete workflow

```zig
test "PermitSingle complete workflow" {
    const token = [_]u8{0xA0} ** 20;
    const spender = [_]u8{0xB0} ** 20;

    // Create permit
    const details = PermitDetails.init(token, 1000000, 9999999999, 0);
    const permit = PermitSingle.init(details, spender, 9999999999);

    // Create domain
    const domain = Permit2Domain.init(1, Permit2Contracts.MAINNET);

    // Compute hash
    const typed_data_hash = permit.hash(domain);

    // Verify hash is 32 bytes and not all zeros
    try std.testing.expectEqual(@as(usize, 32), typed_data_hash.len);
    const zero_hash = [_]u8{0} ** 32;
    try std.testing.expect(!std.mem.eql(u8, &typed_data_hash, &zero_hash));
}
```

### PermitBatch complete workflow

```zig
test "PermitBatch complete workflow" {
    const allocator = std.testing.allocator;
    const token1 = [_]u8{0xA0} ** 20;
    const token2 = [_]u8{0xA1} ** 20;
    const token3 = [_]u8{0xA2} ** 20;
    const spender = [_]u8{0xB0} ** 20;

    // Create permit with multiple tokens
    const details_arr = [_]PermitDetails{
        PermitDetails.init(token1, 1000000, 9999999999, 0),
        PermitDetails.init(token2, 2000000, 9999999999, 1),
        PermitDetails.init(token3, 3000000, 9999999999, 2),
    };

    const batch = PermitBatch.init(&details_arr, spender, 9999999999);

    // Create domain
    const domain = Permit2Domain.init(1, Permit2Contracts.MAINNET);

    // Compute hash
    const typed_data_hash = try batch.hash(domain, allocator);

    // Verify hash is 32 bytes and not all zeros
    try std.testing.expectEqual(@as(usize, 32), typed_data_hash.len);
    const zero_hash = [_]u8{0} ** 32;
    try std.testing.expect(!std.mem.eql(u8, &typed_data_hash, &zero_hash));
}
```

### PermitSingle hash differs for different spenders

```zig
test "PermitSingle hash differs for different spenders" {
    const token = [_]u8{0x01} ** 20;
    const spender1 = [_]u8{0x02} ** 20;
    const spender2 = [_]u8{0x03} ** 20;

    const details = PermitDetails.init(token, 1000, 9999999999, 0);
    const permit1 = PermitSingle.init(details, spender1, 9999999999);
    const permit2 = PermitSingle.init(details, spender2, 9999999999);

    const domain = Permit2Domain.init(1, Permit2Contracts.MAINNET);

    const hash1 = permit1.hash(domain);
    const hash2 = permit2.hash(domain);

    try std.testing.expect(!std.mem.eql(u8, &hash1, &hash2));
}
```

### PermitSingle.toTypedData returns correct structure

```zig
test "PermitSingle.toTypedData returns correct structure" {
    const token = [_]u8{0x01} ** 20;
    const spender = [_]u8{0x02} ** 20;

    const details = PermitDetails.init(token, 1000, 9999999999, 0);
    const permit = PermitSingle.init(details, spender, 9999999999);
    const domain = Permit2Domain.init(1, Permit2Contracts.MAINNET);

    const typed_data = permit.toTypedData(domain);

    try std.testing.expectEqualStrings("PermitSingle", typed_data.primary_type);
    try std.testing.expectEqualStrings("Permit2", typed_data.domain.name);
    try std.testing.expect(typed_data.message.equals(permit));
}
```
