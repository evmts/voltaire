---
title: '[Zig] src/primitives/TokenBalance/TokenBalance.zig'
source: 'src/primitives/TokenBalance/TokenBalance.zig'
---

> Auto-generated from Zig tests in: src/primitives/TokenBalance/TokenBalance.zig

### TokenBalance.from creates balance from u256

```zig
test "TokenBalance.from creates balance from u256" {
    const balance = from(1000000);
    try std.testing.expectEqual(@as(u256, 1000000), balance);
}
```

### TokenBalance.from handles zero

```zig
test "TokenBalance.from handles zero" {
    const balance = from(0);
    try std.testing.expectEqual(@as(u256, 0), balance);
}
```

### TokenBalance.from handles max u256

```zig
test "TokenBalance.from handles max u256" {
    const balance = from(MAX);
    try std.testing.expectEqual(MAX, balance);
}
```

### TokenBalance.fromNumber creates balance from u64

```zig
test "TokenBalance.fromNumber creates balance from u64" {
    const balance = fromNumber(12345);
    try std.testing.expectEqual(@as(u256, 12345), balance);
}
```

### TokenBalance.fromHex parses hex with 0x prefix

```zig
test "TokenBalance.fromHex parses hex with 0x prefix" {
    const balance = try fromHex("0xf4240"); // 1000000
    try std.testing.expectEqual(@as(u256, 1000000), balance);
}
```

### TokenBalance.fromHex parses hex without prefix

```zig
test "TokenBalance.fromHex parses hex without prefix" {
    const balance = try fromHex("ff");
    try std.testing.expectEqual(@as(u256, 255), balance);
}
```

### TokenBalance.fromHex returns error for invalid hex

```zig
test "TokenBalance.fromHex returns error for invalid hex" {
    const result = fromHex("0xgg");
    try std.testing.expectError(error.InvalidHexCharacter, result);
}
```

### TokenBalance.equals returns true for same value

```zig
test "TokenBalance.equals returns true for same value" {
    const a = from(1000000);
    const b = from(1000000);
    try std.testing.expect(equals(a, b));
}
```

### TokenBalance.equals returns false for different values

```zig
test "TokenBalance.equals returns false for different values" {
    const a = from(1000000);
    const b = from(2000000);
    try std.testing.expect(!equals(a, b));
}
```

### TokenBalance.compare returns correct ordering

```zig
test "TokenBalance.compare returns correct ordering" {
    try std.testing.expectEqual(@as(i8, -1), compare(from(1), from(2)));
    try std.testing.expectEqual(@as(i8, 0), compare(from(42), from(42)));
    try std.testing.expectEqual(@as(i8, 1), compare(from(100), from(50)));
}
```

### TokenBalance.toNumber converts to u64

```zig
test "TokenBalance.toNumber converts to u64" {
    const balance = from(42);
    try std.testing.expectEqual(@as(u64, 42), toNumber(balance));
}
```

### TokenBalance.toBigInt returns u256

```zig
test "TokenBalance.toBigInt returns u256" {
    const balance = from(42);
    try std.testing.expectEqual(@as(u256, 42), toBigInt(balance));
}
```

### TokenBalance.toHex converts to hex string

```zig
test "TokenBalance.toHex converts to hex string" {
    const balance = from(1000000); // 0xf4240
    const hex = toHex(balance);
    try std.testing.expectEqualStrings("0x00000000000000000000000000000000000000000000000000000000000f4240", &hex);
}
```

### TokenBalance.toBaseUnit formats with decimals

```zig
test "TokenBalance.toBaseUnit formats with decimals" {
    const allocator = std.testing.allocator;

    // 1 USDC = 1000000 base units (6 decimals)
    const result = try toBaseUnit(allocator, from(1000000), 6);
    defer allocator.free(result);
    try std.testing.expectEqualStrings("1.0", result);
}
```

### TokenBalance.toBaseUnit formats 1.5 ETH

```zig
test "TokenBalance.toBaseUnit formats 1.5 ETH" {
    const allocator = std.testing.allocator;

    // 1.5 ETH = 1500000000000000000 wei (18 decimals)
    const result = try toBaseUnit(allocator, from(1500000000000000000), 18);
    defer allocator.free(result);
    try std.testing.expectEqualStrings("1.5", result);
}
```

### TokenBalance.toBaseUnit formats zero

```zig
test "TokenBalance.toBaseUnit formats zero" {
    const allocator = std.testing.allocator;

    const result = try toBaseUnit(allocator, from(0), 18);
    defer allocator.free(result);
    try std.testing.expectEqualStrings("0.0", result);
}
```

### TokenBalance.toBaseUnit formats small fractional

```zig
test "TokenBalance.toBaseUnit formats small fractional" {
    const allocator = std.testing.allocator;

    // 0.000001 ETH = 1000000000000 wei
    const result = try toBaseUnit(allocator, from(1000000000000), 18);
    defer allocator.free(result);
    try std.testing.expectEqualStrings("0.000001", result);
}
```

### TokenBalance.fromBaseUnit parses integer

```zig
test "TokenBalance.fromBaseUnit parses integer" {
    const allocator = std.testing.allocator;

    const result = try fromBaseUnit(allocator, "1", 18);
    try std.testing.expectEqual(@as(u256, 1000000000000000000), result);
}
```

### TokenBalance.fromBaseUnit parses decimal

```zig
test "TokenBalance.fromBaseUnit parses decimal" {
    const allocator = std.testing.allocator;

    const result = try fromBaseUnit(allocator, "1.5", 18);
    try std.testing.expectEqual(@as(u256, 1500000000000000000), result);
}
```

### TokenBalance.fromBaseUnit parses USDC

```zig
test "TokenBalance.fromBaseUnit parses USDC" {
    const allocator = std.testing.allocator;

    const result = try fromBaseUnit(allocator, "1.0", 6);
    try std.testing.expectEqual(@as(u256, 1000000), result);
}
```

### TokenBalance.format is alias for toBaseUnit

```zig
test "TokenBalance.format is alias for toBaseUnit" {
    const allocator = std.testing.allocator;

    const result = try format(allocator, from(1000000), 6);
    defer allocator.free(result);
    try std.testing.expectEqualStrings("1.0", result);
}
```

### TokenBalance.DECIMALS has correct values

```zig
test "TokenBalance.DECIMALS has correct values" {
    try std.testing.expectEqual(@as(u8, 18), DECIMALS.ETH);
    try std.testing.expectEqual(@as(u8, 18), DECIMALS.WETH);
    try std.testing.expectEqual(@as(u8, 6), DECIMALS.USDC);
    try std.testing.expectEqual(@as(u8, 6), DECIMALS.USDT);
    try std.testing.expectEqual(@as(u8, 18), DECIMALS.DAI);
    try std.testing.expectEqual(@as(u8, 8), DECIMALS.WBTC);
}
```

### TokenBalance constants are correct

```zig
test "TokenBalance constants are correct" {
    try std.testing.expectEqual(@as(u256, 0), MIN);
    try std.testing.expectEqual(std.math.maxInt(u256), MAX);
}
```

### TokenBalance.ERC20_SELECTORS are correct

```zig
test "TokenBalance.ERC20_SELECTORS are correct" {
    // balanceOf(address) = 0x70a08231
    try std.testing.expectEqual([4]u8{ 0x70, 0xa0, 0x82, 0x31 }, ERC20_SELECTORS.balanceOf);
    // transfer(address,uint256) = 0xa9059cbb
    try std.testing.expectEqual([4]u8{ 0xa9, 0x05, 0x9c, 0xbb }, ERC20_SELECTORS.transfer);
}
```

### TokenBalance complete workflow

```zig
test "TokenBalance complete workflow" {
    const allocator = std.testing.allocator;

    // Create balance from hex (10 USDC)
    const balance = try fromHex("0x989680"); // 10000000

    // Format for display
    const formatted = try format(allocator, balance, 6);
    defer allocator.free(formatted);
    try std.testing.expectEqualStrings("10.0", formatted);

    // Compare with another balance
    const other = from(5000000); // 5 USDC
    try std.testing.expect(!equals(balance, other));
    try std.testing.expectEqual(@as(i8, 1), compare(balance, other));
}
```
