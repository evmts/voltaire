---
title: '[Zig] src/primitives/License/license.zig'
source: 'src/primitives/License/license.zig'
---

> Auto-generated from Zig tests in: src/primitives/License/license.zig

### License.from creates license

```zig
test "License.from creates license" {
    const license = from("MIT");
    try std.testing.expectEqualStrings("MIT", license);
}
```

### License.fromCommon creates known licenses

```zig
test "License.fromCommon creates known licenses" {
    try std.testing.expectEqualStrings("MIT", fromCommon(.mit));
    try std.testing.expectEqualStrings("Apache-2.0", fromCommon(.apache_2_0));
    try std.testing.expectEqualStrings("GPL-3.0", fromCommon(.gpl_3_0));
    try std.testing.expectEqualStrings("UNLICENSED", fromCommon(.unlicensed));
}
```

### License.toString converts to string

```zig
test "License.toString converts to string" {
    const license = from("Apache-2.0");
    try std.testing.expectEqualStrings("Apache-2.0", toString(license));
}
```

### License.isOSI detects OSI-approved licenses

```zig
test "License.isOSI detects OSI-approved licenses" {
    try std.testing.expect(isOSI(MIT));
    try std.testing.expect(isOSI(APACHE_2_0));
    try std.testing.expect(isOSI(GPL_3_0));
    try std.testing.expect(isOSI(BSD_3_CLAUSE));
    try std.testing.expect(!isOSI(UNLICENSED));
    try std.testing.expect(!isOSI(BUSL_1_1));
}
```

### License.isCopyleft detects copyleft licenses

```zig
test "License.isCopyleft detects copyleft licenses" {
    try std.testing.expect(isCopyleft(GPL_3_0));
    try std.testing.expect(isCopyleft(LGPL_3_0));
    try std.testing.expect(isCopyleft(AGPL_3_0));
    try std.testing.expect(!isCopyleft(MIT));
    try std.testing.expect(!isCopyleft(APACHE_2_0));
}
```

### License.isPermissive detects permissive licenses

```zig
test "License.isPermissive detects permissive licenses" {
    try std.testing.expect(isPermissive(MIT));
    try std.testing.expect(isPermissive(APACHE_2_0));
    try std.testing.expect(isPermissive(BSD_3_CLAUSE));
    try std.testing.expect(!isPermissive(GPL_3_0));
    try std.testing.expect(!isPermissive(UNLICENSED));
}
```

### License.isMIT

```zig
test "License.isMIT" {
    try std.testing.expect(isMIT(MIT));
    try std.testing.expect(!isMIT(APACHE_2_0));
}
```

### License.isUnlicensed

```zig
test "License.isUnlicensed" {
    try std.testing.expect(isUnlicensed(UNLICENSED));
    try std.testing.expect(!isUnlicensed(MIT));
}
```

### License.isBUSL

```zig
test "License.isBUSL" {
    try std.testing.expect(isBUSL(BUSL_1_1));
    try std.testing.expect(isBUSL("BUSL-1.2"));
    try std.testing.expect(!isBUSL(MIT));
}
```

### License.isValid validates SPDX format

```zig
test "License.isValid validates SPDX format" {
    try std.testing.expect(isValid("MIT"));
    try std.testing.expect(isValid("Apache-2.0"));
    try std.testing.expect(isValid("GPL-3.0-or-later"));
    try std.testing.expect(!isValid(""));
    try std.testing.expect(!isValid("MIT License")); // spaces not allowed
    try std.testing.expect(!isValid("MIT/Apache")); // slash not allowed
}
```

### License.equals compares licenses

```zig
test "License.equals compares licenses" {
    try std.testing.expect(equals(MIT, "MIT"));
    try std.testing.expect(!equals(MIT, APACHE_2_0));
}
```

### License.equalsIgnoreCase case-insensitive comparison

```zig
test "License.equalsIgnoreCase case-insensitive comparison" {
    try std.testing.expect(equalsIgnoreCase("MIT", "mit"));
    try std.testing.expect(equalsIgnoreCase("Apache-2.0", "apache-2.0"));
    try std.testing.expect(!equalsIgnoreCase(MIT, APACHE_2_0));
}
```

### License constants are correct

```zig
test "License constants are correct" {
    try std.testing.expectEqualStrings("MIT", MIT);
    try std.testing.expectEqualStrings("Apache-2.0", APACHE_2_0);
    try std.testing.expectEqualStrings("GPL-3.0", GPL_3_0);
    try std.testing.expectEqualStrings("BSD-3-Clause", BSD_3_CLAUSE);
    try std.testing.expectEqualStrings("UNLICENSED", UNLICENSED);
    try std.testing.expectEqualStrings("BUSL-1.1", BUSL_1_1);
}
```

### License.fromSource parses single-line comment

```zig
test "License.fromSource parses single-line comment" {
    const source1 = "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;";
    try std.testing.expectEqualStrings("MIT", fromSource(source1).?);

    const source2 = "// SPDX-License-Identifier: Apache-2.0\ncontract Foo {}";
    try std.testing.expectEqualStrings("Apache-2.0", fromSource(source2).?);

    const source3 = "//SPDX-License-Identifier: GPL-3.0\n";
    try std.testing.expectEqualStrings("GPL-3.0", fromSource(source3).?);
}
```

### License.fromSource handles whitespace variations

```zig
test "License.fromSource handles whitespace variations" {
    const source1 = "//  SPDX-License-Identifier:  MIT\n";
    try std.testing.expectEqualStrings("MIT", fromSource(source1).?);

    const source2 = "// \t SPDX-License-Identifier:\tUnlicensed\n";
    try std.testing.expect(fromSource(source2) == null); // "Unlicensed" fails isValid (lowercase)

    const source3 = "// SPDX-License-Identifier: UNLICENSED\n";
    try std.testing.expectEqualStrings("UNLICENSED", fromSource(source3).?);
}
```

### License.fromSource returns null for missing identifier

```zig
test "License.fromSource returns null for missing identifier" {
    try std.testing.expect(fromSource("pragma solidity ^0.8.0;") == null);
    try std.testing.expect(fromSource("// Some comment\n") == null);
    try std.testing.expect(fromSource("") == null);
}
```

### License.fromSource finds identifier not on first line

```zig
test "License.fromSource finds identifier not on first line" {
    const source =
        \\// Some header comment
        \\// SPDX-License-Identifier: BSD-3-Clause
        \\pragma solidity ^0.8.0;
    ;
    try std.testing.expectEqualStrings("BSD-3-Clause", fromSource(source).?);
}
```

### License.fromSourceMultiline parses multi-line comment

```zig
test "License.fromSourceMultiline parses multi-line comment" {
    const source1 = "/* SPDX-License-Identifier: MIT */\npragma solidity ^0.8.0;";
    try std.testing.expectEqualStrings("MIT", fromSourceMultiline(source1).?);

    const source2 =
        \\/*
        \\ * SPDX-License-Identifier: Apache-2.0
        \\ */
    ;
    try std.testing.expectEqualStrings("Apache-2.0", fromSourceMultiline(source2).?);
}
```

### License.fromSourceMultiline returns null for missing identifier

```zig
test "License.fromSourceMultiline returns null for missing identifier" {
    try std.testing.expect(fromSourceMultiline("/* Some comment */") == null);
    try std.testing.expect(fromSourceMultiline("pragma solidity ^0.8.0;") == null);
}
```

### License.fromSourceAny tries both styles

```zig
test "License.fromSourceAny tries both styles" {
    const source1 = "// SPDX-License-Identifier: MIT\n";
    try std.testing.expectEqualStrings("MIT", fromSourceAny(source1).?);

    const source2 = "/* SPDX-License-Identifier: GPL-3.0 */";
    try std.testing.expectEqualStrings("GPL-3.0", fromSourceAny(source2).?);

    try std.testing.expect(fromSourceAny("no license here") == null);
}
```

### License.fromSource real Solidity contract

```zig
test "License.fromSource real Solidity contract" {
    const source =
        \\// SPDX-License-Identifier: MIT
        \\pragma solidity ^0.8.19;
        \\
        \\contract SimpleStorage {
        \\    uint256 private value;
        \\
        \\    function set(uint256 _value) external {
        \\        value = _value;
        \\    }
        \\
        \\    function get() external view returns (uint256) {
        \\        return value;
        \\    }
        \\}
    ;
    try std.testing.expectEqualStrings("MIT", fromSource(source).?);
}
```
