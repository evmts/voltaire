---
title: '[Zig] src/primitives/StealthAddress/StealthAddress.zig'
source: 'src/primitives/StealthAddress/StealthAddress.zig'
---

> Auto-generated from Zig tests in: src/primitives/StealthAddress/StealthAddress.zig

### StealthMetaAddress.init creates meta-address

```zig
test "StealthMetaAddress.init creates meta-address" {
    const spending = [_]u8{0x02} ++ [_]u8{0xaa} ** 32;
    const viewing = [_]u8{0x03} ++ [_]u8{0xbb} ** 32;

    const meta = StealthMetaAddress.init(spending, viewing);

    try std.testing.expectEqualSlices(u8, &spending, &meta.spending_pub_key);
    try std.testing.expectEqualSlices(u8, &viewing, &meta.viewing_pub_key);
}
```

### StealthMetaAddress.fromBytes parses 66 bytes

```zig
test "StealthMetaAddress.fromBytes parses 66 bytes" {
    var data: [STEALTH_META_ADDRESS_SIZE]u8 = undefined;
    data[0] = 0x02;
    @memset(data[1..33], 0xaa);
    data[33] = 0x03;
    @memset(data[34..66], 0xbb);

    const meta = try StealthMetaAddress.fromBytes(&data);

    try std.testing.expectEqual(@as(u8, 0x02), meta.spending_pub_key[0]);
    try std.testing.expectEqual(@as(u8, 0x03), meta.viewing_pub_key[0]);
}
```

### StealthMetaAddress.fromBytes rejects wrong length

```zig
test "StealthMetaAddress.fromBytes rejects wrong length" {
    const short_data = [_]u8{0x02} ** 32;
    const result = StealthMetaAddress.fromBytes(&short_data);
    try std.testing.expectError(error.InvalidMetaAddressLength, result);
}
```

### StealthMetaAddress.toBytes returns concatenated keys

```zig
test "StealthMetaAddress.toBytes returns concatenated keys" {
    const spending = [_]u8{0x02} ++ [_]u8{0xaa} ** 32;
    const viewing = [_]u8{0x03} ++ [_]u8{0xbb} ** 32;

    const meta = StealthMetaAddress.init(spending, viewing);
    const bytes = meta.toBytes();

    try std.testing.expectEqualSlices(u8, &spending, bytes[0..33]);
    try std.testing.expectEqualSlices(u8, &viewing, bytes[33..66]);
}
```

### StealthMetaAddress.equals returns true for identical

```zig
test "StealthMetaAddress.equals returns true for identical" {
    const spending = [_]u8{0x02} ++ [_]u8{0xaa} ** 32;
    const viewing = [_]u8{0x03} ++ [_]u8{0xbb} ** 32;

    const meta1 = StealthMetaAddress.init(spending, viewing);
    const meta2 = StealthMetaAddress.init(spending, viewing);

    try std.testing.expect(meta1.equals(meta2));
}
```

### StealthMetaAddress.equals returns false for different

```zig
test "StealthMetaAddress.equals returns false for different" {
    const spending = [_]u8{0x02} ++ [_]u8{0xaa} ** 32;
    const viewing1 = [_]u8{0x03} ++ [_]u8{0xbb} ** 32;
    const viewing2 = [_]u8{0x03} ++ [_]u8{0xcc} ** 32;

    const meta1 = StealthMetaAddress.init(spending, viewing1);
    const meta2 = StealthMetaAddress.init(spending, viewing2);

    try std.testing.expect(!meta1.equals(meta2));
}
```

### StealthMetaAddress.toHex returns hex string

```zig
test "StealthMetaAddress.toHex returns hex string" {
    const spending = [_]u8{0x02} ++ [_]u8{0x00} ** 32;
    const viewing = [_]u8{0x03} ++ [_]u8{0x00} ** 32;

    const meta = StealthMetaAddress.init(spending, viewing);
    const hex = meta.toHex();

    try std.testing.expectEqualStrings("0x", hex[0..2]);
    try std.testing.expectEqual(@as(usize, 2 + 66 * 2), hex.len);
}
```

### StealthAnnouncement.init creates announcement

```zig
test "StealthAnnouncement.init creates announcement" {
    const ephemeral = [_]u8{0x02} ++ [_]u8{0xdd} ** 32;
    const view_tag: u8 = 0x42;
    const stealth = [_]u8{0xee} ** 20;

    const announcement = StealthAnnouncement.init(ephemeral, view_tag, stealth);

    try std.testing.expectEqualSlices(u8, &ephemeral, &announcement.ephemeral_pub_key);
    try std.testing.expectEqual(view_tag, announcement.view_tag);
    try std.testing.expectEqualSlices(u8, &stealth, &announcement.stealth_address);
}
```

### StealthAnnouncement.matchesViewTag returns true for match

```zig
test "StealthAnnouncement.matchesViewTag returns true for match" {
    const ephemeral = [_]u8{0x02} ++ [_]u8{0xdd} ** 32;
    const stealth = [_]u8{0xee} ** 20;

    const announcement = StealthAnnouncement.init(ephemeral, 0x42, stealth);

    try std.testing.expect(announcement.matchesViewTag(0x42));
}
```

### StealthAnnouncement.matchesViewTag returns false for mismatch

```zig
test "StealthAnnouncement.matchesViewTag returns false for mismatch" {
    const ephemeral = [_]u8{0x02} ++ [_]u8{0xdd} ** 32;
    const stealth = [_]u8{0xee} ** 20;

    const announcement = StealthAnnouncement.init(ephemeral, 0x42, stealth);

    try std.testing.expect(!announcement.matchesViewTag(0x43));
}
```

### computeViewTag extracts first byte

```zig
test "computeViewTag extracts first byte" {
    const hash = [_]u8{0xde} ++ [_]u8{0xad} ** 31;
    const view_tag = computeViewTag(hash);

    try std.testing.expectEqual(@as(u8, 0xde), view_tag);
}
```

### compressPublicKey with even y

```zig
test "compressPublicKey with even y" {
    var uncompressed: [UNCOMPRESSED_PUBLIC_KEY_SIZE]u8 = undefined;
    @memset(uncompressed[0..32], 0xaa); // x
    @memset(uncompressed[32..63], 0xbb); // y (most bytes)
    uncompressed[63] = 0x00; // y last byte even

    const compressed = compressPublicKey(uncompressed);

    try std.testing.expectEqual(@as(u8, 0x02), compressed[0]);
    try std.testing.expectEqualSlices(u8, uncompressed[0..32], compressed[1..33]);
}
```

### compressPublicKey with odd y

```zig
test "compressPublicKey with odd y" {
    var uncompressed: [UNCOMPRESSED_PUBLIC_KEY_SIZE]u8 = undefined;
    @memset(uncompressed[0..32], 0xaa); // x
    @memset(uncompressed[32..63], 0xbb); // y (most bytes)
    uncompressed[63] = 0x01; // y last byte odd

    const compressed = compressPublicKey(uncompressed);

    try std.testing.expectEqual(@as(u8, 0x03), compressed[0]);
    try std.testing.expectEqualSlices(u8, uncompressed[0..32], compressed[1..33]);
}
```

### parseAnnouncement parses valid data

```zig
test "parseAnnouncement parses valid data" {
    var data: [54]u8 = undefined;
    data[0] = 0x02;
    @memset(data[1..33], 0xaa);
    data[33] = 0x42; // view tag
    @memset(data[34..54], 0xee);

    const announcement = try parseAnnouncement(&data);

    try std.testing.expectEqual(@as(u8, 0x02), announcement.ephemeral_pub_key[0]);
    try std.testing.expectEqual(@as(u8, 0x42), announcement.view_tag);
    try std.testing.expectEqual(@as(u8, 0xee), announcement.stealth_address[0]);
}
```

### parseAnnouncement rejects short data

```zig
test "parseAnnouncement rejects short data" {
    const short_data = [_]u8{0x02} ** 32;
    const result = parseAnnouncement(&short_data);
    try std.testing.expectError(error.InvalidAnnouncementLength, result);
}
```

### encodeAnnouncement produces parseable output

```zig
test "encodeAnnouncement produces parseable output" {
    const ephemeral = [_]u8{0x02} ++ [_]u8{0xdd} ** 32;
    const stealth = [_]u8{0xee} ** 20;

    const announcement = StealthAnnouncement.init(ephemeral, 0x42, stealth);
    const encoded = encodeAnnouncement(announcement);
    const parsed = try parseAnnouncement(&encoded);

    try std.testing.expectEqualSlices(u8, &announcement.ephemeral_pub_key, &parsed.ephemeral_pub_key);
    try std.testing.expectEqual(announcement.view_tag, parsed.view_tag);
    try std.testing.expectEqualSlices(u8, &announcement.stealth_address, &parsed.stealth_address);
}
```

### isValidCompressedPublicKey accepts valid keys

```zig
test "isValidCompressedPublicKey accepts valid keys" {
    const valid_02 = [_]u8{0x02} ++ [_]u8{0xaa} ** 32;
    const valid_03 = [_]u8{0x03} ++ [_]u8{0xbb} ** 32;

    try std.testing.expect(isValidCompressedPublicKey(&valid_02));
    try std.testing.expect(isValidCompressedPublicKey(&valid_03));
}
```

### isValidCompressedPublicKey rejects invalid keys

```zig
test "isValidCompressedPublicKey rejects invalid keys" {
    const invalid_prefix = [_]u8{0x04} ++ [_]u8{0xaa} ** 32;
    const wrong_length = [_]u8{0x02} ++ [_]u8{0xaa} ** 16;

    try std.testing.expect(!isValidCompressedPublicKey(&invalid_prefix));
    try std.testing.expect(!isValidCompressedPublicKey(&wrong_length));
}
```

### hashSharedSecret produces keccak256 hash

```zig
test "hashSharedSecret produces keccak256 hash" {
    const secret = [_]u8{0xaa} ** 32;
    const hash = hashSharedSecret(&secret);

    // Verify it's a valid 32-byte hash
    try std.testing.expectEqual(@as(usize, 32), hash.len);

    // Same input should produce same output
    const hash2 = hashSharedSecret(&secret);
    try std.testing.expectEqualSlices(u8, &hash, &hash2);
}
```

### constants are correct

```zig
test "constants are correct" {
    try std.testing.expectEqual(@as(usize, 66), STEALTH_META_ADDRESS_SIZE);
    try std.testing.expectEqual(@as(usize, 33), COMPRESSED_PUBLIC_KEY_SIZE);
    try std.testing.expectEqual(@as(usize, 64), UNCOMPRESSED_PUBLIC_KEY_SIZE);
    try std.testing.expectEqual(@as(usize, 32), PRIVATE_KEY_SIZE);
    try std.testing.expectEqual(@as(usize, 1), VIEW_TAG_SIZE);
    try std.testing.expectEqual(@as(u8, 1), SCHEME_ID);
}
```

### StealthAddress complete workflow simulation

```zig
test "StealthAddress complete workflow simulation" {
    // Simulate the stealth address protocol
    // (without actual elliptic curve operations)

    // 1. Recipient creates meta-address
    const spending_key = [_]u8{0x02} ++ [_]u8{0x11} ** 32;
    const viewing_key = [_]u8{0x03} ++ [_]u8{0x22} ** 32;
    const meta = StealthMetaAddress.init(spending_key, viewing_key);

    // 2. Meta-address can be serialized and shared
    const serialized = meta.toBytes();
    const restored = try StealthMetaAddress.fromBytes(&serialized);
    try std.testing.expect(meta.equals(restored));

    // 3. Sender creates announcement
    const ephemeral = [_]u8{0x02} ++ [_]u8{0x33} ** 32;
    const stealth_addr = [_]u8{0x44} ** 20;
    const view_tag: u8 = 0x55;

    const announcement = StealthAnnouncement.init(ephemeral, view_tag, stealth_addr);

    // 4. Announcement can be encoded and parsed
    const encoded = encodeAnnouncement(announcement);
    const parsed = try parseAnnouncement(&encoded);
    try std.testing.expect(announcement.matchesViewTag(parsed.view_tag));

    // 5. Recipient checks view tag first (fast rejection)
    const wrong_tag: u8 = 0x00;
    try std.testing.expect(!announcement.matchesViewTag(wrong_tag));
    try std.testing.expect(announcement.matchesViewTag(view_tag));
}
```
