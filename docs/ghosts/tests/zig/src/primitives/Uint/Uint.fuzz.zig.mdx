---
title: '[Zig] src/primitives/Uint/Uint.fuzz.zig'
source: 'src/primitives/Uint/Uint.fuzz.zig'
---

> Auto-generated from Zig tests in: src/primitives/Uint/Uint.fuzz.zig

### fuzz saturating_mul overflow scenarios

```zig
test "fuzz saturating_mul overflow scenarios" {
    const input = testing.fuzzInput(.{});
    if (input.len < 64) return;

    const a = U256.from_le_bytes(input[0..32]);
    const b = U256.from_le_bytes(input[32..64]);

    const result = a.saturating_mul(b);

    // Property: result never exceeds MAX
    try testing.expect(result.le(U256.MAX));

    // Property: if overflow would occur, result is MAX
    const overflowing = a.overflowing_mul(b);
    if (overflowing.overflow) {
        try testing.expectEqual(U256.MAX, result);
    } else {
        try testing.expectEqual(overflowing.result, result);
    }

    // Zero property
    if (a.is_zero() or b.is_zero()) {
        try testing.expectEqual(U256.ZERO, result);
    }
}
```

### fuzz saturating_pow overflow scenarios

```zig
test "fuzz saturating_pow overflow scenarios" {
    const input = testing.fuzzInput(.{});
    if (input.len < 36) return;

    const base = U256.from_le_bytes(input[0..32]);
    const exp = std.mem.readInt(u32, input[32..36], .little);

    const result = base.saturating_pow(exp);

    // Property: result never exceeds MAX
    try testing.expect(result.le(U256.MAX));

    // Property: if overflow would occur, result is MAX
    const overflowing = base.overflowing_pow(exp);
    if (overflowing.overflow) {
        try testing.expectEqual(U256.MAX, result);
    } else {
        try testing.expectEqual(overflowing.result, result);
    }

    // Exponent 0 always yields 1
    if (exp == 0) {
        try testing.expectEqual(U256.ONE, result);
    }

    // Exponent 1 yields base (unless overflow, but won't with exp=1)
    if (exp == 1) {
        try testing.expectEqual(base, result);
    }
}
```

### fuzz checked_add overflow

```zig
test "fuzz checked_add overflow" {
    const input = testing.fuzzInput(.{});
    if (input.len < 64) return;

    const a = U256.from_le_bytes(input[0..32]);
    const b = U256.from_le_bytes(input[32..64]);

    const result = a.checked_add(b);
    const overflowing = a.overflowing_add(b);

    // Property: checked returns null iff overflow
    if (overflowing.overflow) {
        try testing.expect(result == null);
    } else {
        try testing.expect(result != null);
        try testing.expectEqual(overflowing.result, result.?);
    }
}
```

### fuzz checked_sub underflow

```zig
test "fuzz checked_sub underflow" {
    const input = testing.fuzzInput(.{});
    if (input.len < 64) return;

    const a = U256.from_le_bytes(input[0..32]);
    const b = U256.from_le_bytes(input[32..64]);

    const result = a.checked_sub(b);
    const overflowing = a.overflowing_sub(b);

    // Property: checked returns null iff underflow
    if (overflowing.overflow) {
        try testing.expect(result == null);
    } else {
        try testing.expect(result != null);
        try testing.expectEqual(overflowing.result, result.?);
    }
}
```

### fuzz checked_mul overflow

```zig
test "fuzz checked_mul overflow" {
    const input = testing.fuzzInput(.{});
    if (input.len < 64) return;

    const a = U256.from_le_bytes(input[0..32]);
    const b = U256.from_le_bytes(input[32..64]);

    const result = a.checked_mul(b);
    const overflowing = a.overflowing_mul(b);

    // Property: checked returns null iff overflow
    if (overflowing.overflow) {
        try testing.expect(result == null);
    } else {
        try testing.expect(result != null);
        try testing.expectEqual(overflowing.result, result.?);
    }
}
```

### fuzz checked_div by zero

```zig
test "fuzz checked_div by zero" {
    const input = testing.fuzzInput(.{});
    if (input.len < 32) return;

    const a = U256.from_le_bytes(input[0..32]);

    const result = a.checked_div(U256.ZERO);
    try testing.expect(result == null);
}
```

### fuzz checked_rem by zero

```zig
test "fuzz checked_rem by zero" {
    const input = testing.fuzzInput(.{});
    if (input.len < 32) return;

    const a = U256.from_le_bytes(input[0..32]);

    const result = a.checked_rem(U256.ZERO);
    try testing.expect(result == null);
}
```

### fuzz checked_pow overflow

```zig
test "fuzz checked_pow overflow" {
    const input = testing.fuzzInput(.{});
    if (input.len < 36) return;

    const base = U256.from_le_bytes(input[0..32]);
    const exp = std.mem.readInt(u32, input[32..36], .little);

    const result = base.checked_pow(exp);
    const overflowing = base.overflowing_pow(exp);

    // Property: checked returns null iff overflow
    if (overflowing.overflow) {
        try testing.expect(result == null);
    } else {
        try testing.expect(result != null);
        try testing.expectEqual(overflowing.result, result.?);
    }
}
```

### fuzz checked_log2 zero

```zig
test "fuzz checked_log2 zero" {
    const result = U256.ZERO.checked_log2();
    try testing.expect(result == null);
}
```

### fuzz checked_log2 valid

```zig
test "fuzz checked_log2 valid" {
    const input = testing.fuzzInput(.{});
    if (input.len < 32) return;

    const value = U256.from_le_bytes(input[0..32]);

    const result = value.checked_log2();

    if (value.is_zero()) {
        try testing.expect(result == null);
    } else {
        try testing.expect(result != null);
        const log_val = result.?;
        try testing.expectEqual(value.log2(), log_val);
    }
}
```

### fuzz checked_log10 zero

```zig
test "fuzz checked_log10 zero" {
    const result = U256.ZERO.checked_log10();
    try testing.expect(result == null);
}
```

### fuzz checked_log10 valid

```zig
test "fuzz checked_log10 valid" {
    const input = testing.fuzzInput(.{});
    if (input.len < 32) return;

    const value = U256.from_le_bytes(input[0..32]);

    const result = value.checked_log10();

    if (value.is_zero()) {
        try testing.expect(result == null);
    } else {
        try testing.expect(result != null);
        const log_val = result.?;
        try testing.expectEqual(value.log10(), log_val);
    }
}
```

### fuzz checked_log zero base

```zig
test "fuzz checked_log zero base" {
    const input = testing.fuzzInput(.{});
    if (input.len < 32) return;

    const value = U256.from_le_bytes(input[0..32]);

    const result = value.checked_log(U256.ZERO);
    try testing.expect(result == null);
}
```

### fuzz checked_log unit base

```zig
test "fuzz checked_log unit base" {
    const input = testing.fuzzInput(.{});
    if (input.len < 32) return;

    const value = U256.from_le_bytes(input[0..32]);

    const result = value.checked_log(U256.ONE);
    try testing.expect(result == null);
}
```

### fuzz checked_log valid

```zig
test "fuzz checked_log valid" {
    const input = testing.fuzzInput(.{});
    if (input.len < 64) return;

    const value = U256.from_le_bytes(input[0..32]);
    const base = U256.from_le_bytes(input[32..64]);

    const result = value.checked_log(base);

    if (value.is_zero() or base.is_zero() or base.eq(U256.ONE)) {
        try testing.expect(result == null);
    } else {
        try testing.expect(result != null);
    }
}
```

### fuzz next_power_of_two checked

```zig
test "fuzz next_power_of_two checked" {
    const input = testing.fuzzInput(.{});
    if (input.len < 32) return;

    const value = U256.from_le_bytes(input[0..32]);

    const result = value.next_power_of_two();

    if (result) |pow2| {
        // Property: result is power of two
        try testing.expect(pow2.is_power_of_two());

        // Property: result >= value
        try testing.expect(pow2.ge(value));

        // Property: if value is power of two, result equals value
        if (value.is_power_of_two()) {
            try testing.expectEqual(value, pow2);
        }
    } else {
        // Overflow occurred - value must be > 2^255
        try testing.expect(value.gt(U256.ONE.wrapping_shl(255)));
    }
}
```

### fuzz overflowing_add carry detection

```zig
test "fuzz overflowing_add carry detection" {
    const input = testing.fuzzInput(.{});
    if (input.len < 64) return;

    const a = U256.from_le_bytes(input[0..32]);
    const b = U256.from_le_bytes(input[32..64]);

    const result = a.overflowing_add(b);

    // Property: overflow iff a + b > MAX
    if (!result.overflow) {
        try testing.expect(result.result.ge(a));
        try testing.expect(result.result.ge(b));
    }

    // Property: wrapping_add equals result regardless of overflow
    try testing.expectEqual(result.result, a.wrapping_add(b));
}
```

### fuzz overflowing_sub borrow detection

```zig
test "fuzz overflowing_sub borrow detection" {
    const input = testing.fuzzInput(.{});
    if (input.len < 64) return;

    const a = U256.from_le_bytes(input[0..32]);
    const b = U256.from_le_bytes(input[32..64]);

    const result = a.overflowing_sub(b);

    // Property: overflow iff a < b
    if (!result.overflow) {
        try testing.expect(a.ge(b));
        try testing.expect(result.result.le(a));
    } else {
        try testing.expect(a.lt(b));
    }

    // Property: wrapping_sub equals result regardless of overflow
    try testing.expectEqual(result.result, a.wrapping_sub(b));
}
```

### fuzz overflowing_mul carry detection

```zig
test "fuzz overflowing_mul carry detection" {
    const input = testing.fuzzInput(.{});
    if (input.len < 64) return;

    const a = U256.from_le_bytes(input[0..32]);
    const b = U256.from_le_bytes(input[32..64]);

    const result = a.overflowing_mul(b);

    // Zero multiplication never overflows
    if (a.is_zero() or b.is_zero()) {
        try testing.expect(!result.overflow);
        try testing.expectEqual(U256.ZERO, result.result);
    }

    // Property: if no overflow, result / a == b (if a != 0)
    if (!result.overflow and !a.is_zero()) {
        const div = result.result.div_rem(a);
        try testing.expectEqual(b, div.quotient);
    }
}
```

### fuzz overflowing_pow carry detection

```zig
test "fuzz overflowing_pow carry detection" {
    const input = testing.fuzzInput(.{});
    if (input.len < 36) return;

    const base = U256.from_le_bytes(input[0..32]);
    const exp = std.mem.readInt(u32, input[32..36], .little) % 256; // Limit exp for performance

    const result = base.overflowing_pow(exp);

    // Exponent 0 never overflows, always yields 1
    if (exp == 0) {
        try testing.expect(!result.overflow);
        try testing.expectEqual(U256.ONE, result.result);
    }

    // Exponent 1 never overflows, yields base
    if (exp == 1) {
        try testing.expect(!result.overflow);
        try testing.expectEqual(base, result.result);
    }

    // Base 0 or 1 never overflows
    if (base.is_zero() or base.eq(U256.ONE)) {
        try testing.expect(!result.overflow);
    }
}
```

### fuzz overflowing_neg borrow detection

```zig
test "fuzz overflowing_neg borrow detection" {
    const input = testing.fuzzInput(.{});
    if (input.len < 32) return;

    const value = U256.from_le_bytes(input[0..32]);

    const result = value.overflowing_neg();

    // Property: negation of zero is zero without overflow
    if (value.is_zero()) {
        try testing.expect(!result.overflow);
        try testing.expectEqual(U256.ZERO, result.result);
    } else {
        // Property: negation always overflows for non-zero unsigned
        try testing.expect(result.overflow);
    }

    // Property: result is two's complement
    const added = value.wrapping_add(result.result);
    try testing.expectEqual(U256.ZERO, added);
}
```

### fuzz checked_neg

```zig
test "fuzz checked_neg" {
    const input = testing.fuzzInput(.{});
    if (input.len < 32) return;

    const value = U256.from_le_bytes(input[0..32]);

    const result = value.checked_neg();

    // Property: only succeeds for zero
    if (value.is_zero()) {
        try testing.expect(result != null);
        try testing.expectEqual(U256.ZERO, result.?);
    } else {
        try testing.expect(result == null);
    }
}
```

### fuzz rotate_left properties

```zig
test "fuzz rotate_left properties" {
    const input = testing.fuzzInput(.{});
    if (input.len < 36) return;

    const value = U256.from_le_bytes(input[0..32]);
    const n = std.mem.readInt(u32, input[32..36], .little);

    const rotated = value.rotate_left(n);

    // Property: rotate by 0 is identity
    if (n % 256 == 0) {
        try testing.expectEqual(value, rotated);
    }

    // Property: rotate left by n then right by n returns original
    const back = rotated.rotate_right(n);
    try testing.expectEqual(value, back);

    // Property: rotate by 256 is identity
    const full_rotation = value.rotate_left(256);
    try testing.expectEqual(value, full_rotation);
}
```

### fuzz rotate_right properties

```zig
test "fuzz rotate_right properties" {
    const input = testing.fuzzInput(.{});
    if (input.len < 36) return;

    const value = U256.from_le_bytes(input[0..32]);
    const n = std.mem.readInt(u32, input[32..36], .little);

    const rotated = value.rotate_right(n);

    // Property: rotate by 0 is identity
    if (n % 256 == 0) {
        try testing.expectEqual(value, rotated);
    }

    // Property: rotate right by n then left by n returns original
    const back = rotated.rotate_left(n);
    try testing.expectEqual(value, back);

    // Property: rotate by 256 is identity
    const full_rotation = value.rotate_right(256);
    try testing.expectEqual(value, full_rotation);
}
```

### fuzz rotate_left_right equivalence

```zig
test "fuzz rotate_left_right equivalence" {
    const input = testing.fuzzInput(.{});
    if (input.len < 36) return;

    const value = U256.from_le_bytes(input[0..32]);
    const n = std.mem.readInt(u32, input[32..36], .little) % 256;

    // Property: rotate_left(n) == rotate_right(256 - n)
    const left = value.rotate_left(n);
    const right = value.rotate_right(256 - n);

    try testing.expectEqual(left, right);
}
```

### fuzz get_bit set_bit roundtrip

```zig
test "fuzz get_bit set_bit roundtrip" {
    const input = testing.fuzzInput(.{});
    if (input.len < 33) return;

    const value = U256.from_le_bytes(input[0..32]);
    const bit_index = @as(usize, input[32]);

    if (bit_index >= 256) return;

    const original_bit = value.get_bit(bit_index);

    // Property: setting to current value doesn't change
    const unchanged = value.set_bit(bit_index, original_bit);
    try testing.expectEqual(value, unchanged);

    // Property: flip and flip back returns original
    const flipped = value.set_bit(bit_index, !original_bit);
    const restored = flipped.set_bit(bit_index, original_bit);
    try testing.expectEqual(value, restored);

    // Property: flipped bit has opposite value
    try testing.expectEqual(!original_bit, flipped.get_bit(bit_index));
}
```

### fuzz leading_ones

```zig
test "fuzz leading_ones" {
    const input = testing.fuzzInput(.{});
    if (input.len < 32) return;

    const value = U256.from_le_bytes(input[0..32]);

    const ones = value.leading_ones();

    // Property: leading_ones + leading_zeros <= 256
    const zeros = value.leading_zeros();
    try testing.expect(ones + zeros <= 256);

    // Property: MAX has 256 leading ones
    const max_ones = U256.MAX.leading_ones();
    try testing.expectEqual(@as(u32, 256), max_ones);

    // Property: NOT(value) has leading ones equal to value's leading zeros
    const notted = value.bit_not();
    try testing.expectEqual(zeros, notted.leading_ones());
}
```

### fuzz trailing_ones

```zig
test "fuzz trailing_ones" {
    const input = testing.fuzzInput(.{});
    if (input.len < 32) return;

    const value = U256.from_le_bytes(input[0..32]);

    const ones = value.trailing_ones();

    // Property: MAX has 256 trailing ones
    const max_ones = U256.MAX.trailing_ones();
    try testing.expectEqual(@as(u32, 256), max_ones);

    // Property: ZERO has 0 trailing ones
    const zero_ones = U256.ZERO.trailing_ones();
    try testing.expectEqual(@as(u32, 0), zero_ones);

    // Property: if trailing_ones < 256, bit at position trailing_ones is 0
    if (ones < 256) {
        try testing.expect(!value.get_bit(ones));
    }
}
```

### fuzz reverse_bits involution

```zig
test "fuzz reverse_bits involution" {
    const input = testing.fuzzInput(.{});
    if (input.len < 32) return;

    const value = U256.from_le_bytes(input[0..32]);

    const reversed = value.reverse_bits();
    const restored = reversed.reverse_bits();

    // Property: reversing twice returns original
    try testing.expectEqual(value, restored);

    // Property: ZERO reversed is ZERO
    try testing.expectEqual(U256.ZERO, U256.ZERO.reverse_bits());

    // Property: MAX reversed is MAX
    try testing.expectEqual(U256.MAX, U256.MAX.reverse_bits());
}
```

### fuzz swap_bytes involution

```zig
test "fuzz swap_bytes involution" {
    const input = testing.fuzzInput(.{});
    if (input.len < 32) return;

    const value = U256.from_le_bytes(input[0..32]);

    const swapped = value.swap_bytes();
    const restored = swapped.swap_bytes();

    // Property: swapping twice returns original
    try testing.expectEqual(value, restored);

    // Property: swap_bytes is equivalent to BE/LE conversion
    var be_bytes: [32]u8 = undefined;
    value.to_be_bytes(&be_bytes);
    const from_be = U256.from_le_bytes(&be_bytes);
    try testing.expectEqual(from_be, swapped);
}
```

### fuzz reduce_mod properties

```zig
test "fuzz reduce_mod properties" {
    const input = testing.fuzzInput(.{});
    if (input.len < 64) return;

    const value = U256.from_le_bytes(input[0..32]);
    const modulus = U256.from_le_bytes(input[32..64]);

    if (modulus.is_zero()) return;

    const result = value.reduce_mod(modulus);

    // Property: result < modulus
    try testing.expect(result.lt(modulus));

    // Property: if value < modulus, result == value
    if (value.lt(modulus)) {
        try testing.expectEqual(value, result);
    }

    // Property: reducing again doesn't change result
    try testing.expectEqual(result, result.reduce_mod(modulus));
}
```

### fuzz add_mod properties

```zig
test "fuzz add_mod properties" {
    const input = testing.fuzzInput(.{});
    if (input.len < 96) return;

    const a = U256.from_le_bytes(input[0..32]);
    const b = U256.from_le_bytes(input[32..64]);
    const modulus = U256.from_le_bytes(input[64..96]);

    if (modulus.is_zero()) return;

    const result = a.add_mod(b, modulus);

    // Property: result < modulus
    try testing.expect(result.lt(modulus));

    // Property: commutative
    try testing.expectEqual(result, b.add_mod(a, modulus));

    // Property: identity: (a + 0) mod m = a mod m
    try testing.expectEqual(a.reduce_mod(modulus), a.add_mod(U256.ZERO, modulus));

    // Property: associative: (a + b) + c = a + (b + c) mod m
    if (input.len >= 128) {
        const c = U256.from_le_bytes(input[96..128]);
        const left = result.add_mod(c, modulus);
        const right = a.add_mod(b.add_mod(c, modulus), modulus);
        try testing.expectEqual(left, right);
    }
}
```

### fuzz mul_mod properties

```zig
test "fuzz mul_mod properties" {
    const input = testing.fuzzInput(.{});
    if (input.len < 96) return;

    const a = U256.from_le_bytes(input[0..32]);
    const b = U256.from_le_bytes(input[32..64]);
    const modulus = U256.from_le_bytes(input[64..96]);

    if (modulus.is_zero()) return;

    const result = a.mul_mod(b, modulus);

    // Property: result < modulus
    try testing.expect(result.lt(modulus));

    // Property: commutative
    try testing.expectEqual(result, b.mul_mod(a, modulus));

    // Property: zero property
    try testing.expectEqual(U256.ZERO, a.mul_mod(U256.ZERO, modulus));

    // Property: identity: (a * 1) mod m = a mod m
    try testing.expectEqual(a.reduce_mod(modulus), a.mul_mod(U256.ONE, modulus));
}
```

### fuzz pow_mod properties

```zig
test "fuzz pow_mod properties" {
    const input = testing.fuzzInput(.{});
    if (input.len < 96) return;

    const base = U256.from_le_bytes(input[0..32]);
    const exp = U256.from_le_bytes(input[32..64]);
    const modulus = U256.from_le_bytes(input[64..96]);

    if (modulus.is_zero() or modulus.eq(U256.ONE)) return;

    // Limit exponent size for performance
    const limited_exp = U256.from_u64(@min(exp.to_u64() orelse 255, 100));

    const result = base.pow_mod(limited_exp, modulus);

    // Property: result < modulus
    try testing.expect(result.lt(modulus));

    // Property: base^0 mod m = 1
    if (limited_exp.is_zero()) {
        try testing.expectEqual(U256.ONE, result);
    }

    // Property: base^1 mod m = base mod m
    if (limited_exp.eq(U256.ONE)) {
        try testing.expectEqual(base.reduce_mod(modulus), result);
    }

    // Property: 0^exp mod m = 0 (for exp > 0)
    if (base.is_zero() and !limited_exp.is_zero()) {
        try testing.expectEqual(U256.ZERO, result);
    }
}
```

### fuzz clamp properties

```zig
test "fuzz clamp properties" {
    const input = testing.fuzzInput(.{});
    if (input.len < 96) return;

    const value = U256.from_le_bytes(input[0..32]);
    var min_val = U256.from_le_bytes(input[32..64]);
    var max_val = U256.from_le_bytes(input[64..96]);

    // Ensure min <= max
    if (max_val.lt(min_val)) {
        const tmp = min_val;
        min_val = max_val;
        max_val = tmp;
    }

    const clamped = value.clamp(min_val, max_val);

    // Property: clamped in range [min, max]
    try testing.expect(clamped.ge(min_val));
    try testing.expect(clamped.le(max_val));

    // Property: if value in range, unchanged
    if (value.ge(min_val) and value.le(max_val)) {
        try testing.expectEqual(value, clamped);
    }

    // Property: if value < min, clamped == min
    if (value.lt(min_val)) {
        try testing.expectEqual(min_val, clamped);
    }

    // Property: if value > max, clamped == max
    if (value.gt(max_val)) {
        try testing.expectEqual(max_val, clamped);
    }
}
```

### fuzz abs_diff symmetry

```zig
test "fuzz abs_diff symmetry" {
    const input = testing.fuzzInput(.{});
    if (input.len < 64) return;

    const a = U256.from_le_bytes(input[0..32]);
    const b = U256.from_le_bytes(input[32..64]);

    const diff1 = a.abs_diff(b);
    const diff2 = b.abs_diff(a);

    // Property: symmetric
    try testing.expectEqual(diff1, diff2);

    // Property: abs_diff(a, a) = 0
    try testing.expectEqual(U256.ZERO, a.abs_diff(a));

    // Property: result matches manual calculation
    if (a.ge(b)) {
        try testing.expectEqual(a.wrapping_sub(b), diff1);
    } else {
        try testing.expectEqual(b.wrapping_sub(a), diff1);
    }
}
```

### fuzz div_ceil properties

```zig
test "fuzz div_ceil properties" {
    const input = testing.fuzzInput(.{});
    if (input.len < 64) return;

    const a = U256.from_le_bytes(input[0..32]);
    const b = U256.from_le_bytes(input[32..64]);

    if (b.is_zero()) return;

    const result = a.div_ceil(b);

    // Property: result >= regular division
    const regular_div = a.div_rem(b).quotient;
    try testing.expect(result.ge(regular_div));

    // Property: if a % b == 0, div_ceil == div
    const remainder = a.div_rem(b).remainder;
    if (remainder.is_zero()) {
        try testing.expectEqual(regular_div, result);
    } else {
        // Otherwise, div_ceil == div + 1
        const expected = regular_div.wrapping_add(U256.ONE);
        try testing.expectEqual(expected, result);
    }
}
```

### fuzz sqrt properties

```zig
test "fuzz sqrt properties" {
    const input = testing.fuzzInput(.{});
    if (input.len < 32) return;

    const value = U256.from_le_bytes(input[0..32]);

    const root = value.sqrt();

    // Property: sqrt(0) = 0
    if (value.is_zero()) {
        try testing.expectEqual(U256.ZERO, root);
        return;
    }

    // Property: root^2 <= value < (root+1)^2
    const root_squared = root.wrapping_mul(root);
    try testing.expect(root_squared.le(value));

    const next = root.wrapping_add(U256.ONE);
    const next_squared = next.overflowing_mul(next);
    if (!next_squared.overflow) {
        try testing.expect(value.lt(next_squared.result));
    }
}
```

### fuzz log2 properties

```zig
test "fuzz log2 properties" {
    const input = testing.fuzzInput(.{});
    if (input.len < 32) return;

    const value = U256.from_le_bytes(input[0..32]);

    if (value.is_zero()) return;

    const log_val = value.log2();

    // Property: 2^log2(value) <= value < 2^(log2(value)+1)
    const lower_bound = U256.ONE.wrapping_shl(@intCast(log_val));
    try testing.expect(lower_bound.le(value));

    if (log_val < 255) {
        const upper_bound = U256.ONE.wrapping_shl(@intCast(log_val + 1));
        try testing.expect(value.lt(upper_bound));
    }
}
```

### fuzz log10 properties

```zig
test "fuzz log10 properties" {
    const input = testing.fuzzInput(.{});
    if (input.len < 32) return;

    const value = U256.from_le_bytes(input[0..32]);

    if (value.is_zero()) return;

    const log_val = value.log10();

    // Property: reasonable bounds
    try testing.expect(log_val <= 77); // 10^77 is near 256-bit max
}
```

### fuzz log base properties

```zig
test "fuzz log base properties" {
    const input = testing.fuzzInput(.{});
    if (input.len < 64) return;

    const value = U256.from_le_bytes(input[0..32]);
    const base = U256.from_le_bytes(input[32..64]);

    if (value.is_zero() or base.is_zero() or base.eq(U256.ONE)) return;

    const log_val = value.log(base);

    // Property: base^log <= value < base^(log+1)
    const lower = base.saturating_pow(@intCast(log_val));
    try testing.expect(lower.le(value));
}
```

### fuzz U8 edge cases

```zig
test "fuzz U8 edge cases" {
    const input = testing.fuzzInput(.{});
    if (input.len < 2) return;

    const a = U8.from_u64(input[0]);
    const b = U8.from_u64(input[1]);

    // Property: all values fit in u8
    try testing.expect(a.to_u64() <= 255);
    try testing.expect(b.to_u64() <= 255);

    // Property: operations respect 8-bit bounds
    const sum = a.wrapping_add(b);
    try testing.expect(sum.to_u64() <= 255);
}
```

### fuzz U512 large operations

```zig
test "fuzz U512 large operations" {
    const input = testing.fuzzInput(.{});
    if (input.len < 128) return;

    const a = U512.from_le_bytes(input[0..64]);
    const b = U512.from_le_bytes(input[64..128]);

    // Property: operations don't panic
    _ = a.wrapping_add(b);
    _ = a.wrapping_sub(b);
    _ = a.bit_and(b);
    _ = a.bit_or(b);
    _ = a.bit_xor(b);

    if (!b.is_zero()) {
        _ = a.div_rem(b);
    }
}
```
