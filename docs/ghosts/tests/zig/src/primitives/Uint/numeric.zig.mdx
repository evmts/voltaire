---
title: '[Zig] src/primitives/Uint/numeric.zig'
source: 'src/primitives/Uint/numeric.zig'
---

> Auto-generated from Zig tests in: src/primitives/Uint/numeric.zig

### unit conversions

```zig
test "unit conversions" {
    try testing.expectEqual(@as(u256, 1), WEI);
    try testing.expectEqual(@as(u256, 1_000_000_000), GWEI);
    try testing.expectEqual(@as(u256, 1_000_000_000_000_000_000), ETHER);
}
```

### parse ether

```zig
test "parse ether" {
    const result1 = try parseEther("1");
    try testing.expectEqual(ETHER, result1);

    const result2 = try parseEther("1.5");
    try testing.expectEqual(ETHER + ETHER / 2, result2);

    const result3 = try parseEther("0.001");
    try testing.expectEqual(FINNEY, result3);
}
```

### parse gwei

```zig
test "parse gwei" {
    const result1 = try parseGwei("1");
    try testing.expectEqual(GWEI, result1);

    const result2 = try parseGwei("20");
    try testing.expectEqual(20 * GWEI, result2);

    const result3 = try parseGwei("0.5");
    try testing.expectEqual(GWEI / 2, result3);
}
```

### format ether

```zig
test "format ether" {
    const allocator = testing.allocator;

    const result1 = try formatEther(allocator, ETHER);
    defer allocator.free(result1);
    try testing.expectEqualStrings("1 ether", result1);

    const result2 = try formatEther(allocator, ETHER + ETHER / 2);
    defer allocator.free(result2);
    try testing.expectEqualStrings("1.5 ether", result2);

    const result3 = try formatEther(allocator, FINNEY);
    defer allocator.free(result3);
    try testing.expectEqualStrings("0.001 ether", result3);
}
```

### format gwei

```zig
test "format gwei" {
    const allocator = testing.allocator;

    const result1 = try formatGwei(allocator, GWEI);
    defer allocator.free(result1);
    try testing.expectEqualStrings("1 gwei", result1);

    const result2 = try formatGwei(allocator, 20 * GWEI);
    defer allocator.free(result2);
    try testing.expectEqualStrings("20 gwei", result2);
}
```

### unit conversion

```zig
test "unit conversion" {
    const result1 = try convertUnits(1, .ether, .gwei);
    try testing.expectEqual(@as(u256, 1_000_000_000), result1);

    const result2 = try convertUnits(1000, .gwei, .ether);
    try testing.expectEqual(@as(u256, 0), result2); // Less than 1 ether

    const result3 = try convertUnits(1_000_000_000, .gwei, .ether);
    try testing.expectEqual(@as(u256, 1), result3);
}
```

### gas cost calculations

```zig
test "gas cost calculations" {
    const gas_used: u64 = 21000;
    const gas_price_gwei: u256 = 20;

    const cost = calculateGasCost(gas_used, gas_price_gwei);
    try testing.expectEqual(@as(u256, 21000) * 20 * GWEI, cost);
}
```

### safe math operations

```zig
test "safe math operations" {
    try testing.expectEqual(@as(?u256, 5), safeAdd(2, 3));
    try testing.expectEqual(@as(?u256, null), safeAdd(std.math.maxInt(u256), 1));

    try testing.expectEqual(@as(?u256, 2), safeSub(5, 3));
    try testing.expectEqual(@as(?u256, null), safeSub(3, 5));

    try testing.expectEqual(@as(?u256, 6), safeMul(2, 3));
    try testing.expectEqual(@as(?u256, 0), safeMul(0, 5));

    try testing.expectEqual(@as(?u256, 2), safeDiv(6, 3));
    try testing.expectEqual(@as(?u256, null), safeDiv(5, 0));
}
```

### percentage calculations

```zig
test "percentage calculations" {
    try testing.expectEqual(@as(u256, 50), calculatePercentage(100, 50));
    try testing.expectEqual(@as(u256, 25), calculatePercentageOf(25, 100));
}
```

### parseEther with integer values

```zig
test "parseEther with integer values" {
    const result1 = try parseEther("0");
    try testing.expectEqual(@as(u256, 0), result1);

    const result2 = try parseEther("1");
    try testing.expectEqual(ETHER, result2);

    const result3 = try parseEther("10");
    try testing.expectEqual(10 * ETHER, result3);

    const result4 = try parseEther("100");
    try testing.expectEqual(100 * ETHER, result4);

    const result5 = try parseEther("1000000");
    try testing.expectEqual(1000000 * ETHER, result5);
}
```

### parseEther with decimal values

```zig
test "parseEther with decimal values" {
    const result1 = try parseEther("0.1");
    try testing.expectEqual(ETHER / 10, result1);

    const result2 = try parseEther("0.5");
    try testing.expectEqual(ETHER / 2, result2);

    const result3 = try parseEther("1.5");
    try testing.expectEqual(ETHER + ETHER / 2, result3);

    const result4 = try parseEther("2.25");
    try testing.expectEqual(2 * ETHER + ETHER / 4, result4);

    const result5 = try parseEther("0.001");
    try testing.expectEqual(FINNEY, result5);

    const result6 = try parseEther("0.000001");
    try testing.expectEqual(SZABO, result6);

    const result7 = try parseEther("0.000000001");
    try testing.expectEqual(GWEI, result7);
}
```

### parseEther with maximum precision

```zig
test "parseEther with maximum precision" {
    const result1 = try parseEther("0.000000000000000001");
    try testing.expectEqual(@as(u256, 1), result1);

    const result2 = try parseEther("1.000000000000000001");
    try testing.expectEqual(ETHER + 1, result2);

    const result3 = try parseEther("0.123456789012345678");
    try testing.expectEqual(@as(u256, 123456789012345678), result3);

    const result4 = try parseEther("1.123456789012345678");
    try testing.expectEqual(ETHER + 123456789012345678, result4);
}
```

### parseEther with trailing zeros

```zig
test "parseEther with trailing zeros" {
    const result1 = try parseEther("1.0");
    try testing.expectEqual(ETHER, result1);

    const result2 = try parseEther("1.00");
    try testing.expectEqual(ETHER, result2);

    const result3 = try parseEther("1.500");
    try testing.expectEqual(ETHER + ETHER / 2, result3);

    const result4 = try parseEther("0.100");
    try testing.expectEqual(ETHER / 10, result4);
}
```

### parseEther with leading decimal point

```zig
test "parseEther with leading decimal point" {
    const result1 = try parseEther(".1");
    try testing.expectEqual(ETHER / 10, result1);

    const result2 = try parseEther(".5");
    try testing.expectEqual(ETHER / 2, result2);

    const result3 = try parseEther(".001");
    try testing.expectEqual(FINNEY, result3);
}
```

### parseEther with whitespace

```zig
test "parseEther with whitespace" {
    const result1 = try parseEther("  1  ");
    try testing.expectEqual(ETHER, result1);

    const result2 = try parseEther("\t1.5\t");
    try testing.expectEqual(ETHER + ETHER / 2, result2);

    const result3 = try parseEther("\n0.1\n");
    try testing.expectEqual(ETHER / 10, result3);

    const result4 = try parseEther(" \t\n 2.5 \r\n ");
    try testing.expectEqual(2 * ETHER + ETHER / 2, result4);
}
```

### parseEther with precision overflow

```zig
test "parseEther with precision overflow" {
    const result1 = try parseEther("1.0000000000000000001");
    try testing.expectEqual(ETHER, result1);

    const result2 = try parseEther("1.123456789012345678999999");
    try testing.expectEqual(ETHER + 123456789012345678, result2);
}
```

### parseEther invalid input

```zig
test "parseEther invalid input" {
    try testing.expectError(NumericError.InvalidInput, parseEther(""));
    try testing.expectError(NumericError.InvalidInput, parseEther("   "));
    try testing.expectError(NumericError.InvalidInput, parseEther("abc"));
    try testing.expectError(NumericError.InvalidInput, parseEther("1.2.3"));
    try testing.expectError(NumericError.InvalidInput, parseEther("1..2"));
    try testing.expectError(NumericError.InvalidInput, parseEther("1.2a"));
    try testing.expectError(NumericError.InvalidInput, parseEther("a1.2"));
}
```

### parseUnits with wei

```zig
test "parseUnits with wei" {
    const result1 = try parseUnits("0", .wei);
    try testing.expectEqual(@as(u256, 0), result1);

    const result2 = try parseUnits("1", .wei);
    try testing.expectEqual(@as(u256, 1), result2);

    const result3 = try parseUnits("100", .wei);
    try testing.expectEqual(@as(u256, 100), result3);

    const result4 = try parseUnits("1000000000000000000", .wei);
    try testing.expectEqual(ETHER, result4);
}
```

### parseUnits with kwei

```zig
test "parseUnits with kwei" {
    const result1 = try parseUnits("1", .kwei);
    try testing.expectEqual(KWEI, result1);

    const result2 = try parseUnits("10", .kwei);
    try testing.expectEqual(10 * KWEI, result2);

    const result3 = try parseUnits("0.5", .kwei);
    try testing.expectEqual(KWEI / 2, result3);

    const result4 = try parseUnits("1.5", .kwei);
    try testing.expectEqual(KWEI + KWEI / 2, result4);
}
```

### parseUnits with mwei

```zig
test "parseUnits with mwei" {
    const result1 = try parseUnits("1", .mwei);
    try testing.expectEqual(MWEI, result1);

    const result2 = try parseUnits("10", .mwei);
    try testing.expectEqual(10 * MWEI, result2);

    const result3 = try parseUnits("0.001", .mwei);
    try testing.expectEqual(KWEI, result3);
}
```

### parseUnits with gwei

```zig
test "parseUnits with gwei" {
    const result1 = try parseUnits("1", .gwei);
    try testing.expectEqual(GWEI, result1);

    const result2 = try parseUnits("20", .gwei);
    try testing.expectEqual(20 * GWEI, result2);

    const result3 = try parseUnits("0.5", .gwei);
    try testing.expectEqual(GWEI / 2, result3);

    const result4 = try parseUnits("100.25", .gwei);
    try testing.expectEqual(100 * GWEI + GWEI / 4, result4);
}
```

### parseUnits with szabo

```zig
test "parseUnits with szabo" {
    const result1 = try parseUnits("1", .szabo);
    try testing.expectEqual(SZABO, result1);

    const result2 = try parseUnits("0.001", .szabo);
    try testing.expectEqual(GWEI, result2);

    const result3 = try parseUnits("1000", .szabo);
    try testing.expectEqual(1000 * SZABO, result3);
}
```

### parseUnits with finney

```zig
test "parseUnits with finney" {
    const result1 = try parseUnits("1", .finney);
    try testing.expectEqual(FINNEY, result1);

    const result2 = try parseUnits("0.001", .finney);
    try testing.expectEqual(SZABO, result2);

    const result3 = try parseUnits("1000", .finney);
    try testing.expectEqual(ETHER, result3);
}
```

### parseUnits with ether

```zig
test "parseUnits with ether" {
    const result1 = try parseUnits("1", .ether);
    try testing.expectEqual(ETHER, result1);

    const result2 = try parseUnits("0.001", .ether);
    try testing.expectEqual(FINNEY, result2);

    const result3 = try parseUnits("100", .ether);
    try testing.expectEqual(100 * ETHER, result3);
}
```

### parseUnits decimal precision per unit

```zig
test "parseUnits decimal precision per unit" {
    const result1 = try parseUnits("1.1", .wei);
    try testing.expectEqual(@as(u256, 1), result1);

    const result2 = try parseUnits("1.999", .kwei);
    try testing.expectEqual(KWEI + 999, result2);

    const result3 = try parseUnits("1.999999", .mwei);
    try testing.expectEqual(MWEI + 999999, result3);

    const result4 = try parseUnits("1.999999999", .gwei);
    try testing.expectEqual(GWEI + 999999999, result4);
}
```

### parseUnits with zero values

```zig
test "parseUnits with zero values" {
    const result1 = try parseUnits("0", .wei);
    try testing.expectEqual(@as(u256, 0), result1);

    const result2 = try parseUnits("0", .gwei);
    try testing.expectEqual(@as(u256, 0), result2);

    const result3 = try parseUnits("0", .ether);
    try testing.expectEqual(@as(u256, 0), result3);

    const result4 = try parseUnits("0.0", .ether);
    try testing.expectEqual(@as(u256, 0), result4);

    const result5 = try parseUnits("0.00", .gwei);
    try testing.expectEqual(@as(u256, 0), result5);
}
```

### parseUnits with only decimal part

```zig
test "parseUnits with only decimal part" {
    const result1 = try parseUnits(".1", .ether);
    try testing.expectEqual(ETHER / 10, result1);

    const result2 = try parseUnits(".5", .gwei);
    try testing.expectEqual(GWEI / 2, result2);

    const result3 = try parseUnits(".999", .kwei);
    try testing.expectEqual(@as(u256, 999), result3);
}
```

### parseUnits invalid inputs

```zig
test "parseUnits invalid inputs" {
    try testing.expectError(NumericError.InvalidInput, parseUnits("", .ether));
    try testing.expectError(NumericError.InvalidInput, parseUnits("   ", .ether));
    try testing.expectError(NumericError.InvalidInput, parseUnits("abc", .gwei));
    try testing.expectError(NumericError.InvalidInput, parseUnits("1.2.3", .ether));
    try testing.expectError(NumericError.InvalidInput, parseUnits("1..2", .ether));
    try testing.expectError(NumericError.InvalidInput, parseUnits("1.2a", .gwei));
    try testing.expectError(NumericError.InvalidInput, parseUnits("a1.2", .wei));
    try testing.expectError(NumericError.InvalidInput, parseUnits("1e10", .ether));
    try testing.expectError(NumericError.ValueTooLarge, parseUnits("-1", .ether));
}
```

### parseUnits edge cases with large values

```zig
test "parseUnits edge cases with large values" {
    const result1 = try parseUnits("1000000", .ether);
    try testing.expectEqual(1000000 * ETHER, result1);

    const result2 = try parseUnits("999999999", .gwei);
    try testing.expectEqual(999999999 * GWEI, result2);

    const result3 = try parseUnits("123456.789012345678", .ether);
    try testing.expectEqual(123456 * ETHER + 789012345678000000, result3);
}
```

### parseUnits consistent across all units

```zig
test "parseUnits consistent across all units" {
    const ether_value = try parseUnits("1", .ether);
    const finney_value = try parseUnits("1000", .finney);
    try testing.expectEqual(ether_value, finney_value);

    const gwei_value = try parseUnits("1", .gwei);
    const wei_value = try parseUnits("1000000000", .wei);
    try testing.expectEqual(gwei_value, wei_value);

    const szabo_value = try parseUnits("1", .szabo);
    const gwei_szabo = try parseUnits("1000", .gwei);
    try testing.expectEqual(szabo_value, gwei_szabo);
}
```

### parseUnits whitespace handling

```zig
test "parseUnits whitespace handling" {
    const result1 = try parseUnits("  1  ", .ether);
    try testing.expectEqual(ETHER, result1);

    const result2 = try parseUnits("\t0.5\t", .gwei);
    try testing.expectEqual(GWEI / 2, result2);

    const result3 = try parseUnits("\n\r 10.25 \r\n", .gwei);
    try testing.expectEqual(10 * GWEI + GWEI / 4, result3);
}
```

### unit conversion edge cases

```zig
test "unit conversion edge cases" {
    const result1 = try convertUnits(0, .ether, .gwei);
    try testing.expectEqual(@as(u256, 0), result1);

    const result2 = try convertUnits(1, .wei, .wei);
    try testing.expectEqual(@as(u256, 1), result2);

    const result3 = try convertUnits(1, .ether, .wei);
    try testing.expectEqual(ETHER, result3);

    const result4 = try convertUnits(1, .wei, .ether);
    try testing.expectEqual(@as(u256, 0), result4);

    const result5 = try convertUnits(1_000_000_000_000_000_000, .wei, .ether);
    try testing.expectEqual(@as(u256, 1), result5);
}
```

### unit conversion precision loss

```zig
test "unit conversion precision loss" {
    const result1 = try convertUnits(500, .gwei, .ether);
    try testing.expectEqual(@as(u256, 0), result1);

    const result2 = try convertUnits(1, .kwei, .mwei);
    try testing.expectEqual(@as(u256, 0), result2);

    const result3 = try convertUnits(999, .wei, .kwei);
    try testing.expectEqual(@as(u256, 0), result3);
}
```

### unit conversion all combinations

```zig
test "unit conversion all combinations" {
    const result1 = try convertUnits(1, .kwei, .wei);
    try testing.expectEqual(KWEI, result1);

    const result2 = try convertUnits(1, .mwei, .kwei);
    try testing.expectEqual(@as(u256, 1000), result2);

    const result3 = try convertUnits(1, .gwei, .mwei);
    try testing.expectEqual(@as(u256, 1000), result3);

    const result4 = try convertUnits(1, .szabo, .gwei);
    try testing.expectEqual(@as(u256, 1000), result4);

    const result5 = try convertUnits(1, .finney, .szabo);
    try testing.expectEqual(@as(u256, 1000), result5);

    const result6 = try convertUnits(1, .ether, .finney);
    try testing.expectEqual(@as(u256, 1000), result6);
}
```

### unit fromString and toString

```zig
test "unit fromString and toString" {
    try testing.expectEqual(Unit.wei, Unit.fromString("wei").?);
    try testing.expectEqual(Unit.kwei, Unit.fromString("kwei").?);
    try testing.expectEqual(Unit.mwei, Unit.fromString("mwei").?);
    try testing.expectEqual(Unit.gwei, Unit.fromString("gwei").?);
    try testing.expectEqual(Unit.szabo, Unit.fromString("szabo").?);
    try testing.expectEqual(Unit.finney, Unit.fromString("finney").?);
    try testing.expectEqual(Unit.ether, Unit.fromString("ether").?);

    try testing.expectEqual(@as(?Unit, null), Unit.fromString("invalid"));
    try testing.expectEqual(@as(?Unit, null), Unit.fromString(""));
    try testing.expectEqual(@as(?Unit, null), Unit.fromString("ETHER"));

    try testing.expectEqualStrings("wei", Unit.wei.toString());
    try testing.expectEqualStrings("kwei", Unit.kwei.toString());
    try testing.expectEqualStrings("mwei", Unit.mwei.toString());
    try testing.expectEqualStrings("gwei", Unit.gwei.toString());
    try testing.expectEqualStrings("szabo", Unit.szabo.toString());
    try testing.expectEqualStrings("finney", Unit.finney.toString());
    try testing.expectEqualStrings("ether", Unit.ether.toString());
}
```

### unit toMultiplier

```zig
test "unit toMultiplier" {
    try testing.expectEqual(WEI, Unit.wei.toMultiplier());
    try testing.expectEqual(KWEI, Unit.kwei.toMultiplier());
    try testing.expectEqual(MWEI, Unit.mwei.toMultiplier());
    try testing.expectEqual(GWEI, Unit.gwei.toMultiplier());
    try testing.expectEqual(SZABO, Unit.szabo.toMultiplier());
    try testing.expectEqual(FINNEY, Unit.finney.toMultiplier());
    try testing.expectEqual(ETHER, Unit.ether.toMultiplier());
}
```

### parseEther maximum value handling

```zig
test "parseEther maximum value handling" {
    const max_ether_str = "115792089237316195423570985008687907853269984665640564039457";
    const result = try parseEther(max_ether_str);
    try testing.expect(result > 0);
}
```

### parseUnits with very small decimals

```zig
test "parseUnits with very small decimals" {
    const result1 = try parseUnits("0.000000000000000001", .ether);
    try testing.expectEqual(@as(u256, 1), result1);

    const result2 = try parseUnits("0.000000001", .gwei);
    try testing.expectEqual(@as(u256, 1), result2);

    const result3 = try parseUnits("0.001", .kwei);
    try testing.expectEqual(@as(u256, 1), result3);
}
```

### formatEther with various values

```zig
test "formatEther with various values" {
    const allocator = testing.allocator;

    const zero_formatted = try formatEther(allocator, 0);
    defer allocator.free(zero_formatted);
    try testing.expectEqualStrings("0 ether", zero_formatted);

    const one_wei = try formatEther(allocator, 1);
    defer allocator.free(one_wei);
    try testing.expectEqualStrings("0.000000000000000001 ether", one_wei);

    const half_ether = try formatEther(allocator, ETHER / 2);
    defer allocator.free(half_ether);
    try testing.expectEqualStrings("0.5 ether", half_ether);

    const quarter_ether = try formatEther(allocator, ETHER / 4);
    defer allocator.free(quarter_ether);
    try testing.expectEqualStrings("0.25 ether", quarter_ether);

    const large = try formatEther(allocator, 1000 * ETHER);
    defer allocator.free(large);
    try testing.expectEqualStrings("1000 ether", large);
}
```

### formatGwei with various values

```zig
test "formatGwei with various values" {
    const allocator = testing.allocator;

    const zero_formatted = try formatGwei(allocator, 0);
    defer allocator.free(zero_formatted);
    try testing.expectEqualStrings("0 gwei", zero_formatted);

    const one_formatted = try formatGwei(allocator, GWEI);
    defer allocator.free(one_formatted);
    try testing.expectEqualStrings("1 gwei", one_formatted);

    const half_gwei = try formatGwei(allocator, GWEI / 2);
    defer allocator.free(half_gwei);
    try testing.expectEqualStrings("0.5 gwei", half_gwei);

    const large = try formatGwei(allocator, 1000000 * GWEI);
    defer allocator.free(large);
    try testing.expectEqualStrings("1000000 gwei", large);
}
```

### formatWei function

```zig
test "formatWei function" {
    const allocator = testing.allocator;

    const zero = try formatWei(allocator, 0);
    defer allocator.free(zero);
    try testing.expectEqualStrings("0", zero);

    const one = try formatWei(allocator, 1);
    defer allocator.free(one);
    try testing.expectEqualStrings("1", one);

    const large = try formatWei(allocator, ETHER);
    defer allocator.free(large);
    try testing.expectEqualStrings("1000000000000000000", large);

    const max_u64 = try formatWei(allocator, std.math.maxInt(u64));
    defer allocator.free(max_u64);
    try testing.expectEqualStrings("18446744073709551615", max_u64);
}
```

### formatUnits with custom decimals

```zig
test "formatUnits with custom decimals" {
    const allocator = testing.allocator;

    const result1 = try formatUnits(allocator, ETHER, .ether, 2);
    defer allocator.free(result1);
    try testing.expectEqualStrings("1 ether", result1);

    const result2 = try formatUnits(allocator, ETHER / 3, .ether, 2);
    defer allocator.free(result2);
    try testing.expectEqualStrings("0.33 ether", result2);

    const result3 = try formatUnits(allocator, ETHER / 3, .ether, 6);
    defer allocator.free(result3);
    try testing.expectEqualStrings("0.333333 ether", result3);

    const result4 = try formatUnits(allocator, GWEI, .gwei, 0);
    defer allocator.free(result4);
    try testing.expectEqualStrings("1 gwei", result4);

    const result5 = try formatUnits(allocator, 123456789, .wei, null);
    defer allocator.free(result5);
    try testing.expectEqualStrings("123456789 wei", result5);
}
```

### formatGasCost function

```zig
test "formatGasCost function" {
    const allocator = testing.allocator;

    const result1 = try formatGasCost(allocator, 21000, 20);
    defer allocator.free(result1);

    const expected_cost = calculateGasCost(21000, 20);
    const expected_str = try formatEther(allocator, expected_cost);
    defer allocator.free(expected_str);

    try testing.expectEqualStrings(expected_str, result1);

    const result2 = try formatGasCost(allocator, 100000, 50);
    defer allocator.free(result2);
    const expected_cost2 = calculateGasCost(100000, 50);
    const expected_str2 = try formatEther(allocator, expected_cost2);
    defer allocator.free(expected_str2);
    try testing.expectEqualStrings(expected_str2, result2);
}
```

### min and max functions for u256

```zig
test "min and max functions for u256" {
    const a: u256 = 100;
    const b: u256 = 200;

    try testing.expectEqual(@as(u256, 100), min(a, b));
    try testing.expectEqual(@as(u256, 200), max(a, b));

    try testing.expectEqual(@as(u256, 100), min(b, a));
    try testing.expectEqual(@as(u256, 200), max(b, a));

    try testing.expectEqual(@as(u256, 0), min(0, 100));
    try testing.expectEqual(@as(u256, 100), max(0, 100));

    const large1: u256 = std.math.maxInt(u256);
    const large2: u256 = std.math.maxInt(u256) - 1;

    try testing.expectEqual(large2, min(large1, large2));
    try testing.expectEqual(large1, max(large1, large2));
}
```

### safeMul overflow detection

```zig
test "safeMul overflow detection" {
    const max_val = std.math.maxInt(u256);
    const half_max = max_val / 2;

    const result1 = safeMul(2, 3);
    try testing.expectEqual(@as(?u256, 6), result1);

    const result2 = safeMul(max_val, 2);
    try testing.expectEqual(@as(?u256, null), result2);

    const result3 = safeMul(half_max, 2);
    try testing.expect(result3 != null);

    const result4 = safeMul(half_max + 1, 2);
    try testing.expectEqual(@as(?u256, null), result4);

    const result5 = safeMul(0, max_val);
    try testing.expectEqual(@as(?u256, 0), result5);

    const result6 = safeMul(1, max_val);
    try testing.expectEqual(@as(?u256, max_val), result6);
}
```

### safeAdd overflow at boundary

```zig
test "safeAdd overflow at boundary" {
    const max_val = std.math.maxInt(u256);

    const result1 = safeAdd(max_val, 0);
    try testing.expectEqual(@as(?u256, max_val), result1);

    const result2 = safeAdd(max_val, 1);
    try testing.expectEqual(@as(?u256, null), result2);

    const result3 = safeAdd(max_val - 1, 1);
    try testing.expectEqual(@as(?u256, max_val), result3);

    const result4 = safeAdd(max_val - 1, 2);
    try testing.expectEqual(@as(?u256, null), result4);
}
```

### safeSub underflow at boundary

```zig
test "safeSub underflow at boundary" {
    const result1 = safeSub(0, 1);
    try testing.expectEqual(@as(?u256, null), result1);

    const result2 = safeSub(1, 1);
    try testing.expectEqual(@as(?u256, 0), result2);

    const result3 = safeSub(100, 99);
    try testing.expectEqual(@as(?u256, 1), result3);

    const result4 = safeSub(100, 101);
    try testing.expectEqual(@as(?u256, null), result4);
}
```

### calculatePercentageOf with zero whole

```zig
test "calculatePercentageOf with zero whole" {
    const result = calculatePercentageOf(100, 0);
    try testing.expectEqual(@as(u256, 0), result);

    const result2 = calculatePercentageOf(0, 0);
    try testing.expectEqual(@as(u256, 0), result2);

    const result3 = calculatePercentageOf(50, 100);
    try testing.expectEqual(@as(u256, 50), result3);

    const result4 = calculatePercentageOf(100, 100);
    try testing.expectEqual(@as(u256, 100), result4);
}
```

### formatUnits with all unit types

```zig
test "formatUnits with all unit types" {
    const allocator = testing.allocator;

    const units = [_]Unit{ .wei, .kwei, .mwei, .gwei, .szabo, .finney, .ether };

    for (units) |unit| {
        const multiplier = unit.toMultiplier();
        const formatted = try formatUnits(allocator, multiplier, unit, null);
        defer allocator.free(formatted);

        const unit_str = unit.toString();
        const expected_prefix = "1 ";
        try testing.expect(std.mem.startsWith(u8, formatted, expected_prefix));
        try testing.expect(std.mem.endsWith(u8, formatted, unit_str));
    }
}
```

### parseUnits and formatUnits roundtrip

```zig
test "parseUnits and formatUnits roundtrip" {
    const allocator = testing.allocator;

    const test_values = [_]struct {
        str: []const u8,
        unit: Unit,
    }{
        .{ .str = "1", .unit = .ether },
        .{ .str = "0.5", .unit = .ether },
        .{ .str = "100", .unit = .gwei },
        .{ .str = "1000", .unit = .wei },
        .{ .str = "1.25", .unit = .finney },
    };

    for (test_values) |tv| {
        const parsed = try parseUnits(tv.str, tv.unit);
        const formatted = try formatUnits(allocator, parsed, tv.unit, null);
        defer allocator.free(formatted);

        const reparsed = try parseUnits(tv.str, tv.unit);
        try testing.expectEqual(parsed, reparsed);
    }
}
```

### Unit enum exhaustive coverage

```zig
test "Unit enum exhaustive coverage" {
    try testing.expect(Unit.fromString("wei") != null);
    try testing.expect(Unit.fromString("kwei") != null);
    try testing.expect(Unit.fromString("mwei") != null);
    try testing.expect(Unit.fromString("gwei") != null);
    try testing.expect(Unit.fromString("szabo") != null);
    try testing.expect(Unit.fromString("finney") != null);
    try testing.expect(Unit.fromString("ether") != null);

    try testing.expectEqual(@as(?Unit, null), Unit.fromString("bitcoin"));
    try testing.expect(Unit.fromString("WEI") == null);
    try testing.expect(Unit.fromString("GWEI") == null);
}
```
