---
title: '[Zig] src/primitives/Authorization/authorization.zig'
source: 'src/primitives/Authorization/authorization.zig'
---

> Auto-generated from Zig tests in: src/primitives/Authorization/authorization.zig

### authorization creation and recovery

```zig
test "authorization creation and recovery" {
    const allocator = testing.allocator;

    const private_key: crypto.PrivateKey = [_]u8{0x42} ** 32;

    const signer_address = try crypto.getAddress(allocator, private_key);
    const target_address = try Address.fromHex("0x1111111111111111111111111111111111111111");

    const auth = try createAuthorization(
        allocator,
        1, // chain_id
        target_address,
        0, // nonce
        private_key,
    );

    // Validate
    try auth.validate();

    // Recover authority
    const auth_addr = try auth.authority();
    try testing.expectEqual(signer_address, auth_addr);
}
```

### authorization validation

```zig
test "authorization validation" {
    var auth = Authorization{
        .chain_id = 1,
        .address = try Address.fromHex("0x1111111111111111111111111111111111111111"),
        .nonce = 0,
        .v = 27,
        .r = [_]u8{0x12} ** 32,
        .s = [_]u8{0x34} ** 32,
    };

    // Valid
    try auth.validate();

    // Invalid chain ID
    auth.chain_id = 0;
    try testing.expectError(AuthorizationError.InvalidChainId, auth.validate());
    auth.chain_id = 1;

    // Zero address
    auth.address = Address.ZERO;
    try testing.expectError(AuthorizationError.ZeroAddress, auth.validate());
}
```

### authorization list encoding

```zig
test "authorization list encoding" {
    const allocator = testing.allocator;

    const private_key: crypto.PrivateKey = [_]u8{0x42} ** 32;

    const auth1 = try createAuthorization(
        allocator,
        1,
        try Address.fromHex("0x1111111111111111111111111111111111111111"),
        0,
        private_key,
    );

    const auth2 = try createAuthorization(
        allocator,
        1,
        try Address.fromHex("0x2222222222222222222222222222222222222222"),
        1,
        private_key,
    );

    const auth_list = [_]Authorization{ auth1, auth2 };

    const encoded = try encodeAuthorizationList(allocator, &auth_list);
    defer allocator.free(encoded);

    // Should produce valid RLP
    try testing.expect(encoded.len > 0);
    try testing.expect(encoded[0] >= 0xc0); // RLP list prefix
}
```

### delegation designation

```zig
test "delegation designation" {
    var delegation = DelegationDesignation{
        .authority = try Address.fromHex("0x1111111111111111111111111111111111111111"),
        .delegated_address = try Address.fromHex("0x2222222222222222222222222222222222222222"),
    };

    // Should be active
    try testing.expect(delegation.isActive());

    // Revoke delegation
    delegation.revoke();
    try testing.expect(!delegation.isActive());
    try testing.expectEqual(Address.ZERO, delegation.delegated_address);
}
```

### batch authorization processing

```zig
test "batch authorization processing" {
    const allocator = testing.allocator;

    const private_key1: crypto.PrivateKey = [_]u8{0x01} ** 32;
    const private_key2: crypto.PrivateKey = [_]u8{0x02} ** 32;

    const auth1 = try createAuthorization(
        allocator,
        1,
        try Address.fromHex("0x1111111111111111111111111111111111111111"),
        0,
        private_key1,
    );

    const auth2 = try createAuthorization(
        allocator,
        1,
        try Address.fromHex("0x2222222222222222222222222222222222222222"),
        0,
        private_key2,
    );

    const auth_list = [_]Authorization{ auth1, auth2 };

    const delegations = try processAuthorizations(allocator, &auth_list);
    defer allocator.free(delegations);

    try testing.expectEqual(@as(usize, 2), delegations.len);
    try testing.expect(delegations[0].isActive());
    try testing.expect(delegations[1].isActive());
}
```

### authorization gas cost calculation

```zig
test "authorization gas cost calculation" {
    const auth_list = [_]Authorization{
        .{
            .chain_id = 1,
            .address = try Address.fromHex("0x1111111111111111111111111111111111111111"),
            .nonce = 0,
            .v = 27,
            .r = [_]u8{0x12} ** 32,
            .s = [_]u8{0x34} ** 32,
        },
        .{
            .chain_id = 1,
            .address = try Address.fromHex("0x2222222222222222222222222222222222222222"),
            .nonce = 0,
            .v = 27,
            .r = [_]u8{0x56} ** 32,
            .s = [_]u8{0x78} ** 32,
        },
    };

    // 2 authorizations, 1 empty account
    const gas_cost = calculateAuthorizationGasCost(&auth_list, 1);

    // Expected: 2 * 12500 + 1 * 25000 = 50000
    try testing.expectEqual(@as(u64, 50000), gas_cost);
}
```

### authority() recovers correct signer address

```zig
test "authority() recovers correct signer address" {
    const allocator = testing.allocator;

    const private_key: crypto.PrivateKey = [_]u8{0x42} ** 32;
    const expected_signer = try crypto.getAddress(allocator, private_key);
    const target = try Address.fromHex("0x1111111111111111111111111111111111111111");

    const auth = try createAuthorization(
        allocator,
        1,
        target,
        0,
        private_key,
    );

    const recovered = try auth.authority();
    try testing.expectEqual(expected_signer, recovered);
}
```

### authority() recovers correct signer with different nonces

```zig
test "authority() recovers correct signer with different nonces" {
    const allocator = testing.allocator;

    const private_key: crypto.PrivateKey = [_]u8{0x99} ** 32;
    const expected_signer = try crypto.getAddress(allocator, private_key);
    const target = try Address.fromHex("0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa");

    const nonces = [_]u64{ 0, 1, 100, 999999, std.math.maxInt(u64) };

    for (nonces) |nonce| {
        const auth = try createAuthorization(
            allocator,
            1,
            target,
            nonce,
            private_key,
        );

        const recovered = try auth.authority();
        try testing.expectEqual(expected_signer, recovered);
    }
}
```

### signingHash() produces consistent hashes

```zig
test "signingHash() produces consistent hashes" {
    const allocator = testing.allocator;
    _ = allocator;

    const addr = try Address.fromHex("0x1111111111111111111111111111111111111111");
    const auth1 = Authorization{
        .chain_id = 1,
        .address = addr,
        .nonce = 42,
        .v = 27,
        .r = [_]u8{0x12} ** 32,
        .s = [_]u8{0x34} ** 32,
    };

    const auth2 = Authorization{
        .chain_id = 1,
        .address = addr,
        .nonce = 42,
        .v = 28,
        .r = [_]u8{0xff} ** 32,
        .s = [_]u8{0xaa} ** 32,
    };

    const hash1 = try auth1.signingHash();
    const hash2 = try auth2.signingHash();

    try testing.expectEqual(hash1, hash2);
}
```

### signingHash() produces different hashes for different inputs

```zig
test "signingHash() produces different hashes for different inputs" {
    const allocator = testing.allocator;
    _ = allocator;

    const addr = try Address.fromHex("0x1111111111111111111111111111111111111111");
    const auth1 = Authorization{
        .chain_id = 1,
        .address = addr,
        .nonce = 0,
        .v = 27,
        .r = [_]u8{0x12} ** 32,
        .s = [_]u8{0x34} ** 32,
    };

    const auth2 = Authorization{
        .chain_id = 1,
        .address = addr,
        .nonce = 1,
        .v = 27,
        .r = [_]u8{0x12} ** 32,
        .s = [_]u8{0x34} ** 32,
    };

    const auth3 = Authorization{
        .chain_id = 2,
        .address = addr,
        .nonce = 0,
        .v = 27,
        .r = [_]u8{0x12} ** 32,
        .s = [_]u8{0x34} ** 32,
    };

    const hash1 = try auth1.signingHash();
    const hash2 = try auth2.signingHash();
    const hash3 = try auth3.signingHash();

    try testing.expect(!std.mem.eql(u8, &hash1, &hash2));
    try testing.expect(!std.mem.eql(u8, &hash1, &hash3));
    try testing.expect(!std.mem.eql(u8, &hash2, &hash3));
}
```

### signingHash() handles edge case nonce values

```zig
test "signingHash() handles edge case nonce values" {
    const allocator = testing.allocator;
    _ = allocator;

    const addr = try Address.fromHex("0x1111111111111111111111111111111111111111");

    const auth_zero = Authorization{
        .chain_id = 1,
        .address = addr,
        .nonce = 0,
        .v = 27,
        .r = [_]u8{0x12} ** 32,
        .s = [_]u8{0x34} ** 32,
    };

    const auth_max = Authorization{
        .chain_id = 1,
        .address = addr,
        .nonce = std.math.maxInt(u64),
        .v = 27,
        .r = [_]u8{0x12} ** 32,
        .s = [_]u8{0x34} ** 32,
    };

    const hash_zero = try auth_zero.signingHash();
    const hash_max = try auth_max.signingHash();

    try testing.expect(hash_zero.len == 32);
    try testing.expect(hash_max.len == 32);
    try testing.expect(!std.mem.eql(u8, &hash_zero, &hash_max));
}
```

### validate() rejects zero chain ID

```zig
test "validate() rejects zero chain ID" {
    const allocator = testing.allocator;
    _ = allocator;

    var auth = Authorization{
        .chain_id = 0,
        .address = try Address.fromHex("0x1111111111111111111111111111111111111111"),
        .nonce = 0,
        .v = 27,
        .r = [_]u8{0x12} ** 32,
        .s = [_]u8{0x34} ** 32,
    };

    try testing.expectError(AuthorizationError.InvalidChainId, auth.validate());
}
```

### validate() rejects zero address

```zig
test "validate() rejects zero address" {
    const allocator = testing.allocator;
    _ = allocator;

    var auth = Authorization{
        .chain_id = 1,
        .address = Address.ZERO,
        .nonce = 0,
        .v = 27,
        .r = [_]u8{0x12} ** 32,
        .s = [_]u8{0x34} ** 32,
    };

    try testing.expectError(AuthorizationError.ZeroAddress, auth.validate());
}
```

### validate() rejects signature with r=0

```zig
test "validate() rejects signature with r=0" {
    const allocator = testing.allocator;
    _ = allocator;

    var auth = Authorization{
        .chain_id = 1,
        .address = try Address.fromHex("0x1111111111111111111111111111111111111111"),
        .nonce = 0,
        .v = 27,
        .r = [_]u8{0} ** 32,
        .s = [_]u8{0x34} ** 32,
    };

    try testing.expectError(AuthorizationError.InvalidSignature, auth.validate());
}
```

### validate() rejects signature with s=0

```zig
test "validate() rejects signature with s=0" {
    const allocator = testing.allocator;
    _ = allocator;

    var auth = Authorization{
        .chain_id = 1,
        .address = try Address.fromHex("0x1111111111111111111111111111111111111111"),
        .nonce = 0,
        .v = 27,
        .r = [_]u8{0x12} ** 32,
        .s = [_]u8{0} ** 32,
    };

    try testing.expectError(AuthorizationError.InvalidSignature, auth.validate());
}
```

### validate() rejects signature with r >= N

```zig
test "validate() rejects signature with r >= N" {
    const allocator = testing.allocator;
    _ = allocator;

    const secp256k1_n: u256 = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141;
    var r_bytes: [32]u8 = undefined;
    std.mem.writeInt(u256, &r_bytes, secp256k1_n, .big);

    var auth = Authorization{
        .chain_id = 1,
        .address = try Address.fromHex("0x1111111111111111111111111111111111111111"),
        .nonce = 0,
        .v = 27,
        .r = r_bytes,
        .s = [_]u8{0x34} ** 32,
    };

    try testing.expectError(AuthorizationError.InvalidSignature, auth.validate());
}
```

### validate() rejects signature with s >= N

```zig
test "validate() rejects signature with s >= N" {
    const allocator = testing.allocator;
    _ = allocator;

    const secp256k1_n: u256 = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141;
    var s_bytes: [32]u8 = undefined;
    std.mem.writeInt(u256, &s_bytes, secp256k1_n, .big);

    var auth = Authorization{
        .chain_id = 1,
        .address = try Address.fromHex("0x1111111111111111111111111111111111111111"),
        .nonce = 0,
        .v = 27,
        .r = [_]u8{0x12} ** 32,
        .s = s_bytes,
    };

    try testing.expectError(AuthorizationError.InvalidSignature, auth.validate());
}
```

### validate() rejects malleable signature (high S-value)

```zig
test "validate() rejects malleable signature (high S-value)" {
    const allocator = testing.allocator;
    _ = allocator;

    const secp256k1_n: u256 = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141;
    const half_n = secp256k1_n >> 1;
    const high_s = half_n + 1;

    var s_bytes: [32]u8 = undefined;
    std.mem.writeInt(u256, &s_bytes, high_s, .big);

    var auth = Authorization{
        .chain_id = 1,
        .address = try Address.fromHex("0x1111111111111111111111111111111111111111"),
        .nonce = 0,
        .v = 27,
        .r = [_]u8{0x12} ** 32,
        .s = s_bytes,
    };

    try testing.expectError(AuthorizationError.InvalidSignature, auth.validate());
}
```

### validate() accepts signature with s = N/2 (boundary)

```zig
test "validate() accepts signature with s = N/2 (boundary)" {
    const allocator = testing.allocator;
    _ = allocator;

    const secp256k1_n: u256 = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141;
    const half_n = secp256k1_n >> 1;

    var r_bytes: [32]u8 = undefined;
    std.mem.writeInt(u256, &r_bytes, 0x12345678, .big);

    var s_bytes: [32]u8 = undefined;
    std.mem.writeInt(u256, &s_bytes, half_n, .big);

    var auth = Authorization{
        .chain_id = 1,
        .address = try Address.fromHex("0x1111111111111111111111111111111111111111"),
        .nonce = 0,
        .v = 27,
        .r = r_bytes,
        .s = s_bytes,
    };

    try auth.validate();
}
```

### validate() accepts signature with s = 1 (minimum)

```zig
test "validate() accepts signature with s = 1 (minimum)" {
    const allocator = testing.allocator;
    _ = allocator;

    var r_bytes: [32]u8 = undefined;
    std.mem.writeInt(u256, &r_bytes, 0x12345678, .big);

    var s_bytes: [32]u8 = undefined;
    std.mem.writeInt(u256, &s_bytes, 1, .big);

    var auth = Authorization{
        .chain_id = 1,
        .address = try Address.fromHex("0x1111111111111111111111111111111111111111"),
        .nonce = 0,
        .v = 27,
        .r = r_bytes,
        .s = s_bytes,
    };

    try auth.validate();
}
```

### validate() accepts signature with r = N-1 (maximum valid)

```zig
test "validate() accepts signature with r = N-1 (maximum valid)" {
    const allocator = testing.allocator;
    _ = allocator;

    const secp256k1_n: u256 = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141;
    const max_r = secp256k1_n - 1;

    var r_bytes: [32]u8 = undefined;
    std.mem.writeInt(u256, &r_bytes, max_r, .big);

    var s_bytes: [32]u8 = undefined;
    std.mem.writeInt(u256, &s_bytes, 0x12345678, .big);

    var auth = Authorization{
        .chain_id = 1,
        .address = try Address.fromHex("0x1111111111111111111111111111111111111111"),
        .nonce = 0,
        .v = 27,
        .r = r_bytes,
        .s = s_bytes,
    };

    try auth.validate();
}
```

### isItem() detects signed authorization

```zig
test "isItem() detects signed authorization" {
    const allocator = testing.allocator;
    _ = allocator;

    var signed_auth = Authorization{
        .chain_id = 1,
        .address = try Address.fromHex("0x1111111111111111111111111111111111111111"),
        .nonce = 0,
        .v = 27,
        .r = [_]u8{0x12} ** 32,
        .s = [_]u8{0x34} ** 32,
    };

    try testing.expect(isItem(&signed_auth));

    // Unsigned (zero signature)
    var unsigned_auth = Authorization{
        .chain_id = 1,
        .address = try Address.fromHex("0x1111111111111111111111111111111111111111"),
        .nonce = 0,
        .v = 0,
        .r = [_]u8{0} ** 32,
        .s = [_]u8{0} ** 32,
    };

    try testing.expect(!isItem(&unsigned_auth));
}
```

### isUnsigned() validates unsigned authorization fields

```zig
test "isUnsigned() validates unsigned authorization fields" {
    const allocator = testing.allocator;
    _ = allocator;

    const addr = try Address.fromHex("0x1111111111111111111111111111111111111111");

    // Valid unsigned
    try testing.expect(isUnsigned(1, addr, 0));
    try testing.expect(isUnsigned(1, addr, 42));

    // Invalid: zero chain_id
    try testing.expect(!isUnsigned(0, addr, 0));

    // Invalid: zero address
    try testing.expect(!isUnsigned(1, Address.ZERO, 0));
}
```

### equalsAuth() compares authorizations

```zig
test "equalsAuth() compares authorizations" {
    const allocator = testing.allocator;
    _ = allocator;

    const addr1 = try Address.fromHex("0x1111111111111111111111111111111111111111");
    const addr2 = try Address.fromHex("0x2222222222222222222222222222222222222222");

    var auth1 = Authorization{
        .chain_id = 1,
        .address = addr1,
        .nonce = 0,
        .v = 27,
        .r = [_]u8{0x12} ** 32,
        .s = [_]u8{0x34} ** 32,
    };

    var auth2 = Authorization{
        .chain_id = 1,
        .address = addr1,
        .nonce = 0,
        .v = 27,
        .r = [_]u8{0x12} ** 32,
        .s = [_]u8{0x34} ** 32,
    };

    var auth3 = Authorization{
        .chain_id = 1,
        .address = addr2,
        .nonce = 0,
        .v = 27,
        .r = [_]u8{0x12} ** 32,
        .s = [_]u8{0x34} ** 32,
    };

    // Same authorizations
    try testing.expect(equalsAuth(&auth1, &auth2));

    // Different address
    try testing.expect(!equalsAuth(&auth1, &auth3));

    // Different nonce
    auth2.nonce = 1;
    try testing.expect(!equalsAuth(&auth1, &auth2));
}
```

### format() produces human-readable string

```zig
test "format() produces human-readable string" {
    const allocator = testing.allocator;

    const addr = try Address.fromHex("0x1111111111111111111111111111111111111111");
    var r_bytes: [32]u8 = undefined;
    std.mem.writeInt(u256, &r_bytes, 0x123456, .big);
    var s_bytes: [32]u8 = undefined;
    std.mem.writeInt(u256, &s_bytes, 0x789abc, .big);

    var auth = Authorization{
        .chain_id = 1,
        .address = addr,
        .nonce = 42,
        .v = 27,
        .r = r_bytes,
        .s = s_bytes,
    };

    const formatted = try format(allocator, &auth);
    defer allocator.free(formatted);

    // Should contain key components
    try testing.expect(std.mem.indexOf(u8, formatted, "Authorization") != null);
    try testing.expect(std.mem.indexOf(u8, formatted, "chain=1") != null);
    try testing.expect(std.mem.indexOf(u8, formatted, "nonce=42") != null);
    try testing.expect(std.mem.indexOf(u8, formatted, "v=27") != null);
    try testing.expect(std.mem.indexOf(u8, formatted, "0x1111...1111") != null);
}
```
