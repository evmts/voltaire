---
title: '[Zig] src/primitives/DomainSeparator/DomainSeparator.zig'
source: 'src/primitives/DomainSeparator/DomainSeparator.zig'
---

> Auto-generated from Zig tests in: src/primitives/DomainSeparator/DomainSeparator.zig

### DomainSeparator: fromBytes creates from 32 bytes

```zig
test "DomainSeparator: fromBytes creates from 32 bytes" {
    const bytes = [_]u8{0xab} ** SIZE;
    const sep = try DomainSeparator.fromBytes(&bytes);
    try std.testing.expectEqualSlices(u8, &bytes, &sep.bytes);
}
```

### DomainSeparator: fromBytes rejects invalid length

```zig
test "DomainSeparator: fromBytes rejects invalid length" {
    const bytes = [_]u8{0xab} ** 16;
    try std.testing.expectError(error.InvalidDomainSeparatorLength, DomainSeparator.fromBytes(&bytes));
}
```

### DomainSeparator: from creates from array

```zig
test "DomainSeparator: from creates from array" {
    const bytes = [_]u8{0xcd} ** SIZE;
    const sep = DomainSeparator.from(bytes);
    try std.testing.expectEqualSlices(u8, &bytes, &sep.bytes);
}
```

### DomainSeparator: fromHex with 0x prefix

```zig
test "DomainSeparator: fromHex with 0x prefix" {
    const hex = "0x" ++ ("ab" ** SIZE);
    const sep = try DomainSeparator.fromHex(hex);
    try std.testing.expectEqual(@as(u8, 0xab), sep.bytes[0]);
    try std.testing.expectEqual(@as(u8, 0xab), sep.bytes[31]);
}
```

### DomainSeparator: fromHex without prefix

```zig
test "DomainSeparator: fromHex without prefix" {
    const hex = "cd" ** SIZE;
    const sep = try DomainSeparator.fromHex(hex);
    try std.testing.expectEqual(@as(u8, 0xcd), sep.bytes[0]);
}
```

### DomainSeparator: fromHex invalid length

```zig
test "DomainSeparator: fromHex invalid length" {
    try std.testing.expectError(error.InvalidDomainSeparatorLength, DomainSeparator.fromHex("0x1234"));
}
```

### DomainSeparator: fromHex invalid chars

```zig
test "DomainSeparator: fromHex invalid chars" {
    const hex = "0x" ++ ("zz" ** SIZE);
    try std.testing.expectError(error.InvalidHexString, DomainSeparator.fromHex(hex));
}
```

### DomainSeparator: toHex returns correct format

```zig
test "DomainSeparator: toHex returns correct format" {
    const bytes = [_]u8{0xff} ** SIZE;
    const sep = DomainSeparator.from(bytes);
    const hex = sep.toHex();

    try std.testing.expect(std.mem.startsWith(u8, &hex, "0x"));
    try std.testing.expectEqual(@as(usize, 66), hex.len);
}
```

### DomainSeparator: toHex and fromHex roundtrip

```zig
test "DomainSeparator: toHex and fromHex roundtrip" {
    const bytes = [_]u8{0xab} ** SIZE;
    const sep = DomainSeparator.from(bytes);
    const hex = sep.toHex();
    const decoded = try DomainSeparator.fromHex(&hex);
    try std.testing.expect(sep.equals(decoded));
}
```

### DomainSeparator: toBytes returns correct slice

```zig
test "DomainSeparator: toBytes returns correct slice" {
    const bytes = [_]u8{0x12} ** SIZE;
    const sep = DomainSeparator.from(bytes);
    const slice = sep.toBytes();
    try std.testing.expectEqual(@as(usize, SIZE), slice.len);
    try std.testing.expectEqualSlices(u8, &bytes, slice);
}
```

### DomainSeparator: equals same

```zig
test "DomainSeparator: equals same" {
    const sep = DomainSeparator.from([_]u8{0xaa} ** SIZE);
    try std.testing.expect(sep.equals(sep));
}
```

### DomainSeparator: equals identical

```zig
test "DomainSeparator: equals identical" {
    const a = DomainSeparator.from([_]u8{0xaa} ** SIZE);
    const b = DomainSeparator.from([_]u8{0xaa} ** SIZE);
    try std.testing.expect(a.equals(b));
}
```

### DomainSeparator: equals different

```zig
test "DomainSeparator: equals different" {
    const a = DomainSeparator.from([_]u8{0xaa} ** SIZE);
    const b = DomainSeparator.from([_]u8{0xbb} ** SIZE);
    try std.testing.expect(!a.equals(b));
}
```

### DomainSeparator: isZero true

```zig
test "DomainSeparator: isZero true" {
    const sep = DomainSeparator.ZERO;
    try std.testing.expect(sep.isZero());
}
```

### DomainSeparator: isZero false

```zig
test "DomainSeparator: isZero false" {
    var bytes = [_]u8{0} ** SIZE;
    bytes[0] = 1;
    const sep = DomainSeparator.from(bytes);
    try std.testing.expect(!sep.isZero());
}
```

### DomainSeparator: ZERO constant

```zig
test "DomainSeparator: ZERO constant" {
    const sep = DomainSeparator.ZERO;
    for (sep.bytes) |b| {
        try std.testing.expectEqual(@as(u8, 0), b);
    }
}
```
