---
title: '[Zig] src/primitives/Blob/blob.zig'
source: 'src/primitives/Blob/blob.zig'
---

> Auto-generated from Zig tests in: src/primitives/Blob/blob.zig

### commitment to versioned hash

```zig
test "commitment to versioned hash" {
    const commitment: BlobCommitment = [_]u8{0x12} ** 48;
    const versioned_hash = commitmentToVersionedHash(commitment);

    // Should start with version byte
    try testing.expectEqual(BLOB_COMMITMENT_VERSION_KZG, versioned_hash.bytes[0]);

    // Should be valid
    try testing.expect(isValidVersionedHash(versioned_hash));
}
```

### invalid versioned hash

```zig
test "invalid versioned hash" {
    var h: VersionedHash = undefined;
    h.bytes = [_]u8{0x00} ** 32;
    h.bytes[0] = 0x02; // Invalid version

    try testing.expect(!isValidVersionedHash(h));
}
```

### blob gas price calculation

```zig
test "blob gas price calculation" {
    // Test with no excess gas
    const price_zero = calculateBlobGasPrice(0);
    try testing.expectEqual(@as(u64, 1), price_zero); // MIN_BLOB_BASE_FEE

    // Test with some excess gas
    const price_low = calculateBlobGasPrice(131072); // 1 blob worth
    try testing.expect(price_low > 1);

    // Test with high excess gas
    const price_high = calculateBlobGasPrice(10 * BLOB_GAS_PER_BLOB);
    try testing.expect(price_high > price_low);
}
```

### excess blob gas calculation

```zig
test "excess blob gas calculation" {
    const target = 393216; // 3 blobs

    // No blobs used, no excess
    var excess = calculateExcessBlobGas(0, 0);
    try testing.expectEqual(@as(u64, 0), excess);

    // Used exactly target
    excess = calculateExcessBlobGas(0, target);
    try testing.expectEqual(@as(u64, 0), excess);

    // Used more than target
    excess = calculateExcessBlobGas(0, target + BLOB_GAS_PER_BLOB);
    try testing.expectEqual(BLOB_GAS_PER_BLOB, excess);

    // With existing excess
    excess = calculateExcessBlobGas(BLOB_GAS_PER_BLOB, target);
    try testing.expectEqual(BLOB_GAS_PER_BLOB, excess);
}
```

### blob transaction validation

```zig
test "blob transaction validation" {
    const hash1 = commitmentToVersionedHash([_]u8{0x01} ** 48);
    const hash2 = commitmentToVersionedHash([_]u8{0x02} ** 48);

    const hashes = [_]VersionedHash{ hash1, hash2 };

    var tx = BlobTransaction{
        .max_fee_per_blob_gas = 1000,
        .blob_versioned_hashes = &hashes,
    };

    // Should be valid
    try tx.validate();

    // Test gas calculations
    try testing.expectEqual(@as(u64, 2 * BLOB_GAS_PER_BLOB), tx.blobGasUsed());
    try testing.expectEqual(@as(u64, 2 * BLOB_GAS_PER_BLOB * 10), tx.blobGasCost(10));
}
```

### blob transaction validation failures

```zig
test "blob transaction validation failures" {
    // No blobs
    var tx = BlobTransaction{
        .max_fee_per_blob_gas = 1000,
        .blob_versioned_hashes = &.{},
    };
    try testing.expectError(BlobError.NoBlobs, tx.validate());

    // Too many blobs
    var many_hashes: [MAX_BLOBS_PER_TRANSACTION + 1]VersionedHash = undefined;
    for (0..many_hashes.len) |i| {
        many_hashes[i] = commitmentToVersionedHash([_]u8{@intCast(i)} ** 48);
    }

    tx = BlobTransaction{
        .max_fee_per_blob_gas = 1000,
        .blob_versioned_hashes = &many_hashes,
    };
    try testing.expectError(BlobError.TooManyBlobs, tx.validate());

    // Invalid versioned hash
    var invalid_hash: VersionedHash = undefined;
    invalid_hash.bytes = [_]u8{0x00} ** 32;
    invalid_hash.bytes[0] = 0xFF; // Invalid version

    tx = BlobTransaction{
        .max_fee_per_blob_gas = 1000,
        .blob_versioned_hashes = &[_]VersionedHash{invalid_hash},
    };
    try testing.expectError(BlobError.InvalidVersionedHash, tx.validate());

    // Zero max fee
    const valid_hash = commitmentToVersionedHash([_]u8{0x01} ** 48);
    tx = BlobTransaction{
        .max_fee_per_blob_gas = 0,
        .blob_versioned_hashes = &[_]VersionedHash{valid_hash},
    };
    try testing.expectError(BlobError.ZeroMaxFeePerBlobGas, tx.validate());
}
```

### blob sidecar

```zig
test "blob sidecar" {
    const sidecar = BlobSidecar{
        .blob = [_]u8{0x00} ** BYTES_PER_BLOB,
        .commitment = [_]u8{0x12} ** 48,
        .proof = [_]u8{0x34} ** 48,
    };

    const h = sidecar.versionedHash();
    try testing.expect(isValidVersionedHash(h));
}
```

### blob gas economics

```zig
test "blob gas economics" {
    // Simulate block progression
    var excess_blob_gas: u64 = 0;

    // Block 1: 4 blobs used (above target)
    var blob_gas_used: u64 = 4 * BLOB_GAS_PER_BLOB;
    var blob_price = calculateBlobGasPrice(excess_blob_gas);
    try testing.expectEqual(@as(u64, 1), blob_price); // Min price initially

    excess_blob_gas = calculateExcessBlobGas(excess_blob_gas, blob_gas_used);
    try testing.expect(excess_blob_gas > 0); // Should increase

    // Block 2: Price should have increased
    blob_price = calculateBlobGasPrice(excess_blob_gas);
    try testing.expect(blob_price > 1);

    // Block 3: Use only 1 blob (below target)
    blob_gas_used = BLOB_GAS_PER_BLOB;
    const old_excess = excess_blob_gas;
    excess_blob_gas = calculateExcessBlobGas(excess_blob_gas, blob_gas_used);
    try testing.expect(excess_blob_gas < old_excess); // Should decrease
}
```

### blob data encoding and decoding

```zig
test "blob data encoding and decoding" {
    const allocator = testing.allocator;

    const test_data = "Hello, blob world!";

    const blob = try encodeBlobData(allocator, test_data);

    const decoded = try decodeBlobData(allocator, blob);
    defer allocator.free(decoded);

    try testing.expectEqualStrings(test_data, decoded);
}
```

### blob data too large

```zig
test "blob data too large" {
    const allocator = testing.allocator;

    const large_data = try allocator.alloc(u8, BYTES_PER_BLOB);
    defer allocator.free(large_data);
    @memset(large_data, 0xFF);

    const result = encodeBlobData(allocator, large_data);
    try testing.expectError(BlobError.DataTooLarge, result);
}
```

### isValidVersionedHash with correct version

```zig
test "isValidVersionedHash with correct version" {
    var h: VersionedHash = undefined;
    h.bytes = [_]u8{0x00} ** 32;
    h.bytes[0] = BLOB_COMMITMENT_VERSION_KZG; // 0x01

    try testing.expect(isValidVersionedHash(h));
}
```

### isValidVersionedHash with version zero

```zig
test "isValidVersionedHash with version zero" {
    var h: VersionedHash = undefined;
    h.bytes = [_]u8{0x00} ** 32;
    h.bytes[0] = 0x00;

    try testing.expect(!isValidVersionedHash(h));
}
```

### isValidVersionedHash with version two

```zig
test "isValidVersionedHash with version two" {
    var h: VersionedHash = undefined;
    h.bytes = [_]u8{0x00} ** 32;
    h.bytes[0] = 0x02;

    try testing.expect(!isValidVersionedHash(h));
}
```

### isValidVersionedHash with max version byte

```zig
test "isValidVersionedHash with max version byte" {
    var h: VersionedHash = undefined;
    h.bytes = [_]u8{0xFF} ** 32;
    h.bytes[0] = 0xFF;

    try testing.expect(!isValidVersionedHash(h));
}
```

### isValidVersionedHash with various invalid versions

```zig
test "isValidVersionedHash with various invalid versions" {
    const invalid_versions = [_]u8{ 0x00, 0x02, 0x03, 0x10, 0xAA, 0xFF };

    for (invalid_versions) |version| {
        var h: VersionedHash = undefined;
        h.bytes = [_]u8{0x00} ** 32;
        h.bytes[0] = version;

        try testing.expect(!isValidVersionedHash(h));
    }
}
```

### calculateBlobGasPrice with zero excess gas

```zig
test "calculateBlobGasPrice with zero excess gas" {
    const price = calculateBlobGasPrice(0);
    try testing.expectEqual(@as(u64, MIN_BLOB_BASE_FEE), price);
}
```

### calculateBlobGasPrice with small excess gas

```zig
test "calculateBlobGasPrice with small excess gas" {
    const price = calculateBlobGasPrice(1000);
    try testing.expect(price >= MIN_BLOB_BASE_FEE);
}
```

### calculateBlobGasPrice with one blob worth of excess

```zig
test "calculateBlobGasPrice with one blob worth of excess" {
    const price = calculateBlobGasPrice(BLOB_GAS_PER_BLOB);
    try testing.expect(price > MIN_BLOB_BASE_FEE);
}
```

### calculateBlobGasPrice with target blob gas

```zig
test "calculateBlobGasPrice with target blob gas" {
    const target = 393216; // 3 * BLOB_GAS_PER_BLOB
    const price = calculateBlobGasPrice(target);
    try testing.expect(price > MIN_BLOB_BASE_FEE);
}
```

### calculateBlobGasPrice monotonically increases

```zig
test "calculateBlobGasPrice monotonically increases" {
    const price1 = calculateBlobGasPrice(0);
    const price2 = calculateBlobGasPrice(BLOB_GAS_PER_BLOB);
    const price3 = calculateBlobGasPrice(2 * BLOB_GAS_PER_BLOB);
    const price4 = calculateBlobGasPrice(10 * BLOB_GAS_PER_BLOB);

    try testing.expect(price2 > price1);
    try testing.expect(price3 > price2);
    try testing.expect(price4 > price3);
}
```

### calculateBlobGasPrice with various excess blob gas values

```zig
test "calculateBlobGasPrice with various excess blob gas values" {
    const test_values = [_]u64{
        0,
        1,
        100,
        1000,
        BLOB_GAS_PER_BLOB,
        BLOB_GAS_PER_BLOB * 2,
        BLOB_GAS_PER_BLOB * 6, // Max blobs worth
        393216, // Target
        393216 * 2, // 2x target
    };

    for (test_values) |excess| {
        const price = calculateBlobGasPrice(excess);
        try testing.expect(price >= MIN_BLOB_BASE_FEE);
    }
}
```

### calculateBlobGasPrice with high excess gas

```zig
test "calculateBlobGasPrice with high excess gas" {
    const price = calculateBlobGasPrice(100 * BLOB_GAS_PER_BLOB);
    try testing.expect(price > calculateBlobGasPrice(10 * BLOB_GAS_PER_BLOB));
}
```

### calculateExcessBlobGas with no excess and no usage

```zig
test "calculateExcessBlobGas with no excess and no usage" {
    const excess = calculateExcessBlobGas(0, 0);
    try testing.expectEqual(@as(u64, 0), excess);
}
```

### calculateExcessBlobGas with no excess and below target usage

```zig
test "calculateExcessBlobGas with no excess and below target usage" {
    const target = 393216;
    const excess = calculateExcessBlobGas(0, target - 1);
    try testing.expectEqual(@as(u64, 0), excess);
}
```

### calculateExcessBlobGas with no excess at exact target

```zig
test "calculateExcessBlobGas with no excess at exact target" {
    const target = 393216;
    const excess = calculateExcessBlobGas(0, target);
    try testing.expectEqual(@as(u64, 0), excess);
}
```

### calculateExcessBlobGas with no excess above target

```zig
test "calculateExcessBlobGas with no excess above target" {
    const target = 393216;
    const excess = calculateExcessBlobGas(0, target + 1);
    try testing.expectEqual(@as(u64, 1), excess);
}
```

### calculateExcessBlobGas with existing excess below target usage

```zig
test "calculateExcessBlobGas with existing excess below target usage" {
    const existing_excess = BLOB_GAS_PER_BLOB;
    const usage = BLOB_GAS_PER_BLOB; // Total < target

    const excess = calculateExcessBlobGas(existing_excess, usage);
    try testing.expectEqual(@as(u64, 0), excess);
}
```

### calculateExcessBlobGas with existing excess at target

```zig
test "calculateExcessBlobGas with existing excess at target" {
    const existing_excess = BLOB_GAS_PER_BLOB;
    const usage = 393216 - existing_excess;

    const excess = calculateExcessBlobGas(existing_excess, usage);
    try testing.expectEqual(@as(u64, 0), excess);
}
```

### calculateExcessBlobGas with existing excess above target

```zig
test "calculateExcessBlobGas with existing excess above target" {
    const existing_excess = BLOB_GAS_PER_BLOB;
    const usage = 393216;

    const excess = calculateExcessBlobGas(existing_excess, usage);
    try testing.expectEqual(existing_excess, excess);
}
```

### calculateExcessBlobGas rollover accumulation

```zig
test "calculateExcessBlobGas rollover accumulation" {
    // Start with no excess
    var excess: u64 = 0;

    // Use 6 blobs (max) - above target
    excess = calculateExcessBlobGas(excess, 6 * BLOB_GAS_PER_BLOB);
    try testing.expect(excess > 0);

    // Use another 6 blobs - should accumulate
    const prev_excess = excess;
    excess = calculateExcessBlobGas(excess, 6 * BLOB_GAS_PER_BLOB);
    try testing.expect(excess > prev_excess);
}
```

### calculateExcessBlobGas boundary at target minus one

```zig
test "calculateExcessBlobGas boundary at target minus one" {
    const target = 393216;
    const excess = calculateExcessBlobGas(0, target - 1);
    try testing.expectEqual(@as(u64, 0), excess);
}
```

### calculateExcessBlobGas boundary at target plus one

```zig
test "calculateExcessBlobGas boundary at target plus one" {
    const target = 393216;
    const excess = calculateExcessBlobGas(0, target + 1);
    try testing.expectEqual(@as(u64, 1), excess);
}
```

### fakeExponential with zero numerator

```zig
test "fakeExponential with zero numerator" {
    const result = fakeExponential(MIN_BLOB_BASE_FEE, 0, BLOB_BASE_FEE_UPDATE_FRACTION);
    try testing.expectEqual(@as(u64, MIN_BLOB_BASE_FEE), result);
}
```

### fakeExponential approximation accuracy small values

```zig
test "fakeExponential approximation accuracy small values" {
    // For small values, should approximate e^x well
    const result = fakeExponential(1, 1000, BLOB_BASE_FEE_UPDATE_FRACTION);
    try testing.expect(result >= 1);
}
```

### fakeExponential does not overflow

```zig
test "fakeExponential does not overflow" {
    // Test with large values that could overflow
    const result = fakeExponential(MIN_BLOB_BASE_FEE, 1000000, BLOB_BASE_FEE_UPDATE_FRACTION);
    try testing.expect(result > MIN_BLOB_BASE_FEE);
}
```

### fakeExponential iteration limit

```zig
test "fakeExponential iteration limit" {
    // Ensure iteration limit prevents infinite loop
    const result = fakeExponential(1, 100000000, 1);
    try testing.expect(result > 0);
}
```

### fakeExponential consistency with calculateBlobGasPrice

```zig
test "fakeExponential consistency with calculateBlobGasPrice" {
    // Verify that calculateBlobGasPrice uses fakeExponential correctly
    const excess = BLOB_GAS_PER_BLOB;
    const price = calculateBlobGasPrice(excess);
    const direct = fakeExponential(MIN_BLOB_BASE_FEE, excess, BLOB_BASE_FEE_UPDATE_FRACTION);
    try testing.expectEqual(direct, price);
}
```

### BlobTransaction validate with single valid blob

```zig
test "BlobTransaction validate with single valid blob" {
    const hash = commitmentToVersionedHash([_]u8{0x01} ** 48);
    const hashes = [_]VersionedHash{hash};

    const tx = BlobTransaction{
        .max_fee_per_blob_gas = 1,
        .blob_versioned_hashes = &hashes,
    };

    try tx.validate();
}
```

### BlobTransaction validate with max blobs exactly

```zig
test "BlobTransaction validate with max blobs exactly" {
    var hashes: [MAX_BLOBS_PER_TRANSACTION]VersionedHash = undefined;
    for (0..MAX_BLOBS_PER_TRANSACTION) |i| {
        hashes[i] = commitmentToVersionedHash([_]u8{@intCast(i + 1)} ** 48);
    }

    const tx = BlobTransaction{
        .max_fee_per_blob_gas = 1,
        .blob_versioned_hashes = &hashes,
    };

    try tx.validate();
}
```

### BlobTransaction validate fails with zero blobs

```zig
test "BlobTransaction validate fails with zero blobs" {
    const tx = BlobTransaction{
        .max_fee_per_blob_gas = 1,
        .blob_versioned_hashes = &.{},
    };

    try testing.expectError(BlobError.NoBlobs, tx.validate());
}
```

### BlobTransaction validate fails with max blobs plus one

```zig
test "BlobTransaction validate fails with max blobs plus one" {
    var hashes: [MAX_BLOBS_PER_TRANSACTION + 1]VersionedHash = undefined;
    for (0..hashes.len) |i| {
        hashes[i] = commitmentToVersionedHash([_]u8{@intCast(i + 1)} ** 48);
    }

    const tx = BlobTransaction{
        .max_fee_per_blob_gas = 1,
        .blob_versioned_hashes = &hashes,
    };

    try testing.expectError(BlobError.TooManyBlobs, tx.validate());
}
```

### BlobTransaction validate fails with many blobs

```zig
test "BlobTransaction validate fails with many blobs" {
    var hashes: [100]VersionedHash = undefined;
    for (0..hashes.len) |i| {
        hashes[i] = commitmentToVersionedHash([_]u8{@intCast((i % 255) + 1)} ** 48);
    }

    const tx = BlobTransaction{
        .max_fee_per_blob_gas = 1,
        .blob_versioned_hashes = &hashes,
    };

    try testing.expectError(BlobError.TooManyBlobs, tx.validate());
}
```

### BlobTransaction validate fails with invalid versioned hash in middle

```zig
test "BlobTransaction validate fails with invalid versioned hash in middle" {
    const valid_hash1 = commitmentToVersionedHash([_]u8{0x01} ** 48);
    var invalid_hash: VersionedHash = undefined;
    invalid_hash.bytes = [_]u8{0x00} ** 32;
    invalid_hash.bytes[0] = 0x00; // Invalid version
    const valid_hash2 = commitmentToVersionedHash([_]u8{0x02} ** 48);

    const hashes = [_]VersionedHash{ valid_hash1, invalid_hash, valid_hash2 };

    const tx = BlobTransaction{
        .max_fee_per_blob_gas = 1,
        .blob_versioned_hashes = &hashes,
    };

    try testing.expectError(BlobError.InvalidVersionedHash, tx.validate());
}
```

### BlobTransaction validate fails with zero max fee

```zig
test "BlobTransaction validate fails with zero max fee" {
    const hash = commitmentToVersionedHash([_]u8{0x01} ** 48);
    const hashes = [_]VersionedHash{hash};

    const tx = BlobTransaction{
        .max_fee_per_blob_gas = 0,
        .blob_versioned_hashes = &hashes,
    };

    try testing.expectError(BlobError.ZeroMaxFeePerBlobGas, tx.validate());
}
```

### BlobTransaction validate succeeds with minimal max fee

```zig
test "BlobTransaction validate succeeds with minimal max fee" {
    const hash = commitmentToVersionedHash([_]u8{0x01} ** 48);
    const hashes = [_]VersionedHash{hash};

    const tx = BlobTransaction{
        .max_fee_per_blob_gas = 1,
        .blob_versioned_hashes = &hashes,
    };

    try tx.validate();
}
```

### BlobTransaction validate succeeds with high max fee

```zig
test "BlobTransaction validate succeeds with high max fee" {
    const hash = commitmentToVersionedHash([_]u8{0x01} ** 48);
    const hashes = [_]VersionedHash{hash};

    const tx = BlobTransaction{
        .max_fee_per_blob_gas = 999999999999,
        .blob_versioned_hashes = &hashes,
    };

    try tx.validate();
}
```

### max blob count is six

```zig
test "max blob count is six" {
    try testing.expectEqual(@as(usize, 6), MAX_BLOBS_PER_TRANSACTION);
}
```

### BlobTransaction with exactly max blobs is valid

```zig
test "BlobTransaction with exactly max blobs is valid" {
    var hashes: [MAX_BLOBS_PER_TRANSACTION]VersionedHash = undefined;
    for (0..MAX_BLOBS_PER_TRANSACTION) |i| {
        hashes[i] = commitmentToVersionedHash([_]u8{@intCast(i + 1)} ** 48);
    }

    const tx = BlobTransaction{
        .max_fee_per_blob_gas = 100,
        .blob_versioned_hashes = &hashes,
    };

    try tx.validate();
    try testing.expectEqual(@as(u64, 6 * BLOB_GAS_PER_BLOB), tx.blobGasUsed());
}
```

### BlobTransaction gas calculations with max blobs

```zig
test "BlobTransaction gas calculations with max blobs" {
    var hashes: [MAX_BLOBS_PER_TRANSACTION]VersionedHash = undefined;
    for (0..MAX_BLOBS_PER_TRANSACTION) |i| {
        hashes[i] = commitmentToVersionedHash([_]u8{@intCast(i + 1)} ** 48);
    }

    const tx = BlobTransaction{
        .max_fee_per_blob_gas = 100,
        .blob_versioned_hashes = &hashes,
    };

    const expected_gas = 6 * BLOB_GAS_PER_BLOB;
    try testing.expectEqual(expected_gas, tx.blobGasUsed());

    const blob_base_fee: u64 = 50;
    const expected_cost = expected_gas * blob_base_fee;
    try testing.expectEqual(expected_cost, tx.blobGasCost(blob_base_fee));
}
```

### blob gas calculation boundary with one blob

```zig
test "blob gas calculation boundary with one blob" {
    const hash = commitmentToVersionedHash([_]u8{0x01} ** 48);
    const hashes = [_]VersionedHash{hash};

    const tx = BlobTransaction{
        .max_fee_per_blob_gas = 1,
        .blob_versioned_hashes = &hashes,
    };

    try testing.expectEqual(BLOB_GAS_PER_BLOB, tx.blobGasUsed());
}
```

### blob gas calculation boundary with two blobs

```zig
test "blob gas calculation boundary with two blobs" {
    const hash1 = commitmentToVersionedHash([_]u8{0x01} ** 48);
    const hash2 = commitmentToVersionedHash([_]u8{0x02} ** 48);
    const hashes = [_]VersionedHash{ hash1, hash2 };

    const tx = BlobTransaction{
        .max_fee_per_blob_gas = 1,
        .blob_versioned_hashes = &hashes,
    };

    try testing.expectEqual(@as(u64, 2 * BLOB_GAS_PER_BLOB), tx.blobGasUsed());
}
```

### excess blob gas at target boundary minus one blob

```zig
test "excess blob gas at target boundary minus one blob" {
    const target = 393216;
    const excess = calculateExcessBlobGas(0, target - BLOB_GAS_PER_BLOB);
    try testing.expectEqual(@as(u64, 0), excess);
}
```

### excess blob gas at target boundary plus one blob

```zig
test "excess blob gas at target boundary plus one blob" {
    const target = 393216;
    const excess = calculateExcessBlobGas(0, target + BLOB_GAS_PER_BLOB);
    try testing.expectEqual(BLOB_GAS_PER_BLOB, excess);
}
```

### blob price at target boundary

```zig
test "blob price at target boundary" {
    const target = 393216;

    // Price with zero excess
    const price_zero = calculateBlobGasPrice(0);

    // Price with target excess
    const price_target = calculateBlobGasPrice(target);

    try testing.expect(price_target > price_zero);
}
```

### blob gas cost calculation with zero base fee

```zig
test "blob gas cost calculation with zero base fee" {
    const hash = commitmentToVersionedHash([_]u8{0x01} ** 48);
    const hashes = [_]VersionedHash{hash};

    const tx = BlobTransaction{
        .max_fee_per_blob_gas = 100,
        .blob_versioned_hashes = &hashes,
    };

    const cost = tx.blobGasCost(0);
    try testing.expectEqual(@as(u64, 0), cost);
}
```

### blob gas cost calculation with high base fee

```zig
test "blob gas cost calculation with high base fee" {
    const hash = commitmentToVersionedHash([_]u8{0x01} ** 48);
    const hashes = [_]VersionedHash{hash};

    const tx = BlobTransaction{
        .max_fee_per_blob_gas = 1000000,
        .blob_versioned_hashes = &hashes,
    };

    const base_fee: u64 = 1000000;
    const expected = BLOB_GAS_PER_BLOB * base_fee;
    const cost = tx.blobGasCost(base_fee);
    try testing.expectEqual(expected, cost);
}
```

### gas price with maximum practical excess

```zig
test "gas price with maximum practical excess" {
    // Test with very high excess (100 blobs worth)
    const high_excess = 100 * BLOB_GAS_PER_BLOB;
    const price = calculateBlobGasPrice(high_excess);
    try testing.expect(price > MIN_BLOB_BASE_FEE);
}
```

### gas price progression with incremental excess

```zig
test "gas price progression with incremental excess" {
    var excess: u64 = 0;
    var prev_price = calculateBlobGasPrice(excess);

    for (0..10) |_| {
        excess += BLOB_GAS_PER_BLOB;
        const price = calculateBlobGasPrice(excess);
        try testing.expect(price >= prev_price); // Should never decrease
        prev_price = price;
    }
}
```

### blob transaction cost realistic scenario

```zig
test "blob transaction cost realistic scenario" {
    const hash1 = commitmentToVersionedHash([_]u8{0x01} ** 48);
    const hash2 = commitmentToVersionedHash([_]u8{0x02} ** 48);
    const hash3 = commitmentToVersionedHash([_]u8{0x03} ** 48);
    const hashes = [_]VersionedHash{ hash1, hash2, hash3 };

    const tx = BlobTransaction{
        .max_fee_per_blob_gas = 1000000,
        .blob_versioned_hashes = &hashes,
    };

    try tx.validate();

    // Calculate gas with current excess
    const excess_blob_gas: u64 = BLOB_GAS_PER_BLOB * 2;
    const blob_base_fee = calculateBlobGasPrice(excess_blob_gas);
    const total_cost = tx.blobGasCost(blob_base_fee);

    // Verify cost is reasonable
    try testing.expect(total_cost > 0);
    try testing.expectEqual(@as(u64, 3 * BLOB_GAS_PER_BLOB), tx.blobGasUsed());
}
```

### excess blob gas converges to zero with low usage

```zig
test "excess blob gas converges to zero with low usage" {
    var excess: u64 = 10 * BLOB_GAS_PER_BLOB; // Start high

    // Use 1 blob per block (well below target of 3)
    for (0..20) |_| {
        const prev_excess = excess;
        excess = calculateExcessBlobGas(excess, BLOB_GAS_PER_BLOB);

        if (excess > 0) {
            try testing.expect(excess <= prev_excess); // Should decrease or stay zero
        }
    }

    // Should eventually reach zero
    try testing.expectEqual(@as(u64, 0), excess);
}
```

### isValid with correct size

```zig
test "isValid with correct size" {
    const blob: Blob = [_]u8{0x00} ** BYTES_PER_BLOB;
    try testing.expect(isValid(&blob));
}
```

### isValid with wrong size too small

```zig
test "isValid with wrong size too small" {
    const blob = [_]u8{0x00} ** (BYTES_PER_BLOB - 1);
    try testing.expect(!isValid(&blob));
}
```

### isValid with wrong size too large

```zig
test "isValid with wrong size too large" {
    const blob = [_]u8{0x00} ** (BYTES_PER_BLOB + 1);
    try testing.expect(!isValid(&blob));
}
```

### isValid with zero size

```zig
test "isValid with zero size" {
    const blob = [_]u8{};
    try testing.expect(!isValid(&blob));
}
```

### estimateBlobCount with zero data

```zig
test "estimateBlobCount with zero data" {
    const count = estimateBlobCount(0);
    try testing.expectEqual(@as(usize, 0), count);
}
```

### estimateBlobCount with small data

```zig
test "estimateBlobCount with small data" {
    const count = estimateBlobCount(100);
    try testing.expectEqual(@as(usize, 1), count);
}
```

### estimateBlobCount at exact boundary

```zig
test "estimateBlobCount at exact boundary" {
    const max_per_blob = BYTES_PER_BLOB - 8;
    const count = estimateBlobCount(max_per_blob);
    try testing.expectEqual(@as(usize, 1), count);
}
```

### estimateBlobCount just over boundary

```zig
test "estimateBlobCount just over boundary" {
    const max_per_blob = BYTES_PER_BLOB - 8;
    const count = estimateBlobCount(max_per_blob + 1);
    try testing.expectEqual(@as(usize, 2), count);
}
```

### estimateBlobCount multiple blobs

```zig
test "estimateBlobCount multiple blobs" {
    const max_per_blob = BYTES_PER_BLOB - 8;
    const count = estimateBlobCount(max_per_blob * 3 + 1000);
    try testing.expectEqual(@as(usize, 4), count);
}
```

### calculateGas with zero blobs

```zig
test "calculateGas with zero blobs" {
    const gas = try calculateGas(0);
    try testing.expectEqual(@as(u64, 0), gas);
}
```

### calculateGas with one blob

```zig
test "calculateGas with one blob" {
    const gas = try calculateGas(1);
    try testing.expectEqual(BLOB_GAS_PER_BLOB, gas);
}
```

### calculateGas with max blobs

```zig
test "calculateGas with max blobs" {
    const gas = try calculateGas(MAX_BLOBS_PER_TRANSACTION);
    try testing.expectEqual(@as(u64, MAX_BLOBS_PER_TRANSACTION * BLOB_GAS_PER_BLOB), gas);
}
```

### calculateGas fails with too many blobs

```zig
test "calculateGas fails with too many blobs" {
    const result = calculateGas(MAX_BLOBS_PER_TRANSACTION + 1);
    try testing.expectError(BlobError.TooManyBlobs, result);
}
```

### calculateGas with multiple blobs

```zig
test "calculateGas with multiple blobs" {
    const gas = try calculateGas(3);
    try testing.expectEqual(@as(u64, 3 * BLOB_GAS_PER_BLOB), gas);
}
```

### splitData and joinData round trip small data

```zig
test "splitData and joinData round trip small data" {
    const allocator = testing.allocator;
    const data = "Hello, blob world!";

    const blobs = try splitData(allocator, data);
    defer allocator.free(blobs);

    const recovered = try joinData(allocator, blobs);
    defer allocator.free(recovered);

    try testing.expectEqualStrings(data, recovered);
}
```

### splitData and joinData round trip large data

```zig
test "splitData and joinData round trip large data" {
    const allocator = testing.allocator;
    const max_per_blob = BYTES_PER_BLOB - 8;
    const data_size = max_per_blob * 2 + 1000;

    const data = try allocator.alloc(u8, data_size);
    defer allocator.free(data);

    for (data, 0..) |*b, i| {
        b.* = @intCast(i % 256);
    }

    const blobs = try splitData(allocator, data);
    defer allocator.free(blobs);

    try testing.expectEqual(@as(usize, 3), blobs.len);

    const recovered = try joinData(allocator, blobs);
    defer allocator.free(recovered);

    try testing.expectEqualSlices(u8, data, recovered);
}
```

### splitData at exact boundary

```zig
test "splitData at exact boundary" {
    const allocator = testing.allocator;
    const max_per_blob = BYTES_PER_BLOB - 8;

    const data = try allocator.alloc(u8, max_per_blob);
    defer allocator.free(data);
    @memset(data, 0x42);

    const blobs = try splitData(allocator, data);
    defer allocator.free(blobs);

    try testing.expectEqual(@as(usize, 1), blobs.len);

    const recovered = try joinData(allocator, blobs);
    defer allocator.free(recovered);

    try testing.expectEqualSlices(u8, data, recovered);
}
```

### splitData just over boundary

```zig
test "splitData just over boundary" {
    const allocator = testing.allocator;
    const max_per_blob = BYTES_PER_BLOB - 8;

    const data = try allocator.alloc(u8, max_per_blob + 1);
    defer allocator.free(data);
    @memset(data, 0x33);

    const blobs = try splitData(allocator, data);
    defer allocator.free(blobs);

    try testing.expectEqual(@as(usize, 2), blobs.len);

    const recovered = try joinData(allocator, blobs);
    defer allocator.free(recovered);

    try testing.expectEqualSlices(u8, data, recovered);
}
```

### splitData fails with too many blobs needed

```zig
test "splitData fails with too many blobs needed" {
    const allocator = testing.allocator;
    const max_per_blob = BYTES_PER_BLOB - 8;
    const data_size = max_per_blob * (MAX_BLOBS_PER_TRANSACTION + 1);

    const data = try allocator.alloc(u8, data_size);
    defer allocator.free(data);

    const result = splitData(allocator, data);
    try testing.expectError(BlobError.TooManyBlobs, result);
}
```

### splitData empty data

```zig
test "splitData empty data" {
    const allocator = testing.allocator;
    const data = [_]u8{};

    const blobs = try splitData(allocator, &data);
    defer allocator.free(blobs);

    try testing.expectEqual(@as(usize, 0), blobs.len);

    const recovered = try joinData(allocator, blobs);
    defer allocator.free(recovered);

    try testing.expectEqual(@as(usize, 0), recovered.len);
}
```

### splitData max blobs exactly

```zig
test "splitData max blobs exactly" {
    const allocator = testing.allocator;
    const max_per_blob = BYTES_PER_BLOB - 8;
    const data_size = max_per_blob * MAX_BLOBS_PER_TRANSACTION;

    const data = try allocator.alloc(u8, data_size);
    defer allocator.free(data);

    for (data, 0..) |*b, i| {
        b.* = @intCast(i % 256);
    }

    const blobs = try splitData(allocator, data);
    defer allocator.free(blobs);

    try testing.expectEqual(@as(usize, MAX_BLOBS_PER_TRANSACTION), blobs.len);

    const recovered = try joinData(allocator, blobs);
    defer allocator.free(recovered);

    try testing.expectEqualSlices(u8, data, recovered);
}
```

### joinData preserves data boundaries

```zig
test "joinData preserves data boundaries" {
    const allocator = testing.allocator;
    const max_per_blob = BYTES_PER_BLOB - 8;
    const data_size = max_per_blob * 2;

    const data = try allocator.alloc(u8, data_size);
    defer allocator.free(data);

    // Mark boundaries
    data[0] = 0x01; // Start of first blob
    data[max_per_blob - 1] = 0x02; // End of first blob
    data[max_per_blob] = 0x03; // Start of second blob
    data[data_size - 1] = 0x04; // End of second blob

    const blobs = try splitData(allocator, data);
    defer allocator.free(blobs);

    const recovered = try joinData(allocator, blobs);
    defer allocator.free(recovered);

    try testing.expectEqual(@as(u8, 0x01), recovered[0]);
    try testing.expectEqual(@as(u8, 0x02), recovered[max_per_blob - 1]);
    try testing.expectEqual(@as(u8, 0x03), recovered[max_per_blob]);
    try testing.expectEqual(@as(u8, 0x04), recovered[data_size - 1]);
}
```
