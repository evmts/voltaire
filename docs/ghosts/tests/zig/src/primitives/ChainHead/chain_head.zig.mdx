---
title: '[Zig] src/primitives/ChainHead/chain_head.zig'
source: 'src/primitives/ChainHead/chain_head.zig'
---

> Auto-generated from Zig tests in: src/primitives/ChainHead/chain_head.zig

### ChainHead.from creates chain head

```zig
test "ChainHead.from creates chain head" {
    const hash: BlockHash.BlockHash = [_]u8{0xab} ** 32;
    const head = from(.{
        .number = 18000000,
        .hash = hash,
        .timestamp = 1699000000,
    });

    try std.testing.expectEqual(@as(BlockNumber.BlockNumber, 18000000), head.number);
    try std.testing.expectEqual(@as(u256, 1699000000), head.timestamp);
}
```

### ChainHead.fromFields creates chain head

```zig
test "ChainHead.fromFields creates chain head" {
    const hash: BlockHash.BlockHash = [_]u8{0xcd} ** 32;
    const head = fromFields(18000000, hash, 1699000000);

    try std.testing.expectEqual(@as(BlockNumber.BlockNumber, 18000000), head.number);
    try std.testing.expect(head.difficulty == null);
}
```

### ChainHead.fromFieldsWithDifficulty creates chain head

```zig
test "ChainHead.fromFieldsWithDifficulty creates chain head" {
    const hash: BlockHash.BlockHash = [_]u8{0xef} ** 32;
    const head = fromFieldsWithDifficulty(
        15000000,
        hash,
        1680000000,
        0, // post-merge
        58750003716598352816469,
    );

    try std.testing.expect(head.difficulty != null);
    try std.testing.expectEqual(@as(u256, 0), head.difficulty.?);
    try std.testing.expect(head.total_difficulty != null);
}
```

### ChainHead.isPostMerge detects post-merge blocks

```zig
test "ChainHead.isPostMerge detects post-merge blocks" {
    const hash: BlockHash.BlockHash = [_]u8{0x11} ** 32;

    // Post-merge (difficulty = 0)
    const post_merge = from(.{
        .number = 18000000,
        .hash = hash,
        .timestamp = 1699000000,
        .difficulty = 0,
    });
    try std.testing.expect(isPostMerge(post_merge));

    // Pre-merge (difficulty > 0)
    const pre_merge = from(.{
        .number = 15000000,
        .hash = hash,
        .timestamp = 1680000000,
        .difficulty = 13000000000000000,
    });
    try std.testing.expect(!isPostMerge(pre_merge));

    // No difficulty set (assume post-merge)
    const no_difficulty = from(.{
        .number = 18000000,
        .hash = hash,
        .timestamp = 1699000000,
    });
    try std.testing.expect(isPostMerge(no_difficulty));
}
```

### ChainHead.equals compares chain heads

```zig
test "ChainHead.equals compares chain heads" {
    const hash1: BlockHash.BlockHash = [_]u8{0x22} ** 32;
    const hash2: BlockHash.BlockHash = [_]u8{0x33} ** 32;

    const head1 = from(.{
        .number = 18000000,
        .hash = hash1,
        .timestamp = 1699000000,
    });

    const head2 = from(.{
        .number = 18000000,
        .hash = hash1,
        .timestamp = 1699000000,
    });

    const head3 = from(.{
        .number = 18000001,
        .hash = hash2,
        .timestamp = 1699000012,
    });

    try std.testing.expect(equals(head1, head2));
    try std.testing.expect(!equals(head1, head3));
}
```

### ChainHead accessors work correctly

```zig
test "ChainHead accessors work correctly" {
    const hash: BlockHash.BlockHash = [_]u8{0x44} ** 32;
    const head = from(.{
        .number = 18000000,
        .hash = hash,
        .timestamp = 1699000000,
        .difficulty = 0,
        .total_difficulty = 58750003716598352816469,
    });

    try std.testing.expectEqual(@as(BlockNumber.BlockNumber, 18000000), getNumber(head));
    try std.testing.expectEqualSlices(u8, &hash, &getHash(head));
    try std.testing.expectEqual(@as(u256, 1699000000), getTimestamp(head));
    try std.testing.expect(getDifficulty(head) != null);
    try std.testing.expect(getTotalDifficulty(head) != null);
}
```

### ChainHead.toJson encodes correctly

```zig
test "ChainHead.toJson encodes correctly" {
    const allocator = std.testing.allocator;
    const hash: BlockHash.BlockHash = [_]u8{0xab} ** 32;
    const head = from(.{
        .number = 18000000,
        .hash = hash,
        .timestamp = 1699000000,
    });

    const json_str = try toJson(head, allocator);
    defer allocator.free(json_str);

    try std.testing.expect(std.mem.indexOf(u8, json_str, "\"number\":\"0x") != null);
    try std.testing.expect(std.mem.indexOf(u8, json_str, "\"hash\":\"0x") != null);
    try std.testing.expect(std.mem.indexOf(u8, json_str, "\"timestamp\":\"0x") != null);
}
```

### ChainHead.fromJson decodes correctly

```zig
test "ChainHead.fromJson decodes correctly" {
    const allocator = std.testing.allocator;
    const json_str =
        \\{"number":"0x112a880","hash":"0xabababababababababababababababababababababababababababababababab","timestamp":"0x654d4740"}
    ;

    const head = try fromJson(allocator, json_str);

    try std.testing.expectEqual(@as(u64, 18000000), head.number);
    try std.testing.expectEqual(@as(u256, 1699000000), head.timestamp);
    try std.testing.expectEqual(@as(u8, 0xab), head.hash[0]);
}
```

### ChainHead JSON roundtrip

```zig
test "ChainHead JSON roundtrip" {
    const allocator = std.testing.allocator;
    const hash: BlockHash.BlockHash = [_]u8{0xcd} ** 32;
    const original = from(.{
        .number = 15000000,
        .hash = hash,
        .timestamp = 1680000000,
        .difficulty = 0,
    });

    const json_str = try toJson(original, allocator);
    defer allocator.free(json_str);

    const decoded = try fromJson(allocator, json_str);

    try std.testing.expectEqual(original.number, decoded.number);
    try std.testing.expectEqual(original.timestamp, decoded.timestamp);
    try std.testing.expectEqualSlices(u8, &original.hash, &decoded.hash);
}
```

### BeaconChainHead.beaconFrom creates beacon head

```zig
test "BeaconChainHead.beaconFrom creates beacon head" {
    const block: [32]u8 = [_]u8{0xaa} ** 32;
    const state: [32]u8 = [_]u8{0xbb} ** 32;
    const head = beaconFrom(.{
        .slot = 7000000,
        .block = block,
        .state = state,
    });

    try std.testing.expectEqual(@as(u64, 7000000), head.slot);
    try std.testing.expectEqualSlices(u8, &block, &head.block);
    try std.testing.expectEqualSlices(u8, &state, &head.state);
}
```

### BeaconChainHead.beaconFromFields creates beacon head

```zig
test "BeaconChainHead.beaconFromFields creates beacon head" {
    const block: [32]u8 = [_]u8{0xcc} ** 32;
    const state: [32]u8 = [_]u8{0xdd} ** 32;
    const head = beaconFromFields(8000000, block, state);

    try std.testing.expectEqual(@as(u64, 8000000), head.slot);
}
```

### BeaconChainHead.beaconEquals compares beacon heads

```zig
test "BeaconChainHead.beaconEquals compares beacon heads" {
    const block1: [32]u8 = [_]u8{0x11} ** 32;
    const state1: [32]u8 = [_]u8{0x22} ** 32;
    const block2: [32]u8 = [_]u8{0x33} ** 32;
    const state2: [32]u8 = [_]u8{0x44} ** 32;

    const head1 = beaconFrom(.{ .slot = 7000000, .block = block1, .state = state1 });
    const head2 = beaconFrom(.{ .slot = 7000000, .block = block1, .state = state1 });
    const head3 = beaconFrom(.{ .slot = 7000001, .block = block2, .state = state2 });

    try std.testing.expect(beaconEquals(head1, head2));
    try std.testing.expect(!beaconEquals(head1, head3));
}
```

### BeaconChainHead.beaconToJson encodes correctly

```zig
test "BeaconChainHead.beaconToJson encodes correctly" {
    const allocator = std.testing.allocator;
    const block: [32]u8 = [_]u8{0xab} ** 32;
    const state: [32]u8 = [_]u8{0xcd} ** 32;
    const head = beaconFrom(.{
        .slot = 7000000,
        .block = block,
        .state = state,
    });

    const json_str = try beaconToJson(head, allocator);
    defer allocator.free(json_str);

    try std.testing.expect(std.mem.indexOf(u8, json_str, "\"slot\":\"7000000\"") != null);
    try std.testing.expect(std.mem.indexOf(u8, json_str, "\"block\":\"0x") != null);
    try std.testing.expect(std.mem.indexOf(u8, json_str, "\"state\":\"0x") != null);
}
```

### BeaconChainHead.beaconFromJson decodes correctly

```zig
test "BeaconChainHead.beaconFromJson decodes correctly" {
    const allocator = std.testing.allocator;
    const json_str =
        \\{"slot":"7000000","block":"0xabababababababababababababababababababababababababababababababab","state":"0xcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcd"}
    ;

    const head = try beaconFromJson(allocator, json_str);

    try std.testing.expectEqual(@as(u64, 7000000), head.slot);
    try std.testing.expectEqual(@as(u8, 0xab), head.block[0]);
    try std.testing.expectEqual(@as(u8, 0xcd), head.state[0]);
}
```

### BeaconChainHead JSON roundtrip

```zig
test "BeaconChainHead JSON roundtrip" {
    const allocator = std.testing.allocator;
    const block: [32]u8 = [_]u8{0xef} ** 32;
    const state: [32]u8 = [_]u8{0x12} ** 32;
    const original = beaconFrom(.{
        .slot = 9000000,
        .block = block,
        .state = state,
    });

    const json_str = try beaconToJson(original, allocator);
    defer allocator.free(json_str);

    const decoded = try beaconFromJson(allocator, json_str);

    try std.testing.expectEqual(original.slot, decoded.slot);
    try std.testing.expectEqualSlices(u8, &original.block, &decoded.block);
    try std.testing.expectEqualSlices(u8, &original.state, &decoded.state);
}
```
