---
title: '[Zig] src/primitives/TransactionIndex/TransactionIndex.zig'
source: 'src/primitives/TransactionIndex/TransactionIndex.zig'
---

> Auto-generated from Zig tests in: src/primitives/TransactionIndex/TransactionIndex.zig

### from creates index

```zig
test "from creates index" {
    const idx = from(10);
    try std.testing.expectEqual(10, idx);
}
```

### from handles zero

```zig
test "from handles zero" {
    const idx = from(0);
    try std.testing.expectEqual(0, idx);
}
```

### from handles max u64

```zig
test "from handles max u64" {
    const idx = from(std.math.maxInt(u64));
    try std.testing.expectEqual(std.math.maxInt(u64), idx);
}
```

### fromHex parses prefixed hex

```zig
test "fromHex parses prefixed hex" {
    const idx = try fromHex("0x10");
    try std.testing.expectEqual(16, idx);
}
```

### fromHex parses bare hex

```zig
test "fromHex parses bare hex" {
    const idx = try fromHex("ff");
    try std.testing.expectEqual(255, idx);
}
```

### fromHex parses uppercase

```zig
test "fromHex parses uppercase" {
    const idx = try fromHex("0xABCD");
    try std.testing.expectEqual(0xabcd, idx);
}
```

### fromHex parses zero

```zig
test "fromHex parses zero" {
    const idx = try fromHex("0x0");
    try std.testing.expectEqual(0, idx);
}
```

### fromHex parses large value

```zig
test "fromHex parses large value" {
    const idx = try fromHex("0xdeadbeefcafe");
    try std.testing.expectEqual(0xdeadbeefcafe, idx);
}
```

### fromHex rejects empty

```zig
test "fromHex rejects empty" {
    try std.testing.expectError(error.InvalidHex, fromHex(""));
}
```

### fromHex rejects empty after prefix

```zig
test "fromHex rejects empty after prefix" {
    try std.testing.expectError(error.InvalidHex, fromHex("0x"));
}
```

### fromHex rejects invalid char

```zig
test "fromHex rejects invalid char" {
    try std.testing.expectError(error.InvalidHex, fromHex("0xgg"));
}
```

### fromHex rejects overflow

```zig
test "fromHex rejects overflow" {
    try std.testing.expectError(error.Overflow, fromHex("0x10000000000000000")); // > u64 max
}
```

### toNumber converts to u64

```zig
test "toNumber converts to u64" {
    const idx = from(42);
    try std.testing.expectEqual(42, toNumber(idx));
}
```

### toNumber is identity

```zig
test "toNumber is identity" {
    const idx = from(123);
    try std.testing.expectEqual(idx, toNumber(idx));
}
```

### toHex converts zero

```zig
test "toHex converts zero" {
    const idx = from(0);
    const hex = toHex(idx);
    try std.testing.expectEqualStrings("0x0", std.mem.sliceTo(&hex, 0));
}
```

### toHex converts single digit

```zig
test "toHex converts single digit" {
    const idx = from(10);
    const hex = toHex(idx);
    try std.testing.expectEqualStrings("0xa", std.mem.sliceTo(&hex, 0));
}
```

### toHex converts 255

```zig
test "toHex converts 255" {
    const idx = from(255);
    const hex = toHex(idx);
    try std.testing.expectEqualStrings("0xff", std.mem.sliceTo(&hex, 0));
}
```

### toHex converts large value

```zig
test "toHex converts large value" {
    const idx = from(0xcafebabe);
    const hex = toHex(idx);
    try std.testing.expectEqualStrings("0xcafebabe", std.mem.sliceTo(&hex, 0));
}
```

### toHex converts max u64

```zig
test "toHex converts max u64" {
    const idx = from(std.math.maxInt(u64));
    const hex = toHex(idx);
    try std.testing.expectEqualStrings("0xffffffffffffffff", std.mem.sliceTo(&hex, 0));
}
```

### equals returns true for equal indexes

```zig
test "equals returns true for equal indexes" {
    const a = from(10);
    const b = from(10);
    try std.testing.expect(equals(a, b));
}
```

### equals returns false for unequal indexes

```zig
test "equals returns false for unequal indexes" {
    const a = from(10);
    const b = from(11);
    try std.testing.expect(!equals(a, b));
}
```

### equals handles zero

```zig
test "equals handles zero" {
    const a = from(0);
    const b = from(0);
    try std.testing.expect(equals(a, b));
}
```

### compare returns .lt for lesser

```zig
test "compare returns .lt for lesser" {
    const a = from(5);
    const b = from(10);
    try std.testing.expectEqual(std.math.Order.lt, compare(a, b));
}
```

### compare returns .eq for equal

```zig
test "compare returns .eq for equal" {
    const a = from(10);
    const b = from(10);
    try std.testing.expectEqual(std.math.Order.eq, compare(a, b));
}
```

### compare returns .gt for greater

```zig
test "compare returns .gt for greater" {
    const a = from(15);
    const b = from(10);
    try std.testing.expectEqual(std.math.Order.gt, compare(a, b));
}
```

### increment increments by one

```zig
test "increment increments by one" {
    const idx = from(10);
    const next = increment(idx);
    try std.testing.expectEqual(11, next.?);
}
```

### increment handles zero

```zig
test "increment handles zero" {
    const idx = from(0);
    const next = increment(idx);
    try std.testing.expectEqual(1, next.?);
}
```

### increment returns null on overflow

```zig
test "increment returns null on overflow" {
    const idx = from(std.math.maxInt(u64));
    const next = increment(idx);
    try std.testing.expect(next == null);
}
```

### isZero returns true for zero

```zig
test "isZero returns true for zero" {
    try std.testing.expect(isZero(from(0)));
}
```

### isZero returns false for non-zero

```zig
test "isZero returns false for non-zero" {
    try std.testing.expect(!isZero(from(1)));
    try std.testing.expect(!isZero(from(100)));
}
```

### constants

```zig
test "constants" {
    try std.testing.expectEqual(@as(u64, 0), MIN);
    try std.testing.expectEqual(@as(u64, 0), ZERO);
    try std.testing.expectEqual(std.math.maxInt(u64), MAX);
}
```

### fromHex roundtrip with toHex

```zig
test "fromHex roundtrip with toHex" {
    const original = from(0x123456789abc);
    const hex = toHex(original);
    const parsed = try fromHex(std.mem.sliceTo(&hex, 0));
    try std.testing.expectEqual(original, parsed);
}
```
