---
title: '[Zig] src/primitives/Ssz/merkle.zig'
source: 'src/primitives/Ssz/merkle.zig'
---

> Auto-generated from Zig tests in: src/primitives/Ssz/merkle.zig

### chunkify single chunk

```zig
test "chunkify single chunk" {
    const allocator = std.testing.allocator;
    const data = [_]u8{1} ** 16; // Half chunk
    const chunks = try chunkify(allocator, &data);
    defer allocator.free(chunks);

    try std.testing.expectEqual(@as(usize, 1), chunks.len);
    try std.testing.expectEqual(@as(u8, 1), chunks[0][0]);
    try std.testing.expectEqual(@as(u8, 1), chunks[0][15]);
    try std.testing.expectEqual(@as(u8, 0), chunks[0][16]); // padding
    try std.testing.expectEqual(@as(u8, 0), chunks[0][31]); // padding
}
```

### chunkify multiple chunks

```zig
test "chunkify multiple chunks" {
    const allocator = std.testing.allocator;
    const data = [_]u8{0xAA} ** 64; // Two full chunks
    const chunks = try chunkify(allocator, &data);
    defer allocator.free(chunks);

    try std.testing.expectEqual(@as(usize, 2), chunks.len);
    try std.testing.expectEqual(@as(u8, 0xAA), chunks[0][0]);
    try std.testing.expectEqual(@as(u8, 0xAA), chunks[1][31]);
}
```

### hashPair

```zig
test "hashPair" {
    const left = ZERO_HASH;
    const right = ZERO_HASH;
    const result = hashPair(left, right);

    // Hash of two zero hashes should be deterministic
    try std.testing.expect(result[0] != 0 or result[1] != 0); // Not all zeros
}
```

### nextPowerOfTwo

```zig
test "nextPowerOfTwo" {
    try std.testing.expectEqual(@as(usize, 1), nextPowerOfTwo(0));
    try std.testing.expectEqual(@as(usize, 1), nextPowerOfTwo(1));
    try std.testing.expectEqual(@as(usize, 2), nextPowerOfTwo(2));
    try std.testing.expectEqual(@as(usize, 4), nextPowerOfTwo(3));
    try std.testing.expectEqual(@as(usize, 4), nextPowerOfTwo(4));
    try std.testing.expectEqual(@as(usize, 8), nextPowerOfTwo(5));
    try std.testing.expectEqual(@as(usize, 16), nextPowerOfTwo(15));
}
```

### hashTreeRoot empty

```zig
test "hashTreeRoot empty" {
    const allocator = std.testing.allocator;
    const data = [_]u8{};
    const root = try hashTreeRoot(allocator, &data);
    try std.testing.expectEqual(ZERO_HASH, root);
}
```

### hashTreeRoot single byte

```zig
test "hashTreeRoot single byte" {
    const allocator = std.testing.allocator;
    const data = [_]u8{42};
    const root = try hashTreeRoot(allocator, &data);

    // Should be a 32-byte hash (not all zeros)
    try std.testing.expect(root[0] != 0 or root[1] != 0);
}
```

### hashTreeRootBasic u8

```zig
test "hashTreeRootBasic u8" {
    const root = hashTreeRootBasic(u8, 42);
    try std.testing.expectEqual(@as(u8, 42), root[0]);
    try std.testing.expectEqual(@as(u8, 0), root[1]);
}
```

### hashTreeRootBasic bool

```zig
test "hashTreeRootBasic bool" {
    const root_true = hashTreeRootBasic(bool, true);
    const root_false = hashTreeRootBasic(bool, false);
    try std.testing.expectEqual(@as(u8, 1), root_true[0]);
    try std.testing.expectEqual(@as(u8, 0), root_false[0]);
}
```

### hashTreeRootBasic u64

```zig
test "hashTreeRootBasic u64" {
    const root = hashTreeRootBasic(u64, 0x0102030405060708);
    try std.testing.expectEqual(@as(u8, 0x08), root[0]); // little-endian
    try std.testing.expectEqual(@as(u8, 0x07), root[1]);
    try std.testing.expectEqual(@as(u8, 0x01), root[7]);
    try std.testing.expectEqual(@as(u8, 0), root[8]); // padding
}
```
