---
title: Address Tests
description: Test examples for Address schema showing hex parsing, checksummed addresses, and utility functions.
---

## Parses valid hex addresses

Demonstrates parsing Ethereum addresses from hex strings.

```typescript
import { describe, expect, it } from "@effect/vitest"
import * as S from "effect/Schema"
import * as Address from "voltaire-effect/primitives/Address"

it("parses valid lowercase hex", () => {
  const addr = S.decodeSync(Address.Hex)(
    "0x742d35cc6634c0532925a3b844bc9e7595f251e3",
  )
  expect(addr).toBeInstanceOf(Uint8Array)
  expect(addr.length).toBe(20)
})

it("parses valid checksummed hex", () => {
  const addr = S.decodeSync(Address.Hex)(
    "0x742d35Cc6634C0532925a3b844Bc9e7595f251e3",
  )
  expect(addr.length).toBe(20)
})
```

## Encodes to lowercase hex

Demonstrates encoding addresses to lowercase hex strings.

```typescript
import * as S from "effect/Schema"
import * as Address from "voltaire-effect/primitives/Address"

it("encodes to lowercase hex", () => {
  const addr = S.decodeSync(Address.Hex)(
    "0x742d35Cc6634C0532925a3b844Bc9e7595f251e3",
  )
  const hex = S.encodeSync(Address.Hex)(addr)
  expect(hex).toBe("0x742d35cc6634c0532925a3b844bc9e7595f251e3")
})
```

## Bytes schema

Demonstrates parsing addresses from raw byte arrays.

```typescript
import * as S from "effect/Schema"
import * as Address from "voltaire-effect/primitives/Address"

it("parses 20-byte array", () => {
  const bytes = new Uint8Array(20).fill(0xab)
  const addr = S.decodeSync(Address.Bytes)(bytes)
  expect(addr.length).toBe(20)
})

it("fails on wrong length", () => {
  const bytes = new Uint8Array(19)
  expect(() => S.decodeSync(Address.Bytes)(bytes)).toThrow()
})
```

## Checksummed addresses with Effect

Demonstrates parsing and encoding EIP-55 checksummed addresses.

```typescript
import * as Effect from "effect/Effect"
import * as S from "effect/Schema"
import * as Address from "voltaire-effect/primitives/Address"
import { KeccakLive } from "voltaire-effect/crypto/Keccak256"

it("parses valid checksummed address", async () => {
  const program = S.decode(Address.Checksummed)(
    "0x5aAeb6053F3E94C9b9A09f33669435E7Ef1BeAed",
  )
  const addr = await Effect.runPromise(
    program.pipe(Effect.provide(KeccakLive)),
  )
  expect(addr.length).toBe(20)
})

it("encodes to checksummed format", async () => {
  const addr = S.decodeSync(Address.Hex)(
    "0x5aaeb6053f3e94c9b9a09f33669435e7ef1beaed",
  )
  const program = S.encode(Address.Checksummed)(addr)
  const checksummed = await Effect.runPromise(
    program.pipe(Effect.provide(KeccakLive)),
  )
  expect(checksummed).toBe("0x5aAeb6053F3E94C9b9A09f33669435E7Ef1BeAed")
})
```

## Pure functions: equals, compare, isZero

Demonstrates address comparison and utility functions.

```typescript
import * as S from "effect/Schema"
import * as Address from "voltaire-effect/primitives/Address"

const addrA = S.decodeSync(Address.Hex)(
  "0x742d35cc6634c0532925a3b844bc9e7595f251e3",
)
const addrC = S.decodeSync(Address.Hex)(
  "0x0000000000000000000000000000000000000000",
)

it("equals", () => {
  const addrB = S.decodeSync(Address.Hex)(
    "0x742d35cc6634c0532925a3b844bc9e7595f251e3",
  )
  expect(Address.equals(addrA, addrB)).toBe(true)
  expect(Address.equals(addrA, addrC)).toBe(false)
})

it("isZero", () => {
  expect(Address.isZero(addrC)).toBe(true)
  expect(Address.isZero(addrA)).toBe(false)
})

it("compare", () => {
  expect(Address.compare(addrC, addrA)).toBe(-1)
  expect(Address.compare(addrA, addrC)).toBe(1)
})
```

## Utility functions: toLowercase, toShortHex, toU256

Demonstrates address conversion utilities.

```typescript
import * as S from "effect/Schema"
import * as Address from "voltaire-effect/primitives/Address"

const addr = S.decodeSync(Address.Hex)(
  "0x742d35cc6634c0532925a3b844bc9e7595f251e3",
)

it("toLowercase", () => {
  const lower = Address.toLowercase(addr)
  expect(lower).toBe("0x742d35cc6634c0532925a3b844bc9e7595f251e3")
})

it("toShortHex", () => {
  const short = Address.toShortHex(addr)
  expect(short).toMatch(/^0x[a-f0-9]+\.{3}[a-f0-9]+$/)
})

it("toU256", () => {
  const addr1 = S.decodeSync(Address.Hex)(
    "0x0000000000000000000000000000000000000001",
  )
  expect(Address.toU256(addr1)).toBe(1n)
})

it("toAbiEncoded", () => {
  const encoded = Address.toAbiEncoded(addr)
  expect(encoded).toBeInstanceOf(Uint8Array)
  expect(encoded.length).toBe(32)
  expect(encoded.slice(0, 12).every((b) => b === 0)).toBe(true)
})
```

## Validation functions

Demonstrates address validation utilities.

```typescript
import * as Address from "voltaire-effect/primitives/Address"

it("isValid", () => {
  expect(Address.isValid("0x742d35cc6634c0532925a3b844bc9e7595f251e3")).toBe(true)
  expect(Address.isValid("invalid")).toBe(false)
})

it("isValidChecksum", () => {
  expect(
    Address.isValidChecksum("0x5aAeb6053F3E94C9b9A09f33669435E7Ef1BeAed"),
  ).toBe(true)
  expect(
    Address.isValidChecksum("0x5aaeb6053f3e94c9b9a09f33669435e7ef1beaed"),
  ).toBe(false)
})
```
