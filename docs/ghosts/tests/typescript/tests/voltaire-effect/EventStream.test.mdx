---
title: EventStream Tests
description: Test examples for makeEventStream showing backfill, watch, and event decoding functionality.
---

## EventStreamError Construction

Creates EventStreamError with various options.

```typescript
import { describe, expect, it } from "@effect/vitest"
import { EventStreamError } from "voltaire-effect"

describe("EventStreamError", () => {
  it("creates error with message", () => {
    const error = new EventStreamError("test error")
    expect(error.message).toBe("test error")
    expect(error._tag).toBe("EventStreamError")
  })

  it("creates error with cause", () => {
    const cause = new Error("underlying")
    const error = new EventStreamError("test error", { cause })
    expect(error.message).toContain("test error")
    expect(error.cause).toBe(cause)
  })

  it("creates error with context", () => {
    const error = new EventStreamError("test error", {
      context: { fromBlock: 100n, toBlock: 200n },
    })
    expect(error.message).toBe("test error")
    expect(error._tag).toBe("EventStreamError")
  })
})
```

## makeEventStream

Provides event streaming from TransportService.

```typescript
import { describe, expect, it } from "@effect/vitest"
import * as Effect from "effect/Effect"
import * as Layer from "effect/Layer"
import { TransportService } from "voltaire-effect"
import { makeEventStream } from "voltaire-effect"

describe("EventStream layer", () => {
  it("provides makeEventStream from TransportService", async () => {
    const mockTransport = {
      request: <T>(_method: string, _params?: unknown[]) =>
        Effect.succeed("0x1" as T),
    }

    const TestTransportLayer = Layer.succeed(TransportService, mockTransport)

    const program = Effect.gen(function* () {
      const eventStream = yield* makeEventStream()
      expect(eventStream.backfill).toBeDefined()
      expect(eventStream.watch).toBeDefined()
      expect(typeof eventStream.backfill).toBe("function")
      expect(typeof eventStream.watch).toBe("function")
    }).pipe(Effect.provide(TestTransportLayer))

    await Effect.runPromise(program)
  })
})
```

## Backfill Returns Stream

The backfill method returns a Stream of decoded events.

```typescript
import { describe, expect, it } from "@effect/vitest"
import * as Effect from "effect/Effect"
import * as Layer from "effect/Layer"
import * as S from "effect/Schema"
import * as Stream from "effect/Stream"
import { TransportService } from "voltaire-effect"
import { makeEventStream } from "voltaire-effect"
import { EventSchema } from "voltaire-effect/primitives/Abi/AbiSchema"

const transferEvent = S.decodeUnknownSync(EventSchema)({
  type: "event",
  name: "Transfer",
  inputs: [
    { name: "from", type: "address", indexed: true },
    { name: "to", type: "address", indexed: true },
    { name: "value", type: "uint256", indexed: false },
  ],
}) as any

describe("backfill", () => {
  it("returns a Stream", async () => {
    const mockTransport = {
      request: <T>(method: string, _params?: unknown[]) => {
        if (method === "eth_blockNumber") {
          return Effect.succeed("0x1234567" as T)
        }
        if (method === "eth_getLogs") {
          return Effect.succeed([] as T)
        }
        return Effect.succeed(null as T)
      },
    }

    const TestTransportLayer = Layer.succeed(TransportService, mockTransport)

    const program = Effect.gen(function* () {
      const eventStream = yield* makeEventStream()
      const stream = eventStream.backfill({
        address: "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48",
        event: transferEvent,
        fromBlock: 100n,
        toBlock: 200n,
      })
      expect(stream).toBeDefined()
      const results = yield* Stream.runCollect(stream)
      expect(Array.from(results)).toEqual([])
    }).pipe(Effect.provide(TestTransportLayer))

    await Effect.runPromise(program)
  })
})
```

## Backfill Yields Decoded Events

The backfill method decodes event logs and yields structured data.

```typescript
import { describe, expect, it } from "@effect/vitest"
import * as Effect from "effect/Effect"
import * as Layer from "effect/Layer"
import * as S from "effect/Schema"
import * as Stream from "effect/Stream"
import { TransportService } from "voltaire-effect"
import { makeEventStream } from "voltaire-effect"
import { EventSchema } from "voltaire-effect/primitives/Abi/AbiSchema"

const transferEvent = S.decodeUnknownSync(EventSchema)({
  type: "event",
  name: "Transfer",
  inputs: [
    { name: "from", type: "address", indexed: true },
    { name: "to", type: "address", indexed: true },
    { name: "value", type: "uint256", indexed: false },
  ],
}) as any

describe("backfill yields decoded events", () => {
  it("yields decoded events", async () => {
    const mockLog = {
      address: "0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48",
      blockHash: "0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef",
      blockNumber: "0x64",
      data: "0x0000000000000000000000000000000000000000000000000000000000000064",
      logIndex: "0x0",
      removed: false,
      topics: [
        "0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef",
        "0x000000000000000000000000aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa",
        "0x000000000000000000000000bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb",
      ],
      transactionHash: "0xabcdef1234567890abcdef1234567890abcdef1234567890abcdef1234567890",
      transactionIndex: "0x0",
    }

    const mockTransport = {
      request: <T>(method: string, _params?: unknown[]) => {
        if (method === "eth_blockNumber") {
          return Effect.succeed("0x1234567" as T)
        }
        if (method === "eth_getLogs") {
          return Effect.succeed([mockLog] as T)
        }
        return Effect.succeed(null as T)
      },
    }

    const TestTransportLayer = Layer.succeed(TransportService, mockTransport)

    const program = Effect.gen(function* () {
      const eventStream = yield* makeEventStream()
      const stream = eventStream.backfill({
        address: "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48",
        event: transferEvent,
        fromBlock: 100n,
        toBlock: 100n,
      })
      const results = yield* Stream.runCollect(stream)
      const arr = Array.from(results)
      expect(arr.length).toBe(1)
      expect(arr[0]?.log.eventName).toBe("Transfer")
      expect(arr[0]?.log.blockNumber).toBeDefined()
      expect(arr[0]?.metadata.chainHead).toBe(0x1234567n)
    }).pipe(Effect.provide(TestTransportLayer))

    await Effect.runPromise(program)
  })
})
```

## Transport Error Propagation

Transport errors are propagated correctly through the event stream.

```typescript
import { describe, expect, it } from "@effect/vitest"
import * as Effect from "effect/Effect"
import * as Layer from "effect/Layer"
import * as S from "effect/Schema"
import * as Stream from "effect/Stream"
import { TransportError, TransportService } from "voltaire-effect"
import { makeEventStream } from "voltaire-effect"
import { EventSchema } from "voltaire-effect/primitives/Abi/AbiSchema"

const transferEvent = S.decodeUnknownSync(EventSchema)({
  type: "event",
  name: "Transfer",
  inputs: [
    { name: "from", type: "address", indexed: true },
    { name: "to", type: "address", indexed: true },
    { name: "value", type: "uint256", indexed: false },
  ],
}) as any

describe("transport error propagation", () => {
  it("propagates eth_blockNumber transport errors", async () => {
    const mockTransport = {
      request: <T>(method: string, _params?: unknown[]) => {
        if (method === "eth_blockNumber") {
          return Effect.fail(
            new TransportError({ code: -32000, message: "eth_blockNumber failed" })
          )
        }
        return Effect.succeed(null as T)
      },
    }

    const TestTransportLayer = Layer.succeed(TransportService, mockTransport)

    const program = Effect.gen(function* () {
      const eventStream = yield* makeEventStream()
      const stream = eventStream.backfill({
        address: "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48",
        event: transferEvent,
        fromBlock: 100n,
        toBlock: 200n,
      })
      yield* Stream.runCollect(stream)
    }).pipe(Effect.provide(TestTransportLayer))

    const result = await Effect.runPromiseExit(program)
    expect(result._tag).toBe("Failure")
  })
})
```
