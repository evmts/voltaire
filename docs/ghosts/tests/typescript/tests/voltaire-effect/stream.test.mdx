---
title: Stream Errors Tests
description: Test examples for Stream module error types showing streaming error handling.
---

## StreamAbortedError creates with default message

The base class for stream abort errors.

```typescript
import { StreamAbortedError } from 'voltaire-effect/stream'

const error = new StreamAbortedError()
expect(error.name).toBe("StreamAbortedError")
expect(error.message).toBe("Stream was aborted")
expect(error).toBeInstanceOf(Error)
```

## StreamAbortedError creates with custom message

Custom messages can be provided to StreamAbortedError.

```typescript
import { StreamAbortedError } from 'voltaire-effect/stream'

const error = new StreamAbortedError("Custom abort")
expect(error.message).toBe("Custom abort")
```

## EventStreamAbortedError creates with correct message

Specialized error for event stream aborts.

```typescript
import { EventStreamAbortedError, StreamAbortedError } from 'voltaire-effect/stream'

const error = new EventStreamAbortedError()
expect(error.name).toBe("EventStreamAbortedError")
expect(error.message).toBe("Event stream was aborted")
expect(error).toBeInstanceOf(StreamAbortedError)
```

## BlockStreamAbortedError creates with correct message

Specialized error for block stream aborts.

```typescript
import { BlockStreamAbortedError, StreamAbortedError } from 'voltaire-effect/stream'

const error = new BlockStreamAbortedError()
expect(error.name).toBe("BlockStreamAbortedError")
expect(error.message).toBe("Block stream was aborted")
expect(error).toBeInstanceOf(StreamAbortedError)
```

## BlockRangeTooLargeError creates with block range

Error for when a requested block range exceeds RPC limits.

```typescript
import { BlockRangeTooLargeError } from 'voltaire-effect/stream'

const error = new BlockRangeTooLargeError(100n, 200n)
expect(error.name).toBe("BlockRangeTooLargeError")
expect(error.message).toBe("Block range too large: 100 to 200")
expect(error.fromBlock).toBe(100n)
expect(error.toBlock).toBe(200n)
```

## BlockRangeTooLargeError creates with cause

The error can wrap an underlying RPC error.

```typescript
import { BlockRangeTooLargeError } from 'voltaire-effect/stream'

const cause = new Error("RPC error")
const error = new BlockRangeTooLargeError(1n, 1000000n, cause)
expect(error.cause).toBe(cause)
```

## UnrecoverableReorgError creates with reorg details

Error when a chain reorg exceeds the tracked history depth.

```typescript
import { UnrecoverableReorgError } from 'voltaire-effect/stream'

const error = new UnrecoverableReorgError(100n, 50n)
expect(error.name).toBe("UnrecoverableReorgError")
expect(error.message).toBe(
  "Unrecoverable reorg: depth 100 exceeds tracked history of 50 blocks",
)
expect(error.reorgDepth).toBe(100n)
expect(error.trackedDepth).toBe(50n)
```

## StreamError type includes all error types in union

All stream errors can be handled with pattern matching.

```typescript
import * as Stream from 'voltaire-effect/stream'

const errors: Stream.StreamError[] = [
  new Stream.StreamAbortedError(),
  new Stream.EventStreamAbortedError(),
  new Stream.BlockStreamAbortedError(),
  new Stream.BlockRangeTooLargeError(1n, 2n),
  new Stream.UnrecoverableReorgError(10n, 5n),
]
expect(errors).toHaveLength(5)

for (const error of errors) {
  expect(error.name).toBeDefined()
  expect(error.message).toBeDefined()
}
```

## Error inheritance hierarchy allows catching specific stream errors

Specific stream errors can be caught as their base type.

```typescript
import { EventStreamAbortedError, StreamAbortedError } from 'voltaire-effect/stream'

const throwAndCatch = () => {
  try {
    throw new EventStreamAbortedError()
  } catch (e) {
    if (e instanceof StreamAbortedError) {
      return "caught as StreamAbortedError"
    }
    return "not caught"
  }
}
expect(throwAndCatch()).toBe("caught as StreamAbortedError")
```
