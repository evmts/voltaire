---
title: BatchScheduler Tests
description: Test examples for BatchScheduler showing JSON-RPC request batching.
---

## BatchScheduler schedules and sends a single request

A single scheduled request is batched and sent.

```typescript
import { Effect } from 'effect'
import { createBatchScheduler } from 'voltaire-effect'

const createMockSend = () =>
  vi.fn((requests: { id: number; method: string; params?: unknown[] }[]) =>
    Effect.succeed(
      requests.map((req) => ({ id: req.id, result: `result-${req.id}` })),
    ),
  )

const send = createMockSend()
const program = Effect.gen(function* () {
  const scheduler = yield* createBatchScheduler(send)
  return yield* scheduler.schedule<string>("eth_blockNumber")
}).pipe(Effect.scoped)

const result = await Effect.runPromise(program)
const sentId = send.mock.calls[0][0][0]?.id
expect(result).toBe(`result-${sentId}`)
expect(send).toHaveBeenCalledTimes(1)
```

## BatchScheduler batches multiple concurrent requests

Concurrent requests are combined into a single batch.

```typescript
import { Effect, Fiber } from 'effect'
import { createBatchScheduler } from 'voltaire-effect'

const send = createMockSend()
const program = Effect.gen(function* () {
  const scheduler = yield* createBatchScheduler(send)
  const fibers = yield* Effect.all([
    Effect.fork(scheduler.schedule<string>("eth_blockNumber")),
    Effect.fork(scheduler.schedule<string>("eth_chainId")),
    Effect.fork(scheduler.schedule<string>("eth_gasPrice")),
  ])
  const results = yield* Effect.all(fibers.map(Fiber.join))
  return results
}).pipe(Effect.scoped)

const results = await Effect.runPromise(program)
expect(results).toHaveLength(3)
expect(send).toHaveBeenCalledTimes(1)
expect(send.mock.calls[0][0]).toHaveLength(3)
```

## BatchScheduler respects batchSize limit

Requests are split into multiple batches when the limit is exceeded.

```typescript
import { Effect, Fiber } from 'effect'
import { createBatchScheduler, type BatchOptions } from 'voltaire-effect'

const send = createMockSend()
const options: BatchOptions = { batchSize: 2 }
const program = Effect.gen(function* () {
  const scheduler = yield* createBatchScheduler(send, options)
  const fibers = yield* Effect.all([
    Effect.fork(scheduler.schedule<string>("m1")),
    Effect.fork(scheduler.schedule<string>("m2")),
    Effect.fork(scheduler.schedule<string>("m3")),
  ])
  yield* Effect.all(fibers.map(Fiber.join))
}).pipe(Effect.scoped)

await Effect.runPromise(program)
expect(send).toHaveBeenCalledTimes(2) // Split into 2 batches
```

## BatchScheduler fails deferred when response missing for request ID

Missing responses cause the corresponding deferred to fail.

```typescript
import { Effect } from 'effect'
import { createBatchScheduler } from 'voltaire-effect'

const send = vi.fn(() => Effect.succeed([{ id: 999, result: "wrong-id" }]))
const program = Effect.gen(function* () {
  const scheduler = yield* createBatchScheduler(send)
  return yield* scheduler.schedule<string>("eth_blockNumber")
}).pipe(Effect.scoped)

const exit = await Effect.runPromiseExit(program)
expect(exit._tag).toBe("Failure")
if (exit._tag === "Failure" && exit.cause._tag === "Fail") {
  expect(exit.cause.error.message).toContain("Missing JSON-RPC response")
}
```

## BatchScheduler fails individual deferred when batch response has error

JSON-RPC errors in batch responses fail the corresponding request.

```typescript
import { Effect } from 'effect'
import { createBatchScheduler } from 'voltaire-effect'

const send = vi.fn((requests: { id: number }[]) =>
  Effect.succeed([{
    id: requests[0]?.id ?? -1,
    error: { code: -32603, message: "Internal error" },
  }]),
)

const program = Effect.gen(function* () {
  const scheduler = yield* createBatchScheduler(send)
  return yield* scheduler.schedule<string>("eth_blockNumber")
}).pipe(Effect.scoped)

const exit = await Effect.runPromiseExit(program)
expect(exit._tag).toBe("Failure")
if (exit._tag === "Failure" && exit.cause._tag === "Fail") {
  expect(exit.cause.error.message).toBe("Internal error")
}
```

## BatchScheduler assigns unique IDs to requests

All requests receive unique IDs within the batch.

```typescript
import { Effect, Fiber } from 'effect'
import { createBatchScheduler } from 'voltaire-effect'

const send = createMockSend()
const program = Effect.gen(function* () {
  const scheduler = yield* createBatchScheduler(send, { wait: 0 })
  const fibers = yield* Effect.all([
    Effect.fork(scheduler.schedule<string>("m1")),
    Effect.fork(scheduler.schedule<string>("m2")),
    Effect.fork(scheduler.schedule<string>("m3")),
  ])
  yield* Effect.all(fibers.map(Fiber.join))
}).pipe(Effect.scoped)

await Effect.runPromise(program)
const allRequests = send.mock.calls.flatMap((call) => call[0])
const ids = allRequests.map((r) => r.id).sort((a, b) => a - b)
expect(new Set(ids).size).toBe(ids.length) // All unique
```
