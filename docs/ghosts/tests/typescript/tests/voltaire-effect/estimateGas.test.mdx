---
title: Contract.estimateGas Tests
description: Test examples for Contract.estimateGas showing gas estimation for contract calls.
---

## Contract.estimateGas encodes data and calls provider.estimateGas

The estimateGas method encodes function call data and estimates gas usage.

```typescript
import { Effect, Layer } from 'effect'
import * as S from 'effect/Schema'
import { Address, BrandedAbi } from 'voltaire'
import { Contract } from 'voltaire-effect'
import { ProviderService } from 'voltaire-effect'
import { fromArray } from 'voltaire-effect/primitives/Abi/AbiSchema'

const testAddress = Address("0x6B175474E89094C44Da98b954EecdEfaE6E286AB")
const erc20Abi = S.decodeUnknownSync(fromArray)([
  {
    type: "function",
    name: "transfer",
    stateMutability: "nonpayable",
    inputs: [{ name: "to", type: "address" }, { name: "amount", type: "uint256" }],
    outputs: [{ name: "success", type: "bool" }],
  },
])

const mockProvider = { estimateGas: vi.fn() }
const MockProviderLayer = Layer.succeed(ProviderService, mockProvider as any)

const recipient = Address("0x1234567890123456789012345678901234567890")
const amount = 1000n
mockProvider.estimateGas.mockReturnValue(Effect.succeed(45000n))

const program = Effect.gen(function* () {
  const contract = yield* Contract(testAddress, erc20Abi)
  return yield* Contract.estimateGas(contract, "transfer", [recipient, amount])
})

const gas = await Effect.runPromise(
  program.pipe(Effect.provide(MockProviderLayer)),
)

expect(gas).toBe(45000n)
expect(mockProvider.estimateGas).toHaveBeenCalledTimes(1)

const callArgs = mockProvider.estimateGas.mock.calls[0][0]
const expectedData = BrandedAbi.encodeFunction(erc20Abi, "transfer", [recipient, amount])
expect(callArgs.to).toBe(Address.toHex(testAddress))
expect(callArgs.data).toBe(expectedData)
```

## Contract.estimateGas passes value for payable methods

Payable methods include the value in the gas estimation.

```typescript
import { Effect, Layer } from 'effect'
import { Address, BrandedAbi } from 'voltaire'
import { Contract } from 'voltaire-effect'

const erc20Abi = S.decodeUnknownSync(fromArray)([
  {
    type: "function",
    name: "deposit",
    stateMutability: "payable",
    inputs: [],
    outputs: [],
  },
])

const value = 1000000000000000000n
mockProvider.estimateGas.mockReturnValue(Effect.succeed(21000n))

const program = Effect.gen(function* () {
  const contract = yield* Contract(testAddress, erc20Abi)
  return yield* Contract.estimateGas(contract, "deposit", [{ value }])
})

await Effect.runPromise(program.pipe(Effect.provide(MockProviderLayer)))

const callArgs = mockProvider.estimateGas.mock.calls[0][0]
const expectedData = BrandedAbi.encodeFunction(erc20Abi, "deposit", [])
expect(callArgs.data).toBe(expectedData)
expect(callArgs.value).toBe(value)
```

## Contract.estimateGas maps provider errors to ContractCallError

Provider errors are wrapped in ContractCallError for consistent error handling.

```typescript
import { Effect, Layer } from 'effect'
import { Address } from 'voltaire'
import { Contract } from 'voltaire-effect'

const recipient = Address("0x1234567890123456789012345678901234567890")
mockProvider.estimateGas.mockReturnValue(
  Effect.fail(new Error("estimate failed")),
)

const program = Effect.gen(function* () {
  const contract = yield* Contract(testAddress, erc20Abi)
  return yield* Contract.estimateGas(contract, "transfer", [recipient, 1000n])
}).pipe(
  Effect.catchTag("ContractCallError", (e) =>
    Effect.succeed(`caught: ${e.message}`),
  ),
)

const result = await Effect.runPromise(
  program.pipe(Effect.provide(MockProviderLayer)),
)

expect(result).toContain("caught:")
expect(result).toContain("estimate failed")
```
