---
title: PrivateKey Tests
description: Test examples for PrivateKey showing schema validation, hex/bytes encoding, random generation, and cryptographic operations.
---

## Parse 64-char hex with prefix

Validates that a 32-byte private key can be decoded from a prefixed hex string.

```typescript
import * as S from 'effect/Schema'
import * as PrivateKey from 'voltaire-effect/primitives/PrivateKey'

const validHex = `0x${'ab'.repeat(32)}`
const pk = S.decodeSync(PrivateKey.Hex)(validHex)
expect(pk).toBeInstanceOf(Uint8Array)
expect(pk.length).toBe(32)
```

## Parse 64-char hex without prefix

Validates decoding a private key from hex without the 0x prefix.

```typescript
import * as S from 'effect/Schema'
import * as PrivateKey from 'voltaire-effect/primitives/PrivateKey'

const validHexNoPrefix = 'ab'.repeat(32)
const pk = S.decodeSync(PrivateKey.Hex)(validHexNoPrefix)
expect(pk).toBeInstanceOf(Uint8Array)
expect(pk.length).toBe(32)
```

## Encode to lowercase hex with prefix

Encodes a private key back to lowercase hex with 0x prefix.

```typescript
import * as S from 'effect/Schema'
import * as PrivateKey from 'voltaire-effect/primitives/PrivateKey'

const pk = S.decodeSync(PrivateKey.Hex)(`0x${'ab'.repeat(32)}`)
const hex = S.encodeSync(PrivateKey.Hex)(pk)
expect(hex.startsWith('0x')).toBe(true)
expect(hex.length).toBe(66)
expect(hex).toBe(hex.toLowerCase())
```

## Parse 32-byte array

Decodes a private key from a 32-byte Uint8Array.

```typescript
import * as S from 'effect/Schema'
import * as PrivateKey from 'voltaire-effect/primitives/PrivateKey'

const bytes = new Uint8Array(32).fill(0xab)
const pk = S.decodeSync(PrivateKey.Bytes)(bytes)
expect(pk.length).toBe(32)
```

## isValid returns true for valid hex

Validates a hex string as a valid private key using Effect.

```typescript
import * as Effect from 'effect/Effect'
import * as PrivateKey from 'voltaire-effect/primitives/PrivateKey'

const validHex = `0x${'ab'.repeat(32)}`
const result = await Effect.runPromise(PrivateKey.isValid(validHex))
expect(result).toBe(true)
```

## Generate random private key

Generates a cryptographically random 32-byte private key.

```typescript
import * as Effect from 'effect/Effect'
import * as PrivateKey from 'voltaire-effect/primitives/PrivateKey'

const pk = await Effect.runPromise(PrivateKey.random())
expect(pk).toBeInstanceOf(Uint8Array)
expect(pk.length).toBe(32)
```

## Generate unique keys each time

Verifies random generation produces different keys.

```typescript
import * as Effect from 'effect/Effect'
import * as PrivateKey from 'voltaire-effect/primitives/PrivateKey'

const pk1 = await Effect.runPromise(PrivateKey.random())
const pk2 = await Effect.runPromise(PrivateKey.random())
expect([...pk1]).not.toEqual([...pk2])
```

## Derive public key from private key

Derives a 64-byte uncompressed public key from a private key.

```typescript
import * as S from 'effect/Schema'
import * as PrivateKey from 'voltaire-effect/primitives/PrivateKey'
import * as Secp256k1 from 'voltaire/Secp256k1'

const pk = S.decodeSync(PrivateKey.Bytes)(new Uint8Array(32).fill(1))
const publicKey = Secp256k1.derivePublicKey(pk)
expect(publicKey).toBeInstanceOf(Uint8Array)
expect(publicKey.length).toBe(64)
```

## Sign message with private key

Signs a 32-byte message hash producing r, s, v components.

```typescript
import * as S from 'effect/Schema'
import { Hash } from 'voltaire'
import * as PrivateKey from 'voltaire-effect/primitives/PrivateKey'
import * as Secp256k1 from 'voltaire/Secp256k1'

const pk = S.decodeSync(PrivateKey.Bytes)(new Uint8Array(32).fill(1))
const messageHash = Hash.from(new Uint8Array(32).fill(0x42))
const signature = Secp256k1.sign(messageHash, pk)
expect(signature.r).toBeInstanceOf(Uint8Array)
expect(signature.s).toBeInstanceOf(Uint8Array)
expect(signature.r.length).toBe(32)
expect(signature.s.length).toBe(32)
```

## Verify signature against public key

Verifies a signature matches the expected public key.

```typescript
import * as S from 'effect/Schema'
import { Hash } from 'voltaire'
import * as PrivateKey from 'voltaire-effect/primitives/PrivateKey'
import * as Secp256k1 from 'voltaire/Secp256k1'

const pk = S.decodeSync(PrivateKey.Bytes)(new Uint8Array(32).fill(1))
const publicKey = Secp256k1.derivePublicKey(pk)
const messageHash = Hash.from(new Uint8Array(32).fill(0x42))
const signature = Secp256k1.sign(messageHash, pk)
const isValid = Secp256k1.verify(signature, messageHash, publicKey)
expect(isValid).toBe(true)
```

## Recover public key from signature

Recovers the public key from a signature and message hash.

```typescript
import * as S from 'effect/Schema'
import { Hash } from 'voltaire'
import * as PrivateKey from 'voltaire-effect/primitives/PrivateKey'
import * as Secp256k1 from 'voltaire/Secp256k1'

const pk = S.decodeSync(PrivateKey.Bytes)(new Uint8Array(32).fill(1))
const publicKey = Secp256k1.derivePublicKey(pk)
const messageHash = Hash.from(new Uint8Array(32).fill(0x42))
const signature = Secp256k1.sign(messageHash, pk)
const recoveredPubKey = Secp256k1.recoverPublicKey(signature, messageHash)
expect([...recoveredPubKey]).toEqual([...publicKey])
```
