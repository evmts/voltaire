---
title: Uint16 Tests
description: Test examples for Uint16 schema showing unsigned 16-bit integer operations, arithmetic, and validation.
---

## Schema: Number decoding

Demonstrates decoding numbers into branded Uint16.

```typescript
import { describe, expect, it } from "@effect/vitest"
import * as S from "effect/Schema"
import * as Uint16 from "voltaire-effect/primitives/Uint16"

const UINT16_MAX = 65535

it("decodes valid number", () => {
  const value = S.decodeSync(Uint16.Number)(1000)
  expect(S.encodeSync(Uint16.Number)(value)).toBe(1000)
})

it("decodes zero", () => {
  const value = S.decodeSync(Uint16.Number)(0)
  expect(S.encodeSync(Uint16.Number)(value)).toBe(0)
})

it("decodes UINT16_MAX (65535)", () => {
  const value = S.decodeSync(Uint16.Number)(UINT16_MAX)
  expect(S.encodeSync(Uint16.Number)(value)).toBe(UINT16_MAX)
})

it("fails on overflow (65536)", () => {
  expect(() => S.decodeSync(Uint16.Number)(65536)).toThrow()
})

it("fails on negative (-1)", () => {
  expect(() => S.decodeSync(Uint16.Number)(-1)).toThrow()
})
```

## Schema: String and BigInt

Demonstrates string and BigInt schema variants.

```typescript
import * as S from "effect/Schema"
import * as Uint16 from "voltaire-effect/primitives/Uint16"

it("decodes valid string", () => {
  const value = S.decodeSync(Uint16.String)("1000")
  expect(S.encodeSync(Uint16.String)(value)).toBe("1000")
})

it("decodes valid bigint", () => {
  const value = S.decodeSync(Uint16.BigInt)(1000n)
  expect(S.encodeSync(Uint16.BigInt)(value)).toBe(1000n)
})

it("fails on negative bigint", () => {
  expect(() => S.decodeSync(Uint16.BigInt)(-1n)).toThrow()
})
```

## Schema: Hex and Bytes

Demonstrates hex string and byte array schemas.

```typescript
import * as S from "effect/Schema"
import * as Uint16 from "voltaire-effect/primitives/Uint16"

it("decodes valid hex with 0x prefix", () => {
  const value = S.decodeSync(Uint16.Hex)("0xffff")
  expect(S.encodeSync(Uint16.Number)(value)).toBe(65535)
})

it("decodes two-byte array", () => {
  const bytes = new Uint8Array([0xff, 0xff])
  const value = S.decodeSync(Uint16.Bytes)(bytes)
  expect(S.encodeSync(Uint16.Number)(value)).toBe(65535)
})

it("round-trips correctly", () => {
  const value = S.decodeSync(Uint16.Number)(1000)
  const hex = S.encodeSync(Uint16.Hex)(value)
  const decoded = S.decodeSync(Uint16.Hex)(hex)
  expect(S.encodeSync(Uint16.Number)(decoded)).toBe(1000)
})
```

## Arithmetic: plus and minus

Demonstrates addition and subtraction with overflow checks.

```typescript
import * as S from "effect/Schema"
import * as Uint16 from "voltaire-effect/primitives/Uint16"

const UINT16_MAX = 65535

it("adds two values", () => {
  const a = S.decodeSync(Uint16.Number)(10000)
  const b = S.decodeSync(Uint16.Number)(5000)
  const result = Uint16.plus(a, b)
  expect(Uint16.toNumber(result)).toBe(15000)
})

it("throws on overflow (65535 + 1)", () => {
  const max = S.decodeSync(Uint16.Number)(UINT16_MAX)
  const one = S.decodeSync(Uint16.Number)(1)
  expect(() => Uint16.plus(max, one)).toThrow()
})

it("subtracts two values", () => {
  const a = S.decodeSync(Uint16.Number)(10000)
  const b = S.decodeSync(Uint16.Number)(5000)
  const result = Uint16.minus(a, b)
  expect(Uint16.toNumber(result)).toBe(5000)
})

it("throws on underflow (0 - 1)", () => {
  const zero = S.decodeSync(Uint16.Number)(0)
  const one = S.decodeSync(Uint16.Number)(1)
  expect(() => Uint16.minus(zero, one)).toThrow()
})
```

## Arithmetic: times

Demonstrates multiplication with overflow checks.

```typescript
import * as S from "effect/Schema"
import * as Uint16 from "voltaire-effect/primitives/Uint16"

it("multiplies two values", () => {
  const a = S.decodeSync(Uint16.Number)(100)
  const b = S.decodeSync(Uint16.Number)(60)
  const result = Uint16.times(a, b)
  expect(Uint16.toNumber(result)).toBe(6000)
})

it("multiplies by zero", () => {
  const a = S.decodeSync(Uint16.Number)(10000)
  const zero = S.decodeSync(Uint16.Number)(0)
  const result = Uint16.times(a, zero)
  expect(Uint16.toNumber(result)).toBe(0)
})

it("throws on overflow", () => {
  const a = S.decodeSync(Uint16.Number)(32768)
  const b = S.decodeSync(Uint16.Number)(2)
  expect(() => Uint16.times(a, b)).toThrow()
})
```

## Comparison and conversion

Demonstrates equality and conversion utilities.

```typescript
import * as S from "effect/Schema"
import * as Uint16 from "voltaire-effect/primitives/Uint16"

it("returns true for equal values", () => {
  const a = S.decodeSync(Uint16.Number)(1000)
  const b = S.decodeSync(Uint16.Number)(1000)
  expect(Uint16.equals(a, b)).toBe(true)
})

it("converts to number", () => {
  const value = S.decodeSync(Uint16.Number)(1000)
  expect(Uint16.toNumber(value)).toBe(1000)
})

it("converts to hex string", () => {
  const value = S.decodeSync(Uint16.Number)(65535)
  const hex = Uint16.toHex(value)
  expect(hex).toMatch(/^0x[0-9a-f]+$/i)
})
```

## Constants

Demonstrates accessing Uint16 constant values.

```typescript
import * as Uint16 from "voltaire-effect/primitives/Uint16"

it("MAX equals 65535", () => {
  expect(Uint16.toNumber(Uint16.MAX)).toBe(65535)
})

it("MIN equals 0", () => {
  expect(Uint16.toNumber(Uint16.MIN)).toBe(0)
})

it("ZERO equals 0", () => {
  expect(Uint16.toNumber(Uint16.ZERO)).toBe(0)
})

it("ONE equals 1", () => {
  expect(Uint16.toNumber(Uint16.ONE)).toBe(1)
})
```
