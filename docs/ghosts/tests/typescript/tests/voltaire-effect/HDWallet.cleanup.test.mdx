---
title: HDWallet Cleanup Tests
description: Test examples for verifying memory cleanup of private keys and seeds in HDWallet operations.
---

## withPrivateKey zeroes private key after normal use

Demonstrates that private keys are securely zeroed after use.

```typescript
import * as Effect from "effect/Effect";
import * as Layer from "effect/Layer";
import { withPrivateKey } from "voltaire-effect/crypto/HDWallet";
import { HDWalletService } from "voltaire-effect/crypto/HDWallet";

const TestWithDataLayer = Layer.succeed(HDWalletService, {
  derive: () => Effect.succeed({}),
  generateMnemonic: () => Effect.succeed("abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon about"),
  fromSeed: () => Effect.succeed({}),
  fromMnemonic: () => Effect.succeed({}),
  mnemonicToSeed: () => Effect.succeed(new Uint8Array(64).fill(42)),
  getPrivateKey: () => Effect.succeed(new Uint8Array(32).fill(99)),
  getPublicKey: () => Effect.succeed(new Uint8Array(33).fill(88)),
});

let capturedKey: Uint8Array | null = null;

const program = Effect.gen(function* () {
  const master = {};
  yield* withPrivateKey(master, (key) =>
    Effect.sync(() => {
      capturedKey = key;
      expect(key.some((b) => b !== 0)).toBe(true);
    }),
  );
}).pipe(Effect.provide(TestWithDataLayer));

await Effect.runPromise(program);

expect(capturedKey).not.toBeNull();
expect((capturedKey as Uint8Array).every((b) => b === 0)).toBe(true);
```

## withPrivateKey zeroes key even when use effect fails

Shows that keys are cleaned up even on error paths.

```typescript
import * as Effect from "effect/Effect";
import * as Exit from "effect/Exit";
import { withPrivateKey } from "voltaire-effect/crypto/HDWallet";

let capturedKey: Uint8Array | null = null;

const program = Effect.gen(function* () {
  const master = {};
  yield* withPrivateKey(master, (key) =>
    Effect.sync(() => {
      capturedKey = key;
      throw new Error("deliberate test error");
    }),
  );
}).pipe(Effect.provide(TestWithDataLayer));

const exit = await Effect.runPromiseExit(program);

expect(Exit.isFailure(exit)).toBe(true);
expect(capturedKey).not.toBeNull();
expect((capturedKey as Uint8Array).every((b) => b === 0)).toBe(true);
```

## withSeed zeroes seed after normal use

Demonstrates that seeds are securely zeroed after use.

```typescript
import * as Effect from "effect/Effect";
import { withSeed } from "voltaire-effect/crypto/HDWallet";

const mnemonic = [
  "abandon", "abandon", "abandon", "abandon",
  "abandon", "abandon", "abandon", "abandon",
  "abandon", "abandon", "abandon", "about",
];

let capturedSeed: Uint8Array | null = null;

const program = Effect.gen(function* () {
  yield* withSeed(mnemonic, (seed) =>
    Effect.sync(() => {
      capturedSeed = seed;
      expect(seed.length).toBe(64);
      expect(seed.some((b) => b !== 0)).toBe(true);
    }),
  );
}).pipe(Effect.provide(TestWithDataLayer));

await Effect.runPromise(program);

expect(capturedSeed).not.toBeNull();
expect((capturedSeed as Uint8Array).every((b) => b === 0)).toBe(true);
```

## withSeed zeroes seed even when use effect fails

Shows that seeds are cleaned up even on error paths.

```typescript
import * as Effect from "effect/Effect";
import * as Exit from "effect/Exit";
import { withSeed } from "voltaire-effect/crypto/HDWallet";

let capturedSeed: Uint8Array | null = null;

const program = Effect.gen(function* () {
  yield* withSeed(mnemonic, (seed) =>
    Effect.sync(() => {
      capturedSeed = seed;
      throw new Error("deliberate test error");
    }),
  );
}).pipe(Effect.provide(TestWithDataLayer));

const exit = await Effect.runPromiseExit(program);

expect(Exit.isFailure(exit)).toBe(true);
expect(capturedSeed).not.toBeNull();
expect((capturedSeed as Uint8Array).every((b) => b === 0)).toBe(true);
```
