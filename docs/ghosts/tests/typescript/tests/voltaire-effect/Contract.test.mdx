---
title: Contract Tests
description: Test examples for Contract showing typed contract interactions with read, write, simulate, and events.
---

## Contract factory creates contract instance with address and abi

The Contract factory creates a typed contract instance from an address and ABI.

```typescript
import { Effect, Layer } from 'effect'
import * as S from 'effect/Schema'
import { Address } from 'voltaire'
import { Contract } from 'voltaire-effect'
import { ProviderService } from 'voltaire-effect'
import { fromArray } from 'voltaire-effect/primitives/Abi/AbiSchema'

const testAddress = Address("0x6B175474E89094C44Da98b954EecdEfaE6E286AB")
const erc20Abi = S.decodeUnknownSync(fromArray)([
  { type: "function", name: "balanceOf", stateMutability: "view", inputs: [{ name: "account", type: "address" }], outputs: [{ name: "balance", type: "uint256" }] },
  { type: "function", name: "transfer", stateMutability: "nonpayable", inputs: [{ name: "to", type: "address" }, { name: "amount", type: "uint256" }], outputs: [{ name: "success", type: "bool" }] },
])

const program = Effect.gen(function* () {
  const contract = yield* Contract(testAddress, erc20Abi)
  return contract
})

const result = await Effect.runPromise(
  program.pipe(Effect.provide(MockProviderLayer)),
)

expect(result.address).toBe(testAddress)
expect(result.abi).toBe(erc20Abi)
```

## Contract has read methods for view functions

View functions are available on the contract.read namespace.

```typescript
import { Effect, Layer } from 'effect'
import { Contract } from 'voltaire-effect'

const program = Effect.gen(function* () {
  const contract = yield* Contract(testAddress, erc20Abi)
  return {
    hasBalanceOf: typeof contract.read.balanceOf === "function",
    hasTotalSupply: typeof contract.read.totalSupply === "function",
  }
})

const result = await Effect.runPromise(
  program.pipe(Effect.provide(MockProviderLayer)),
)

expect(result.hasBalanceOf).toBe(true)
expect(result.hasTotalSupply).toBe(true)
```

## Contract read methods call eth_call with encoded function data

Read methods encode arguments and decode the response using the ABI.

```typescript
import { Effect, Layer } from 'effect'
import { Address } from 'voltaire'
import { Contract } from 'voltaire-effect'

const expectedBalance = 1000000000000000000n
mockProvider.call.mockReturnValue(
  Effect.succeed("0x0000000000000000000000000000000000000000000000000de0b6b3a7640000"),
)

const program = Effect.gen(function* () {
  const contract = yield* Contract(testAddress, erc20Abi)
  const balance = yield* contract.read.balanceOf(
    Address("0x1234567890123456789012345678901234567890"),
  )
  return balance
})

const result = await Effect.runPromise(
  program.pipe(Effect.provide(MockProviderLayer)),
)

expect(mockProvider.call).toHaveBeenCalled()
expect(result).toBe(expectedBalance)
```

## Contract write methods send transactions

Write methods require a signer and send transactions.

```typescript
import { Effect, Layer } from 'effect'
import { Address } from 'voltaire'
import { Contract } from 'voltaire-effect'
import { SignerService } from 'voltaire-effect'

mockSigner.sendTransaction.mockReturnValue(Effect.succeed(mockTxHash))

const program = Effect.gen(function* () {
  const contract = yield* Contract(testAddress, erc20Abi)
  return yield* contract.write.transfer(
    Address("0x1234567890123456789012345678901234567890"),
    1000000000000000000n,
  )
})

const result = await Effect.runPromise(
  program.pipe(Effect.provide(MockProviderLayer), Effect.provide(MockSignerLayer)),
)

expect(mockSigner.sendTransaction).toHaveBeenCalled()
```

## Contract getEvents fetches and decodes events

The getEvents method queries logs and decodes them using the event ABI.

```typescript
import { Effect, Layer } from 'effect'
import { Contract } from 'voltaire-effect'

mockProvider.getLogs.mockReturnValue(
  Effect.succeed([{
    address: testAddress,
    topics: [
      "0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef",
      "0x0000000000000000000000001234567890123456789012345678901234567890",
      "0x0000000000000000000000000987654321098765432109876543210987654321",
    ],
    data: "0x0000000000000000000000000000000000000000000000000de0b6b3a7640000",
    blockNumber: 18000000n,
    transactionHash: "0xabcd",
    logIndex: 0,
  }]),
)

const program = Effect.gen(function* () {
  const contract = yield* Contract(testAddress, erc20Abi)
  const events = yield* contract.getEvents("Transfer", {
    fromBlock: 17000000n,
    toBlock: "latest",
  })
  return events
})

const result = await Effect.runPromise(
  program.pipe(Effect.provide(MockProviderLayer)),
)

expect(mockProvider.getLogs).toHaveBeenCalled()
expect(result.length).toBe(1)
expect(result[0].eventName).toBe("Transfer")
```

## Contract event not found error is catchable with Effect.catchTag

Querying for a non-existent event produces a ContractEventError.

```typescript
import { Effect, Layer } from 'effect'
import { Contract } from 'voltaire-effect'

const program = Effect.gen(function* () {
  const contract = yield* Contract(testAddress, erc20Abi)
  return yield* contract.getEvents("NonExistentEvent" as any)
}).pipe(
  Effect.catchTag("ContractEventError", (e) =>
    Effect.succeed(`caught: ${e.message}`),
  ),
)

const result = await Effect.runPromise(
  program.pipe(Effect.provide(MockProviderLayer)),
)

expect(result).toContain("caught:")
expect(result).toContain("NonExistentEvent not found")
```
