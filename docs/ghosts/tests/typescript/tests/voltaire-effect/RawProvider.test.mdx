---
title: RawProvider Tests
description: Test examples for RawProviderService showing direct transport access and error propagation.
---

## Direct Access via Transport

Provides direct RPC access through the transport layer.

```typescript
import { describe, expect, it } from "@effect/vitest"
import * as Effect from "effect/Effect"
import * as Layer from "effect/Layer"
import { TransportError, TransportService } from "voltaire-effect"
import { RawProviderService } from "voltaire-effect"
import { RawProviderTransport } from "voltaire-effect"

describe("RawProvider", () => {
  describe("RawProviderService", () => {
    it.effect("provides direct access via transport", () =>
      Effect.gen(function* () {
        const mockTransport = Layer.succeed(TransportService, {
          request: <T>(method: string, _params?: unknown[]) => {
            if (method === "eth_chainId") {
              return Effect.succeed("0x2a" as T)
            }
            return Effect.fail(
              new TransportError({ code: -32601, message: "Method not found" })
            )
          },
        })

        const result = yield* Effect.gen(function* () {
          const raw = yield* RawProviderService
          return yield* raw.request({ method: "eth_chainId", params: [] })
        }).pipe(
          Effect.provide(RawProviderTransport),
          Effect.provide(mockTransport)
        )

        expect(result).toBe("0x2a")
      })
    )
  })
})
```

## RPC Error Propagation

Propagates RPC errors correctly.

```typescript
import { describe, expect, it } from "@effect/vitest"
import * as Effect from "effect/Effect"
import * as Exit from "effect/Exit"
import * as Layer from "effect/Layer"
import { TransportError, TransportService } from "voltaire-effect"
import { RawProviderService } from "voltaire-effect"
import { RawProviderTransport } from "voltaire-effect"

describe("error propagation", () => {
  it.effect("propagates RPC errors", () =>
    Effect.gen(function* () {
      const mockTransport = Layer.succeed(TransportService, {
        request: <T>(_method: string, _params?: unknown[]) => {
          return Effect.fail(
            new TransportError({ code: 4200, message: "Not supported" })
          ) as Effect.Effect<T, TransportError>
        },
      })

      const exit = yield* Effect.exit(
        Effect.gen(function* () {
          const raw = yield* RawProviderService
          return yield* raw.request({ method: "eth_sign", params: ["0x0", "0x0"] })
        }).pipe(
          Effect.provide(RawProviderTransport),
          Effect.provide(mockTransport)
        )
      )

      expect(Exit.isFailure(exit)).toBe(true)
      if (Exit.isFailure(exit)) {
        const error = exit.cause._tag === "Fail" ? exit.cause.error : null
        expect(error).toBeInstanceOf(TransportError)
        expect((error as TransportError).code).toBe(4200)
      }
    })
  )
})
```

## Parameter Passing

Passes params correctly to underlying transport.

```typescript
import { describe, expect, it } from "@effect/vitest"
import * as Effect from "effect/Effect"
import * as Layer from "effect/Layer"
import { TransportService } from "voltaire-effect"
import { RawProviderService } from "voltaire-effect"
import { RawProviderTransport } from "voltaire-effect"

describe("parameter passing", () => {
  it.effect("passes params correctly", () =>
    Effect.gen(function* () {
      let capturedMethod = ""
      let capturedParams: unknown[] = []
      const mockTransport = Layer.succeed(TransportService, {
        request: <T>(method: string, params?: unknown[]) => {
          capturedMethod = method
          capturedParams = params ?? []
          return Effect.succeed("0x1" as T)
        },
      })

      yield* Effect.gen(function* () {
        const raw = yield* RawProviderService
        return yield* raw.request({
          method: "eth_getBalance",
          params: ["0x1234", "latest"],
        })
      }).pipe(
        Effect.provide(RawProviderTransport),
        Effect.provide(mockTransport)
      )

      expect(capturedMethod).toBe("eth_getBalance")
      expect(capturedParams).toEqual(["0x1234", "latest"])
    })
  )
})
```

## Complex Response Objects

Handles complex JSON response objects.

```typescript
import { describe, expect, it } from "@effect/vitest"
import * as Effect from "effect/Effect"
import * as Layer from "effect/Layer"
import { TransportService } from "voltaire-effect"
import { RawProviderService } from "voltaire-effect"
import { RawProviderTransport } from "voltaire-effect"

describe("complex responses", () => {
  it.effect("handles complex response objects", () =>
    Effect.gen(function* () {
      const mockBlock = {
        number: "0x10",
        hash: "0xabc",
        parentHash: "0xdef",
        transactions: ["0x1", "0x2"],
      }
      const mockTransport = Layer.succeed(TransportService, {
        request: <T>(_method: string, _params?: unknown[]) => {
          return Effect.succeed(mockBlock as T)
        },
      })

      const result = yield* Effect.gen(function* () {
        const raw = yield* RawProviderService
        return yield* raw.request({
          method: "eth_getBlockByNumber",
          params: ["0x10", true],
        })
      }).pipe(
        Effect.provide(RawProviderTransport),
        Effect.provide(mockTransport)
      )

      expect(result).toEqual(mockBlock)
    })
  )
})
```

## Sequential Requests

Handles multiple sequential requests.

```typescript
import { describe, expect, it } from "@effect/vitest"
import * as Effect from "effect/Effect"
import * as Layer from "effect/Layer"
import { TransportService } from "voltaire-effect"
import { RawProviderService } from "voltaire-effect"
import { RawProviderTransport } from "voltaire-effect"

describe("sequential requests", () => {
  it.effect("handles multiple sequential requests", () =>
    Effect.gen(function* () {
      let callCount = 0
      const mockTransport = Layer.succeed(TransportService, {
        request: <T>(method: string, _params?: unknown[]) => {
          callCount++
          if (method === "eth_blockNumber") {
            return Effect.succeed("0x100" as T)
          }
          if (method === "eth_chainId") {
            return Effect.succeed("0x1" as T)
          }
          return Effect.succeed("0x0" as T)
        },
      })

      const result = yield* Effect.gen(function* () {
        const raw = yield* RawProviderService
        const blockNum = yield* raw.request({ method: "eth_blockNumber" })
        const chainId = yield* raw.request({ method: "eth_chainId" })
        return { blockNum, chainId }
      }).pipe(
        Effect.provide(RawProviderTransport),
        Effect.provide(mockTransport)
      )

      expect(callCount).toBe(2)
      expect(result.blockNum).toBe("0x100")
      expect(result.chainId).toBe("0x1")
    })
  )
})
```
