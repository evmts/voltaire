---
title: Signature Tests
description: Test examples for signature verification utilities including EIP-191 message hashing and recovery.
---

## Constant-Time Comparison

Compares two byte arrays in constant time to prevent timing attacks.

```typescript
import { constantTimeEqual } from 'voltaire-effect/crypto/Signature'

const a = new Uint8Array([1, 2, 3, 4, 5])
const b = new Uint8Array([1, 2, 3, 4, 5])
const c = new Uint8Array([1, 2, 3, 4, 6])

constantTimeEqual(a, b) // true
constantTimeEqual(a, c) // false
```

## Hash a Message (EIP-191)

Hashes a message with the Ethereum Signed Message prefix.

```typescript
import { Effect } from 'effect'
import { hashMessage } from 'voltaire-effect/crypto/Signature'
import { KeccakLive } from 'voltaire-effect/crypto/Keccak256'

const program = Effect.gen(function* () {
  const result = yield* hashMessage('hello world')
  // result is Uint8Array of length 32
}).pipe(Effect.provide(KeccakLive))
```

## Hash Bytes

Hashes raw bytes with EIP-191 prefix.

```typescript
import { Effect } from 'effect'
import { hashMessage } from 'voltaire-effect/crypto/Signature'
import { KeccakLive } from 'voltaire-effect/crypto/Keccak256'

const program = Effect.gen(function* () {
  const bytes = new Uint8Array([1, 2, 3, 4, 5])
  const result = yield* hashMessage(bytes)
  // result is Uint8Array of length 32
}).pipe(Effect.provide(KeccakLive))
```

## Recover Message Address

Recovers the signer's address from a message signature.

```typescript
import { Effect } from 'effect'
import { recoverMessageAddress } from 'voltaire-effect/crypto/Signature'
import { CryptoLive } from 'voltaire-effect/crypto/CryptoLive'

const hexToBytes = (hex: string): Uint8Array => {
  const normalized = hex.startsWith('0x') ? hex.slice(2) : hex
  const bytes = new Uint8Array(normalized.length / 2)
  for (let i = 0; i < bytes.length; i++) {
    bytes[i] = Number.parseInt(normalized.slice(i * 2, i * 2 + 2), 16)
  }
  return bytes
}

const vectorMessage = 'hello world'
const vectorMessageSignature = {
  r: hexToBytes('0x4abf5429c5dcb3faf26e434987bb59016de5e47a2cb97ddf0efee0041ee4562a'),
  s: hexToBytes('0x27f3df3e38ebe155bfe211699e382d645d83963a1004da01e16f6e60512eafa1'),
  v: 27,
}

const program = Effect.gen(function* () {
  const recovered = yield* recoverMessageAddress({
    message: vectorMessage,
    signature: vectorMessageSignature,
  })
  // recovered is Uint8Array of length 20
}).pipe(Effect.provide(CryptoLive))
```

## Verify a Message

Verifies a message signature against an expected address.

```typescript
import { Effect } from 'effect'
import { verifyMessage } from 'voltaire-effect/crypto/Signature'
import { CryptoLive } from 'voltaire-effect/crypto/CryptoLive'
import { Address } from '@tevm/voltaire/Address'

const hexToBytes = (hex: string): Uint8Array => {
  const normalized = hex.startsWith('0x') ? hex.slice(2) : hex
  const bytes = new Uint8Array(normalized.length / 2)
  for (let i = 0; i < bytes.length; i++) {
    bytes[i] = Number.parseInt(normalized.slice(i * 2, i * 2 + 2), 16)
  }
  return bytes
}

const vectorAddressHex = '0x6370ef2f4db3611d657b90667de398a2cc2a370c'
const expectedAddress = Address.fromHex(vectorAddressHex)
const vectorMessage = 'hello world'
const vectorMessageSignature = {
  r: hexToBytes('0x4abf5429c5dcb3faf26e434987bb59016de5e47a2cb97ddf0efee0041ee4562a'),
  s: hexToBytes('0x27f3df3e38ebe155bfe211699e382d645d83963a1004da01e16f6e60512eafa1'),
  v: 27,
}

const program = Effect.gen(function* () {
  const isValid = yield* verifyMessage({
    message: vectorMessage,
    signature: vectorMessageSignature,
    address: expectedAddress,
  })
  // isValid is true
}).pipe(Effect.provide(CryptoLive))
```

## Recover Address from Hash

Recovers the signer's address from a raw hash signature.

```typescript
import { Effect } from 'effect'
import { recoverAddress } from 'voltaire-effect/crypto/Signature'
import { CryptoLive } from 'voltaire-effect/crypto/CryptoLive'
import { Hash } from '@tevm/voltaire/Hash'

const hexToBytes = (hex: string): Uint8Array => {
  const normalized = hex.startsWith('0x') ? hex.slice(2) : hex
  const bytes = new Uint8Array(normalized.length / 2)
  for (let i = 0; i < bytes.length; i++) {
    bytes[i] = Number.parseInt(normalized.slice(i * 2, i * 2 + 2), 16)
  }
  return bytes
}

const vectorHash = '0xaabbccddeeff00112233445566778899aabbccddeeff00112233445566778899'
const vectorHashSignature = {
  r: hexToBytes('0xff651c65eeded46383a4bdcd9170ff659a4f617bb658a46dd456c51ec8cc211a'),
  s: hexToBytes('0x7dc4de91d0c847bf5def995bd043658136fe2135afe69282f7de873990dacb77'),
  v: 28,
}

const program = Effect.gen(function* () {
  const recovered = yield* recoverAddress({
    hash: Hash.from(vectorHash),
    signature: vectorHashSignature,
  })
  // recovered is Uint8Array of length 20
}).pipe(Effect.provide(CryptoLive))
```

## Verify a Hash Signature

Verifies a raw hash signature against an expected address.

```typescript
import { Effect } from 'effect'
import { verifyHash } from 'voltaire-effect/crypto/Signature'
import { CryptoLive } from 'voltaire-effect/crypto/CryptoLive'
import { Address } from '@tevm/voltaire/Address'
import { Hash } from '@tevm/voltaire/Hash'

const hexToBytes = (hex: string): Uint8Array => {
  const normalized = hex.startsWith('0x') ? hex.slice(2) : hex
  const bytes = new Uint8Array(normalized.length / 2)
  for (let i = 0; i < bytes.length; i++) {
    bytes[i] = Number.parseInt(normalized.slice(i * 2, i * 2 + 2), 16)
  }
  return bytes
}

const vectorAddressHex = '0x6370ef2f4db3611d657b90667de398a2cc2a370c'
const expectedAddress = Address.fromHex(vectorAddressHex)
const vectorHash = '0xaabbccddeeff00112233445566778899aabbccddeeff00112233445566778899'
const vectorHashSignature = {
  r: hexToBytes('0xff651c65eeded46383a4bdcd9170ff659a4f617bb658a46dd456c51ec8cc211a'),
  s: hexToBytes('0x7dc4de91d0c847bf5def995bd043658136fe2135afe69282f7de873990dacb77'),
  v: 28,
}

const program = Effect.gen(function* () {
  const isValid = yield* verifyHash({
    hash: Hash.from(vectorHash),
    signature: vectorHashSignature,
    address: expectedAddress,
  })
  // isValid is true
}).pipe(Effect.provide(CryptoLive))
```

## Verify Typed Data Signature

Verifies an EIP-712 typed data signature.

```typescript
import { Effect } from 'effect'
import { verifyTypedData } from 'voltaire-effect/crypto/Signature'
import { CryptoLive } from 'voltaire-effect/crypto/CryptoLive'
import { Address } from '@tevm/voltaire/Address'
import type { TypedData } from '@tevm/voltaire/EIP712'

const hexToBytes = (hex: string): Uint8Array => {
  const normalized = hex.startsWith('0x') ? hex.slice(2) : hex
  const bytes = new Uint8Array(normalized.length / 2)
  for (let i = 0; i < bytes.length; i++) {
    bytes[i] = Number.parseInt(normalized.slice(i * 2, i * 2 + 2), 16)
  }
  return bytes
}

const vectorAddressHex = '0x6370ef2f4db3611d657b90667de398a2cc2a370c'
const expectedAddress = Address.fromHex(vectorAddressHex)

const vectorTypedData: TypedData = {
  domain: { name: 'Test App', version: '1', chainId: 1n },
  types: { Message: [{ name: 'content', type: 'string' }] },
  primaryType: 'Message',
  message: { content: 'Hello, World!' },
}

const vectorTypedSignature = {
  r: hexToBytes('0x518902699cee276b2df67790727fe4a5b2707886db43d171fc48aba66f5b25fc'),
  s: hexToBytes('0x5fc558727f1070827057ef76bb9f7dde6a77b3b7235d613583a06f07c5bbf9f1'),
  v: 28,
}

const program = Effect.gen(function* () {
  const isValid = yield* verifyTypedData({
    typedData: vectorTypedData,
    signature: vectorTypedSignature,
    address: expectedAddress,
  })
  // isValid is true
}).pipe(Effect.provide(CryptoLive))
```

## Error Types

Signature module exports typed errors for handling failures.

```typescript
import { VerifyError, RecoverError, AddressDerivationError } from 'voltaire-effect/crypto/Signature'

const verifyError = VerifyError.of('verification failed')
// verifyError._tag is "VerifyError"
// verifyError.message is "verification failed"

const recoverError = RecoverError.of('recovery failed', { cause: new Error('inner') })
// recoverError._tag is "RecoverError"
// recoverError.cause is the inner error

const addressError = AddressDerivationError.of('invalid public key')
// addressError._tag is "AddressDerivationError"
```

## Constant-Time Address Comparison

Compares 20-byte addresses in constant time.

```typescript
import { constantTimeEqual } from 'voltaire-effect/crypto/Signature'

const addr1 = new Uint8Array(20).fill(0xab)
const addr2 = new Uint8Array(20).fill(0xab)
const addr3 = new Uint8Array(20).fill(0xcd)

constantTimeEqual(addr1, addr2) // true
constantTimeEqual(addr1, addr3) // false
```

## Constant-Time Hash Comparison

Compares 32-byte hashes in constant time.

```typescript
import { constantTimeEqual } from 'voltaire-effect/crypto/Signature'

const hash1 = new Uint8Array(32).fill(0x12)
const hash2 = new Uint8Array(32).fill(0x12)
const hash3 = new Uint8Array(32).fill(0x34)

constantTimeEqual(hash1, hash2) // true
constantTimeEqual(hash1, hash3) // false
```
