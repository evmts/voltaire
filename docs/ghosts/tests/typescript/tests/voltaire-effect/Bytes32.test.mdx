---
title: Bytes32 Tests
description: Test examples for Bytes32 showing 32-byte data parsing, encoding, and comparison.
---

## Parses valid hex input

Demonstrates parsing 32-byte hex strings into Bytes32.

```typescript
import { describe, expect, it } from "@effect/vitest"
import { Bytes32 } from "@tevm/voltaire/Bytes"

it("parses valid hex input", () => {
  const bytes = Bytes32.fromHex(`0x${"ab".repeat(32)}`)
  expect(bytes).toBeInstanceOf(Uint8Array)
  expect(bytes.length).toBe(32)
  expect(bytes[0]).toBe(0xab)
})

it("parses valid hex without 0x prefix", () => {
  const bytes = Bytes32.fromHex("cd".repeat(32))
  expect(bytes.length).toBe(32)
  expect(bytes[0]).toBe(0xcd)
})
```

## Throws on invalid input

Demonstrates that invalid inputs are rejected.

```typescript
import { Bytes32 } from "@tevm/voltaire/Bytes"

it("throws on short hex input", () => {
  expect(() => Bytes32.fromHex(`0x${"ab".repeat(31)}`)).toThrow()
})

it("throws on invalid hex input", () => {
  expect(() => Bytes32.fromHex(`0x${"gg".repeat(32)}`)).toThrow()
})
```

## From bytes

Demonstrates creating Bytes32 from raw byte arrays.

```typescript
import { Bytes32 } from "@tevm/voltaire/Bytes"

it("accepts 32-byte inputs", () => {
  const input = new Uint8Array(32).fill(0xef)
  const bytes = Bytes32.fromBytes(input)
  expect(bytes).toBeInstanceOf(Uint8Array)
  expect(bytes.length).toBe(32)
  expect(bytes[0]).toBe(0xef)
})

it("throws on wrong length inputs", () => {
  expect(() => Bytes32.fromBytes(new Uint8Array(31))).toThrow()
  expect(() => Bytes32.fromBytes(new Uint8Array(33))).toThrow()
})
```

## toHex encoding

Demonstrates encoding Bytes32 to lowercase hex string.

```typescript
import { Bytes32 } from "@tevm/voltaire/Bytes"

it("converts bytes to lowercase hex", () => {
  const bytes = Bytes32.fromHex(`0x${"AB".repeat(32)}`)
  const hex = Bytes32.toHex(bytes)
  expect(hex).toBe(`0x${"ab".repeat(32)}`)
})
```

## Equality comparison

Demonstrates comparing Bytes32 values for equality.

```typescript
import { Bytes32 } from "@tevm/voltaire/Bytes"

it("returns true for equal values", () => {
  const a = Bytes32.fromHex(`0x${"ab".repeat(32)}`)
  const b = Bytes32.fromHex(`0x${"ab".repeat(32)}`)
  expect(Bytes32.equals(a, b)).toBe(true)
})

it("returns false for different values", () => {
  const a = Bytes32.fromHex(`0x${"ab".repeat(32)}`)
  const b = Bytes32.fromHex(`0x${"cd".repeat(32)}`)
  expect(Bytes32.equals(a, b)).toBe(false)
})
```
