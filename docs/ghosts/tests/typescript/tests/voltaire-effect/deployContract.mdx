---
title: deployContract Tests
description: Test examples for deployContract showing contract deployment with constructor encoding.
---

## Deploys contract without constructor args

Demonstrates deploying a contract that has no constructor arguments.

```typescript
import { Effect } from 'effect'
import * as Hash from '@tevm/voltaire/Hash'
import { deployContract } from 'voltaire-effect'

const simpleBytecode = "0x608060405234801561001057600080fd5b50"

const abiWithoutConstructor = [
  {
    type: "function",
    name: "getValue",
    inputs: [],
    outputs: [{ type: "uint256" }],
    stateMutability: "view",
  },
]

const program = deployContract({
  abi: abiWithoutConstructor,
  bytecode: simpleBytecode,
})

const result = await Effect.runPromise(
  Effect.provide(program, FullTestLayer),
)

expect(Hash.equals(result.hash, mockTxHash)).toBe(true)
```

## Deploys contract with constructor args

Shows deploying a contract with ABI-encoded constructor arguments.

```typescript
import { Effect } from 'effect'
import { deployContract } from 'voltaire-effect'

const abiWithConstructor = [
  {
    type: "constructor",
    inputs: [
      { name: "initialValue", type: "uint256" },
      { name: "name", type: "string" },
    ],
    stateMutability: "nonpayable",
  },
]

const program = deployContract({
  abi: abiWithConstructor,
  bytecode: simpleBytecode,
  args: [1000n, "MyContract"],
})

const result = await Effect.runPromise(
  Effect.provide(program, FullTestLayer),
)

// Transaction data includes bytecode + encoded constructor args
```

## Deploys contract with value (payable constructor)

Demonstrates sending ETH value during deployment for payable constructors.

```typescript
import { Effect } from 'effect'
import { deployContract } from 'voltaire-effect'

const abiPayableConstructor = [
  {
    type: "constructor",
    inputs: [{ name: "initialValue", type: "uint256" }],
    stateMutability: "payable",
  },
]

const program = deployContract({
  abi: abiPayableConstructor,
  bytecode: simpleBytecode,
  args: [500n],
  value: 1000000000000000000n, // 1 ETH
})

await Effect.runPromise(Effect.provide(program, FullTestLayer))
```

## Applies custom gas params

Shows specifying custom gas limit and EIP-1559 fee parameters.

```typescript
import { Effect } from 'effect'
import { deployContract } from 'voltaire-effect'

const program = deployContract({
  abi: abiWithoutConstructor,
  bytecode: simpleBytecode,
  gas: 200000n,
  maxFeePerGas: 50000000000n,
  maxPriorityFeePerGas: 3000000000n,
})

await Effect.runPromise(Effect.provide(program, FullTestLayer))
```

## Returns lazy address effect

Demonstrates that the returned address is a lazy Effect that waits for the receipt.

```typescript
import { Effect } from 'effect'
import { deployContract } from 'voltaire-effect'

const program = deployContract({
  abi: abiWithoutConstructor,
  bytecode: simpleBytecode,
})

const result = await Effect.runPromise(
  Effect.provide(program, FullTestLayer),
)

// Hash is available immediately
expect(result.hash).toBeDefined()

// Address requires waiting for receipt (lazy effect)
const address = await Effect.runPromise(
  Effect.provide(result.address, ProviderLayer),
)
```

## Fails when constructor args do not match ABI types

Shows validation error when arguments don't match the expected types.

```typescript
import { Effect } from 'effect'
import { deployContract } from 'voltaire-effect'

const program = deployContract({
  abi: abiWithConstructor,
  bytecode: simpleBytecode,
  args: ["not-a-number", 12345], // Wrong types
})

const result = await Effect.runPromiseExit(
  Effect.provide(program, FullTestLayer),
)

expect(result._tag).toBe("Failure")
```
