---
title: RateLimitedTransport Tests
description: Test examples for rate-limited transport with fail-fast and delay strategies.
---

## Passes through when no rate limiter is provided

Shows that requests work normally without a rate limiter configured.

```typescript
import { describe, expect, it } from "@effect/vitest";
import * as Effect from "effect/Effect";
import {
  RateLimitedTransport,
  TestTransport,
  TransportService,
} from "voltaire-effect";

it.effect("passes through when no rate limiter is provided", () =>
  Effect.gen(function* () {
    const transport = yield* TransportService;
    const result = yield* transport.request<string>("eth_call", []);
    expect(result).toBe("0x1");
  }).pipe(
    Effect.provide(RateLimitedTransport(TestTransport({ eth_call: "0x1" }))),
  ),
);
```

## Fails fast when onExceeded is fail

Demonstrates fail-fast rate limiting that rejects immediately when limit is exceeded.

```typescript
import * as Effect from "effect/Effect";
import { DefaultRateLimiter } from "voltaire-effect";
import {
  RateLimitedTransport,
  TestTransport,
  TransportError,
  TransportService,
} from "voltaire-effect";

it.effect("fails fast when onExceeded is fail", () =>
  Effect.gen(function* () {
    const transport = yield* TransportService;
    const first = yield* transport.request<string>("eth_call", []);
    expect(first).toBe("0x1");

    const error = yield* transport.request<string>("eth_call", []).pipe(Effect.flip);
    expect(error).toBeInstanceOf(TransportError);
    expect(error.code).toBe(-32005);
    expect(error.message).toMatch(/rate limit exceeded/i);
  }).pipe(
    Effect.scoped,
    Effect.provide(RateLimitedTransport(TestTransport({ eth_call: "0x1" }))),
    Effect.provide(
      DefaultRateLimiter({
        global: { limit: 1, interval: "1 seconds" },
        onExceeded: "fail",
      }),
    ),
  ),
);
```

## Delays when onExceeded is delay

Shows delay-based rate limiting that waits before retrying.

```typescript
import * as Duration from "effect/Duration";
import * as Effect from "effect/Effect";
import * as Fiber from "effect/Fiber";
import * as TestClock from "effect/TestClock";
import { DefaultRateLimiter } from "voltaire-effect";
import {
  RateLimitedTransport,
  TestTransport,
  TransportService,
} from "voltaire-effect";

it.effect("delays when onExceeded is delay", () =>
  Effect.gen(function* () {
    const transport = yield* TransportService;
    const fiber1 = yield* Effect.fork(transport.request<string>("eth_call", []));
    const fiber2 = yield* Effect.fork(transport.request<string>("eth_call", []));

    yield* Effect.yieldNow();
    yield* Effect.yieldNow();

    const pending = yield* Fiber.poll(fiber2);
    expect(pending._tag).toBe("None");  // Second request is waiting

    yield* TestClock.adjust(Duration.seconds(1));

    const r1 = yield* Fiber.join(fiber1);
    const r2 = yield* Fiber.join(fiber2);

    expect(r1).toBe("0x1");
    expect(r2).toBe("0x1");
  }).pipe(
    Effect.scoped,
    Effect.provide(RateLimitedTransport(TestTransport({ eth_call: "0x1" }))),
    Effect.provide(
      DefaultRateLimiter({
        global: { limit: 1, interval: "1 seconds" },
        onExceeded: "delay",
      }),
    ),
  ),
);
```

## Applies per-method limits with fixed-window strategy

Demonstrates method-specific rate limits with different limits per RPC method.

```typescript
import * as Effect from "effect/Effect";
import { DefaultRateLimiter } from "voltaire-effect";
import {
  RateLimitedTransport,
  TestTransport,
  TransportError,
  TransportService,
} from "voltaire-effect";

it.effect("applies per-method limits with fixed-window strategy", () =>
  Effect.gen(function* () {
    const transport = yield* TransportService;
    
    // eth_chainId has no limit
    const ok = yield* transport.request<string>("eth_chainId", []);
    expect(ok).toBe("0x1");

    // eth_call is limited to 1 per second
    yield* transport.request<string>("eth_call", []);
    const error = yield* transport.request<string>("eth_call", []).pipe(Effect.flip);

    expect(error).toBeInstanceOf(TransportError);
    expect(error.code).toBe(-32005);
  }).pipe(
    Effect.scoped,
    Effect.provide(
      RateLimitedTransport(
        TestTransport({ eth_call: "0x1", eth_chainId: "0x1" }),
      ),
    ),
    Effect.provide(
      DefaultRateLimiter({
        methods: {
          eth_call: {
            limit: 1,
            interval: "1 seconds",
            algorithm: "fixed-window",
          },
        },
        onExceeded: "fail",
      }),
    ),
  ),
);
```
