---
title: Hash Tests
description: Test examples for Hash showing 32-byte hash parsing, Keccak256 hashing, Merkle root computation, and utility functions.
---

## Parse Hex Hash

Parses 32-byte hash from 66-character hex string.

```typescript
import { describe, expect, it } from "@effect/vitest"
import * as S from "effect/Schema"
import * as Hash from "voltaire-effect/primitives/Hash"

const hash = S.decodeSync(Hash.Hex)(`0x${"ab".repeat(32)}`)
expect(hash).toBeInstanceOf(Uint8Array)
expect(hash.length).toBe(32)
```

## Encode to Lowercase Hex

Encodes hash to lowercase hex with 0x prefix.

```typescript
import * as S from "effect/Schema"
import * as Hash from "voltaire-effect/primitives/Hash"

const hash = S.decodeSync(Hash.Hex)(`0x${"AB".repeat(32)}`)
const hex = S.encodeSync(Hash.Hex)(hash)
expect(hex).toBe(`0x${"ab".repeat(32)}`)
```

## Parse Bytes Hash

Parses hash from 32-byte Uint8Array.

```typescript
import * as S from "effect/Schema"
import * as Hash from "voltaire-effect/primitives/Hash"

const bytes = new Uint8Array(32).fill(0xab)
const hash = S.decodeSync(Hash.Bytes)(bytes)
expect(hash.length).toBe(32)
```

## Keccak256 Hashing

Computes Keccak256 hash of bytes, hex, or string.

```typescript
import * as Effect from "effect/Effect"
import * as S from "effect/Schema"
import * as Hash from "voltaire-effect/primitives/Hash"

// Hash empty bytes
const emptyHash = Effect.runSync(Hash.keccak256(new Uint8Array(0)))
const emptyHex = S.encodeSync(Hash.Hex)(emptyHash)
expect(emptyHex).toBe("0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470")

// Hash string
const helloHash = Effect.runSync(Hash.keccak256String("hello"))
const helloHex = S.encodeSync(Hash.Hex)(helloHash)
expect(helloHex).toBe("0x1c8aff950685c2ed4bc3174f3472287b56d9517b9c948127319a09a7a36deac8")

// Hash hex
const hexHash = Effect.runSync(Hash.keccak256Hex("0x0102030405"))
const bytesHash = Effect.runSync(Hash.keccak256(new Uint8Array([1, 2, 3, 4, 5])))
expect(Effect.runSync(Hash.equals(hexHash, bytesHash))).toBe(true)
```

## Check Zero Hash

Checks if hash is all zeros.

```typescript
import * as Effect from "effect/Effect"
import * as S from "effect/Schema"
import * as Hash from "voltaire-effect/primitives/Hash"

const zeroHash = S.decodeSync(Hash.Hex)(`0x${"00".repeat(32)}`)
expect(Effect.runSync(Hash.isZero(zeroHash))).toBe(true)

const nonZero = S.decodeSync(Hash.Hex)(`0x${"ab".repeat(32)}`)
expect(Effect.runSync(Hash.isZero(nonZero))).toBe(false)
```

## Clone Hash

Creates an independent copy of a hash.

```typescript
import * as Effect from "effect/Effect"
import * as S from "effect/Schema"
import * as Hash from "voltaire-effect/primitives/Hash"

const original = S.decodeSync(Hash.Hex)(`0x${"ab".repeat(32)}`)
const cloned = Effect.runSync(Hash.clone(original))

expect(cloned).not.toBe(original) // Different object
cloned[0] = 0x00
expect(original[0]).toBe(0xab) // Original unchanged
```

## Compare Hashes

Compares two hashes for equality.

```typescript
import * as Effect from "effect/Effect"
import * as S from "effect/Schema"
import * as Hash from "voltaire-effect/primitives/Hash"

const hashA = S.decodeSync(Hash.Hex)(`0x${"ab".repeat(32)}`)
const hashACopy = S.decodeSync(Hash.Hex)(`0x${"ab".repeat(32)}`)
const hashB = S.decodeSync(Hash.Hex)(`0x${"cd".repeat(32)}`)

expect(Effect.runSync(Hash.equals(hashA, hashACopy))).toBe(true)
expect(Effect.runSync(Hash.equals(hashA, hashB))).toBe(false)
```

## Concatenate and Hash

Concatenates multiple hashes and computes Keccak256 of the result.

```typescript
import * as Effect from "effect/Effect"
import * as S from "effect/Schema"
import * as Hash from "voltaire-effect/primitives/Hash"
import * as BaseHash from "@tevm/voltaire/Hash"

const hashA = S.decodeSync(Hash.Hex)(`0x${"ab".repeat(32)}`)
const hashB = S.decodeSync(Hash.Hex)(`0x${"cd".repeat(32)}`)

const ab = Effect.runSync(Hash.concat(hashA, hashB))
const ba = Effect.runSync(Hash.concat(hashB, hashA))
expect(BaseHash.equals(ab, ba)).toBe(false) // Order matters
```

## Merkle Root

Computes Merkle tree root from array of hashes.

```typescript
import * as Effect from "effect/Effect"
import * as S from "effect/Schema"
import * as Hash from "voltaire-effect/primitives/Hash"
import * as BaseHash from "@tevm/voltaire/Hash"

const leaves = [
  S.decodeSync(Hash.Hex)(`0x${"11".repeat(32)}`),
  S.decodeSync(Hash.Hex)(`0x${"22".repeat(32)}`),
]
const root1 = Effect.runSync(Hash.merkleRoot(leaves))
const root2 = Effect.runSync(Hash.merkleRoot(leaves))
expect(BaseHash.equals(root1, root2)).toBe(true) // Deterministic
```

## Slice Hash

Extracts a portion of a hash.

```typescript
import * as Effect from "effect/Effect"
import * as S from "effect/Schema"
import * as Hash from "voltaire-effect/primitives/Hash"

const hash = S.decodeSync(Hash.Hex)(`0x${"ab".repeat(32)}`)

const first4 = Effect.runSync(Hash.slice(hash, 0, 4))
expect(first4.length).toBe(4)
expect(first4[0]).toBe(0xab)

const last4 = Effect.runSync(Hash.slice(hash, 28, 32))
expect(last4.length).toBe(4)
```

## Random Hash

Generates a cryptographically random 32-byte hash.

```typescript
import * as Effect from "effect/Effect"
import * as S from "effect/Schema"
import * as Hash from "voltaire-effect/primitives/Hash"

const hash = await Effect.runPromise(Hash.random())
const hex = S.encodeSync(Hash.Hex)(hash)
expect(hex.startsWith("0x")).toBe(true)
expect(hex.length).toBe(66)
```
