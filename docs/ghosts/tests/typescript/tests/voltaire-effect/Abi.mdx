---
title: Abi Tests
description: Test examples for Abi showing parsing, encoding, and decoding of ABI functions, events, and errors.
---

## Parse JSON ABI

Parses ABI from JSON string.

```typescript
import { describe, expect, it } from "@effect/vitest"
import { Abi } from "@tevm/voltaire/Abi"
import * as Effect from "effect/Effect"
import { parse } from "voltaire-effect/primitives/Abi/parse"

const erc20Abi = Abi([
  {
    type: "function",
    name: "transfer",
    stateMutability: "nonpayable",
    inputs: [
      { name: "to", type: "address" },
      { name: "amount", type: "uint256" },
    ],
    outputs: [{ type: "bool" }],
  },
])

const jsonString = JSON.stringify(erc20Abi)
const abi = await Effect.runPromise(parse(jsonString))
expect(Array.isArray(abi)).toBe(true)
expect(abi.length).toBe(1)
```

## Encode Function Data

Encodes function call with arguments to calldata.

```typescript
import { Abi } from "@tevm/voltaire/Abi"
import * as Effect from "effect/Effect"
import { encodeFunctionData } from "voltaire-effect/primitives/Abi/encodeFunctionData"

const erc20Abi = Abi([
  {
    type: "function",
    name: "transfer",
    stateMutability: "nonpayable",
    inputs: [
      { name: "to", type: "address" },
      { name: "amount", type: "uint256" },
    ],
    outputs: [{ type: "bool" }],
  },
])

const calldata = await Effect.runPromise(
  encodeFunctionData(erc20Abi, "transfer", [
    "0x1111111111111111111111111111111111111111",
    1000000000000000000n,
  ])
)
expect(calldata.startsWith("0xa9059cbb")).toBe(true) // transfer selector
expect(calldata.length).toBe(138) // 4 bytes selector + 2 * 32 bytes params
```

## Decode Function Data

Decodes calldata back to function name and arguments.

```typescript
import { Abi } from "@tevm/voltaire/Abi"
import * as Effect from "effect/Effect"
import { encodeFunctionData } from "voltaire-effect/primitives/Abi/encodeFunctionData"
import { decodeFunctionData } from "voltaire-effect/primitives/Abi/decodeFunctionData"

const calldata = await Effect.runPromise(
  encodeFunctionData(erc20Abi, "transfer", [
    "0x1111111111111111111111111111111111111111",
    1000n,
  ])
)

const decoded = await Effect.runPromise(
  decodeFunctionData(erc20Abi, calldata)
)
expect(decoded.functionName).toBe("transfer")
expect(decoded.args[1]).toBe(1000n)
```

## Decode Function Result

Decodes return data from function call.

```typescript
import { Abi } from "@tevm/voltaire/Abi"
import { Hex } from "@tevm/voltaire"
import * as Effect from "effect/Effect"
import { decodeFunctionResult } from "voltaire-effect/primitives/Abi/decodeFunctionResult"

const erc20Abi = Abi([
  {
    type: "function",
    name: "balanceOf",
    stateMutability: "view",
    inputs: [{ name: "account", type: "address" }],
    outputs: [{ type: "uint256" }],
  },
])

// Decode uint256 return value (1 ETH)
const result = await Effect.runPromise(
  decodeFunctionResult(
    erc20Abi,
    "balanceOf",
    Hex(`0x${"00".repeat(31)}01`) // 1n as uint256
  )
)
expect(result).toBe(1n)
```

## Encode Event Log

Encodes event with topics and data.

```typescript
import { Abi } from "@tevm/voltaire/Abi"
import * as Effect from "effect/Effect"
import { encodeEventLog } from "voltaire-effect/primitives/Abi/encodeEventLog"

const erc20Abi = Abi([
  {
    type: "event",
    name: "Transfer",
    inputs: [
      { name: "from", type: "address", indexed: true },
      { name: "to", type: "address", indexed: true },
      { name: "value", type: "uint256", indexed: false },
    ],
  },
])

const { topics, data } = await Effect.runPromise(
  encodeEventLog(erc20Abi, "Transfer", [
    "0x1111111111111111111111111111111111111111",
    "0x2222222222222222222222222222222222222222",
    1000000000000000000n,
  ])
)
expect(topics.length).toBe(3) // event sig + 2 indexed params
expect(data.length).toBe(32) // 1 non-indexed param
```

## Encode Error Data

Encodes custom error with parameters.

```typescript
import { Abi } from "@tevm/voltaire/Abi"
import * as Effect from "effect/Effect"
import { encodeError } from "voltaire-effect/primitives/Abi/encodeError"

const abi = Abi([
  {
    type: "error",
    name: "InsufficientBalance",
    inputs: [
      { name: "available", type: "uint256" },
      { name: "required", type: "uint256" },
    ],
  },
])

const encoded = await Effect.runPromise(
  encodeError(abi, "InsufficientBalance", [100n, 1000n])
)
expect(encoded.startsWith("0x")).toBe(true)
expect(encoded.length).toBeGreaterThan(10)
```

## Decode Error Data

Decodes custom error back to parameters.

```typescript
import { Abi } from "@tevm/voltaire/Abi"
import * as Effect from "effect/Effect"
import { encodeError } from "voltaire-effect/primitives/Abi/encodeError"
import { decodeError } from "voltaire-effect/primitives/Abi/decodeError"

const encoded = await Effect.runPromise(
  encodeError(abi, "InsufficientBalance", [100n, 1000n])
)

const decoded = await Effect.runPromise(
  decodeError(abi, "InsufficientBalance", encoded)
)
expect(decoded[0]).toBe(100n)
expect(decoded[1]).toBe(1000n)
```

## Handle Tuple Types

Encodes and decodes functions with tuple parameters.

```typescript
import { Abi } from "@tevm/voltaire/Abi"
import * as Effect from "effect/Effect"
import { encodeFunctionData } from "voltaire-effect/primitives/Abi/encodeFunctionData"
import { decodeFunctionData } from "voltaire-effect/primitives/Abi/decodeFunctionData"

const abi = Abi([
  {
    type: "function",
    name: "submitOrder",
    stateMutability: "nonpayable",
    inputs: [
      {
        name: "order",
        type: "tuple",
        components: [
          { name: "maker", type: "address" },
          { name: "taker", type: "address" },
          { name: "amount", type: "uint256" },
          { name: "price", type: "uint256" },
        ],
      },
    ],
    outputs: [{ type: "bytes32" }],
  },
])

const order = {
  maker: "0x1111111111111111111111111111111111111111",
  taker: "0x2222222222222222222222222222222222222222",
  amount: 1000n,
  price: 50n,
}

const calldata = await Effect.runPromise(
  encodeFunctionData(abi, "submitOrder", [order])
)
expect(calldata.startsWith("0x")).toBe(true)
```

## Handle Dynamic Arrays

Encodes functions with dynamic array parameters.

```typescript
import { Abi } from "@tevm/voltaire/Abi"
import * as Effect from "effect/Effect"
import { encodeFunctionData } from "voltaire-effect/primitives/Abi/encodeFunctionData"

const abi = Abi([
  {
    type: "function",
    name: "batchTransfer",
    stateMutability: "nonpayable",
    inputs: [
      { name: "recipients", type: "address[]" },
      { name: "amounts", type: "uint256[]" },
    ],
    outputs: [{ type: "bool" }],
  },
])

const calldata = await Effect.runPromise(
  encodeFunctionData(abi, "batchTransfer", [
    [
      "0x1111111111111111111111111111111111111111",
      "0x2222222222222222222222222222222222222222",
    ],
    [100n, 200n],
  ])
)
expect(calldata.startsWith("0x")).toBe(true)
```

## Handle Max Uint256

Encodes maximum uint256 value correctly.

```typescript
import { Abi } from "@tevm/voltaire/Abi"
import * as Effect from "effect/Effect"
import { encodeFunctionData } from "voltaire-effect/primitives/Abi/encodeFunctionData"

const maxUint256 = 2n ** 256n - 1n

const calldata = await Effect.runPromise(
  encodeFunctionData(erc20Abi, "transfer", [
    "0x1111111111111111111111111111111111111111",
    maxUint256,
  ])
)
expect(calldata).toContain("f".repeat(64))
```

## Error Types

AbiParseError and AbiItemParseError are catchable Effect errors.

```typescript
import { AbiParseError } from "voltaire-effect/primitives/Abi/parse"
import { AbiItemParseError } from "voltaire-effect/primitives/Abi/parseItem"

const parseError = new AbiParseError({ message: "Failed to parse ABI" })
expect(parseError._tag).toBe("AbiParseError")

const itemError = new AbiItemParseError({ message: "Invalid item" })
expect(itemError._tag).toBe("AbiItemParseError")
```
