---
title: PackedUserOperation hash Tests
description: Test examples for computing ERC-4337 packed user operation hashes.
---

## Produces deterministic 32-byte hash

Computes consistent hash for same inputs.

```typescript
import { describe, expect, it } from "@effect/vitest"
import { Address } from "voltaire/Address"
import * as Effect from "effect/Effect"
import * as PackedUserOperation from "voltaire-effect/primitives/PackedUserOperation"
import type { PackedUserOperationType } from "voltaire-effect/primitives/PackedUserOperation"

const mockPackedUserOp: PackedUserOperationType = {
  sender: new Uint8Array(20) as PackedUserOperationType["sender"],
  nonce: 0n,
  initCode: new Uint8Array(0),
  callData: new Uint8Array(0),
  accountGasLimits: new Uint8Array(32),
  preVerificationGas: 21000n,
  gasFees: new Uint8Array(32),
  paymasterAndData: new Uint8Array(0),
  signature: new Uint8Array(0),
}

const entryPointAddress = "0x0000000071727De22E5E9d8BAf0edAc6f37da032"

it("produces deterministic 32-byte hash", async () => {
  const result = await Effect.runPromise(
    PackedUserOperation.hash(mockPackedUserOp, entryPointAddress, 1n),
  )
  expect(result).toBeInstanceOf(Uint8Array)
  expect(result.length).toBe(32)

  const result2 = await Effect.runPromise(
    PackedUserOperation.hash(mockPackedUserOp, entryPointAddress, 1n),
  )
  expect(result).toEqual(result2)
})
```

## ChainId as number vs bigint yields same result

Accepts chainId as either number or bigint.

```typescript
it("chainId as number vs bigint yields same result", async () => {
  const resultBigInt = await Effect.runPromise(
    PackedUserOperation.hash(mockPackedUserOp, entryPointAddress, 1n),
  )
  const resultNumber = await Effect.runPromise(
    PackedUserOperation.hash(mockPackedUserOp, entryPointAddress, 1),
  )
  expect(resultBigInt).toEqual(resultNumber)
})
```

## EntryPoint as Uint8Array works

Accepts entryPoint as raw bytes.

```typescript
it("entryPoint as Uint8Array works", async () => {
  const entryPointBytes = Address(entryPointAddress)
  const resultString = await Effect.runPromise(
    PackedUserOperation.hash(mockPackedUserOp, entryPointAddress, 1n),
  )
  const resultBytes = await Effect.runPromise(
    PackedUserOperation.hash(mockPackedUserOp, entryPointBytes, 1n),
  )
  expect(resultString).toEqual(resultBytes)
})
```

## Invalid entryPoint triggers ValidationError

Returns failure for invalid address format.

```typescript
import * as Exit from "effect/Exit"

it("invalid entryPoint triggers ValidationError", async () => {
  const exit = await Effect.runPromiseExit(
    PackedUserOperation.hash(mockPackedUserOp, "invalid-address", 1n),
  )
  expect(Exit.isFailure(exit)).toBe(true)
})
```

## Different chainIds produce different hashes

ChainId is included in hash computation.

```typescript
it("different chainIds produce different hashes", async () => {
  const hash1 = await Effect.runPromise(
    PackedUserOperation.hash(mockPackedUserOp, entryPointAddress, 1n),
  )
  const hash137 = await Effect.runPromise(
    PackedUserOperation.hash(mockPackedUserOp, entryPointAddress, 137n),
  )
  expect(hash1).not.toEqual(hash137)
})
```
