---
title: Transport Tests
description: Test examples for Transport service showing TestTransport, HttpTransport, and WebSocketTransport usage.
---

## TestTransport - Returns mocked responses

Demonstrates using TestTransport for mocking RPC responses in tests.

```typescript
import { Effect } from 'effect'
import { TestTransport, TransportService } from 'voltaire-effect'

const program = Effect.gen(function* () {
  const transport = yield* TransportService
  return yield* transport.request<string>("eth_blockNumber", [])
}).pipe(Effect.provide(TestTransport({ eth_blockNumber: "0x1234" })))

const result = await Effect.runPromise(program)
expect(result).toBe("0x1234")
```

## TestTransport - Returns mocked responses from Map

Shows using a Map for more complex mock configurations.

```typescript
import { Effect } from 'effect'
import { TestTransport, TransportService } from 'voltaire-effect'

const responses = new Map([["eth_chainId", "0x1"]])
const program = Effect.gen(function* () {
  const transport = yield* TransportService
  return yield* transport.request<string>("eth_chainId", [])
}).pipe(Effect.provide(TestTransport(responses)))

const result = await Effect.runPromise(program)
expect(result).toBe("0x1")
```

## TestTransport - Fails for unknown methods

Demonstrates that unmocked methods produce errors.

```typescript
import { Effect } from 'effect'
import { TestTransport, TransportService } from 'voltaire-effect'

const program = Effect.gen(function* () {
  const transport = yield* TransportService
  return yield* transport.request<string>("eth_unknown", [])
}).pipe(Effect.provide(TestTransport({})))

const exit = await Effect.runPromiseExit(program)
expect(exit._tag).toBe("Failure")
```

## TestTransport - Can mock errors

Shows how to mock transport errors.

```typescript
import { Effect } from 'effect'
import { TestTransport, TransportService, TransportError } from 'voltaire-effect'

const responses = new Map([
  ["eth_call", new TransportError({ code: -32000, message: "execution reverted" })],
])

const program = Effect.gen(function* () {
  const transport = yield* TransportService
  return yield* transport.request<string>("eth_call", [])
}).pipe(Effect.provide(TestTransport(responses)))

const exit = await Effect.runPromiseExit(program)
expect(exit._tag).toBe("Failure")
```

## TestTransport - Returns complex object responses

Demonstrates mocking complex structured responses.

```typescript
import { Effect } from 'effect'
import { TestTransport, TransportService } from 'voltaire-effect'

const mockBlock = {
  number: "0x10",
  hash: "0xabc",
  transactions: ["0x1", "0x2"],
}

const program = Effect.gen(function* () {
  const transport = yield* TransportService
  return yield* transport.request<typeof mockBlock>("eth_getBlockByNumber", [])
}).pipe(Effect.provide(TestTransport({ eth_getBlockByNumber: mockBlock })))

const result = await Effect.runPromise(program)
expect(result.number).toBe("0x10")
expect(result.transactions).toHaveLength(2)
```

## HttpTransport - Makes JSON-RPC requests

Shows using HttpTransport for HTTP-based RPC calls.

```typescript
import { Effect } from 'effect'
import { HttpTransport, TransportService } from 'voltaire-effect'

const program = Effect.gen(function* () {
  const transport = yield* TransportService
  return yield* transport.request<string>("eth_blockNumber", [])
}).pipe(
  Effect.provide(
    HttpTransport({
      url: "https://eth.example.com",
    }),
  ),
)

const result = await Effect.runPromise(program)
```

## HttpTransport - Accepts URL string directly

Demonstrates simplified HttpTransport configuration with just a URL.

```typescript
import { Effect } from 'effect'
import { HttpTransport, TransportService } from 'voltaire-effect'

const program = Effect.gen(function* () {
  const transport = yield* TransportService
  return yield* transport.request<string>("eth_chainId", [])
}).pipe(Effect.provide(HttpTransport("https://eth.example.com")))
```

## HttpTransport - Batches requests

Shows automatic request batching for concurrent calls.

```typescript
import { Effect } from 'effect'
import { HttpTransport, TransportService } from 'voltaire-effect'

const program = Effect.gen(function* () {
  const transport = yield* TransportService
  return yield* Effect.all([
    transport.request<string>("eth_blockNumber", []),
    transport.request<string>("eth_chainId", []),
    transport.request<string>("eth_gasPrice", []),
  ])
}).pipe(
  Effect.provide(
    HttpTransport({
      url: "https://eth.example.com",
      batch: { maxSize: 10, maxWait: 10 },
    }),
  ),
)
// All three requests are batched into a single HTTP call
```

## WebSocketTransport - Makes persistent connection requests

Demonstrates using WebSocket transport for real-time connections.

```typescript
import { Effect, Layer } from 'effect'
import { 
  WebSocketTransport, 
  TransportService, 
  WebSocketConstructorGlobal 
} from 'voltaire-effect'

const program = Effect.gen(function* () {
  const transport = yield* TransportService
  return yield* transport.request<string>("eth_blockNumber", [])
}).pipe(
  Effect.provide(
    Layer.provide(
      WebSocketTransport({ url: "ws://localhost:8545" }),
      WebSocketConstructorGlobal,
    ),
  ),
  Effect.scoped,
)

const result = await Effect.runPromise(program)
```

## WebSocketTransport - Reconnects after disconnect

Shows automatic reconnection behavior for WebSocket transport.

```typescript
import { Effect, Layer } from 'effect'
import { 
  WebSocketTransport, 
  TransportService, 
  WebSocketConstructorGlobal 
} from 'voltaire-effect'

const program = Effect.gen(function* () {
  const transport = yield* TransportService

  const result1 = yield* transport.request<string>("eth_blockNumber", [])
  
  // Simulate disconnect...
  yield* Effect.sleep(50)

  // Reconnects automatically
  const result2 = yield* transport.request<string>("eth_blockNumber", [])

  return { result1, result2 }
}).pipe(
  Effect.provide(
    Layer.provide(
      WebSocketTransport({
        url: "ws://localhost:8545",
        reconnect: { delay: 10, maxAttempts: 3 },
      }),
      WebSocketConstructorGlobal,
    ),
  ),
  Effect.scoped,
)
```

## WebSocketTransport - Sends keep-alive pings

Demonstrates keep-alive configuration for long-lived connections.

```typescript
import { Effect, Layer } from 'effect'
import { 
  WebSocketTransport, 
  TransportService, 
  WebSocketConstructorGlobal 
} from 'voltaire-effect'

const program = Effect.gen(function* () {
  yield* TransportService
  yield* Effect.sleep(150)
  // Keep-alive pings sent every 50ms
}).pipe(
  Effect.provide(
    Layer.provide(
      WebSocketTransport({
        url: "ws://localhost:8545",
        keepAlive: 50,
      }),
      WebSocketConstructorGlobal,
    ),
  ),
  Effect.scoped,
)
```

## TransportError - Preserves error code and data

Shows that TransportError maintains error details.

```typescript
import { Effect } from 'effect'
import { TestTransport, TransportService, TransportError } from 'voltaire-effect'

const errorData = { revertReason: "0x08c379a0..." }

const program = Effect.gen(function* () {
  const transport = yield* TransportService
  return yield* transport.request<string>("eth_call", [])
}).pipe(
  Effect.provide(
    TestTransport({
      eth_call: new TransportError({
        code: -32000,
        message: "reverted",
        data: errorData,
      }),
    }),
  ),
)

const exit = await Effect.runPromiseExit(program)
if (exit._tag === "Failure" && exit.cause._tag === "Fail") {
  const error = exit.cause.error as TransportError
  expect(error.code).toBe(-32000)
  expect(error.data).toEqual(errorData)
}
```
