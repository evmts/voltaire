---
title: Secp256k1 Tests
description: Test examples for secp256k1 showing ECDSA signing, recovery, and verification.
---

## Sign a Message Hash

Signs a 32-byte message hash with a private key, returning r, s, and v values.

```typescript
import { Effect } from 'effect'
import * as Secp256k1 from 'voltaire-effect/crypto/Secp256k1'
import { Hash } from '@tevm/voltaire'

const testPrivateKeyBytes = new Uint8Array([
  0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
  0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10,
  0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18,
  0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0x20,
])
const testMessageHash = Hash.from(new Uint8Array(32).fill(0xab))

const program = Effect.gen(function* () {
  const result = yield* Secp256k1.sign(testMessageHash, testPrivateKeyBytes)
  // result.r is Uint8Array of length 32
  // result.s is Uint8Array of length 32
  // result.v is 27 or 28
})
```

## Deterministic Signatures (RFC 6979)

Secp256k1 produces deterministic signatures per RFC 6979.

```typescript
import { Effect } from 'effect'
import * as Secp256k1 from 'voltaire-effect/crypto/Secp256k1'
import { Hash } from '@tevm/voltaire'

const testPrivateKeyBytes = new Uint8Array(32).fill(0x42)
const testMessageHash = Hash.from(new Uint8Array(32).fill(0xab))

const program = Effect.gen(function* () {
  const sig1 = yield* Secp256k1.sign(testMessageHash, testPrivateKeyBytes)
  const sig2 = yield* Secp256k1.sign(testMessageHash, testPrivateKeyBytes)
  // sig1.r equals sig2.r
  // sig1.s equals sig2.s
  // sig1.v equals sig2.v
})
```

## Recover Public Key

Recovers the 64-byte public key from a signature and message hash.

```typescript
import { Effect } from 'effect'
import * as Secp256k1 from 'voltaire-effect/crypto/Secp256k1'
import * as VoltaireSecp256k1 from '@tevm/voltaire/Secp256k1'
import { Hash } from '@tevm/voltaire'

const testPrivateKeyBytes = new Uint8Array(32).fill(0x42)
const testMessageHash = Hash.from(new Uint8Array(32).fill(0xab))

const program = Effect.gen(function* () {
  const signature = yield* Secp256k1.sign(testMessageHash, testPrivateKeyBytes)
  const recovered = yield* Secp256k1.recover(signature, testMessageHash)
  // recovered is Uint8Array of length 64
  const expected = VoltaireSecp256k1.derivePublicKey(testPrivateKeyBytes)
  // recovered equals expected
})
```

## Verify a Signature

Verifies a signature against a message hash and public key.

```typescript
import { Effect } from 'effect'
import * as Secp256k1 from 'voltaire-effect/crypto/Secp256k1'
import * as VoltaireSecp256k1 from '@tevm/voltaire/Secp256k1'
import { Hash } from '@tevm/voltaire'

const testPrivateKeyBytes = new Uint8Array(32).fill(0x42)
const testMessageHash = Hash.from(new Uint8Array(32).fill(0xab))

const program = Effect.gen(function* () {
  const signature = yield* Secp256k1.sign(testMessageHash, testPrivateKeyBytes)
  const publicKey = VoltaireSecp256k1.derivePublicKey(testPrivateKeyBytes)
  const isValid = yield* Secp256k1.verify(signature, testMessageHash, publicKey)
  // isValid is true
})
```

## Service Layer Usage

Uses the Secp256k1Service with dependency injection.

```typescript
import { Effect } from 'effect'
import { Secp256k1Service, Secp256k1Live } from 'voltaire-effect/crypto/Secp256k1'
import { Hash } from '@tevm/voltaire'

const testPrivateKeyBytes = new Uint8Array(32).fill(0x42)
const testMessageHash = Hash.from(new Uint8Array(32).fill(0xab))

const program = Effect.gen(function* () {
  const secp = yield* Secp256k1Service
  const sig = yield* secp.sign(testMessageHash, testPrivateKeyBytes)
  const pubKey = yield* secp.recover(sig, testMessageHash)
  const result = yield* secp.verify(sig, testMessageHash, pubKey)
  // result is true
}).pipe(Effect.provide(Secp256k1Live))
```

## Test Layer for Mocking

Uses the Secp256k1Test layer for testing with mock implementations.

```typescript
import { Effect } from 'effect'
import { Secp256k1Service, Secp256k1Test } from 'voltaire-effect/crypto/Secp256k1'
import { Hash } from '@tevm/voltaire'

const testMessageHash = Hash.from(new Uint8Array(32).fill(0xab))

const program = Effect.gen(function* () {
  const secp = yield* Secp256k1Service
  const result = yield* secp.sign(testMessageHash, new Uint8Array(32))
  // result has r, s, v properties (mock values)
}).pipe(Effect.provide(Secp256k1Test))
```

## Full Sign-Recover-Verify Round Trip

Demonstrates a complete signing, recovery, and verification flow.

```typescript
import { Effect } from 'effect'
import * as Secp256k1 from 'voltaire-effect/crypto/Secp256k1'
import { Hash } from '@tevm/voltaire'

const program = Effect.gen(function* () {
  const privateKey = new Uint8Array(32).fill(0x42)
  const messageHash = Hash.from(new Uint8Array(32).fill(0xab))
  
  const signature = yield* Secp256k1.sign(messageHash, privateKey)
  const recovered = yield* Secp256k1.recover(signature, messageHash)
  const isValid = yield* Secp256k1.verify(signature, messageHash, recovered)
  // isValid is true
})
```
