---
title: Uint8 Tests
description: Test examples for Uint8 showing 8-bit unsigned integer parsing, arithmetic operations, and boundary validation.
---

## Parse from Number

Decodes valid numbers in the 0-255 range.

```typescript
import { describe, expect, it } from "@effect/vitest"
import * as S from "effect/Schema"
import * as Uint8 from "voltaire-effect/primitives/Uint8"

const value = S.decodeSync(Uint8.Number)(42)
expect(S.encodeSync(Uint8.Number)(value)).toBe(42)

const zero = S.decodeSync(Uint8.Number)(0)
expect(S.encodeSync(Uint8.Number)(zero)).toBe(0)

const max = S.decodeSync(Uint8.Number)(255)
expect(S.encodeSync(Uint8.Number)(max)).toBe(255)
```

## Reject Invalid Numbers

Rejects values outside the valid range or non-integers.

```typescript
import * as S from "effect/Schema"
import * as Uint8 from "voltaire-effect/primitives/Uint8"

expect(() => S.decodeSync(Uint8.Number)(256)).toThrow() // Overflow
expect(() => S.decodeSync(Uint8.Number)(-1)).toThrow()  // Negative
expect(() => S.decodeSync(Uint8.Number)(1.5)).toThrow() // Non-integer
```

## Parse from Hex

Decodes hex strings with or without 0x prefix.

```typescript
import * as S from "effect/Schema"
import * as Uint8 from "voltaire-effect/primitives/Uint8"

const value = S.decodeSync(Uint8.Hex)("0xff")
expect(S.encodeSync(Uint8.Number)(value)).toBe(255)

const noPrefix = S.decodeSync(Uint8.Hex)("ff")
expect(S.encodeSync(Uint8.Number)(noPrefix)).toBe(255)
```

## Arithmetic Operations

Performs safe arithmetic with overflow/underflow checking.

```typescript
import * as S from "effect/Schema"
import * as Uint8 from "voltaire-effect/primitives/Uint8"

const a = S.decodeSync(Uint8.Number)(100)
const b = S.decodeSync(Uint8.Number)(50)

// Addition
const sum = Uint8.plus(a, b)
expect(Uint8.toNumber(sum)).toBe(150)

// Subtraction
const diff = Uint8.minus(a, b)
expect(Uint8.toNumber(diff)).toBe(50)

// Multiplication
const five = S.decodeSync(Uint8.Number)(5)
const six = S.decodeSync(Uint8.Number)(6)
const product = Uint8.times(five, six)
expect(Uint8.toNumber(product)).toBe(30)
```

## Overflow/Underflow Protection

Throws on arithmetic overflow or underflow.

```typescript
import * as S from "effect/Schema"
import * as Uint8 from "voltaire-effect/primitives/Uint8"

const max = S.decodeSync(Uint8.Number)(255)
const one = S.decodeSync(Uint8.Number)(1)
expect(() => Uint8.plus(max, one)).toThrow() // 255 + 1 overflow

const zero = S.decodeSync(Uint8.Number)(0)
expect(() => Uint8.minus(zero, one)).toThrow() // 0 - 1 underflow

const large = S.decodeSync(Uint8.Number)(128)
const two = S.decodeSync(Uint8.Number)(2)
expect(() => Uint8.times(large, two)).toThrow() // 128 * 2 overflow
```

## Comparison and Constants

Compares values and provides common constants.

```typescript
import * as S from "effect/Schema"
import * as Uint8 from "voltaire-effect/primitives/Uint8"

const a = S.decodeSync(Uint8.Number)(42)
const b = S.decodeSync(Uint8.Number)(42)
const c = S.decodeSync(Uint8.Number)(43)

expect(Uint8.equals(a, b)).toBe(true)
expect(Uint8.equals(a, c)).toBe(false)

expect(Uint8.toNumber(Uint8.MAX)).toBe(255)
expect(Uint8.toNumber(Uint8.MIN)).toBe(0)
expect(Uint8.toNumber(Uint8.ZERO)).toBe(0)
expect(Uint8.toNumber(Uint8.ONE)).toBe(1)
```
