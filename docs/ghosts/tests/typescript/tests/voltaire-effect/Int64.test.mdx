---
title: Int64 Tests
description: Test examples for Int64 schema showing signed 64-bit integer operations, arithmetic, and validation.
---

## Schema: Decodes number values

Demonstrates decoding numbers into branded Int64.

```typescript
import { describe, expect, it } from "@effect/vitest"
import * as S from "effect/Schema"
import * as Int64 from "voltaire-effect/primitives/Int64"

it("decodes valid positive number", () => {
  const value = S.decodeSync(Int64.Number)(1000000000)
  expect(S.encodeSync(Int64.Number)(value)).toBe(1000000000)
})

it("decodes valid negative number", () => {
  const value = S.decodeSync(Int64.Number)(-1000000000)
  expect(S.encodeSync(Int64.Number)(value)).toBe(-1000000000)
})

it("truncates non-integer to integer", () => {
  const result = S.decodeSync(Int64.Number)(1.5)
  expect(S.encodeSync(Int64.Number)(result)).toBe(1)
})
```

## Schema: String parsing

Demonstrates decoding string representations including boundary values.

```typescript
import * as S from "effect/Schema"
import * as Int64 from "voltaire-effect/primitives/Int64"

it("decodes INT64_MIN string", () => {
  const value = S.decodeSync(Int64.String)("-9223372036854775808")
  expect(S.encodeSync(Int64.String)(value)).toBe("-9223372036854775808")
})

it("decodes INT64_MAX string", () => {
  const value = S.decodeSync(Int64.String)("9223372036854775807")
  expect(S.encodeSync(Int64.String)(value)).toBe("9223372036854775807")
})
```

## Schema: BigInt with overflow checks

Demonstrates BigInt decoding with boundary validation.

```typescript
import * as S from "effect/Schema"
import * as Int64 from "voltaire-effect/primitives/Int64"

const INT64_MIN = -9223372036854775808n
const INT64_MAX = 9223372036854775807n

it("decodes INT64_MIN bigint", () => {
  const value = S.decodeSync(Int64.BigInt)(INT64_MIN)
  expect(S.encodeSync(Int64.BigInt)(value)).toBe(INT64_MIN)
})

it("fails on overflow bigint", () => {
  expect(() => S.decodeSync(Int64.BigInt)(INT64_MAX + 1n)).toThrow()
})

it("fails on underflow bigint", () => {
  expect(() => S.decodeSync(Int64.BigInt)(INT64_MIN - 1n)).toThrow()
})
```

## Arithmetic: Addition with BrandedInt64

Demonstrates safe addition operations.

```typescript
import { BrandedInt64 } from "@tevm/voltaire"
import * as S from "effect/Schema"
import * as Int64 from "voltaire-effect/primitives/Int64"

const INT64_MAX = 9223372036854775807n
const INT64_MIN = -9223372036854775808n

it("adds two positive values", () => {
  const a = S.decodeSync(Int64.BigInt)(1000000000000n)
  const b = S.decodeSync(Int64.BigInt)(500000000000n)
  const result = BrandedInt64.plus(a, b)
  expect(S.encodeSync(Int64.BigInt)(result)).toBe(1500000000000n)
})

it("throws on overflow", () => {
  const max = S.decodeSync(Int64.BigInt)(INT64_MAX)
  const one = S.decodeSync(Int64.BigInt)(1n)
  expect(() => BrandedInt64.plus(max, one)).toThrow()
})

it("throws on underflow", () => {
  const min = S.decodeSync(Int64.BigInt)(INT64_MIN)
  const negOne = S.decodeSync(Int64.BigInt)(-1n)
  expect(() => BrandedInt64.plus(min, negOne)).toThrow()
})
```

## Arithmetic: Subtraction, multiplication, division

Demonstrates other arithmetic operations.

```typescript
import * as S from "effect/Schema"
import * as Int64 from "voltaire-effect/primitives/Int64"

it("subtracts two values", () => {
  const a = S.decodeSync(Int64.BigInt)(1000000000000n)
  const b = S.decodeSync(Int64.BigInt)(500000000000n)
  const result = Int64.sub(a, b)
  expect(S.encodeSync(Int64.BigInt)(result)).toBe(500000000000n)
})

it("multiplies two positive values", () => {
  const a = S.decodeSync(Int64.BigInt)(1000000n)
  const b = S.decodeSync(Int64.BigInt)(1000000n)
  const result = Int64.mul(a, b)
  expect(S.encodeSync(Int64.BigInt)(result)).toBe(1000000000000n)
})

it("truncates toward zero (negative)", () => {
  const a = S.decodeSync(Int64.BigInt)(-7n)
  const b = S.decodeSync(Int64.BigInt)(3n)
  const result = Int64.div(a, b)
  expect(S.encodeSync(Int64.BigInt)(result)).toBe(-2n)
})
```

## Sign handling: negate, abs, isNegative

Demonstrates sign manipulation operations.

```typescript
import * as S from "effect/Schema"
import * as Int64 from "voltaire-effect/primitives/Int64"

const INT64_MIN = -9223372036854775808n

it("negates positive value", () => {
  const a = S.decodeSync(Int64.BigInt)(1000000000000n)
  const result = Int64.negate(a)
  expect(S.encodeSync(Int64.BigInt)(result)).toBe(-1000000000000n)
})

it("abs of negative value", () => {
  const a = S.decodeSync(Int64.BigInt)(-1000000000000n)
  const result = Int64.abs(a)
  expect(S.encodeSync(Int64.BigInt)(result)).toBe(1000000000000n)
})

it("negate of INT64_MIN throws overflow", () => {
  const min = S.decodeSync(Int64.BigInt)(INT64_MIN)
  expect(() => Int64.negate(min)).toThrow()
})

it("returns true for negative", () => {
  const a = S.decodeSync(Int64.BigInt)(-1000000000000n)
  expect(Int64.isNegative(a)).toBe(true)
})
```

## Comparison and utility functions

Demonstrates comparison and utility operations.

```typescript
import * as S from "effect/Schema"
import * as Int64 from "voltaire-effect/primitives/Int64"

it("returns -1 when a < b", () => {
  const a = S.decodeSync(Int64.BigInt)(100n)
  const b = S.decodeSync(Int64.BigInt)(200n)
  expect(Int64.compare(a, b)).toBe(-1)
})

it("returns true for zero", () => {
  const zero = S.decodeSync(Int64.BigInt)(0n)
  expect(Int64.isZero(zero)).toBe(true)
})
```

## Constants

Demonstrates accessing Int64 constant values.

```typescript
import * as Int64 from "voltaire-effect/primitives/Int64"

it("INT64_MIN equals -9223372036854775808n", () => {
  expect(Int64.INT64_MIN).toBe(-9223372036854775808n)
})

it("INT64_MAX equals 9223372036854775807n", () => {
  expect(Int64.INT64_MAX).toBe(9223372036854775807n)
})
```
