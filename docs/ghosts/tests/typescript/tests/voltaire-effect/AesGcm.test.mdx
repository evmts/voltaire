---
title: AesGcm Tests
description: Test examples for AES-GCM encryption with key generation and input validation.
---

## generateKey generates 256-bit key by default

Shows generating a cryptographically secure AES key.

```typescript
import { describe, expect, it } from "@effect/vitest";
import * as Effect from "effect/Effect";
import * as AesGcm from "voltaire-effect/crypto/AesGcm";

it.effect("generates 256-bit key by default", () =>
  Effect.gen(function* () {
    const result = yield* AesGcm.generateKey();
    expect(result.length).toBe(32);
  }),
);

it.effect("generates 128-bit key", () =>
  Effect.gen(function* () {
    const result = yield* AesGcm.generateKey(128);
    expect(result.length).toBe(16);
  }),
);
```

## generateNonce generates 12-byte nonce

Demonstrates generating a unique nonce for each encryption.

```typescript
import * as Effect from "effect/Effect";
import * as AesGcm from "voltaire-effect/crypto/AesGcm";

it.effect("generates 12-byte nonce", () =>
  Effect.gen(function* () {
    const result = yield* AesGcm.generateNonce();
    expect(result.length).toBe(12);
  }),
);
```

## encrypt/decrypt roundtrip

Shows complete encryption and decryption cycle.

```typescript
import * as Effect from "effect/Effect";
import * as AesGcm from "voltaire-effect/crypto/AesGcm";

it.effect("encrypts and decrypts correctly", () =>
  Effect.gen(function* () {
    const key = yield* AesGcm.generateKey();
    const nonce = yield* AesGcm.generateNonce();
    const plaintext = new Uint8Array([1, 2, 3, 4, 5]);
    const ciphertext = yield* AesGcm.encrypt(key, plaintext, nonce);
    const decrypted = yield* AesGcm.decrypt(key, ciphertext, nonce);
    expect(Array.from(decrypted)).toEqual(Array.from(plaintext));
  }),
);
```

## encrypt with AAD (additional authenticated data)

Demonstrates encryption with associated data for integrity verification.

```typescript
import * as Effect from "effect/Effect";
import * as AesGcm from "voltaire-effect/crypto/AesGcm";

it.effect("encrypts with AAD", () =>
  Effect.gen(function* () {
    const key = yield* AesGcm.generateKey();
    const nonce = yield* AesGcm.generateNonce();
    const plaintext = new Uint8Array([1, 2, 3]);
    const aad = new Uint8Array([10, 20, 30]);
    const ciphertext = yield* AesGcm.encrypt(key, plaintext, nonce, aad);
    const decrypted = yield* AesGcm.decrypt(key, ciphertext, nonce, aad);
    expect(Array.from(decrypted)).toEqual(Array.from(plaintext));
  }),
);
```

## Service layer with live layer

Shows using the service through the AesGcmLive layer.

```typescript
import * as Effect from "effect/Effect";
import * as AesGcm from "voltaire-effect/crypto/AesGcm";

it.effect("works with live layer", () =>
  Effect.gen(function* () {
    const service = yield* AesGcm.AesGcmService;
    const key = yield* service.generateKey();
    expect(key.length).toBe(32);
  }).pipe(Effect.provide(AesGcm.AesGcmLive)),
);
```

## Rejects invalid key size on encrypt

Demonstrates validation rejecting non-standard key sizes.

```typescript
import * as Effect from "effect/Effect";
import * as Exit from "effect/Exit";
import * as AesGcm from "voltaire-effect/crypto/AesGcm";

it.effect("rejects invalid key size on encrypt", () =>
  Effect.gen(function* () {
    const nonce = yield* AesGcm.generateNonce();
    const plaintext = new Uint8Array([1, 2, 3]);
    const invalidKey = new Uint8Array(10);
    const exit = yield* Effect.exit(AesGcm.encrypt(invalidKey, plaintext, nonce));
    expect(Exit.isFailure(exit)).toBe(true);
    if (Exit.isFailure(exit) && exit.cause._tag === "Fail") {
      expect(exit.cause.error).toBeInstanceOf(AesGcm.InvalidKeyError);
      expect((exit.cause.error as AesGcm.InvalidKeyError).keyLength).toBe(10);
    }
  }),
);
```

## Rejects invalid nonce size

Shows nonce validation requiring exactly 12 bytes.

```typescript
import * as Effect from "effect/Effect";
import * as Exit from "effect/Exit";
import * as AesGcm from "voltaire-effect/crypto/AesGcm";

it.effect("rejects invalid nonce size on encrypt", () =>
  Effect.gen(function* () {
    const key = yield* AesGcm.generateKey();
    const plaintext = new Uint8Array([1, 2, 3]);
    const invalidNonce = new Uint8Array(8);
    const exit = yield* Effect.exit(AesGcm.encrypt(key, plaintext, invalidNonce));
    expect(Exit.isFailure(exit)).toBe(true);
    if (Exit.isFailure(exit) && exit.cause._tag === "Fail") {
      expect(exit.cause.error).toBeInstanceOf(AesGcm.InvalidNonceError);
    }
  }),
);
```

## Accepts valid key sizes (16, 32 bytes)

Demonstrates both AES-128 and AES-256 key sizes work.

```typescript
import * as Effect from "effect/Effect";
import * as AesGcm from "voltaire-effect/crypto/AesGcm";

it.effect("accepts valid key sizes", () =>
  Effect.gen(function* () {
    const nonce = yield* AesGcm.generateNonce();
    const plaintext = new Uint8Array([1, 2, 3]);

    // AES-128 (16 bytes)
    const key16 = new Uint8Array(16).fill(1);
    const result16 = yield* AesGcm.encrypt(key16, plaintext, nonce);
    expect(result16.length).toBeGreaterThan(plaintext.length);

    // AES-256 (32 bytes)
    const nonce2 = yield* AesGcm.generateNonce();
    const key32 = new Uint8Array(32).fill(1);
    const result32 = yield* AesGcm.encrypt(key32, plaintext, nonce2);
    expect(result32.length).toBeGreaterThan(plaintext.length);
  }),
);
```

## Rejects AES-192 (24-byte key)

Shows that AES-192 is not supported.

```typescript
import * as Effect from "effect/Effect";
import * as Exit from "effect/Exit";
import * as AesGcm from "voltaire-effect/crypto/AesGcm";

it.effect("rejects AES-192 (24-byte key)", () =>
  Effect.gen(function* () {
    const nonce = yield* AesGcm.generateNonce();
    const plaintext = new Uint8Array([1, 2, 3]);
    const key24 = new Uint8Array(24).fill(1);
    const exit = yield* Effect.exit(AesGcm.encrypt(key24, plaintext, nonce));
    expect(Exit.isFailure(exit)).toBe(true);
    if (Exit.isFailure(exit) && exit.cause._tag === "Fail") {
      expect(exit.cause.error).toBeInstanceOf(AesGcm.InvalidKeyError);
    }
  }),
);
```
