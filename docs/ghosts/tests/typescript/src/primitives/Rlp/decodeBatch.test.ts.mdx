---
title: '[TS/JS] src/primitives/Rlp/decodeBatch.test.ts'
source: 'src/primitives/Rlp/decodeBatch.test.ts'
---

> Auto-generated from test file: src/primitives/Rlp/decodeBatch.test.ts

```typescript
/**
 * Tests for Rlp.decodeBatch
 */

import { describe, expect, it } from "vitest";
import { decodeBatch } from "./decodeBatch.js";
import { encode } from "./encode.js";
import { encodeBatch } from "./encodeBatch.js";

describe("Rlp.decodeBatch", () => {
	it("decodes empty batch", () => {
		const result = decodeBatch([]);
		expect(Array.isArray(result)).toBe(true);
		expect(result).toHaveLength(0);
	});

	it("decodes single item batch", () => {
		const item = encode([new Uint8Array([1, 2, 3])]);
		const result = decodeBatch([item]);
		expect(result).toHaveLength(1);
		expect(result[0]).toEqual([new Uint8Array([1, 2, 3])]);
	});

	it("decodes multiple items in stream", () => {
		const items = [
			encode([new Uint8Array([1, 2])]),
			encode([new Uint8Array([3, 4])]),
			encode([new Uint8Array([5, 6])]),
		];
		const result = decodeBatch(items);
		expect(result).toHaveLength(3);
		expect(result[0]).toEqual([new Uint8Array([1, 2])]);
		expect(result[1]).toEqual([new Uint8Array([3, 4])]);
		expect(result[2]).toEqual([new Uint8Array([5, 6])]);
	});

	it("decodes mixed types", () => {
		const items = [
			encode([new Uint8Array([1])]),
			encode([[new Uint8Array([2])]]),
			encode([new Uint8Array([])]),
		];
		const result = decodeBatch(items);
		expect(result).toHaveLength(3);
		expect(result[0]).toEqual([new Uint8Array([1])]);
		expect(Array.isArray(result[1]?.[0])).toBe(true);
		expect(result[2]).toEqual([new Uint8Array([])]);
	});

	it("decodes nested structures", () => {
		const items = [
			encode([[new Uint8Array([1]), new Uint8Array([2])]]),
			encode([new Uint8Array([3])]),
		];
		const result = decodeBatch(items);
		expect(result).toHaveLength(2);
		expect(Array.isArray(result[0]?.[0])).toBe(true);
		expect(result[0]?.[0] as any).toHaveLength(2);
	});

	it("decodes large batch (100+ items)", () => {
		const items = Array.from({ length: 100 }, (_, i) =>
			encode([new Uint8Array([i % 256])]),
		);
		const result = decodeBatch(items);
		expect(result).toHaveLength(100);
		for (let i = 0; i < 100; i++) {
			expect(result[i]).toEqual([new Uint8Array([i % 256])]);
		}
	});

	it("round-trips with encodeBatch", () => {
		const original = [
			[new Uint8Array([1, 2])],
			[new Uint8Array([3, 4, 5])],
			[new Uint8Array([6])],
		];
		const encoded = encodeBatch(original);
		const decoded = decodeBatch(encoded);
		expect(decoded).toEqual(original);
	});

	it("handles single non-list item (wraps in array)", () => {
		// When decoding a non-list item, it wraps it in an array
		const item = encode(new Uint8Array([1, 2, 3]));
		const result = decodeBatch([item]);
		expect(result).toHaveLength(1);
		expect(result[0]).toEqual([new Uint8Array([1, 2, 3])]);
	});
});

```
