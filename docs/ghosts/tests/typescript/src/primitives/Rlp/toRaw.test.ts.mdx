---
title: '[TS/JS] src/primitives/Rlp/toRaw.test.ts'
source: 'src/primitives/Rlp/toRaw.test.ts'
---

> Auto-generated from test file: src/primitives/Rlp/toRaw.test.ts

```typescript
/**
 * Tests for Rlp.toRaw
 */

import { describe, expect, it } from "vitest";
import type { BrandedRlp } from "./RlpType.js";
import { toRaw } from "./toRaw.js";

describe("Rlp.toRaw", () => {
	it("converts bytes Data to Uint8Array", () => {
		const data: BrandedRlp = {
			type: "bytes",
			value: new Uint8Array([1, 2, 3]),
		};
		const result = toRaw(data);
		expect(result).toEqual(new Uint8Array([1, 2, 3]));
		expect(result).toBeInstanceOf(Uint8Array);
	});

	it("converts empty bytes Data", () => {
		const data: BrandedRlp = {
			type: "bytes",
			value: new Uint8Array([]),
		};
		const result = toRaw(data);
		expect(result).toEqual(new Uint8Array([]));
		expect(result).toBeInstanceOf(Uint8Array);
	});

	it("converts empty list Data to empty array", () => {
		const data: BrandedRlp = {
			type: "list",
			value: [],
		};
		const result = toRaw(data);
		expect(Array.isArray(result)).toBe(true);
		expect(result).toHaveLength(0);
	});

	it("converts list Data to array of Uint8Arrays", () => {
		const data: BrandedRlp = {
			type: "list",
			value: [
				{ type: "bytes", value: new Uint8Array([1]) },
				{ type: "bytes", value: new Uint8Array([2]) },
			],
		};
		const result = toRaw(data);
		expect(Array.isArray(result)).toBe(true);
		expect(result).toHaveLength(2);
		expect(result[0]).toEqual(new Uint8Array([1]));
		expect(result[1]).toEqual(new Uint8Array([2]));
	});

	it("converts nested list Data", () => {
		const data: BrandedRlp = {
			type: "list",
			value: [
				{ type: "bytes", value: new Uint8Array([1]) },
				{
					type: "list",
					value: [
						{ type: "bytes", value: new Uint8Array([2]) },
						{ type: "bytes", value: new Uint8Array([3]) },
					],
				},
			],
		};
		const result = toRaw(data);
		expect(Array.isArray(result)).toBe(true);
		expect(result).toHaveLength(2);
		expect(result[0]).toEqual(new Uint8Array([1]));
		expect(Array.isArray(result[1])).toBe(true);
		// biome-ignore lint/suspicious/noExplicitAny: accessing nested array
		expect(result[1] as any).toHaveLength(2);
		// biome-ignore lint/suspicious/noExplicitAny: accessing nested array
		expect((result[1] as any)[0]).toEqual(new Uint8Array([2]));
		// biome-ignore lint/suspicious/noExplicitAny: accessing nested array
		expect((result[1] as any)[1]).toEqual(new Uint8Array([3]));
	});

	it("converts deeply nested list Data", () => {
		const data: BrandedRlp = {
			type: "list",
			value: [
				{
					type: "list",
					value: [
						{
							type: "list",
							value: [{ type: "bytes", value: new Uint8Array([1]) }],
						},
					],
				},
			],
		};
		const result = toRaw(data);
		expect(Array.isArray(result)).toBe(true);
		expect(Array.isArray(result[0])).toBe(true);
		// biome-ignore lint/suspicious/noExplicitAny: accessing deeply nested array
		expect(Array.isArray((result[0] as any)[0])).toBe(true);
		// biome-ignore lint/suspicious/noExplicitAny: accessing deeply nested array
		expect((result[0] as any)[0][0]).toEqual(new Uint8Array([1]));
	});

	it("converts mixed list with bytes and nested lists", () => {
		const data: BrandedRlp = {
			type: "list",
			value: [
				{ type: "bytes", value: new Uint8Array([1]) },
				{
					type: "list",
					value: [{ type: "bytes", value: new Uint8Array([2]) }],
				},
				{ type: "bytes", value: new Uint8Array([3]) },
			],
		};
		const result = toRaw(data);
		expect(result).toHaveLength(3);
		expect(result[0]).toEqual(new Uint8Array([1]));
		expect(Array.isArray(result[1])).toBe(true);
		expect(result[2]).toEqual(new Uint8Array([3]));
	});

	it("converts large bytes Data", () => {
		const largeBytes = new Uint8Array(1000).fill(0xff);
		const data: BrandedRlp = {
			type: "bytes",
			value: largeBytes,
		};
		const result = toRaw(data);
		expect(result).toEqual(largeBytes);
		expect(result.length).toBe(1000);
	});

	it("converts list with many items", () => {
		const items: BrandedRlp[] = Array.from({ length: 100 }, (_, i) => ({
			type: "bytes" as const,
			value: new Uint8Array([i % 256]),
		}));
		const data: BrandedRlp = {
			type: "list",
			value: items,
		};
		const result = toRaw(data);
		expect(Array.isArray(result)).toBe(true);
		expect(result).toHaveLength(100);
		for (let i = 0; i < 100; i++) {
			expect(result[i]).toEqual(new Uint8Array([i % 256]));
		}
	});

	it("preserves reference to original Uint8Array", () => {
		const original = new Uint8Array([1, 2, 3]);
		const data: BrandedRlp = {
			type: "bytes",
			value: original,
		};
		const result = toRaw(data);
		expect(result).toBe(original); // Same reference
	});
});

```
