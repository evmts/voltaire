---
title: '[TS/JS] src/primitives/Blob/Blob.test.ts'
source: 'src/primitives/Blob/Blob.test.ts'
---

> Auto-generated from test file: src/primitives/Blob/Blob.test.ts

```typescript
import { describe, expect, it } from "vitest";
import type {
	BrandedBlob,
	Commitment,
	Proof,
	VersionedHash,
} from "./BlobType.js";
import {
	BYTES_PER_FIELD_ELEMENT,
	COMMITMENT_VERSION_KZG,
	FIELD_ELEMENTS_PER_BLOB,
	GAS_PER_BLOB,
	MAX_PER_TRANSACTION,
	SIZE,
	TARGET_GAS_PER_BLOCK,
} from "./constants.js";
import { Blob } from "./index.js";

// ============================================================================
// Blob Class API Tests
// Testing the Blob() constructor pattern and instance methods
// ============================================================================

describe("Blob() Constructor", () => {
	it("creates blob from size (number)", () => {
		const blob = Blob(SIZE);
		expect(blob.length).toBe(SIZE);
		expect(blob instanceof Uint8Array).toBe(true);
	});

	it("creates blob from Uint8Array (raw blob)", () => {
		const raw = new Uint8Array(SIZE);
		const blob = Blob(raw);
		expect(blob.length).toBe(SIZE);
		expect(Blob.isValid(blob)).toBe(true);
	});

	it("creates blob from small data (auto-encodes)", () => {
		const data = new TextEncoder().encode("Hello");
		const blob = Blob(data);
		expect(blob.length).toBe(SIZE);
		expect(Blob.isValid(blob)).toBe(true);
	});

	it("preserves Uint8Array prototype chain", () => {
		const blob = Blob(SIZE);
		expect(blob instanceof Uint8Array).toBe(true);
		expect(Object.getPrototypeOf(blob)).toBe(Blob.prototype);
	});
});

describe("Blob.from() - Static Factory", () => {
	it("creates blob from raw blob data", () => {
		const raw = new Uint8Array(SIZE);
		const blob = Blob.from(raw);
		expect(blob.length).toBe(SIZE);
		expect(Blob.isValid(blob)).toBe(true);
	});

	it("encodes small data automatically", () => {
		const data = new TextEncoder().encode("Test");
		const blob = Blob.from(data);
		expect(blob.length).toBe(SIZE);
	});

	it("returns same instance if already valid blob", () => {
		const raw = new Uint8Array(SIZE) as BrandedBlob;
		const blob = Blob.from(raw);
		expect(blob).toBe(raw);
	});
});

describe("Blob.fromData() - Static Factory", () => {
	it("creates blob from arbitrary data", () => {
		const data = new TextEncoder().encode("Hello, blob!");
		const blob = Blob.fromData(data);
		expect(blob.length).toBe(SIZE);
		expect(Blob.isValid(blob)).toBe(true);
	});

	it("encodes empty data", () => {
		const blob = Blob.fromData(new Uint8Array(0));
		expect(blob.length).toBe(SIZE);
		expect(Blob.isValid(blob)).toBe(true);
	});

	it("encodes max size data", () => {
		// Max is 4096 field elements * 31 bytes per element = 126976
		const maxSize = FIELD_ELEMENTS_PER_BLOB * (BYTES_PER_FIELD_ELEMENT - 1) - 4;
		const data = new Uint8Array(maxSize);
		const blob = Blob.fromData(data);
		expect(blob.length).toBe(SIZE);
	});

	it("throws on oversized data", () => {
		const oversized = new Uint8Array(SIZE);
		expect(() => Blob.fromData(oversized)).toThrow("Data too large");
	});

	it("throws InvalidBlobDataSizeError with correct name", () => {
		const oversized = new Uint8Array(SIZE);
		try {
			Blob.fromData(oversized);
			expect.fail("Should have thrown");
		} catch (e) {
			expect((e as Error).name).toBe("InvalidBlobDataSizeError");
		}
	});
});

// ============================================================================
// Instance Methods
// ============================================================================

describe("blob.toData() - Instance Method", () => {
	it("extracts data from blob", () => {
		const original = new TextEncoder().encode("Hello");
		const blob = Blob.fromData(original);
		const extracted = blob.toData();
		expect(extracted).toEqual(original);
	});

	it("handles empty data", () => {
		const blob = Blob.fromData(new Uint8Array(0));
		const extracted = blob.toData();
		expect(extracted.length).toBe(0);
	});

	it("roundtrip preserves data", () => {
		const original = new Uint8Array([1, 2, 3, 4, 5]);
		const blob = Blob.fromData(original);
		const extracted = blob.toData();
		expect(extracted).toEqual(original);
	});

	it("handles unicode text", () => {
		const text = "Hello ä¸–ç•Œ ðŸŒ";
		const original = new TextEncoder().encode(text);
		const blob = Blob.fromData(original);
		const extracted = blob.toData();
		const result = new TextDecoder().decode(extracted);
		expect(result).toBe(text);
	});
});

describe("blob.toCommitment() - Instance Method", () => {
	it("throws KZG error when trusted setup not loaded", () => {
		const blob = Blob.fromData(new Uint8Array([1, 2, 3]));
		expect(() => blob.toCommitment()).toThrow(/KZG/i);
	});

	it("validates blob size", () => {
		const invalid = new Uint8Array(100);
		Object.setPrototypeOf(invalid, Blob.prototype);
		// biome-ignore lint/suspicious/noExplicitAny: type coercion required
		expect(() => (invalid as any).toCommitment()).toThrow("Invalid blob size");
	});
});

describe("blob.toProof() - Instance Method", () => {
	it("throws KZG error when trusted setup not loaded", () => {
		const blob = Blob.fromData(new Uint8Array([1, 2, 3]));
		const commitment = new Uint8Array(48) as Commitment;
		// biome-ignore lint/suspicious/noExplicitAny: type coercion required
		expect(() => (blob as any).toProof(commitment)).toThrow(/KZG/i);
	});

	it("validates blob size", () => {
		const invalid = new Uint8Array(100);
		const commitment = new Uint8Array(48) as Commitment;
		Object.setPrototypeOf(invalid, Blob.prototype);
		// biome-ignore lint/suspicious/noExplicitAny: type coercion required
		expect(() => (invalid as any).toProof(commitment)).toThrow(
			"Invalid blob size",
		);
	});
});

describe("blob.verify() - Instance Method", () => {
	it("throws KZG error when trusted setup not loaded", () => {
		const blob = Blob.fromData(new Uint8Array([1, 2, 3]));
		const commitment = new Uint8Array(48) as Commitment;
		const proof = new Uint8Array(48) as Proof;
		// biome-ignore lint/suspicious/noExplicitAny: type coercion required
		expect(() => (blob as any).verify(commitment, proof)).toThrow(/KZG/i);
	});

	it("validates blob size", () => {
		const invalid = new Uint8Array(100);
		const commitment = new Uint8Array(48) as Commitment;
		const proof = new Uint8Array(48) as Proof;
		Object.setPrototypeOf(invalid, Blob.prototype);
		// biome-ignore lint/suspicious/noExplicitAny: test requires type flexibility
		expect(() => (invalid as any).verify(commitment, proof)).toThrow(
			"Invalid blob size",
		);
	});
});

// ============================================================================
// Static Validation Methods
// ============================================================================

describe("Blob.isValid() - Static Method", () => {
	it("validates correct blob size", () => {
		const blob = new Uint8Array(SIZE);
		expect(Blob.isValid(blob)).toBe(true);
	});

	it("rejects undersized blobs", () => {
		const blob = new Uint8Array(100);
		expect(Blob.isValid(blob)).toBe(false);
	});

	it("rejects oversized blobs", () => {
		const blob = new Uint8Array(SIZE + 1);
		expect(Blob.isValid(blob)).toBe(false);
	});
});

describe("Blob.isValidVersion() - Static Method", () => {
	it("validates correct version", () => {
		const hash = new Uint8Array(32) as VersionedHash;
		hash[0] = COMMITMENT_VERSION_KZG;
		expect(Blob.isValidVersion(hash)).toBe(true);
	});

	it("rejects incorrect version", () => {
		const hash = new Uint8Array(32) as VersionedHash;
		hash[0] = 0x00;
		expect(Blob.isValidVersion(hash)).toBe(false);
	});

	it("rejects incorrect size", () => {
		const hash = new Uint8Array(64) as VersionedHash;
		hash[0] = COMMITMENT_VERSION_KZG;
		expect(Blob.isValidVersion(hash)).toBe(false);
	});
});

// ============================================================================
// Static Utility Methods - Data Splitting
// ============================================================================

describe("Blob.splitData() - Static Method", () => {
	it("splits large data into multiple blobs", () => {
		const data = new Uint8Array(200000).fill(0xab);
		const blobs = Blob.splitData(data);
		expect(blobs.length).toBeGreaterThan(1);
		expect(blobs.every((b) => Blob.isValid(b))).toBe(true);
	});

	it("creates single blob for small data", () => {
		const data = new Uint8Array(1000).fill(0xcd);
		const blobs = Blob.splitData(data);
		expect(blobs.length).toBe(1);
		// biome-ignore lint/style/noNonNullAssertion: test array access is safe
		expect(Blob.isValid(blobs[0]!)).toBe(true);
	});

	it("handles empty data", () => {
		const data = new Uint8Array(0);
		const blobs = Blob.splitData(data);
		expect(blobs.length).toBe(0);
	});

	it("splits at correct boundaries", () => {
		const maxDataPerBlob =
			FIELD_ELEMENTS_PER_BLOB * (BYTES_PER_FIELD_ELEMENT - 1) - 4;
		const data = new Uint8Array(maxDataPerBlob * 2 + 100);
		const blobs = Blob.splitData(data);
		expect(blobs.length).toBe(3);
	});

	it("throws when exceeding max blobs per transaction", () => {
		const maxDataPerBlob =
			FIELD_ELEMENTS_PER_BLOB * (BYTES_PER_FIELD_ELEMENT - 1) - 4;
		const tooMuch = new Uint8Array(maxDataPerBlob * (MAX_PER_TRANSACTION + 1));
		expect(() => Blob.splitData(tooMuch)).toThrow("Data too large");
	});

	it("handles exactly max transaction capacity", () => {
		const maxDataPerBlob =
			FIELD_ELEMENTS_PER_BLOB * (BYTES_PER_FIELD_ELEMENT - 1) - 4;
		const data = new Uint8Array(maxDataPerBlob * MAX_PER_TRANSACTION);
		const blobs = Blob.splitData(data);
		expect(blobs.length).toBe(MAX_PER_TRANSACTION);
	});
});

describe("Blob.joinData() - Static Method", () => {
	it("joins multiple blobs", () => {
		const original = new Uint8Array(200000).fill(0xef);
		const blobs = Blob.splitData(original);
		const joined = Blob.joinData(blobs);
		expect(joined).toEqual(original);
	});

	it("handles single blob", () => {
		const original = new Uint8Array(1000).fill(0x12);
		const blob = Blob.fromData(original);
		const joined = Blob.joinData([blob]);
		expect(joined).toEqual(original);
	});

	it("handles empty array", () => {
		const joined = Blob.joinData([]);
		expect(joined.length).toBe(0);
	});

	it("roundtrip with pattern data", () => {
		const pattern = new Uint8Array([1, 2, 3, 4, 5]);
		const data = new Uint8Array(150000);
		for (let i = 0; i < data.length; i++) {
			// biome-ignore lint/style/noNonNullAssertion: test array access is safe
			data[i] = pattern[i % pattern.length]!;
		}
		const blobs = Blob.splitData(data);
		const joined = Blob.joinData(blobs);
		expect(joined).toEqual(data);
	});

	it("roundtrip with max transaction capacity", () => {
		const maxPerTransaction =
			MAX_PER_TRANSACTION *
				FIELD_ELEMENTS_PER_BLOB *
				(BYTES_PER_FIELD_ELEMENT - 1) -
			4;
		const data = new Uint8Array(maxPerTransaction - 100);
		for (let i = 0; i < data.length; i++) {
			data[i] = (i * 7) % 256;
		}
		const blobs = Blob.splitData(data);
		const joined = Blob.joinData(blobs);
		expect(joined).toEqual(data);
	});
});

// ============================================================================
// Static Utility Methods - Estimation & Gas
// ============================================================================

describe("Blob.estimateBlobCount() - Static Method", () => {
	it("estimates single blob for small data", () => {
		expect(Blob.estimateBlobCount(100)).toBe(1);
		expect(Blob.estimateBlobCount(1000)).toBe(1);
	});

	it("estimates multiple blobs for large data", () => {
		const maxDataPerBlob =
			FIELD_ELEMENTS_PER_BLOB * (BYTES_PER_FIELD_ELEMENT - 1) - 4;
		expect(Blob.estimateBlobCount(maxDataPerBlob + 1)).toBe(2);
		expect(Blob.estimateBlobCount(maxDataPerBlob * 2)).toBe(2);
		expect(Blob.estimateBlobCount(maxDataPerBlob * 2 + 1)).toBe(3);
	});

	it("returns zero for zero data", () => {
		expect(Blob.estimateBlobCount(0)).toBe(0);
	});

	it("throws on negative size", () => {
		expect(() => Blob.estimateBlobCount(-1)).toThrow("Invalid data size");
	});

	it("throws InvalidBlobDataSizeError with correct name", () => {
		try {
			Blob.estimateBlobCount(-1);
			expect.fail("Should have thrown");
		} catch (e) {
			expect((e as Error).name).toBe("InvalidBlobDataSizeError");
		}
	});

	it("estimates correctly at exact boundaries", () => {
		const maxDataPerBlob =
			FIELD_ELEMENTS_PER_BLOB * (BYTES_PER_FIELD_ELEMENT - 1) - 4;
		expect(Blob.estimateBlobCount(maxDataPerBlob)).toBe(1);
		expect(Blob.estimateBlobCount(maxDataPerBlob * MAX_PER_TRANSACTION)).toBe(
			MAX_PER_TRANSACTION,
		);
	});
});

describe("Blob.calculateGas() - Static Method", () => {
	it("calculates gas for single blob", () => {
		expect(Blob.calculateGas(1)).toBe(GAS_PER_BLOB);
	});

	it("calculates gas for multiple blobs", () => {
		expect(Blob.calculateGas(3)).toBe(TARGET_GAS_PER_BLOCK);
		expect(Blob.calculateGas(6)).toBe(GAS_PER_BLOB * 6);
	});

	it("returns zero for zero blobs", () => {
		expect(Blob.calculateGas(0)).toBe(0);
	});

	it("throws on negative count", () => {
		expect(() => Blob.calculateGas(-1)).toThrow("Invalid blob count");
	});

	it("throws on exceeding max per transaction", () => {
		expect(() => Blob.calculateGas(MAX_PER_TRANSACTION + 1)).toThrow(
			"Invalid blob count",
		);
	});

	it("throws InvalidBlobCountError with correct name", () => {
		try {
			Blob.calculateGas(-1);
			expect.fail("Should have thrown");
		} catch (e) {
			expect((e as Error).name).toBe("InvalidBlobCountError");
		}
	});
});

// ============================================================================
// Static Utility Methods - KZG Operations
// ============================================================================

describe("Blob.toCommitment() - Static Method", () => {
	it("throws KZG error when trusted setup not loaded or native unavailable", () => {
		const blob = Blob.fromData(new Uint8Array([1, 2, 3]));
		// Either "KZG trusted setup not initialized" (WASM) or "requires native bindings" (no native)
		expect(() => Blob.toCommitment(blob)).toThrow(/KZG/i);
	});

	it("validates blob size", () => {
		const invalid = new Uint8Array(100) as BrandedBlob;
		expect(() => Blob.toCommitment(invalid)).toThrow("Invalid blob size");
	});
});

describe("Blob.toProof() - Static Method", () => {
	it("throws KZG error when trusted setup not loaded", () => {
		const blob = Blob.fromData(new Uint8Array([1, 2, 3]));
		const commitment = new Uint8Array(48) as Commitment;
		expect(() => Blob.toProof(blob, commitment)).toThrow(/KZG/i);
	});

	it("validates blob size", () => {
		const invalid = new Uint8Array(100) as BrandedBlob;
		const commitment = new Uint8Array(48) as Commitment;
		expect(() => Blob.toProof(invalid, commitment)).toThrow(
			"Invalid blob size",
		);
	});

	it("validates commitment size", () => {
		const blob = Blob.fromData(new Uint8Array([1, 2, 3]));
		const invalid = new Uint8Array(32) as Commitment;
		expect(() => Blob.toProof(blob, invalid)).toThrow(
			"Invalid commitment size",
		);
	});
});

describe("Blob.toVersionedHash() - Static Method", () => {
	it("creates versioned hash from commitment", () => {
		const commitment = new Uint8Array(48).fill(0xab) as Commitment;
		const hash = Blob.toVersionedHash(commitment);
		expect(hash.length).toBe(32);
		expect(hash[0]).toBe(COMMITMENT_VERSION_KZG);
	});

	it("validates commitment size", () => {
		const invalid = new Uint8Array(32) as Commitment;
		expect(() => Blob.toVersionedHash(invalid)).toThrow(
			"Invalid commitment size",
		);
	});

	it("throws InvalidCommitmentSizeError with correct name", () => {
		const invalid = new Uint8Array(32) as Commitment;
		try {
			Blob.toVersionedHash(invalid);
			expect.fail("Should have thrown");
		} catch (e) {
			expect((e as Error).name).toBe("InvalidCommitmentSizeError");
		}
	});

	it("produces deterministic hash", () => {
		const commitment = new Uint8Array(48).fill(0xab) as Commitment;
		const hash1 = Blob.toVersionedHash(commitment);
		const hash2 = Blob.toVersionedHash(commitment);
		expect(hash1).toEqual(hash2);
	});

	it("produces different hash for different commitments", () => {
		const commitment1 = new Uint8Array(48).fill(0xab) as Commitment;
		const commitment2 = new Uint8Array(48).fill(0xcd) as Commitment;
		const hash1 = Blob.toVersionedHash(commitment1);
		const hash2 = Blob.toVersionedHash(commitment2);
		expect(hash1).not.toEqual(hash2);
	});
});

describe("Blob.verify() - Static Method", () => {
	it("throws KZG error when trusted setup not loaded", () => {
		const blob = Blob.fromData(new Uint8Array([1, 2, 3]));
		const commitment = new Uint8Array(48) as Commitment;
		const proof = new Uint8Array(48) as Proof;
		expect(() => Blob.verify(blob, commitment, proof)).toThrow(/KZG/i);
	});

	it("validates blob size", () => {
		const invalid = new Uint8Array(100) as BrandedBlob;
		const commitment = new Uint8Array(48) as Commitment;
		const proof = new Uint8Array(48) as Proof;
		expect(() => Blob.verify(invalid, commitment, proof)).toThrow(
			"Invalid blob size",
		);
	});

	it("validates commitment size", () => {
		const blob = Blob.fromData(new Uint8Array([1, 2, 3]));
		const invalid = new Uint8Array(32) as Commitment;
		const proof = new Uint8Array(48) as Proof;
		expect(() => Blob.verify(blob, invalid, proof)).toThrow(
			"Invalid commitment size",
		);
	});

	it("validates proof size", () => {
		const blob = Blob.fromData(new Uint8Array([1, 2, 3]));
		const commitment = new Uint8Array(48) as Commitment;
		const invalid = new Uint8Array(32) as Proof;
		expect(() => Blob.verify(blob, commitment, invalid)).toThrow(
			"Invalid proof size",
		);
	});
});

describe("Blob.verifyBatch() - Static Method", () => {
	it("throws not implemented", () => {
		const blob = Blob.fromData(new Uint8Array([1, 2, 3]));
		const commitment = new Uint8Array(48) as Commitment;
		const proof = new Uint8Array(48) as Proof;
		expect(() => Blob.verifyBatch([blob], [commitment], [proof])).toThrow(
			"Not implemented",
		);
	});

	it("throws BlobNotImplementedError with correct name", () => {
		const blob = Blob.fromData(new Uint8Array([1, 2, 3]));
		const commitment = new Uint8Array(48) as Commitment;
		const proof = new Uint8Array(48) as Proof;
		try {
			Blob.verifyBatch([blob], [commitment], [proof]);
			expect.fail("Should have thrown");
		} catch (e) {
			expect((e as Error).name).toBe("BlobNotImplementedError");
		}
	});

	it("validates array lengths match", () => {
		const blob = Blob.fromData(new Uint8Array([1, 2, 3]));
		const commitment = new Uint8Array(48) as Commitment;
		const proof = new Uint8Array(48) as Proof;
		expect(() => Blob.verifyBatch([blob, blob], [commitment], [proof])).toThrow(
			"Arrays must have same length",
		);
	});

	it("throws BlobArrayLengthMismatchError with correct name", () => {
		const blob = Blob.fromData(new Uint8Array([1, 2, 3]));
		const commitment = new Uint8Array(48) as Commitment;
		const proof = new Uint8Array(48) as Proof;
		try {
			Blob.verifyBatch([blob, blob], [commitment], [proof]);
			expect.fail("Should have thrown");
		} catch (e) {
			expect((e as Error).name).toBe("BlobArrayLengthMismatchError");
		}
	});

	it("validates max blobs per transaction", () => {
		const blobs = Array(7)
			.fill(null)
			.map(() => Blob.fromData(new Uint8Array([1, 2, 3])));
		const commitments = Array(7)
			.fill(null)
			.map(() => new Uint8Array(48) as Commitment);
		const proofs = Array(7)
			.fill(null)
			.map(() => new Uint8Array(48) as Proof);
		expect(() => Blob.verifyBatch(blobs, commitments, proofs)).toThrow(
			"Too many blobs",
		);
	});

	it("throws InvalidBlobCountError with correct name for too many blobs", () => {
		const blobs = Array(7)
			.fill(null)
			.map(() => Blob.fromData(new Uint8Array([1, 2, 3])));
		const commitments = Array(7)
			.fill(null)
			.map(() => new Uint8Array(48) as Commitment);
		const proofs = Array(7)
			.fill(null)
			.map(() => new Uint8Array(48) as Proof);
		try {
			Blob.verifyBatch(blobs, commitments, proofs);
			expect.fail("Should have thrown");
		} catch (e) {
			expect((e as Error).name).toBe("InvalidBlobCountError");
		}
	});

	it("accepts max blobs per transaction", () => {
		const blobs = Array(MAX_PER_TRANSACTION)
			.fill(null)
			.map(() => Blob.fromData(new Uint8Array([1, 2, 3])));
		const commitments = Array(MAX_PER_TRANSACTION)
			.fill(null)
			.map(() => new Uint8Array(48) as Commitment);
		const proofs = Array(MAX_PER_TRANSACTION)
			.fill(null)
			.map(() => new Uint8Array(48) as Proof);
		expect(() => Blob.verifyBatch(blobs, commitments, proofs)).toThrow(
			"Not implemented",
		);
	});
});

// ============================================================================
// Nested Namespace Tests - Blob.Commitment
// ============================================================================

describe("Blob.Commitment.isValid() - Nested Method", () => {
	it("validates 48-byte commitment", () => {
		const commitment = new Uint8Array(48);
		expect(Blob.Commitment.isValid(commitment)).toBe(true);
	});

	it("rejects incorrect sizes", () => {
		expect(Blob.Commitment.isValid(new Uint8Array(32))).toBe(false);
		expect(Blob.Commitment.isValid(new Uint8Array(64))).toBe(false);
	});
});

describe("Blob.Commitment.toVersionedHash() - Nested Method", () => {
	it("creates versioned hash from commitment", () => {
		const commitment = new Uint8Array(48).fill(0xab) as Commitment;
		const hash = Blob.Commitment.toVersionedHash(commitment);
		expect(hash.length).toBe(32);
		expect(hash[0]).toBe(COMMITMENT_VERSION_KZG);
	});
});

// ============================================================================
// Nested Namespace Tests - Blob.Proof
// ============================================================================

describe("Blob.Proof.isValid() - Nested Method", () => {
	it("validates 48-byte proof", () => {
		const proof = new Uint8Array(48);
		expect(Blob.Proof.isValid(proof)).toBe(true);
	});

	it("rejects incorrect sizes", () => {
		expect(Blob.Proof.isValid(new Uint8Array(32))).toBe(false);
		expect(Blob.Proof.isValid(new Uint8Array(64))).toBe(false);
	});
});

// ============================================================================
// Nested Namespace Tests - Blob.VersionedHash
// ============================================================================

describe("Blob.VersionedHash.isValid() - Nested Method", () => {
	it("validates correct versioned hash", () => {
		const hash = new Uint8Array(32);
		hash[0] = COMMITMENT_VERSION_KZG;
		expect(Blob.VersionedHash.isValid(hash)).toBe(true);
	});

	it("rejects incorrect size", () => {
		const hash = new Uint8Array(64);
		hash[0] = COMMITMENT_VERSION_KZG;
		expect(Blob.VersionedHash.isValid(hash)).toBe(false);
	});

	it("rejects incorrect version", () => {
		const hash = new Uint8Array(32);
		hash[0] = 0x00;
		expect(Blob.VersionedHash.isValid(hash)).toBe(false);
	});
});

describe("Blob.VersionedHash.getVersion() - Nested Method", () => {
	it("returns version byte", () => {
		const hash = new Uint8Array(32) as VersionedHash;
		hash[0] = COMMITMENT_VERSION_KZG;
		expect(Blob.VersionedHash.getVersion(hash)).toBe(COMMITMENT_VERSION_KZG);
	});

	it("returns 0 for undefined version byte", () => {
		const hash = new Uint8Array(32) as VersionedHash;
		expect(Blob.VersionedHash.getVersion(hash)).toBe(0);
	});
});

describe("Blob.VersionedHash.version() - Nested Method", () => {
	it("returns version byte (alias)", () => {
		const hash = new Uint8Array(32) as VersionedHash;
		hash[0] = COMMITMENT_VERSION_KZG;
		expect(Blob.VersionedHash.version(hash)).toBe(COMMITMENT_VERSION_KZG);
	});
});

// ============================================================================
// Constants Tests
// ============================================================================

describe("Blob Constants - Static Properties", () => {
	it("SIZE is correct", () => {
		expect(Blob.SIZE).toBe(131072);
		expect(Blob.SIZE).toBe(FIELD_ELEMENTS_PER_BLOB * BYTES_PER_FIELD_ELEMENT);
	});

	it("FIELD_ELEMENTS_PER_BLOB is correct", () => {
		expect(Blob.FIELD_ELEMENTS_PER_BLOB).toBe(4096);
	});

	it("BYTES_PER_FIELD_ELEMENT is correct", () => {
		expect(Blob.BYTES_PER_FIELD_ELEMENT).toBe(32);
	});

	it("MAX_PER_TRANSACTION is correct", () => {
		expect(Blob.MAX_PER_TRANSACTION).toBe(6);
	});

	it("COMMITMENT_VERSION_KZG is correct", () => {
		expect(Blob.COMMITMENT_VERSION_KZG).toBe(0x01);
	});

	it("GAS_PER_BLOB is correct", () => {
		expect(Blob.GAS_PER_BLOB).toBe(131072);
		expect(Blob.GAS_PER_BLOB).toBe(2 ** 17);
	});

	it("TARGET_GAS_PER_BLOCK is correct", () => {
		expect(Blob.TARGET_GAS_PER_BLOCK).toBe(393216);
		expect(Blob.TARGET_GAS_PER_BLOCK).toBe(GAS_PER_BLOB * 3);
	});
});

// ============================================================================
// Edge Cases & Integration
// ============================================================================

describe("Edge Cases", () => {
	it("handles exact max data size", () => {
		const maxSize = FIELD_ELEMENTS_PER_BLOB * (BYTES_PER_FIELD_ELEMENT - 1) - 4;
		const data = new Uint8Array(maxSize);
		const blob = Blob.fromData(data);
		const decoded = Blob.toData(blob);
		expect(decoded.length).toBe(maxSize);
		expect(decoded).toEqual(data);
	});

	it("handles all-zero blob", () => {
		const blob = Blob(SIZE);
		expect(blob.every((b) => b === 0)).toBe(true);
	});

	it("handles all-ones data", () => {
		const data = new Uint8Array(1000).fill(0xff);
		const blob = Blob.fromData(data);
		const decoded = Blob.toData(blob);
		expect(decoded).toEqual(data);
	});

	it("handles binary patterns", () => {
		const patterns = [
			new Uint8Array([0x00, 0x00, 0x00, 0x00]),
			new Uint8Array([0xff, 0xff, 0xff, 0xff]),
			new Uint8Array([0xaa, 0x55, 0xaa, 0x55]),
			new Uint8Array([0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80]),
		];
		for (const pattern of patterns) {
			const blob = Blob.fromData(pattern);
			const decoded = Blob.toData(blob);
			expect(decoded).toEqual(pattern);
		}
	});

	it("handles sequential blob operations", () => {
		const data1 = new TextEncoder().encode("First");
		const data2 = new TextEncoder().encode("Second");
		const data3 = new TextEncoder().encode("Third");
		const blob1 = Blob.fromData(data1);
		const blob2 = Blob.fromData(data2);
		const blob3 = Blob.fromData(data3);
		expect(Blob.toData(blob1)).toEqual(data1);
		expect(Blob.toData(blob2)).toEqual(data2);
		expect(Blob.toData(blob3)).toEqual(data3);
	});

	it("mixed instance and static method calls", () => {
		const data = new TextEncoder().encode("Mixed API test");
		const blob = Blob.fromData(data);
		const extracted1 = blob.toData();
		const extracted2 = Blob.toData(blob);
		expect(extracted1).toEqual(extracted2);
		expect(extracted1).toEqual(data);
	});
});

describe("Integration Scenarios", () => {
	it("blob sidecar structure simulation", () => {
		const data = new TextEncoder().encode("Transaction calldata");
		const blob = Blob.fromData(data);
		expect(Blob.isValid(blob)).toBe(true);
		const extracted = Blob.toData(blob);
		expect(extracted).toEqual(data);
	});

	it("multiple blobs in transaction", () => {
		const blobs = [];
		for (let i = 0; i < MAX_PER_TRANSACTION; i++) {
			const data = new TextEncoder().encode(`Blob ${i}`);
			blobs.push(Blob.fromData(data));
		}
		expect(blobs.length).toBe(MAX_PER_TRANSACTION);
		expect(blobs.every((b) => Blob.isValid(b))).toBe(true);
		const totalGas = Blob.calculateGas(blobs.length);
		expect(totalGas).toBe(GAS_PER_BLOB * MAX_PER_TRANSACTION);
	});

	it("data size estimation workflow", () => {
		const dataSize = 300000;
		const estimatedCount = Blob.estimateBlobCount(dataSize);
		const estimatedGas = Blob.calculateGas(estimatedCount);
		expect(estimatedCount).toBeGreaterThan(1);
		expect(estimatedGas).toBe(GAS_PER_BLOB * estimatedCount);
	});

	it("split and join workflow", () => {
		const largeData = new Uint8Array(400000);
		for (let i = 0; i < largeData.length; i++) {
			largeData[i] = i % 256;
		}
		const blobs = Blob.splitData(largeData);
		expect(blobs.length).toBeGreaterThan(1);
		expect(blobs.length).toBeLessThanOrEqual(MAX_PER_TRANSACTION);
		const reconstructed = Blob.joinData(blobs);
		expect(reconstructed).toEqual(largeData);
		const estimatedCount = Blob.estimateBlobCount(largeData.length);
		expect(blobs.length).toBe(estimatedCount);
	});
});

describe("Type Safety & Branding", () => {
	it("blob maintains type brand", () => {
		const blob = Blob.fromData(new Uint8Array([1, 2, 3]));
		expect(Blob.isValid(blob)).toBe(true);
	});

	it("commitment size validation enforced", () => {
		const wrongSize = new Uint8Array(47) as Commitment;
		expect(Blob.Commitment.isValid(wrongSize)).toBe(false);
	});

	it("proof size validation enforced", () => {
		const wrongSize = new Uint8Array(47) as Proof;
		expect(Blob.Proof.isValid(wrongSize)).toBe(false);
	});

	it("versioned hash validation enforced", () => {
		const wrongSize = new Uint8Array(31) as VersionedHash;
		expect(Blob.VersionedHash.isValid(wrongSize)).toBe(false);
		const wrongVersion = new Uint8Array(32) as VersionedHash;
		wrongVersion[0] = 0x02;
		expect(Blob.VersionedHash.isValid(wrongVersion)).toBe(false);
	});
});

```
