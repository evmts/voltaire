---
title: '[TS/JS] src/primitives/TransactionHash/TransactionHash.test.ts'
source: 'src/primitives/TransactionHash/TransactionHash.test.ts'
---

> Auto-generated from test file: src/primitives/TransactionHash/TransactionHash.test.ts

```typescript
import { describe, expect, it } from "vitest";
import * as TransactionHash from "./index.js";
import {
	InvalidTransactionHashFormatError,
	InvalidTransactionHashLengthError,
} from "./errors.js";

describe("TransactionHash", () => {
	const testHash =
		"0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef";
	const testBytes = new Uint8Array([
		0x12, 0x34, 0x56, 0x78, 0x90, 0xab, 0xcd, 0xef, 0x12, 0x34, 0x56, 0x78,
		0x90, 0xab, 0xcd, 0xef, 0x12, 0x34, 0x56, 0x78, 0x90, 0xab, 0xcd, 0xef,
		0x12, 0x34, 0x56, 0x78, 0x90, 0xab, 0xcd, 0xef,
	]);

	describe("from", () => {
		it("creates from hex string", () => {
			const hash = TransactionHash.from(testHash);
			expect(hash).toHaveLength(32);
		});

		it("creates from bytes", () => {
			const hash = TransactionHash.from(testBytes);
			expect(hash).toHaveLength(32);
		});

		it("throws on invalid type", () => {
			try {
				// biome-ignore lint/suspicious/noExplicitAny: testing invalid input types
				TransactionHash.from(123 as any);
				expect.fail("Should have thrown");
			} catch (e) {
				expect(e).toBeInstanceOf(InvalidTransactionHashFormatError);
				expect((e as InvalidTransactionHashFormatError).name).toBe(
					"InvalidTransactionHashFormatError",
				);
				expect((e as InvalidTransactionHashFormatError).message).toContain(
					"Unsupported TransactionHash value type",
				);
			}
		});
	});

	describe("fromHex", () => {
		it("parses valid hex", () => {
			const hash = TransactionHash.fromHex(testHash);
			expect(hash).toHaveLength(32);
		});

		it("parses hex without 0x prefix", () => {
			const hash = TransactionHash.fromHex(testHash.slice(2));
			expect(hash).toHaveLength(32);
		});

		it("throws on wrong length", () => {
			try {
				TransactionHash.fromHex("0x1234");
				expect.fail("Should have thrown");
			} catch (e) {
				expect(e).toBeInstanceOf(InvalidTransactionHashFormatError);
				expect((e as InvalidTransactionHashFormatError).name).toBe(
					"InvalidTransactionHashFormatError",
				);
				expect((e as InvalidTransactionHashFormatError).message).toContain(
					"must be 64 characters",
				);
			}
		});

		it("throws on invalid characters", () => {
			try {
				TransactionHash.fromHex(
					"0xgg34567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef",
				);
				expect.fail("Should have thrown");
			} catch (e) {
				expect(e).toBeInstanceOf(InvalidTransactionHashFormatError);
				expect((e as InvalidTransactionHashFormatError).name).toBe(
					"InvalidTransactionHashFormatError",
				);
				expect((e as InvalidTransactionHashFormatError).message).toContain(
					"invalid characters",
				);
			}
		});
	});

	describe("fromBytes", () => {
		it("throws on wrong length", () => {
			try {
				TransactionHash.fromBytes(new Uint8Array(31));
				expect.fail("Should have thrown");
			} catch (e) {
				expect(e).toBeInstanceOf(InvalidTransactionHashLengthError);
				expect((e as InvalidTransactionHashLengthError).name).toBe(
					"InvalidTransactionHashLengthError",
				);
				expect((e as InvalidTransactionHashLengthError).message).toContain(
					"must be 32 bytes",
				);
			}

			try {
				TransactionHash.fromBytes(new Uint8Array(33));
				expect.fail("Should have thrown");
			} catch (e) {
				expect(e).toBeInstanceOf(InvalidTransactionHashLengthError);
				expect((e as InvalidTransactionHashLengthError).name).toBe(
					"InvalidTransactionHashLengthError",
				);
			}
		});

		it("accepts 32 bytes", () => {
			const hash = TransactionHash.fromBytes(testBytes);
			expect(hash).toHaveLength(32);
		});
	});

	describe("toHex", () => {
		it("converts to hex", () => {
			const hash = TransactionHash.fromBytes(testBytes);
			const hex = TransactionHash.toHex(hash);
			expect(hex).toBe(testHash);
		});
	});

	describe("equals", () => {
		it("returns true for equal hashes", () => {
			const a = TransactionHash.fromHex(testHash);
			const b = TransactionHash.fromHex(testHash);
			expect(TransactionHash.equals(a, b)).toBe(true);
		});

		it("returns false for different hashes", () => {
			const a = TransactionHash.fromHex(testHash);
			const b = TransactionHash.fromHex(
				"0xabcdef1234567890abcdef1234567890abcdef1234567890abcdef1234567890",
			);
			expect(TransactionHash.equals(a, b)).toBe(false);
		});
	});

	describe("error properties", () => {
		it("InvalidTransactionHashLengthError has correct properties", () => {
			const error = new InvalidTransactionHashLengthError("Test message", {
				value: new Uint8Array(10),
				expected: "32 bytes",
			});
			expect(error.name).toBe("InvalidTransactionHashLengthError");
			expect(error.code).toBe("INVALID_TRANSACTION_HASH_LENGTH");
			expect(error.value).toEqual(new Uint8Array(10));
			expect(error.expected).toBe("32 bytes");
		});

		it("InvalidTransactionHashFormatError has correct properties", () => {
			const error = new InvalidTransactionHashFormatError("Test message", {
				value: "0xinvalid",
				expected: "valid hex",
			});
			expect(error.name).toBe("InvalidTransactionHashFormatError");
			expect(error.code).toBe("INVALID_TRANSACTION_HASH_FORMAT");
			expect(error.value).toBe("0xinvalid");
			expect(error.expected).toBe("valid hex");
		});
	});
});

```
