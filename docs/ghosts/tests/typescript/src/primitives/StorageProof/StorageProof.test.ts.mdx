---
title: '[TS/JS] src/primitives/StorageProof/StorageProof.test.ts'
source: 'src/primitives/StorageProof/StorageProof.test.ts'
---

> Auto-generated from test file: src/primitives/StorageProof/StorageProof.test.ts

```typescript
import { describe, expect, it } from "vitest";
import { Address } from "../Address/index.js";
import * as StorageKey from "../State/index.js";
import * as StorageValue from "../StorageValue/index.js";
import * as StorageProof from "./index.js";

describe("StorageProof", () => {
	const createTestKey = () =>
		StorageKey.create(
			Address("0x1234567890123456789012345678901234567890"),
			0n,
		);

	const createTestValue = () => StorageValue.from(123n);

	const createTestProof = () => [
		new Uint8Array([1, 2, 3, 4]),
		new Uint8Array([5, 6, 7, 8]),
	];

	describe("from", () => {
		it("creates StorageProof from object", () => {
			const key = createTestKey();
			const value = createTestValue();
			const proof = createTestProof();

			const storageProof = StorageProof.from({
				key,
				value,
				proof,
			});

			expect(storageProof).toBeDefined();
			expect(storageProof.key).toBe(key);
			expect(storageProof.value).toBe(value);
			expect(storageProof.proof).toHaveLength(2);
		});

		it("accepts empty proof array", () => {
			const storageProof = StorageProof.from({
				key: createTestKey(),
				value: createTestValue(),
				proof: [],
			});

			expect(storageProof.proof).toHaveLength(0);
		});

		it("returns immutable object", () => {
			const storageProof = StorageProof.from({
				key: createTestKey(),
				value: createTestValue(),
				proof: createTestProof(),
			});

			expect(Object.isFrozen(storageProof)).toBe(true);
			expect(Object.isFrozen(storageProof.proof)).toBe(true);
		});

		it("throws on missing key", () => {
			expect(() =>
				StorageProof.from({
					// @ts-expect-error - testing missing field
					value: createTestValue(),
					proof: [],
				}),
			).toThrow();
		});

		it("throws on invalid key", () => {
			expect(() =>
				StorageProof.from({
					// @ts-expect-error - testing invalid type
					key: "not a storage key",
					value: createTestValue(),
					proof: [],
				}),
			).toThrow("key must be a StorageKey");
		});

		it("throws on invalid value", () => {
			expect(() =>
				StorageProof.from({
					key: createTestKey(),
					// @ts-expect-error - testing invalid type
					value: "not a storage value",
					proof: [],
				}),
			).toThrow("value must be a StorageValue");
		});

		it("throws on invalid value length", () => {
			expect(() =>
				StorageProof.from({
					key: createTestKey(),
					// @ts-expect-error - testing invalid length
					value: new Uint8Array(16), // Wrong length
					proof: [],
				}),
			).toThrow("value must be 32 bytes");
		});

		it("throws on invalid proof type", () => {
			expect(() =>
				StorageProof.from({
					key: createTestKey(),
					value: createTestValue(),
					// @ts-expect-error - testing invalid type
					proof: "not an array",
				}),
			).toThrow("proof must be an array");
		});

		it("throws on invalid proof element", () => {
			expect(() =>
				StorageProof.from({
					key: createTestKey(),
					value: createTestValue(),
					// @ts-expect-error - testing invalid element
					proof: [new Uint8Array([1, 2]), "invalid", new Uint8Array([3, 4])],
				}),
			).toThrow("proof[1] must be a Uint8Array");
		});
	});

	describe("equals", () => {
		it("returns true for equal StorageProofs", () => {
			const key = createTestKey();
			const value = createTestValue();
			const proof = createTestProof();

			const proof1 = StorageProof.from({ key, value, proof });
			const proof2 = StorageProof.from({ key, value, proof });

			expect(StorageProof.equals(proof1, proof2)).toBe(true);
		});

		it("returns false for different keys", () => {
			const value = createTestValue();
			const proof = createTestProof();

			const key1 = StorageKey.create(
				Address("0x1234567890123456789012345678901234567890"),
				0n,
			);
			const key2 = StorageKey.create(
				Address("0x1234567890123456789012345678901234567890"),
				1n, // Different slot
			);

			const proof1 = StorageProof.from({ key: key1, value, proof });
			const proof2 = StorageProof.from({ key: key2, value, proof });

			expect(StorageProof.equals(proof1, proof2)).toBe(false);
		});

		it("returns false for different values", () => {
			const key = createTestKey();
			const proof = createTestProof();

			const proof1 = StorageProof.from({
				key,
				value: StorageValue.from(123n),
				proof,
			});
			const proof2 = StorageProof.from({
				key,
				value: StorageValue.from(456n),
				proof,
			});

			expect(StorageProof.equals(proof1, proof2)).toBe(false);
		});

		it("returns false for different proof lengths", () => {
			const key = createTestKey();
			const value = createTestValue();

			const proof1 = StorageProof.from({
				key,
				value,
				proof: [new Uint8Array([1, 2])],
			});
			const proof2 = StorageProof.from({
				key,
				value,
				proof: [new Uint8Array([1, 2]), new Uint8Array([3, 4])],
			});

			expect(StorageProof.equals(proof1, proof2)).toBe(false);
		});

		it("returns false for different proof elements", () => {
			const key = createTestKey();
			const value = createTestValue();

			const proof1 = StorageProof.from({
				key,
				value,
				proof: [new Uint8Array([1, 2, 3])],
			});
			const proof2 = StorageProof.from({
				key,
				value,
				proof: [new Uint8Array([1, 2, 4])], // Different last byte
			});

			expect(StorageProof.equals(proof1, proof2)).toBe(false);
		});
	});

	describe("immutability", () => {
		it("prevents modification of proof array", () => {
			const proofArray = [new Uint8Array([1, 2, 3])];
			const storageProof = StorageProof.from({
				key: createTestKey(),
				value: createTestValue(),
				proof: proofArray,
			});

			// Original array modification shouldn't affect proof
			proofArray.push(new Uint8Array([4, 5, 6]));
			expect(storageProof.proof).toHaveLength(1);
		});
	});
});

```
