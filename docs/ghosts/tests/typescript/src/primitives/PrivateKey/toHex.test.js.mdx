---
title: '[TS/JS] src/primitives/PrivateKey/toHex.test.js'
source: 'src/primitives/PrivateKey/toHex.test.js'
---

> Auto-generated from test file: src/primitives/PrivateKey/toHex.test.js

```javascript
import { describe, expect, it } from "vitest";
import { from } from "./from.js";
import { fromBytes } from "./fromBytes.js";
import { toHex } from "./toHex.js";

describe("PrivateKey.toHex", () => {
	describe("conversion tests", () => {
		it("converts zero key to hex", () => {
			const pk = fromBytes(new Uint8Array(32));
			const hex = toHex.call(pk);

			expect(hex).toBe(
				"0x0000000000000000000000000000000000000000000000000000000000000000",
			);
		});

		it("converts max key to hex", () => {
			const pk = fromBytes(new Uint8Array(32).fill(0xff));
			const hex = toHex.call(pk);

			expect(hex).toBe(
				"0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff",
			);
		});

		it("converts known test key to hex", () => {
			const pk = from(
				"0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80",
			);
			const hex = toHex.call(pk);

			expect(hex).toBe(
				"0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80",
			);
		});

		it("converts key with leading zeros", () => {
			const pk = fromBytes(
				new Uint8Array([
					0x00, 0x00, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
					0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13,
					0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d,
				]),
			);
			const hex = toHex.call(pk);

			expect(hex).toBe(
				"0x0000000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d",
			);
		});

		it("converts key with trailing zeros", () => {
			const pk = fromBytes(
				new Uint8Array([
					0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b,
					0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16,
					0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x00, 0x00, 0x00, 0x00,
				]),
			);
			const hex = toHex.call(pk);

			expect(hex).toBe(
				"0x0102030405060708090a0b0c0d0e0f101112131415161718191a1b1c00000000",
			);
		});

		it("pads single digit bytes with zero", () => {
			const pk = fromBytes(
				new Uint8Array([
					0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b,
					0x0c, 0x0d, 0x0e, 0x0f, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06,
					0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x00,
				]),
			);
			const hex = toHex.call(pk);

			expect(hex).toContain("01");
			expect(hex).toContain("0f");
			expect(/^0x[0-9a-f]{64}$/.test(hex)).toBe(true);
			expect(hex.length).toBe(66);
		});
	});

	describe("format tests", () => {
		it("returns hex string with 0x prefix", () => {
			const pk = fromBytes(new Uint8Array(32));
			const hex = toHex.call(pk);

			expect(hex.startsWith("0x")).toBe(true);
		});

		it("returns lowercase hex", () => {
			const pk = fromBytes(new Uint8Array(32).fill(0xab));
			const hex = toHex.call(pk);

			expect(hex).toBe(
				"0xabababababababababababababababababababababababababababababababab",
			);
			expect(hex).not.toContain("A");
			expect(hex).not.toContain("B");
		});

		it("returns exactly 66 characters", () => {
			const pk = fromBytes(new Uint8Array(32));
			const hex = toHex.call(pk);

			expect(hex.length).toBe(66);
		});

		it("returns valid hex string", () => {
			const pk = fromBytes(new Uint8Array(32).fill(0x12));
			const hex = toHex.call(pk);

			expect(/^0x[0-9a-f]{64}$/.test(hex)).toBe(true);
		});
	});

	describe("round-trip tests", () => {
		it("round-trips with from", () => {
			const original =
				"0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80";
			const pk = from(original);
			const hex = toHex.call(pk);

			expect(hex).toBe(original);
		});

		it("round-trips with fromBytes", () => {
			const bytes = new Uint8Array(32);
			for (let i = 0; i < 32; i++) {
				bytes[i] = i * 8;
			}
			const pk = fromBytes(bytes);
			const hex = toHex.call(pk);
			const pk2 = from(hex);

			expect(pk2).toEqual(pk);
		});

		it("round-trips zero key", () => {
			const original =
				"0x0000000000000000000000000000000000000000000000000000000000000000";
			const pk = from(original);
			const hex = toHex.call(pk);

			expect(hex).toBe(original);
		});

		it("round-trips max key", () => {
			const original =
				"0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff";
			const pk = from(original);
			const hex = toHex.call(pk);

			expect(hex).toBe(original);
		});

		it("preserves all byte values", () => {
			const bytes = new Uint8Array(32);
			for (let i = 0; i < 32; i++) {
				bytes[i] = i;
			}
			const pk = fromBytes(bytes);
			const hex = toHex.call(pk);
			const pk2 = from(hex);

			for (let i = 0; i < 32; i++) {
				expect(pk2[i]).toBe(bytes[i]);
			}
		});
	});

	describe("edge cases", () => {
		it("handles all zeros", () => {
			const pk = fromBytes(new Uint8Array(32));
			const hex = toHex.call(pk);

			expect(hex).toBe(
				"0x0000000000000000000000000000000000000000000000000000000000000000",
			);
		});

		it("handles all ones", () => {
			const pk = fromBytes(new Uint8Array(32).fill(0xff));
			const hex = toHex.call(pk);

			expect(hex).toBe(
				"0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff",
			);
		});

		it("handles alternating bytes", () => {
			const bytes = new Uint8Array(32);
			for (let i = 0; i < 32; i++) {
				bytes[i] = i % 2 === 0 ? 0xaa : 0x55;
			}
			const pk = fromBytes(bytes);
			const hex = toHex.call(pk);

			expect(hex).toContain("aa");
			expect(hex).toContain("55");
		});

		it("handles sequential bytes", () => {
			const bytes = new Uint8Array(32);
			for (let i = 0; i < 32; i++) {
				bytes[i] = i;
			}
			const pk = fromBytes(bytes);
			const hex = toHex.call(pk);

			expect(hex).toContain("00");
			expect(hex).toContain("01");
			expect(hex).toContain("1f");
		});

		it("handles bytes with special patterns", () => {
			const pk = fromBytes(
				new Uint8Array([
					0xde, 0xad, 0xbe, 0xef, 0xca, 0xfe, 0xba, 0xbe, 0x12, 0x34, 0x56,
					0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x01, 0x23, 0x45, 0x67, 0x89, 0xab,
					0xcd, 0xef, 0xff, 0xee, 0xdd, 0xcc, 0xbb, 0xaa, 0x99, 0x88,
				]),
			);
			const hex = toHex.call(pk);

			expect(hex).toContain("dead");
			expect(hex).toContain("beef");
			expect(hex).toContain("cafe");
			expect(hex).toContain("babe");
		});
	});

	describe("determinism tests", () => {
		it("produces same output for same input", () => {
			const pk = from(
				"0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80",
			);
			const hex1 = toHex.call(pk);
			const hex2 = toHex.call(pk);

			expect(hex1).toBe(hex2);
		});

		it("produces different output for different input", () => {
			const pk1 = fromBytes(new Uint8Array(32).fill(0x01));
			const pk2 = fromBytes(new Uint8Array(32).fill(0x02));
			const hex1 = toHex.call(pk1);
			const hex2 = toHex.call(pk2);

			expect(hex1).not.toBe(hex2);
		});

		it("distinguishes keys differing by one byte", () => {
			const bytes1 = new Uint8Array(32).fill(0xaa);
			const bytes2 = new Uint8Array(32).fill(0xaa);
			bytes2[15] = 0xab;

			const pk1 = fromBytes(bytes1);
			const pk2 = fromBytes(bytes2);
			const hex1 = toHex.call(pk1);
			const hex2 = toHex.call(pk2);

			expect(hex1).not.toBe(hex2);
		});
	});

	describe("usage tests", () => {
		it("can be called with this context", () => {
			const pk = from(
				"0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80",
			);
			const hex = toHex.call(pk);

			expect(hex).toBeDefined();
			expect(typeof hex).toBe("string");
		});

		it("produces string that can be parsed", () => {
			const pk = fromBytes(new Uint8Array(32).fill(0x42));
			const hex = toHex.call(pk);

			expect(() => from(hex)).not.toThrow();
		});
	});
});

```
