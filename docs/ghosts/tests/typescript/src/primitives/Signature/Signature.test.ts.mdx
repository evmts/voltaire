---
title: '[TS/JS] src/primitives/Signature/Signature.test.ts'
source: 'src/primitives/Signature/Signature.test.ts'
---

> Auto-generated from test file: src/primitives/Signature/Signature.test.ts

```typescript
import { describe, expect, it } from "vitest";
import * as Signature from "./index.js";

describe("Signature", () => {
	describe("secp256k1", () => {
		const r = new Uint8Array(32).fill(1);
		const s = new Uint8Array(32).fill(2);
		const v = 27;

		it("should create from secp256k1 components", () => {
			const sig = Signature.fromSecp256k1(r, s, v);
			expect(sig.algorithm).toBe("secp256k1");
			expect(sig.v).toBe(27);
			expect(sig.length).toBe(64);
		});

		it("should create from secp256k1 without v", () => {
			const sig = Signature.fromSecp256k1(r, s);
			expect(sig.algorithm).toBe("secp256k1");
			expect(sig.v).toBeUndefined();
		});

		it("should throw on invalid r length", () => {
			expect(() => Signature.fromSecp256k1(new Uint8Array(31), s, v)).toThrow(
				Signature.InvalidSignatureLengthError,
			);
		});

		it("should throw on invalid s length", () => {
			expect(() => Signature.fromSecp256k1(r, new Uint8Array(31), v)).toThrow(
				Signature.InvalidSignatureLengthError,
			);
		});
	});

	describe("p256", () => {
		const r = new Uint8Array(32).fill(3);
		const s = new Uint8Array(32).fill(4);

		it("should create from p256 components", () => {
			const sig = Signature.fromP256(r, s);
			expect(sig.algorithm).toBe("p256");
			expect(sig.v).toBeUndefined();
			expect(sig.length).toBe(64);
		});

		it("should throw on invalid r length", () => {
			expect(() => Signature.fromP256(new Uint8Array(31), s)).toThrow(
				Signature.InvalidSignatureLengthError,
			);
		});
	});

	describe("ed25519", () => {
		const signature = new Uint8Array(64).fill(5);

		it("should create from ed25519 signature", () => {
			const sig = Signature.fromEd25519(signature);
			expect(sig.algorithm).toBe("ed25519");
			expect(sig.length).toBe(64);
		});

		it("should throw on invalid signature length", () => {
			expect(() => Signature.fromEd25519(new Uint8Array(63))).toThrow(
				Signature.InvalidSignatureLengthError,
			);
		});
	});

	describe("from (universal constructor)", () => {
		it("should handle Uint8Array (defaults to secp256k1)", () => {
			const bytes = new Uint8Array(64).fill(1);
			const sig = Signature.from(bytes);
			expect(sig.algorithm).toBe("secp256k1");
		});

		it("should handle object with r, s, v", () => {
			const r = new Uint8Array(32).fill(1);
			const s = new Uint8Array(32).fill(2);
			const sig = Signature.from({ r, s, v: 27, algorithm: "secp256k1" });
			expect(sig.algorithm).toBe("secp256k1");
			expect(sig.v).toBe(27);
		});

		it("should handle object with r, s (p256)", () => {
			const r = new Uint8Array(32).fill(1);
			const s = new Uint8Array(32).fill(2);
			const sig = Signature.from({ r, s, algorithm: "p256" });
			expect(sig.algorithm).toBe("p256");
		});

		it("should handle ed25519 object", () => {
			const signature = new Uint8Array(64).fill(1);
			const sig = Signature.from({ signature, algorithm: "ed25519" });
			expect(sig.algorithm).toBe("ed25519");
		});

		it("should return existing BrandedSignature", () => {
			const r = new Uint8Array(32).fill(1);
			const s = new Uint8Array(32).fill(2);
			const sig1 = Signature.fromSecp256k1(r, s);
			const sig2 = Signature.from(sig1);
			expect(sig2).toBe(sig1);
		});
	});

	describe("compact encoding", () => {
		it("should convert to compact (without v)", () => {
			const r = new Uint8Array(32).fill(1);
			const s = new Uint8Array(32).fill(2);
			const sig = Signature.fromSecp256k1(r, s);
			const compact = Signature.toCompact(sig);
			expect(compact.length).toBe(64);
			expect(compact[0]).toBe(1);
			expect(compact[32]).toBe(2);
		});

		it("should convert to compact (with v)", () => {
			const r = new Uint8Array(32).fill(1);
			const s = new Uint8Array(32).fill(2);
			const sig = Signature.fromSecp256k1(r, s, 1); // yParity 1
			const compact = Signature.toCompact(sig);
			expect(compact.length).toBe(64); // EIP-2098 format
			// yParity encoded in bit 255 of s
			expect(compact[32] & 0x80).toBe(0x80); // Bit 255 set for yParity=1
		});

		it("should create from compact (64 bytes)", () => {
			const compact = new Uint8Array(64);
			compact.fill(1, 0, 32);
			compact.fill(2, 32, 64);
			const sig = Signature.fromCompact(compact, "secp256k1");
			expect(sig.algorithm).toBe("secp256k1");
			expect(sig.length).toBe(64);
		});

		it("should create from compact (65 bytes with v)", () => {
			const compact = new Uint8Array(65);
			compact.fill(1, 0, 32);
			compact.fill(2, 32, 64);
			compact[64] = 27;
			const sig = Signature.fromCompact(compact, "secp256k1");
			expect(sig.algorithm).toBe("secp256k1");
			expect(sig.v).toBe(27);
		});
	});

	describe("DER encoding", () => {
		it("should convert ECDSA to DER", () => {
			const r = new Uint8Array(32).fill(0);
			r[31] = 0x42;
			const s = new Uint8Array(32).fill(0);
			s[31] = 0x84;
			const sig = Signature.fromSecp256k1(r, s, 27);
			const der = Signature.toDER(sig);
			expect(der[0]).toBe(0x30); // SEQUENCE tag
			expect(der[2]).toBe(0x02); // INTEGER tag for r
		});

		it("should throw for Ed25519", () => {
			const sig = Signature.fromEd25519(new Uint8Array(64));
			expect(() => Signature.toDER(sig)).toThrow(
				Signature.InvalidAlgorithmError,
			);
		});

		it("should create from DER", () => {
			// Minimal DER: SEQUENCE { INTEGER r, INTEGER s }
			const der = new Uint8Array([
				0x30,
				0x06, // SEQUENCE, length 6
				0x02,
				0x01,
				0x42, // INTEGER r = 0x42
				0x02,
				0x01,
				0x84, // INTEGER s = 0x84
			]);
			const sig = Signature.fromDER(der, "secp256k1", 27);
			expect(sig.algorithm).toBe("secp256k1");
			expect(sig.v).toBe(27);
		});
	});

	describe("canonical form", () => {
		it("should check if signature is canonical", () => {
			// Low s value (canonical)
			const r = new Uint8Array(32).fill(0);
			r[31] = 1;
			const s = new Uint8Array(32).fill(0);
			s[31] = 1;
			const sig = Signature.fromSecp256k1(r, s);
			expect(Signature.isCanonical(sig)).toBe(true);
		});

		it("should detect non-canonical signature", () => {
			const r = new Uint8Array(32).fill(0);
			r[31] = 1;
			// High s value (non-canonical)
			const s = new Uint8Array(32).fill(0xff);
			const sig = Signature.fromSecp256k1(r, s);
			expect(Signature.isCanonical(sig)).toBe(false);
		});

		it("should normalize non-canonical signature", () => {
			const r = new Uint8Array(32).fill(0);
			r[31] = 1;
			// High s value (non-canonical but valid): 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A1
			// This is just above n/2 for secp256k1
			const s = new Uint8Array([
				0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
				0xff, 0xff, 0xff, 0xff, 0x5d, 0x57, 0x6e, 0x73, 0x57, 0xa4, 0x50, 0x1d,
				0xdf, 0xe9, 0x2f, 0x46, 0x68, 0x1b, 0x20, 0xa2,
			]);
			const sig = Signature.fromSecp256k1(r, s, 27);
			const normalized = Signature.normalize(sig);
			expect(Signature.isCanonical(normalized)).toBe(true);
			// v should flip
			expect(normalized.v).toBe(28);
		});

		it("should return Ed25519 as-is (always canonical)", () => {
			const sig = Signature.fromEd25519(new Uint8Array(64).fill(1));
			expect(Signature.isCanonical(sig)).toBe(true);
			expect(Signature.normalize(sig)).toBe(sig);
		});
	});

	describe("getters", () => {
		it("should get algorithm", () => {
			const sig = Signature.fromSecp256k1(
				new Uint8Array(32),
				new Uint8Array(32),
			);
			expect(Signature.getAlgorithm(sig)).toBe("secp256k1");
		});

		it("should get r component", () => {
			const r = new Uint8Array(32).fill(1);
			const s = new Uint8Array(32).fill(2);
			const sig = Signature.fromSecp256k1(r, s);
			const rValue = Signature.getR(sig);
			expect(rValue.length).toBe(32);
			expect(rValue[0]).toBe(1);
		});

		it("should get s component", () => {
			const r = new Uint8Array(32).fill(1);
			const s = new Uint8Array(32).fill(2);
			const sig = Signature.fromSecp256k1(r, s);
			const sValue = Signature.getS(sig);
			expect(sValue.length).toBe(32);
			expect(sValue[0]).toBe(2);
		});

		it("should get v", () => {
			const r = new Uint8Array(32).fill(1);
			const s = new Uint8Array(32).fill(2);
			const sig = Signature.fromSecp256k1(r, s, 27);
			expect(Signature.getV(sig)).toBe(27);
		});

		it("should throw getR for Ed25519", () => {
			const sig = Signature.fromEd25519(new Uint8Array(64));
			expect(() => Signature.getR(sig)).toThrow(
				Signature.InvalidAlgorithmError,
			);
		});

		it("should throw getV for non-secp256k1", () => {
			const sig = Signature.fromP256(new Uint8Array(32), new Uint8Array(32));
			expect(() => Signature.getV(sig)).toThrow(
				Signature.InvalidAlgorithmError,
			);
		});
	});

	describe("utilities", () => {
		it("should check if value is BrandedSignature", () => {
			const sig = Signature.fromSecp256k1(
				new Uint8Array(32),
				new Uint8Array(32),
			);
			expect(Signature.is(sig)).toBe(true);
			expect(Signature.is(new Uint8Array(64))).toBe(false);
			expect(Signature.is(null)).toBe(false);
		});

		it("should check equality", () => {
			const r = new Uint8Array(32).fill(1);
			const s = new Uint8Array(32).fill(2);
			const sig1 = Signature.fromSecp256k1(r, s, 27);
			const sig2 = Signature.fromSecp256k1(r, s, 27);
			const sig3 = Signature.fromSecp256k1(r, s, 28);
			expect(Signature.equals(sig1, sig2)).toBe(true);
			expect(Signature.equals(sig1, sig3)).toBe(false);
		});

		it("should convert to bytes", () => {
			const r = new Uint8Array(32).fill(1);
			const s = new Uint8Array(32).fill(2);
			const sig = Signature.fromSecp256k1(r, s, 27);
			const bytes = Signature.toBytes(sig);
			expect(bytes.length).toBe(64);
			expect(bytes[0]).toBe(1);
			expect(bytes[32]).toBe(2);
		});
	});

	describe("verify", () => {
		it("should return false for invalid signature", () => {
			const sig = Signature.fromSecp256k1(
				new Uint8Array(32),
				new Uint8Array(32),
			);
			// Invalid signature with zero r,s should return false (not throw)
			const isValid = Signature.verify(
				sig,
				new Uint8Array(32),
				new Uint8Array(64),
			);
			expect(isValid).toBe(false);
		});

		it("should throw for ed25519 (not yet implemented)", () => {
			const sig = Signature.fromEd25519(new Uint8Array(64));
			expect(() =>
				Signature.verify(sig, new Uint8Array(32), new Uint8Array(32)),
			).toThrow(Signature.InvalidAlgorithmError);
		});
	});

	describe("DER encoding edge cases", () => {
		it("should handle DER with leading zeros in r", () => {
			const der = new Uint8Array([
				0x30,
				0x09, // SEQUENCE, length 9
				0x02,
				0x03,
				0x00,
				0x00,
				0x42, // INTEGER r with leading zeros
				0x02,
				0x02,
				0x00,
				0x84, // INTEGER s with padding
			]);
			const sig = Signature.fromDER(der, "secp256k1", 27);
			expect(sig.algorithm).toBe("secp256k1");
			const r = Signature.getR(sig);
			expect(r[31]).toBe(0x42);
		});

		it("should handle DER with high bit set requiring padding", () => {
			const der = new Uint8Array([
				0x30,
				0x08, // SEQUENCE, length 8
				0x02,
				0x02,
				0x00,
				0x81, // INTEGER r = 0x81 (needs 0x00 padding)
				0x02,
				0x02,
				0x00,
				0xff, // INTEGER s = 0xff (needs 0x00 padding)
			]);
			const sig = Signature.fromDER(der, "p256");
			expect(sig.algorithm).toBe("p256");
		});

		it("should roundtrip DER encoding", () => {
			const r = new Uint8Array(32).fill(0);
			r[30] = 0x12;
			r[31] = 0x34;
			const s = new Uint8Array(32).fill(0);
			s[30] = 0x56;
			s[31] = 0x78;
			const sig = Signature.fromSecp256k1(r, s, 27);
			const der = Signature.toDER(sig);
			const sig2 = Signature.fromDER(der, "secp256k1", 27);
			expect(Signature.equals(sig, sig2)).toBe(true);
		});

		it("should throw on invalid SEQUENCE tag", () => {
			const der = new Uint8Array([
				0x31, 0x06, 0x02, 0x01, 0x42, 0x02, 0x01, 0x84,
			]);
			expect(() => Signature.fromDER(der, "secp256k1")).toThrow(
				Signature.InvalidDERError,
			);
		});

		it("should throw on invalid INTEGER tag for r", () => {
			const der = new Uint8Array([
				0x30, 0x06, 0x03, 0x01, 0x42, 0x02, 0x01, 0x84,
			]);
			expect(() => Signature.fromDER(der, "secp256k1")).toThrow(
				Signature.InvalidDERError,
			);
		});

		it("should throw on invalid INTEGER tag for s", () => {
			const der = new Uint8Array([
				0x30, 0x06, 0x02, 0x01, 0x42, 0x03, 0x01, 0x84,
			]);
			expect(() => Signature.fromDER(der, "secp256k1")).toThrow(
				Signature.InvalidDERError,
			);
		});

		it("should throw on invalid SEQUENCE length", () => {
			const der = new Uint8Array([
				0x30, 0x10, 0x02, 0x01, 0x42, 0x02, 0x01, 0x84,
			]);
			expect(() => Signature.fromDER(der, "secp256k1")).toThrow(
				Signature.InvalidDERError,
			);
		});

		it("should throw on extra data after signature", () => {
			const der = new Uint8Array([
				0x30, 0x06, 0x02, 0x01, 0x42, 0x02, 0x01, 0x84, 0xff,
			]);
			expect(() => Signature.fromDER(der, "secp256k1")).toThrow(
				Signature.InvalidDERError,
			);
		});

		it("should throw when trying to convert Ed25519 to DER", () => {
			const sig = Signature.fromEd25519(new Uint8Array(64).fill(1));
			expect(() => Signature.toDER(sig)).toThrow(
				Signature.InvalidAlgorithmError,
			);
		});

		it("should throw when trying to parse DER as Ed25519", () => {
			const der = new Uint8Array([
				0x30, 0x06, 0x02, 0x01, 0x42, 0x02, 0x01, 0x84,
			]);
			expect(() => Signature.fromDER(der, "ed25519")).toThrow(
				Signature.InvalidDERError,
			);
		});
	});

	describe("EIP-155 chain ID encoding", () => {
		it("should handle pre-EIP-155 v values (27/28)", () => {
			const r = new Uint8Array(32).fill(1);
			const s = new Uint8Array(32).fill(2);
			const sig27 = Signature.fromSecp256k1(r, s, 27);
			const sig28 = Signature.fromSecp256k1(r, s, 28);
			expect(sig27.v).toBe(27);
			expect(sig28.v).toBe(28);
		});

		it("should handle EIP-155 v values with chain ID", () => {
			const r = new Uint8Array(32).fill(1);
			const s = new Uint8Array(32).fill(2);
			// v = chainId * 2 + 35 + yParity
			// For chain ID 1: v = 37 (yParity 0) or 38 (yParity 1)
			const sig37 = Signature.fromSecp256k1(r, s, 37);
			const sig38 = Signature.fromSecp256k1(r, s, 38);
			expect(sig37.v).toBe(37);
			expect(sig38.v).toBe(38);
		});

		it("should handle large chain IDs", () => {
			const r = new Uint8Array(32).fill(1);
			const s = new Uint8Array(32).fill(2);
			// Chain ID 137 (Polygon): v = 137 * 2 + 35 + 0 = 309
			const sig = Signature.fromSecp256k1(r, s, 309);
			expect(sig.v).toBe(309);
		});

		it("should handle recovery ID 0 and 1 (EIP-2098 compact)", () => {
			const r = new Uint8Array(32).fill(1);
			const s = new Uint8Array(32).fill(2);
			const sig0 = Signature.fromSecp256k1(r, s, 0);
			const sig1 = Signature.fromSecp256k1(r, s, 1);
			expect(sig0.v).toBe(0);
			expect(sig1.v).toBe(1);
		});
	});

	describe("malleability and security", () => {
		it("should detect canonical low-s signature", () => {
			const r = new Uint8Array(32).fill(0);
			r[31] = 1;
			// Very low s value (definitely canonical)
			const s = new Uint8Array(32).fill(0);
			s[31] = 1;
			const sig = Signature.fromSecp256k1(r, s);
			expect(Signature.isCanonical(sig)).toBe(true);
		});

		it("should detect non-canonical high-s signature", () => {
			const r = new Uint8Array(32).fill(0);
			r[31] = 1;
			// Very high s value (definitely non-canonical)
			const s = new Uint8Array(32).fill(0xff);
			const sig = Signature.fromSecp256k1(r, s);
			expect(Signature.isCanonical(sig)).toBe(false);
		});

		it("should normalize maintains algorithm", () => {
			const r = new Uint8Array(32).fill(0);
			r[31] = 1;
			const s = new Uint8Array(32).fill(0xff);
			const sig = Signature.fromSecp256k1(r, s, 27);
			const normalized = Signature.normalize(sig);
			expect(normalized.algorithm).toBe("secp256k1");
		});

		it("should not modify already canonical signature", () => {
			const r = new Uint8Array(32).fill(0);
			r[31] = 1;
			const s = new Uint8Array(32).fill(0);
			s[31] = 1;
			const sig = Signature.fromSecp256k1(r, s, 27);
			expect(Signature.isCanonical(sig)).toBe(true);
			const normalized = Signature.normalize(sig);
			expect(normalized).toBe(sig);
		});

		it("should handle P256 canonicalization", () => {
			const r = new Uint8Array(32).fill(0);
			r[31] = 1;
			const s = new Uint8Array(32).fill(0);
			s[31] = 1;
			const sig = Signature.fromP256(r, s);
			expect(Signature.isCanonical(sig)).toBe(true);
		});
	});

	describe("r/s/v bounds and edge cases", () => {
		it("should accept zero-filled r (testing lower bound)", () => {
			const r = new Uint8Array(32).fill(0);
			r[31] = 1; // Minimal non-zero
			const s = new Uint8Array(32).fill(0);
			s[31] = 1;
			const sig = Signature.fromSecp256k1(r, s);
			const rValue = Signature.getR(sig);
			expect(rValue[31]).toBe(1);
		});

		it("should accept max-filled r (testing upper bound)", () => {
			const r = new Uint8Array(32).fill(0xff);
			const s = new Uint8Array(32).fill(0);
			s[31] = 1;
			const sig = Signature.fromSecp256k1(r, s);
			const rValue = Signature.getR(sig);
			expect(rValue[0]).toBe(0xff);
		});

		it("should accept zero-filled s (testing lower bound)", () => {
			const r = new Uint8Array(32).fill(0);
			r[31] = 1;
			const s = new Uint8Array(32).fill(0);
			s[31] = 1; // Minimal non-zero
			const sig = Signature.fromSecp256k1(r, s);
			const sValue = Signature.getS(sig);
			expect(sValue[31]).toBe(1);
		});

		it("should handle all valid v values", () => {
			const r = new Uint8Array(32).fill(1);
			const s = new Uint8Array(32).fill(2);
			const validVValues = [0, 1, 27, 28, 37, 38, 309, 310, 1000];
			for (const v of validVValues) {
				const sig = Signature.fromSecp256k1(r, s, v);
				expect(sig.v).toBe(v);
			}
		});

		it("should handle signature without v", () => {
			const r = new Uint8Array(32).fill(1);
			const s = new Uint8Array(32).fill(2);
			const sig = Signature.fromSecp256k1(r, s);
			expect(sig.v).toBeUndefined();
		});

		it("should preserve v through normalization", () => {
			const r = new Uint8Array(32).fill(0);
			r[31] = 1;
			const s = new Uint8Array(32).fill(0);
			s[31] = 1;
			const sig = Signature.fromSecp256k1(r, s, 37);
			expect(Signature.isCanonical(sig)).toBe(true);
			const normalized = Signature.normalize(sig);
			expect(normalized.v).toBe(37);
		});

		it("should flip EIP-155 v correctly during normalization", () => {
			const r = new Uint8Array(32).fill(0);
			r[31] = 1;
			// High s value (non-canonical but valid): n/2 + 2
			const s = new Uint8Array([
				0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
				0xff, 0xff, 0xff, 0xff, 0x5d, 0x57, 0x6e, 0x73, 0x57, 0xa4, 0x50, 0x1d,
				0xdf, 0xe9, 0x2f, 0x46, 0x68, 0x1b, 0x20, 0xa2,
			]);
			// EIP-155 v for chainId=1, yParity=0: v = 1*2 + 35 + 0 = 37
			const sig = Signature.fromSecp256k1(r, s, 37);
			expect(Signature.isCanonical(sig)).toBe(false);
			const normalized = Signature.normalize(sig);
			expect(Signature.isCanonical(normalized)).toBe(true);
			// After normalization, yParity flips: 37 (yParity=0) -> 38 (yParity=1)
			expect(normalized.v).toBe(38);
		});

		it("should flip EIP-155 v for even v values", () => {
			const r = new Uint8Array(32).fill(0);
			r[31] = 1;
			// High s value (non-canonical but valid)
			const s = new Uint8Array([
				0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
				0xff, 0xff, 0xff, 0xff, 0x5d, 0x57, 0x6e, 0x73, 0x57, 0xa4, 0x50, 0x1d,
				0xdf, 0xe9, 0x2f, 0x46, 0x68, 0x1b, 0x20, 0xa2,
			]);
			// v=38 means yParity=1
			const sig = Signature.fromSecp256k1(r, s, 38);
			const normalized = Signature.normalize(sig);
			// After normalization, yParity flips: 38 (yParity=1) -> 37 (yParity=0)
			expect(normalized.v).toBe(37);
		});

		it("should flip EIP-155 v for large chain IDs", () => {
			const r = new Uint8Array(32).fill(0);
			r[31] = 1;
			// High s value (non-canonical but valid)
			const s = new Uint8Array([
				0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
				0xff, 0xff, 0xff, 0xff, 0x5d, 0x57, 0x6e, 0x73, 0x57, 0xa4, 0x50, 0x1d,
				0xdf, 0xe9, 0x2f, 0x46, 0x68, 0x1b, 0x20, 0xa2,
			]);
			// chainId=137 (Polygon): v = 137*2 + 35 + 0 = 309
			const sig = Signature.fromSecp256k1(r, s, 309);
			const normalized = Signature.normalize(sig);
			// 309 is odd -> 310 (yParity flips)
			expect(normalized.v).toBe(310);
		});

		it("should flip legacy v correctly during normalization", () => {
			const r = new Uint8Array(32).fill(0);
			r[31] = 1;
			// High s value (non-canonical but valid)
			const s = new Uint8Array([
				0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
				0xff, 0xff, 0xff, 0xff, 0x5d, 0x57, 0x6e, 0x73, 0x57, 0xa4, 0x50, 0x1d,
				0xdf, 0xe9, 0x2f, 0x46, 0x68, 0x1b, 0x20, 0xa2,
			]);
			const sig27 = Signature.fromSecp256k1(r, s, 27);
			const sig28 = Signature.fromSecp256k1(r, s, 28);
			const norm27 = Signature.normalize(sig27);
			const norm28 = Signature.normalize(sig28);
			expect(norm27.v).toBe(28);
			expect(norm28.v).toBe(27);
		});
	});

	describe("algorithm-specific behavior", () => {
		it("should throw getR for Ed25519", () => {
			const sig = Signature.fromEd25519(new Uint8Array(64));
			expect(() => Signature.getR(sig)).toThrow(
				Signature.InvalidAlgorithmError,
			);
		});

		it("should throw getS for Ed25519", () => {
			const sig = Signature.fromEd25519(new Uint8Array(64));
			expect(() => Signature.getS(sig)).toThrow(
				Signature.InvalidAlgorithmError,
			);
		});

		it("should throw getV for P256", () => {
			const sig = Signature.fromP256(new Uint8Array(32), new Uint8Array(32));
			expect(() => Signature.getV(sig)).toThrow(
				Signature.InvalidAlgorithmError,
			);
		});

		it("should throw getV for Ed25519", () => {
			const sig = Signature.fromEd25519(new Uint8Array(64));
			expect(() => Signature.getV(sig)).toThrow(
				Signature.InvalidAlgorithmError,
			);
		});

		it("should handle Ed25519 as always canonical", () => {
			const sig = Signature.fromEd25519(new Uint8Array(64).fill(0xff));
			expect(Signature.isCanonical(sig)).toBe(true);
		});
	});

	describe("compact encoding edge cases", () => {
		it("should handle compact without v (64 bytes)", () => {
			const r = new Uint8Array(32).fill(1);
			const s = new Uint8Array(32).fill(2);
			const sig = Signature.fromSecp256k1(r, s);
			const compact = Signature.toCompact(sig);
			expect(compact.length).toBe(64);
			expect(compact.slice(0, 32)).toEqual(r);
			expect(compact.slice(32, 64)).toEqual(s);
		});

		it("should handle compact with v (65 bytes)", () => {
			const r = new Uint8Array(32).fill(1);
			const s = new Uint8Array(32).fill(2);
			const sig = Signature.fromSecp256k1(r, s, 0); // yParity 0
			const compact = Signature.toCompact(sig);
			expect(compact.length).toBe(64); // EIP-2098 format
			// yParity not encoded for yParity=0 (bit 255 clear)
			expect(compact[32] & 0x80).toBe(0x00); // Bit 255 clear for yParity=0
		});

		it("should roundtrip compact encoding without v", () => {
			const r = new Uint8Array(32).fill(3);
			const s = new Uint8Array(32).fill(4);
			const sig = Signature.fromSecp256k1(r, s, 0); // yParity 0
			const compact = Signature.toCompact(sig);
			const sig2 = Signature.fromCompact(compact, "secp256k1");
			expect(Signature.equals(sig, sig2)).toBe(true);
		});

		it("should roundtrip compact encoding with v", () => {
			const r = new Uint8Array(32).fill(5);
			const s = new Uint8Array(32).fill(6);
			const sig = Signature.fromSecp256k1(r, s, 1); // yParity 1
			const compact = Signature.toCompact(sig);
			const sig2 = Signature.fromCompact(compact, "secp256k1");
			expect(Signature.equals(sig, sig2)).toBe(true);
			expect(sig2.v).toBe(1);
		});

		it("should handle P256 compact encoding", () => {
			const r = new Uint8Array(32).fill(7);
			const s = new Uint8Array(32).fill(8);
			const sig = Signature.fromP256(r, s);
			const compact = Signature.toCompact(sig);
			expect(compact.length).toBe(64);
		});

		it("should handle Ed25519 compact encoding", () => {
			const signature = new Uint8Array(64).fill(9);
			const sig = Signature.fromEd25519(signature);
			const compact = Signature.toCompact(sig);
			expect(compact).toEqual(signature);
		});

		it("should throw on invalid compact length", () => {
			const compact = new Uint8Array(63);
			expect(() => Signature.fromCompact(compact, "secp256k1")).toThrow(
				Signature.InvalidSignatureLengthError,
			);
		});
	});

	describe("equality and comparison", () => {
		it("should detect equal signatures", () => {
			const r = new Uint8Array(32).fill(1);
			const s = new Uint8Array(32).fill(2);
			const sig1 = Signature.fromSecp256k1(r, s, 27);
			const sig2 = Signature.fromSecp256k1(r, s, 27);
			expect(Signature.equals(sig1, sig2)).toBe(true);
		});

		it("should detect different r values", () => {
			const r1 = new Uint8Array(32).fill(1);
			const r2 = new Uint8Array(32).fill(3);
			const s = new Uint8Array(32).fill(2);
			const sig1 = Signature.fromSecp256k1(r1, s, 27);
			const sig2 = Signature.fromSecp256k1(r2, s, 27);
			expect(Signature.equals(sig1, sig2)).toBe(false);
		});

		it("should detect different s values", () => {
			const r = new Uint8Array(32).fill(1);
			const s1 = new Uint8Array(32).fill(2);
			const s2 = new Uint8Array(32).fill(4);
			const sig1 = Signature.fromSecp256k1(r, s1, 27);
			const sig2 = Signature.fromSecp256k1(r, s2, 27);
			expect(Signature.equals(sig1, sig2)).toBe(false);
		});

		it("should detect different v values", () => {
			const r = new Uint8Array(32).fill(1);
			const s = new Uint8Array(32).fill(2);
			const sig1 = Signature.fromSecp256k1(r, s, 27);
			const sig2 = Signature.fromSecp256k1(r, s, 28);
			expect(Signature.equals(sig1, sig2)).toBe(false);
		});

		it("should detect different algorithms", () => {
			const r = new Uint8Array(32).fill(1);
			const s = new Uint8Array(32).fill(2);
			const sig1 = Signature.fromSecp256k1(r, s);
			const sig2 = Signature.fromP256(r, s);
			expect(Signature.equals(sig1, sig2)).toBe(false);
		});

		it("should handle equality with undefined v", () => {
			const r = new Uint8Array(32).fill(1);
			const s = new Uint8Array(32).fill(2);
			const sig1 = Signature.fromSecp256k1(r, s);
			const sig2 = Signature.fromSecp256k1(r, s);
			expect(Signature.equals(sig1, sig2)).toBe(true);
		});
	});

	describe("type guards and validation", () => {
		it("should identify BrandedSignature", () => {
			const sig = Signature.fromSecp256k1(
				new Uint8Array(32),
				new Uint8Array(32),
			);
			expect(Signature.is(sig)).toBe(true);
		});

		it("should reject plain Uint8Array", () => {
			expect(Signature.is(new Uint8Array(64))).toBe(false);
		});

		it("should reject null", () => {
			expect(Signature.is(null)).toBe(false);
		});

		it("should reject undefined", () => {
			expect(Signature.is(undefined)).toBe(false);
		});

		it("should reject objects", () => {
			expect(Signature.is({})).toBe(false);
		});

		it("should reject numbers", () => {
			expect(Signature.is(42)).toBe(false);
		});
	});

	describe("secp256k1 canonical boundary tests", () => {
		// secp256k1 curve order n
		const n = new Uint8Array([
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xfe, 0xba, 0xae, 0xdc, 0xe6, 0xaf, 0x48, 0xa0, 0x3b,
			0xbf, 0xd2, 0x5e, 0x8c, 0xd0, 0x36, 0x41, 0x41,
		]);
		// n/2
		const nHalf = new Uint8Array([
			0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0x5d, 0x57, 0x6e, 0x73, 0x57, 0xa4, 0x50, 0x1d,
			0xdf, 0xe9, 0x2f, 0x46, 0x68, 0x1b, 0x20, 0xa0,
		]);

		it("should treat s = n/2 as canonical (boundary)", () => {
			const r = new Uint8Array(32).fill(0);
			r[31] = 1;
			const sig = Signature.fromSecp256k1(r, nHalf, 27);
			expect(Signature.isCanonical(sig)).toBe(true);
		});

		it("should treat s = n/2 + 1 as non-canonical", () => {
			const r = new Uint8Array(32).fill(0);
			r[31] = 1;
			const sHigher = new Uint8Array(nHalf);
			sHigher[31] += 1;
			const sig = Signature.fromSecp256k1(r, sHigher, 27);
			expect(Signature.isCanonical(sig)).toBe(false);
		});

		it("should normalize s = n - 1 (max) to s = 1 (min)", () => {
			const r = new Uint8Array(32).fill(0);
			r[31] = 1;
			// s = n - 1
			const sMax = new Uint8Array(n);
			sMax[31] -= 1;
			const sig = Signature.fromSecp256k1(r, sMax, 27);
			expect(Signature.isCanonical(sig)).toBe(false);
			const normalized = Signature.normalize(sig);
			expect(Signature.isCanonical(normalized)).toBe(true);
			// Verify s = 1
			const s = Signature.getS(normalized);
			expect(s[31]).toBe(1);
			expect(s.slice(0, 31).every((b) => b === 0)).toBe(true);
		});

		it("should handle all zero r (testing zero boundary)", () => {
			const r = new Uint8Array(32).fill(0);
			const s = new Uint8Array(32).fill(0);
			s[31] = 1;
			const sig = Signature.fromSecp256k1(r, s, 27);
			const rValue = Signature.getR(sig);
			expect(rValue.every((b) => b === 0)).toBe(true);
		});

		it("should handle all zero s (testing zero boundary)", () => {
			const r = new Uint8Array(32).fill(0);
			r[31] = 1;
			const s = new Uint8Array(32).fill(0);
			const sig = Signature.fromSecp256k1(r, s, 27);
			const sValue = Signature.getS(sig);
			expect(sValue.every((b) => b === 0)).toBe(true);
		});
	});

	describe("P256 canonical boundary tests", () => {
		// P-256 curve order n
		const p256n = new Uint8Array([
			0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xbc, 0xe6, 0xfa, 0xad, 0xa7, 0x17, 0x9e, 0x84,
			0xf3, 0xb9, 0xca, 0xc2, 0xfc, 0x63, 0x25, 0x51,
		]);
		// n/2 for P-256 (matches isCanonical.js)
		const p256nHalf = new Uint8Array([
			0x7f, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x7f, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xbc, 0xe6, 0xfa, 0xad, 0xa7, 0x17, 0x9e, 0x84,
			0xf3, 0xb9, 0xca, 0xc2, 0xfc, 0x63, 0x25, 0x51,
		]);

		it("should treat P-256 s = n/2 as canonical (boundary)", () => {
			const r = new Uint8Array(32).fill(0);
			r[31] = 1;
			const sig = Signature.fromP256(r, p256nHalf);
			expect(Signature.isCanonical(sig)).toBe(true);
		});

		it("should treat P-256 s = n/2 + 1 as non-canonical", () => {
			const r = new Uint8Array(32).fill(0);
			r[31] = 1;
			const sHigher = new Uint8Array(p256nHalf);
			sHigher[31] += 1;
			const sig = Signature.fromP256(r, sHigher);
			expect(Signature.isCanonical(sig)).toBe(false);
		});

		it("should normalize P-256 high-s signature", () => {
			const r = new Uint8Array(32).fill(0);
			r[31] = 1;
			// Use a clearly high s value (close to full order)
			const sHigh = new Uint8Array(p256n);
			sHigh[31] -= 10; // s = n - 10 (definitely > n/2)
			const sig = Signature.fromP256(r, sHigh);
			expect(Signature.isCanonical(sig)).toBe(false);
			const normalized = Signature.normalize(sig);
			expect(Signature.isCanonical(normalized)).toBe(true);
		});
	});

	describe("DER encoding security tests", () => {
		it("should reject DER with negative r (0x00 prefix missing)", () => {
			const der = new Uint8Array([
				0x30,
				0x06, // SEQUENCE, length 6
				0x02,
				0x01,
				0x80, // INTEGER r = 0x80 (negative without padding)
				0x02,
				0x01,
				0x01, // INTEGER s = 0x01
			]);
			// Should work - implementation handles this
			const sig = Signature.fromDER(der, "secp256k1", 27);
			expect(sig.algorithm).toBe("secp256k1");
		});

		it("should handle DER with minimal r and s", () => {
			const der = new Uint8Array([
				0x30,
				0x06, // SEQUENCE, length 6
				0x02,
				0x01,
				0x01, // INTEGER r = 1
				0x02,
				0x01,
				0x01, // INTEGER s = 1
			]);
			const sig = Signature.fromDER(der, "secp256k1", 27);
			const r = Signature.getR(sig);
			const s = Signature.getS(sig);
			expect(r[31]).toBe(1);
			expect(s[31]).toBe(1);
		});

		it("should handle DER with 32-byte r and s", () => {
			const der = new Uint8Array([
				0x30,
				0x44, // SEQUENCE, length 68
				0x02,
				0x20, // INTEGER r, length 32
				...new Uint8Array(32).fill(0x11),
				0x02,
				0x20, // INTEGER s, length 32
				...new Uint8Array(32).fill(0x22),
			]);
			const sig = Signature.fromDER(der, "secp256k1", 27);
			const r = Signature.getR(sig);
			const s = Signature.getS(sig);
			expect(r.every((b) => b === 0x11)).toBe(true);
			expect(s.every((b) => b === 0x22)).toBe(true);
		});

		it("should reject DER with length overflow", () => {
			const der = new Uint8Array([
				0x30,
				0xff, // SEQUENCE with inflated length
				0x02,
				0x01,
				0x01,
				0x02,
				0x01,
				0x01,
			]);
			expect(() => Signature.fromDER(der, "secp256k1")).toThrow(
				Signature.InvalidDERError,
			);
		});

		it("should reject truncated DER (incomplete r)", () => {
			const der = new Uint8Array([
				0x30,
				0x06, // SEQUENCE claims 6 bytes
				0x02,
				0x02, // INTEGER r claims 2 bytes
				0x01, // But only 1 byte provided
			]);
			expect(() => Signature.fromDER(der, "secp256k1")).toThrow(
				Signature.InvalidDERError,
			);
		});

		it("should reject truncated DER (incomplete s)", () => {
			const der = new Uint8Array([
				0x30,
				0x06, // SEQUENCE claims 6 bytes
				0x02,
				0x01,
				0x01, // INTEGER r complete
				0x02,
				0x01, // INTEGER s claims 1 byte but missing
			]);
			expect(() => Signature.fromDER(der, "secp256k1")).toThrow(
				Signature.InvalidDERError,
			);
		});
	});

	describe("EIP-2098 compact signature encoding", () => {
		it("should encode yParity=0 in compact format (bit 255 clear)", () => {
			const r = new Uint8Array(32).fill(0xaa);
			const s = new Uint8Array(32).fill(0x55);
			const sig = Signature.fromSecp256k1(r, s, 0);
			const compact = Signature.toCompact(sig);
			expect(compact.length).toBe(64);
			expect(compact[32] & 0x80).toBe(0x00); // MSB clear
			expect(compact[32] & 0x7f).toBe(0x55); // Original s value preserved
		});

		it("should encode yParity=1 in compact format (bit 255 set)", () => {
			const r = new Uint8Array(32).fill(0xaa);
			const s = new Uint8Array(32).fill(0x55);
			const sig = Signature.fromSecp256k1(r, s, 1);
			const compact = Signature.toCompact(sig);
			expect(compact.length).toBe(64);
			expect(compact[32] & 0x80).toBe(0x80); // MSB set
			expect(compact[32] & 0x7f).toBe(0x55); // Original s value preserved
		});

		it("should decode yParity=0 from compact format", () => {
			const compact = new Uint8Array(64);
			compact.fill(0xaa, 0, 32); // r
			compact.fill(0x55, 32, 64); // s with MSB clear (yParity=0)
			const sig = Signature.fromCompact(compact, "secp256k1");
			expect(sig.v).toBe(0);
		});

		it("should decode yParity=1 from compact format", () => {
			const compact = new Uint8Array(64);
			compact.fill(0xaa, 0, 32); // r
			compact.fill(0xd5, 32, 64); // s with MSB set (0xd5 = 0x55 | 0x80)
			const sig = Signature.fromCompact(compact, "secp256k1");
			expect(sig.v).toBe(1);
			// Verify s was cleared of bit 255
			const s = Signature.getS(sig);
			expect(s[0]).toBe(0x55); // MSB cleared
		});

		it("should roundtrip EIP-2098 with high bit in original s", () => {
			const r = new Uint8Array(32).fill(0xaa);
			const s = new Uint8Array(32).fill(0x7f); // High bit clear in s
			const sig = Signature.fromSecp256k1(r, s, 1);
			const compact = Signature.toCompact(sig);
			expect(compact[32]).toBe(0xff); // 0x7f | 0x80
			const sig2 = Signature.fromCompact(compact, "secp256k1");
			expect(Signature.equals(sig, sig2)).toBe(true);
		});
	});

	describe("legacy 65-byte compact format", () => {
		it("should parse legacy 65-byte format with v at end", () => {
			const compact = new Uint8Array(65);
			compact.fill(0x11, 0, 32); // r
			compact.fill(0x22, 32, 64); // s
			compact[64] = 27; // v
			const sig = Signature.fromCompact(compact, "secp256k1");
			expect(sig.v).toBe(27);
			expect(Signature.getR(sig).every((b) => b === 0x11)).toBe(true);
			expect(Signature.getS(sig).every((b) => b === 0x22)).toBe(true);
		});

		it("should parse legacy 65-byte format with v=28", () => {
			const compact = new Uint8Array(65);
			compact.fill(0x33, 0, 32); // r
			compact.fill(0x44, 32, 64); // s
			compact[64] = 28; // v
			const sig = Signature.fromCompact(compact, "secp256k1");
			expect(sig.v).toBe(28);
		});

		it("should parse legacy 65-byte format with EIP-155 v", () => {
			const compact = new Uint8Array(65);
			compact.fill(0x55, 0, 32); // r
			compact.fill(0x66, 32, 64); // s
			compact[64] = 37; // v = chainId * 2 + 35 + 0 (chainId=1)
			const sig = Signature.fromCompact(compact, "secp256k1");
			expect(sig.v).toBe(37);
		});
	});

	describe("cross-algorithm comparison", () => {
		it("should not equal signatures with same bytes but different algorithms", () => {
			const r = new Uint8Array(32).fill(1);
			const s = new Uint8Array(32).fill(2);
			const sig1 = Signature.fromSecp256k1(r, s);
			const sig2 = Signature.fromP256(r, s);
			expect(Signature.equals(sig1, sig2)).toBe(false);
		});

		it("should handle Ed25519 vs ECDSA comparison", () => {
			const bytes = new Uint8Array(64).fill(1);
			const sig1 = Signature.fromEd25519(bytes);
			const sig2 = Signature.fromSecp256k1(
				bytes.slice(0, 32),
				bytes.slice(32, 64),
			);
			expect(Signature.equals(sig1, sig2)).toBe(false);
		});
	});

	describe("toBytes consistency", () => {
		it("should return raw signature bytes (without v)", () => {
			const r = new Uint8Array(32).fill(0xaa);
			const s = new Uint8Array(32).fill(0xbb);
			const sig = Signature.fromSecp256k1(r, s, 27);
			const bytes = Signature.toBytes(sig);
			expect(bytes.length).toBe(64);
			expect(bytes.slice(0, 32).every((b) => b === 0xaa)).toBe(true);
			expect(bytes.slice(32, 64).every((b) => b === 0xbb)).toBe(true);
		});

		it("should return Ed25519 signature bytes unchanged", () => {
			const original = new Uint8Array(64).fill(0xcc);
			const sig = Signature.fromEd25519(original);
			const bytes = Signature.toBytes(sig);
			expect(bytes).toEqual(original);
		});

		it("should return P256 signature bytes", () => {
			const r = new Uint8Array(32).fill(0xdd);
			const s = new Uint8Array(32).fill(0xee);
			const sig = Signature.fromP256(r, s);
			const bytes = Signature.toBytes(sig);
			expect(bytes.length).toBe(64);
			expect(bytes.slice(0, 32).every((b) => b === 0xdd)).toBe(true);
			expect(bytes.slice(32, 64).every((b) => b === 0xee)).toBe(true);
		});
	});

	describe("toHex serialization", () => {
		it("should convert secp256k1 signature to hex (without v)", () => {
			const r = new Uint8Array(32).fill(0xaa);
			const s = new Uint8Array(32).fill(0xbb);
			const sig = Signature.fromSecp256k1(r, s);
			const hex = Signature.toHex(sig);
			expect(hex).toMatch(/^0x[0-9a-f]{128}$/);
			expect(hex.slice(2, 66)).toBe("a".repeat(64)); // r
			expect(hex.slice(66, 130)).toBe("b".repeat(64)); // s
		});

		it("should convert secp256k1 signature to hex (with v)", () => {
			const r = new Uint8Array(32).fill(0xaa);
			const s = new Uint8Array(32).fill(0xbb);
			const sig = Signature.fromSecp256k1(r, s, 27);
			const hex = Signature.toHex(sig);
			expect(hex).toMatch(/^0x[0-9a-f]{130}$/);
			expect(hex.slice(2, 66)).toBe("a".repeat(64)); // r
			expect(hex.slice(66, 130)).toBe("b".repeat(64)); // s
			expect(hex.slice(130, 132)).toBe("1b"); // v = 27 = 0x1b
		});

		it("should convert secp256k1 signature to hex (excluding v)", () => {
			const r = new Uint8Array(32).fill(0xaa);
			const s = new Uint8Array(32).fill(0xbb);
			const sig = Signature.fromSecp256k1(r, s, 27);
			const hex = Signature.toHex(sig, false);
			expect(hex).toMatch(/^0x[0-9a-f]{128}$/);
			expect(hex.length).toBe(130); // 0x + 128 chars
		});

		it("should convert Ed25519 signature to hex", () => {
			const signature = new Uint8Array(64).fill(0xcc);
			const sig = Signature.fromEd25519(signature);
			const hex = Signature.toHex(sig);
			expect(hex).toMatch(/^0x[0-9a-f]{128}$/);
			expect(hex).toBe(`0x${"c".repeat(128)}`);
		});

		it("should convert P256 signature to hex", () => {
			const r = new Uint8Array(32).fill(0xdd);
			const s = new Uint8Array(32).fill(0xee);
			const sig = Signature.fromP256(r, s);
			const hex = Signature.toHex(sig);
			expect(hex).toMatch(/^0x[0-9a-f]{128}$/);
			expect(hex.slice(2, 66)).toBe("d".repeat(64)); // r
			expect(hex.slice(66, 130)).toBe("e".repeat(64)); // s
		});

		it("should handle mixed byte values in hex conversion", () => {
			const r = new Uint8Array(32);
			const s = new Uint8Array(32);
			for (let i = 0; i < 32; i++) {
				r[i] = i;
				s[i] = i + 32;
			}
			const sig = Signature.fromSecp256k1(r, s, 28);
			const hex = Signature.toHex(sig);
			expect(hex).toMatch(/^0x[0-9a-f]{130}$/);
			expect(hex.slice(-2)).toBe("1c"); // v = 28 = 0x1c
		});
	});

	describe("fromHex deserialization", () => {
		it("should create signature from hex (64 bytes, no v)", () => {
			const hex = `0x${"1".repeat(64)}${"2".repeat(64)}`;
			const sig = Signature.fromHex(hex);
			expect(sig.algorithm).toBe("secp256k1");
			expect(sig.v).toBe(0); // EIP-2098 yParity extracted from bit 255 (clear)
			const r = Signature.getR(sig);
			const s = Signature.getS(sig);
			expect(r[0]).toBe(0x11);
			expect(s[0]).toBe(0x22);
		});

		it("should create signature from hex (65 bytes, with v)", () => {
			const hex = `0x${"3".repeat(64)}${"4".repeat(64)}1b`;
			const sig = Signature.fromHex(hex);
			expect(sig.algorithm).toBe("secp256k1");
			expect(sig.v).toBe(27);
		});

		it("should create signature from hex without 0x prefix", () => {
			const hex = "5".repeat(64) + "6".repeat(64);
			const sig = Signature.fromHex(hex);
			expect(sig.algorithm).toBe("secp256k1");
		});

		it("should create Ed25519 signature from hex", () => {
			const hex = `0x${"c".repeat(128)}`;
			const sig = Signature.fromHex(hex, "ed25519");
			expect(sig.algorithm).toBe("ed25519");
			expect(sig.length).toBe(64);
		});

		it("should create P256 signature from hex", () => {
			const hex = `0x${"d".repeat(64)}${"e".repeat(64)}`;
			const sig = Signature.fromHex(hex, "p256");
			expect(sig.algorithm).toBe("p256");
		});

		it("should throw on invalid hex length", () => {
			const hex = `0x${"a".repeat(100)}`;
			expect(() => Signature.fromHex(hex)).toThrow(
				Signature.InvalidSignatureLengthError,
			);
		});

		it("should throw on invalid hex characters", () => {
			const hex = `0x${"z".repeat(128)}`;
			expect(() => Signature.fromHex(hex)).toThrow(
				Signature.InvalidSignatureFormatError,
			);
		});

		it("should throw on non-string input", () => {
			// biome-ignore lint/suspicious/noExplicitAny: testing invalid input
			expect(() => Signature.fromHex(123 as any)).toThrow(
				Signature.InvalidSignatureFormatError,
			);
		});

		it("should roundtrip hex serialization (without v)", () => {
			const r = new Uint8Array(32).fill(0x12);
			const s = new Uint8Array(32).fill(0x34);
			const sig1 = Signature.fromSecp256k1(r, s, 0);
			const hex = Signature.toHex(sig1, false);
			const sig2 = Signature.fromHex(hex);
			expect(Signature.equals(sig1, sig2)).toBe(true);
		});

		it("should roundtrip hex serialization (with v)", () => {
			const r = new Uint8Array(32).fill(0x56);
			const s = new Uint8Array(32).fill(0x78);
			const sig1 = Signature.fromSecp256k1(r, s, 27);
			const hex = Signature.toHex(sig1);
			const sig2 = Signature.fromHex(hex);
			expect(Signature.equals(sig1, sig2)).toBe(true);
		});

		it("should roundtrip Ed25519 hex serialization", () => {
			const signature = new Uint8Array(64).fill(0xab);
			const sig1 = Signature.fromEd25519(signature);
			const hex = Signature.toHex(sig1);
			const sig2 = Signature.fromHex(hex, "ed25519");
			expect(Signature.equals(sig1, sig2)).toBe(true);
		});
	});

	describe("fromBytes wrapper", () => {
		it("should create signature from bytes (64 bytes)", () => {
			const bytes = new Uint8Array(64);
			bytes.fill(0x11, 0, 32);
			bytes.fill(0x22, 32, 64);
			const sig = Signature.fromBytes(bytes);
			expect(sig.algorithm).toBe("secp256k1");
			expect(sig.length).toBe(64);
		});

		it("should create signature from bytes (65 bytes with v)", () => {
			const bytes = new Uint8Array(65);
			bytes.fill(0x33, 0, 32);
			bytes.fill(0x44, 32, 64);
			bytes[64] = 27;
			const sig = Signature.fromBytes(bytes);
			expect(sig.algorithm).toBe("secp256k1");
			expect(sig.v).toBe(27);
		});

		it("should create Ed25519 signature from bytes", () => {
			const bytes = new Uint8Array(64).fill(0x55);
			const sig = Signature.fromBytes(bytes, "ed25519");
			expect(sig.algorithm).toBe("ed25519");
		});

		it("should create P256 signature from bytes", () => {
			const bytes = new Uint8Array(64).fill(0x66);
			const sig = Signature.fromBytes(bytes, "p256");
			expect(sig.algorithm).toBe("p256");
		});

		it("should accept explicit v value", () => {
			const bytes = new Uint8Array(64);
			bytes.fill(0x77, 0, 32);
			bytes.fill(0x88, 32, 64);
			const sig = Signature.fromBytes(bytes, 1);
			expect(sig.v).toBe(1);
		});

		it("should roundtrip bytes serialization", () => {
			const r = new Uint8Array(32).fill(0x19);
			const s = new Uint8Array(32).fill(0x2a);
			const sig1 = Signature.fromSecp256k1(r, s, 28);
			const bytes = Signature.toBytes(sig1);
			const sig2 = Signature.fromBytes(bytes);
			// Note: v is lost in toBytes (only returns r+s), so we can't compare v
			expect(Signature.getR(sig2)).toEqual(Signature.getR(sig1));
			expect(Signature.getS(sig2)).toEqual(Signature.getS(sig1));
		});
	});

	describe("serialization format consistency", () => {
		it("should maintain consistency between toBytes and toHex", () => {
			const r = new Uint8Array(32).fill(0xab);
			const s = new Uint8Array(32).fill(0xcd);
			const sig = Signature.fromSecp256k1(r, s);
			const bytes = Signature.toBytes(sig);
			const hex = Signature.toHex(sig, false);
			// Convert bytes to hex manually and compare
			let expectedHex = "0x";
			for (let i = 0; i < bytes.length; i++) {
				expectedHex += bytes[i].toString(16).padStart(2, "0");
			}
			expect(hex).toBe(expectedHex);
		});

		it("should maintain consistency between fromBytes and fromHex", () => {
			const hex = `0x${"12".repeat(32)}${"34".repeat(32)}`;
			const bytes = new Uint8Array(64);
			bytes.fill(0x12, 0, 32);
			bytes.fill(0x34, 32, 64);
			const sig1 = Signature.fromHex(hex);
			const sig2 = Signature.fromBytes(bytes);
			expect(Signature.equals(sig1, sig2)).toBe(true);
		});
	});

	describe("EIP-155 v encoding in hex", () => {
		it("should encode pre-EIP-155 v values (27/28)", () => {
			const r = new Uint8Array(32).fill(1);
			const s = new Uint8Array(32).fill(2);
			const sig27 = Signature.fromSecp256k1(r, s, 27);
			const sig28 = Signature.fromSecp256k1(r, s, 28);
			expect(Signature.toHex(sig27).slice(-2)).toBe("1b"); // 27 = 0x1b
			expect(Signature.toHex(sig28).slice(-2)).toBe("1c"); // 28 = 0x1c
		});

		it("should encode EIP-155 v values", () => {
			const r = new Uint8Array(32).fill(1);
			const s = new Uint8Array(32).fill(2);
			const sig37 = Signature.fromSecp256k1(r, s, 37); // chainId 1
			const sig38 = Signature.fromSecp256k1(r, s, 38);
			expect(Signature.toHex(sig37).slice(-2)).toBe("25"); // 37 = 0x25
			expect(Signature.toHex(sig38).slice(-2)).toBe("26"); // 38 = 0x26
		});

		it("should encode large chain ID v values", () => {
			const r = new Uint8Array(32).fill(1);
			const s = new Uint8Array(32).fill(2);
			const sig309 = Signature.fromSecp256k1(r, s, 309); // chainId 137 (Polygon)
			const hex = Signature.toHex(sig309);
			// v=309 = 0x0135 (padded to even length)
			// v=309 = 0x0135 (padded to even length)
			expect(hex.slice(-4)).toBe("0135"); // 309 = 0x0135
		});

		it("should decode EIP-155 v values from hex", () => {
			// For v > 255, we need 2 bytes. v=309 = 0x0135
			// But fromHex expects 65 bytes (130 hex chars), so v must be 1 byte
			// Let's use a smaller v that fits in 1 byte
			const hex = `0x${"11".repeat(32)}${"22".repeat(32)}fd`; // v=253
			const sig = Signature.fromHex(hex);
			expect(sig.v).toBe(253);
		});
	});

	describe("edge cases and malformed input", () => {
		it("should handle all zeros signature", () => {
			const bytes = new Uint8Array(64);
			const sig = Signature.fromBytes(bytes);
			const hex = Signature.toHex(sig, false);
			expect(hex).toBe(`0x${"0".repeat(128)}`);
		});

		it("should handle all 0xff signature", () => {
			const bytes = new Uint8Array(64).fill(0xff);
			const sig = Signature.fromBytes(bytes);
			const hex = Signature.toHex(sig, false);
			// Note: When fromCompact parses this, it extracts yParity from bit 255 of s
			// and clears that bit, so s[0] becomes 0x7f instead of 0xff
			const expectedHex = `0x${"f".repeat(64)}7${"f".repeat(63)}`;
			expect(hex).toBe(expectedHex);
		});

		it("should reject odd-length hex strings", () => {
			const hex = `0x${"a".repeat(127)}`; // Odd length
			expect(() => Signature.fromHex(hex)).toThrow(
				Signature.InvalidSignatureLengthError,
			);
		});

		it("should handle lowercase and uppercase hex", () => {
			const hexLower = `0x${"ab".repeat(64)}`;
			const hexUpper = `0x${"AB".repeat(64)}`;
			const sig1 = Signature.fromHex(hexLower);
			const sig2 = Signature.fromHex(hexUpper);
			expect(Signature.equals(sig1, sig2)).toBe(true);
		});

		it("should handle mixed case hex", () => {
			const hex = `0x${"aB".repeat(64)}`;
			const sig = Signature.fromHex(hex);
			expect(sig.algorithm).toBe("secp256k1");
		});
	});
});

```
