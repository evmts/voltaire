---
title: '[TS/JS] src/primitives/ContractCode/ContractCode.test.ts'
source: 'src/primitives/ContractCode/ContractCode.test.ts'
---

> Auto-generated from test file: src/primitives/ContractCode/ContractCode.test.ts

```typescript
import { describe, expect, it } from "vitest";
import * as ContractCode from "./index.js";

describe("ContractCode", () => {
	describe("from", () => {
		it("creates from hex string", () => {
			const code = ContractCode.from("0x6001600155");
			expect(code).toBeInstanceOf(Uint8Array);
			expect(code.length).toBe(5);
		});

		it("creates from Uint8Array", () => {
			const bytes = new Uint8Array([0x60, 0x01, 0x60, 0x01, 0x55]);
			const code = ContractCode.from(bytes);
			expect(code).toBeInstanceOf(Uint8Array);
			expect(code.length).toBe(5);
		});
	});

	describe("fromHex", () => {
		it("creates from hex string", () => {
			const code = ContractCode.fromHex("0x6001600155");
			expect(code).toBeInstanceOf(Uint8Array);
			expect(code[0]).toBe(0x60);
			expect(code[1]).toBe(0x01);
		});
	});

	describe("toHex", () => {
		it("converts to hex string", () => {
			const code = ContractCode.from("0x6001600155");
			const hex = ContractCode.toHex(code);
			expect(hex).toBe("0x6001600155");
		});

		it("accepts string input", () => {
			const hex = ContractCode.toHex("0x6001600155");
			expect(hex).toBe("0x6001600155");
		});
	});

	describe("equals", () => {
		it("returns true for equal bytecode", () => {
			const code1 = ContractCode.from("0x6001");
			const code2 = ContractCode.from("0x6001");
			expect(ContractCode.equals(code1, code2)).toBe(true);
		});

		it("returns false for different bytecode", () => {
			const code1 = ContractCode.from("0x6001");
			const code2 = ContractCode.from("0x6002");
			expect(ContractCode.equals(code1, code2)).toBe(false);
		});

		it("returns false for different lengths", () => {
			const code1 = ContractCode.from("0x6001");
			const code2 = ContractCode.from("0x600155");
			expect(ContractCode.equals(code1, code2)).toBe(false);
		});
	});

	describe("hasMetadata", () => {
		it("detects metadata presence", () => {
			// Bytecode with metadata marker: 0x00 0x21 (33 bytes)
			const withMeta = new Uint8Array([
				0x60,
				0x01,
				0x60,
				0x01,
				0x55, // code
				0xa2,
				0x64,
				0x69,
				0x70,
				0x66,
				0x73, // metadata start
				...new Array(27).fill(0x00), // padding
				0x00,
				0x21, // metadata length marker (33 bytes)
			]);
			const code = ContractCode.from(withMeta);
			expect(ContractCode.hasMetadata(code)).toBe(true);
		});

		it("returns false for code without metadata", () => {
			const code = ContractCode.from("0x6001600155");
			expect(ContractCode.hasMetadata(code)).toBe(false);
		});
	});

	describe("stripMetadata", () => {
		it("strips metadata from bytecode", () => {
			// Metadata: 6 bytes + 27 padding = 33 bytes
			// Length marker: 0x00 + 0x21 (33 decimal)
			const withMeta = new Uint8Array([
				0x60,
				0x01,
				0x60,
				0x01,
				0x55, // code (5 bytes)
				0xa2,
				0x64,
				0x69,
				0x70,
				0x66,
				0x73, // metadata start (6 bytes)
				...new Array(27).fill(0x00), // padding
				0x00,
				0x21, // length marker: 33 bytes (0x21 = 33)
			]);
			const code = ContractCode.from(withMeta);
			const runtime = ContractCode.stripMetadata(code);
			expect(runtime.length).toBe(5);
			expect(runtime[0]).toBe(0x60);
		});

		it("returns same bytecode if no metadata", () => {
			const code = ContractCode.from("0x6001600155");
			const result = ContractCode.stripMetadata(code);
			expect(result.length).toBe(code.length);
		});
	});

	describe("extractRuntime", () => {
		it("extracts runtime code (alias for stripMetadata)", () => {
			const withMeta = new Uint8Array([
				0x60,
				0x01,
				0x60,
				0x01,
				0x55, // code (5 bytes)
				0xa2,
				0x64,
				0x69,
				0x70,
				0x66,
				0x73, // metadata (6 bytes)
				...new Array(27).fill(0x00), // padding
				0x00,
				0x21, // length: 33 bytes
			]);
			const code = ContractCode.from(withMeta);
			const runtime = ContractCode.extractRuntime(code);
			expect(runtime.length).toBe(5);
		});
	});
});

```
