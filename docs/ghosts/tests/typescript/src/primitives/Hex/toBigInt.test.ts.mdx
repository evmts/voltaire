---
title: '[TS/JS] src/primitives/Hex/toBigInt.test.ts'
source: 'src/primitives/Hex/toBigInt.test.ts'
---

> Auto-generated from test file: src/primitives/Hex/toBigInt.test.ts

```typescript
import { describe, expect, it } from "vitest";
import { fromBigInt } from "./fromBigInt.js";
import type { HexType } from "./HexType.js";
import { toBigInt } from "./toBigInt.js";

describe("toBigInt", () => {
	describe("signed interpretation", () => {
		it("converts 0xff to -1n when signed", () => {
			expect(toBigInt("0xff" as HexType, { signed: true })).toBe(-1n);
		});

		it("converts 0x80 to -128n when signed (min int8)", () => {
			expect(toBigInt("0x80" as HexType, { signed: true })).toBe(-128n);
		});

		it("converts 0x7f to 127n when signed (max int8)", () => {
			expect(toBigInt("0x7f" as HexType, { signed: true })).toBe(127n);
		});

		it("converts 0xffff to -1n when signed (16-bit)", () => {
			expect(toBigInt("0xffff" as HexType, { signed: true })).toBe(-1n);
		});

		it("converts 0x8000 to -32768n when signed (min int16)", () => {
			expect(toBigInt("0x8000" as HexType, { signed: true })).toBe(-32768n);
		});

		it("converts 0x7fff to 32767n when signed (max int16)", () => {
			expect(toBigInt("0x7fff" as HexType, { signed: true })).toBe(32767n);
		});

		it("converts 0xffffffff to -1n when signed (32-bit)", () => {
			expect(toBigInt("0xffffffff" as HexType, { signed: true })).toBe(-1n);
		});

		it("converts 0x80000000 to -2147483648n when signed (min int32)", () => {
			expect(toBigInt("0x80000000" as HexType, { signed: true })).toBe(
				-2147483648n,
			);
		});

		it("converts 0x7fffffff to 2147483647n when signed (max int32)", () => {
			expect(toBigInt("0x7fffffff" as HexType, { signed: true })).toBe(
				2147483647n,
			);
		});

		it("handles 256-bit signed values", () => {
			// -1n as 256-bit two's complement
			const negOne =
				"0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff" as HexType;
			expect(toBigInt(negOne, { signed: true })).toBe(-1n);
		});

		it("handles positive values correctly when signed", () => {
			expect(toBigInt("0x01" as HexType, { signed: true })).toBe(1n);
			expect(toBigInt("0x0f" as HexType, { signed: true })).toBe(15n);
			expect(toBigInt("0x00ff" as HexType, { signed: true })).toBe(255n);
		});

		it("defaults to unsigned (no options)", () => {
			expect(toBigInt("0xff" as HexType)).toBe(255n);
			expect(toBigInt("0x80" as HexType)).toBe(128n);
		});

		it("defaults to unsigned (signed: false)", () => {
			expect(toBigInt("0xff" as HexType, { signed: false })).toBe(255n);
			expect(toBigInt("0x80" as HexType, { signed: false })).toBe(128n);
		});
	});
	it("converts zero", () => {
		expect(toBigInt("0x0" as HexType)).toBe(0n);
		expect(toBigInt("0x00" as HexType)).toBe(0n);
		expect(toBigInt("0x0000" as HexType)).toBe(0n);
	});

	it("converts small values", () => {
		expect(toBigInt("0x1" as HexType)).toBe(1n);
		expect(toBigInt("0xf" as HexType)).toBe(15n);
		expect(toBigInt("0xff" as HexType)).toBe(255n);
		expect(toBigInt("0x100" as HexType)).toBe(256n);
		expect(toBigInt("0x1234" as HexType)).toBe(0x1234n);
	});

	it("converts large values", () => {
		const large = "0xffffffffffffffffffffffffffffffff" as HexType;
		expect(toBigInt(large)).toBe(0xffffffffffffffffffffffffffffffffn);
	});

	it("converts very large values (u256 max)", () => {
		const max =
			"0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff" as HexType;
		expect(toBigInt(max)).toBe(
			0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffn,
		);
	});

	it("handles leading zeros", () => {
		expect(toBigInt("0x00ff" as HexType)).toBe(255n);
		expect(toBigInt("0x0001" as HexType)).toBe(1n);
		expect(toBigInt("0x00001234" as HexType)).toBe(0x1234n);
	});

	it("handles uppercase hex", () => {
		expect(toBigInt("0xABCD" as HexType)).toBe(0xabcdn);
		expect(toBigInt("0xDEADBEEF" as HexType)).toBe(0xdeadbeefn);
	});

	it("handles mixed case", () => {
		expect(toBigInt("0xAbCd" as HexType)).toBe(0xabcdn);
		expect(toBigInt("0xDeAdBeEf" as HexType)).toBe(0xdeadbeefn);
	});

	it("round-trip conversions", () => {
		const values = [0n, 1n, 255n, 0x1234n, 0xffffffffn, 0xffffffffffffffffn];
		values.forEach((val) => {
			const hex = fromBigInt(val);
			expect(toBigInt(hex)).toBe(val);
		});
	});

	it("converts powers of 2", () => {
		expect(toBigInt("0x1" as HexType)).toBe(1n);
		expect(toBigInt("0x2" as HexType)).toBe(2n);
		expect(toBigInt("0x4" as HexType)).toBe(4n);
		expect(toBigInt("0x100" as HexType)).toBe(256n);
		expect(toBigInt("0x10000" as HexType)).toBe(65536n);
		expect(toBigInt("0x10000000000000000" as HexType)).toBe(2n ** 64n);
		expect(toBigInt("0x100000000000000000000000000000000" as HexType)).toBe(
			2n ** 128n,
		);
	});

	it("handles wei conversions (18 decimals)", () => {
		const oneEther = 1_000_000_000_000_000_000n;
		const hex = fromBigInt(oneEther);
		expect(toBigInt(hex)).toBe(oneEther);
	});

	it("throws on empty hex", () => {
		expect(() => toBigInt("0x" as HexType)).toThrow(SyntaxError);
	});

	it("handles values beyond Number.MAX_SAFE_INTEGER", () => {
		const beyond = "0xffffffffffffffff" as HexType;
		expect(toBigInt(beyond)).toBe(0xffffffffffffffffn);
		expect(toBigInt(beyond)).toBeGreaterThan(BigInt(Number.MAX_SAFE_INTEGER));
	});
});

```
