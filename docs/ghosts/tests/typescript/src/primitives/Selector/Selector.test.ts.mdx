---
title: '[TS/JS] src/primitives/Selector/Selector.test.ts'
source: 'src/primitives/Selector/Selector.test.ts'
---

> Auto-generated from test file: src/primitives/Selector/Selector.test.ts

```typescript
import { describe, expect, it } from "vitest";
import * as Keccak256 from "../../crypto/Keccak256/index.js";
import * as Selector from "./index.js";

describe("Selector", () => {
	const transferSelector = new Uint8Array([0xa9, 0x05, 0x9c, 0xbb]);
	const transferHex = "0xa9059cbb";
	const transferSig = "transfer(address,uint256)";

	describe("from", () => {
		it("creates selector from Uint8Array", () => {
			const sel = Selector.from(transferSelector);
			expect(sel).toEqual(transferSelector);
			expect(sel.length).toBe(4);
		});

		it("creates selector from hex string", () => {
			const sel = Selector.from(transferHex);
			expect(Selector.toHex(sel)).toBe(transferHex);
		});

		it("throws on invalid length", () => {
			expect(() => Selector.from(new Uint8Array([0xa9, 0x05]))).toThrow(
				"Selector must be exactly 4 bytes",
			);
		});
	});

	describe("fromHex", () => {
		it("creates selector from hex with 0x prefix", () => {
			const sel = Selector.fromHex("0xa9059cbb");
			expect(sel).toEqual(transferSelector);
		});

		it("throws on hex without prefix", () => {
			expect(() => Selector.fromHex("a9059cbb")).toThrow("Invalid hex format");
		});

		it("throws on invalid hex length", () => {
			expect(() => Selector.fromHex("0xa9")).toThrow(
				"Selector hex must be exactly 4 bytes",
			);
		});
	});

	describe("fromSignature", () => {
		it("computes transfer(address,uint256) selector", () => {
			const sel = Selector.fromSignature(transferSig);
			expect(Selector.toHex(sel)).toBe("0xa9059cbb");
		});

		it("computes approve(address,uint256) selector", () => {
			const sel = Selector.fromSignature("approve(address,uint256)");
			expect(Selector.toHex(sel)).toBe("0x095ea7b3");
		});

		it("computes balanceOf(address) selector", () => {
			const sel = Selector.fromSignature("balanceOf(address)");
			expect(Selector.toHex(sel)).toBe("0x70a08231");
		});

		it("computes selector with no params", () => {
			const sel = Selector.fromSignature("totalSupply()");
			expect(Selector.toHex(sel)).toBe("0x18160ddd");
		});

		it("computes selector with complex types", () => {
			const sel = Selector.fromSignature("swap(uint256,uint256,address,bytes)");
			expect(Selector.toHex(sel)).toBe("0x022c0d9f");
		});
	});

	describe("toHex", () => {
		it("converts selector to hex string", () => {
			const sel = Selector.from(transferSelector);
			expect(Selector.toHex(sel)).toBe(transferHex);
		});
	});

	describe("equals", () => {
		it("returns true for equal selectors", () => {
			const sel1 = Selector.from(transferSelector);
			const sel2 = Selector.from(transferHex);
			expect(Selector.equals(sel1, sel2)).toBe(true);
		});

		it("returns false for different selectors", () => {
			const sel1 = Selector.fromSignature("transfer(address,uint256)");
			const sel2 = Selector.fromSignature("approve(address,uint256)");
			expect(Selector.equals(sel1, sel2)).toBe(false);
		});
	});

	describe("selector is first 4 bytes of keccak256 hash (issue #122)", () => {
		it("verifies selector equals keccak256(signature)[0:4]", () => {
			const signature = "transfer(address,uint256)";
			const hash = Keccak256.hashString(signature);
			const expectedSelector = hash.slice(0, 4);
			const actualSelector = Selector.fromSignature(signature);

			expect(actualSelector).toEqual(expectedSelector);
			expect(actualSelector.length).toBe(4);
			expect(Selector.toHex(actualSelector)).toBe("0xa9059cbb");
		});

		it("verifies approve selector matches first 4 bytes", () => {
			const signature = "approve(address,uint256)";
			const hash = Keccak256.hashString(signature);
			const expectedSelector = hash.slice(0, 4);
			const actualSelector = Selector.fromSignature(signature);

			expect(actualSelector).toEqual(expectedSelector);
			expect(Selector.toHex(actualSelector)).toBe("0x095ea7b3");
		});

		it("verifies balanceOf selector matches first 4 bytes", () => {
			const signature = "balanceOf(address)";
			const hash = Keccak256.hashString(signature);
			const expectedSelector = hash.slice(0, 4);
			const actualSelector = Selector.fromSignature(signature);

			expect(actualSelector).toEqual(expectedSelector);
			expect(Selector.toHex(actualSelector)).toBe("0x70a08231");
		});

		it("confirms selector is NOT bytes 1-4 (off-by-one would fail)", () => {
			const signature = "transfer(address,uint256)";
			const hash = Keccak256.hashString(signature);
			const wrongSelector = hash.slice(1, 5); // off-by-one error

			const correctSelector = Selector.fromSignature(signature);
			expect(correctSelector).not.toEqual(wrongSelector);
		});
	});
});

```
