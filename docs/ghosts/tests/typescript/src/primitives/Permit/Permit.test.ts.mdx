---
title: '[TS/JS] src/primitives/Permit/Permit.test.ts'
source: 'src/primitives/Permit/Permit.test.ts'
---

> Auto-generated from test file: src/primitives/Permit/Permit.test.ts

```typescript
import { describe, expect, it } from "vitest";
import { Address } from "../Address/index.js";
import * as Uint256 from "../Uint/index.js";
import * as Permit from "./index.js";

describe("Permit", () => {
	// Test private key and owner address
	const privateKey = new Uint8Array(32);
	privateKey[31] = 1; // Simple test key

	const owner = Address.fromHex("0x7E5F4552091A69125d5DfCb7b8C2659029395Bdf");
	const spender = Address.fromHex("0x1234567890123456789012345678901234567890");

	const domain: Permit.PermitDomainType = {
		name: "Test Token",
		version: "1",
		chainId: 1,
		verifyingContract: Address.fromHex(
			"0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48",
		),
	};

	describe("createPermitSignature", () => {
		it("creates valid permit signature", () => {
			const permit: Permit.PermitType = {
				owner,
				spender,
				value: Uint256.fromBigInt(1000000n),
				nonce: Uint256.fromBigInt(0n),
				deadline: Uint256.fromBigInt(
					BigInt(Math.floor(Date.now() / 1000) + 3600),
				),
			};

			const signature = Permit.createPermitSignature(
				permit,
				domain,
				privateKey,
			);

			// Signature is { r, s, v } object
			expect(signature).toHaveProperty("r");
			expect(signature).toHaveProperty("s");
			expect(signature).toHaveProperty("v");
			expect(signature.r).toBeInstanceOf(Uint8Array);
			expect(signature.s).toBeInstanceOf(Uint8Array);
			expect(signature.r.length).toBe(32);
			expect(signature.s.length).toBe(32);
		});

		it("produces different signatures for different values", () => {
			const permit1: Permit.PermitType = {
				owner,
				spender,
				value: Uint256.fromBigInt(1000000n),
				nonce: Uint256.fromBigInt(0n),
				deadline: Uint256.fromBigInt(1234567890n),
			};

			const permit2: Permit.PermitType = {
				owner,
				spender,
				value: Uint256.fromBigInt(2000000n), // Different value
				nonce: Uint256.fromBigInt(0n),
				deadline: Uint256.fromBigInt(1234567890n),
			};

			const sig1 = Permit.createPermitSignature(permit1, domain, privateKey);
			const sig2 = Permit.createPermitSignature(permit2, domain, privateKey);

			expect(sig1).not.toEqual(sig2);
		});

		it("produces different signatures for different nonces", () => {
			const permit1: Permit.PermitType = {
				owner,
				spender,
				value: Uint256.fromBigInt(1000000n),
				nonce: Uint256.fromBigInt(0n),
				deadline: Uint256.fromBigInt(1234567890n),
			};

			const permit2: Permit.PermitType = {
				owner,
				spender,
				value: Uint256.fromBigInt(1000000n),
				nonce: Uint256.fromBigInt(1n), // Different nonce
				deadline: Uint256.fromBigInt(1234567890n),
			};

			const sig1 = Permit.createPermitSignature(permit1, domain, privateKey);
			const sig2 = Permit.createPermitSignature(permit2, domain, privateKey);

			expect(sig1).not.toEqual(sig2);
		});
	});

	describe("verifyPermit", () => {
		it("verifies valid permit signature", () => {
			const permit: Permit.PermitType = {
				owner,
				spender,
				value: Uint256.fromBigInt(1000000n),
				nonce: Uint256.fromBigInt(0n),
				deadline: Uint256.fromBigInt(1234567890n),
			};

			const signature = Permit.createPermitSignature(
				permit,
				domain,
				privateKey,
			);
			const isValid = Permit.verifyPermit(permit, signature, domain);

			expect(isValid).toBe(true);
		});

		it("rejects signature with wrong permit data", () => {
			const permit1: Permit.PermitType = {
				owner,
				spender,
				value: Uint256.fromBigInt(1000000n),
				nonce: Uint256.fromBigInt(0n),
				deadline: Uint256.fromBigInt(1234567890n),
			};

			const permit2: Permit.PermitType = {
				owner,
				spender,
				value: Uint256.fromBigInt(2000000n), // Different value
				nonce: Uint256.fromBigInt(0n),
				deadline: Uint256.fromBigInt(1234567890n),
			};

			const signature = Permit.createPermitSignature(
				permit1,
				domain,
				privateKey,
			);
			const isValid = Permit.verifyPermit(permit2, signature, domain);

			expect(isValid).toBe(false);
		});

		it("rejects signature with wrong domain", () => {
			const permit: Permit.PermitType = {
				owner,
				spender,
				value: Uint256.fromBigInt(1000000n),
				nonce: Uint256.fromBigInt(0n),
				deadline: Uint256.fromBigInt(1234567890n),
			};

			const domain2: Permit.PermitDomainType = {
				name: "Different Token",
				version: "1",
				chainId: 1,
				verifyingContract: Address.fromHex(
					"0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48",
				),
			};

			const signature = Permit.createPermitSignature(
				permit,
				domain,
				privateKey,
			);
			const isValid = Permit.verifyPermit(permit, signature, domain2);

			expect(isValid).toBe(false);
		});
	});

	describe("KnownTokens", () => {
		it("has USDC mainnet domain", () => {
			expect(Permit.KnownTokens.USDC_MAINNET.name).toBe("USD Coin");
			expect(Permit.KnownTokens.USDC_MAINNET.version).toBe("2");
			expect(Permit.KnownTokens.USDC_MAINNET.chainId).toBe(1);
		});

		it("has DAI mainnet domain", () => {
			expect(Permit.KnownTokens.DAI_MAINNET.name).toBe("Dai Stablecoin");
			expect(Permit.KnownTokens.DAI_MAINNET.version).toBe("1");
			expect(Permit.KnownTokens.DAI_MAINNET.chainId).toBe(1);
		});

		it("has UNI mainnet domain", () => {
			expect(Permit.KnownTokens.UNI_MAINNET.name).toBe("Uniswap");
			expect(Permit.KnownTokens.UNI_MAINNET.chainId).toBe(1);
		});

		it("different tokens have different contract addresses", () => {
			const usdcAddr = Permit.KnownTokens.USDC_MAINNET.verifyingContract;
			const daiAddr = Permit.KnownTokens.DAI_MAINNET.verifyingContract;

			expect(Address.equals(usdcAddr, daiAddr)).toBe(false);
		});
	});

	describe("PERMIT_TYPES", () => {
		it("has correct type structure", () => {
			expect(Permit.PERMIT_TYPES.Permit).toHaveLength(5);

			const typeNames = Permit.PERMIT_TYPES.Permit.map((t) => t.name);
			expect(typeNames).toEqual([
				"owner",
				"spender",
				"value",
				"nonce",
				"deadline",
			]);

			const types = Permit.PERMIT_TYPES.Permit.map((t) => t.type);
			expect(types).toEqual([
				"address",
				"address",
				"uint256",
				"uint256",
				"uint256",
			]);
		});
	});
});

```
