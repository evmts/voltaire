---
title: '[TS/JS] src/primitives/Hash/effect.test.ts'
source: 'src/primitives/Hash/effect.test.ts'
---

> Auto-generated from test file: src/primitives/Hash/effect.test.ts

```typescript
import * as Effect from "effect/Effect";
import * as Schema from "effect/Schema";
import { describe, expect, it } from "vitest";
import {
	HashBrand,
	HashFromHex,
	HashFromUnknown,
	HashSchema,
} from "./effect.js";

describe("Hash Effect Schema", () => {
	const zeroHex = `0x${"00".repeat(32)}`;
	const oneBytes = (() => {
		const b = new Uint8Array(32);
		b[31] = 1;
		return b;
	})();

	describe("HashSchema class", () => {
		it("creates HashSchema from hex", () => {
			const h = HashSchema.fromHex(zeroHex);
			expect(h).toBeInstanceOf(HashSchema);
			expect(h.toHex()).toBe(zeroHex);
		});

		it("creates HashSchema from bytes", () => {
			const h = HashSchema.fromBytes(oneBytes);
			expect(h.toHex()).toMatch(/^0x[0-9a-f]{64}$/);
		});

		it("creates HashSchema from universal input", () => {
			const h1 = HashSchema.from(zeroHex);
			const h2 = HashSchema.from(oneBytes);
			expect(h1.equals(h2)).toBe(false);
			expect(h1.isZero()).toBe(true);
			expect(h2.isZero()).toBe(false);
		});

		it("validates HashSchema schema (constructor throws on invalid length)", () => {
			const bad = new Uint8Array(31);
			// biome-ignore lint/suspicious/noExplicitAny: testing invalid input intentionally
			expect(() => new HashSchema({ value: bad as any })).toThrow();
		});

		it("supports conversions and equality", () => {
			const h = HashSchema.fromHex(zeroHex);
			expect(h.toHex()).toBe(zeroHex);
			expect(h.toBytes()).toBeInstanceOf(Uint8Array);
			expect(h.equals(h.clone())).toBe(true);
			expect(h.slice(0, 16)).toBeInstanceOf(Uint8Array);
			expect(h.format()).toMatch(/^0x[0-9a-f]{6}\.\.\.[0-9a-f]{4}$/);
		});
	});

	describe("Effect Branded Types", () => {
		it("creates HashBrand with validation", () => {
			const data = new Uint8Array(32);
			const brand = HashBrand(data);
			expect(brand).toBe(data);
		});

		it("rejects invalid HashBrand", () => {
			const bad = new Uint8Array(31);
			// biome-ignore lint/suspicious/noExplicitAny: testing invalid input intentionally
			expect(() => HashBrand(bad as any)).toThrow();
		});

		it("creates HashSchema from HashBrand", () => {
			const data = new Uint8Array(32);
			const brand = HashBrand(data);
			const schema = HashSchema.fromBranded(brand);
			expect(schema.branded).toBe(brand);
		});

		it("exposes branded getter", () => {
			const h = HashSchema.fromHex(zeroHex);
			const brand = h.branded;
			expect(brand).toBeInstanceOf(Uint8Array);
		});
	});

	describe("Schema transforms", () => {
		it("decodes from hex using HashFromHex", () => {
			const decode = Schema.decodeUnknownSync(HashFromHex);
			const h = decode(zeroHex);
			expect(h).toBeInstanceOf(HashSchema);
			expect(h.toHex()).toBe(zeroHex);
		});

		it("encodes to hex using HashFromHex", () => {
			const encode = Schema.encodeSync(HashFromHex);
			const h = HashSchema.fromHex(zeroHex);
			const out = encode(h);
			expect(out).toBe(zeroHex);
		});

		it("decodes from unknown (string | bytes)", () => {
			const decode = Schema.decodeUnknownSync(HashFromUnknown);
			const h1 = decode(zeroHex);
			const h2 = decode(oneBytes);
			expect(h1).toBeInstanceOf(HashSchema);
			expect(h2).toBeInstanceOf(HashSchema);
		});
	});

	describe("Effect integration", () => {
		it("works with Effect.gen", async () => {
			const program = Effect.gen(function* () {
				const h = yield* Effect.sync(() => HashSchema.fromHex(zeroHex));
				return h.toHex();
			});
			const res = await Effect.runPromise(program);
			expect(res).toBe(zeroHex);
		});

		it("handles validation errors", async () => {
			const program = Effect.try({
				// biome-ignore lint/suspicious/noExplicitAny: testing invalid input
				try: () => new HashSchema({ value: new Uint8Array(31) as any }),
				catch: (e) => new Error(`Failed: ${String(e)}`),
			});
			const result = await Effect.runPromise(Effect.either(program));
			expect(result._tag).toBe("Left");
		});
	});
});

```
