---
title: '[TS/JS] src/primitives/Transaction/Legacy/hash.test.ts'
source: 'src/primitives/Transaction/Legacy/hash.test.ts'
---

> Auto-generated from test file: src/primitives/Transaction/Legacy/hash.test.ts

```typescript
import { keccak256, serializeTransaction } from "viem";
import { describe, expect, it } from "vitest";
import { Address } from "../../Address/index.js";
import * as Hex from "../../Hex/index.js";
import { Type } from "../types.js";
import * as TransactionLegacy from "./index.js";

describe("TransactionLegacy.hash", () => {
	describe("cross-validation with viem", () => {
		it("matches viem for pre-EIP-155 transaction (v=27)", () => {
			const tx = {
				__tag: "TransactionLegacy" as const,
				type: Type.Legacy,
				nonce: 0n,
				gasPrice: 20000000000n,
				gasLimit: 21000n,
				to: Address("0x742d35cc6634c0532925a3b844bc9e7595f0beb0"),
				value: 1000000000000000000n,
				data: new Uint8Array(),
				v: 27n,
				r: new Uint8Array(32).fill(1),
				s: new Uint8Array(32).fill(2),
			};

			// biome-ignore lint/suspicious/noExplicitAny: branded type cast
			const hash = TransactionLegacy.hash.call(tx as any);
			const hashHex = Hex.fromBytes(hash);

			// Expected hash from viem
			expect(hashHex).toBe(
				"0x822ea70c916e490db54858649be030ca9cf5727bf24d0024e6cd424636d98b2b",
			);
		});

		it("matches viem for EIP-155 transaction (v=37, chainId=1)", () => {
			const tx = {
				__tag: "TransactionLegacy" as const,
				type: Type.Legacy,
				nonce: 0n,
				gasPrice: 20000000000n,
				gasLimit: 21000n,
				to: Address("0x742d35cc6634c0532925a3b844bc9e7595f0beb0"),
				value: 1000000000000000000n,
				data: new Uint8Array(),
				v: 37n, // chainId 1: v = 1 * 2 + 35 = 37
				r: new Uint8Array(32).fill(1),
				s: new Uint8Array(32).fill(2),
			};

			// biome-ignore lint/suspicious/noExplicitAny: branded type cast
			const hash = TransactionLegacy.hash.call(tx as any);
			const hashHex = Hex.fromBytes(hash);

			// Expected hash from viem
			expect(hashHex).toBe(
				"0x9354317a6de6e196cbbf1e6b734b647bb4ad2cd373bad3c5129b9674520cdd76",
			);
		});

		it("hash equals keccak256(serialize) matching viem behavior", () => {
			const tx = {
				__tag: "TransactionLegacy" as const,
				type: Type.Legacy,
				nonce: 0n,
				gasPrice: 20000000000n,
				gasLimit: 21000n,
				to: Address("0x742d35cc6634c0532925a3b844bc9e7595f0beb0"),
				value: 1000000000000000000n,
				data: new Uint8Array(),
				v: 27n,
				r: new Uint8Array(32).fill(1),
				s: new Uint8Array(32).fill(2),
			};

			// Compute hash using our implementation
			// biome-ignore lint/suspicious/noExplicitAny: branded type cast
			const hash = TransactionLegacy.hash.call(tx as any);

			// Compute hash using viem for comparison
			const viemTx = {
				type: "legacy" as const,
				nonce: 0n,
				gasPrice: 20000000000n,
				gas: 21000n,
				to: "0x742d35cc6634c0532925a3b844bc9e7595f0beb0" as `0x${string}`,
				value: 1000000000000000000n,
				data: "0x" as const,
			};
			const viemSig = {
				r: "0x0101010101010101010101010101010101010101010101010101010101010101" as `0x${string}`,
				s: "0x0202020202020202020202020202020202020202020202020202020202020202" as `0x${string}`,
				v: 27n,
			};
			const viemSerialized = serializeTransaction(viemTx, viemSig);
			const viemHash = keccak256(viemSerialized);

			expect(Hex.fromBytes(hash)).toBe(viemHash);
		});
	});

	it("computes transaction hash", () => {
		const tx = {
			__tag: "TransactionLegacy" as const,
			type: Type.Legacy,
			nonce: 0n,
			gasPrice: 20000000000n,
			gasLimit: 21000n,
			to: Address("0x742d35cc6634c0532925a3b844bc9e7595f0beb0"),
			value: 1000000000000000000n,
			data: new Uint8Array(),
			v: 27n,
			r: new Uint8Array(32).fill(1),
			s: new Uint8Array(32).fill(2),
		};

		const txHash = TransactionLegacy.hash // biome-ignore lint/suspicious/noExplicitAny: branded type cast
			.call(tx as any);
		expect(txHash).toBeInstanceOf(Uint8Array);
		expect(txHash.length).toBe(32);
	});

	it("produces deterministic hash", () => {
		const tx = {
			__tag: "TransactionLegacy" as const,
			type: Type.Legacy,
			nonce: 5n,
			gasPrice: 25000000000n,
			gasLimit: 50000n,
			to: Address("0x742d35cc6634c0532925a3b844bc9e7595f0beb0"),
			value: 100n,
			data: new Uint8Array([0xa9, 0x05, 0x9c, 0xbb]),
			v: 27n,
			r: new Uint8Array(32).fill(1),
			s: new Uint8Array(32).fill(2),
		};

		const hash1 = TransactionLegacy.hash // biome-ignore lint/suspicious/noExplicitAny: branded type cast
			.call(tx as any);
		const hash2 = TransactionLegacy.hash // biome-ignore lint/suspicious/noExplicitAny: branded type cast
			.call(tx as any);
		expect(hash1).toEqual(hash2);
	});

	it("produces different hash for different transactions", () => {
		const tx1 = {
			__tag: "TransactionLegacy" as const,
			type: Type.Legacy,
			nonce: 0n,
			gasPrice: 20000000000n,
			gasLimit: 21000n,
			to: Address("0x742d35cc6634c0532925a3b844bc9e7595f0beb0"),
			value: 1000000000000000000n,
			data: new Uint8Array(),
			v: 27n,
			r: new Uint8Array(32).fill(1),
			s: new Uint8Array(32).fill(2),
		};

		const tx2 = {
			...tx1,
			nonce: 1n,
		} as const;

		const hash1 = TransactionLegacy.hash // biome-ignore lint/suspicious/noExplicitAny: branded type cast
			.call(tx1 as any);
		const hash2 = TransactionLegacy.hash // biome-ignore lint/suspicious/noExplicitAny: branded type cast
			.call(tx2 as any);
		expect(hash1).not.toEqual(hash2);
	});

	it("hash changes with different signature", () => {
		const base = {
			__tag: "TransactionLegacy" as const,
			type: Type.Legacy,
			nonce: 0n,
			gasPrice: 20000000000n,
			gasLimit: 21000n,
			to: Address("0x742d35cc6634c0532925a3b844bc9e7595f0beb0"),
			value: 0n,
			data: new Uint8Array(),
		};

		const tx1 = {
			...base,
			v: 27n,
			r: new Uint8Array(32).fill(1),
			s: new Uint8Array(32).fill(2),
		} as const;
		const tx2 = {
			...base,
			v: 27n,
			r: new Uint8Array(32).fill(3),
			s: new Uint8Array(32).fill(2),
		} as const;

		const hash1 = TransactionLegacy.hash // biome-ignore lint/suspicious/noExplicitAny: branded type cast
			.call(tx1 as any);
		const hash2 = TransactionLegacy.hash // biome-ignore lint/suspicious/noExplicitAny: branded type cast
			.call(tx2 as any);
		expect(hash1).not.toEqual(hash2);
	});

	it("hash changes with EIP-155 v value", () => {
		const base = {
			__tag: "TransactionLegacy" as const,
			type: Type.Legacy,
			nonce: 0n,
			gasPrice: 20000000000n,
			gasLimit: 21000n,
			to: Address("0x742d35cc6634c0532925a3b844bc9e7595f0beb0"),
			value: 0n,
			data: new Uint8Array(),
			r: new Uint8Array(32).fill(1),
			s: new Uint8Array(32).fill(2),
		};

		const tx1 = { ...base, v: 27n } as const; // pre-EIP-155
		const tx2 = { ...base, v: 37n } as const; // EIP-155 chainId 1

		const hash1 = TransactionLegacy.hash // biome-ignore lint/suspicious/noExplicitAny: branded type cast
			.call(tx1 as any);
		const hash2 = TransactionLegacy.hash // biome-ignore lint/suspicious/noExplicitAny: branded type cast
			.call(tx2 as any);
		expect(hash1).not.toEqual(hash2);
	});

	it("computes hash for contract creation", () => {
		const tx = {
			__tag: "TransactionLegacy" as const,
			type: Type.Legacy,
			nonce: 0n,
			gasPrice: 20000000000n,
			gasLimit: 1000000n,
			to: null,
			value: 0n,
			data: new Uint8Array([0x60, 0x80, 0x60, 0x40]),
			v: 27n,
			r: new Uint8Array(32).fill(1),
			s: new Uint8Array(32).fill(2),
		};

		const txHash = TransactionLegacy.hash // biome-ignore lint/suspicious/noExplicitAny: branded type cast
			.call(tx as any);
		expect(txHash).toBeInstanceOf(Uint8Array);
		expect(txHash.length).toBe(32);
	});

	it("round-trip: serialize -> deserialize -> hash", () => {
		const tx = {
			__tag: "TransactionLegacy" as const,
			type: Type.Legacy,
			nonce: 5n,
			gasPrice: 20000000000n,
			gasLimit: 21000n,
			to: Address("0x742d35cc6634c0532925a3b844bc9e7595f0beb0"),
			value: 1000000000000000000n,
			data: new Uint8Array([0xa9, 0x05, 0x9c, 0xbb]),
			v: 27n,
			r: new Uint8Array(32).fill(1),
			s: new Uint8Array(32).fill(2),
		};

		// biome-ignore lint/suspicious/noExplicitAny: branded type cast
		const hash1 = TransactionLegacy.hash.call(tx as any);
		// biome-ignore lint/suspicious/noExplicitAny: branded type cast
		const serialized = TransactionLegacy.serialize.call(tx as any);
		const deserialized = TransactionLegacy.deserialize(serialized);
		const hash2 = TransactionLegacy.hash.call(deserialized);

		expect(hash1).toEqual(hash2);
	});

	// Test vectors - verify correct encoding for signed transactions
	// Note: hash() = keccak256(serialize()) where serialize includes v,r,s
	// The EIP-155 spec defines the SIGNING hash format, not the transaction hash
	describe("transaction hash encoding", () => {
		it("includes signature in hash (v, r, s are part of serialization)", () => {
			// EIP-155 signed transaction - the tx hash changes with v value
			// v = 37 for chainId 1 (recovery bit 0)
			const tx = {
				__tag: "TransactionLegacy" as const,
				type: Type.Legacy,
				nonce: 9n,
				gasPrice: 20000000000n,
				gasLimit: 21000n,
				to: Address("0x3535353535353535353535353535353535353535"),
				value: 1000000000000000000n,
				data: new Uint8Array(),
				v: 37n,
				r: Hex.toBytes(
					"0x28ef61340bd939bc2195fe537567866003e1a15d3c71ff63e1590620aa636276",
				),
				s: Hex.toBytes(
					"0x67cbe9d8997f761aecb703304b3800ccf555c9f3dc64214b297fb1966a3b6d83",
				),
			};

			const txHash = TransactionLegacy.hash // biome-ignore lint/suspicious/noExplicitAny: branded type cast
				.call(tx as any);

			// Hash is 32 bytes
			expect(txHash.length).toBe(32);

			// Transaction hash is deterministic
			const txHash2 = TransactionLegacy.hash // biome-ignore lint/suspicious/noExplicitAny: branded type cast
				.call(tx as any);
			expect(txHash).toEqual(txHash2);

			// Change r and hash should change (signature is part of the serialization)
			const tx2 = {
				...tx,
				r: Hex.toBytes(
					"0x38ef61340bd939bc2195fe537567866003e1a15d3c71ff63e1590620aa636276",
				),
			};
			const txHash3 = TransactionLegacy.hash // biome-ignore lint/suspicious/noExplicitAny: branded type cast
				.call(tx2 as any);
			expect(txHash).not.toEqual(txHash3);
		});

		it("verifies serialize includes v, r, s (signed tx encoding)", () => {
			// The hash() function uses serialize() which includes v,r,s
			// This is correct - the transaction hash is over the SIGNED tx
			const tx = {
				__tag: "TransactionLegacy" as const,
				type: Type.Legacy,
				nonce: 0n,
				gasPrice: 1n,
				gasLimit: 21000n,
				to: Address("0x0000000000000000000000000000000000000001"),
				value: 0n,
				data: new Uint8Array(),
				v: 27n,
				r: new Uint8Array(32),
				s: new Uint8Array(32),
			};

			// biome-ignore lint/suspicious/noExplicitAny: branded type cast
			const serialized = TransactionLegacy.serialize.call(tx as any);
			// Serialization should be an RLP list with 9 items: [nonce, gasPrice, gasLimit, to, value, data, v, r, s]
			// The first byte should be in RLP list prefix range
			expect(serialized[0]).toBeGreaterThanOrEqual(0xc0);
		});

		it("pre-EIP-155 tx has different hash than EIP-155 tx with same fields", () => {
			const base = {
				__tag: "TransactionLegacy" as const,
				type: Type.Legacy,
				nonce: 0n,
				gasPrice: 20000000000n,
				gasLimit: 21000n,
				to: Address("0x3535353535353535353535353535353535353535"),
				value: 1000000000000000000n,
				data: new Uint8Array(),
				r: Hex.toBytes(
					"0x28ef61340bd939bc2195fe537567866003e1a15d3c71ff63e1590620aa636276",
				),
				s: Hex.toBytes(
					"0x67cbe9d8997f761aecb703304b3800ccf555c9f3dc64214b297fb1966a3b6d83",
				),
			};

			// Pre-EIP-155: v = 27 or 28
			const preEip155Tx = { ...base, v: 27n } as const;
			// EIP-155 chainId 1: v = 37 or 38
			const eip155Tx = { ...base, v: 37n } as const;

			const hash1 = TransactionLegacy.hash // biome-ignore lint/suspicious/noExplicitAny: branded type cast
				.call(preEip155Tx as any);
			const hash2 = TransactionLegacy.hash // biome-ignore lint/suspicious/noExplicitAny: branded type cast
				.call(eip155Tx as any);

			// Hashes should differ because v is part of the serialization
			expect(hash1).not.toEqual(hash2);
		});
	});
});

```
