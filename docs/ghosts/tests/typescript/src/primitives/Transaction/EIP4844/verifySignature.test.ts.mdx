---
title: '[TS/JS] src/primitives/Transaction/EIP4844/verifySignature.test.ts'
source: 'src/primitives/Transaction/EIP4844/verifySignature.test.ts'
---

> Auto-generated from test file: src/primitives/Transaction/EIP4844/verifySignature.test.ts

```typescript
import { describe, expect, it } from "vitest";
import * as Secp256k1 from "../../../crypto/Secp256k1/index.js";
import { PrivateKey } from "../../../crypto/Secp256k1/index.js";
import { Address } from "../../Address/index.js";
import { Type } from "../types.js";
import type { TransactionEIP4844Type } from "./TransactionEIP4844Type.js";
import * as TransactionEIP4844 from "./index.js";

describe("TransactionEIP4844.verifySignature", () => {
	it("returns true for valid signature (yParity 0)", () => {
		const privateKey = PrivateKey.from(
			"0x0123456789012345678901234567890123456789012345678901234567890123",
		);

		const unsignedTx: TransactionEIP4844Type = {
			__brand: "TransactionEIP4844",
			type: Type.EIP4844,
			chainId: 1n,
			nonce: 0n,
			maxPriorityFeePerGas: 1000000000n,
			maxFeePerGas: 20000000000n,
			gasLimit: 21000n,
			to: Address("0x742d35cc6634c0532925a3b844bc9e7595f0beb0"),
			value: 1000000000000000000n,
			data: new Uint8Array(),
			accessList: [],
			maxFeePerBlobGas: 1000000000n,
			blobVersionedHashes: [new Uint8Array(32).fill(1)],
			yParity: 0,
			r: new Uint8Array(32),
			s: new Uint8Array(32),
		};

		const signingHash = TransactionEIP4844.getSigningHash(unsignedTx);
		const signature = Secp256k1.sign(signingHash, privateKey);

		const signedTx: TransactionEIP4844Type = {
			...unsignedTx,
			yParity: signature.v - 27,
			r: signature.r,
			s: signature.s,
		};

		expect(TransactionEIP4844.verifySignature(signedTx)).toBe(true);
	});

	it("returns true for valid signature (yParity 1)", () => {
		const privateKey = PrivateKey.from(
			"0xfedcba9876543210fedcba9876543210fedcba9876543210fedcba9876543210",
		);

		const unsignedTx: TransactionEIP4844Type = {
			__brand: "TransactionEIP4844",
			type: Type.EIP4844,
			chainId: 1n,
			nonce: 5n,
			maxPriorityFeePerGas: 2000000000n,
			maxFeePerGas: 30000000000n,
			gasLimit: 50000n,
			to: Address("0x1234567890123456789012345678901234567890"),
			value: 5000000000000000000n,
			data: new Uint8Array([0xa9, 0x05, 0x9c, 0xbb]),
			accessList: [],
			maxFeePerBlobGas: 2000000000n,
			blobVersionedHashes: [new Uint8Array(32).fill(2)],
			yParity: 1,
			r: new Uint8Array(32),
			s: new Uint8Array(32),
		};

		const signingHash = TransactionEIP4844.getSigningHash(unsignedTx);
		const signature = Secp256k1.sign(signingHash, privateKey);

		const signedTx: TransactionEIP4844Type = {
			...unsignedTx,
			yParity: signature.v - 27,
			r: signature.r,
			s: signature.s,
		};

		expect(TransactionEIP4844.verifySignature(signedTx)).toBe(true);
	});

	it("returns true for signature with multiple blob hashes", () => {
		const privateKey = PrivateKey.from(
			"0x0123456789012345678901234567890123456789012345678901234567890123",
		);

		const unsignedTx: TransactionEIP4844Type = {
			__brand: "TransactionEIP4844",
			type: Type.EIP4844,
			chainId: 1n,
			nonce: 0n,
			maxPriorityFeePerGas: 1000000000n,
			maxFeePerGas: 20000000000n,
			gasLimit: 100000n,
			to: Address("0x742d35cc6634c0532925a3b844bc9e7595f0beb0"),
			value: 0n,
			data: new Uint8Array(),
			accessList: [],
			maxFeePerBlobGas: 1000000000n,
			blobVersionedHashes: [
				new Uint8Array(32).fill(1),
				new Uint8Array(32).fill(2),
				new Uint8Array(32).fill(3),
			],
			yParity: 0,
			r: new Uint8Array(32),
			s: new Uint8Array(32),
		};

		const signingHash = TransactionEIP4844.getSigningHash(unsignedTx);
		const signature = Secp256k1.sign(signingHash, privateKey);

		const signedTx: TransactionEIP4844Type = {
			...unsignedTx,
			yParity: signature.v - 27,
			r: signature.r,
			s: signature.s,
		};

		expect(TransactionEIP4844.verifySignature(signedTx)).toBe(true);
	});

	it("returns true for signature with access list", () => {
		const privateKey = PrivateKey.from(
			"0x0123456789012345678901234567890123456789012345678901234567890123",
		);

		const unsignedTx: TransactionEIP4844Type = {
			__brand: "TransactionEIP4844",
			type: Type.EIP4844,
			chainId: 1n,
			nonce: 0n,
			maxPriorityFeePerGas: 1000000000n,
			maxFeePerGas: 20000000000n,
			gasLimit: 100000n,
			to: Address("0x742d35cc6634c0532925a3b844bc9e7595f0beb0"),
			value: 0n,
			data: new Uint8Array(),
			accessList: [
				{
					address: Address("0x1234567890123456789012345678901234567890"),
					storageKeys: [new Uint8Array(32).fill(1), new Uint8Array(32).fill(2)],
				},
			],
			maxFeePerBlobGas: 1000000000n,
			blobVersionedHashes: [new Uint8Array(32).fill(1)],
			yParity: 0,
			r: new Uint8Array(32),
			s: new Uint8Array(32),
		};

		const signingHash = TransactionEIP4844.getSigningHash(unsignedTx);
		const signature = Secp256k1.sign(signingHash, privateKey);

		const signedTx: TransactionEIP4844Type = {
			...unsignedTx,
			yParity: signature.v - 27,
			r: signature.r,
			s: signature.s,
		};

		expect(TransactionEIP4844.verifySignature(signedTx)).toBe(true);
	});

	it("returns true for different chainId", () => {
		const privateKey = PrivateKey.from(
			"0x0123456789012345678901234567890123456789012345678901234567890123",
		);

		const unsignedTx: TransactionEIP4844Type = {
			__brand: "TransactionEIP4844",
			type: Type.EIP4844,
			chainId: 137n,
			nonce: 10n,
			maxPriorityFeePerGas: 30000000000n,
			maxFeePerGas: 100000000000n,
			gasLimit: 21000n,
			to: Address("0x742d35cc6634c0532925a3b844bc9e7595f0beb0"),
			value: 1000000000000000000n,
			data: new Uint8Array(),
			accessList: [],
			maxFeePerBlobGas: 3000000000n,
			blobVersionedHashes: [new Uint8Array(32).fill(1)],
			yParity: 0,
			r: new Uint8Array(32),
			s: new Uint8Array(32),
		};

		const signingHash = TransactionEIP4844.getSigningHash(unsignedTx);
		const signature = Secp256k1.sign(signingHash, privateKey);

		const signedTx: TransactionEIP4844Type = {
			...unsignedTx,
			yParity: signature.v - 27,
			r: signature.r,
			s: signature.s,
		};

		expect(TransactionEIP4844.verifySignature(signedTx)).toBe(true);
	});

	it("returns false for invalid signature", () => {
		const tx: TransactionEIP4844Type = {
			__brand: "TransactionEIP4844",
			type: Type.EIP4844,
			chainId: 1n,
			nonce: 0n,
			maxPriorityFeePerGas: 1000000000n,
			maxFeePerGas: 20000000000n,
			gasLimit: 21000n,
			to: Address("0x742d35cc6634c0532925a3b844bc9e7595f0beb0"),
			value: 1000000000000000000n,
			data: new Uint8Array(),
			accessList: [],
			maxFeePerBlobGas: 1000000000n,
			blobVersionedHashes: [new Uint8Array(32).fill(1)],
			yParity: 0,
			r: new Uint8Array(32),
			s: new Uint8Array(32),
		};

		expect(TransactionEIP4844.verifySignature(tx)).toBe(false);
	});

	it("detects tampered nonce via sender mismatch", () => {
		const privateKey = PrivateKey.from(
			"0x0123456789012345678901234567890123456789012345678901234567890123",
		);

		const unsignedTx: TransactionEIP4844Type = {
			__brand: "TransactionEIP4844",
			type: Type.EIP4844,
			chainId: 1n,
			nonce: 0n,
			maxPriorityFeePerGas: 1000000000n,
			maxFeePerGas: 20000000000n,
			gasLimit: 21000n,
			to: Address("0x742d35cc6634c0532925a3b844bc9e7595f0beb0"),
			value: 1000000000000000000n,
			data: new Uint8Array(),
			accessList: [],
			maxFeePerBlobGas: 1000000000n,
			blobVersionedHashes: [new Uint8Array(32).fill(1)],
			yParity: 0,
			r: new Uint8Array(32),
			s: new Uint8Array(32),
		};

		const signingHash = TransactionEIP4844.getSigningHash(unsignedTx);
		const signature = Secp256k1.sign(signingHash, privateKey);

		const signedTx: TransactionEIP4844Type = {
			...unsignedTx,
			yParity: signature.v - 27,
			r: signature.r,
			s: signature.s,
		};
		const expectedSender = TransactionEIP4844.getSender(signedTx);

		const tamperedTx: TransactionEIP4844Type = {
			...signedTx,
			nonce: 1n,
		};

		// Signature is still cryptographically valid
		expect(TransactionEIP4844.verifySignature(tamperedTx)).toBe(true);
		// But sender is different due to tampering
		const recoveredSender = TransactionEIP4844.getSender(tamperedTx);
		expect(Address.equals(recoveredSender, expectedSender)).toBe(false);
	});

	it("detects tampered value via sender mismatch", () => {
		const privateKey = PrivateKey.from(
			"0x0123456789012345678901234567890123456789012345678901234567890123",
		);

		const unsignedTx: TransactionEIP4844Type = {
			__brand: "TransactionEIP4844",
			type: Type.EIP4844,
			chainId: 1n,
			nonce: 0n,
			maxPriorityFeePerGas: 1000000000n,
			maxFeePerGas: 20000000000n,
			gasLimit: 21000n,
			to: Address("0x742d35cc6634c0532925a3b844bc9e7595f0beb0"),
			value: 1000000000000000000n,
			data: new Uint8Array(),
			accessList: [],
			maxFeePerBlobGas: 1000000000n,
			blobVersionedHashes: [new Uint8Array(32).fill(1)],
			yParity: 0,
			r: new Uint8Array(32),
			s: new Uint8Array(32),
		};

		const signingHash = TransactionEIP4844.getSigningHash(unsignedTx);
		const signature = Secp256k1.sign(signingHash, privateKey);

		const signedTx: TransactionEIP4844Type = {
			...unsignedTx,
			yParity: signature.v - 27,
			r: signature.r,
			s: signature.s,
		};
		const expectedSender = TransactionEIP4844.getSender(signedTx);

		const tamperedTx: TransactionEIP4844Type = {
			...signedTx,
			value: 2000000000000000000n,
		};

		// Signature is still cryptographically valid
		expect(TransactionEIP4844.verifySignature(tamperedTx)).toBe(true);
		// But sender is different due to tampering
		const recoveredSender = TransactionEIP4844.getSender(tamperedTx);
		expect(Address.equals(recoveredSender, expectedSender)).toBe(false);
	});

	it("detects wrong chainId via sender mismatch", () => {
		const privateKey = PrivateKey.from(
			"0x0123456789012345678901234567890123456789012345678901234567890123",
		);

		const unsignedTx: TransactionEIP4844Type = {
			__brand: "TransactionEIP4844",
			type: Type.EIP4844,
			chainId: 1n,
			nonce: 0n,
			maxPriorityFeePerGas: 1000000000n,
			maxFeePerGas: 20000000000n,
			gasLimit: 21000n,
			to: Address("0x742d35cc6634c0532925a3b844bc9e7595f0beb0"),
			value: 1000000000000000000n,
			data: new Uint8Array(),
			accessList: [],
			maxFeePerBlobGas: 1000000000n,
			blobVersionedHashes: [new Uint8Array(32).fill(1)],
			yParity: 0,
			r: new Uint8Array(32),
			s: new Uint8Array(32),
		};

		const signingHash = TransactionEIP4844.getSigningHash(unsignedTx);
		const signature = Secp256k1.sign(signingHash, privateKey);

		const signedTx: TransactionEIP4844Type = {
			...unsignedTx,
			yParity: signature.v - 27,
			r: signature.r,
			s: signature.s,
		};
		const expectedSender = TransactionEIP4844.getSender(signedTx);

		const tamperedTx: TransactionEIP4844Type = {
			...signedTx,
			chainId: 5n,
		};

		// Signature is still cryptographically valid
		expect(TransactionEIP4844.verifySignature(tamperedTx)).toBe(true);
		// But sender is different due to tampering
		const recoveredSender = TransactionEIP4844.getSender(tamperedTx);
		expect(Address.equals(recoveredSender, expectedSender)).toBe(false);
	});

	it("returns false for malformed r value", () => {
		const tx: TransactionEIP4844Type = {
			__brand: "TransactionEIP4844",
			type: Type.EIP4844,
			chainId: 1n,
			nonce: 0n,
			maxPriorityFeePerGas: 1000000000n,
			maxFeePerGas: 20000000000n,
			gasLimit: 21000n,
			to: Address("0x742d35cc6634c0532925a3b844bc9e7595f0beb0"),
			value: 1000000000000000000n,
			data: new Uint8Array(),
			accessList: [],
			maxFeePerBlobGas: 1000000000n,
			blobVersionedHashes: [new Uint8Array(32).fill(1)],
			yParity: 0,
			r: new Uint8Array(32),
			s: new Uint8Array(32).fill(1),
		};

		expect(TransactionEIP4844.verifySignature(tx)).toBe(false);
	});

	it("returns false for malformed s value", () => {
		const tx: TransactionEIP4844Type = {
			__brand: "TransactionEIP4844",
			type: Type.EIP4844,
			chainId: 1n,
			nonce: 0n,
			maxPriorityFeePerGas: 1000000000n,
			maxFeePerGas: 20000000000n,
			gasLimit: 21000n,
			to: Address("0x742d35cc6634c0532925a3b844bc9e7595f0beb0"),
			value: 1000000000000000000n,
			data: new Uint8Array(),
			accessList: [],
			maxFeePerBlobGas: 1000000000n,
			blobVersionedHashes: [new Uint8Array(32).fill(1)],
			yParity: 0,
			r: new Uint8Array(32).fill(1),
			s: new Uint8Array(32),
		};

		expect(TransactionEIP4844.verifySignature(tx)).toBe(false);
	});

	it("detects tampered blob hashes via sender mismatch", () => {
		const privateKey = PrivateKey.from(
			"0x0123456789012345678901234567890123456789012345678901234567890123",
		);

		const unsignedTx: TransactionEIP4844Type = {
			__brand: "TransactionEIP4844",
			type: Type.EIP4844,
			chainId: 1n,
			nonce: 0n,
			maxPriorityFeePerGas: 1000000000n,
			maxFeePerGas: 20000000000n,
			gasLimit: 21000n,
			to: Address("0x742d35cc6634c0532925a3b844bc9e7595f0beb0"),
			value: 1000000000000000000n,
			data: new Uint8Array(),
			accessList: [],
			maxFeePerBlobGas: 1000000000n,
			blobVersionedHashes: [new Uint8Array(32).fill(1)],
			yParity: 0,
			r: new Uint8Array(32),
			s: new Uint8Array(32),
		};

		const signingHash = TransactionEIP4844.getSigningHash(unsignedTx);
		const signature = Secp256k1.sign(signingHash, privateKey);

		const signedTx: TransactionEIP4844Type = {
			...unsignedTx,
			yParity: signature.v - 27,
			r: signature.r,
			s: signature.s,
		};
		const expectedSender = TransactionEIP4844.getSender(signedTx);

		const tamperedTx: TransactionEIP4844Type = {
			...signedTx,
			blobVersionedHashes: [new Uint8Array(32).fill(2)],
		};

		// Signature is still cryptographically valid
		expect(TransactionEIP4844.verifySignature(tamperedTx)).toBe(true);
		// But sender is different due to tampering
		const recoveredSender = TransactionEIP4844.getSender(tamperedTx);
		expect(Address.equals(recoveredSender, expectedSender)).toBe(false);
	});

	it("detects tampered maxFeePerBlobGas via sender mismatch", () => {
		const privateKey = PrivateKey.from(
			"0x0123456789012345678901234567890123456789012345678901234567890123",
		);

		const unsignedTx: TransactionEIP4844Type = {
			__brand: "TransactionEIP4844",
			type: Type.EIP4844,
			chainId: 1n,
			nonce: 0n,
			maxPriorityFeePerGas: 1000000000n,
			maxFeePerGas: 20000000000n,
			gasLimit: 21000n,
			to: Address("0x742d35cc6634c0532925a3b844bc9e7595f0beb0"),
			value: 1000000000000000000n,
			data: new Uint8Array(),
			accessList: [],
			maxFeePerBlobGas: 1000000000n,
			blobVersionedHashes: [new Uint8Array(32).fill(1)],
			yParity: 0,
			r: new Uint8Array(32),
			s: new Uint8Array(32),
		};

		const signingHash = TransactionEIP4844.getSigningHash(unsignedTx);
		const signature = Secp256k1.sign(signingHash, privateKey);

		const signedTx: TransactionEIP4844Type = {
			...unsignedTx,
			yParity: signature.v - 27,
			r: signature.r,
			s: signature.s,
		};
		const expectedSender = TransactionEIP4844.getSender(signedTx);

		const tamperedTx: TransactionEIP4844Type = {
			...signedTx,
			maxFeePerBlobGas: 2000000000n,
		};

		// Signature is still cryptographically valid
		expect(TransactionEIP4844.verifySignature(tamperedTx)).toBe(true);
		// But sender is different due to tampering
		const recoveredSender = TransactionEIP4844.getSender(tamperedTx);
		expect(Address.equals(recoveredSender, expectedSender)).toBe(false);
	});
});

```
