---
title: '[TS/JS] src/primitives/Abi/decodeFunction.test.ts'
source: 'src/primitives/Abi/decodeFunction.test.ts'
---

> Auto-generated from test file: src/primitives/Abi/decodeFunction.test.ts

```typescript
/**
 * Unit tests for decodeFunction
 */

import { describe, expect, it } from "vitest";
import type { BrandedAddress as Address } from "../Address/AddressType.js";
import type { Abi as AbiType } from "./Abi.js";
import { AbiInvalidSelectorError, AbiItemNotFoundError } from "./Errors.js";
import { decodeFunction } from "./decodeFunction.js";
import * as Abi from "./index.js";

const mockAbi = [
	{
		type: "function",
		name: "transfer",
		stateMutability: "nonpayable",
		inputs: [
			{ type: "address", name: "to" },
			{ type: "uint256", name: "amount" },
		],
		outputs: [{ type: "bool", name: "" }],
	},
	{
		type: "function",
		name: "balanceOf",
		stateMutability: "view",
		inputs: [{ type: "address", name: "account" }],
		outputs: [{ type: "uint256", name: "" }],
	},
	{
		type: "function",
		name: "approve",
		stateMutability: "nonpayable",
		inputs: [
			{ type: "address", name: "spender" },
			{ type: "uint256", name: "amount" },
		],
		outputs: [{ type: "bool", name: "" }],
	},
] as const satisfies Abi;

describe("decodeFunction", () => {
	it("decodes transfer function call", () => {
		const to = "0x742d35cc6634c0532925a3b844bc9e7595f251e3" as Address;
		const amount = 1000n;

		// Encode
		const encoded = Abi.Function.encodeParams(mockAbi[0], [to, amount]);

		// Decode
		const decoded = decodeFunction(mockAbi, encoded);

		expect(decoded.name).toBe("transfer");
		expect(decoded.params).toHaveLength(2);
		expect(String(decoded.params[0]).toLowerCase()).toBe(to.toLowerCase());
		expect(decoded.params[1]).toBe(amount);
	});

	it("decodes balanceOf function call", () => {
		const account = "0x742d35cc6634c0532925a3b844bc9e7595f251e3" as Address;

		// Encode
		const encoded = Abi.Function.encodeParams(mockAbi[1], [account]);

		// Decode
		const decoded = decodeFunction(mockAbi, encoded);

		expect(decoded.name).toBe("balanceOf");
		expect(decoded.params).toHaveLength(1);
		expect(String(decoded.params[0]).toLowerCase()).toBe(account.toLowerCase());
	});

	it("decodes hex string calldata", () => {
		const to = "0x742d35cc6634c0532925a3b844bc9e7595f251e3" as Address;
		const amount = 1000n;

		// Encode and convert to hex
		const encoded = Abi.Function.encodeParams(mockAbi[0], [to, amount]);
		const hexData = `0x${Array.from(encoded)
			.map((b) => b.toString(16).padStart(2, "0"))
			.join("")}`;

		// Decode from hex string
		// biome-ignore lint/suspicious/noExplicitAny: Testing hex string input coercion
		const decoded = decodeFunction(mockAbi, hexData as any);

		expect(decoded.name).toBe("transfer");
		expect(decoded.params).toHaveLength(2);
	});

	it("decodes Uint8Array calldata", () => {
		const account = "0x742d35cc6634c0532925a3b844bc9e7595f251e3" as Address;

		// Encode
		const encoded = Abi.Function.encodeParams(mockAbi[1], [account]);

		// Decode from Uint8Array
		const decoded = decodeFunction(mockAbi, encoded);

		expect(decoded.name).toBe("balanceOf");
		expect(decoded.params).toHaveLength(1);
	});

	it("throws on data too short for selector", () => {
		const shortData = new Uint8Array([0xa9, 0x05, 0x9c]); // Only 3 bytes

		expect(() => decodeFunction(mockAbi, shortData)).toThrow(
			AbiInvalidSelectorError,
		);
		expect(() => decodeFunction(mockAbi, shortData)).toThrow(
			/too short to contain selector/,
		);
	});

	it("throws on empty data", () => {
		const emptyData = new Uint8Array([]);

		expect(() => decodeFunction(mockAbi, emptyData)).toThrow(
			AbiInvalidSelectorError,
		);
	});

	it("throws on unknown function selector", () => {
		// Create data with unknown selector
		const unknownData = new Uint8Array(68); // 4 bytes selector + 64 bytes params
		unknownData[0] = 0x12;
		unknownData[1] = 0x34;
		unknownData[2] = 0x56;
		unknownData[3] = 0x78;

		expect(() => decodeFunction(mockAbi, unknownData)).toThrow(
			AbiItemNotFoundError,
		);
		expect(() => decodeFunction(mockAbi, unknownData)).toThrow(
			/not found in ABI/,
		);
	});

	it("throws on empty ABI", () => {
		const emptyAbi: Abi = [];
		const encoded = Abi.Function.encodeParams(mockAbi[0], [
			"0x742d35cc6634c0532925a3b844bc9e7595f251e3" as Address,
			1000n,
		]);

		expect(() => decodeFunction(emptyAbi, encoded)).toThrow(
			AbiItemNotFoundError,
		);
	});

	it("handles function with no inputs", () => {
		const noInputAbi = [
			{
				type: "function",
				name: "totalSupply",
				stateMutability: "view",
				inputs: [],
				outputs: [{ type: "uint256", name: "" }],
			},
		] as const satisfies Abi;

		const encoded = Abi.Function.encodeParams(noInputAbi[0], []);
		const decoded = decodeFunction(noInputAbi, encoded);

		expect(decoded.name).toBe("totalSupply");
		expect(decoded.params).toHaveLength(0);
	});

	it("handles function with multiple parameters", () => {
		const multiParamAbi = [
			{
				type: "function",
				name: "swap",
				stateMutability: "nonpayable",
				inputs: [
					{ type: "address", name: "tokenIn" },
					{ type: "address", name: "tokenOut" },
					{ type: "uint256", name: "amountIn" },
					{ type: "uint256", name: "amountOutMin" },
				],
				outputs: [{ type: "uint256", name: "" }],
			},
		] as const satisfies Abi;

		const tokenIn = "0x742d35cc6634c0532925a3b844bc9e7595f251e3" as Address;
		const tokenOut = "0x0000000000000000000000000000000000000001" as Address;
		const amountIn = 1000n;
		const amountOutMin = 950n;

		const encoded = Abi.Function.encodeParams(multiParamAbi[0], [
			tokenIn,
			tokenOut,
			amountIn,
			amountOutMin,
		]);
		const decoded = decodeFunction(multiParamAbi, encoded);

		expect(decoded.name).toBe("swap");
		expect(decoded.params).toHaveLength(4);
		expect(decoded.params[2]).toBe(amountIn);
		expect(decoded.params[3]).toBe(amountOutMin);
	});

	it("preserves parameter types", () => {
		const to = "0x742d35cc6634c0532925a3b844bc9e7595f251e3" as Address;
		const amount = 999999999999999999n; // Large bigint

		const encoded = Abi.Function.encodeParams(mockAbi[0], [to, amount]);
		const decoded = decodeFunction(mockAbi, encoded);

		expect(typeof decoded.params[0]).toBe("string"); // address
		expect(typeof decoded.params[1]).toBe("bigint"); // uint256
		expect(decoded.params[1]).toBe(amount);
	});

	it("handles ABI with events (ignores non-functions)", () => {
		const mixedAbi = [
			...mockAbi,
			{
				type: "event",
				name: "Transfer",
				inputs: [
					{ type: "address", name: "from", indexed: true },
					{ type: "address", name: "to", indexed: true },
				],
			},
		] as const satisfies Abi;

		const to = "0x742d35cc6634c0532925a3b844bc9e7595f251e3" as Address;
		const amount = 1000n;

		const encoded = Abi.Function.encodeParams(mockAbi[0], [to, amount]);
		const decoded = decodeFunction(mixedAbi, encoded);

		expect(decoded.name).toBe("transfer");
	});

	it("round-trips encoding and decoding", () => {
		const to = "0x742d35cc6634c0532925a3b844bc9e7595f251e3" as Address;
		const amount = 1000n;

		// Encode
		const encoded = Abi.Function.encodeParams(mockAbi[0], [to, amount]);

		// Decode
		const decoded = decodeFunction(mockAbi, encoded);

		// Re-encode with decoded params
		const reEncoded = Abi.Function.encodeParams(mockAbi[0], [
			decoded.params[0],
			decoded.params[1],
			// biome-ignore lint/suspicious/noExplicitAny: Dynamic params from decode don't match static type
		] as any);

		expect(reEncoded).toEqual(encoded);
	});

	it("handles function with tuple parameters", () => {
		const tupleAbi = [
			{
				type: "function",
				name: "executeTrade",
				stateMutability: "nonpayable",
				inputs: [
					{
						type: "tuple",
						name: "trade",
						components: [
							{ type: "address", name: "token" },
							{ type: "uint256", name: "amount" },
						],
					},
				],
				outputs: [],
			},
		] as const satisfies Abi;

		const token = "0x742d35cc6634c0532925a3b844bc9e7595f251e3" as Address;
		const amount = 1000n;

		const encoded = Abi.Function.encodeParams(tupleAbi[0], [[token, amount]]);
		const decoded = decodeFunction(tupleAbi, encoded);

		expect(decoded.name).toBe("executeTrade");
		expect(decoded.params).toHaveLength(1);
	});

	it("distinguishes between overloaded functions (different signatures)", () => {
		// Note: In reality, overloaded functions have different selectors
		// This tests that the right function is matched by selector
		const account = "0x742d35cc6634c0532925a3b844bc9e7595f251e3" as Address;

		const balanceOfEncoded = Abi.Function.encodeParams(mockAbi[1], [account]);
		const decoded = decodeFunction(mockAbi, balanceOfEncoded);

		expect(decoded.name).toBe("balanceOf");
		expect(decoded.name).not.toBe("transfer");
	});
});

```
