---
title: '[TS/JS] src/primitives/Abi/parseLogs.test.ts'
source: 'src/primitives/Abi/parseLogs.test.ts'
---

> Auto-generated from test file: src/primitives/Abi/parseLogs.test.ts

```typescript
/**
 * Unit tests for parseLogs
 */

import { describe, expect, it } from "vitest";
import type { BrandedAddress as Address } from "../Address/AddressType.js";
import * as Hex from "../Hex/index.js";
import * as Abi from "./index.js";

const transferEvent = {
	type: "event",
	name: "Transfer",
	inputs: [
		{ type: "address", name: "from", indexed: true },
		{ type: "address", name: "to", indexed: true },
		{ type: "uint256", name: "value", indexed: false },
	],
} as const satisfies Abi.Event;

const approvalEvent = {
	type: "event",
	name: "Approval",
	inputs: [
		{ type: "address", name: "owner", indexed: true },
		{ type: "address", name: "spender", indexed: true },
		{ type: "uint256", name: "value", indexed: false },
	],
} as const satisfies Abi.Event;

const mockAbi = [
	{
		type: "function",
		name: "transfer",
		stateMutability: "nonpayable",
		inputs: [
			{ type: "address", name: "to" },
			{ type: "uint256", name: "amount" },
		],
		outputs: [{ type: "bool", name: "" }],
	},
	transferEvent,
	approvalEvent,
] as const satisfies Abi.Abi;

describe("parseLogs", () => {
	it("parses single Transfer event log", () => {
		const from = "0x742d35cc6634c0532925a3b844bc9e7595f251e3" as Address;
		const to = "0x0000000000000000000000000000000000000001" as Address;
		const value = 1000n;

		const topics = Abi.Event.encodeTopics(transferEvent, { from, to });
		const data = Abi.encodeParameters([{ type: "uint256" }], [value]);

		const logs = [{ topics: topics as any, data }];
		const parsed = Abi.parseLogs.call(mockAbi, logs);

		expect(parsed).toHaveLength(1);
		expect(parsed[0]?.eventName).toBe("Transfer");
		expect(parsed[0]?.args.from).toBe(from);
		expect(parsed[0]?.args.to).toBe(to);
		expect(parsed[0]?.args.value).toBe(value);
	});

	it("parses multiple event logs", () => {
		const from = "0x742d35cc6634c0532925a3b844bc9e7595f251e3" as Address;
		const to = "0x0000000000000000000000000000000000000001" as Address;

		const transferTopics = Abi.Event.encodeTopics(transferEvent, { from, to });
		const transferData = Abi.encodeParameters([{ type: "uint256" }], [1000n]);

		const approvalTopics = Abi.Event.encodeTopics(approvalEvent, {
			owner: from,
			spender: to,
		});
		const approvalData = Abi.encodeParameters([{ type: "uint256" }], [2000n]);

		const logs = [
			{ topics: transferTopics as any, data: transferData },
			{ topics: approvalTopics as any, data: approvalData },
		];

		const parsed = Abi.parseLogs.call(mockAbi, logs);

		expect(parsed).toHaveLength(2);
		expect(parsed[0]?.eventName).toBe("Transfer");
		expect(parsed[1]?.eventName).toBe("Approval");
	});

	it("parses empty logs array", () => {
		const logs: { data: Uint8Array; topics: readonly Uint8Array[] }[] = [];
		const parsed = Abi.parseLogs.call(mockAbi, logs);

		expect(parsed).toHaveLength(0);
		expect(parsed).toEqual([]);
	});

	it("skips logs with no topics (anonymous events)", () => {
		const logs = [{ topics: [], data: new Uint8Array(32) }];
		const parsed = Abi.parseLogs.call(mockAbi, logs);

		expect(parsed).toHaveLength(0);
	});

	it("skips logs with unknown event selector", () => {
		const unknownSelector = new Uint8Array(32).fill(0xff);
		const logs = [{ topics: [unknownSelector], data: new Uint8Array(32) }];
		const parsed = Abi.parseLogs.call(mockAbi, logs);

		expect(parsed).toHaveLength(0);
	});

	it("skips malformed log data", () => {
		const from = "0x742d35cc6634c0532925a3b844bc9e7595f251e3" as Address;
		const to = "0x0000000000000000000000000000000000000001" as Address;

		const topics = Abi.Event.encodeTopics(transferEvent, { from, to });
		// Malformed data (too short)
		const malformedData = new Uint8Array(16);

		const logs = [{ topics: topics as any, data: malformedData }];
		const parsed = Abi.parseLogs.call(mockAbi, logs);

		// Should skip malformed logs gracefully
		expect(parsed).toHaveLength(0);
	});

	it("handles hex string topics and data", () => {
		const from = "0x742d35cc6634c0532925a3b844bc9e7595f251e3" as Address;
		const to = "0x0000000000000000000000000000000000000001" as Address;
		const value = 1000n;

		const topics = Abi.Event.encodeTopics(transferEvent, { from, to });
		const data = Abi.encodeParameters([{ type: "uint256" }], [value]);

		// Convert to hex strings
		const hexTopics = topics.map((t) => Hex.fromBytes(t));
		const hexData = Hex.fromBytes(data);

		const logs = [{ topics: hexTopics, data: hexData }];
		const parsed = Abi.parseLogs.call(mockAbi, logs);

		expect(parsed).toHaveLength(1);
		expect(parsed[0]?.eventName).toBe("Transfer");
	});

	it("filters mixed valid and invalid logs", () => {
		const from = "0x742d35cc6634c0532925a3b844bc9e7595f251e3" as Address;
		const to = "0x0000000000000000000000000000000000000001" as Address;

		const validTopics = Abi.Event.encodeTopics(transferEvent, { from, to });
		const validData = Abi.encodeParameters([{ type: "uint256" }], [1000n]);

		const logs = [
			{ topics: validTopics as any, data: validData }, // valid
			{ topics: [], data: new Uint8Array(32) }, // no topics
			{ topics: [new Uint8Array(32).fill(0xff)], data: new Uint8Array(32) }, // unknown
			{ topics: validTopics as any, data: new Uint8Array(16) }, // malformed
		];

		const parsed = Abi.parseLogs.call(mockAbi, logs);

		// Only the first valid log should be parsed
		expect(parsed).toHaveLength(1);
		expect(parsed[0]?.eventName).toBe("Transfer");
	});

	it("handles ABI with no events", () => {
		const abiNoEvents = [
			{
				type: "function",
				name: "transfer",
				stateMutability: "nonpayable",
				inputs: [],
				outputs: [],
			},
		] as const satisfies Abi.Abi;

		const logs = [
			{
				topics: [new Uint8Array(32)],
				data: new Uint8Array(32),
			},
		];

		const parsed = Abi.parseLogs.call(abiNoEvents, logs);

		expect(parsed).toHaveLength(0);
	});

	it("preserves original args types", () => {
		const from = "0x742d35cc6634c0532925a3b844bc9e7595f251e3" as Address;
		const to = "0x0000000000000000000000000000000000000001" as Address;
		const value = 999999999999999999n; // Large bigint

		const topics = Abi.Event.encodeTopics(transferEvent, { from, to });
		const data = Abi.encodeParameters([{ type: "uint256" }], [value]);

		const logs = [{ topics: topics as any, data }];
		const parsed = Abi.parseLogs.call(mockAbi, logs);

		expect(parsed[0]?.args.value).toBe(value);
		expect(typeof parsed[0]?.args.value).toBe("bigint");
		expect(typeof parsed[0]?.args.from).toBe("string");
	});

	it("handles event with only indexed parameters", () => {
		const indexedOnlyEvent = {
			type: "event",
			name: "IndexedOnly",
			inputs: [
				{ type: "address", name: "addr1", indexed: true },
				{ type: "address", name: "addr2", indexed: true },
			],
		} as const satisfies Abi.Event;

		const abiWithIndexed = [indexedOnlyEvent] as const satisfies Abi.Abi;

		const addr1 = "0x742d35cc6634c0532925a3b844bc9e7595f251e3" as Address;
		const addr2 = "0x0000000000000000000000000000000000000001" as Address;

		const topics = Abi.Event.encodeTopics(indexedOnlyEvent, { addr1, addr2 });
		const data = new Uint8Array(0); // No non-indexed data

		const logs = [{ topics: topics as any, data }];
		const parsed = Abi.parseLogs.call(abiWithIndexed, logs);

		expect(parsed).toHaveLength(1);
		expect(parsed[0]?.eventName).toBe("IndexedOnly");
		expect(parsed[0]?.args.addr1).toBe(addr1);
		expect(parsed[0]?.args.addr2).toBe(addr2);
	});

	it("handles event with no indexed parameters", () => {
		const nonIndexedEvent = {
			type: "event",
			name: "NonIndexed",
			inputs: [
				{ type: "uint256", name: "value1", indexed: false },
				{ type: "uint256", name: "value2", indexed: false },
			],
		} as const satisfies Abi.Event;

		const abiWithNonIndexed = [nonIndexedEvent] as const satisfies Abi.Abi;

		const selector = Abi.Event.getSelector(nonIndexedEvent);
		const data = Abi.encodeParameters(
			[{ type: "uint256" }, { type: "uint256" }],
			[100n, 200n] as any,
		);

		const logs = [{ topics: [selector], data }];
		const parsed = Abi.parseLogs.call(abiWithNonIndexed, logs);

		expect(parsed).toHaveLength(1);
		expect(parsed[0]?.eventName).toBe("NonIndexed");
		expect(parsed[0]?.args.value1).toBe(100n);
		expect(parsed[0]?.args.value2).toBe(200n);
	});

	it("handles large batch of logs efficiently", () => {
		const from = "0x742d35cc6634c0532925a3b844bc9e7595f251e3" as Address;
		const to = "0x0000000000000000000000000000000000000001" as Address;

		const topics = Abi.Event.encodeTopics(transferEvent, { from, to });
		const data = Abi.encodeParameters([{ type: "uint256" }], [1000n]);

		// Create 100 identical logs
		const logs = Array.from({ length: 100 }, () => ({
			topics: topics as any,
			data,
		}));

		const parsed = Abi.parseLogs.call(mockAbi, logs);

		expect(parsed).toHaveLength(100);
		expect(parsed.every((p) => p.eventName === "Transfer")).toBe(true);
	});
});

```
