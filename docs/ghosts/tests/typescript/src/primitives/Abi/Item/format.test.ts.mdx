---
title: '[TS/JS] src/primitives/Abi/Item/format.test.ts'
source: 'src/primitives/Abi/Item/format.test.ts'
---

> Auto-generated from test file: src/primitives/Abi/Item/format.test.ts

```typescript
/**
 * Unit tests for format function
 */

import { describe, expect, it } from "vitest";
import { format } from "./format.js";

describe("format", () => {
	describe("items without names", () => {
		it("formats fallback", () => {
			const item = {
				type: "fallback",
				stateMutability: "payable",
			} as const;

			expect(format(item)).toBe("fallback");
		});

		it("formats receive", () => {
			const item = {
				type: "receive",
				stateMutability: "payable",
			} as const;

			expect(format(item)).toBe("receive");
		});
	});

	describe("function formatting", () => {
		it("formats function with no inputs or outputs", () => {
			const item = {
				type: "function",
				name: "example",
				stateMutability: "nonpayable",
				inputs: [],
				outputs: [],
			} as const;

			expect(format(item)).toBe("function example()");
		});

		it("formats function with inputs", () => {
			const item = {
				type: "function",
				name: "transfer",
				stateMutability: "nonpayable",
				inputs: [
					{ type: "address", name: "to" },
					{ type: "uint256", name: "amount" },
				],
				outputs: [],
			} as const;

			expect(format(item)).toBe(
				"function transfer(address to, uint256 amount)",
			);
		});

		it("formats function with outputs", () => {
			const item = {
				type: "function",
				name: "balanceOf",
				stateMutability: "view",
				inputs: [{ type: "address", name: "account" }],
				outputs: [{ type: "uint256", name: "balance" }],
			} as const;

			expect(format(item)).toBe(
				"function balanceOf(address account) returns (uint256) view",
			);
		});

		it("formats function with multiple outputs", () => {
			const item = {
				type: "function",
				name: "getReserves",
				stateMutability: "view",
				inputs: [],
				outputs: [
					{ type: "uint112", name: "reserve0" },
					{ type: "uint112", name: "reserve1" },
					{ type: "uint32", name: "blockTimestampLast" },
				],
			} as const;

			expect(format(item)).toBe(
				"function getReserves() returns (uint112, uint112, uint32) view",
			);
		});

		it("formats function with unnamed parameters", () => {
			const item = {
				type: "function",
				name: "test",
				stateMutability: "pure",
				inputs: [{ type: "uint256", name: "" }],
				outputs: [{ type: "bool", name: "" }],
			} as const;

			expect(format(item)).toBe("function test(uint256) returns (bool) pure");
		});

		it("formats view function", () => {
			const item = {
				type: "function",
				name: "totalSupply",
				stateMutability: "view",
				inputs: [],
				outputs: [{ type: "uint256", name: "" }],
			} as const;

			expect(format(item)).toBe(
				"function totalSupply() returns (uint256) view",
			);
		});

		it("formats pure function", () => {
			const item = {
				type: "function",
				name: "calculate",
				stateMutability: "pure",
				inputs: [{ type: "uint256", name: "x" }],
				outputs: [{ type: "uint256", name: "" }],
			} as const;

			expect(format(item)).toBe(
				"function calculate(uint256 x) returns (uint256) pure",
			);
		});

		it("formats payable function", () => {
			const item = {
				type: "function",
				name: "deposit",
				stateMutability: "payable",
				inputs: [],
				outputs: [],
			} as const;

			expect(format(item)).toBe("function deposit() payable");
		});

		it("does not append nonpayable to output", () => {
			const item = {
				type: "function",
				name: "burn",
				stateMutability: "nonpayable",
				inputs: [{ type: "uint256", name: "amount" }],
				outputs: [],
			} as const;

			expect(format(item)).toBe("function burn(uint256 amount)");
			expect(format(item)).not.toContain("nonpayable");
		});
	});

	describe("event formatting", () => {
		it("formats event with no inputs", () => {
			const item = {
				type: "event",
				name: "Empty",
				inputs: [],
			} as const;

			expect(format(item)).toBe("event Empty()");
		});

		it("formats event with inputs", () => {
			const item = {
				type: "event",
				name: "Transfer",
				inputs: [
					{ type: "address", name: "from", indexed: true },
					{ type: "address", name: "to", indexed: true },
					{ type: "uint256", name: "value", indexed: false },
				],
			} as const;

			expect(format(item)).toBe(
				"event Transfer(address from, address to, uint256 value)",
			);
		});

		it("formats event with unnamed inputs", () => {
			const item = {
				type: "event",
				name: "Log",
				inputs: [{ type: "bytes", name: "" }],
			} as const;

			expect(format(item)).toBe("event Log(bytes)");
		});

		it("formats anonymous event", () => {
			const item = {
				type: "event",
				name: "Anonymous",
				anonymous: true,
				inputs: [{ type: "uint256", name: "value" }],
			} as const;

			expect(format(item)).toBe("event Anonymous(uint256 value)");
		});
	});

	describe("error formatting", () => {
		it("formats error with no inputs", () => {
			const item = {
				type: "error",
				name: "Unauthorized",
				inputs: [],
			} as const;

			expect(format(item)).toBe("error Unauthorized()");
		});

		it("formats error with inputs", () => {
			const item = {
				type: "error",
				name: "InsufficientBalance",
				inputs: [
					{ type: "uint256", name: "available" },
					{ type: "uint256", name: "required" },
				],
			} as const;

			expect(format(item)).toBe(
				"error InsufficientBalance(uint256 available, uint256 required)",
			);
		});

		it("formats error with unnamed inputs", () => {
			const item = {
				type: "error",
				name: "CustomError",
				inputs: [
					{ type: "address", name: "" },
					{ type: "uint256", name: "" },
				],
			} as const;

			expect(format(item)).toBe("error CustomError(address, uint256)");
		});
	});

	describe("constructor formatting", () => {
		it("formats constructor with no inputs", () => {
			const item = {
				type: "constructor",
				stateMutability: "nonpayable",
				inputs: [],
			} as const;

			// Constructor has no name field, so returns just type
			expect(format(item)).toBe("constructor");
		});

		it("formats constructor with inputs", () => {
			const item = {
				type: "constructor",
				stateMutability: "nonpayable",
				inputs: [
					{ type: "string", name: "name" },
					{ type: "string", name: "symbol" },
				],
			} as const;

			// Constructor has no name field, so returns just type
			expect(format(item)).toBe("constructor");
		});

		it("formats payable constructor", () => {
			const item = {
				type: "constructor",
				stateMutability: "payable",
				inputs: [],
			} as const;

			// Constructor has no name field, so returns just type
			expect(format(item)).toBe("constructor");
		});
	});

	describe("edge cases", () => {
		it("formats function with complex tuple input", () => {
			const item = {
				type: "function",
				name: "swap",
				stateMutability: "nonpayable",
				inputs: [
					{
						type: "tuple",
						name: "params",
						components: [
							{ type: "address", name: "tokenIn" },
							{ type: "uint256", name: "amountIn" },
						],
					},
				],
				outputs: [],
			} as const;

			expect(format(item)).toBe("function swap(tuple params)");
		});

		it("formats function with array type", () => {
			const item = {
				type: "function",
				name: "batchTransfer",
				stateMutability: "nonpayable",
				inputs: [
					{ type: "address[]", name: "recipients" },
					{ type: "uint256[]", name: "amounts" },
				],
				outputs: [],
			} as const;

			expect(format(item)).toBe(
				"function batchTransfer(address[] recipients, uint256[] amounts)",
			);
		});

		it("formats function with fixed array type", () => {
			const item = {
				type: "function",
				name: "setValues",
				stateMutability: "nonpayable",
				inputs: [{ type: "uint256[3]", name: "values" }],
				outputs: [],
			} as const;

			expect(format(item)).toBe("function setValues(uint256[3] values)");
		});
	});
});

```
