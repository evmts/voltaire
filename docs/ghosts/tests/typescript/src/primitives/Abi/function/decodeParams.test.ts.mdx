---
title: '[TS/JS] src/primitives/Abi/function/decodeParams.test.ts'
source: 'src/primitives/Abi/function/decodeParams.test.ts'
---

> Auto-generated from test file: src/primitives/Abi/function/decodeParams.test.ts

```typescript
/**
 * Unit tests for decodeParams function
 */

import { describe, expect, it } from "vitest";
import { decodeParams } from "./decodeParams.js";
import { encodeParams } from "./encodeParams.js";
import {
	FunctionDecodingError,
	FunctionInvalidSelectorError,
} from "./errors.js";

describe("decodeParams", () => {
	describe("basic decoding", () => {
		it("decodes function with no parameters", () => {
			const func = {
				type: "function",
				name: "test",
				stateMutability: "nonpayable",
				inputs: [],
				outputs: [],
			} as const;

			const encoded = encodeParams(func, []);
			const decoded = decodeParams(func, encoded);
			expect(decoded).toEqual([]);
		});

		it("decodes function with single uint256 parameter", () => {
			const func = {
				type: "function",
				name: "setValue",
				stateMutability: "nonpayable",
				inputs: [{ type: "uint256", name: "value" }],
				outputs: [],
			} as const;

			const encoded = encodeParams(func, [100n]);
			const decoded = decodeParams(func, encoded);
			expect(decoded).toEqual([100n]);
		});

		it("decodes function with multiple parameters", () => {
			const func = {
				type: "function",
				name: "transfer",
				stateMutability: "nonpayable",
				inputs: [
					{ type: "address", name: "to" },
					{ type: "uint256", name: "amount" },
				],
				outputs: [{ type: "bool", name: "" }],
			} as const;

			const encoded = encodeParams(func, [
				"0x742d35Cc6634C0532925a3b844Bc9e7595f251e3",
				100n,
			]);
			const decoded = decodeParams(func, encoded);
			expect(decoded).toHaveLength(2);
			expect(decoded[1]).toBe(100n);
		});
	});

	describe("round-trip encoding/decoding", () => {
		it("round-trips address parameter", () => {
			const func = {
				type: "function",
				name: "setAddress",
				stateMutability: "nonpayable",
				inputs: [{ type: "address", name: "addr" }],
				outputs: [],
			} as const;

			const addr = "0x742d35Cc6634C0532925a3b844Bc9e7595f251e3";
			const encoded = encodeParams(func, [addr]);
			const decoded = decodeParams(func, encoded);
			expect(decoded[0]).toBe(addr.toLowerCase());
		});

		it("round-trips bool parameter", () => {
			const func = {
				type: "function",
				name: "setFlag",
				stateMutability: "nonpayable",
				inputs: [{ type: "bool", name: "flag" }],
				outputs: [],
			} as const;

			const encoded = encodeParams(func, [true]);
			const decoded = decodeParams(func, encoded);
			expect(decoded[0]).toBe(true);
		});

		it("round-trips bytes32 parameter", () => {
			const func = {
				type: "function",
				name: "setHash",
				stateMutability: "nonpayable",
				inputs: [{ type: "bytes32", name: "hash" }],
				outputs: [],
			} as const;

			const hash = new Uint8Array(32);
			hash[0] = 0xaa;
			hash[31] = 0xbb;
			const encoded = encodeParams(func, [hash]);
			const decoded = decodeParams(func, encoded);
			expect(decoded[0]).toBeInstanceOf(Uint8Array);
			expect((decoded[0] as Uint8Array)[0]).toBe(0xaa);
			expect((decoded[0] as Uint8Array)[31]).toBe(0xbb);
		});

		it("round-trips string parameter", () => {
			const func = {
				type: "function",
				name: "setName",
				stateMutability: "nonpayable",
				inputs: [{ type: "string", name: "name" }],
				outputs: [],
			} as const;

			const encoded = encodeParams(func, ["hello"]);
			const decoded = decodeParams(func, encoded);
			expect(decoded[0]).toBe("hello");
		});

		it("round-trips bytes parameter", () => {
			const func = {
				type: "function",
				name: "setData",
				stateMutability: "nonpayable",
				inputs: [{ type: "bytes", name: "data" }],
				outputs: [],
			} as const;

			const data = new Uint8Array([1, 2, 3, 4]);
			const encoded = encodeParams(func, [data]);
			const decoded = decodeParams(func, encoded);
			expect(decoded[0]).toBeInstanceOf(Uint8Array);
			expect(Array.from(decoded[0] as Uint8Array)).toEqual([1, 2, 3, 4]);
		});
	});

	describe("array parameters", () => {
		it("decodes fixed-size array", () => {
			const func = {
				type: "function",
				name: "setArray",
				stateMutability: "nonpayable",
				inputs: [{ type: "uint256[3]", name: "values" }],
				outputs: [],
			} as const;

			const encoded = encodeParams(func, [[1n, 2n, 3n]]);
			const decoded = decodeParams(func, encoded);
			expect(decoded[0]).toEqual([1n, 2n, 3n]);
		});

		it("decodes dynamic array", () => {
			const func = {
				type: "function",
				name: "setDynamicArray",
				stateMutability: "nonpayable",
				inputs: [{ type: "uint256[]", name: "values" }],
				outputs: [],
			} as const;

			const encoded = encodeParams(func, [[1n, 2n, 3n, 4n]]);
			const decoded = decodeParams(func, encoded);
			expect(decoded[0]).toEqual([1n, 2n, 3n, 4n]);
		});

		it("decodes empty dynamic array", () => {
			const func = {
				type: "function",
				name: "setDynamicArray",
				stateMutability: "nonpayable",
				inputs: [{ type: "uint256[]", name: "values" }],
				outputs: [],
			} as const;

			const encoded = encodeParams(func, [[]]);
			const decoded = decodeParams(func, encoded);
			expect(decoded[0]).toEqual([]);
		});
	});

	describe("tuple parameters", () => {
		it("decodes simple tuple", () => {
			const func = {
				type: "function",
				name: "setData",
				stateMutability: "nonpayable",
				inputs: [
					{
						type: "tuple",
						name: "data",
						components: [
							{ type: "address", name: "addr" },
							{ type: "uint256", name: "value" },
						],
					},
				],
				outputs: [],
			} as const;

			const addr = "0x742d35Cc6634C0532925a3b844Bc9e7595f251e3";
			const encoded = encodeParams(func, [[addr, 100n]]);
			const decoded = decodeParams(func, encoded);
			expect(decoded[0]).toBeInstanceOf(Array);
			expect((decoded[0] as any[])[1]).toBe(100n);
		});

		it("decodes tuple array", () => {
			const func = {
				type: "function",
				name: "setTuples",
				stateMutability: "nonpayable",
				inputs: [
					{
						type: "tuple[]",
						name: "items",
						components: [
							{ type: "address", name: "addr" },
							{ type: "uint256", name: "value" },
						],
					},
				],
				outputs: [],
			} as const;

			const addr = "0x742d35Cc6634C0532925a3b844Bc9e7595f251e3";
			const encoded = encodeParams(func, [
				[
					[addr, 100n],
					[addr, 200n],
				],
			]);
			const decoded = decodeParams(func, encoded);
			expect(decoded[0]).toBeInstanceOf(Array);
			expect((decoded[0] as any[]).length).toBe(2);
		});
	});

	describe("error handling", () => {
		it("throws FunctionDecodingError for data too short", () => {
			const func = {
				type: "function",
				name: "test",
				stateMutability: "nonpayable",
				inputs: [],
				outputs: [],
			} as const;

			const shortData = new Uint8Array([0x12, 0x34]);
			expect(() => decodeParams(func, shortData)).toThrow(
				FunctionDecodingError,
			);
		});

		it("throws with correct error message for short data", () => {
			const func = {
				type: "function",
				name: "test",
				stateMutability: "nonpayable",
				inputs: [],
				outputs: [],
			} as const;

			const shortData = new Uint8Array([0x12, 0x34]);
			expect(() => decodeParams(func, shortData)).toThrow(
				"Data too short for function selector",
			);
		});

		it("throws FunctionInvalidSelectorError for wrong selector", () => {
			const func = {
				type: "function",
				name: "transfer",
				stateMutability: "nonpayable",
				inputs: [
					{ type: "address", name: "to" },
					{ type: "uint256", name: "amount" },
				],
				outputs: [],
			} as const;

			// Create data with wrong selector
			const wrongData = new Uint8Array(68);
			wrongData[0] = 0xff;
			wrongData[1] = 0xff;
			wrongData[2] = 0xff;
			wrongData[3] = 0xff;

			expect(() => decodeParams(func, wrongData)).toThrow(
				FunctionInvalidSelectorError,
			);
		});

		it("throws with correct error message for wrong selector", () => {
			const func = {
				type: "function",
				name: "transfer",
				stateMutability: "nonpayable",
				inputs: [
					{ type: "address", name: "to" },
					{ type: "uint256", name: "amount" },
				],
				outputs: [],
			} as const;

			const wrongData = new Uint8Array(68);
			wrongData[0] = 0xff;
			wrongData[1] = 0xff;
			wrongData[2] = 0xff;
			wrongData[3] = 0xff;

			expect(() => decodeParams(func, wrongData)).toThrow(
				"Function selector mismatch",
			);
		});

		it("includes function name in error context", () => {
			const func = {
				type: "function",
				name: "myFunction",
				stateMutability: "nonpayable",
				inputs: [],
				outputs: [],
			} as const;

			const shortData = new Uint8Array([0x12]);
			try {
				decodeParams(func, shortData);
				expect.fail("Should have thrown");
			} catch (error) {
				expect(error).toBeInstanceOf(FunctionDecodingError);
				const err = error as FunctionDecodingError;
				expect(err.context?.functionName).toBe("myFunction");
			}
		});
	});

	describe("edge cases", () => {
		it("decodes zero values", () => {
			const func = {
				type: "function",
				name: "setZero",
				stateMutability: "nonpayable",
				inputs: [{ type: "uint256", name: "value" }],
				outputs: [],
			} as const;

			const encoded = encodeParams(func, [0n]);
			const decoded = decodeParams(func, encoded);
			expect(decoded[0]).toBe(0n);
		});

		it("decodes max uint256", () => {
			const func = {
				type: "function",
				name: "setMax",
				stateMutability: "nonpayable",
				inputs: [{ type: "uint256", name: "value" }],
				outputs: [],
			} as const;

			const max =
				0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffn;
			const encoded = encodeParams(func, [max]);
			const decoded = decodeParams(func, encoded);
			expect(decoded[0]).toBe(max);
		});

		it("decodes empty string", () => {
			const func = {
				type: "function",
				name: "setString",
				stateMutability: "nonpayable",
				inputs: [{ type: "string", name: "text" }],
				outputs: [],
			} as const;

			const encoded = encodeParams(func, [""]);
			const decoded = decodeParams(func, encoded);
			expect(decoded[0]).toBe("");
		});

		it("decodes empty bytes", () => {
			const func = {
				type: "function",
				name: "setBytes",
				stateMutability: "nonpayable",
				inputs: [{ type: "bytes", name: "data" }],
				outputs: [],
			} as const;

			const encoded = encodeParams(func, [new Uint8Array(0)]);
			const decoded = decodeParams(func, encoded);
			expect(decoded[0]).toBeInstanceOf(Uint8Array);
			expect((decoded[0] as Uint8Array).length).toBe(0);
		});
	});

	describe("real-world examples", () => {
		it("decodes ERC20 transfer", () => {
			const func = {
				type: "function",
				name: "transfer",
				stateMutability: "nonpayable",
				inputs: [
					{ type: "address", name: "recipient" },
					{ type: "uint256", name: "amount" },
				],
				outputs: [{ type: "bool", name: "" }],
			} as const;

			const addr = "0x742d35Cc6634C0532925a3b844Bc9e7595f251e3";
			const amount = 1000000000000000000n;
			const encoded = encodeParams(func, [addr, amount]);
			const decoded = decodeParams(func, encoded);

			expect(decoded).toHaveLength(2);
			expect(decoded[0]).toBe(addr.toLowerCase());
			expect(decoded[1]).toBe(amount);
		});

		it("decodes ERC20 approve", () => {
			const func = {
				type: "function",
				name: "approve",
				stateMutability: "nonpayable",
				inputs: [
					{ type: "address", name: "spender" },
					{ type: "uint256", name: "amount" },
				],
				outputs: [{ type: "bool", name: "" }],
			} as const;

			const addr = "0x742d35Cc6634C0532925a3b844Bc9e7595f251e3";
			const amount = 1000000000000000000n;
			const encoded = encodeParams(func, [addr, amount]);
			const decoded = decodeParams(func, encoded);

			expect(decoded).toHaveLength(2);
			expect(decoded[1]).toBe(amount);
		});
	});

	describe("selector verification", () => {
		it("accepts correct selector", () => {
			const func = {
				type: "function",
				name: "transfer",
				stateMutability: "nonpayable",
				inputs: [
					{ type: "address", name: "to" },
					{ type: "uint256", name: "amount" },
				],
				outputs: [],
			} as const;

			const encoded = encodeParams(func, [
				"0x742d35Cc6634C0532925a3b844Bc9e7595f251e3",
				100n,
			]);
			expect(() => decodeParams(func, encoded)).not.toThrow();
		});

		it("rejects selector with single byte difference", () => {
			const func = {
				type: "function",
				name: "transfer",
				stateMutability: "nonpayable",
				inputs: [
					{ type: "address", name: "to" },
					{ type: "uint256", name: "amount" },
				],
				outputs: [],
			} as const;

			const encoded = encodeParams(func, [
				"0x742d35Cc6634C0532925a3b844Bc9e7595f251e3",
				100n,
			]);
			// Corrupt one byte of selector
			encoded[0] = encoded[0] ^ 0x01;

			expect(() => decodeParams(func, encoded)).toThrow(
				FunctionInvalidSelectorError,
			);
		});
	});
});

```
