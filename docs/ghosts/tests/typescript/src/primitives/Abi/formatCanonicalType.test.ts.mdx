---
title: '[TS/JS] src/primitives/Abi/formatCanonicalType.test.ts'
source: 'src/primitives/Abi/formatCanonicalType.test.ts'
---

> Auto-generated from test file: src/primitives/Abi/formatCanonicalType.test.ts

```typescript
/**
 * Unit tests for formatCanonicalType function
 */

import { describe, expect, it } from "vitest";
import { formatCanonicalType } from "./formatCanonicalType.js";

describe("formatCanonicalType", () => {
	describe("non-tuple types", () => {
		it("returns simple types as-is", () => {
			expect(formatCanonicalType({ type: "address", name: "to" })).toBe(
				"address",
			);
			expect(formatCanonicalType({ type: "uint256", name: "amount" })).toBe(
				"uint256",
			);
			expect(formatCanonicalType({ type: "bool", name: "flag" })).toBe("bool");
			expect(formatCanonicalType({ type: "bytes32", name: "hash" })).toBe(
				"bytes32",
			);
			expect(formatCanonicalType({ type: "string", name: "text" })).toBe(
				"string",
			);
			expect(formatCanonicalType({ type: "bytes", name: "data" })).toBe(
				"bytes",
			);
		});

		it("returns array types as-is", () => {
			expect(formatCanonicalType({ type: "uint256[]", name: "values" })).toBe(
				"uint256[]",
			);
			expect(formatCanonicalType({ type: "address[]", name: "addrs" })).toBe(
				"address[]",
			);
			expect(formatCanonicalType({ type: "uint256[3]", name: "fixed" })).toBe(
				"uint256[3]",
			);
		});
	});

	describe("tuple types", () => {
		it("expands simple tuple", () => {
			const param = {
				type: "tuple" as const,
				name: "data",
				components: [
					{ type: "address", name: "addr" },
					{ type: "uint256", name: "value" },
				],
			};
			expect(formatCanonicalType(param)).toBe("(address,uint256)");
		});

		it("expands tuple with single component", () => {
			const param = {
				type: "tuple" as const,
				name: "data",
				components: [{ type: "uint256", name: "value" }],
			};
			expect(formatCanonicalType(param)).toBe("(uint256)");
		});

		it("expands tuple with many components", () => {
			const param = {
				type: "tuple" as const,
				name: "data",
				components: [
					{ type: "address", name: "a" },
					{ type: "uint256", name: "b" },
					{ type: "bool", name: "c" },
					{ type: "bytes32", name: "d" },
				],
			};
			expect(formatCanonicalType(param)).toBe("(address,uint256,bool,bytes32)");
		});
	});

	describe("tuple array types", () => {
		it("expands tuple[]", () => {
			const param = {
				type: "tuple[]" as const,
				name: "items",
				components: [
					{ type: "address", name: "addr" },
					{ type: "uint256", name: "value" },
				],
			};
			expect(formatCanonicalType(param)).toBe("(address,uint256)[]");
		});

		it("expands fixed-size tuple array", () => {
			const param = {
				type: "tuple[3]" as const,
				name: "items",
				components: [
					{ type: "address", name: "addr" },
					{ type: "uint256", name: "value" },
				],
			};
			expect(formatCanonicalType(param)).toBe("(address,uint256)[3]");
		});

		it("expands nested tuple arrays", () => {
			const param = {
				type: "tuple[][]" as const,
				name: "matrix",
				components: [
					{ type: "uint256", name: "x" },
					{ type: "uint256", name: "y" },
				],
			};
			expect(formatCanonicalType(param)).toBe("(uint256,uint256)[][]");
		});
	});

	describe("nested tuples", () => {
		it("expands nested tuple", () => {
			const param = {
				type: "tuple" as const,
				name: "outer",
				components: [
					{
						type: "tuple" as const,
						name: "inner",
						components: [{ type: "uint256", name: "value" }],
					},
				],
			};
			expect(formatCanonicalType(param)).toBe("((uint256))");
		});

		it("expands deeply nested tuple", () => {
			const param = {
				type: "tuple" as const,
				name: "outer",
				components: [
					{ type: "address", name: "user" },
					{
						type: "tuple" as const,
						name: "inner",
						components: [
							{ type: "uint256", name: "x" },
							{ type: "uint256", name: "y" },
						],
					},
				],
			};
			expect(formatCanonicalType(param)).toBe("(address,(uint256,uint256))");
		});

		it("expands tuple with nested tuple array", () => {
			const param = {
				type: "tuple" as const,
				name: "data",
				components: [
					{ type: "address", name: "owner" },
					{
						type: "tuple[]" as const,
						name: "items",
						components: [
							{ type: "uint256", name: "id" },
							{ type: "uint256", name: "amount" },
						],
					},
				],
			};
			expect(formatCanonicalType(param)).toBe("(address,(uint256,uint256)[])");
		});
	});

	describe("real-world examples", () => {
		it("handles Uniswap V3 ExactInputSingleParams", () => {
			const param = {
				type: "tuple" as const,
				name: "params",
				components: [
					{ type: "address", name: "tokenIn" },
					{ type: "address", name: "tokenOut" },
					{ type: "uint24", name: "fee" },
					{ type: "address", name: "recipient" },
					{ type: "uint256", name: "deadline" },
					{ type: "uint256", name: "amountIn" },
					{ type: "uint256", name: "amountOutMinimum" },
					{ type: "uint160", name: "sqrtPriceLimitX96" },
				],
			};
			expect(formatCanonicalType(param)).toBe(
				"(address,address,uint24,address,uint256,uint256,uint256,uint160)",
			);
		});

		it("handles compound struct with nested arrays", () => {
			const param = {
				type: "tuple" as const,
				name: "order",
				components: [
					{ type: "address", name: "maker" },
					{ type: "address", name: "taker" },
					{
						type: "tuple[]" as const,
						name: "items",
						components: [
							{ type: "address", name: "token" },
							{ type: "uint256", name: "amount" },
						],
					},
					{ type: "bytes32", name: "nonce" },
				],
			};
			expect(formatCanonicalType(param)).toBe(
				"(address,address,(address,uint256)[],bytes32)",
			);
		});
	});
});

```
