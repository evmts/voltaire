---
title: '[TS/JS] src/primitives/TokenBalance/TokenBalance.test.ts'
source: 'src/primitives/TokenBalance/TokenBalance.test.ts'
---

> Auto-generated from test file: src/primitives/TokenBalance/TokenBalance.test.ts

```typescript
import { describe, expect, it } from "vitest";
import * as TokenBalance from "./index.js";

describe("TokenBalance", () => {
	describe("from", () => {
		it("creates from bigint", () => {
			const balance = TokenBalance.from(1000000000000000000n);
			expect(balance).toBe(1000000000000000000n);
		});

		it("creates from number", () => {
			const balance = TokenBalance.from(100);
			expect(balance).toBe(100n);
		});

		it("creates from hex string", () => {
			const balance = TokenBalance.from("0xff");
			expect(balance).toBe(255n);
		});

		it("creates from decimal string", () => {
			const balance = TokenBalance.from("1000000");
			expect(balance).toBe(1000000n);
		});

		it("throws on negative value", () => {
			expect(() => TokenBalance.from(-1n)).toThrow("cannot be negative");
		});

		it("throws on float number", () => {
			expect(() => TokenBalance.from(1.5)).toThrow("must be an integer");
		});

		it("throws on value exceeding max", () => {
			const overMax = 1n << 256n;
			expect(() => TokenBalance.from(overMax)).toThrow("exceeds maximum");
		});
	});

	describe("toNumber", () => {
		it("converts to number", () => {
			const balance = TokenBalance.from(100n);
			expect(TokenBalance.toNumber(balance)).toBe(100);
		});

		it("throws on value exceeding MAX_SAFE_INTEGER", () => {
			const balance = TokenBalance.from(BigInt(Number.MAX_SAFE_INTEGER) + 1n);
			expect(() => TokenBalance.toNumber(balance)).toThrow("MAX_SAFE_INTEGER");
		});
	});

	describe("toBigInt", () => {
		it("converts to bigint", () => {
			const balance = TokenBalance.from(1000000n);
			expect(TokenBalance.toBigInt(balance)).toBe(1000000n);
		});
	});

	describe("toHex", () => {
		it("converts to hex string", () => {
			const balance = TokenBalance.from(255n);
			expect(TokenBalance.toHex(balance)).toBe("0xff");
		});

		it("handles zero", () => {
			const balance = TokenBalance.from(0n);
			expect(TokenBalance.toHex(balance)).toBe("0x0");
		});

		it("handles large values", () => {
			const balance = TokenBalance.from(1000000000000000000n);
			expect(TokenBalance.toHex(balance)).toBe("0xde0b6b3a7640000");
		});
	});

	describe("equals", () => {
		it("returns true for equal balances", () => {
			const a = TokenBalance.from(100n);
			const b = TokenBalance.from(100n);
			expect(TokenBalance.equals(a, b)).toBe(true);
		});

		it("returns false for different balances", () => {
			const a = TokenBalance.from(100n);
			const b = TokenBalance.from(200n);
			expect(TokenBalance.equals(a, b)).toBe(false);
		});
	});

	describe("compare", () => {
		it("returns -1 when a < b", () => {
			const a = TokenBalance.from(100n);
			const b = TokenBalance.from(200n);
			expect(TokenBalance.compare(a, b)).toBe(-1);
		});

		it("returns 0 when a === b", () => {
			const a = TokenBalance.from(100n);
			const b = TokenBalance.from(100n);
			expect(TokenBalance.compare(a, b)).toBe(0);
		});

		it("returns 1 when a > b", () => {
			const a = TokenBalance.from(200n);
			const b = TokenBalance.from(100n);
			expect(TokenBalance.compare(a, b)).toBe(1);
		});
	});

	describe("format", () => {
		it("formats balance with decimals", () => {
			const balance = TokenBalance.from(1234567890123456789n);
			const formatted = TokenBalance.format(balance, 18);
			expect(formatted).toBe("1.234567890123456789");
		});

		it("formats with rounding", () => {
			const balance = TokenBalance.from(1234567890123456789n);
			const formatted = TokenBalance.format(balance, 18, 6);
			expect(formatted).toBe("1.234568");
		});

		it("handles zero fractional part", () => {
			const balance = TokenBalance.from(1000000000000000000n);
			const formatted = TokenBalance.format(balance, 18);
			expect(formatted).toBe("1");
		});

		it("formats USDC (6 decimals)", () => {
			const balance = TokenBalance.from(100500000n);
			const formatted = TokenBalance.format(balance, 6);
			expect(formatted).toBe("100.5");
		});

		it("formats small amounts", () => {
			const balance = TokenBalance.from(1n);
			const formatted = TokenBalance.format(balance, 18);
			expect(formatted).toBe("0.000000000000000001");
		});
	});

	describe("fromBaseUnit", () => {
		it("converts from human-readable amount", () => {
			const balance = TokenBalance.fromBaseUnit("1.5", 18);
			expect(balance).toBe(1500000000000000000n);
		});

		it("handles USDC (6 decimals)", () => {
			const balance = TokenBalance.fromBaseUnit("100.5", 6);
			expect(balance).toBe(100500000n);
		});

		it("handles integer amounts", () => {
			const balance = TokenBalance.fromBaseUnit("100", 18);
			expect(balance).toBe(100000000000000000000n);
		});

		it("handles amounts without integer part", () => {
			const balance = TokenBalance.fromBaseUnit(".5", 18);
			expect(balance).toBe(500000000000000000n);
		});

		it("throws on invalid format", () => {
			expect(() => TokenBalance.fromBaseUnit("1.2.3", 18)).toThrow(
				"Invalid amount format",
			);
		});
	});

	describe("toBaseUnit", () => {
		it("returns raw bigint value", () => {
			const balance = TokenBalance.from(1500000000000000000n);
			expect(TokenBalance.toBaseUnit(balance)).toBe(1500000000000000000n);
		});
	});

	describe("constants", () => {
		it("exports MAX", () => {
			expect(TokenBalance.constants.MAX).toBe((1n << 256n) - 1n);
		});

		it("exports MIN", () => {
			expect(TokenBalance.constants.MIN).toBe(0n);
		});

		it("exports DECIMALS", () => {
			expect(TokenBalance.constants.DECIMALS.ETH).toBe(18);
			expect(TokenBalance.constants.DECIMALS.USDC).toBe(6);
			expect(TokenBalance.constants.DECIMALS.WBTC).toBe(8);
		});
	});

	describe("ERC20_SELECTORS", () => {
		it("exports balanceOf selector", () => {
			expect(TokenBalance.ERC20_SELECTORS.balanceOf).toBe("0x70a08231");
		});

		it("exports transfer selector", () => {
			expect(TokenBalance.ERC20_SELECTORS.transfer).toBe("0xa9059cbb");
		});

		it("exports approve selector", () => {
			expect(TokenBalance.ERC20_SELECTORS.approve).toBe("0x095ea7b3");
		});

		it("exports transferFrom selector", () => {
			expect(TokenBalance.ERC20_SELECTORS.transferFrom).toBe("0x23b872dd");
		});
	});
});

```
