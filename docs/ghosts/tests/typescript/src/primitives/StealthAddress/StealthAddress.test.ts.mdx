---
title: '[TS/JS] src/primitives/StealthAddress/StealthAddress.test.ts'
source: 'src/primitives/StealthAddress/StealthAddress.test.ts'
---

> Auto-generated from test file: src/primitives/StealthAddress/StealthAddress.test.ts

```typescript
import { describe, expect, it } from "vitest";
import * as Keccak256 from "../../crypto/Keccak256/index.js";
import * as Secp256k1 from "../../crypto/Secp256k1/index.js";
import * as BrandedAddress from "../Address/internal-index.js";
import * as StealthAddress from "./index.js";

describe("StealthAddress - ERC-5564", () => {
	describe("compressPublicKey", () => {
		it("compresses 64-byte uncompressed public key to 33 bytes", () => {
			const privateKey = new Uint8Array(32);
			privateKey[31] = 1; // Private key = 1

			const uncompressed = Secp256k1.derivePublicKey(privateKey);
			expect(uncompressed.length).toBe(64);

			const compressed = StealthAddress.compressPublicKey(uncompressed);
			expect(compressed.length).toBe(33);
			expect(compressed[0] === 0x02 || compressed[0] === 0x03).toBe(true);
		});

		it("throws on invalid length", () => {
			expect(() =>
				StealthAddress.compressPublicKey(new Uint8Array(32)),
			).toThrow("Uncompressed public key must be 64 bytes");
		});

		it("handles even and odd y coordinates", () => {
			// Test multiple keys to get both even and odd y
			for (let i = 1; i < 10; i++) {
				const privateKey = new Uint8Array(32);
				privateKey[31] = i;
				const uncompressed = Secp256k1.derivePublicKey(privateKey);
				const compressed = StealthAddress.compressPublicKey(uncompressed);

				// Should have valid prefix
				expect(compressed[0] === 0x02 || compressed[0] === 0x03).toBe(true);

				// x-coordinate should match
				expect(Array.from(compressed.slice(1))).toEqual(
					Array.from(uncompressed.slice(0, 32)),
				);
			}
		});
	});

	describe("decompressPublicKey", () => {
		it("decompresses 33-byte compressed public key to 64 bytes", () => {
			const privateKey = new Uint8Array(32);
			privateKey[31] = 1;

			const uncompressed = Secp256k1.derivePublicKey(privateKey);
			const compressed = StealthAddress.compressPublicKey(uncompressed);
			const decompressed = StealthAddress.decompressPublicKey(compressed);

			expect(decompressed.length).toBe(64);
			expect(Array.from(decompressed)).toEqual(Array.from(uncompressed));
		});

		it("throws on invalid length", () => {
			expect(() =>
				StealthAddress.decompressPublicKey(new Uint8Array(32)),
			).toThrow("Compressed public key must be 33 bytes");
		});

		it("round-trip compress/decompress preserves key", () => {
			for (let i = 1; i < 10; i++) {
				const privateKey = new Uint8Array(32);
				privateKey[31] = i;
				const original = Secp256k1.derivePublicKey(privateKey);
				const compressed = StealthAddress.compressPublicKey(original);
				const decompressed = StealthAddress.decompressPublicKey(compressed);

				expect(Array.from(decompressed)).toEqual(Array.from(original));
			}
		});
	});

	describe("generateMetaAddress", () => {
		it("generates 66-byte stealth meta-address", () => {
			const spendingPrivKey = new Uint8Array(32);
			const viewingPrivKey = new Uint8Array(32);
			spendingPrivKey[31] = 1;
			viewingPrivKey[31] = 2;

			const spendingPubKey = StealthAddress.compressPublicKey(
				Secp256k1.derivePublicKey(spendingPrivKey),
			);
			const viewingPubKey = StealthAddress.compressPublicKey(
				Secp256k1.derivePublicKey(viewingPrivKey),
			);

			const metaAddress = StealthAddress.generateMetaAddress(
				spendingPubKey,
				viewingPubKey,
			);

			expect(metaAddress.length).toBe(66);
			expect(Array.from(metaAddress.slice(0, 33))).toEqual(
				Array.from(spendingPubKey),
			);
			expect(Array.from(metaAddress.slice(33, 66))).toEqual(
				Array.from(viewingPubKey),
			);
		});

		it("throws on invalid spending key length", () => {
			const viewingPubKey = new Uint8Array(33);
			expect(() =>
				StealthAddress.generateMetaAddress(new Uint8Array(32), viewingPubKey),
			).toThrow("Spending public key must be 33 bytes");
		});

		it("throws on invalid viewing key length", () => {
			const spendingPubKey = new Uint8Array(33);
			expect(() =>
				StealthAddress.generateMetaAddress(spendingPubKey, new Uint8Array(32)),
			).toThrow("Viewing public key must be 33 bytes");
		});
	});

	describe("parseMetaAddress", () => {
		it("parses 66-byte meta-address into spending and viewing keys", () => {
			const spendingPrivKey = new Uint8Array(32);
			const viewingPrivKey = new Uint8Array(32);
			spendingPrivKey[31] = 1;
			viewingPrivKey[31] = 2;

			const spendingPubKey = StealthAddress.compressPublicKey(
				Secp256k1.derivePublicKey(spendingPrivKey),
			);
			const viewingPubKey = StealthAddress.compressPublicKey(
				Secp256k1.derivePublicKey(viewingPrivKey),
			);

			const metaAddress = StealthAddress.generateMetaAddress(
				spendingPubKey,
				viewingPubKey,
			);

			const parsed = StealthAddress.parseMetaAddress(metaAddress);

			expect(Array.from(parsed.spendingPubKey)).toEqual(
				Array.from(spendingPubKey),
			);
			expect(Array.from(parsed.viewingPubKey)).toEqual(
				Array.from(viewingPubKey),
			);
		});

		it("throws on invalid length", () => {
			expect(() => StealthAddress.parseMetaAddress(new Uint8Array(65))).toThrow(
				"Stealth meta-address must be 66 bytes",
			);
		});
	});

	describe("computeViewTag", () => {
		it("extracts first byte of hash as view tag", () => {
			const hash = new Uint8Array(32);
			hash[0] = 0x42;

			const viewTag = StealthAddress.computeViewTag(hash);
			expect(viewTag).toBe(0x42);
		});

		it("returns number in range 0-255", () => {
			for (let i = 0; i < 256; i++) {
				const hash = new Uint8Array(32);
				hash[0] = i;
				const viewTag = StealthAddress.computeViewTag(hash);
				expect(viewTag).toBe(i);
				expect(typeof viewTag).toBe("number");
			}
		});
	});

	describe("parseAnnouncement", () => {
		it("parses ephemeral public key and view tag", () => {
			const announcement = new Uint8Array(34);
			// Set ephemeral public key (33 bytes)
			announcement[0] = 0x02; // compressed prefix
			for (let i = 1; i < 33; i++) {
				announcement[i] = i;
			}
			announcement[33] = 0x42; // view tag

			const parsed = StealthAddress.parseAnnouncement(announcement);

			expect(parsed.ephemeralPublicKey.length).toBe(33);
			expect(parsed.ephemeralPublicKey[0]).toBe(0x02);
			expect(parsed.viewTag).toBe(0x42);
		});

		it("throws on invalid length", () => {
			expect(() =>
				StealthAddress.parseAnnouncement(new Uint8Array(33)),
			).toThrow("Announcement must be 34 bytes");
		});
	});

	describe("generateStealthAddress", () => {
		it("generates stealth address with ephemeral key and view tag", () => {
			// Recipient keys
			const spendingPrivKey = new Uint8Array(32);
			const viewingPrivKey = new Uint8Array(32);
			spendingPrivKey[31] = 1;
			viewingPrivKey[31] = 2;

			const spendingPubKey = StealthAddress.compressPublicKey(
				Secp256k1.derivePublicKey(spendingPrivKey),
			);
			const viewingPubKey = StealthAddress.compressPublicKey(
				Secp256k1.derivePublicKey(viewingPrivKey),
			);

			const metaAddress = StealthAddress.generateMetaAddress(
				spendingPubKey,
				viewingPubKey,
			);

			// Sender generates stealth address
			const ephemeralPrivKey = new Uint8Array(32);
			ephemeralPrivKey[31] = 3;

			const result = StealthAddress.generateStealthAddress(
				metaAddress,
				ephemeralPrivKey,
			);

			expect(result.stealthAddress.length).toBe(20);
			expect(result.ephemeralPublicKey.length).toBe(33);
			expect(typeof result.viewTag).toBe("number");
			expect(result.viewTag).toBeGreaterThanOrEqual(0);
			expect(result.viewTag).toBeLessThanOrEqual(255);
		});

		it("generates different addresses for different ephemeral keys", () => {
			const spendingPrivKey = new Uint8Array(32);
			const viewingPrivKey = new Uint8Array(32);
			spendingPrivKey[31] = 1;
			viewingPrivKey[31] = 2;

			const spendingPubKey = StealthAddress.compressPublicKey(
				Secp256k1.derivePublicKey(spendingPrivKey),
			);
			const viewingPubKey = StealthAddress.compressPublicKey(
				Secp256k1.derivePublicKey(viewingPrivKey),
			);

			const metaAddress = StealthAddress.generateMetaAddress(
				spendingPubKey,
				viewingPubKey,
			);

			const ephemeral1 = new Uint8Array(32);
			const ephemeral2 = new Uint8Array(32);
			ephemeral1[31] = 1;
			ephemeral2[31] = 2;

			const result1 = StealthAddress.generateStealthAddress(
				metaAddress,
				ephemeral1,
			);
			const result2 = StealthAddress.generateStealthAddress(
				metaAddress,
				ephemeral2,
			);

			expect(
				BrandedAddress.equals(result1.stealthAddress, result2.stealthAddress),
			).toBe(false);
		});

		it("throws on invalid ephemeral key length", () => {
			const metaAddress = new Uint8Array(66);
			expect(() =>
				StealthAddress.generateStealthAddress(metaAddress, new Uint8Array(31)),
			).toThrow("Ephemeral private key must be 32 bytes");
		});
	});

	describe("checkStealthAddress", () => {
		it("detects stealth address belonging to recipient", () => {
			// Recipient keys
			const spendingPrivKey = new Uint8Array(32);
			const viewingPrivKey = new Uint8Array(32);
			spendingPrivKey[31] = 1;
			viewingPrivKey[31] = 2;

			const spendingPubKey = StealthAddress.compressPublicKey(
				Secp256k1.derivePublicKey(spendingPrivKey),
			);
			const viewingPubKey = StealthAddress.compressPublicKey(
				Secp256k1.derivePublicKey(viewingPrivKey),
			);

			const metaAddress = StealthAddress.generateMetaAddress(
				spendingPubKey,
				viewingPubKey,
			);

			// Sender generates stealth address
			const ephemeralPrivKey = new Uint8Array(32);
			ephemeralPrivKey[31] = 3;

			const generated = StealthAddress.generateStealthAddress(
				metaAddress,
				ephemeralPrivKey,
			);

			// Recipient checks if address is theirs
			const result = StealthAddress.checkStealthAddress(
				viewingPrivKey,
				generated.ephemeralPublicKey,
				generated.viewTag,
				spendingPubKey,
				generated.stealthAddress,
			);

			expect(result.isForRecipient).toBe(true);
			expect(result.stealthPrivateKey).toBeDefined();
			expect(result.stealthPrivateKey?.length).toBe(32);
		});

		it("rejects stealth address not for recipient (wrong view tag)", () => {
			// Recipient keys
			const spendingPrivKey = new Uint8Array(32);
			const viewingPrivKey = new Uint8Array(32);
			spendingPrivKey[31] = 1;
			viewingPrivKey[31] = 2;

			const spendingPubKey = StealthAddress.compressPublicKey(
				Secp256k1.derivePublicKey(spendingPrivKey),
			);
			const viewingPubKey = StealthAddress.compressPublicKey(
				Secp256k1.derivePublicKey(viewingPrivKey),
			);

			const metaAddress = StealthAddress.generateMetaAddress(
				spendingPubKey,
				viewingPubKey,
			);

			// Sender generates stealth address
			const ephemeralPrivKey = new Uint8Array(32);
			ephemeralPrivKey[31] = 3;

			const generated = StealthAddress.generateStealthAddress(
				metaAddress,
				ephemeralPrivKey,
			);

			// Check with wrong view tag
			const wrongViewTag = (generated.viewTag + 1) % 256;
			const result = StealthAddress.checkStealthAddress(
				viewingPrivKey,
				generated.ephemeralPublicKey,
				wrongViewTag,
				spendingPubKey,
				generated.stealthAddress,
			);

			expect(result.isForRecipient).toBe(false);
			expect(result.stealthPrivateKey).toBeUndefined();
		});

		it("rejects stealth address for different recipient", () => {
			// Recipient 1 keys
			const spendingPrivKey1 = new Uint8Array(32);
			const viewingPrivKey1 = new Uint8Array(32);
			spendingPrivKey1[31] = 1;
			viewingPrivKey1[31] = 2;

			const spendingPubKey1 = StealthAddress.compressPublicKey(
				Secp256k1.derivePublicKey(spendingPrivKey1),
			);
			const viewingPubKey1 = StealthAddress.compressPublicKey(
				Secp256k1.derivePublicKey(viewingPrivKey1),
			);

			const metaAddress1 = StealthAddress.generateMetaAddress(
				spendingPubKey1,
				viewingPubKey1,
			);

			// Sender generates stealth address for recipient 1
			const ephemeralPrivKey = new Uint8Array(32);
			ephemeralPrivKey[31] = 3;

			const generated = StealthAddress.generateStealthAddress(
				metaAddress1,
				ephemeralPrivKey,
			);

			// Recipient 2 tries to claim it
			const viewingPrivKey2 = new Uint8Array(32);
			const spendingPrivKey2 = new Uint8Array(32);
			viewingPrivKey2[31] = 4;
			spendingPrivKey2[31] = 5;

			const spendingPubKey2 = StealthAddress.compressPublicKey(
				Secp256k1.derivePublicKey(spendingPrivKey2),
			);

			const result = StealthAddress.checkStealthAddress(
				viewingPrivKey2,
				generated.ephemeralPublicKey,
				generated.viewTag,
				spendingPubKey2,
				generated.stealthAddress,
			);

			expect(result.isForRecipient).toBe(false);
		});
	});

	describe("computeStealthPrivateKey", () => {
		it("computes stealth private key from spending key and shared secret", () => {
			const spendingPrivKey = new Uint8Array(32);
			const hashedSecret = new Uint8Array(32);
			spendingPrivKey[31] = 1;
			hashedSecret[31] = 2;

			const stealthPrivKey = StealthAddress.computeStealthPrivateKey(
				spendingPrivKey,
				hashedSecret,
			);

			expect(stealthPrivKey.length).toBe(32);
			// Result should be (1 + 2) mod n = 3
			expect(stealthPrivKey[31]).toBe(3);
		});

		it("handles modulo reduction with curve order", () => {
			// Test with large values that require mod n
			const spendingPrivKey = new Uint8Array(32);
			const hashedSecret = new Uint8Array(32);

			// Set to max values
			for (let i = 0; i < 32; i++) {
				spendingPrivKey[i] = 0xff;
				hashedSecret[i] = 0xff;
			}

			const stealthPrivKey = StealthAddress.computeStealthPrivateKey(
				spendingPrivKey,
				hashedSecret,
			);

			expect(stealthPrivKey.length).toBe(32);
			// Should be reduced mod n
			expect(Array.from(stealthPrivKey)).not.toEqual(
				Array.from(new Uint8Array(32).fill(0xff)),
			);
		});

		it("throws on invalid spending key length", () => {
			const hashedSecret = new Uint8Array(32);
			expect(() =>
				StealthAddress.computeStealthPrivateKey(
					new Uint8Array(31),
					hashedSecret,
				),
			).toThrow("Spending private key must be 32 bytes");
		});

		it("throws on invalid hashed secret length", () => {
			const spendingPrivKey = new Uint8Array(32);
			expect(() =>
				StealthAddress.computeStealthPrivateKey(
					spendingPrivKey,
					new Uint8Array(31),
				),
			).toThrow("Hashed shared secret must be 32 bytes");
		});
	});

	describe("End-to-end ERC-5564 workflow", () => {
		it("complete stealth address flow with key recovery", () => {
			// 1. Recipient generates key pairs
			const spendingPrivKey = new Uint8Array(32);
			const viewingPrivKey = new Uint8Array(32);
			spendingPrivKey[31] = 0x11;
			viewingPrivKey[31] = 0x22;

			const spendingPubKey = StealthAddress.compressPublicKey(
				Secp256k1.derivePublicKey(spendingPrivKey),
			);
			const viewingPubKey = StealthAddress.compressPublicKey(
				Secp256k1.derivePublicKey(viewingPrivKey),
			);

			// 2. Recipient publishes meta-address
			const metaAddress = StealthAddress.generateMetaAddress(
				spendingPubKey,
				viewingPubKey,
			);
			expect(metaAddress.length).toBe(66);

			// 3. Sender generates stealth address
			const ephemeralPrivKey = new Uint8Array(32);
			ephemeralPrivKey[31] = 0x33;

			const generated = StealthAddress.generateStealthAddress(
				metaAddress,
				ephemeralPrivKey,
			);

			// 4. Sender announces: ephemeralPublicKey, viewTag, stealthAddress
			const announcement = new Uint8Array(34);
			announcement.set(generated.ephemeralPublicKey, 0);
			announcement[33] = generated.viewTag;

			// 5. Recipient scans announcement
			const parsed = StealthAddress.parseAnnouncement(announcement);
			expect(parsed.ephemeralPublicKey.length).toBe(33);
			expect(parsed.viewTag).toBe(generated.viewTag);

			// 6. Recipient checks if stealth address is theirs
			const checkResult = StealthAddress.checkStealthAddress(
				viewingPrivKey,
				parsed.ephemeralPublicKey,
				parsed.viewTag,
				spendingPubKey,
				generated.stealthAddress,
			);

			expect(checkResult.isForRecipient).toBe(true);
			expect(checkResult.stealthPrivateKey).toBeDefined();

			// 7. Recipient computes full stealth private key
			const stealthPrivKey = StealthAddress.computeStealthPrivateKey(
				spendingPrivKey,
				// biome-ignore lint/style/noNonNullAssertion: asserted above with toBeDefined
				checkResult.stealthPrivateKey!,
			);

			// 8. Verify stealth private key derives to stealth address
			const stealthPubKey = Secp256k1.derivePublicKey(stealthPrivKey);
			const x = stealthPubKey.slice(0, 32);
			const y = stealthPubKey.slice(32, 64);

			let xBigInt = 0n;
			for (let i = 0; i < 32; i++) {
				xBigInt = (xBigInt << 8n) | BigInt(x[i]);
			}
			let yBigInt = 0n;
			for (let i = 0; i < 32; i++) {
				yBigInt = (yBigInt << 8n) | BigInt(y[i]);
			}

			const derivedAddress = BrandedAddress.fromPublicKey(xBigInt, yBigInt);
			expect(
				BrandedAddress.equals(derivedAddress, generated.stealthAddress),
			).toBe(true);
		});

		it("multiple recipients scanning same announcement", () => {
			// Generate 3 recipients
			const recipients = [1, 2, 3].map((i) => {
				const spendingPrivKey = new Uint8Array(32);
				const viewingPrivKey = new Uint8Array(32);
				spendingPrivKey[31] = i * 10;
				viewingPrivKey[31] = i * 20;

				const spendingPubKey = StealthAddress.compressPublicKey(
					Secp256k1.derivePublicKey(spendingPrivKey),
				);
				const viewingPubKey = StealthAddress.compressPublicKey(
					Secp256k1.derivePublicKey(viewingPrivKey),
				);

				const metaAddress = StealthAddress.generateMetaAddress(
					spendingPubKey,
					viewingPubKey,
				);

				return {
					spendingPrivKey,
					viewingPrivKey,
					spendingPubKey,
					viewingPubKey,
					metaAddress,
				};
			});

			// Sender generates stealth address for recipient 1
			const ephemeralPrivKey = new Uint8Array(32);
			ephemeralPrivKey[31] = 0x99;

			const generated = StealthAddress.generateStealthAddress(
				recipients[0].metaAddress,
				ephemeralPrivKey,
			);

			// All recipients scan
			const results = recipients.map((recipient) =>
				StealthAddress.checkStealthAddress(
					recipient.viewingPrivKey,
					generated.ephemeralPublicKey,
					generated.viewTag,
					recipient.spendingPubKey,
					generated.stealthAddress,
				),
			);

			// Only recipient 0 should detect it
			expect(results[0].isForRecipient).toBe(true);
			expect(results[1].isForRecipient).toBe(false);
			expect(results[2].isForRecipient).toBe(false);
		});
	});
});

```
