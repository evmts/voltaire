---
title: '[TS/JS] src/primitives/Bytes/BytesType.test.ts'
source: 'src/primitives/Bytes/BytesType.test.ts'
---

> Auto-generated from test file: src/primitives/Bytes/BytesType.test.ts

```typescript
import { describe, it } from "vitest";
import type { BytesType } from "./BytesType.js";

type Equals<X, Y> = (<T>() => T extends X ? 1 : 2) extends <T>() => T extends Y
	? 1
	: 2
	? true
	: false;

describe("BytesType type-level tests", () => {
	describe("basic type structure", () => {
		it("should be a branded Uint8Array type", () => {
			type Test1 = Equals<BytesType, Uint8Array>;
			const test1: Test1 = false;
			test1;

			type Test2 = BytesType extends Uint8Array ? true : false;
			const test2: Test2 = true;
			test2;
		});

		it("should be assignable to Uint8Array", () => {
			const value = new Uint8Array([1, 2, 3]) as BytesType;
			const _arr: Uint8Array = value;
		});

		it("should not allow plain Uint8Array assignment without cast", () => {
			const arr = new Uint8Array([1, 2, 3]);
			// @ts-expect-error - plain Uint8Array not assignable to branded type
			const _value: BytesType = arr;
		});
	});

	describe("branding", () => {
		it("should not allow other branded types", () => {
			type OtherBrand = Uint8Array & { readonly __tag: "Other" };
			const other = new Uint8Array([1, 2, 3]) as OtherBrand;
			// @ts-expect-error - different branded type not assignable
			const _value: BytesType = other;
		});

		it("should maintain brand through const assertions", () => {
			const value = new Uint8Array([1, 2, 3]) as const as BytesType;
			const _typed: BytesType = value;
		});

		it("should have readonly brand property", () => {
			const bytes = new Uint8Array([1, 2, 3]) as BytesType;
			// @ts-expect-error - brand is readonly
			bytes.__tag = "Modified";
		});
	});

	describe("Uint8Array compatibility", () => {
		it("should support length property", () => {
			const bytes = new Uint8Array([1, 2, 3]) as BytesType;
			const _length: number = bytes.length;
		});

		it("should support array indexing", () => {
			const bytes = new Uint8Array([1, 2, 3]) as BytesType;
			const _first: number | undefined = bytes[0];
			const _second: number | undefined = bytes[1];
		});

		it("should support iteration", () => {
			const bytes = new Uint8Array([1, 2, 3]) as BytesType;
			for (const _byte of bytes) {
				const _value: number = _byte;
			}
		});

		it("should support slice", () => {
			const bytes = new Uint8Array([1, 2, 3, 4]) as BytesType;
			const _sliced: Uint8Array = bytes.slice(1, 3);
		});

		it("should support set", () => {
			const bytes = new Uint8Array(4) as BytesType;
			bytes.set([1, 2], 0);
			const _check: BytesType = bytes;
		});

		it("should support subarray", () => {
			const bytes = new Uint8Array([1, 2, 3, 4]) as BytesType;
			const _sub: Uint8Array = bytes.subarray(1, 3);
		});
	});

	describe("type narrowing", () => {
		it("should narrow from Uint8Array to BytesType", () => {
			const arr: Uint8Array = new Uint8Array([1, 2, 3]);
			const bytes = arr as BytesType;
			const _typed: BytesType = bytes;
		});

		it("should widen from BytesType to Uint8Array", () => {
			const bytes: BytesType = new Uint8Array([1, 2, 3]) as BytesType;
			const arr: Uint8Array = bytes;
			const _typed: Uint8Array = arr;
		});
	});

	describe("type compatibility", () => {
		it("should not accept string", () => {
			// @ts-expect-error - string is not BytesType
			const _bytes: BytesType = "0x1234";
		});

		it("should not accept number", () => {
			// @ts-expect-error - number is not BytesType
			const _bytes: BytesType = 1234;
		});

		it("should not accept boolean", () => {
			// @ts-expect-error - boolean is not BytesType
			const _bytes: BytesType = true;
		});

		it("should not accept plain array", () => {
			// @ts-expect-error - array is not BytesType
			const _bytes: BytesType = [1, 2, 3, 4];
		});

		it("should not accept object", () => {
			// @ts-expect-error - object is not BytesType
			const _bytes: BytesType = { data: new Uint8Array([1, 2, 3]) };
		});

		it("should not accept Int8Array", () => {
			// @ts-expect-error - Int8Array is not BytesType
			const _bytes: BytesType = new Int8Array([1, 2, 3]);
		});

		it("should not accept Uint16Array", () => {
			// @ts-expect-error - Uint16Array is not BytesType
			const _bytes: BytesType = new Uint16Array([1, 2, 3]);
		});

		// Removed Buffer-based test to avoid Node-specific Buffer usage.
	});

	describe("union types", () => {
		it("should work in unions", () => {
			type BytesOrArray = BytesType | Uint8Array;
			const _bytes: BytesOrArray = new Uint8Array([1, 2, 3]) as BytesType;
			const _arr: BytesOrArray = new Uint8Array([1, 2, 3]);
		});

		it("should work with union of branded types", () => {
			type OtherBytes = Uint8Array & { readonly __tag: "OtherBytes" };
			type BytesUnion = BytesType | OtherBytes;
			const _bytes1: BytesUnion = new Uint8Array([1, 2, 3]) as BytesType;
			const _bytes2: BytesUnion = new Uint8Array([1, 2, 3]) as OtherBytes;
		});
	});

	describe("generic functions", () => {
		it("should work as generic parameter", () => {
			function test<T extends Uint8Array>(bytes: T): T {
				return bytes;
			}

			const bytes = new Uint8Array([1, 2, 3]) as BytesType;
			const result = test(bytes);
			const _typed: BytesType = result;
		});

		it("should preserve branding through generic", () => {
			function identity<T>(value: T): T {
				return value;
			}

			const bytes = new Uint8Array([1, 2, 3]) as BytesType;
			const result = identity(bytes);
			const _typed: BytesType = result;
		});
	});

	describe("ArrayBuffer compatibility", () => {
		it("should support buffer property", () => {
			const bytes = new Uint8Array([1, 2, 3]) as BytesType;
			const _buffer: ArrayBuffer = bytes.buffer;
		});

		it("should support byteLength", () => {
			const bytes = new Uint8Array([1, 2, 3]) as BytesType;
			const _byteLength: number = bytes.byteLength;
		});

		it("should support byteOffset", () => {
			const bytes = new Uint8Array([1, 2, 3]) as BytesType;
			const _byteOffset: number = bytes.byteOffset;
		});
	});

	describe("construction patterns", () => {
		it("should support empty bytes", () => {
			const _empty: BytesType = new Uint8Array(0) as BytesType;
		});

		it("should support sized bytes", () => {
			const _bytes: BytesType = new Uint8Array(32) as BytesType;
		});

		it("should support from array", () => {
			const _bytes: BytesType = new Uint8Array([1, 2, 3, 4]) as BytesType;
		});

		it("should support from ArrayBuffer", () => {
			const buffer = new ArrayBuffer(4);
			const _bytes: BytesType = new Uint8Array(buffer) as BytesType;
		});
	});

	describe("mutability", () => {
		it("should allow mutations", () => {
			const bytes = new Uint8Array([1, 2, 3]) as BytesType;
			bytes[0] = 99;
			const _check: BytesType = bytes;
		});

		it("should allow fill", () => {
			const bytes = new Uint8Array(4) as BytesType;
			bytes.fill(0xff);
			const _check: BytesType = bytes;
		});

		it("should allow copyWithin", () => {
			const bytes = new Uint8Array([1, 2, 3, 4]) as BytesType;
			bytes.copyWithin(0, 2);
			const _check: BytesType = bytes;
		});
	});

	describe("common Ethereum sizes", () => {
		it("should support Bytes4 (4 bytes)", () => {
			const _selector: BytesType = new Uint8Array(4) as BytesType;
		});

		it("should support Bytes20 (20 bytes - address)", () => {
			const _address: BytesType = new Uint8Array(20) as BytesType;
		});

		it("should support Bytes32 (32 bytes - hash)", () => {
			const _hash: BytesType = new Uint8Array(32) as BytesType;
		});

		it("should support Bytes64 (64 bytes)", () => {
			const _bytes64: BytesType = new Uint8Array(64) as BytesType;
		});

		it("should support variable length", () => {
			const _variable: BytesType = new Uint8Array(100) as BytesType;
		});
	});

	describe("type guards", () => {
		it("should work with instanceof", () => {
			const bytes = new Uint8Array([1, 2, 3]) as BytesType;
			const isUint8Array: boolean = bytes instanceof Uint8Array;
			const _check: true = isUint8Array as true;
		});

		it("should not be instanceof Array", () => {
			const bytes = new Uint8Array([1, 2, 3]) as BytesType;
			const isArray: boolean = Array.isArray(bytes);
			const _check: false = isArray as false;
		});
	});
});

```
