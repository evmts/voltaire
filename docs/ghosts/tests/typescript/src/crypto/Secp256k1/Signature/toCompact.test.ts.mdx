---
title: '[TS/JS] src/crypto/Secp256k1/Signature/toCompact.test.ts'
source: 'src/crypto/Secp256k1/Signature/toCompact.test.ts'
---

> Auto-generated from test file: src/crypto/Secp256k1/Signature/toCompact.test.ts

```typescript
import { describe, expect, it } from "vitest";
import { Hash } from "../../../primitives/Hash/index.js";
import * as Signature from "./index.js";

describe("Secp256k1.Signature.toCompact", () => {
	describe("EIP-2098 compact format", () => {
		it("should convert signature to 64-byte array", () => {
			const r = Hash.from(new Uint8Array(32).fill(1));
			const s = Hash.from(new Uint8Array(32).fill(2));
			const sig = { r, s, v: 27 };

			const compact = Signature.toCompact(sig);

			expect(compact).toBeInstanceOf(Uint8Array);
			expect(compact.length).toBe(64);
		});

		it("should place r in first 32 bytes", () => {
			const r = Hash.from(new Uint8Array(32).fill(42));
			const s = Hash.from(new Uint8Array(32).fill(99));
			const sig = { r, s, v: 27 };

			const compact = Signature.toCompact(sig);

			expect(compact.slice(0, 32).every((b) => b === 42)).toBe(true);
		});

		it("should place s in bytes 32-63 with yParity in bit 255", () => {
			const r = Hash.from(new Uint8Array(32).fill(42));
			const s = Hash.from(new Uint8Array(32).fill(0x55));
			const sig = { r, s, v: 27 }; // yParity = 0

			const compact = Signature.toCompact(sig);

			// s[0] should be 0x55 (bit 255 clear for yParity=0)
			expect(compact[32]).toBe(0x55);
			expect(compact.slice(33, 64).every((b) => b === 0x55)).toBe(true);
		});

		it("should encode yParity=0 (v=27) with bit 255 clear", () => {
			const r = Hash.from(new Uint8Array(32).fill(1));
			const s = Hash.from(new Uint8Array(32).fill(0x55));
			const sig = { r, s, v: 27 };

			const compact = Signature.toCompact(sig);

			expect(compact[32] & 0x80).toBe(0x00); // Bit 255 clear
			expect(compact[32] & 0x7f).toBe(0x55); // Original s preserved
		});

		it("should encode yParity=1 (v=28) with bit 255 set", () => {
			const r = Hash.from(new Uint8Array(32).fill(1));
			const s = Hash.from(new Uint8Array(32).fill(0x55));
			const sig = { r, s, v: 28 };

			const compact = Signature.toCompact(sig);

			expect(compact[32] & 0x80).toBe(0x80); // Bit 255 set
			expect(compact[32] & 0x7f).toBe(0x55); // Original s preserved
		});

		it("should produce different compact for different v values (EIP-2098)", () => {
			const r = Hash.from(new Uint8Array(32).fill(7));
			const s = Hash.from(new Uint8Array(32).fill(13));
			const sig27 = { r, s, v: 27 };
			const sig28 = { r, s, v: 28 };

			const compact27 = Signature.toCompact(sig27);
			const compact28 = Signature.toCompact(sig28);

			// Should differ in bit 255 of s
			expect(compact27[32] & 0x80).toBe(0x00);
			expect(compact28[32] & 0x80).toBe(0x80);
			expect(compact27).not.toEqual(compact28);
		});
	});

	describe("edge cases", () => {
		it("should handle all-zero r", () => {
			const r = Hash.from(new Uint8Array(32));
			const s = Hash.from(new Uint8Array(32).fill(1));
			const sig = { r, s, v: 27 };

			const compact = Signature.toCompact(sig);

			expect(compact.slice(0, 32).every((b) => b === 0)).toBe(true);
		});

		it("should handle all-zero s with yParity=0", () => {
			const r = Hash.from(new Uint8Array(32).fill(1));
			const s = Hash.from(new Uint8Array(32));
			const sig = { r, s, v: 27 };

			const compact = Signature.toCompact(sig);

			expect(compact.slice(32, 64).every((b) => b === 0)).toBe(true);
		});

		it("should handle all-zero s with yParity=1", () => {
			const r = Hash.from(new Uint8Array(32).fill(1));
			const s = Hash.from(new Uint8Array(32));
			const sig = { r, s, v: 28 };

			const compact = Signature.toCompact(sig);

			// First byte of s should have bit 255 set
			expect(compact[32]).toBe(0x80);
			expect(compact.slice(33, 64).every((b) => b === 0)).toBe(true);
		});

		it("should handle max values for r (s will have bit 255 set based on yParity)", () => {
			const r = Hash.from(new Uint8Array(32).fill(0xff));
			const s = Hash.from(new Uint8Array(32).fill(0x7f)); // Use 0x7f to avoid collision with yParity bit
			const sig = { r, s, v: 27 }; // yParity = 0

			const compact = Signature.toCompact(sig);

			expect(compact.slice(0, 32).every((b) => b === 0xff)).toBe(true);
			expect(compact[32]).toBe(0x7f); // Bit 255 clear for yParity=0
		});

		it("should handle v=0 (yParity=0)", () => {
			const r = Hash.from(new Uint8Array(32).fill(1));
			const s = Hash.from(new Uint8Array(32).fill(0x55));
			const sig = { r, s, v: 0 };

			const compact = Signature.toCompact(sig);

			expect(compact.length).toBe(64);
			expect(compact[32] & 0x80).toBe(0x00); // Bit 255 clear
		});

		it("should handle v=1 (yParity=1)", () => {
			const r = Hash.from(new Uint8Array(32).fill(1));
			const s = Hash.from(new Uint8Array(32).fill(0x55));
			const sig = { r, s, v: 1 };

			const compact = Signature.toCompact(sig);

			expect(compact.length).toBe(64);
			expect(compact[32] & 0x80).toBe(0x80); // Bit 255 set
		});

		it("should handle EIP-155 v=37 (chainId=1, yParity=0)", () => {
			const r = Hash.from(new Uint8Array(32).fill(1));
			const s = Hash.from(new Uint8Array(32).fill(0x55));
			const sig = { r, s, v: 37 }; // (37-35) % 2 = 0

			const compact = Signature.toCompact(sig);

			expect(compact.length).toBe(64);
			expect(compact[32] & 0x80).toBe(0x00); // Bit 255 clear
		});

		it("should handle EIP-155 v=38 (chainId=1, yParity=1)", () => {
			const r = Hash.from(new Uint8Array(32).fill(1));
			const s = Hash.from(new Uint8Array(32).fill(0x55));
			const sig = { r, s, v: 38 }; // (38-35) % 2 = 1

			const compact = Signature.toCompact(sig);

			expect(compact.length).toBe(64);
			expect(compact[32] & 0x80).toBe(0x80); // Bit 255 set
		});
	});

	describe("specific byte patterns", () => {
		it("should correctly encode sequential r values", () => {
			const r = Hash.from(new Uint8Array(32));
			for (let i = 0; i < 32; i++) {
				r[i] = i;
			}
			const s = Hash.from(new Uint8Array(32).fill(0));
			const sig = { r, s, v: 27 };

			const compact = Signature.toCompact(sig);

			for (let i = 0; i < 32; i++) {
				expect(compact[i]).toBe(i);
			}
		});

		it("should correctly encode sequential s values", () => {
			const r = Hash.from(new Uint8Array(32).fill(0));
			const s = Hash.from(new Uint8Array(32));
			for (let i = 0; i < 32; i++) {
				s[i] = 100 + i;
			}
			const sig = { r, s, v: 27 };

			const compact = Signature.toCompact(sig);

			for (let i = 0; i < 32; i++) {
				expect(compact[32 + i]).toBe(100 + i);
			}
		});
	});

	describe("roundtrip with fromCompact (EIP-2098)", () => {
		it("should roundtrip correctly with yParity=0", () => {
			const r = Hash.from(new Uint8Array(32).fill(7));
			const s = Hash.from(new Uint8Array(32).fill(0x13)); // Use value < 0x80
			const original = { r, s, v: 27 }; // yParity = 0

			const compact = Signature.toCompact(original);
			const reconstructed = Signature.fromCompact(compact, 0); // Use yParity 0

			expect(new Uint8Array(reconstructed.r)).toEqual(
				new Uint8Array(original.r),
			);
			// s is unchanged for yParity=0 (bit 255 clear)
			expect(new Uint8Array(reconstructed.s)).toEqual(
				new Uint8Array(original.s),
			);
			expect(reconstructed.v).toBe(0); // yParity 0
		});

		it("should roundtrip correctly with yParity=1 (EIP-2098 compliant)", () => {
			const r = Hash.from(new Uint8Array(32).fill(7));
			const s = Hash.from(new Uint8Array(32).fill(0x13)); // Use value < 0x80
			const original = { r, s, v: 28 }; // yParity = 1

			const compact = Signature.toCompact(original);

			// Verify yParity is encoded in bit 255 of compact
			expect(compact[32] & 0x80).toBe(0x80);

			// fromCompact clears bit 255 from s and extracts yParity
			const reconstructed = Signature.fromCompact(compact, 1);

			// r should match
			expect(new Uint8Array(reconstructed.r)).toEqual(
				new Uint8Array(original.r),
			);
			// s should match (bit 255 cleared by fromCompact)
			expect(new Uint8Array(reconstructed.s)).toEqual(
				new Uint8Array(original.s),
			);
			expect(reconstructed.v).toBe(1);
		});

		it("should preserve yParity in EIP-2098 format", () => {
			const r = Hash.from(new Uint8Array(32).fill(1));
			const s = Hash.from(new Uint8Array(32).fill(0x55));
			const original = { r, s, v: 28 }; // yParity = 1

			const compact = Signature.toCompact(original);

			// Verify yParity is encoded in bit 255
			expect(compact[32] & 0x80).toBe(0x80);
			expect(compact[32] & 0x7f).toBe(0x55); // Original s value preserved
		});
	});

	describe("immutability", () => {
		it("should not modify signature r", () => {
			const r = Hash.from(new Uint8Array(32).fill(42));
			const s = Hash.from(new Uint8Array(32).fill(99));
			const sig = { r, s, v: 27 };
			const rCopy = new Uint8Array(r);

			Signature.toCompact(sig);

			expect(new Uint8Array(r)).toEqual(rCopy);
		});

		it("should not modify signature s", () => {
			const r = Hash.from(new Uint8Array(32).fill(42));
			const s = Hash.from(new Uint8Array(32).fill(99));
			const sig = { r, s, v: 27 };
			const sCopy = new Uint8Array(s);

			Signature.toCompact(sig);

			expect(new Uint8Array(s)).toEqual(sCopy);
		});

		it("should create independent byte array", () => {
			const r = Hash.from(new Uint8Array(32).fill(1));
			const s = Hash.from(new Uint8Array(32).fill(2));
			const sig = { r, s, v: 27 };

			const compact = Signature.toCompact(sig);
			compact[0] = 255;
			compact[32] = 255;

			expect(r[0]).toBe(1);
			expect(s[0]).toBe(2);
		});
	});

	describe("determinism", () => {
		it("should produce same result for same input", () => {
			const r = Hash.from(new Uint8Array(32).fill(7));
			const s = Hash.from(new Uint8Array(32).fill(13));
			const sig = { r, s, v: 27 };

			const compact1 = Signature.toCompact(sig);
			const compact2 = Signature.toCompact(sig);

			expect(compact1).toEqual(compact2);
		});

		it("should produce different results for different r", () => {
			const sig1 = {
				r: Hash.from(new Uint8Array(32).fill(1)),
				s: Hash.from(new Uint8Array(32).fill(2)),
				v: 27,
			};
			const sig2 = {
				r: Hash.from(new Uint8Array(32).fill(3)),
				s: Hash.from(new Uint8Array(32).fill(2)),
				v: 27,
			};

			const compact1 = Signature.toCompact(sig1);
			const compact2 = Signature.toCompact(sig2);

			expect(compact1).not.toEqual(compact2);
		});

		it("should produce different results for different s", () => {
			const sig1 = {
				r: Hash.from(new Uint8Array(32).fill(1)),
				s: Hash.from(new Uint8Array(32).fill(2)),
				v: 27,
			};
			const sig2 = {
				r: Hash.from(new Uint8Array(32).fill(1)),
				s: Hash.from(new Uint8Array(32).fill(4)),
				v: 27,
			};

			const compact1 = Signature.toCompact(sig1);
			const compact2 = Signature.toCompact(sig2);

			expect(compact1).not.toEqual(compact2);
		});
	});

	describe("comparison with toBytes", () => {
		it("should differ from toBytes due to EIP-2098 yParity encoding for v=28", () => {
			const r = Hash.from(new Uint8Array(32).fill(7));
			const s = Hash.from(new Uint8Array(32).fill(0x13));
			const sig = { r, s, v: 28 }; // yParity = 1

			const compact = Signature.toCompact(sig);
			const bytes = Signature.toBytes(sig);

			// r should match
			expect(compact.slice(0, 32)).toEqual(bytes.slice(0, 32));

			// s in compact has bit 255 set, bytes does not
			expect(compact[32] & 0x80).toBe(0x80); // yParity encoded
			expect(bytes[32] & 0x80).toBe(0x00); // No yParity encoding
		});

		it("should match toBytes for v=27 (yParity=0, no bit 255 modification)", () => {
			const r = Hash.from(new Uint8Array(32).fill(7));
			const s = Hash.from(new Uint8Array(32).fill(0x13));
			const sig = { r, s, v: 27 }; // yParity = 0

			const compact = Signature.toCompact(sig);
			const bytes = Signature.toBytes(sig);

			// For yParity=0, compact and bytes[:64] should match
			expect(compact).toEqual(bytes.slice(0, 64));
		});
	});
});

```
