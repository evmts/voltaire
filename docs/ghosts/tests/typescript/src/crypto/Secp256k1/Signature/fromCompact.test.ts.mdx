---
title: '[TS/JS] src/crypto/Secp256k1/Signature/fromCompact.test.ts'
source: 'src/crypto/Secp256k1/Signature/fromCompact.test.ts'
---

> Auto-generated from test file: src/crypto/Secp256k1/Signature/fromCompact.test.ts

```typescript
import { describe, expect, it } from "vitest";
import { InvalidSignatureError } from "../../../primitives/errors/index.js";
import * as Signature from "./index.js";

describe("Secp256k1.Signature.fromCompact", () => {
	describe("valid compact signatures", () => {
		it("should create signature from 64-byte compact format", () => {
			const compact = new Uint8Array(64);
			compact.fill(1, 0, 32); // r
			compact.fill(2, 32, 64); // s

			const sig = Signature.fromCompact(compact, 27);

			expect(sig).toHaveProperty("r");
			expect(sig).toHaveProperty("s");
			expect(sig).toHaveProperty("v");
			expect(sig.v).toBe(27);
		});

		it("should extract r component correctly", () => {
			const compact = new Uint8Array(64);
			for (let i = 0; i < 32; i++) {
				compact[i] = i;
			}
			compact.fill(0, 32, 64);

			const sig = Signature.fromCompact(compact, 27);

			expect(sig.r[0]).toBe(0);
			expect(sig.r[1]).toBe(1);
			expect(sig.r[31]).toBe(31);
		});

		it("should extract s component correctly and clear bit 255", () => {
			const compact = new Uint8Array(64);
			compact.fill(0, 0, 32);
			for (let i = 0; i < 32; i++) {
				compact[32 + i] = i; // Use 0-31 to avoid high bit
			}

			const sig = Signature.fromCompact(compact, 28);

			expect(sig.s[0]).toBe(0); // bit 255 cleared
			expect(sig.s[1]).toBe(1);
			expect(sig.s[31]).toBe(31);
		});

		it("should accept v=27", () => {
			const compact = new Uint8Array(64);
			compact.fill(1, 0, 32);
			compact.fill(2, 32, 64);

			const sig = Signature.fromCompact(compact, 27);

			expect(sig.v).toBe(27);
		});

		it("should accept v=28", () => {
			const compact = new Uint8Array(64);
			compact.fill(1, 0, 32);
			compact.fill(2, 32, 64);

			const sig = Signature.fromCompact(compact, 28);

			expect(sig.v).toBe(28);
		});

		it("should accept v=0 (recovery id format)", () => {
			const compact = new Uint8Array(64);
			compact.fill(1, 0, 32);
			compact.fill(2, 32, 64);

			const sig = Signature.fromCompact(compact, 0);

			expect(sig.v).toBe(0);
		});

		it("should accept v=1 (recovery id format)", () => {
			const compact = new Uint8Array(64);
			compact.fill(1, 0, 32);
			compact.fill(2, 32, 64);

			const sig = Signature.fromCompact(compact, 1);

			expect(sig.v).toBe(1);
		});

		it("should accept EIP-155 v values", () => {
			const compact = new Uint8Array(64);
			compact.fill(1, 0, 32);
			compact.fill(2, 32, 64);

			// Chain ID 1: v = 37 or 38
			const sig37 = Signature.fromCompact(compact, 37);
			const sig38 = Signature.fromCompact(compact, 38);

			expect(sig37.v).toBe(37);
			expect(sig38.v).toBe(38);
		});
	});

	describe("validation errors", () => {
		it("should throw InvalidSignatureError on wrong length (too short)", () => {
			const shortCompact = new Uint8Array(63);

			expect(() => Signature.fromCompact(shortCompact, 27)).toThrow(
				InvalidSignatureError,
			);
			expect(() => Signature.fromCompact(shortCompact, 27)).toThrow(
				/Compact signature must be 64 bytes, got 63/,
			);
		});

		it("should throw InvalidSignatureError on wrong length (too long)", () => {
			const longCompact = new Uint8Array(65);

			expect(() => Signature.fromCompact(longCompact, 27)).toThrow(
				InvalidSignatureError,
			);
			expect(() => Signature.fromCompact(longCompact, 27)).toThrow(
				/Compact signature must be 64 bytes, got 65/,
			);
		});

		it("should throw on empty array", () => {
			const emptyCompact = new Uint8Array(0);

			expect(() => Signature.fromCompact(emptyCompact, 27)).toThrow(
				InvalidSignatureError,
			);
		});

		it("should throw on 32-byte array", () => {
			const compact32 = new Uint8Array(32);

			expect(() => Signature.fromCompact(compact32, 27)).toThrow(
				InvalidSignatureError,
			);
		});

		it("should include error context", () => {
			const wrongCompact = new Uint8Array(60);

			try {
				Signature.fromCompact(wrongCompact, 27);
				expect.fail("Should have thrown");
			} catch (error) {
				expect(error).toBeInstanceOf(InvalidSignatureError);
				if (error instanceof InvalidSignatureError) {
					expect(error.code).toBe("INVALID_COMPACT_SIGNATURE_LENGTH");
					expect(error.context).toHaveProperty("actualLength", 60);
					expect(error.context).toHaveProperty("expectedLength", 64);
				}
			}
		});
	});

	describe("edge cases", () => {
		it("should handle all-zero r", () => {
			const compact = new Uint8Array(64);
			compact.fill(0, 0, 32);
			compact.fill(1, 32, 64);

			const sig = Signature.fromCompact(compact, 27);

			expect(sig.r.every((b) => b === 0)).toBe(true);
		});

		it("should handle all-zero s", () => {
			const compact = new Uint8Array(64);
			compact.fill(1, 0, 32);
			compact.fill(0, 32, 64);

			const sig = Signature.fromCompact(compact, 27);

			expect(sig.s.every((b) => b === 0)).toBe(true);
		});

		it("should handle max values for r and clear bit 255 from s", () => {
			const compact = new Uint8Array(64);
			compact.fill(0xff, 0, 64);

			const sig = Signature.fromCompact(compact, 27);

			expect(sig.r.every((b) => b === 0xff)).toBe(true);
			// s[0] should have bit 255 cleared (0xff -> 0x7f)
			expect(sig.s[0]).toBe(0x7f);
			expect(sig.s.slice(1).every((b) => b === 0xff)).toBe(true);
		});

		it("should handle large chain ID v values", () => {
			const compact = new Uint8Array(64);
			compact.fill(1, 0, 32);
			compact.fill(2, 32, 64);

			// Chain ID 137 (Polygon): v = 309 or 310
			const sig309 = Signature.fromCompact(compact, 309);
			const sig310 = Signature.fromCompact(compact, 310);

			expect(sig309.v).toBe(309);
			expect(sig310.v).toBe(310);
		});
	});

	describe("component slicing", () => {
		it("should create independent r slice", () => {
			const compact = new Uint8Array(64);
			compact.fill(42, 0, 32);
			compact.fill(99, 32, 64);

			const sig = Signature.fromCompact(compact, 27);

			expect(sig.r.length).toBe(32);
			sig.r[0] = 0;
			expect(compact[0]).toBe(42); // Original unchanged
		});

		it("should create independent s slice", () => {
			const compact = new Uint8Array(64);
			compact.fill(42, 0, 32);
			compact.fill(99, 32, 64);

			const sig = Signature.fromCompact(compact, 27);

			expect(sig.s.length).toBe(32);
			sig.s[0] = 0;
			expect(compact[32]).toBe(99); // Original unchanged
		});
	});

	describe("roundtrip with toCompact (EIP-2098)", () => {
		it("should roundtrip correctly for yParity=0", () => {
			// Use s values without high bit to avoid EIP-2098 encoding
			const original = new Uint8Array(64);
			for (let i = 0; i < 32; i++) {
				original[i] = i;
			}
			for (let i = 0; i < 32; i++) {
				original[32 + i] = i; // Use 0-31 to avoid high bit
			}

			const sig = Signature.fromCompact(original, 27); // yParity=0
			const reconstructed = Signature.toCompact(sig);

			expect(reconstructed).toEqual(original);
		});

		it("should roundtrip correctly for yParity=1", () => {
			// Use s values without high bit
			const original = new Uint8Array(64);
			for (let i = 0; i < 32; i++) {
				original[i] = i;
			}
			for (let i = 0; i < 32; i++) {
				original[32 + i] = i; // Use 0-31 to avoid high bit
			}

			const sig = Signature.fromCompact(original, 28); // yParity=1
			const reconstructed = Signature.toCompact(sig);

			// For yParity=1, bit 255 gets set in toCompact
			expect(reconstructed[32] & 0x80).toBe(0x80);
			// But the rest matches after clearing bit 255
			const expected = new Uint8Array(original);
			expected[32] |= 0x80;
			expect(reconstructed).toEqual(expected);
		});

		it("should preserve v through roundtrip", () => {
			const compact = new Uint8Array(64);
			compact.fill(7, 0, 32);
			compact.fill(0x13, 32, 64); // Use low value

			const sig = Signature.fromCompact(compact, 28);

			expect(sig.v).toBe(28);
		});
	});

	describe("determinism", () => {
		it("should produce same result for same input", () => {
			const compact = new Uint8Array(64);
			compact.fill(7, 0, 32);
			compact.fill(13, 32, 64);

			const sig1 = Signature.fromCompact(compact, 27);
			const sig2 = Signature.fromCompact(compact, 27);

			expect(sig1.r).toEqual(sig2.r);
			expect(sig1.s).toEqual(sig2.s);
			expect(sig1.v).toBe(sig2.v);
		});

		it("should produce different results for different v", () => {
			const compact = new Uint8Array(64);
			compact.fill(7, 0, 32);
			compact.fill(13, 32, 64);

			const sig27 = Signature.fromCompact(compact, 27);
			const sig28 = Signature.fromCompact(compact, 28);

			expect(sig27.r).toEqual(sig28.r);
			expect(sig27.s).toEqual(sig28.s);
			expect(sig27.v).not.toBe(sig28.v);
		});
	});
});

```
