---
title: '[TS/JS] src/crypto/Keccak256/from.test.ts'
source: 'src/crypto/Keccak256/from.test.ts'
---

> Auto-generated from test file: src/crypto/Keccak256/from.test.ts

```typescript
import { describe, expect, it } from "vitest";
import { from } from "./from.js";
import { hash } from "./hash.js";
import { hashHex } from "./hashHex.js";
import { hashString } from "./hashString.js";

describe("Keccak256 constructor pattern (from)", () => {
	describe("auto-detection", () => {
		it("should hash Uint8Array directly", () => {
			const input = new Uint8Array([1, 2, 3, 4, 5]);
			const result = from(input);
			const expected = hash(input);

			expect(result).toEqual(expected);
			expect(result.length).toBe(32);
		});

		it("should detect and hash hex string with 0x prefix", () => {
			const input = "0x1234abcd";
			const result = from(input);
			const expected = hashHex(input);

			expect(result).toEqual(expected);
			expect(result.length).toBe(32);
		});

		it("should detect and hash hex string without 0x prefix", () => {
			const input = "abcdef1234567890";
			const result = from(input);
			const expected = hashHex(input);

			expect(result).toEqual(expected);
			expect(result.length).toBe(32);
		});

		it("should hash regular string as UTF-8", () => {
			const input = "Hello, Voltaire!";
			const result = from(input);
			const expected = hashString(input);

			expect(result).toEqual(expected);
			expect(result.length).toBe(32);
		});

		it("should hash string with special characters as UTF-8", () => {
			const input = "hello world!";
			const result = from(input);
			const expected = hashString(input);

			expect(result).toEqual(expected);
		});
	});

	describe("hex detection edge cases", () => {
		it("should treat empty string as hex", () => {
			const result = from("");
			const expected = hashHex("");

			expect(result).toEqual(expected);
		});

		it("should treat 0x as empty hex", () => {
			const result = from("0x");
			const expected = hashHex("0x");

			expect(result).toEqual(expected);
		});

		it("should treat pure hex digits without 0x as hex", () => {
			const result = from("1234");
			const expected = hashHex("1234");

			expect(result).toEqual(expected);
		});

		it("should treat string with non-hex chars as UTF-8", () => {
			const input = "hello";
			const result = from(input);
			const expected = hashString(input);

			expect(result).toEqual(expected);
		});
	});

	describe("type validation", () => {
		it("should throw for invalid input type", () => {
			expect(() => from(123 as unknown as Uint8Array)).toThrow(
				"Invalid input type",
			);
			expect(() => from(null as unknown as Uint8Array)).toThrow(
				"Invalid input type",
			);
			expect(() => from(undefined as unknown as Uint8Array)).toThrow(
				"Invalid input type",
			);
			expect(() => from({} as unknown as Uint8Array)).toThrow(
				"Invalid input type",
			);
			expect(() => from([] as unknown as Uint8Array)).toThrow(
				"Invalid input type",
			);
		});
	});

	describe("empty inputs", () => {
		it("should hash empty Uint8Array", () => {
			const result = from(new Uint8Array(0));
			const expected = hash(new Uint8Array(0));

			expect(result).toEqual(expected);
		});

		it("should hash empty hex string", () => {
			const result = from("0x");
			const expected = hashHex("0x");

			expect(result).toEqual(expected);
		});
	});

	describe("Ethereum use cases", () => {
		it("should hash Ethereum address", () => {
			const address = "0x742d35Cc6634C0532925a3b844Bc9e7595f0bEb0";
			const result = from(address);

			expect(result.length).toBe(32);
		});

		it("should hash transaction data", () => {
			const txData =
				"0xa9059cbb000000000000000000000000742d35cc6634c0532925a3b844bc9e7595f0beb0";
			const result = from(txData);

			expect(result.length).toBe(32);
		});

		it("should hash message string", () => {
			const message = "Hello, Ethereum!";
			const result = from(message);

			expect(result.length).toBe(32);
		});

		it("should hash contract bytecode", () => {
			const bytecode =
				"0x6080604052348015600f57600080fd5b50603f80601d6000396000f3fe";
			const result = from(bytecode);

			expect(result.length).toBe(32);
		});
	});

	describe("determinism", () => {
		it("should produce same hash for same input", () => {
			const inputs = [new Uint8Array([1, 2, 3]), "0x123456", "hello"] as const;

			for (const input of inputs) {
				const hash1 = from(input);
				const hash2 = from(input);

				expect(hash1).toEqual(hash2);
			}
		});
	});

	describe("cross-validation", () => {
		it("should match hash() for Uint8Array", () => {
			const input = new Uint8Array([0x12, 0x34, 0x56]);
			const constructorResult = from(input);
			const hashResult = hash(input);

			expect(constructorResult).toEqual(hashResult);
		});

		it("should match hashHex() for hex strings", () => {
			const testCases = ["0x1234", "abcd", "0xdeadbeef"];

			for (const hex of testCases) {
				const constructorResult = from(hex);
				const hashHexResult = hashHex(hex);

				expect(constructorResult).toEqual(hashHexResult);
			}
		});

		it("should match hashString() for text strings", () => {
			const testCases = ["hello", "Hello, World!", "test message"];

			for (const str of testCases) {
				const constructorResult = from(str);
				const hashStringResult = hashString(str);

				expect(constructorResult).toEqual(hashStringResult);
			}
		});
	});

	describe("hex parsing validation", () => {
		it("should throw for odd length hex", () => {
			expect(() => from("0x123")).toThrow("even length");
		});

		it("should throw for invalid hex characters in prefixed string", () => {
			expect(() => from("0x12gh")).toThrow("Invalid hex");
		});
	});
});

```
