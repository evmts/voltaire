---
title: '[TS/JS] src/crypto/Bip39/Bip39.test.ts'
source: 'src/crypto/Bip39/Bip39.test.ts'
---

> Auto-generated from test file: src/crypto/Bip39/Bip39.test.ts

```typescript
import { describe, expect, it } from "vitest";
import * as Bip39 from "./Bip39.js";

describe("Bip39", () => {
	describe("generateMnemonic", () => {
		it("generates 12-word mnemonic from 128 bits", () => {
			const mnemonic = Bip39.generateMnemonic(128);
			const words = mnemonic.split(" ");
			expect(words).toHaveLength(12);
		});

		it("generates 15-word mnemonic from 160 bits", () => {
			const mnemonic = Bip39.generateMnemonic(160);
			const words = mnemonic.split(" ");
			expect(words).toHaveLength(15);
		});

		it("generates 18-word mnemonic from 192 bits", () => {
			const mnemonic = Bip39.generateMnemonic(192);
			const words = mnemonic.split(" ");
			expect(words).toHaveLength(18);
		});

		it("generates 21-word mnemonic from 224 bits", () => {
			const mnemonic = Bip39.generateMnemonic(224);
			const words = mnemonic.split(" ");
			expect(words).toHaveLength(21);
		});

		it("generates 24-word mnemonic from 256 bits (default)", () => {
			const mnemonic = Bip39.generateMnemonic(256);
			const words = mnemonic.split(" ");
			expect(words).toHaveLength(24);
		});

		it("generates 24-word mnemonic with no arguments (default)", () => {
			const mnemonic = Bip39.generateMnemonic();
			const words = mnemonic.split(" ");
			expect(words).toHaveLength(24);
		});

		it("generates valid mnemonic that passes validation", () => {
			const mnemonic = Bip39.generateMnemonic(256);
			expect(Bip39.validateMnemonic(mnemonic)).toBe(true);
		});

		it("generates different mnemonics on each call", () => {
			const mnemonic1 = Bip39.generateMnemonic(256);
			const mnemonic2 = Bip39.generateMnemonic(256);
			expect(mnemonic1).not.toBe(mnemonic2);
		});

		it("throws on invalid entropy - not multiple of 32", () => {
			expect(() => Bip39.generateMnemonic(100)).toThrow();
		});

		it("throws on invalid entropy - too small", () => {
			expect(() => Bip39.generateMnemonic(64)).toThrow();
		});

		it("throws on invalid entropy - too large", () => {
			expect(() => Bip39.generateMnemonic(512)).toThrow();
		});

		it("throws on zero entropy", () => {
			expect(() => Bip39.generateMnemonic(0)).toThrow();
		});

		it("throws on negative entropy", () => {
			expect(() => Bip39.generateMnemonic(-128)).toThrow();
		});

		it("generates unique mnemonics - no collisions in 100 generations", () => {
			const mnemonics = new Set<string>();
			for (let i = 0; i < 100; i++) {
				mnemonics.add(Bip39.generateMnemonic(256));
			}
			expect(mnemonics.size).toBe(100);
		});

		it("all generated words are valid BIP39 words", () => {
			const mnemonic = Bip39.generateMnemonic(256);
			expect(Bip39.validateMnemonic(mnemonic)).toBe(true);
		});

		it("generates mnemonics with valid checksums", () => {
			for (let i = 0; i < 10; i++) {
				const mnemonic = Bip39.generateMnemonic(128);
				expect(Bip39.validateMnemonic(mnemonic)).toBe(true);
			}
		});
	});

	describe("validateMnemonic", () => {
		it("validates correct 12-word mnemonic", () => {
			const mnemonic =
				"abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon about";
			expect(Bip39.validateMnemonic(mnemonic)).toBe(true);
		});

		it("validates correct 15-word mnemonic", () => {
			const mnemonic =
				"door lift capital buyer kid degree beach thunder jelly today shy venture echo just ridge";
			expect(Bip39.validateMnemonic(mnemonic)).toBe(true);
		});

		it("validates correct 18-word mnemonic", () => {
			const mnemonic =
				"sauce town great expand divert fine desert season remember orient suit morning glimpse weekend remind crystal shine effort";
			expect(Bip39.validateMnemonic(mnemonic)).toBe(true);
		});

		it("validates correct 21-word mnemonic", () => {
			const mnemonic =
				"thunder merit visa pelican marriage number olive evil photo chase jump essay rabbit milk harbor fix wear spot bulk promote jelly";
			expect(Bip39.validateMnemonic(mnemonic)).toBe(true);
		});

		it("validates correct 24-word mnemonic", () => {
			const mnemonic =
				"abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon art";
			expect(Bip39.validateMnemonic(mnemonic)).toBe(true);
		});

		it("rejects mnemonic with invalid checksum (last word wrong)", () => {
			const mnemonic =
				"abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon";
			expect(Bip39.validateMnemonic(mnemonic)).toBe(false);
		});

		it("rejects mnemonic with invalid checksum (first word wrong)", () => {
			const mnemonic =
				"zoo abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon about";
			expect(Bip39.validateMnemonic(mnemonic)).toBe(false);
		});

		it("rejects mnemonic with invalid checksum (middle word wrong)", () => {
			const mnemonic =
				"abandon abandon abandon abandon abandon zoo abandon abandon abandon abandon abandon about";
			expect(Bip39.validateMnemonic(mnemonic)).toBe(false);
		});

		it("rejects mnemonic with 11 words", () => {
			const mnemonic =
				"abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon";
			expect(Bip39.validateMnemonic(mnemonic)).toBe(false);
		});

		it("rejects mnemonic with 13 words", () => {
			const mnemonic =
				"abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon about abandon";
			expect(Bip39.validateMnemonic(mnemonic)).toBe(false);
		});

		it("rejects mnemonic with 23 words", () => {
			const mnemonic =
				"abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon";
			expect(Bip39.validateMnemonic(mnemonic)).toBe(false);
		});

		it("rejects mnemonic with 25 words", () => {
			const mnemonic =
				"abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon art abandon";
			expect(Bip39.validateMnemonic(mnemonic)).toBe(false);
		});

		it("rejects mnemonic with unknown word", () => {
			const mnemonic =
				"abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon notaword";
			expect(Bip39.validateMnemonic(mnemonic)).toBe(false);
		});

		it("rejects empty mnemonic", () => {
			expect(Bip39.validateMnemonic("")).toBe(false);
		});

		it("rejects single word", () => {
			expect(Bip39.validateMnemonic("abandon")).toBe(false);
		});

		it("rejects mnemonic with typo", () => {
			const mnemonic =
				"abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abot";
			expect(Bip39.validateMnemonic(mnemonic)).toBe(false);
		});

		it("handles case insensitivity - uppercase", () => {
			const mnemonic =
				"ABANDON ABANDON ABANDON ABANDON ABANDON ABANDON ABANDON ABANDON ABANDON ABANDON ABANDON ABOUT";
			const normalized = mnemonic.toLowerCase();
			expect(Bip39.validateMnemonic(normalized)).toBe(true);
		});

		it("handles case insensitivity - mixed case", () => {
			const mnemonic =
				"AbAnDoN aBaNdOn abandon ABANDON Abandon abandon abandon abandon abandon abandon abandon about";
			const normalized = mnemonic.toLowerCase();
			expect(Bip39.validateMnemonic(normalized)).toBe(true);
		});

		it("handles leading whitespace", () => {
			const mnemonic =
				"  abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon about";
			const normalized = mnemonic.trim();
			expect(Bip39.validateMnemonic(normalized)).toBe(true);
		});

		it("handles trailing whitespace", () => {
			const mnemonic =
				"abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon about  ";
			const normalized = mnemonic.trim();
			expect(Bip39.validateMnemonic(normalized)).toBe(true);
		});

		it("handles multiple spaces between words", () => {
			const mnemonic =
				"abandon  abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon about";
			const normalized = mnemonic.replace(/\s+/g, " ");
			expect(Bip39.validateMnemonic(normalized)).toBe(true);
		});

		it("handles tabs as separators", () => {
			const mnemonic =
				"abandon\tabandon\tabandon\tabandon\tabandon\tabandon\tabandon\tabandon\tabandon\tabandon\tabandon\tabout";
			const normalized = mnemonic.replace(/\t/g, " ");
			expect(Bip39.validateMnemonic(normalized)).toBe(true);
		});

		it("handles newlines as separators", () => {
			const mnemonic =
				"abandon\nabandon\nabandon\nabandon\nabandon\nabandon\nabandon\nabandon\nabandon\nabandon\nabandon\nabout";
			const normalized = mnemonic.replace(/\n/g, " ");
			expect(Bip39.validateMnemonic(normalized)).toBe(true);
		});

		it("rejects mnemonic with numbers", () => {
			const mnemonic =
				"abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon 123";
			expect(Bip39.validateMnemonic(mnemonic)).toBe(false);
		});

		it("rejects mnemonic with special characters", () => {
			const mnemonic =
				"abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon @#$";
			expect(Bip39.validateMnemonic(mnemonic)).toBe(false);
		});

		it("rejects mnemonic with emoji", () => {
			const mnemonic =
				"abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon ðŸ˜€";
			expect(Bip39.validateMnemonic(mnemonic)).toBe(false);
		});

		it("validates generated mnemonics of all sizes", () => {
			const sizes = [128, 160, 192, 224, 256];
			for (const size of sizes) {
				const mnemonic = Bip39.generateMnemonic(size);
				expect(Bip39.validateMnemonic(mnemonic)).toBe(true);
			}
		});
	});

	describe("assertValidMnemonic", () => {
		it("does not throw for valid 12-word mnemonic", () => {
			const mnemonic =
				"abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon about";
			expect(() => Bip39.assertValidMnemonic(mnemonic)).not.toThrow();
		});

		it("does not throw for valid 24-word mnemonic", () => {
			const mnemonic =
				"abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon art";
			expect(() => Bip39.assertValidMnemonic(mnemonic)).not.toThrow();
		});

		it("throws for invalid checksum", () => {
			const mnemonic =
				"abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon";
			expect(() => Bip39.assertValidMnemonic(mnemonic)).toThrow();
		});

		it("throws for invalid word count", () => {
			const mnemonic = "abandon abandon abandon abandon abandon";
			expect(() => Bip39.assertValidMnemonic(mnemonic)).toThrow();
		});

		it("throws for unknown word", () => {
			const mnemonic =
				"abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon notaword";
			expect(() => Bip39.assertValidMnemonic(mnemonic)).toThrow();
		});

		it("throws with clear error message for invalid checksum", () => {
			const mnemonic =
				"abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon";
			expect(() => Bip39.assertValidMnemonic(mnemonic)).toThrow(
				"Invalid BIP-39 mnemonic phrase",
			);
		});

		it("throws for empty mnemonic", () => {
			expect(() => Bip39.assertValidMnemonic("")).toThrow();
		});

		it("does not throw for generated mnemonics", () => {
			const mnemonic = Bip39.generateMnemonic(256);
			expect(() => Bip39.assertValidMnemonic(mnemonic)).not.toThrow();
		});
	});

	describe("mnemonicToSeed", () => {
		// Official BIP-39 test vectors
		it("derives seed from mnemonic without passphrase (vector 1)", async () => {
			const mnemonic =
				"abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon about";
			const seed = await Bip39.mnemonicToSeed(mnemonic);

			expect(seed).toBeInstanceOf(Uint8Array);
			expect(seed.length).toBe(64);

			const expectedHex =
				"5eb00bbddcf069084889a8ab9155568165f5c453ccb85e70811aaed6f6da5fc19a5ac40b389cd370d086206dec8aa6c43daea6690f20ad3d8d48b2d2ce9e38e4";
			const actualHex = [...seed]
				.map((b) => b.toString(16).padStart(2, "0"))
				.join("");
			expect(actualHex).toBe(expectedHex);
		});

		it("derives seed from mnemonic with empty string passphrase", async () => {
			const mnemonic =
				"abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon about";
			const seed = await Bip39.mnemonicToSeed(mnemonic, "");

			expect(seed).toBeInstanceOf(Uint8Array);
			expect(seed.length).toBe(64);

			const expectedHex =
				"5eb00bbddcf069084889a8ab9155568165f5c453ccb85e70811aaed6f6da5fc19a5ac40b389cd370d086206dec8aa6c43daea6690f20ad3d8d48b2d2ce9e38e4";
			const actualHex = [...seed]
				.map((b) => b.toString(16).padStart(2, "0"))
				.join("");
			expect(actualHex).toBe(expectedHex);
		});

		it("derives seed from mnemonic with passphrase (vector 2)", async () => {
			const mnemonic =
				"abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon about";
			const seed = await Bip39.mnemonicToSeed(mnemonic, "TREZOR");

			expect(seed).toBeInstanceOf(Uint8Array);
			expect(seed.length).toBe(64);

			const expectedHex =
				"c55257c360c07c72029aebc1b53c05ed0362ada38ead3e3e9efa3708e53495531f09a6987599d18264c1e1c92f2cf141630c7a3c4ab7c81b2f001698e7463b04";
			const actualHex = [...seed]
				.map((b) => b.toString(16).padStart(2, "0"))
				.join("");
			expect(actualHex).toBe(expectedHex);
		});

		it("derives seed from 12-word mnemonic without passphrase (vector 3)", async () => {
			const mnemonic =
				"legal winner thank year wave sausage worth useful legal winner thank yellow";
			const seed = await Bip39.mnemonicToSeed(mnemonic);

			expect(seed.length).toBe(64);

			// Actual derived seed from @scure/bip39 (verified correct implementation)
			const expectedHex =
				"878386efb78845b3355bd15ea4d39ef97d179cb712b77d5c12b6be415fffeffe5f377ba02bf3f8544ab800b955e51fbff09828f682052a20faa6addbbddfb096";
			const actualHex = [...seed]
				.map((b) => b.toString(16).padStart(2, "0"))
				.join("");
			expect(actualHex).toBe(expectedHex);
		});

		it("derives seed from mnemonic with japanese characters in passphrase", async () => {
			const mnemonic =
				"abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon about";
			const seed = await Bip39.mnemonicToSeed(
				mnemonic,
				"ãã‚¬ãƒãƒ´ã‚¡ã±ã°ãã‚žã¡ã¢åäººåè‰²",
			);

			expect(seed).toBeInstanceOf(Uint8Array);
			expect(seed.length).toBe(64);

			// Note: This is just testing that it handles Unicode without crashing
			// The actual expected value would need to be verified against a reference implementation
			const actualHex = [...seed]
				.map((b) => b.toString(16).padStart(2, "0"))
				.join("");
			expect(actualHex.length).toBe(128);
		});

		it("derives seed from 12-word mnemonic (vector 4)", async () => {
			const mnemonic =
				"letter advice cage absurd amount doctor acoustic avoid letter advice cage above";
			const seed = await Bip39.mnemonicToSeed(mnemonic);

			expect(seed.length).toBe(64);

			// Actual derived seed from @scure/bip39 (verified correct implementation)
			const expectedHex =
				"77d6be9708c8218738934f84bbbb78a2e048ca007746cb764f0673e4b1812d176bbb173e1a291f31cf633f1d0bad7d3cf071c30e98cd0688b5bcce65ecaceb36";
			const actualHex = [...seed]
				.map((b) => b.toString(16).padStart(2, "0"))
				.join("");
			expect(actualHex).toBe(expectedHex);
		});

		it("derives seed with ASCII passphrase", async () => {
			const mnemonic =
				"abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon about";
			const passphrase = "password123";
			const seed = await Bip39.mnemonicToSeed(mnemonic, passphrase);

			expect(seed).toBeInstanceOf(Uint8Array);
			expect(seed.length).toBe(64);
		});

		it("derives seed with Unicode passphrase (emoji)", async () => {
			const mnemonic =
				"abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon about";
			const passphrase = "ðŸ”’ðŸ”‘ðŸ’Ž";
			const seed = await Bip39.mnemonicToSeed(mnemonic, passphrase);

			expect(seed).toBeInstanceOf(Uint8Array);
			expect(seed.length).toBe(64);
		});

		it("derives seed with Unicode passphrase (Chinese)", async () => {
			const mnemonic =
				"abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon about";
			const passphrase = "å¯†ç æµ‹è¯•";
			const seed = await Bip39.mnemonicToSeed(mnemonic, passphrase);

			expect(seed).toBeInstanceOf(Uint8Array);
			expect(seed.length).toBe(64);
		});

		it("derives seed with Unicode passphrase (Arabic)", async () => {
			const mnemonic =
				"abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon about";
			const passphrase = "ÙƒÙ„Ù…Ø© Ø§Ù„Ø³Ø±";
			const seed = await Bip39.mnemonicToSeed(mnemonic, passphrase);

			expect(seed).toBeInstanceOf(Uint8Array);
			expect(seed.length).toBe(64);
		});

		it("derives seed with passphrase containing spaces", async () => {
			const mnemonic =
				"abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon about";
			const passphrase = "my secure passphrase";
			const seed = await Bip39.mnemonicToSeed(mnemonic, passphrase);

			expect(seed).toBeInstanceOf(Uint8Array);
			expect(seed.length).toBe(64);
		});

		it("derives seed with special characters in passphrase", async () => {
			const mnemonic =
				"abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon about";
			const passphrase = "!@#$%^&*()_+-=[]{}|;:',.<>?/~`";
			const seed = await Bip39.mnemonicToSeed(mnemonic, passphrase);

			expect(seed).toBeInstanceOf(Uint8Array);
			expect(seed.length).toBe(64);
		});

		it("derives seed with very long passphrase (1KB+)", async () => {
			const mnemonic =
				"abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon about";
			const passphrase = "a".repeat(2000);
			const seed = await Bip39.mnemonicToSeed(mnemonic, passphrase);

			expect(seed).toBeInstanceOf(Uint8Array);
			expect(seed.length).toBe(64);
		});

		it("throws error for invalid mnemonic", async () => {
			const mnemonic =
				"abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon";
			await expect(Bip39.mnemonicToSeed(mnemonic)).rejects.toThrow();
		});

		it("derives different seeds for same mnemonic with different passphrases", async () => {
			const mnemonic =
				"abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon about";
			const seed1 = await Bip39.mnemonicToSeed(mnemonic, "");
			const seed2 = await Bip39.mnemonicToSeed(mnemonic, "password");

			expect(seed1).not.toEqual(seed2);
		});

		it("empty passphrase vs undefined produces same result", async () => {
			const mnemonic =
				"abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon about";
			const seed1 = await Bip39.mnemonicToSeed(mnemonic, "");
			const seed2 = await Bip39.mnemonicToSeed(mnemonic);

			expect(seed1).toEqual(seed2);
		});

		it("is deterministic - same inputs produce same seed", async () => {
			const mnemonic =
				"abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon about";
			const seed1 = await Bip39.mnemonicToSeed(mnemonic, "TREZOR");
			const seed2 = await Bip39.mnemonicToSeed(mnemonic, "TREZOR");

			expect(seed1).toEqual(seed2);
		});

		it("derives seed from 15-word mnemonic", async () => {
			const mnemonic =
				"door lift capital buyer kid degree beach thunder jelly today shy venture echo just ridge";
			const seed = await Bip39.mnemonicToSeed(mnemonic);

			expect(seed).toBeInstanceOf(Uint8Array);
			expect(seed.length).toBe(64);
		});

		it("derives seed from 18-word mnemonic", async () => {
			const mnemonic =
				"sauce town great expand divert fine desert season remember orient suit morning glimpse weekend remind crystal shine effort";
			const seed = await Bip39.mnemonicToSeed(mnemonic);

			expect(seed).toBeInstanceOf(Uint8Array);
			expect(seed.length).toBe(64);
		});

		it("derives seed from 21-word mnemonic", async () => {
			const mnemonic =
				"thunder merit visa pelican marriage number olive evil photo chase jump essay rabbit milk harbor fix wear spot bulk promote jelly";
			const seed = await Bip39.mnemonicToSeed(mnemonic);

			expect(seed).toBeInstanceOf(Uint8Array);
			expect(seed.length).toBe(64);
		});

		it("null passphrase behaves like undefined", async () => {
			const mnemonic =
				"abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon about";
			const seed1 = await Bip39.mnemonicToSeed(mnemonic);
			const seed2 = await Bip39.mnemonicToSeed(mnemonic, undefined);

			expect(seed1).toEqual(seed2);
		});
	});

	describe("mnemonicToSeedSync", () => {
		it("derives seed synchronously", () => {
			const mnemonic =
				"abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon about";
			const seed = Bip39.mnemonicToSeedSync(mnemonic);

			expect(seed).toBeInstanceOf(Uint8Array);
			expect(seed.length).toBe(64);

			const expectedHex =
				"5eb00bbddcf069084889a8ab9155568165f5c453ccb85e70811aaed6f6da5fc19a5ac40b389cd370d086206dec8aa6c43daea6690f20ad3d8d48b2d2ce9e38e4";
			const actualHex = [...seed]
				.map((b) => b.toString(16).padStart(2, "0"))
				.join("");
			expect(actualHex).toBe(expectedHex);
		});

		it("derives seed with passphrase synchronously", () => {
			const mnemonic =
				"abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon about";
			const seed = Bip39.mnemonicToSeedSync(mnemonic, "TREZOR");

			expect(seed).toBeInstanceOf(Uint8Array);
			expect(seed.length).toBe(64);

			const expectedHex =
				"c55257c360c07c72029aebc1b53c05ed0362ada38ead3e3e9efa3708e53495531f09a6987599d18264c1e1c92f2cf141630c7a3c4ab7c81b2f001698e7463b04";
			const actualHex = [...seed]
				.map((b) => b.toString(16).padStart(2, "0"))
				.join("");
			expect(actualHex).toBe(expectedHex);
		});

		it("produces same result as async version - no passphrase", async () => {
			const mnemonic =
				"abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon about";

			const seedAsync = await Bip39.mnemonicToSeed(mnemonic);
			const seedSync = Bip39.mnemonicToSeedSync(mnemonic);

			expect(seedSync).toEqual(seedAsync);
		});

		it("produces same result as async version - with passphrase", async () => {
			const mnemonic =
				"abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon about";
			const passphrase = "TREZOR";

			const seedAsync = await Bip39.mnemonicToSeed(mnemonic, passphrase);
			const seedSync = Bip39.mnemonicToSeedSync(mnemonic, passphrase);

			expect(seedSync).toEqual(seedAsync);
		});

		it("produces same result as async version - Unicode passphrase", async () => {
			const mnemonic =
				"abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon about";
			const passphrase = "å¯†ç æµ‹è¯•ðŸ”‘";

			const seedAsync = await Bip39.mnemonicToSeed(mnemonic, passphrase);
			const seedSync = Bip39.mnemonicToSeedSync(mnemonic, passphrase);

			expect(seedSync).toEqual(seedAsync);
		});

		it("throws for invalid mnemonic", () => {
			const mnemonic =
				"abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon";
			expect(() => Bip39.mnemonicToSeedSync(mnemonic)).toThrow();
		});

		it("is deterministic", () => {
			const mnemonic =
				"abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon about";
			const seed1 = Bip39.mnemonicToSeedSync(mnemonic, "password");
			const seed2 = Bip39.mnemonicToSeedSync(mnemonic, "password");

			expect(seed1).toEqual(seed2);
		});

		it("produces different seeds for different passphrases", () => {
			const mnemonic =
				"abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon about";
			const seed1 = Bip39.mnemonicToSeedSync(mnemonic, "password1");
			const seed2 = Bip39.mnemonicToSeedSync(mnemonic, "password2");

			expect(seed1).not.toEqual(seed2);
		});

		it("handles empty passphrase", () => {
			const mnemonic =
				"abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon about";
			const seed1 = Bip39.mnemonicToSeedSync(mnemonic, "");
			const seed2 = Bip39.mnemonicToSeedSync(mnemonic);

			expect(seed1).toEqual(seed2);
		});

		it("handles very long passphrase", () => {
			const mnemonic =
				"abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon about";
			const passphrase = "x".repeat(1000);
			const seed = Bip39.mnemonicToSeedSync(mnemonic, passphrase);

			expect(seed).toBeInstanceOf(Uint8Array);
			expect(seed.length).toBe(64);
		});
	});

	describe("getWordCount", () => {
		it("returns 12 for 128 bits", () => {
			expect(Bip39.getWordCount(128)).toBe(12);
		});

		it("returns 15 for 160 bits", () => {
			expect(Bip39.getWordCount(160)).toBe(15);
		});

		it("returns 18 for 192 bits", () => {
			expect(Bip39.getWordCount(192)).toBe(18);
		});

		it("returns 21 for 224 bits", () => {
			expect(Bip39.getWordCount(224)).toBe(21);
		});

		it("returns 24 for 256 bits", () => {
			expect(Bip39.getWordCount(256)).toBe(24);
		});

		it("throws on invalid entropy - not multiple of 32", () => {
			expect(() => Bip39.getWordCount(100)).toThrow();
		});

		it("throws on invalid entropy - too small", () => {
			expect(() => Bip39.getWordCount(64)).toThrow();
		});

		it("throws on invalid entropy - too large", () => {
			expect(() => Bip39.getWordCount(512)).toThrow();
		});

		it("throws on zero entropy", () => {
			expect(() => Bip39.getWordCount(0)).toThrow();
		});

		it("throws on negative entropy", () => {
			expect(() => Bip39.getWordCount(-128)).toThrow();
		});
	});

	describe("getEntropyBits", () => {
		it("returns 128 for 12 words", () => {
			expect(Bip39.getEntropyBits(12)).toBe(128);
		});

		it("returns 160 for 15 words", () => {
			expect(Bip39.getEntropyBits(15)).toBe(160);
		});

		it("returns 192 for 18 words", () => {
			expect(Bip39.getEntropyBits(18)).toBe(192);
		});

		it("returns 224 for 21 words", () => {
			expect(Bip39.getEntropyBits(21)).toBe(224);
		});

		it("returns 256 for 24 words", () => {
			expect(Bip39.getEntropyBits(24)).toBe(256);
		});

		it("throws on invalid word count - 11 words", () => {
			expect(() => Bip39.getEntropyBits(11)).toThrow();
		});

		it("throws on invalid word count - 13 words", () => {
			expect(() => Bip39.getEntropyBits(13)).toThrow();
		});

		it("throws on invalid word count - 25 words", () => {
			expect(() => Bip39.getEntropyBits(25)).toThrow();
		});

		it("throws on zero words", () => {
			expect(() => Bip39.getEntropyBits(0)).toThrow();
		});

		it("throws on negative word count", () => {
			expect(() => Bip39.getEntropyBits(-12)).toThrow();
		});

		it("throws on very large word count", () => {
			expect(() => Bip39.getEntropyBits(1000)).toThrow();
		});
	});

	describe("entropyToMnemonic", () => {
		it("converts 16 bytes (128 bits) to 12-word mnemonic", () => {
			const entropy = new Uint8Array(16).fill(0);
			const mnemonic = Bip39.entropyToMnemonic(entropy);
			const words = mnemonic.split(" ");
			expect(words).toHaveLength(12);
			expect(Bip39.validateMnemonic(mnemonic)).toBe(true);
		});

		it("converts 20 bytes (160 bits) to 15-word mnemonic", () => {
			const entropy = new Uint8Array(20).fill(0);
			const mnemonic = Bip39.entropyToMnemonic(entropy);
			const words = mnemonic.split(" ");
			expect(words).toHaveLength(15);
			expect(Bip39.validateMnemonic(mnemonic)).toBe(true);
		});

		it("converts 24 bytes (192 bits) to 18-word mnemonic", () => {
			const entropy = new Uint8Array(24).fill(0);
			const mnemonic = Bip39.entropyToMnemonic(entropy);
			const words = mnemonic.split(" ");
			expect(words).toHaveLength(18);
			expect(Bip39.validateMnemonic(mnemonic)).toBe(true);
		});

		it("converts 28 bytes (224 bits) to 21-word mnemonic", () => {
			const entropy = new Uint8Array(28).fill(0);
			const mnemonic = Bip39.entropyToMnemonic(entropy);
			const words = mnemonic.split(" ");
			expect(words).toHaveLength(21);
			expect(Bip39.validateMnemonic(mnemonic)).toBe(true);
		});

		it("converts 32 bytes (256 bits) to 24-word mnemonic", () => {
			const entropy = new Uint8Array(32).fill(0);
			const mnemonic = Bip39.entropyToMnemonic(entropy);
			const words = mnemonic.split(" ");
			expect(words).toHaveLength(24);
			expect(Bip39.validateMnemonic(mnemonic)).toBe(true);
		});

		it("throws on invalid entropy length - 15 bytes", () => {
			const entropy = new Uint8Array(15);
			expect(() => Bip39.entropyToMnemonic(entropy)).toThrow();
		});

		it("throws on invalid entropy length - 17 bytes", () => {
			const entropy = new Uint8Array(17);
			expect(() => Bip39.entropyToMnemonic(entropy)).toThrow();
		});

		it("throws on invalid entropy length - 33 bytes", () => {
			const entropy = new Uint8Array(33);
			expect(() => Bip39.entropyToMnemonic(entropy)).toThrow();
		});

		it("handles all-zero entropy (16 bytes)", () => {
			const entropy = new Uint8Array(16).fill(0);
			const mnemonic = Bip39.entropyToMnemonic(entropy);
			expect(mnemonic).toBe(
				"abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon about",
			);
		});

		it("handles all-zero entropy (32 bytes)", () => {
			const entropy = new Uint8Array(32).fill(0);
			const mnemonic = Bip39.entropyToMnemonic(entropy);
			expect(mnemonic).toBe(
				"abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon art",
			);
		});

		it("handles max entropy - all 0xFF (16 bytes)", () => {
			const entropy = new Uint8Array(16).fill(0xff);
			const mnemonic = Bip39.entropyToMnemonic(entropy);
			expect(Bip39.validateMnemonic(mnemonic)).toBe(true);
			expect(mnemonic.split(" ")).toHaveLength(12);
		});

		it("handles max entropy - all 0xFF (32 bytes)", () => {
			const entropy = new Uint8Array(32).fill(0xff);
			const mnemonic = Bip39.entropyToMnemonic(entropy);
			expect(Bip39.validateMnemonic(mnemonic)).toBe(true);
			expect(mnemonic.split(" ")).toHaveLength(24);
		});

		it("is deterministic - same entropy produces same mnemonic", () => {
			const entropy = new Uint8Array(16);
			for (let i = 0; i < 16; i++) {
				entropy[i] = i;
			}
			const mnemonic1 = Bip39.entropyToMnemonic(entropy);
			const mnemonic2 = Bip39.entropyToMnemonic(entropy);
			expect(mnemonic1).toBe(mnemonic2);
		});

		it("produces different mnemonics for different entropy", () => {
			const entropy1 = new Uint8Array(16).fill(0);
			const entropy2 = new Uint8Array(16).fill(1);
			const mnemonic1 = Bip39.entropyToMnemonic(entropy1);
			const mnemonic2 = Bip39.entropyToMnemonic(entropy2);
			expect(mnemonic1).not.toBe(mnemonic2);
		});

		it("handles sequential entropy", () => {
			const entropy = new Uint8Array(16);
			for (let i = 0; i < 16; i++) {
				entropy[i] = i;
			}
			const mnemonic = Bip39.entropyToMnemonic(entropy);
			expect(Bip39.validateMnemonic(mnemonic)).toBe(true);
		});

		it("all generated mnemonics are valid", () => {
			for (let i = 0; i < 10; i++) {
				const entropy = new Uint8Array(16);
				crypto.getRandomValues(entropy);
				const mnemonic = Bip39.entropyToMnemonic(entropy);
				expect(Bip39.validateMnemonic(mnemonic)).toBe(true);
			}
		});
	});

	describe("BIP39 test vectors", () => {
		it("test vector 1: abandon x11 + about", async () => {
			const mnemonic =
				"abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon about";
			expect(Bip39.validateMnemonic(mnemonic)).toBe(true);

			const seed = await Bip39.mnemonicToSeed(mnemonic);
			const expectedHex =
				"5eb00bbddcf069084889a8ab9155568165f5c453ccb85e70811aaed6f6da5fc19a5ac40b389cd370d086206dec8aa6c43daea6690f20ad3d8d48b2d2ce9e38e4";
			const actualHex = [...seed]
				.map((b) => b.toString(16).padStart(2, "0"))
				.join("");
			expect(actualHex).toBe(expectedHex);
		});

		it("test vector 2: legal winner thank year wave sausage worth useful legal winner thank yellow", async () => {
			const mnemonic =
				"legal winner thank year wave sausage worth useful legal winner thank yellow";
			expect(Bip39.validateMnemonic(mnemonic)).toBe(true);

			const seed = await Bip39.mnemonicToSeed(mnemonic);
			const expectedHex =
				"878386efb78845b3355bd15ea4d39ef97d179cb712b77d5c12b6be415fffeffe5f377ba02bf3f8544ab800b955e51fbff09828f682052a20faa6addbbddfb096";
			const actualHex = [...seed]
				.map((b) => b.toString(16).padStart(2, "0"))
				.join("");
			expect(actualHex).toBe(expectedHex);
		});

		it("test vector 3: letter advice cage absurd amount doctor acoustic avoid letter advice cage above", async () => {
			const mnemonic =
				"letter advice cage absurd amount doctor acoustic avoid letter advice cage above";
			expect(Bip39.validateMnemonic(mnemonic)).toBe(true);

			const seed = await Bip39.mnemonicToSeed(mnemonic);
			const expectedHex =
				"77d6be9708c8218738934f84bbbb78a2e048ca007746cb764f0673e4b1812d176bbb173e1a291f31cf633f1d0bad7d3cf071c30e98cd0688b5bcce65ecaceb36";
			const actualHex = [...seed]
				.map((b) => b.toString(16).padStart(2, "0"))
				.join("");
			expect(actualHex).toBe(expectedHex);
		});

		it("test vector 4: all-zero entropy produces abandon x11 + about", () => {
			const entropy = new Uint8Array(16).fill(0);
			const mnemonic = Bip39.entropyToMnemonic(entropy);
			expect(mnemonic).toBe(
				"abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon about",
			);
		});

		it("test vector 5: all-zero entropy (32 bytes) produces abandon x23 + art", () => {
			const entropy = new Uint8Array(32).fill(0);
			const mnemonic = Bip39.entropyToMnemonic(entropy);
			expect(mnemonic).toBe(
				"abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon art",
			);
		});
	});

	describe("Unicode normalization", () => {
		it("handles NFKD normalized passphrase", async () => {
			const mnemonic =
				"abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon about";
			const passphrase = "Ã‘oÃ±o";
			const seed = await Bip39.mnemonicToSeed(mnemonic, passphrase);

			expect(seed).toBeInstanceOf(Uint8Array);
			expect(seed.length).toBe(64);
		});

		it("handles combining characters in passphrase", async () => {
			const mnemonic =
				"abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon about";
			const passphrase = "e\u0301"; // Ã© as combining chars
			const seed = await Bip39.mnemonicToSeed(mnemonic, passphrase);

			expect(seed).toBeInstanceOf(Uint8Array);
			expect(seed.length).toBe(64);
		});

		it("handles emoji normalization", async () => {
			const mnemonic =
				"abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon about";
			const passphrase = "ðŸ‘¨â€ðŸ‘©â€ðŸ‘§â€ðŸ‘¦"; // Family emoji with ZWJ
			const seed = await Bip39.mnemonicToSeed(mnemonic, passphrase);

			expect(seed).toBeInstanceOf(Uint8Array);
			expect(seed.length).toBe(64);
		});
	});

	describe("integration tests", () => {
		it("full wallet flow: generate -> validate -> seed", async () => {
			const mnemonic = Bip39.generateMnemonic(256);
			expect(Bip39.validateMnemonic(mnemonic)).toBe(true);

			const seed = await Bip39.mnemonicToSeed(mnemonic, "password");
			expect(seed).toBeInstanceOf(Uint8Array);
			expect(seed.length).toBe(64);
		});

		it("recovery flow: entropy -> mnemonic -> seed", async () => {
			const entropy = new Uint8Array(32);
			crypto.getRandomValues(entropy);

			const mnemonic = Bip39.entropyToMnemonic(entropy);
			expect(Bip39.validateMnemonic(mnemonic)).toBe(true);

			const seed = await Bip39.mnemonicToSeed(mnemonic);
			expect(seed).toBeInstanceOf(Uint8Array);
			expect(seed.length).toBe(64);
		});

		it("backup/restore: mnemonic can be stored and recovered", async () => {
			const original = Bip39.generateMnemonic(256);
			const seed1 = await Bip39.mnemonicToSeed(original, "passphrase");

			// Simulate storage/retrieval
			const stored = original;
			const recovered = stored;

			const seed2 = await Bip39.mnemonicToSeed(recovered, "passphrase");
			expect(seed1).toEqual(seed2);
		});

		it("all word sizes produce valid seeds", async () => {
			const sizes = [128, 160, 192, 224, 256];
			for (const size of sizes) {
				const mnemonic = Bip39.generateMnemonic(size);
				expect(Bip39.validateMnemonic(mnemonic)).toBe(true);

				const seed = await Bip39.mnemonicToSeed(mnemonic);
				expect(seed.length).toBe(64);
			}
		});
	});

	describe("edge cases and security", () => {
		it("validates mnemonic case-insensitively", () => {
			const mnemonic =
				"ABANDON ABANDON ABANDON ABANDON ABANDON ABANDON ABANDON ABANDON ABANDON ABANDON ABANDON ABOUT";
			const normalized = mnemonic.toLowerCase();
			expect(Bip39.validateMnemonic(normalized)).toBe(true);
		});

		it("seed derivation is deterministic", async () => {
			const mnemonic =
				"abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon about";
			const seed1 = await Bip39.mnemonicToSeed(mnemonic);
			const seed2 = await Bip39.mnemonicToSeed(mnemonic);
			expect(seed1).toEqual(seed2);
		});

		it("empty passphrase and no passphrase produce same result", async () => {
			const mnemonic =
				"abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon about";
			const seed1 = await Bip39.mnemonicToSeed(mnemonic, "");
			const seed2 = await Bip39.mnemonicToSeed(mnemonic);
			expect(seed1).toEqual(seed2);
		});

		it("different passphrases produce different seeds", async () => {
			const mnemonic =
				"abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon about";
			const seeds = await Promise.all([
				Bip39.mnemonicToSeed(mnemonic, "pass1"),
				Bip39.mnemonicToSeed(mnemonic, "pass2"),
				Bip39.mnemonicToSeed(mnemonic, "pass3"),
			]);

			expect(seeds[0]).not.toEqual(seeds[1]);
			expect(seeds[1]).not.toEqual(seeds[2]);
			expect(seeds[0]).not.toEqual(seeds[2]);
		});

		it("checksum prevents single bit flip", () => {
			const mnemonic =
				"abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon about";
			expect(Bip39.validateMnemonic(mnemonic)).toBe(true);

			// Change last word (checksum)
			const corrupted =
				"abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon";
			expect(Bip39.validateMnemonic(corrupted)).toBe(false);
		});

		it("validates word order matters", () => {
			const mnemonic1 =
				"legal winner thank year wave sausage worth useful legal winner thank yellow";
			const mnemonic2 =
				"winner legal thank year wave sausage worth useful legal winner thank yellow";

			expect(Bip39.validateMnemonic(mnemonic1)).toBe(true);
			expect(Bip39.validateMnemonic(mnemonic2)).toBe(false);
		});

		it("generates cryptographically random mnemonics", () => {
			const mnemonics = new Set<string>();
			for (let i = 0; i < 1000; i++) {
				mnemonics.add(Bip39.generateMnemonic(128));
			}
			// All should be unique with overwhelming probability
			expect(mnemonics.size).toBe(1000);
		});
	});
});

```
