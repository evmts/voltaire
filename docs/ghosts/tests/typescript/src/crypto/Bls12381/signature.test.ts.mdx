---
title: '[TS/JS] src/crypto/Bls12381/signature.test.ts'
source: 'src/crypto/Bls12381/signature.test.ts'
---

> Auto-generated from test file: src/crypto/Bls12381/signature.test.ts

```typescript
/**
 * BLS12-381 Signature Tests
 *
 * Tests for high-level BLS signature operations.
 */

import { describe, expect, it } from "vitest";
import {
	aggregate,
	aggregatePublicKeys,
	aggregateVerify,
	Bls12381,
	batchVerify,
	derivePublicKey,
	fastAggregateVerify,
	isValidPrivateKey,
	randomPrivateKey,
	sign,
	verify,
} from "./Bls12381.js";
import { InvalidScalarError, SignatureError } from "./errors.js";

describe("BLS12-381 Signatures", () => {
	describe("randomPrivateKey", () => {
		it("should generate a valid 32-byte private key", () => {
			const privateKey = randomPrivateKey();
			expect(privateKey).toBeInstanceOf(Uint8Array);
			expect(privateKey.length).toBe(32);
		});

		it("should generate different keys each time", () => {
			const pk1 = randomPrivateKey();
			const pk2 = randomPrivateKey();
			expect(pk1).not.toEqual(pk2);
		});

		it("should generate valid private keys", () => {
			for (let i = 0; i < 10; i++) {
				const pk = randomPrivateKey();
				expect(isValidPrivateKey(pk)).toBe(true);
			}
		});
	});

	describe("isValidPrivateKey", () => {
		it("should accept valid private keys", () => {
			const pk = randomPrivateKey();
			expect(isValidPrivateKey(pk)).toBe(true);
		});

		it("should reject zero key", () => {
			const zeroKey = new Uint8Array(32);
			expect(isValidPrivateKey(zeroKey)).toBe(false);
		});

		it("should reject wrong length", () => {
			const shortKey = new Uint8Array(31);
			const longKey = new Uint8Array(33);
			expect(isValidPrivateKey(shortKey)).toBe(false);
			expect(isValidPrivateKey(longKey)).toBe(false);
		});

		it("should reject non-Uint8Array", () => {
			// @ts-expect-error testing invalid input
			expect(isValidPrivateKey("not a key")).toBe(false);
			// @ts-expect-error testing invalid input
			expect(isValidPrivateKey(null)).toBe(false);
		});
	});

	describe("derivePublicKey", () => {
		it("should derive a 96-byte compressed public key (G2)", () => {
			const privateKey = randomPrivateKey();
			const publicKey = derivePublicKey(privateKey);
			expect(publicKey).toBeInstanceOf(Uint8Array);
			// Short signatures scheme: public keys are G2 points (96 bytes)
			expect(publicKey.length).toBe(96);
		});

		it("should derive same public key for same private key", () => {
			const privateKey = randomPrivateKey();
			const pk1 = derivePublicKey(privateKey);
			const pk2 = derivePublicKey(privateKey);
			expect(pk1).toEqual(pk2);
		});

		it("should throw for invalid private key", () => {
			expect(() => derivePublicKey(new Uint8Array(32))).toThrow(
				InvalidScalarError,
			);
		});

		it("should throw for wrong length key", () => {
			const key = new Uint8Array(31);
			key.fill(1);
			expect(() => derivePublicKey(key)).toThrow(InvalidScalarError);
		});

		it("should throw InvalidScalarError with correct error.name", () => {
			try {
				derivePublicKey(new Uint8Array(32));
				expect.fail("Should have thrown");
			} catch (e) {
				expect(e).toBeInstanceOf(InvalidScalarError);
				expect((e as InvalidScalarError).name).toBe("InvalidScalarError");
			}
		});
	});

	describe("sign", () => {
		it("should produce a 48-byte signature (G1)", () => {
			const privateKey = randomPrivateKey();
			const message = new TextEncoder().encode("Hello, Ethereum!");
			const signature = sign(message, privateKey);
			expect(signature).toBeInstanceOf(Uint8Array);
			// Short signatures scheme: signatures are G1 points (48 bytes)
			expect(signature.length).toBe(48);
		});

		it("should produce different signatures for different messages", () => {
			const privateKey = randomPrivateKey();
			const msg1 = new TextEncoder().encode("Message 1");
			const msg2 = new TextEncoder().encode("Message 2");
			const sig1 = sign(msg1, privateKey);
			const sig2 = sign(msg2, privateKey);
			expect(sig1).not.toEqual(sig2);
		});

		it("should produce same signature for same message and key", () => {
			const privateKey = randomPrivateKey();
			const message = new TextEncoder().encode("Deterministic");
			const sig1 = sign(message, privateKey);
			const sig2 = sign(message, privateKey);
			expect(sig1).toEqual(sig2);
		});

		it("should throw for zero private key", () => {
			const message = new TextEncoder().encode("Test");
			expect(() => sign(message, new Uint8Array(32))).toThrow(
				InvalidScalarError,
			);
		});

		it("should throw InvalidScalarError for sign with correct error.name", () => {
			const message = new TextEncoder().encode("Test");
			try {
				sign(message, new Uint8Array(32));
				expect.fail("Should have thrown");
			} catch (e) {
				expect(e).toBeInstanceOf(InvalidScalarError);
				expect((e as InvalidScalarError).name).toBe("InvalidScalarError");
			}
		});
	});

	describe("verify", () => {
		it("should verify valid signature", () => {
			const privateKey = randomPrivateKey();
			const publicKey = derivePublicKey(privateKey);
			const message = new TextEncoder().encode("Hello!");
			const signature = sign(message, privateKey);

			const isValid = verify(signature, message, publicKey);
			expect(isValid).toBe(true);
		});

		it("should reject signature with wrong message", () => {
			const privateKey = randomPrivateKey();
			const publicKey = derivePublicKey(privateKey);
			const message = new TextEncoder().encode("Original");
			const signature = sign(message, privateKey);

			const wrongMessage = new TextEncoder().encode("Tampered");
			const isValid = verify(signature, wrongMessage, publicKey);
			expect(isValid).toBe(false);
		});

		it("should reject signature with wrong public key", () => {
			const privateKey1 = randomPrivateKey();
			const privateKey2 = randomPrivateKey();
			const publicKey2 = derivePublicKey(privateKey2);
			const message = new TextEncoder().encode("Test");
			const signature = sign(message, privateKey1);

			const isValid = verify(signature, message, publicKey2);
			expect(isValid).toBe(false);
		});

		it("should return false for corrupted signature", () => {
			const privateKey = randomPrivateKey();
			const publicKey = derivePublicKey(privateKey);
			const message = new TextEncoder().encode("Test");
			const signature = sign(message, privateKey);

			// Corrupt the signature
			const corrupted = new Uint8Array(signature);
			corrupted[0] ^= 0xff;

			const isValid = verify(corrupted, message, publicKey);
			expect(isValid).toBe(false);
		});
	});

	describe("aggregate", () => {
		it("should aggregate multiple signatures", () => {
			const message = new TextEncoder().encode("Vote yes");
			const pk1 = randomPrivateKey();
			const pk2 = randomPrivateKey();
			const sig1 = sign(message, pk1);
			const sig2 = sign(message, pk2);

			const aggSig = aggregate([sig1, sig2]);
			expect(aggSig).toBeInstanceOf(Uint8Array);
			// Short signatures: aggregated sig is still G1 (48 bytes)
			expect(aggSig.length).toBe(48);
		});

		it("should throw for empty array", () => {
			expect(() => aggregate([])).toThrow(SignatureError);
		});

		it("should throw SignatureError with correct error.name for empty aggregate", () => {
			try {
				aggregate([]);
				expect.fail("Should have thrown");
			} catch (e) {
				expect(e).toBeInstanceOf(SignatureError);
				expect((e as SignatureError).name).toBe("SignatureError");
			}
		});

		it("should handle single signature", () => {
			const pk = randomPrivateKey();
			const message = new TextEncoder().encode("Single");
			const sig = sign(message, pk);

			const aggSig = aggregate([sig]);
			expect(aggSig).toBeInstanceOf(Uint8Array);
		});
	});

	describe("aggregatePublicKeys", () => {
		it("should aggregate multiple public keys", () => {
			const pk1 = randomPrivateKey();
			const pk2 = randomPrivateKey();
			const pubKey1 = derivePublicKey(pk1);
			const pubKey2 = derivePublicKey(pk2);

			const aggPubKey = aggregatePublicKeys([pubKey1, pubKey2]);
			expect(aggPubKey).toBeInstanceOf(Uint8Array);
			// Short signatures: public keys are G2 (96 bytes)
			expect(aggPubKey.length).toBe(96);
		});

		it("should throw for empty array", () => {
			expect(() => aggregatePublicKeys([])).toThrow(SignatureError);
		});
	});

	describe("aggregateVerify", () => {
		it("should verify aggregated signature (same message)", () => {
			const message = new TextEncoder().encode("Block attestation");

			const pk1 = randomPrivateKey();
			const pk2 = randomPrivateKey();
			const pubKey1 = derivePublicKey(pk1);
			const pubKey2 = derivePublicKey(pk2);

			const sig1 = sign(message, pk1);
			const sig2 = sign(message, pk2);
			const aggSig = aggregate([sig1, sig2]);

			const isValid = aggregateVerify(aggSig, message, [pubKey1, pubKey2]);
			expect(isValid).toBe(true);
		});

		it("should reject invalid aggregated signature", () => {
			const message = new TextEncoder().encode("Test");

			const pk1 = randomPrivateKey();
			const pk2 = randomPrivateKey();
			const pk3 = randomPrivateKey(); // Different key
			const pubKey1 = derivePublicKey(pk1);
			const _pubKey2 = derivePublicKey(pk2);
			const pubKey3 = derivePublicKey(pk3);

			const sig1 = sign(message, pk1);
			const sig2 = sign(message, pk2);
			const aggSig = aggregate([sig1, sig2]);

			// Verify with wrong public keys
			const isValid = aggregateVerify(aggSig, message, [pubKey1, pubKey3]);
			expect(isValid).toBe(false);
		});
	});

	describe("fastAggregateVerify", () => {
		it("should verify with pre-aggregated public key", () => {
			const message = new TextEncoder().encode("Fast verify");

			const pk1 = randomPrivateKey();
			const pk2 = randomPrivateKey();
			const pubKey1 = derivePublicKey(pk1);
			const pubKey2 = derivePublicKey(pk2);

			const sig1 = sign(message, pk1);
			const sig2 = sign(message, pk2);
			const aggSig = aggregate([sig1, sig2]);
			const aggPubKey = aggregatePublicKeys([pubKey1, pubKey2]);

			const isValid = fastAggregateVerify(aggSig, message, aggPubKey);
			expect(isValid).toBe(true);
		});
	});

	describe("batchVerify", () => {
		it("should verify aggregated signature (different messages)", () => {
			const pk1 = randomPrivateKey();
			const pk2 = randomPrivateKey();
			const pubKey1 = derivePublicKey(pk1);
			const pubKey2 = derivePublicKey(pk2);

			const msg1 = new TextEncoder().encode("Message 1");
			const msg2 = new TextEncoder().encode("Message 2");

			const sig1 = sign(msg1, pk1);
			const sig2 = sign(msg2, pk2);
			const aggSig = aggregate([sig1, sig2]);

			const isValid = batchVerify(aggSig, [msg1, msg2], [pubKey1, pubKey2]);
			expect(isValid).toBe(true);
		});

		it("should reject with wrong message order", () => {
			const pk1 = randomPrivateKey();
			const pk2 = randomPrivateKey();
			const pubKey1 = derivePublicKey(pk1);
			const pubKey2 = derivePublicKey(pk2);

			const msg1 = new TextEncoder().encode("Message 1");
			const msg2 = new TextEncoder().encode("Message 2");

			const sig1 = sign(msg1, pk1);
			const sig2 = sign(msg2, pk2);
			const aggSig = aggregate([sig1, sig2]);

			// Wrong order of messages
			const isValid = batchVerify(aggSig, [msg2, msg1], [pubKey1, pubKey2]);
			expect(isValid).toBe(false);
		});

		it("should throw for mismatched array lengths", () => {
			const pk1 = randomPrivateKey();
			const pubKey1 = derivePublicKey(pk1);
			const msg1 = new TextEncoder().encode("Msg");
			const sig1 = sign(msg1, pk1);

			expect(() => batchVerify(sig1, [msg1, msg1], [pubKey1])).toThrow(
				SignatureError,
			);
		});
	});

	describe("Bls12381 namespace", () => {
		it("should have all high-level functions", () => {
			expect(typeof Bls12381.sign).toBe("function");
			expect(typeof Bls12381.verify).toBe("function");
			expect(typeof Bls12381.aggregate).toBe("function");
			expect(typeof Bls12381.aggregatePublicKeys).toBe("function");
			expect(typeof Bls12381.aggregateVerify).toBe("function");
			expect(typeof Bls12381.batchVerify).toBe("function");
			expect(typeof Bls12381.fastAggregateVerify).toBe("function");
			expect(typeof Bls12381.derivePublicKey).toBe("function");
			expect(typeof Bls12381.randomPrivateKey).toBe("function");
			expect(typeof Bls12381.isValidPrivateKey).toBe("function");
		});

		it("should have low-level curve operations", () => {
			expect(Bls12381.G1).toBeDefined();
			expect(Bls12381.G2).toBeDefined();
			expect(Bls12381.Fp).toBeDefined();
			expect(Bls12381.Fr).toBeDefined();
			expect(Bls12381.Pairing).toBeDefined();
		});

		it("should work with namespace pattern", () => {
			const privateKey = Bls12381.randomPrivateKey();
			const publicKey = Bls12381.derivePublicKey(privateKey);
			const message = new TextEncoder().encode("Namespace test");
			const signature = Bls12381.sign(message, privateKey);
			const isValid = Bls12381.verify(signature, message, publicKey);
			expect(isValid).toBe(true);
		});
	});
});

```
