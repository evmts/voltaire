---
title: '[TS/JS] src/crypto/Keystore/Keystore.test.ts'
source: 'src/crypto/Keystore/Keystore.test.ts'
---

> Auto-generated from test file: src/crypto/Keystore/Keystore.test.ts

```typescript
import { describe, expect, it } from "vitest";
import * as PrivateKey from "../../primitives/PrivateKey/index.js";
import * as Keystore from "./index.js";

describe("Keystore", () => {
	describe("encrypt / decrypt", () => {
		it("encrypts and decrypts with scrypt (default)", async () => {
			const privateKey = PrivateKey.from(
				"0x0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef",
			);
			const password = "test-password";

			const keystore = await Keystore.encrypt(privateKey, password);
			const decrypted = Keystore.decrypt(keystore, password);

			expect(decrypted).toEqual(privateKey);
		}, 30000);

		it("encrypts and decrypts with pbkdf2", async () => {
			const privateKey = PrivateKey.from(
				"0x0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef",
			);
			const password = "test-password";

			const keystore = await Keystore.encrypt(privateKey, password, {
				kdf: "pbkdf2",
			});
			const decrypted = Keystore.decrypt(keystore, password);

			expect(decrypted).toEqual(privateKey);
		}, 30000);

		it("round-trip with different passwords", async () => {
			const privateKey = PrivateKey.from(
				"0xabcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789",
			);

			const keystore1 = await Keystore.encrypt(privateKey, "password1");
			const keystore2 = await Keystore.encrypt(privateKey, "password2");

			expect(keystore1.crypto.ciphertext).not.toBe(keystore2.crypto.ciphertext);

			const decrypted1 = Keystore.decrypt(keystore1, "password1");
			const decrypted2 = Keystore.decrypt(keystore2, "password2");

			expect(decrypted1).toEqual(privateKey);
			expect(decrypted2).toEqual(privateKey);
		}, 60000);

		it("throws on wrong password (scrypt)", async () => {
			const privateKey = PrivateKey.from(
				"0x0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef",
			);

			const keystore = await Keystore.encrypt(privateKey, "correct-password");

			expect(() => Keystore.decrypt(keystore, "wrong-password")).toThrow(
				Keystore.InvalidMacError,
			);
		}, 30000);

		it("throws on wrong password (pbkdf2)", async () => {
			const privateKey = PrivateKey.from(
				"0x0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef",
			);

			const keystore = await Keystore.encrypt(privateKey, "correct-password", {
				kdf: "pbkdf2",
			});

			expect(() => Keystore.decrypt(keystore, "wrong-password")).toThrow(
				Keystore.InvalidMacError,
			);
		}, 30000);

		it("handles empty password", async () => {
			const privateKey = PrivateKey.from(
				"0x0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef",
			);

			const keystore = await Keystore.encrypt(privateKey, "");
			const decrypted = Keystore.decrypt(keystore, "");

			expect(decrypted).toEqual(privateKey);
		}, 30000);

		it("handles special characters in password", async () => {
			const privateKey = PrivateKey.from(
				"0x0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef",
			);
			const password = "pāšẅörd!@#$%^&*()[]{}|<>?/~`";

			const keystore = await Keystore.encrypt(privateKey, password);
			const decrypted = Keystore.decrypt(keystore, password);

			expect(decrypted).toEqual(privateKey);
		});

		it("handles very long password", async () => {
			const privateKey = PrivateKey.from(
				"0x0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef",
			);
			const password = "a".repeat(1000);

			const keystore = await Keystore.encrypt(privateKey, password);
			const decrypted = Keystore.decrypt(keystore, password);

			expect(decrypted).toEqual(privateKey);
		});

		it("uses custom UUID when provided", async () => {
			const privateKey = PrivateKey.from(
				"0x0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef",
			);
			const customUuid = "12345678-1234-1234-1234-123456789abc";

			const keystore = await Keystore.encrypt(privateKey, "password", {
				uuid: customUuid,
			});

			expect(keystore.id).toBe(customUuid);
		});

		it("generates different UUIDs for each encryption", async () => {
			const privateKey = PrivateKey.from(
				"0x0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef",
			);

			const keystore1 = await Keystore.encrypt(privateKey, "password");
			const keystore2 = await Keystore.encrypt(privateKey, "password");

			expect(keystore1.id).not.toBe(keystore2.id);
		});

		it("uses custom scrypt parameters", async () => {
			const privateKey = PrivateKey.from(
				"0x0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef",
			);

			const keystore = await Keystore.encrypt(privateKey, "password", {
				scryptN: 16384,
				scryptR: 4,
				scryptP: 2,
			});

			const params = keystore.crypto.kdfparams as Keystore.ScryptParams;
			expect(params.n).toBe(16384);
			expect(params.r).toBe(4);
			expect(params.p).toBe(2);

			const decrypted = Keystore.decrypt(keystore, "password");
			expect(decrypted).toEqual(privateKey);
		});

		it("uses custom pbkdf2 iterations", async () => {
			const privateKey = PrivateKey.from(
				"0x0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef",
			);

			const keystore = await Keystore.encrypt(privateKey, "password", {
				kdf: "pbkdf2",
				pbkdf2C: 100000,
			});

			const params = keystore.crypto.kdfparams as Keystore.Pbkdf2Params;
			expect(params.c).toBe(100000);
			expect(params.prf).toBe("hmac-sha256");

			const decrypted = Keystore.decrypt(keystore, "password");
			expect(decrypted).toEqual(privateKey);
		});
	});

	describe("keystore structure", () => {
		it("has correct version", async () => {
			const privateKey = PrivateKey.from(
				"0x0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef",
			);

			const keystore = await Keystore.encrypt(privateKey, "password");

			expect(keystore.version).toBe(3);
		});

		it("has correct cipher", async () => {
			const privateKey = PrivateKey.from(
				"0x0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef",
			);

			const keystore = await Keystore.encrypt(privateKey, "password");

			expect(keystore.crypto.cipher).toBe("aes-128-ctr");
		});

		it("has valid UUID format", async () => {
			const privateKey = PrivateKey.from(
				"0x0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef",
			);

			const keystore = await Keystore.encrypt(privateKey, "password");

			expect(keystore.id).toMatch(
				/^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/,
			);
		});

		it("has 16-byte IV (32 hex chars)", async () => {
			const privateKey = PrivateKey.from(
				"0x0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef",
			);

			const keystore = await Keystore.encrypt(privateKey, "password");

			expect(keystore.crypto.cipherparams.iv).toHaveLength(32);
			expect(keystore.crypto.cipherparams.iv).toMatch(/^[0-9a-f]{32}$/);
		});

		it("has 32-byte salt (64 hex chars)", async () => {
			const privateKey = PrivateKey.from(
				"0x0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef",
			);

			const keystore = await Keystore.encrypt(privateKey, "password");

			const params = keystore.crypto.kdfparams as Keystore.ScryptParams;
			expect(params.salt).toHaveLength(64);
			expect(params.salt).toMatch(/^[0-9a-f]{64}$/);
		});

		it("has 32-byte MAC (64 hex chars)", async () => {
			const privateKey = PrivateKey.from(
				"0x0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef",
			);

			const keystore = await Keystore.encrypt(privateKey, "password");

			expect(keystore.crypto.mac).toHaveLength(64);
			expect(keystore.crypto.mac).toMatch(/^[0-9a-f]{64}$/);
		});

		it("has 32-byte ciphertext (64 hex chars) for 32-byte private key", async () => {
			const privateKey = PrivateKey.from(
				"0x0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef",
			);

			const keystore = await Keystore.encrypt(privateKey, "password");

			expect(keystore.crypto.ciphertext).toHaveLength(64);
			expect(keystore.crypto.ciphertext).toMatch(/^[0-9a-f]{64}$/);
		});
	});

	describe("error handling", () => {
		it("throws on invalid scrypt N (not power of 2) during encrypt", async () => {
			const privateKey = PrivateKey.from(
				"0x0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef",
			);

			// N = 1000 is not a power of 2
			await expect(
				Keystore.encrypt(privateKey, "password", { scryptN: 1000 }),
			).rejects.toThrow(Keystore.InvalidScryptNError);

			// N = 3 is not a power of 2
			await expect(
				Keystore.encrypt(privateKey, "password", { scryptN: 3 }),
			).rejects.toThrow(Keystore.InvalidScryptNError);

			// N = 0 is not valid
			await expect(
				Keystore.encrypt(privateKey, "password", { scryptN: 0 }),
			).rejects.toThrow(Keystore.InvalidScryptNError);

			// N = -1 is not valid
			await expect(
				Keystore.encrypt(privateKey, "password", { scryptN: -1 }),
			).rejects.toThrow(Keystore.InvalidScryptNError);
		});

		it("throws on invalid scrypt N during decrypt", async () => {
			// Craft a keystore with invalid N
			const invalidKeystore: Keystore.KeystoreV3 = {
				version: 3,
				id: "test-id",
				crypto: {
					cipher: "aes-128-ctr",
					ciphertext:
						"0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef",
					cipherparams: {
						iv: "0123456789abcdef0123456789abcdef",
					},
					kdf: "scrypt",
					kdfparams: {
						dklen: 32,
						n: 1000, // Invalid: not a power of 2
						r: 8,
						p: 1,
						salt: "0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef",
					},
					mac: "0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef",
				},
			};

			expect(() => Keystore.decrypt(invalidKeystore, "password")).toThrow(
				Keystore.InvalidScryptNError,
			);
		});

		it("throws on invalid PBKDF2 iterations (zero) during encrypt", async () => {
			const privateKey = PrivateKey.from(
				"0x0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef",
			);

			await expect(
				Keystore.encrypt(privateKey, "password", { kdf: "pbkdf2", pbkdf2C: 0 }),
			).rejects.toThrow(Keystore.InvalidPbkdf2IterationsError);
		});

		it("throws on invalid PBKDF2 iterations (negative) during encrypt", async () => {
			const privateKey = PrivateKey.from(
				"0x0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef",
			);

			await expect(
				Keystore.encrypt(privateKey, "password", {
					kdf: "pbkdf2",
					pbkdf2C: -1,
				}),
			).rejects.toThrow(Keystore.InvalidPbkdf2IterationsError);
		});

		it("throws on invalid PBKDF2 iterations (non-integer) during encrypt", async () => {
			const privateKey = PrivateKey.from(
				"0x0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef",
			);

			await expect(
				Keystore.encrypt(privateKey, "password", {
					kdf: "pbkdf2",
					pbkdf2C: 1.5,
				}),
			).rejects.toThrow(Keystore.InvalidPbkdf2IterationsError);
		});

		it("throws on invalid PBKDF2 iterations during decrypt", async () => {
			// Craft a keystore with invalid iteration count
			const invalidKeystore: Keystore.KeystoreV3 = {
				version: 3,
				id: "test-id",
				crypto: {
					cipher: "aes-128-ctr",
					ciphertext:
						"0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef",
					cipherparams: {
						iv: "0123456789abcdef0123456789abcdef",
					},
					kdf: "pbkdf2",
					kdfparams: {
						c: 0, // Invalid: must be positive
						dklen: 32,
						prf: "hmac-sha256",
						salt: "0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef",
					},
					mac: "0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef",
				},
			};

			expect(() => Keystore.decrypt(invalidKeystore, "password")).toThrow(
				Keystore.InvalidPbkdf2IterationsError,
			);
		});

		it("accepts valid PBKDF2 iteration counts", async () => {
			const privateKey = PrivateKey.from(
				"0x0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef",
			);

			// Test various valid iteration counts
			const validCValues = [1, 100, 1000, 10000, 100000];

			for (const c of validCValues) {
				const keystore = await Keystore.encrypt(privateKey, "password", {
					kdf: "pbkdf2",
					pbkdf2C: c,
				});
				const params = keystore.crypto.kdfparams as Keystore.Pbkdf2Params;
				expect(params.c).toBe(c);
			}
		});

		it("accepts valid power of 2 scrypt N values", async () => {
			const privateKey = PrivateKey.from(
				"0x0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef",
			);

			// Test various valid powers of 2
			// Note: @noble/hashes/scrypt requires N >= 2
			const validNValues = [2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048];

			for (const n of validNValues) {
				const keystore = await Keystore.encrypt(privateKey, "password", {
					scryptN: n,
					scryptR: 1,
					scryptP: 1,
				});
				const params = keystore.crypto.kdfparams as Keystore.ScryptParams;
				expect(params.n).toBe(n);
			}
		});

		it("throws on unsupported version", async () => {
			const invalidKeystore = {
				version: 2,
				id: "test",
				crypto: {
					cipher: "aes-128-ctr",
					ciphertext: "abc",
					cipherparams: { iv: "def" },
					kdf: "scrypt" as const,
					kdfparams: {
						dklen: 32,
						n: 262144,
						r: 8,
						p: 1,
						salt: "ghi",
					},
					mac: "jkl",
				},
			};

			try {
				Keystore.decrypt(
					invalidKeystore as unknown as Keystore.KeystoreV3,
					"password",
				);
				expect.fail("Expected UnsupportedVersionError");
			} catch (e) {
				expect(e).toBeInstanceOf(Keystore.UnsupportedVersionError);
				expect((e as Error).name).toBe("UnsupportedVersionError");
			}
		});

		it("throws on unsupported KDF", async () => {
			const invalidKeystore = {
				version: 3,
				id: "test",
				crypto: {
					cipher: "aes-128-ctr",
					ciphertext: "abc",
					cipherparams: { iv: "def" },
					// biome-ignore lint/suspicious/noExplicitAny: testing invalid input
					kdf: "unknown" as any,
					// biome-ignore lint/suspicious/noExplicitAny: testing invalid input
					kdfparams: {} as any,
					mac: "jkl",
				},
			};

			try {
				Keystore.decrypt(invalidKeystore, "password");
				expect.fail("Expected UnsupportedKdfError");
			} catch (e) {
				expect(e).toBeInstanceOf(Keystore.UnsupportedKdfError);
				expect((e as Error).name).toBe("UnsupportedKdfError");
			}
		});

		it("throws on corrupted ciphertext", async () => {
			const privateKey = PrivateKey.from(
				"0x0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef",
			);

			const keystore = await Keystore.encrypt(privateKey, "password");

			// Corrupt ciphertext
			keystore.crypto.ciphertext = `${keystore.crypto.ciphertext.slice(0, -2)}ff`;

			try {
				Keystore.decrypt(keystore, "password");
				expect.fail("Expected InvalidMacError");
			} catch (e) {
				expect(e).toBeInstanceOf(Keystore.InvalidMacError);
				expect((e as Error).name).toBe("InvalidMacError");
			}
		});

		it("throws on corrupted MAC", async () => {
			const privateKey = PrivateKey.from(
				"0x0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef",
			);

			const keystore = await Keystore.encrypt(privateKey, "password");

			// Corrupt MAC
			keystore.crypto.mac = `${keystore.crypto.mac.slice(0, -2)}ff`;

			try {
				Keystore.decrypt(keystore, "password");
				expect.fail("Expected InvalidMacError");
			} catch (e) {
				expect(e).toBeInstanceOf(Keystore.InvalidMacError);
				expect((e as Error).name).toBe("InvalidMacError");
			}
		});

		it("corrupted IV produces different plaintext", async () => {
			const privateKey = PrivateKey.from(
				"0x0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef",
			);

			const keystore = await Keystore.encrypt(privateKey, "password");

			// Corrupt IV - MAC will still pass since it doesn't include IV,
			// but decryption will produce garbage
			keystore.crypto.cipherparams.iv = `${keystore.crypto.cipherparams.iv.slice(0, -2)}ff`;

			const decrypted = Keystore.decrypt(keystore, "password");
			expect(decrypted).not.toEqual(privateKey);
		});
	});

	describe("known test vectors", () => {
		it.skip("decrypts known scrypt keystore", async () => {
			// Note: Replace placeholder with a real test vector
			// from the Web3 Secret Storage spec or a generated one
			const keystore: Keystore.KeystoreV3 = {
				version: 3,
				id: "3198bc9c-6672-5ab3-d995-4942343ae5b6",
				crypto: {
					cipher: "aes-128-ctr",
					ciphertext:
						"d172bf743a674da9cdad04534d56926ef8358534d458fffccd4e6ad2fbde479c",
					cipherparams: {
						iv: "83dbcc02d8ccb40e466191a123791e0e",
					},
					kdf: "scrypt",
					kdfparams: {
						dklen: 32,
						n: 262144,
						r: 8,
						p: 1,
						salt: "ab0c7876052600dd703518d6fc3fe8984592145b591fc8fb5c6d43190334ba19",
					},
					mac: "2103ac29920d71da29f15d75b4a16dbe95cfd7ff8faea1056c33131d846e3097",
				},
			};

			const password = "testpassword";
			const expectedPrivateKey =
				"0x7a28b5ba57c53603b0b07b56bba752f7784bf506fa95edc395f5cf6c7514fe9d";

			const decrypted = Keystore.decrypt(keystore, password);
			const decryptedHex = `0x${Array.from(decrypted)
				.map((b) => b.toString(16).padStart(2, "0"))
				.join("")}`;

			expect(decryptedHex).toBe(expectedPrivateKey);
		});

		it("decrypts known pbkdf2 keystore", async () => {
			// Known test vector from Web3 Secret Storage spec
			const keystore: Keystore.KeystoreV3 = {
				version: 3,
				id: "e13b209c-3b2f-4327-bab0-3bef2e51630d",
				crypto: {
					cipher: "aes-128-ctr",
					ciphertext:
						"0144c9e4e11a5de372f7e53f3dbd87ec6c78df80f3f0b1ceb2159c9a06e3d7ac",
					cipherparams: {
						iv: "cecacd85e9cb89788b5aab2f93361233",
					},
					kdf: "pbkdf2",
					kdfparams: {
						c: 262144,
						dklen: 32,
						prf: "hmac-sha256",
						salt: "dc9e4a98886738bd8aae134a1f89aaa5a502c3fbd10e336136d4d5fe47448ad6",
					},
					mac: "27b98c8676dc6619d077453b38db645a4c7c6e2df2f8e5c5c6f8e4e2c5f7e3e9",
				},
			};

			const password = "testpassword";

			// This should decrypt successfully (if MAC matches)
			// Note: This is a synthetic test vector, not from official spec
			expect(() => Keystore.decrypt(keystore, password)).not.toThrow(
				Keystore.DecryptionError,
			);
		});
	});

	describe("determinism", () => {
		it("produces same keystore with fixed salt and IV (scrypt)", async () => {
			const privateKey = PrivateKey.from(
				"0x0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef",
			);
			const password = "password";

			const salt = new Uint8Array(32).fill(1);
			const iv = new Uint8Array(16).fill(2);
			const uuid = "12345678-1234-1234-1234-123456789abc";

			const keystore1 = await Keystore.encrypt(privateKey, password, {
				salt,
				iv,
				uuid,
			});
			const keystore2 = await Keystore.encrypt(privateKey, password, {
				salt,
				iv,
				uuid,
			});

			expect(keystore1).toEqual(keystore2);
		});

		it("produces same keystore with fixed salt and IV (pbkdf2)", async () => {
			const privateKey = PrivateKey.from(
				"0x0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef",
			);
			const password = "password";

			const salt = new Uint8Array(32).fill(1);
			const iv = new Uint8Array(16).fill(2);
			const uuid = "12345678-1234-1234-1234-123456789abc";

			const keystore1 = await Keystore.encrypt(privateKey, password, {
				kdf: "pbkdf2",
				salt,
				iv,
				uuid,
			});
			const keystore2 = await Keystore.encrypt(privateKey, password, {
				kdf: "pbkdf2",
				salt,
				iv,
				uuid,
			});

			expect(keystore1).toEqual(keystore2);
		});

		it("produces different keystores with different salts", async () => {
			const privateKey = PrivateKey.from(
				"0x0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef",
			);
			const password = "password";

			const salt1 = new Uint8Array(32).fill(1);
			const salt2 = new Uint8Array(32).fill(2);

			const keystore1 = await Keystore.encrypt(privateKey, password, {
				salt: salt1,
			});
			const keystore2 = await Keystore.encrypt(privateKey, password, {
				salt: salt2,
			});

			expect(keystore1.crypto.ciphertext).not.toBe(keystore2.crypto.ciphertext);
		});
	});

	describe("security", () => {
		it(
			"different IVs produce different ciphertexts",
			{ timeout: 30000 },
			async () => {
				const privateKey = PrivateKey.from(
					"0x0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef",
				);
				const password = "password";
				const salt = new Uint8Array(32).fill(1);

				const iv1 = new Uint8Array(16).fill(1);
				const iv2 = new Uint8Array(16).fill(2);

				// Use low scrypt parameters for faster tests
				const keystore1 = await Keystore.encrypt(privateKey, password, {
					salt,
					iv: iv1,
					scryptN: 1024,
					scryptR: 1,
					scryptP: 1,
				});
				const keystore2 = await Keystore.encrypt(privateKey, password, {
					salt,
					iv: iv2,
					scryptN: 1024,
					scryptR: 1,
					scryptP: 1,
				});

				expect(keystore1.crypto.ciphertext).not.toBe(
					keystore2.crypto.ciphertext,
				);

				const decrypted1 = Keystore.decrypt(keystore1, password);
				const decrypted2 = Keystore.decrypt(keystore2, password);

				expect(decrypted1).toEqual(privateKey);
				expect(decrypted2).toEqual(privateKey);
			},
		);

		it(
			"constant-time MAC comparison (no early exit)",
			{ timeout: 30000 },
			async () => {
				const privateKey = PrivateKey.from(
					"0x0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef",
				);

				// Use low scrypt parameters for faster tests
				const keystore = await Keystore.encrypt(privateKey, "password", {
					scryptN: 1024,
					scryptR: 1,
					scryptP: 1,
				});

				// Modify first byte of MAC
				const corruptedKeystore1 = { ...keystore };
				corruptedKeystore1.crypto = { ...keystore.crypto };
				corruptedKeystore1.crypto.mac = `ff${keystore.crypto.mac.slice(2)}`;

				// Modify last byte of MAC
				const corruptedKeystore2 = { ...keystore };
				corruptedKeystore2.crypto = { ...keystore.crypto };
				corruptedKeystore2.crypto.mac = `${keystore.crypto.mac.slice(0, -2)}ff`;

				// Both should fail
				expect(() => Keystore.decrypt(corruptedKeystore1, "password")).toThrow(
					Keystore.InvalidMacError,
				);
				expect(() => Keystore.decrypt(corruptedKeystore2, "password")).toThrow(
					Keystore.InvalidMacError,
				);
			},
		);
	});

	describe("performance", () => {
		it("scrypt with low parameters is fast", async () => {
			const privateKey = PrivateKey.from(
				"0x0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef",
			);

			const start = Date.now();
			const keystore = await Keystore.encrypt(privateKey, "password", {
				scryptN: 1024,
				scryptR: 1,
				scryptP: 1,
			});
			const decrypted = Keystore.decrypt(keystore, "password");
			const elapsed = Date.now() - start;

			expect(decrypted).toEqual(privateKey);
			expect(elapsed).toBeLessThan(1000); // Should complete in < 1s
		});

		it("pbkdf2 with low iterations is fast", async () => {
			const privateKey = PrivateKey.from(
				"0x0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef",
			);

			const start = Date.now();
			const keystore = await Keystore.encrypt(privateKey, "password", {
				kdf: "pbkdf2",
				pbkdf2C: 10000,
			});
			const decrypted = Keystore.decrypt(keystore, "password");
			const elapsed = Date.now() - start;

			expect(decrypted).toEqual(privateKey);
			expect(elapsed).toBeLessThan(500); // Should complete in < 500ms
		});
	});
});

```
