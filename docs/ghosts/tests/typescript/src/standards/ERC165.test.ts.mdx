---
title: '[TS/JS] src/standards/ERC165.test.ts'
source: 'src/standards/ERC165.test.ts'
---

> Auto-generated from test file: src/standards/ERC165.test.ts

```typescript
import { describe, expect, it } from "vitest";
import { hash as keccak256 } from "../crypto/Keccak256/hash.js";
import * as Hex from "../primitives/Hex/index.js";
import * as ERC165 from "./ERC165.js";

describe("ERC165", () => {
	describe("SELECTOR", () => {
		it("has correct supportsInterface selector", () => {
			const sig = "supportsInterface(bytes4)";
			const hash = keccak256(new TextEncoder().encode(sig));
			const selector = Hex.fromBytes(hash.slice(0, 4));
			expect(ERC165.SELECTOR).toBe(selector);
		});
	});

	describe("INTERFACE_IDS", () => {
		it("has correct ERC-165 interface ID", () => {
			// ERC-165 interface ID is its own selector
			expect(ERC165.INTERFACE_IDS.ERC165).toBe(ERC165.SELECTOR);
		});

		it("has correct ERC-721 interface ID", () => {
			// ERC-721: XOR of balanceOf, ownerOf, safeTransferFrom, transferFrom, approve, setApprovalForAll, getApproved, isApprovedForAll
			expect(ERC165.INTERFACE_IDS.ERC721).toBe("0x80ac58cd");
		});

		it("has correct ERC-1155 interface ID", () => {
			// ERC-1155: XOR of balanceOf, balanceOfBatch, setApprovalForAll, isApprovedForAll, safeTransferFrom, safeBatchTransferFrom
			expect(ERC165.INTERFACE_IDS.ERC1155).toBe("0xd9b67a26");
		});
	});

	describe("encodeSupportsInterface", () => {
		it("encodes supportsInterface calldata", () => {
			const calldata = ERC165.encodeSupportsInterface(
				ERC165.INTERFACE_IDS.ERC721,
			);

			expect(calldata).toMatch(/^0x01ffc9a7/); // supportsInterface selector
			expect(calldata.length).toBe(74); // 10 (0x + selector) + 64 (interface id)
		});

		it("handles interface ID with 0x prefix", () => {
			const calldata = ERC165.encodeSupportsInterface("0x80ac58cd");
			expect(calldata).toContain("80ac58cd");
		});

		it("handles interface ID without 0x prefix", () => {
			const calldata = ERC165.encodeSupportsInterface("80ac58cd");
			expect(calldata).toContain("80ac58cd");
		});
	});

	describe("decodeSupportsInterface", () => {
		it("decodes true", () => {
			const data =
				"0x0000000000000000000000000000000000000000000000000000000000000001";
			expect(ERC165.decodeSupportsInterface(data)).toBe(true);
		});

		it("decodes false", () => {
			const data =
				"0x0000000000000000000000000000000000000000000000000000000000000000";
			expect(ERC165.decodeSupportsInterface(data)).toBe(false);
		});
	});

	describe("supportsInterface", () => {
		it("detects interface support", async () => {
			const mockProvider = {
				request: async ({
					method,
					params,
				}: { method: string; params: unknown[] }) => {
					expect(method).toBe("eth_call");
					// Mock: contract supports ERC-721
					return "0x0000000000000000000000000000000000000000000000000000000000000001";
				},
			};

			const supports = await ERC165.supportsInterface(
				mockProvider,
				"0x1234567890123456789012345678901234567890",
				ERC165.INTERFACE_IDS.ERC721,
			);

			expect(supports).toBe(true);
		});

		it("detects lack of interface support", async () => {
			const mockProvider = {
				request: async () => {
					return "0x0000000000000000000000000000000000000000000000000000000000000000";
				},
			};

			const supports = await ERC165.supportsInterface(
				mockProvider,
				"0x1234567890123456789012345678901234567890",
				ERC165.INTERFACE_IDS.ERC721,
			);

			expect(supports).toBe(false);
		});

		it("handles empty response", async () => {
			const mockProvider = {
				request: async () => {
					return "0x";
				},
			};

			const supports = await ERC165.supportsInterface(
				mockProvider,
				"0x1234567890123456789012345678901234567890",
				ERC165.INTERFACE_IDS.ERC721,
			);

			expect(supports).toBe(false);
		});

		it("handles call failure", async () => {
			const mockProvider = {
				request: async () => {
					throw new Error("Contract execution reverted");
				},
			};

			const supports = await ERC165.supportsInterface(
				mockProvider,
				"0x1234567890123456789012345678901234567890",
				ERC165.INTERFACE_IDS.ERC721,
			);

			expect(supports).toBe(false);
		});
	});

	describe("detectInterfaces", () => {
		it("detects multiple interfaces", async () => {
			// Set of supported interfaces
			const supportedInterfaces = new Set([
				ERC165.INTERFACE_IDS.ERC165,
				ERC165.INTERFACE_IDS.ERC721,
				ERC165.INTERFACE_IDS.ERC721Metadata,
			]);

			const mockProvider = {
				request: async ({ params }: { params: unknown[] }) => {
					const callParams = (
						params as [{ to: string; data: string }, string]
					)[0];
					const data = callParams.data;

					// Extract the interface ID from the calldata (skip selector, get padded interface ID)
					const interfaceIdInData = data.slice(10); // Skip 0x + 8 char selector

					// Check each supported interface
					for (const interfaceId of supportedInterfaces) {
						if (
							interfaceIdInData.includes(interfaceId.slice(2).padStart(64, "0"))
						) {
							return "0x0000000000000000000000000000000000000000000000000000000000000001";
						}
					}

					return "0x0000000000000000000000000000000000000000000000000000000000000000";
				},
			};

			const interfaces = await ERC165.detectInterfaces(
				mockProvider,
				"0x1234567890123456789012345678901234567890",
			);

			expect(interfaces).toContain("ERC165");
			expect(interfaces).toContain("ERC721");
			expect(interfaces).toContain("ERC721Metadata");
			expect(interfaces).not.toContain("ERC1155");
		});

		it("returns empty array if contract doesn't support ERC-165", async () => {
			const mockProvider = {
				request: async () => {
					return "0x0000000000000000000000000000000000000000000000000000000000000000";
				},
			};

			const interfaces = await ERC165.detectInterfaces(
				mockProvider,
				"0x1234567890123456789012345678901234567890",
			);

			expect(interfaces).toEqual([]);
		});
	});
});

```
