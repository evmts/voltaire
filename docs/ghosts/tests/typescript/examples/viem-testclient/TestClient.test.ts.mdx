---
title: '[TS/JS] examples/viem-testclient/TestClient.test.ts'
source: 'examples/viem-testclient/TestClient.test.ts'
---

> Auto-generated from test file: examples/viem-testclient/TestClient.test.ts

```typescript
/**
 * Test Client Tests
 *
 * @module examples/viem-testclient/TestClient.test
 */

import { beforeEach, describe, expect, it, vi } from "vitest";
import type { TestClientMode } from "./TestClientTypes.js";
import { createTestClient } from "./createTestClient.js";
import { dropTransaction } from "./dropTransaction.js";
import { dumpState } from "./dumpState.js";
import { impersonateAccount } from "./impersonateAccount.js";
import { increaseTime } from "./increaseTime.js";
import { loadState } from "./loadState.js";
import { mine } from "./mine.js";
import { reset } from "./reset.js";
import { revert } from "./revert.js";
import { setAutomine } from "./setAutomine.js";
import { setBalance } from "./setBalance.js";
import { setCode } from "./setCode.js";
import { setNextBlockTimestamp } from "./setNextBlockTimestamp.js";
import { setNonce } from "./setNonce.js";
import { setStorageAt } from "./setStorageAt.js";
import { snapshot } from "./snapshot.js";
import { stopImpersonatingAccount } from "./stopImpersonatingAccount.js";

// Mock provider factory
function createMockProvider() {
	const calls: { method: string; params?: unknown[] }[] = [];
	return {
		calls,
		request: vi.fn(async ({ method, params }) => {
			calls.push({ method, params });
			// Return mock responses based on method
			if (method === "evm_snapshot") return "0x1";
			if (method.includes("dumpState")) return "0xdeadbeef";
			return null;
		}),
	};
}

describe("createTestClient", () => {
	it("creates client with mode and provider", () => {
		const provider = createMockProvider();
		const client = createTestClient({
			mode: "anvil",
			provider,
		});

		expect(client.mode).toBe("anvil");
		expect(client.key).toBe("test");
		expect(client.name).toBe("Test Client");
	});

	it("throws without provider", () => {
		expect(() =>
			createTestClient({
				mode: "anvil",
			} as unknown as Parameters<typeof createTestClient>[0]),
		).toThrow("Provider is required");
	});

	it("accepts custom key and name", () => {
		const provider = createMockProvider();
		const client = createTestClient({
			mode: "hardhat",
			provider,
			key: "custom-key",
			name: "Custom Client",
		});

		expect(client.key).toBe("custom-key");
		expect(client.name).toBe("Custom Client");
	});
});

describe("mine", () => {
	const modes: TestClientMode[] = ["anvil", "hardhat", "ganache"];

	it.each(modes)("mines blocks in %s mode", async (mode) => {
		const provider = createMockProvider();
		const client = { mode, request: provider.request };

		await mine(client, { blocks: 5 });

		if (mode === "ganache") {
			expect(provider.request).toHaveBeenCalledWith({
				method: "evm_mine",
				params: [{ blocks: "0x5" }],
			});
		} else {
			expect(provider.request).toHaveBeenCalledWith({
				method: `${mode}_mine`,
				params: ["0x5", "0x0"],
			});
		}
	});

	it("passes interval parameter", async () => {
		const provider = createMockProvider();
		const client = { mode: "anvil" as const, request: provider.request };

		await mine(client, { blocks: 10, interval: 12 });

		expect(provider.request).toHaveBeenCalledWith({
			method: "anvil_mine",
			params: ["0xa", "0xc"],
		});
	});
});

describe("setBalance", () => {
	const modes: TestClientMode[] = ["anvil", "hardhat", "ganache"];

	it.each(modes)("sets balance in %s mode", async (mode) => {
		const provider = createMockProvider();
		const client = { mode, request: provider.request };
		const address = "0xa5cc3c03994DB5b0d9A5eEdD10CabaB0813678AC";

		await setBalance(client, { address, value: 1000000000000000000n });

		if (mode === "ganache") {
			expect(provider.request).toHaveBeenCalledWith({
				method: "evm_setAccountBalance",
				params: [address, "0xde0b6b3a7640000"],
			});
		} else {
			expect(provider.request).toHaveBeenCalledWith({
				method: `${mode}_setBalance`,
				params: [address, "0xde0b6b3a7640000"],
			});
		}
	});
});

describe("setCode", () => {
	const modes: TestClientMode[] = ["anvil", "hardhat", "ganache"];

	it.each(modes)("sets code in %s mode", async (mode) => {
		const provider = createMockProvider();
		const client = { mode, request: provider.request };
		const address = "0xe846c6fcf817734ca4527b28ccb4aea2b6663c79";
		const bytecode = "0x608060405260006003";

		await setCode(client, { address, bytecode });

		if (mode === "ganache") {
			expect(provider.request).toHaveBeenCalledWith({
				method: "evm_setAccountCode",
				params: [address, bytecode],
			});
		} else {
			expect(provider.request).toHaveBeenCalledWith({
				method: `${mode}_setCode`,
				params: [address, bytecode],
			});
		}
	});
});

describe("setStorageAt", () => {
	it("sets storage slot with numeric index", async () => {
		const provider = createMockProvider();
		const client = { mode: "anvil" as const, request: provider.request };
		const address = "0xe846c6fcf817734ca4527b28ccb4aea2b6663c79";
		const value =
			"0x0000000000000000000000000000000000000000000000000000000000000069";

		await setStorageAt(client, { address, index: 2, value });

		expect(provider.request).toHaveBeenCalledWith({
			method: "anvil_setStorageAt",
			params: [address, "0x2", value],
		});
	});

	it("sets storage slot with hex index", async () => {
		const provider = createMockProvider();
		const client = { mode: "hardhat" as const, request: provider.request };
		const address = "0xe846c6fcf817734ca4527b28ccb4aea2b6663c79";
		const value =
			"0x0000000000000000000000000000000000000000000000000000000000000069";

		await setStorageAt(client, { address, index: "0xff", value });

		expect(provider.request).toHaveBeenCalledWith({
			method: "hardhat_setStorageAt",
			params: [address, "0xff", value],
		});
	});
});

describe("setNonce", () => {
	it("sets account nonce", async () => {
		const provider = createMockProvider();
		const client = { mode: "anvil" as const, request: provider.request };
		const address = "0xa5cc3c03994DB5b0d9A5eEdD10CabaB0813678AC";

		await setNonce(client, { address, nonce: 420 });

		expect(provider.request).toHaveBeenCalledWith({
			method: "anvil_setNonce",
			params: [address, "0x1a4"],
		});
	});
});

describe("impersonateAccount", () => {
	it("impersonates account", async () => {
		const provider = createMockProvider();
		const client = { mode: "anvil" as const, request: provider.request };
		const address = "0xA0Cf798816D4b9b9866b5330EEa46a18382f251e";

		await impersonateAccount(client, { address });

		expect(provider.request).toHaveBeenCalledWith({
			method: "anvil_impersonateAccount",
			params: [address],
		});
	});
});

describe("stopImpersonatingAccount", () => {
	it("stops impersonating account", async () => {
		const provider = createMockProvider();
		const client = { mode: "hardhat" as const, request: provider.request };
		const address = "0xa5cc3c03994DB5b0d9A5eEdD10CabaB0813678AC";

		await stopImpersonatingAccount(client, { address });

		expect(provider.request).toHaveBeenCalledWith({
			method: "hardhat_stopImpersonatingAccount",
			params: [address],
		});
	});
});

describe("snapshot", () => {
	it("creates snapshot and returns ID", async () => {
		const provider = createMockProvider();
		const client = { request: provider.request };

		const id = await snapshot(client);

		expect(provider.request).toHaveBeenCalledWith({
			method: "evm_snapshot",
		});
		expect(id).toBe("0x1");
	});
});

describe("revert", () => {
	it("reverts to snapshot", async () => {
		const provider = createMockProvider();
		const client = { request: provider.request };

		await revert(client, { id: "0x1" });

		expect(provider.request).toHaveBeenCalledWith({
			method: "evm_revert",
			params: ["0x1"],
		});
	});
});

describe("increaseTime", () => {
	it("advances time", async () => {
		const provider = createMockProvider();
		const client = { request: provider.request };

		await increaseTime(client, { seconds: 3600 });

		expect(provider.request).toHaveBeenCalledWith({
			method: "evm_increaseTime",
			params: ["0xe10"],
		});
	});
});

describe("setNextBlockTimestamp", () => {
	it("sets next block timestamp", async () => {
		const provider = createMockProvider();
		const client = { request: provider.request };

		await setNextBlockTimestamp(client, { timestamp: 1671744314n });

		expect(provider.request).toHaveBeenCalledWith({
			method: "evm_setNextBlockTimestamp",
			params: ["0x63a4cb3a"],
		});
	});
});

describe("dropTransaction", () => {
	it("drops transaction from mempool", async () => {
		const provider = createMockProvider();
		const client = { mode: "anvil" as const, request: provider.request };
		const hash =
			"0xe58dceb6b20b03965bb678e27d141e151d7d4efc2334c2d6a49b9fac523f7364";

		await dropTransaction(client, { hash });

		expect(provider.request).toHaveBeenCalledWith({
			method: "anvil_dropTransaction",
			params: [hash],
		});
	});
});

describe("reset", () => {
	it("resets with no parameters", async () => {
		const provider = createMockProvider();
		const client = { mode: "anvil" as const, request: provider.request };

		await reset(client);

		expect(provider.request).toHaveBeenCalledWith({
			method: "anvil_reset",
			params: [{ forking: { blockNumber: undefined, jsonRpcUrl: undefined } }],
		});
	});

	it("resets with block number", async () => {
		const provider = createMockProvider();
		const client = { mode: "hardhat" as const, request: provider.request };

		await reset(client, { blockNumber: 69420n });

		expect(provider.request).toHaveBeenCalledWith({
			method: "hardhat_reset",
			params: [{ forking: { blockNumber: 69420, jsonRpcUrl: undefined } }],
		});
	});

	it("resets with JSON-RPC URL", async () => {
		const provider = createMockProvider();
		const client = { mode: "anvil" as const, request: provider.request };

		await reset(client, {
			jsonRpcUrl: "https://eth-mainnet.alchemyapi.io/v2/xxx",
			blockNumber: 18000000n,
		});

		expect(provider.request).toHaveBeenCalledWith({
			method: "anvil_reset",
			params: [
				{
					forking: {
						blockNumber: 18000000,
						jsonRpcUrl: "https://eth-mainnet.alchemyapi.io/v2/xxx",
					},
				},
			],
		});
	});
});

describe("dumpState", () => {
	it("dumps state and returns hex", async () => {
		const provider = createMockProvider();
		const client = { mode: "anvil" as const, request: provider.request };

		const state = await dumpState(client);

		expect(provider.request).toHaveBeenCalledWith({
			method: "anvil_dumpState",
		});
		expect(state).toBe("0xdeadbeef");
	});
});

describe("loadState", () => {
	it("loads state from hex", async () => {
		const provider = createMockProvider();
		const client = { mode: "hardhat" as const, request: provider.request };

		await loadState(client, { state: "0xdeadbeef" });

		expect(provider.request).toHaveBeenCalledWith({
			method: "hardhat_loadState",
			params: ["0xdeadbeef"],
		});
	});
});

describe("setAutomine", () => {
	it("enables automine in anvil/hardhat", async () => {
		const provider = createMockProvider();
		const client = { mode: "anvil" as const, request: provider.request };

		await setAutomine(client, true);

		expect(provider.request).toHaveBeenCalledWith({
			method: "evm_setAutomine",
			params: [true],
		});
	});

	it("disables automine in anvil/hardhat", async () => {
		const provider = createMockProvider();
		const client = { mode: "hardhat" as const, request: provider.request };

		await setAutomine(client, false);

		expect(provider.request).toHaveBeenCalledWith({
			method: "evm_setAutomine",
			params: [false],
		});
	});

	it("uses miner_start in ganache", async () => {
		const provider = createMockProvider();
		const client = { mode: "ganache" as const, request: provider.request };

		await setAutomine(client, true);

		expect(provider.request).toHaveBeenCalledWith({
			method: "miner_start",
		});
	});

	it("uses miner_stop in ganache", async () => {
		const provider = createMockProvider();
		const client = { mode: "ganache" as const, request: provider.request };

		await setAutomine(client, false);

		expect(provider.request).toHaveBeenCalledWith({
			method: "miner_stop",
		});
	});
});

describe("TestClient integration", () => {
	it("provides all test actions", async () => {
		const provider = createMockProvider();
		const client = createTestClient({
			mode: "anvil",
			provider,
		});

		// Verify all methods exist
		expect(typeof client.mine).toBe("function");
		expect(typeof client.setBalance).toBe("function");
		expect(typeof client.setCode).toBe("function");
		expect(typeof client.setStorageAt).toBe("function");
		expect(typeof client.setNonce).toBe("function");
		expect(typeof client.impersonateAccount).toBe("function");
		expect(typeof client.stopImpersonatingAccount).toBe("function");
		expect(typeof client.snapshot).toBe("function");
		expect(typeof client.revert).toBe("function");
		expect(typeof client.increaseTime).toBe("function");
		expect(typeof client.setNextBlockTimestamp).toBe("function");
		expect(typeof client.dropTransaction).toBe("function");
		expect(typeof client.reset).toBe("function");
		expect(typeof client.dumpState).toBe("function");
		expect(typeof client.loadState).toBe("function");
		expect(typeof client.setAutomine).toBe("function");
		expect(typeof client.request).toBe("function");
	});

	it("snapshot/revert workflow", async () => {
		const provider = createMockProvider();
		const client = createTestClient({
			mode: "anvil",
			provider,
		});

		const id = await client.snapshot();
		expect(id).toBe("0x1");

		await client.revert({ id });

		expect(provider.calls).toContainEqual({ method: "evm_snapshot" });
		expect(provider.calls).toContainEqual({
			method: "evm_revert",
			params: ["0x1"],
		});
	});

	it("impersonation workflow", async () => {
		const provider = createMockProvider();
		const client = createTestClient({
			mode: "anvil",
			provider,
		});

		const address = "0xA0Cf798816D4b9b9866b5330EEa46a18382f251e";

		await client.impersonateAccount({ address });
		await client.setBalance({ address, value: 10n ** 18n });
		await client.stopImpersonatingAccount({ address });

		expect(provider.calls).toContainEqual({
			method: "anvil_impersonateAccount",
			params: [address],
		});
		expect(provider.calls).toContainEqual({
			method: "anvil_setBalance",
			params: [address, "0xde0b6b3a7640000"],
		});
		expect(provider.calls).toContainEqual({
			method: "anvil_stopImpersonatingAccount",
			params: [address],
		});
	});

	it("time manipulation workflow", async () => {
		const provider = createMockProvider();
		const client = createTestClient({
			mode: "hardhat",
			provider,
		});

		// Set specific timestamp
		await client.setNextBlockTimestamp({ timestamp: 1700000000n });
		await client.mine({ blocks: 1 });

		// Increase time by 1 hour
		await client.increaseTime({ seconds: 3600 });
		await client.mine({ blocks: 1 });

		expect(provider.calls).toContainEqual({
			method: "evm_setNextBlockTimestamp",
			params: ["0x6553f100"],
		});
		expect(provider.calls).toContainEqual({
			method: "evm_increaseTime",
			params: ["0xe10"],
		});
	});
});

```
