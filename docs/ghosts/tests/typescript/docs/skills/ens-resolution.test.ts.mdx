---
title: '[TS/JS] docs/skills/ens-resolution.test.ts'
source: 'docs/skills/ens-resolution.test.ts'
---

> Auto-generated from test file: docs/skills/ens-resolution.test.ts

```typescript
/**
 * Tests for ENS resolution guide
 * @see /docs/guides/ens-resolution.mdx
 *
 * Note: The guide shows Contract-based resolution which requires a provider.
 * These tests cover the primitive ENS operations (validation, normalization, namehash)
 * that ARE available in the codebase.
 */
import { describe, expect, it } from "vitest";

describe("ENS Resolution Guide", () => {
	it("should validate ENS names", async () => {
		const Ens = await import("../../src/primitives/Ens/index.js");

		expect(Ens.isValid("vitalik.eth")).toBe(true);
		expect(Ens.isValid("test.eth")).toBe(true);
		expect(Ens.isValid("")).toBe(false);
	});

	it("should normalize ENS names", async () => {
		const Ens = await import("../../src/primitives/Ens/index.js");

		const normalized = Ens.normalize("VitaliK.ETH");
		expect(Ens.toString(normalized)).toBe("vitalik.eth");

		const normalized2 = Ens.normalize("TEST.eth");
		expect(Ens.toString(normalized2)).toBe("test.eth");
	});

	it("should beautify ENS names", async () => {
		const Ens = await import("../../src/primitives/Ens/index.js");

		const beautified = Ens.beautify("TEST.eth");
		expect(Ens.toString(beautified)).toBe("test.eth");
	});

	it("should compute namehash", async () => {
		const Ens = await import("../../src/primitives/Ens/index.js");
		const { Hex } = await import("../../src/primitives/Hex/index.js");

		// Known test vector: namehash of empty string
		const emptyNode = Ens.namehash("");
		expect(emptyNode.length).toBe(32);
		// Empty name has zero hash
		expect(Hex.fromBytes(emptyNode)).toBe(
			"0x0000000000000000000000000000000000000000000000000000000000000000",
		);
	});

	it("should compute namehash for eth TLD", async () => {
		const Ens = await import("../../src/primitives/Ens/index.js");
		const { Hex } = await import("../../src/primitives/Hex/index.js");

		// Known test vector: namehash of "eth"
		const ethNode = Ens.namehash("eth");
		expect(ethNode.length).toBe(32);
		// eth namehash is well-known
		expect(Hex.fromBytes(ethNode)).toBe(
			"0x93cdeb708b7545dc668eb9280176169d1c33cfd8ed6f04690a0bcc88a93fc4ae",
		);
	});

	it("should compute namehash for vitalik.eth", async () => {
		const Ens = await import("../../src/primitives/Ens/index.js");
		const { Hex } = await import("../../src/primitives/Hex/index.js");

		const node = Ens.namehash("vitalik.eth");
		expect(node.length).toBe(32);
		// Known namehash for vitalik.eth
		expect(Hex.fromBytes(node)).toBe(
			"0xee6c4522aab0003e8d14cd40a6af439055fd2577951148c14b6cea9a53475835",
		);
	});

	it("should compute labelhash", async () => {
		const Ens = await import("../../src/primitives/Ens/index.js");
		const { Hex } = await import("../../src/primitives/Hex/index.js");

		// labelhash is keccak256 of the label
		const label = Ens.labelhash("vitalik");
		expect(label.length).toBe(32);
		expect(Hex.fromBytes(label)).toBe(
			"0xaf2caa1c2ca1d027f1ac823b529d0a67cd144264b2789fa2ea4d63a67c7103cc",
		);
	});

	it("should throw on invalid ENS names", async () => {
		const Ens = await import("../../src/primitives/Ens/index.js");

		expect(() => Ens.validate("")).toThrow();
	});

	it("should handle reverse resolution name format", async () => {
		const Ens = await import("../../src/primitives/Ens/index.js");

		// Reverse resolution uses <address>.addr.reverse format
		const address = "0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045";
		const addrLower = address.toLowerCase().slice(2);
		const reverseName = `${addrLower}.addr.reverse`;

		const node = Ens.namehash(reverseName);
		expect(node.length).toBe(32);
	});
});

```
