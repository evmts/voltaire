---
title: '[TS/JS] docs/crypto/bls12-381/index.test.ts'
source: 'docs/crypto/bls12-381/index.test.ts'
---

> Auto-generated from test file: docs/crypto/bls12-381/index.test.ts

```typescript
/**
 * Tests for docs/crypto/bls12-381/index.mdx
 *
 * Validates that the BLS12-381 API works correctly.
 * Note: Docs say "NO JavaScript/TypeScript interface" but there IS one.
 *
 * DOC BUGS FOUND:
 * - Docs say public key is 48 bytes compressed but API returns 96 bytes
 * - Docs say signature is 96 bytes but API returns 48 bytes
 * - Docs claim no TypeScript API but there is one
 */
import { describe, expect, it } from "vitest";

describe("BLS12-381 Documentation - index.mdx", () => {
	describe("Key Management", () => {
		it("should generate random private key", async () => {
			const { randomPrivateKey } = await import(
				"../../../src/crypto/Bls12381/index.js"
			);

			const privateKey = randomPrivateKey();

			expect(privateKey).toBeInstanceOf(Uint8Array);
			expect(privateKey.length).toBe(32);
		});

		it("should validate private key", async () => {
			const { isValidPrivateKey, randomPrivateKey } = await import(
				"../../../src/crypto/Bls12381/index.js"
			);

			const privateKey = randomPrivateKey();
			expect(isValidPrivateKey(privateKey)).toBe(true);

			// Zero key is invalid
			const zeroKey = new Uint8Array(32);
			expect(isValidPrivateKey(zeroKey)).toBe(false);
		});

		it("should derive public key from private key", async () => {
			const { derivePublicKey, randomPrivateKey } = await import(
				"../../../src/crypto/Bls12381/index.js"
			);

			const privateKey = randomPrivateKey();
			const publicKey = derivePublicKey(privateKey);

			// DOC BUG: Docs say 48 bytes but API returns 96 bytes
			expect(publicKey).toBeInstanceOf(Uint8Array);
			expect(publicKey.length).toBe(96);
		});
	});

	describe("Signing", () => {
		it("should sign a message", async () => {
			const { sign, randomPrivateKey } = await import(
				"../../../src/crypto/Bls12381/index.js"
			);

			const privateKey = randomPrivateKey();
			const message = new Uint8Array([1, 2, 3, 4, 5]);
			const signature = sign(message, privateKey);

			// DOC BUG: Docs say 96 bytes but API returns 48 bytes
			expect(signature).toBeInstanceOf(Uint8Array);
			expect(signature.length).toBe(48);
		});
	});

	describe("Signature Aggregation", () => {
		it("should aggregate signatures", async () => {
			const { sign, aggregate, randomPrivateKey } = await import(
				"../../../src/crypto/Bls12381/index.js"
			);

			const pk1 = randomPrivateKey();
			const pk2 = randomPrivateKey();
			const message = new Uint8Array([1, 2, 3]);

			const sig1 = sign(message, pk1);
			const sig2 = sign(message, pk2);

			const aggregated = aggregate([sig1, sig2]);

			// Aggregated signature same size as individual
			expect(aggregated.length).toBe(48);
		});

		it("should aggregate public keys", async () => {
			const { aggregatePublicKeys, randomPrivateKey, derivePublicKey } =
				await import("../../../src/crypto/Bls12381/index.js");

			const pk1 = randomPrivateKey();
			const pk2 = randomPrivateKey();

			const pubKey1 = derivePublicKey(pk1);
			const pubKey2 = derivePublicKey(pk2);

			const aggregated = aggregatePublicKeys([pubKey1, pubKey2]);

			// Aggregated public key same size as individual
			expect(aggregated.length).toBe(96);
		});
	});

	describe("Constants", () => {
		it("should export curve constants", async () => {
			const { EMBEDDING_DEGREE, FP_MOD, FR_MOD } = await import(
				"../../../src/crypto/Bls12381/index.js"
			);

			expect(EMBEDDING_DEGREE).toBe(12);
			expect(typeof FP_MOD).toBe("bigint");
			expect(typeof FR_MOD).toBe("bigint");
		});

		it("should export generator points", async () => {
			const { G1_GENERATOR_X, G1_GENERATOR_Y, G2_GENERATOR_X, G2_GENERATOR_Y } =
				await import("../../../src/crypto/Bls12381/index.js");

			expect(typeof G1_GENERATOR_X).toBe("bigint");
			expect(typeof G1_GENERATOR_Y).toBe("bigint");
			expect(typeof G2_GENERATOR_X).toBe("object"); // Fp2 element
			expect(typeof G2_GENERATOR_Y).toBe("object"); // Fp2 element
		});
	});

	describe("Field Operations", () => {
		it("should export Fp (base field) with operations", async () => {
			const { Fp } = await import("../../../src/crypto/Bls12381/index.js");

			// Fp should have arithmetic operations
			expect(typeof Fp).toBe("object");
			expect(typeof Fp.add).toBe("function");
			expect(typeof Fp.mul).toBe("function");
			expect(typeof Fp.inv).toBe("function");
		});

		it("should export Fr (scalar field) with validation", async () => {
			const { Fr } = await import("../../../src/crypto/Bls12381/index.js");

			// Fr should have validation
			expect(typeof Fr).toBe("object");
			expect(typeof Fr.isValid).toBe("function");
			expect(typeof Fr.mod).toBe("function");
		});
	});
});

```
