---
title: '[TS/JS] docs/crypto/bn254/performance.test.ts'
source: 'docs/crypto/bn254/performance.test.ts'
---

> Auto-generated from test file: docs/crypto/bn254/performance.test.ts

```typescript
/**
 * Tests for docs/crypto/bn254/performance.mdx code examples
 *
 * NOTE: This documentation page is marked as "planned and under active development"
 * with placeholder content. Tests below verify the operations that would be
 * benchmarked in performance documentation.
 *
 * Import path: ../../../src/crypto/bn254/BN254.js
 */

import { describe, expect, it } from "vitest";

describe("docs/crypto/bn254/performance.mdx", () => {
	/**
	 * API DISCREPANCY NOTE:
	 * The docs page is a placeholder. Performance benchmarks would cover:
	 * - G1 operations: add, mul, double
	 * - G2 operations: add, mul, double
	 * - Pairing: single pairing, multi-pairing
	 *
	 * These tests verify the operations work correctly (not performance).
	 * Actual benchmarks are in src/crypto/bn254.bench.ts
	 */

	describe("G1 Operations (correctness)", () => {
		it("should perform G1 addition", async () => {
			const { BN254 } = await import("../../../src/crypto/bn254/BN254.js");

			const g1 = BN254.G1.generator();
			const p1 = BN254.G1.mul(g1, 2n);
			const p2 = BN254.G1.mul(g1, 3n);

			const result = BN254.G1.add(p1, p2);

			// 2G + 3G = 5G
			const expected = BN254.G1.mul(g1, 5n);
			expect(BN254.G1.equal(result, expected)).toBe(true);
		});

		it("should perform G1 scalar multiplication", async () => {
			const { BN254 } = await import("../../../src/crypto/bn254/BN254.js");

			const g1 = BN254.G1.generator();
			const scalar = 12345n;

			const result = BN254.G1.mul(g1, scalar);

			expect(BN254.G1.isOnCurve(result)).toBe(true);
		});

		it("should perform G1 doubling", async () => {
			const { BN254 } = await import("../../../src/crypto/bn254/BN254.js");

			const g1 = BN254.G1.generator();
			const doubled = BN254.G1.double(g1);

			const expected = BN254.G1.mul(g1, 2n);
			expect(BN254.G1.equal(doubled, expected)).toBe(true);
		});
	});

	describe("G2 Operations (correctness)", () => {
		it("should perform G2 addition", async () => {
			const { BN254 } = await import("../../../src/crypto/bn254/BN254.js");

			const g2 = BN254.G2.generator();
			const p1 = BN254.G2.mul(g2, 2n);
			const p2 = BN254.G2.mul(g2, 3n);

			const result = BN254.G2.add(p1, p2);

			// 2G + 3G = 5G
			const expected = BN254.G2.mul(g2, 5n);
			expect(BN254.G2.equal(result, expected)).toBe(true);
		});

		it("should perform G2 scalar multiplication", async () => {
			const { BN254 } = await import("../../../src/crypto/bn254/BN254.js");

			const g2 = BN254.G2.generator();
			const scalar = 12345n;

			const result = BN254.G2.mul(g2, scalar);

			expect(BN254.G2.isOnCurve(result)).toBe(true);
		});

		it("should perform G2 doubling", async () => {
			const { BN254 } = await import("../../../src/crypto/bn254/BN254.js");

			const g2 = BN254.G2.generator();
			const doubled = BN254.G2.double(g2);

			const expected = BN254.G2.mul(g2, 2n);
			expect(BN254.G2.equal(doubled, expected)).toBe(true);
		});
	});

	describe("Pairing Operations (correctness)", () => {
		it("should perform single pairing", async () => {
			const { BN254 } = await import("../../../src/crypto/bn254/BN254.js");

			const g1 = BN254.G1.generator();
			const g2 = BN254.G2.generator();

			const result = BN254.Pairing.pair(g1, g2);

			expect(result).toBeDefined();
			expect(result.value).not.toBe(1n);
		});

		/**
		 * API DISCREPANCY: Bilinearity tests are skipped in the main test suite
		 * (src/crypto/bn254.test.ts) because the pairing implementation is still
		 * being refined. This test documents expected behavior once complete.
		 */
		it.skip("should perform pairing check with 2 pairs", async () => {
			const { BN254 } = await import("../../../src/crypto/bn254/BN254.js");

			const g1 = BN254.G1.generator();
			const g2 = BN254.G2.generator();

			// e(aG1, G2) * e(-G1, aG2) = 1
			const a = 5n;
			const aG1 = BN254.G1.mul(g1, a);
			const aG2 = BN254.G2.mul(g2, a);
			const negG1 = BN254.G1.negate(g1);

			const valid = BN254.Pairing.pairingCheck([
				[aG1, g2],
				[negG1, aG2],
			]);

			expect(valid).toBe(true);
		});

		it("should perform multi-pairing", async () => {
			const { BN254 } = await import("../../../src/crypto/bn254/BN254.js");

			const g1 = BN254.G1.generator();
			const g2 = BN254.G2.generator();

			const pairs: Array<
				[
					ReturnType<typeof BN254.G1.generator>,
					ReturnType<typeof BN254.G2.generator>,
				]
			> = [
				[BN254.G1.mul(g1, 2n), BN254.G2.mul(g2, 3n)],
				[BN254.G1.mul(g1, 4n), BN254.G2.mul(g2, 5n)],
				[BN254.G1.mul(g1, 6n), BN254.G2.mul(g2, 7n)],
			];

			const result = BN254.Pairing.multiPairing(pairs);
			expect(result).toBeDefined();
		});
	});

	describe("Serialization Operations (correctness)", () => {
		it("should serialize G1 points", async () => {
			const { BN254 } = await import("../../../src/crypto/bn254/BN254.js");

			const g1 = BN254.G1.generator();
			const point = BN254.G1.mul(g1, 42n);

			const bytes = BN254.serializeG1(point);

			expect(bytes.length).toBe(64);
		});

		it("should serialize G2 points", async () => {
			const { BN254 } = await import("../../../src/crypto/bn254/BN254.js");

			const g2 = BN254.G2.generator();
			const point = BN254.G2.mul(g2, 42n);

			const bytes = BN254.serializeG2(point);

			expect(bytes.length).toBe(128);
		});

		it("should deserialize G1 points", async () => {
			const { BN254 } = await import("../../../src/crypto/bn254/BN254.js");

			const g1 = BN254.G1.generator();
			const point = BN254.G1.mul(g1, 42n);
			const bytes = BN254.serializeG1(point);

			const deserialized = BN254.deserializeG1(bytes);

			expect(BN254.G1.equal(point, deserialized)).toBe(true);
		});

		it("should deserialize G2 points", async () => {
			const { BN254 } = await import("../../../src/crypto/bn254/BN254.js");

			const g2 = BN254.G2.generator();
			const point = BN254.G2.mul(g2, 42n);
			const bytes = BN254.serializeG2(point);

			const deserialized = BN254.deserializeG2(bytes);

			expect(BN254.G2.equal(point, deserialized)).toBe(true);
		});
	});
});

```
