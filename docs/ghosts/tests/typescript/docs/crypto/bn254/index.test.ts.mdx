---
title: '[TS/JS] docs/crypto/bn254/index.test.ts'
source: 'docs/crypto/bn254/index.test.ts'
---

> Auto-generated from test file: docs/crypto/bn254/index.test.ts

```typescript
/**
 * Tests for docs/crypto/bn254/index.mdx code examples
 *
 * Tests all code examples from the BN254 overview documentation.
 * Import path: ../../../src/crypto/bn254/BN254.js
 */

import { describe, expect, it } from "vitest";

describe("docs/crypto/bn254/index.mdx", () => {
	describe("Quick Start example", () => {
		/**
		 * NOTE: The docs show:
		 *   import { bn254Ark } from '@tevm/voltaire/crypto';
		 *
		 * But the actual API is:
		 *   import { BN254 } from '../../../src/crypto/bn254/BN254.js';
		 *
		 * The bn254Ark implementation is stubbed and throws errors.
		 * Using the pure TS BN254 implementation instead.
		 */
		it("should perform G1 point addition", async () => {
			const { BN254 } = await import("../../../src/crypto/bn254/BN254.js");

			// Get two G1 points (using generator and a multiple)
			const g1a = BN254.G1.generator();
			const g1b = BN254.G1.generator();

			// Add them
			const result = BN254.G1.add(g1a, g1b);

			// Result should be valid and equal to 2*G
			expect(BN254.G1.isOnCurve(result)).toBe(true);
			const doubled = BN254.G1.double(g1a);
			expect(BN254.G1.equal(result, doubled)).toBe(true);
		});

		it("should perform G1 scalar multiplication", async () => {
			const { BN254 } = await import("../../../src/crypto/bn254/BN254.js");

			// Get generator point
			const point = BN254.G1.generator();

			// Multiply by scalar 3
			const scalar = 3n;
			const result = BN254.G1.mul(point, scalar);

			// Verify result is on curve
			expect(BN254.G1.isOnCurve(result)).toBe(true);

			// Verify 3*G = G + G + G
			const manual = BN254.G1.add(BN254.G1.add(point, point), point);
			expect(BN254.G1.equal(result, manual)).toBe(true);
		});

		it("should perform pairing check", async () => {
			const { BN254 } = await import("../../../src/crypto/bn254/BN254.js");

			// Get generator points
			const g1 = BN254.G1.generator();
			const g2 = BN254.G2.generator();

			// Compute pairing
			const result = BN254.Pairing.pair(g1, g2);

			// Result should be defined and not 1 (not infinity pairing)
			expect(result).toBeDefined();
			expect(result.value).not.toBe(1n);
		});
	});

	describe("Key Operations - G1 Point Operations", () => {
		it("should create generator point", async () => {
			const { BN254 } = await import("../../../src/crypto/bn254/BN254.js");

			const gen = BN254.G1.generator();
			expect(BN254.G1.isOnCurve(gen)).toBe(true);
			expect(BN254.G1.isZero(gen)).toBe(false);
		});

		it("should perform point doubling", async () => {
			const { BN254 } = await import("../../../src/crypto/bn254/BN254.js");

			const gen = BN254.G1.generator();
			const doubled = BN254.G1.double(gen);

			expect(BN254.G1.isOnCurve(doubled)).toBe(true);
			expect(BN254.G1.equal(doubled, BN254.G1.add(gen, gen))).toBe(true);
		});

		it("should compute additive inverse (negate)", async () => {
			const { BN254 } = await import("../../../src/crypto/bn254/BN254.js");

			const gen = BN254.G1.generator();
			const neg = BN254.G1.negate(gen);

			// P + (-P) = O (point at infinity)
			const sum = BN254.G1.add(gen, neg);
			expect(BN254.G1.isZero(sum)).toBe(true);
		});
	});

	describe("Key Operations - G2 Point Operations", () => {
		it("should create G2 generator point", async () => {
			const { BN254 } = await import("../../../src/crypto/bn254/BN254.js");

			const gen = BN254.G2.generator();
			expect(BN254.G2.isOnCurve(gen)).toBe(true);
			expect(BN254.G2.isZero(gen)).toBe(false);
		});

		it("should validate G2 subgroup membership", async () => {
			const { BN254 } = await import("../../../src/crypto/bn254/BN254.js");

			const gen = BN254.G2.generator();
			expect(BN254.G2.isInSubgroup(gen)).toBe(true);

			// Multiple of generator should also be in subgroup
			const mul = BN254.G2.mul(gen, 7n);
			expect(BN254.G2.isInSubgroup(mul)).toBe(true);
		});
	});

	describe("Point Formats", () => {
		it("should serialize G1 points to 64 bytes", async () => {
			const { BN254 } = await import("../../../src/crypto/bn254/BN254.js");

			const gen = BN254.G1.generator();
			const bytes = BN254.serializeG1(gen);

			// G1 points are 64 bytes (32 for x, 32 for y)
			expect(bytes.length).toBe(64);
		});

		it("should serialize G2 points to 128 bytes", async () => {
			const { BN254 } = await import("../../../src/crypto/bn254/BN254.js");

			const gen = BN254.G2.generator();
			const bytes = BN254.serializeG2(gen);

			// G2 points are 128 bytes (32*2 for x (Fp2), 32*2 for y (Fp2))
			expect(bytes.length).toBe(128);
		});

		it("should represent infinity as (0, 0) for G1", async () => {
			const { BN254 } = await import("../../../src/crypto/bn254/BN254.js");

			const inf = BN254.G1.infinity();
			const bytes = BN254.serializeG1(inf);

			// Check all bytes are 0
			const allZero = bytes.every((b) => b === 0);
			expect(allZero).toBe(true);
		});
	});

	describe("Field Parameters", () => {
		it("should use correct base field modulus p (254-bit prime)", async () => {
			const { FP_MOD } = await import("../../../src/crypto/bn254/constants.js");

			// From docs: p = 21888242871839275222246405745257275088696311157297823662689037894645226208583
			// NOTE: API exports FP_MOD, not P
			const expected =
				21888242871839275222246405745257275088696311157297823662689037894645226208583n;
			expect(FP_MOD).toBe(expected);
		});

		it("should use correct scalar field modulus r (curve order)", async () => {
			const { FR_MOD } = await import("../../../src/crypto/bn254/constants.js");

			// From docs: r = 21888242871839275222246405745257275088548364400416034343698204186575808495617
			const expected =
				21888242871839275222246405745257275088548364400416034343698204186575808495617n;
			expect(FR_MOD).toBe(expected);
		});
	});

	describe("Curve Order", () => {
		it("should have r*G = O for G1", async () => {
			const { BN254 } = await import("../../../src/crypto/bn254/BN254.js");
			const { FR_MOD } = await import("../../../src/crypto/bn254/constants.js");

			const gen = BN254.G1.generator();
			const result = BN254.G1.mul(gen, FR_MOD);

			// Multiplying by curve order gives point at infinity
			expect(BN254.G1.isZero(result)).toBe(true);
		});

		it("should have r*G = O for G2", async () => {
			const { BN254 } = await import("../../../src/crypto/bn254/BN254.js");
			const { FR_MOD } = await import("../../../src/crypto/bn254/constants.js");

			const gen = BN254.G2.generator();
			const result = BN254.G2.mul(gen, FR_MOD);

			// Multiplying by curve order gives point at infinity
			expect(BN254.G2.isZero(result)).toBe(true);
		});
	});

	describe("Pairing Properties", () => {
		it("should return 1 for pairing with infinity", async () => {
			const { BN254 } = await import("../../../src/crypto/bn254/BN254.js");

			const g1 = BN254.G1.generator();
			const g2 = BN254.G2.generator();
			const inf1 = BN254.G1.infinity();
			const inf2 = BN254.G2.infinity();

			// e(O, Q) = 1
			const r1 = BN254.Pairing.pair(inf1, g2);
			expect(r1.value).toBe(1n);

			// e(P, O) = 1
			const r2 = BN254.Pairing.pair(g1, inf2);
			expect(r2.value).toBe(1n);
		});
	});

	describe("Serialization round-trip", () => {
		it("should serialize and deserialize G1 points correctly", async () => {
			const { BN254 } = await import("../../../src/crypto/bn254/BN254.js");

			const gen = BN254.G1.generator();
			const point = BN254.G1.mul(gen, 42n);

			const bytes = BN254.serializeG1(point);
			const deserialized = BN254.deserializeG1(bytes);

			expect(BN254.G1.equal(point, deserialized)).toBe(true);
		});

		it("should serialize and deserialize G2 points correctly", async () => {
			const { BN254 } = await import("../../../src/crypto/bn254/BN254.js");

			const gen = BN254.G2.generator();
			const point = BN254.G2.mul(gen, 42n);

			const bytes = BN254.serializeG2(point);
			const deserialized = BN254.deserializeG2(bytes);

			expect(BN254.G2.equal(point, deserialized)).toBe(true);
		});
	});
});

```
