---
title: '[TS/JS] docs/crypto/bn254/test-vectors.test.ts'
source: 'docs/crypto/bn254/test-vectors.test.ts'
---

> Auto-generated from test file: docs/crypto/bn254/test-vectors.test.ts

```typescript
/**
 * Tests for docs/crypto/bn254/test-vectors.mdx code examples
 *
 * NOTE: This documentation page is marked as "planned and under active development"
 * with placeholder content. Tests below use official EIP-196/197 test vectors.
 *
 * Test vectors sourced from:
 * - EIP-196: https://eips.ethereum.org/EIPS/eip-196
 * - EIP-197: https://eips.ethereum.org/EIPS/eip-197
 * - Ethereum execution-spec-tests
 *
 * Import path: ../../../src/crypto/bn254/BN254.js
 */

import { describe, expect, it } from "vitest";

describe("docs/crypto/bn254/test-vectors.mdx", () => {
	/**
	 * API DISCREPANCY NOTE:
	 * The docs page is a placeholder. These tests use known test vectors
	 * to verify correctness of the BN254 implementation.
	 */

	describe("Generator Points", () => {
		it("should have correct G1 generator", async () => {
			const { BN254 } = await import("../../../src/crypto/bn254/BN254.js");

			const g1 = BN254.G1.generator();
			const affine = BN254.G1.toAffine(g1);

			// G1 generator: (1, 2)
			expect(affine.x).toBe(1n);
			expect(affine.y).toBe(2n);
		});

		it("should have correct G2 generator", async () => {
			const { BN254 } = await import("../../../src/crypto/bn254/BN254.js");

			const g2 = BN254.G2.generator();
			const affine = BN254.G2.toAffine(g2);

			// G2 generator x-coordinate (Fp2)
			expect(affine.x.c0).toBe(
				10857046999023057135944570762232829481370756359578518086990519993285655852781n,
			);
			expect(affine.x.c1).toBe(
				11559732032986387107991004021392285783925812861821192530917403151452391805634n,
			);

			// G2 generator y-coordinate (Fp2)
			expect(affine.y.c0).toBe(
				8495653923123431417604973247489272438418190587263600148770280649306958101930n,
			);
			expect(affine.y.c1).toBe(
				4082367875863433681332203403145435568316851327593401208105741076214120093531n,
			);
		});
	});

	describe("Field Moduli", () => {
		it("should have correct base field modulus FP_MOD", async () => {
			const { FP_MOD } = await import("../../../src/crypto/bn254/constants.js");

			// FP_MOD = 21888242871839275222246405745257275088696311157297823662689037894645226208583
			// NOTE: API exports FP_MOD, not P
			const expected =
				21888242871839275222246405745257275088696311157297823662689037894645226208583n;
			expect(FP_MOD).toBe(expected);
		});

		it("should have correct scalar field modulus FR_MOD", async () => {
			const { FR_MOD } = await import("../../../src/crypto/bn254/constants.js");

			// FR_MOD = 21888242871839275222246405745257275088548364400416034343698204186575808495617
			const expected =
				21888242871839275222246405745257275088548364400416034343698204186575808495617n;
			expect(FR_MOD).toBe(expected);
		});
	});

	describe("ECADD Test Vectors", () => {
		it("should add G1 + G1 = 2G1", async () => {
			const { BN254 } = await import("../../../src/crypto/bn254/BN254.js");

			const g1 = BN254.G1.generator();
			const result = BN254.G1.add(g1, g1);
			const affine = BN254.G1.toAffine(result);

			// 2G1 coordinates
			expect(affine.x).toBe(
				1368015179489954701390400359078579693043519447331113978918064868415326638035n,
			);
			expect(affine.y).toBe(
				9918110051302171585080402603319702774565515993150576347155970296011118125764n,
			);
		});

		it("should handle P + O = P", async () => {
			const { BN254 } = await import("../../../src/crypto/bn254/BN254.js");

			const g1 = BN254.G1.generator();
			const zero = BN254.G1.infinity();

			const result = BN254.G1.add(g1, zero);
			expect(BN254.G1.equal(result, g1)).toBe(true);
		});

		it("should handle P + (-P) = O", async () => {
			const { BN254 } = await import("../../../src/crypto/bn254/BN254.js");

			const g1 = BN254.G1.generator();
			const negG1 = BN254.G1.negate(g1);

			const result = BN254.G1.add(g1, negG1);
			expect(BN254.G1.isZero(result)).toBe(true);
		});
	});

	describe("ECMUL Test Vectors", () => {
		it("should compute 2 * G1", async () => {
			const { BN254 } = await import("../../../src/crypto/bn254/BN254.js");

			const g1 = BN254.G1.generator();
			const result = BN254.G1.mul(g1, 2n);
			const affine = BN254.G1.toAffine(result);

			// 2G1 coordinates (same as G1 + G1)
			expect(affine.x).toBe(
				1368015179489954701390400359078579693043519447331113978918064868415326638035n,
			);
			expect(affine.y).toBe(
				9918110051302171585080402603319702774565515993150576347155970296011118125764n,
			);
		});

		it("should compute 9 * G1", async () => {
			const { BN254 } = await import("../../../src/crypto/bn254/BN254.js");

			const g1 = BN254.G1.generator();
			const result = BN254.G1.mul(g1, 9n);
			const affine = BN254.G1.toAffine(result);

			// 9G1 should be on curve
			expect(BN254.G1.isOnCurve(result)).toBe(true);

			// Verify: 9G = 8G + G = 2*(2*(2G)) + G
			const twoG = BN254.G1.mul(g1, 2n);
			const fourG = BN254.G1.mul(twoG, 2n);
			const eightG = BN254.G1.mul(fourG, 2n);
			const expected = BN254.G1.add(eightG, g1);

			expect(BN254.G1.equal(result, expected)).toBe(true);
		});

		it("should compute 0 * G1 = O", async () => {
			const { BN254 } = await import("../../../src/crypto/bn254/BN254.js");

			const g1 = BN254.G1.generator();
			const result = BN254.G1.mul(g1, 0n);

			expect(BN254.G1.isZero(result)).toBe(true);
		});

		it("should compute r * G1 = O (curve order)", async () => {
			const { BN254 } = await import("../../../src/crypto/bn254/BN254.js");
			const { FR_MOD } = await import("../../../src/crypto/bn254/constants.js");

			const g1 = BN254.G1.generator();
			const result = BN254.G1.mul(g1, FR_MOD);

			expect(BN254.G1.isZero(result)).toBe(true);
		});
	});

	describe("ECPAIRING Test Vectors", () => {
		/**
		 * API DISCREPANCY: Bilinearity tests are skipped in the main test suite
		 * (src/crypto/bn254.test.ts) because the pairing implementation is still
		 * being refined. These tests document expected behavior once complete.
		 */
		it.skip("should verify bilinearity: e(aP, Q) = e(P, aQ)", async () => {
			const { BN254 } = await import("../../../src/crypto/bn254/BN254.js");

			const g1 = BN254.G1.generator();
			const g2 = BN254.G2.generator();
			const a = 7n;

			const aG1 = BN254.G1.mul(g1, a);
			const aG2 = BN254.G2.mul(g2, a);
			const negG1 = BN254.G1.negate(g1);

			// e(aG1, G2) * e(-G1, aG2) = 1
			const valid = BN254.Pairing.pairingCheck([
				[aG1, g2],
				[negG1, aG2],
			]);

			expect(valid).toBe(true);
		});

		it("should verify empty pairing = true", async () => {
			const { BN254 } = await import("../../../src/crypto/bn254/BN254.js");

			const valid = BN254.Pairing.pairingCheck([]);
			expect(valid).toBe(true);
		});

		it("should verify pairing with infinity = 1", async () => {
			const { BN254 } = await import("../../../src/crypto/bn254/BN254.js");

			const g1 = BN254.G1.generator();
			const g2 = BN254.G2.generator();
			const inf1 = BN254.G1.infinity();
			const inf2 = BN254.G2.infinity();

			// e(O, G2) = 1
			const r1 = BN254.Pairing.pair(inf1, g2);
			expect(r1.value).toBe(1n);

			// e(G1, O) = 1
			const r2 = BN254.Pairing.pair(g1, inf2);
			expect(r2.value).toBe(1n);
		});
	});

	describe("Edge Cases", () => {
		it("should handle large scalar multiplication", async () => {
			const { BN254 } = await import("../../../src/crypto/bn254/BN254.js");
			const { FR_MOD } = await import("../../../src/crypto/bn254/constants.js");

			const g1 = BN254.G1.generator();

			// Large scalar (close to FR_MOD)
			const large = FR_MOD - 1n;
			const result = BN254.G1.mul(g1, large);

			// (r-1)*G = -G
			const negG = BN254.G1.negate(g1);
			expect(BN254.G1.equal(result, negG)).toBe(true);
		});

		it("should handle scalar larger than curve order", async () => {
			const { BN254 } = await import("../../../src/crypto/bn254/BN254.js");
			const { FR_MOD } = await import("../../../src/crypto/bn254/constants.js");

			const g1 = BN254.G1.generator();

			// Scalar = r + 5 should equal 5*G (wraps around)
			const scalar = FR_MOD + 5n;
			const result = BN254.G1.mul(g1, scalar);
			const expected = BN254.G1.mul(g1, 5n);

			expect(BN254.G1.equal(result, expected)).toBe(true);
		});

		it("should maintain point validity through chained operations", async () => {
			const { BN254 } = await import("../../../src/crypto/bn254/BN254.js");

			const g1 = BN254.G1.generator();
			let point = g1;

			// Chain: double, add, mul, negate, add
			point = BN254.G1.double(point);
			expect(BN254.G1.isOnCurve(point)).toBe(true);

			point = BN254.G1.add(point, g1);
			expect(BN254.G1.isOnCurve(point)).toBe(true);

			point = BN254.G1.mul(point, 7n);
			expect(BN254.G1.isOnCurve(point)).toBe(true);

			const neg = BN254.G1.negate(point);
			expect(BN254.G1.isOnCurve(neg)).toBe(true);

			const sum = BN254.G1.add(point, neg);
			expect(BN254.G1.isZero(sum)).toBe(true);
		});
	});
});

```
