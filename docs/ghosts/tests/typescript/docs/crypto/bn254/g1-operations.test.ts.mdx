---
title: '[TS/JS] docs/crypto/bn254/g1-operations.test.ts'
source: 'docs/crypto/bn254/g1-operations.test.ts'
---

> Auto-generated from test file: docs/crypto/bn254/g1-operations.test.ts

```typescript
/**
 * Tests for docs/crypto/bn254/g1-operations.mdx code examples
 *
 * NOTE: This documentation page is marked as "planned and under active development"
 * with placeholder content. Tests below cover expected G1 operations that should
 * be documented once the page is complete.
 *
 * Import path: ../../../src/crypto/bn254/BN254.js
 */

import { describe, expect, it } from "vitest";

describe("docs/crypto/bn254/g1-operations.mdx", () => {
	/**
	 * API DISCREPANCY NOTE:
	 * The docs page is a placeholder. The actual BN254.G1 API includes:
	 * - generator(): G1PointType
	 * - infinity(): G1PointType
	 * - add(a, b): G1PointType
	 * - double(p): G1PointType
	 * - negate(p): G1PointType
	 * - mul(p, scalar): G1PointType
	 * - isZero(p): boolean
	 * - isOnCurve(p): boolean
	 * - equal(a, b): boolean
	 * - toAffine(p): G1PointType
	 * - fromAffine(x, y): G1PointType
	 */

	describe("G1 Point Creation", () => {
		it("should create generator point", async () => {
			const { BN254 } = await import("../../../src/crypto/bn254/BN254.js");

			const gen = BN254.G1.generator();
			expect(BN254.G1.isOnCurve(gen)).toBe(true);
			expect(BN254.G1.isZero(gen)).toBe(false);
		});

		it("should create infinity point", async () => {
			const { BN254 } = await import("../../../src/crypto/bn254/BN254.js");

			const inf = BN254.G1.infinity();
			expect(BN254.G1.isZero(inf)).toBe(true);
			expect(BN254.G1.isOnCurve(inf)).toBe(true);
		});

		it("should create point from affine coordinates", async () => {
			const { BN254 } = await import("../../../src/crypto/bn254/BN254.js");

			// Generator point coordinates
			const x = 1n;
			const y = 2n;
			const point = BN254.G1.fromAffine(x, y);

			expect(BN254.G1.isOnCurve(point)).toBe(true);
		});
	});

	describe("G1 Point Validation", () => {
		it("should validate on-curve points", async () => {
			const { BN254 } = await import("../../../src/crypto/bn254/BN254.js");

			const gen = BN254.G1.generator();
			const point = BN254.G1.mul(gen, 7n);
			expect(BN254.G1.isOnCurve(point)).toBe(true);
		});

		it("should reject off-curve points", async () => {
			const { BN254, Bn254InvalidPointError } = await import(
				"../../../src/crypto/bn254/BN254.js"
			);

			// (1, 3) is not on y^2 = x^3 + 3
			expect(() => BN254.G1.fromAffine(1n, 3n)).toThrow(Bn254InvalidPointError);
		});
	});

	describe("G1 Point Addition", () => {
		it("should add two points", async () => {
			const { BN254 } = await import("../../../src/crypto/bn254/BN254.js");

			const gen = BN254.G1.generator();
			const doubled = BN254.G1.double(gen);
			const sum = BN254.G1.add(gen, gen);
			expect(BN254.G1.equal(doubled, sum)).toBe(true);
		});

		it("should handle addition with infinity", async () => {
			const { BN254 } = await import("../../../src/crypto/bn254/BN254.js");

			const gen = BN254.G1.generator();
			const inf = BN254.G1.infinity();

			// P + O = P
			const result = BN254.G1.add(gen, inf);
			expect(BN254.G1.equal(result, gen)).toBe(true);
		});

		it("should be commutative", async () => {
			const { BN254 } = await import("../../../src/crypto/bn254/BN254.js");

			const gen = BN254.G1.generator();
			const p1 = BN254.G1.mul(gen, 11n);
			const p2 = BN254.G1.mul(gen, 13n);

			const sum1 = BN254.G1.add(p1, p2);
			const sum2 = BN254.G1.add(p2, p1);
			expect(BN254.G1.equal(sum1, sum2)).toBe(true);
		});

		it("should be associative", async () => {
			const { BN254 } = await import("../../../src/crypto/bn254/BN254.js");

			const gen = BN254.G1.generator();
			const p1 = BN254.G1.mul(gen, 3n);
			const p2 = BN254.G1.mul(gen, 5n);
			const p3 = BN254.G1.mul(gen, 7n);

			const left = BN254.G1.add(BN254.G1.add(p1, p2), p3);
			const right = BN254.G1.add(p1, BN254.G1.add(p2, p3));
			expect(BN254.G1.equal(left, right)).toBe(true);
		});
	});

	describe("G1 Point Doubling", () => {
		it("should double a point", async () => {
			const { BN254 } = await import("../../../src/crypto/bn254/BN254.js");

			const gen = BN254.G1.generator();
			const doubled = BN254.G1.double(gen);
			const manual = BN254.G1.add(gen, gen);
			expect(BN254.G1.equal(doubled, manual)).toBe(true);
		});
	});

	describe("G1 Point Negation", () => {
		it("should negate a point", async () => {
			const { BN254 } = await import("../../../src/crypto/bn254/BN254.js");

			const gen = BN254.G1.generator();
			const neg = BN254.G1.negate(gen);
			const sum = BN254.G1.add(gen, neg);
			expect(BN254.G1.isZero(sum)).toBe(true);
		});
	});

	describe("G1 Scalar Multiplication", () => {
		it("should multiply by scalar", async () => {
			const { BN254 } = await import("../../../src/crypto/bn254/BN254.js");

			const gen = BN254.G1.generator();
			const result = BN254.G1.mul(gen, 5n);

			// 5*G = G + G + G + G + G
			const manual = BN254.G1.add(
				BN254.G1.add(BN254.G1.add(BN254.G1.add(gen, gen), gen), gen),
				gen,
			);
			expect(BN254.G1.equal(result, manual)).toBe(true);
		});

		it("should multiply by zero", async () => {
			const { BN254 } = await import("../../../src/crypto/bn254/BN254.js");

			const gen = BN254.G1.generator();
			const result = BN254.G1.mul(gen, 0n);
			expect(BN254.G1.isZero(result)).toBe(true);
		});

		it("should multiply by one", async () => {
			const { BN254 } = await import("../../../src/crypto/bn254/BN254.js");

			const gen = BN254.G1.generator();
			const result = BN254.G1.mul(gen, 1n);
			expect(BN254.G1.equal(result, gen)).toBe(true);
		});

		it("should multiply by curve order to get infinity", async () => {
			const { BN254 } = await import("../../../src/crypto/bn254/BN254.js");
			const { FR_MOD } = await import("../../../src/crypto/bn254/constants.js");

			const gen = BN254.G1.generator();
			const result = BN254.G1.mul(gen, FR_MOD);
			expect(BN254.G1.isZero(result)).toBe(true);
		});
	});

	describe("G1 Coordinate Conversion", () => {
		it("should convert to affine coordinates", async () => {
			const { BN254 } = await import("../../../src/crypto/bn254/BN254.js");

			const gen = BN254.G1.generator();
			const point = BN254.G1.mul(gen, 17n);
			const affine = BN254.G1.toAffine(point);

			expect(affine.z).toBe(1n);
			expect(BN254.G1.equal(point, affine)).toBe(true);
		});

		it("should handle infinity in toAffine", async () => {
			const { BN254 } = await import("../../../src/crypto/bn254/BN254.js");

			const inf = BN254.G1.infinity();
			const affine = BN254.G1.toAffine(inf);
			expect(BN254.G1.isZero(affine)).toBe(true);
		});
	});

	describe("G1 Serialization", () => {
		it("should serialize to 64 bytes", async () => {
			const { BN254 } = await import("../../../src/crypto/bn254/BN254.js");

			const gen = BN254.G1.generator();
			const bytes = BN254.serializeG1(gen);
			expect(bytes.length).toBe(64);
		});

		it("should round-trip through serialization", async () => {
			const { BN254 } = await import("../../../src/crypto/bn254/BN254.js");

			const gen = BN254.G1.generator();
			const point = BN254.G1.mul(gen, 42n);

			const bytes = BN254.serializeG1(point);
			const deserialized = BN254.deserializeG1(bytes);

			expect(BN254.G1.equal(point, deserialized)).toBe(true);
		});
	});
});

```
