---
title: '[TS/JS] docs/crypto/bn254/usage-patterns.test.ts'
source: 'docs/crypto/bn254/usage-patterns.test.ts'
---

> Auto-generated from test file: docs/crypto/bn254/usage-patterns.test.ts

```typescript
/**
 * Tests for docs/crypto/bn254/usage-patterns.mdx code examples
 *
 * NOTE: This documentation page is marked as "planned and under active development"
 * with placeholder content. Tests below demonstrate common usage patterns.
 *
 * Common use cases:
 * - Privacy protocols (Tornado Cash, zkBob)
 * - L2 scaling (zkSync, Polygon zkEVM, Scroll)
 * - Identity verification
 * - Private DeFi
 * - Anonymous voting
 *
 * Import path: ../../../src/crypto/bn254/BN254.js
 */

import { describe, expect, it } from "vitest";

describe("docs/crypto/bn254/usage-patterns.mdx", () => {
	/**
	 * API DISCREPANCY NOTE:
	 * The docs page is a placeholder. These tests demonstrate common
	 * usage patterns for BN254 cryptographic operations.
	 */

	describe("Basic Point Operations Pattern", () => {
		it("should create and manipulate G1 points", async () => {
			const { BN254 } = await import("../../../src/crypto/bn254/BN254.js");

			// 1. Get generator
			const g1 = BN254.G1.generator();

			// 2. Create points via scalar multiplication
			const publicKey = BN254.G1.mul(g1, 12345n);

			// 3. Verify point is valid
			expect(BN254.G1.isOnCurve(publicKey)).toBe(true);

			// 4. Serialize for storage/transmission
			const bytes = BN254.serializeG1(publicKey);
			expect(bytes.length).toBe(64);

			// 5. Deserialize to restore
			const restored = BN254.deserializeG1(bytes);
			expect(BN254.G1.equal(publicKey, restored)).toBe(true);
		});

		it("should create and manipulate G2 points", async () => {
			const { BN254 } = await import("../../../src/crypto/bn254/BN254.js");

			// 1. Get generator
			const g2 = BN254.G2.generator();

			// 2. Create points via scalar multiplication
			const verificationKey = BN254.G2.mul(g2, 54321n);

			// 3. Verify point is valid and in subgroup
			expect(BN254.G2.isOnCurve(verificationKey)).toBe(true);
			expect(BN254.G2.isInSubgroup(verificationKey)).toBe(true);

			// 4. Serialize for storage/transmission
			const bytes = BN254.serializeG2(verificationKey);
			expect(bytes.length).toBe(128);

			// 5. Deserialize to restore
			const restored = BN254.deserializeG2(bytes);
			expect(BN254.G2.equal(verificationKey, restored)).toBe(true);
		});
	});

	describe("Commitment Scheme Pattern", () => {
		/**
		 * Pedersen Commitment: C = vG + rH
		 * - v: value to commit
		 * - r: random blinding factor
		 * - G, H: generator points
		 */
		it("should create Pedersen-like commitment", async () => {
			const { BN254 } = await import("../../../src/crypto/bn254/BN254.js");

			// Setup: Two generator points (G and H)
			const G = BN254.G1.generator();
			const H = BN254.G1.mul(G, 7n); // In practice, H should be randomly chosen

			// Values
			const value = 1000n; // Amount to commit
			const blinding = 123456789n; // Random blinding factor

			// Commitment: C = vG + rH
			const vG = BN254.G1.mul(G, value);
			const rH = BN254.G1.mul(H, blinding);
			const commitment = BN254.G1.add(vG, rH);

			expect(BN254.G1.isOnCurve(commitment)).toBe(true);

			// Verify commitment (with known v and r)
			const vG2 = BN254.G1.mul(G, value);
			const rH2 = BN254.G1.mul(H, blinding);
			const expected = BN254.G1.add(vG2, rH2);

			expect(BN254.G1.equal(commitment, expected)).toBe(true);
		});
	});

	describe("Signature Aggregation Pattern", () => {
		/**
		 * Simple signature aggregation using pairing:
		 * Aggregate signatures can be verified with single pairing check.
		 */
		it("should aggregate multiple points", async () => {
			const { BN254 } = await import("../../../src/crypto/bn254/BN254.js");

			const g1 = BN254.G1.generator();

			// Simulate multiple "signatures" (points)
			const sig1 = BN254.G1.mul(g1, 111n);
			const sig2 = BN254.G1.mul(g1, 222n);
			const sig3 = BN254.G1.mul(g1, 333n);

			// Aggregate by addition
			const aggregate = BN254.G1.add(BN254.G1.add(sig1, sig2), sig3);

			// Aggregated point should be on curve
			expect(BN254.G1.isOnCurve(aggregate)).toBe(true);

			// Verify: aggregate = (111 + 222 + 333) * G = 666 * G
			const expected = BN254.G1.mul(g1, 666n);
			expect(BN254.G1.equal(aggregate, expected)).toBe(true);
		});
	});

	describe("Proof Verification Pattern", () => {
		/**
		 * Common zkSNARK verification pattern:
		 * Verify equation e(A, B) = e(C, D)
		 * Rewritten as: e(A, B) * e(-C, D) = 1
		 *
		 * API DISCREPANCY: Bilinearity tests are skipped in the main test suite
		 * (src/crypto/bn254.test.ts) because the pairing implementation is still
		 * being refined. These tests document expected behavior once complete.
		 */
		it.skip("should verify proof-like pairing equation", async () => {
			const { BN254 } = await import("../../../src/crypto/bn254/BN254.js");

			const g1 = BN254.G1.generator();
			const g2 = BN254.G2.generator();

			// Setup a valid equation: e(aG1, G2) = e(G1, aG2)
			const a = 42n;
			const aG1 = BN254.G1.mul(g1, a);
			const aG2 = BN254.G2.mul(g2, a);

			// Rewrite as pairing check: e(aG1, G2) * e(-G1, aG2) = 1
			const negG1 = BN254.G1.negate(g1);

			const valid = BN254.Pairing.pairingCheck([
				[aG1, g2],
				[negG1, aG2],
			]);

			expect(valid).toBe(true);
		});

		it("should detect invalid proof", async () => {
			const { BN254 } = await import("../../../src/crypto/bn254/BN254.js");

			const g1 = BN254.G1.generator();
			const g2 = BN254.G2.generator();

			// Invalid equation (random points)
			const valid = BN254.Pairing.pairingCheck([
				[BN254.G1.mul(g1, 7n), BN254.G2.mul(g2, 11n)],
				[BN254.G1.mul(g1, 13n), BN254.G2.mul(g2, 17n)],
			]);

			expect(valid).toBe(false);
		});
	});

	describe("Batch Verification Pattern", () => {
		/**
		 * API DISCREPANCY: Bilinearity tests are skipped in the main test suite
		 * (src/crypto/bn254.test.ts) because the pairing implementation is still
		 * being refined. This test documents expected behavior once complete.
		 */
		it.skip("should verify multiple equations in single check", async () => {
			const { BN254 } = await import("../../../src/crypto/bn254/BN254.js");

			const g1 = BN254.G1.generator();
			const g2 = BN254.G2.generator();

			// Multiple valid equations combined:
			// e(2G1, G2) * e(-G1, 2G2) = 1
			// e(3G1, G2) * e(-G1, 3G2) = 1
			// Combined: e(2G1, G2) * e(-G1, 2G2) * e(3G1, G2) * e(-G1, 3G2) = 1

			const twoG1 = BN254.G1.mul(g1, 2n);
			const threeG1 = BN254.G1.mul(g1, 3n);
			const twoG2 = BN254.G2.mul(g2, 2n);
			const threeG2 = BN254.G2.mul(g2, 3n);
			const negG1 = BN254.G1.negate(g1);

			const valid = BN254.Pairing.pairingCheck([
				[twoG1, g2],
				[negG1, twoG2],
				[threeG1, g2],
				[negG1, threeG2],
			]);

			expect(valid).toBe(true);
		});
	});

	describe("Key Derivation Pattern", () => {
		/**
		 * API DISCREPANCY: Bilinearity tests are skipped in the main test suite
		 * (src/crypto/bn254.test.ts) because the pairing implementation is still
		 * being refined. This test documents expected behavior once complete.
		 */
		it.skip("should derive related keys from master secret", async () => {
			const { BN254 } = await import("../../../src/crypto/bn254/BN254.js");

			const g1 = BN254.G1.generator();
			const g2 = BN254.G2.generator();

			// Master secret
			const masterSecret = 1234567890n;

			// Derive G1 public key
			const g1PublicKey = BN254.G1.mul(g1, masterSecret);

			// Derive G2 public key (same scalar, different group)
			const g2PublicKey = BN254.G2.mul(g2, masterSecret);

			// Both should be valid points in their respective groups
			expect(BN254.G1.isOnCurve(g1PublicKey)).toBe(true);
			expect(BN254.G2.isOnCurve(g2PublicKey)).toBe(true);
			expect(BN254.G2.isInSubgroup(g2PublicKey)).toBe(true);

			// Verify consistency via pairing
			// e(G1_pk, G2) should equal e(G1, G2_pk)
			const negG1 = BN254.G1.negate(g1);
			const valid = BN254.Pairing.pairingCheck([
				[g1PublicKey, g2],
				[negG1, g2PublicKey],
			]);

			expect(valid).toBe(true);
		});
	});

	describe("Serialization Pattern", () => {
		it("should serialize proof components for on-chain verification", async () => {
			const { BN254 } = await import("../../../src/crypto/bn254/BN254.js");

			const g1 = BN254.G1.generator();
			const g2 = BN254.G2.generator();

			// Simulate proof components
			const proofA = BN254.G1.mul(g1, 123n);
			const proofB = BN254.G2.mul(g2, 456n);
			const proofC = BN254.G1.mul(g1, 789n);

			// Serialize for calldata
			const aBytes = BN254.serializeG1(proofA);
			const bBytes = BN254.serializeG2(proofB);
			const cBytes = BN254.serializeG1(proofC);

			// Total calldata size: 64 + 128 + 64 = 256 bytes
			expect(aBytes.length + bBytes.length + cBytes.length).toBe(256);

			// Verify round-trip
			const aRestored = BN254.deserializeG1(aBytes);
			const bRestored = BN254.deserializeG2(bBytes);
			const cRestored = BN254.deserializeG1(cBytes);

			expect(BN254.G1.equal(proofA, aRestored)).toBe(true);
			expect(BN254.G2.equal(proofB, bRestored)).toBe(true);
			expect(BN254.G1.equal(proofC, cRestored)).toBe(true);
		});
	});
});

```
