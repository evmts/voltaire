---
title: '[TS/JS] docs/evm/precompiles/sha256.test.ts'
source: 'docs/evm/precompiles/sha256.test.ts'
---

> Auto-generated from test file: docs/evm/precompiles/sha256.test.ts

```typescript
/**
 * Tests for sha256.mdx documentation examples
 * Validates code examples work correctly with actual API
 */
import { describe, expect, it } from "vitest";
import { PrecompileAddress, execute, sha256 } from "../../../src/evm/precompiles/precompiles.js";
import * as Hardfork from "../../../src/primitives/Hardfork/index.js";

/**
 * Helper: Convert Uint8Array to hex string
 */
function bytesToHex(bytes: Uint8Array): string {
	return Array.from(bytes)
		.map((b) => b.toString(16).padStart(2, "0"))
		.join("");
}

describe("sha256.mdx documentation examples", () => {
	describe("Overview section", () => {
		it("should produce 32-byte hash as described", () => {
			// Doc states: producing a 32-byte hash of arbitrary input data
			const input = new TextEncoder().encode("test");
			const result = sha256(input, 1000n);

			expect(result.success).toBe(true);
			expect(result.output.length).toBe(32);
		});
	});

	describe("Gas Cost section", () => {
		it("should follow formula: 60 + 12 * ceil(input_length / 32)", () => {
			// Doc states: Base cost: 60 gas, Per-word cost: 12 gas per 32-byte word
			const testCases = [
				{ len: 0, expected: 60n },   // 0 bytes: 60 gas
				{ len: 32, expected: 72n },  // 32 bytes: 72 gas (60 + 12*1)
				{ len: 33, expected: 84n },  // 33 bytes: 84 gas (60 + 12*2)
				{ len: 64, expected: 84n },  // 64 bytes: 84 gas (60 + 12*2)
			];

			for (const { len, expected } of testCases) {
				const input = new Uint8Array(len);
				const result = sha256(input, 10000n);
				expect(result.gasUsed).toBe(expected);
			}
		});

		it("should fail with insufficient gas", () => {
			const input = new Uint8Array(0);
			const result = sha256(input, 59n); // Need 60
			expect(result.success).toBe(false);
			expect(result.error).toBe("Out of gas");
		});
	});

	describe("Input Format section", () => {
		it("should accept arbitrary-length byte array", () => {
			// Doc states: Accepts arbitrary-length byte array
			const testSizes = [0, 1, 31, 32, 33, 64, 128, 1000];

			for (const size of testSizes) {
				const input = new Uint8Array(size);
				const expectedGas = 60n + BigInt(Math.ceil(size / 32)) * 12n;
				const result = sha256(input, expectedGas + 100n);
				expect(result.success).toBe(true);
			}
		});
	});

	describe("Output Format section", () => {
		it("should always return 32 bytes", () => {
			// Doc states: Total output length: 32 bytes (256 bits)
			const testCases = [0, 1, 32, 100, 1000];

			for (const len of testCases) {
				const input = new Uint8Array(len);
				const result = sha256(input, 100000n);
				expect(result.output.length).toBe(32);
			}
		});
	});

	describe("Test Vectors from documentation", () => {
		it("should hash empty input correctly", () => {
			// Doc states: Expected: e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855
			const input = new Uint8Array(0);
			const result = sha256(input, 1000n);

			expect(result.success).toBe(true);
			expect(bytesToHex(result.output)).toBe(
				"e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855"
			);
		});

		it("should hash 'abc' correctly", () => {
			// Doc states: Expected: ba7816bf8f01cfea414140de5dae2223b00361a396177a9cb410ff61f20015ad
			const input = new TextEncoder().encode("abc");
			const result = sha256(input, 1000n);

			expect(result.success).toBe(true);
			expect(bytesToHex(result.output)).toBe(
				"ba7816bf8f01cfea414140de5dae2223b00361a396177a9cb410ff61f20015ad"
			);
		});

		it("should calculate gas correctly for 1000 bytes", () => {
			// Doc states: Gas: 60 + 12 * ceil(1000/32) = 60 + 12*32 = 444
			const input = new Uint8Array(1000);
			const result = sha256(input, 10000n);

			expect(result.success).toBe(true);
			expect(result.gasUsed).toBe(60n + BigInt(Math.ceil(1000 / 32)) * 12n);
		});
	});

	describe("Usage Example from documentation", () => {
		it("should work with TextEncoder input", () => {
			// Doc example: Hash some data with TextEncoder
			const input = new TextEncoder().encode("Hello, Ethereum!");

			// Calculate required gas as shown in doc
			const words = Math.ceil(input.length / 32);
			const gasNeeded = 60n + 12n * BigInt(words);

			const result = sha256(input, gasNeeded);

			expect(result.success).toBe(true);
			expect(result.output.length).toBe(32);
		});
	});

	describe("Bitcoin Integration section", () => {
		it("should support double SHA-256 for Bitcoin block hashes", () => {
			// Doc states: Bitcoin block hash = SHA256(SHA256(header))
			const blockHeader = new Uint8Array(80).fill(0);

			const firstHash = sha256(blockHeader, 10000n);
			expect(firstHash.success).toBe(true);

			const blockHash = sha256(firstHash.output, 10000n);
			expect(blockHash.success).toBe(true);
			expect(blockHash.output.length).toBe(32);
		});
	});

	describe("Integration with execute function", () => {
		it("should work via execute with PrecompileAddress.SHA256", () => {
			const input = new TextEncoder().encode("test");
			const result = execute(
				PrecompileAddress.SHA256,
				input,
				1000n,
				Hardfork.CANCUN,
			);

			expect(result.success).toBe(true);
			expect(result.output.length).toBe(32);
		});

		it("should be available in FRONTIER hardfork", () => {
			// Doc states: Introduced: Frontier
			const input = new Uint8Array(0);
			const result = execute(
				PrecompileAddress.SHA256,
				input,
				1000n,
				Hardfork.FRONTIER,
			);
			expect(result.success).toBe(true);
		});
	});
});

```
