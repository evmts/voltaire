---
title: '[TS/JS] docs/evm/precompiles/bn254-pairing.test.ts'
source: 'docs/evm/precompiles/bn254-pairing.test.ts'
---

> Auto-generated from test file: docs/evm/precompiles/bn254-pairing.test.ts

```typescript
/**
 * Tests for bn254-pairing.mdx documentation examples
 * Validates code examples work correctly with actual API
 */
import { describe, expect, it } from "vitest";
import { PrecompileAddress, execute, bn254Pairing } from "../../../src/evm/precompiles/precompiles.js";
import * as Hardfork from "../../../src/primitives/Hardfork/index.js";

/**
 * Helper: Convert hex string to Uint8Array
 */
function hexToBytes(hex: string): Uint8Array {
	const clean = hex.startsWith("0x") ? hex.slice(2) : hex;
	const bytes = new Uint8Array(clean.length / 2);
	for (let i = 0; i < clean.length; i += 2) {
		bytes[i / 2] = Number.parseInt(clean.slice(i, i + 2), 16);
	}
	return bytes;
}

describe("bn254-pairing.mdx documentation examples", () => {
	describe("Overview section", () => {
		it("should perform pairing check on BN254 curve", () => {
			// Doc states: performs a pairing check on the BN254 elliptic curve
			// Empty input (0 pairs) should return success (empty product = 1)
			const input = new Uint8Array(0);
			const result = bn254Pairing(input, 50000n);

			expect(result.success).toBe(true);
			expect(result.output.length).toBe(32);
		});
	});

	describe("Gas Cost section", () => {
		it("should follow formula: 45000 + 34000 * k", () => {
			// Doc states: Formula: 45000 + 34000 * k where k = number of point pairs
			const testCases = [
				{ pairs: 0, expectedGas: 45000n },  // Empty input
				{ pairs: 1, expectedGas: 79000n },  // 45000 + 34000*1
				{ pairs: 2, expectedGas: 113000n }, // 45000 + 34000*2
				{ pairs: 4, expectedGas: 181000n }, // 45000 + 34000*4
			];

			for (const { pairs, expectedGas } of testCases) {
				const input = new Uint8Array(192 * pairs);
				const result = bn254Pairing(input, 200000n);
				expect(result.gasUsed).toBe(expectedGas);
			}
		});

		it("should fail with insufficient gas for empty input", () => {
			const input = new Uint8Array(0);
			const result = bn254Pairing(input, 44999n); // Need 45000
			expect(result.success).toBe(false);
			expect(result.error).toBe("Out of gas");
		});

		it("should fail with insufficient gas for 1 pair", () => {
			const input = new Uint8Array(192);
			const result = bn254Pairing(input, 78999n); // Need 79000
			expect(result.success).toBe(false);
			expect(result.error).toBe("Out of gas");
		});
	});

	describe("Input Format section", () => {
		it("should accept input as multiple of 192 bytes", () => {
			// Doc states: Input must be a multiple of 192 bytes
			const validSizes = [0, 192, 384, 576, 768];

			for (const size of validSizes) {
				const input = new Uint8Array(size);
				const gasNeeded = 45000n + 34000n * BigInt(size / 192);
				const result = bn254Pairing(input, gasNeeded + 10000n);
				// May fail for invalid points, but input format should be accepted
				expect(result.gasUsed).toBeGreaterThanOrEqual(gasNeeded);
			}
		});

		it("should fail for input not multiple of 192", () => {
			// Doc states: Input length not multiple of 192 -> error
			const invalidSizes = [1, 100, 191, 193, 200];

			for (const size of invalidSizes) {
				const input = new Uint8Array(size);
				const result = bn254Pairing(input, 200000n);
				expect(result.success).toBe(false);
			}
		});

		it("should accept empty input (k=0)", () => {
			// Doc states: Empty input (0 bytes) is valid and returns success
			const input = new Uint8Array(0);
			const result = bn254Pairing(input, 50000n);

			expect(result.success).toBe(true);
			expect(result.output[31]).toBe(1); // Pairing check passes (empty product = 1)
		});
	});

	describe("Output Format section", () => {
		it("should return 32 bytes", () => {
			// Doc states: Total output length: 32 bytes (single word)
			const input = new Uint8Array(0);
			const result = bn254Pairing(input, 50000n);

			expect(result.success).toBe(true);
			expect(result.output.length).toBe(32);
		});

		it("should return 1 for successful pairing check", () => {
			// Doc states: Success: 0x0000...0001 (last byte = 1)
			const input = new Uint8Array(0);
			const result = bn254Pairing(input, 50000n);

			expect(result.success).toBe(true);
			expect(result.output[31]).toBe(1);
			// Other bytes should be zero
			expect([...result.output.slice(0, 31)].every((b) => b === 0)).toBe(true);
		});
	});

	describe("Test Vectors from documentation", () => {
		it("should pass empty input (identity check)", () => {
			// Doc Vector 1: Empty input (identity check)
			// Empty product of pairings should equal 1 (success)
			const input = new Uint8Array(0);
			const result = bn254Pairing(input, 50000n);

			expect(result.success).toBe(true);
			expect(result.gasUsed).toBe(45000n);
			expect(result.output[31]).toBe(1);
		});
	});

	describe("Error Conditions section", () => {
		it("should fail with out of gas", () => {
			// Doc states: Out of gas
			const input = new Uint8Array(192);
			const result = bn254Pairing(input, 1000n);
			expect(result.success).toBe(false);
		});

		it("should fail for input length not multiple of 192", () => {
			// Doc states: Input length not multiple of 192
			const input = new Uint8Array(100);
			const result = bn254Pairing(input, 100000n);
			expect(result.success).toBe(false);
		});
	});

	describe("Integration with execute function", () => {
		it("should work via execute with PrecompileAddress.BN254_PAIRING", () => {
			const input = new Uint8Array(0);
			const result = execute(
				PrecompileAddress.BN254_PAIRING,
				input,
				50000n,
				Hardfork.CANCUN,
			);

			expect(result.success).toBe(true);
			expect(result.gasUsed).toBe(45000n);
			expect(result.output[31]).toBe(1);
		});

		it("should be available from BYZANTIUM hardfork", () => {
			// Doc states: Introduced: Byzantium (EIP-197)
			const input = new Uint8Array(0);
			const result = execute(
				PrecompileAddress.BN254_PAIRING,
				input,
				50000n,
				Hardfork.BYZANTIUM,
			);
			expect(result.success).toBe(true);
		});
	});

	describe("Gas Cost Comparison section", () => {
		it("should be significantly reduced after Istanbul", () => {
			// Doc states: Pre-Istanbul: 100,000 + 80,000*k (much more expensive)
			// Post-Istanbul: 45,000 + 34,000*k
			// We verify current (post-Istanbul) gas costs
			const pairs = 4;
			const input = new Uint8Array(192 * pairs);
			const result = bn254Pairing(input, 200000n);

			// Post-Istanbul gas for 4 pairs: 181,000
			// (compared to pre-Istanbul: 420,000)
			expect(result.gasUsed).toBe(181000n);
		});
	});

	describe("Groth16 zkSNARK Verification section", () => {
		it("should support 4 pairs for Groth16 verification", () => {
			// Doc states: Gas cost for Groth16: 45000 + 34000*4 = 181,000 gas
			const pairs = 4;
			const input = new Uint8Array(192 * pairs);
			const gasNeeded = 45000n + 34000n * BigInt(pairs);

			const result = bn254Pairing(input, gasNeeded + 10000n);

			// Will fail for invalid points, but gas calculation should be correct
			expect(result.gasUsed).toBe(gasNeeded);
		});
	});
});

```
