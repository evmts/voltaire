---
title: '[TS/JS] docs/evm/precompiles/bls12-g1-mul.test.ts'
source: 'docs/evm/precompiles/bls12-g1-mul.test.ts'
---

> Auto-generated from test file: docs/evm/precompiles/bls12-g1-mul.test.ts

```typescript
/**
 * Tests for bls12-g1-mul.mdx documentation examples
 * Validates code examples work correctly with actual API
 */
import { describe, expect, it } from "vitest";
import { PrecompileAddress, execute, bls12G1Mul } from "../../../src/evm/precompiles/precompiles.js";
import * as Hardfork from "../../../src/primitives/Hardfork/index.js";

describe("bls12-g1-mul.mdx documentation examples", () => {
	describe("Overview section", () => {
		it("should perform scalar multiplication on BLS12-381 G1 group", () => {
			// Doc states: performs elliptic curve scalar multiplication on the BLS12-381 curve's G1 group
			// Infinity * k = Infinity
			const input = new Uint8Array(160); // Zero point + scalar
			const result = bls12G1Mul(input, 20000n);

			expect(result.success).toBe(true);
			expect(result.output.length).toBe(128);
		});
	});

	describe("Gas Cost section", () => {
		it("should use exactly 12000 gas", () => {
			// Doc states: Fixed: 12000 gas
			const input = new Uint8Array(160);
			const result = bls12G1Mul(input, 20000n);

			expect(result.success).toBe(true);
			expect(result.gasUsed).toBe(12000n);
		});

		it("should fail with insufficient gas", () => {
			// Doc states: Out of gas: gasLimit < 12000
			const input = new Uint8Array(160);
			const result = bls12G1Mul(input, 11999n);

			expect(result.success).toBe(false);
			expect(result.error).toBe("Out of gas");
		});
	});

	describe("Input Format section", () => {
		it("should require exactly 160 bytes", () => {
			// Doc states: Total input length: 160 bytes (exactly)
			const input = new Uint8Array(160);
			const result = bls12G1Mul(input, 20000n);

			expect(result.success).toBe(true);
		});

		it("should fail for invalid input length", () => {
			// Doc states: Invalid input length: input.len != 160
			const shortInput = new Uint8Array(159);
			const longInput = new Uint8Array(161);

			const resultShort = bls12G1Mul(shortInput, 20000n);
			const resultLong = bls12G1Mul(longInput, 20000n);

			expect(resultShort.success).toBe(false);
			expect(resultLong.success).toBe(false);
		});

		it("should have 128-byte point + 32-byte scalar structure", () => {
			// Doc states: x (64 bytes) + y (64 bytes) + k (32 bytes) = 160 bytes
			const input = new Uint8Array(160);
			// Point: bytes 0-127, Scalar: bytes 128-159
			const result = bls12G1Mul(input, 20000n);
			expect(result.success).toBe(true);
		});
	});

	describe("Output Format section", () => {
		it("should return 128 bytes", () => {
			// Doc states: Total output length: 128 bytes
			const input = new Uint8Array(160);
			const result = bls12G1Mul(input, 20000n);

			expect(result.success).toBe(true);
			expect(result.output.length).toBe(128);
		});
	});

	describe("Scalar Multiplication Properties from documentation", () => {
		it("should return infinity for P * 0", () => {
			// Doc states: P * 0 = O (multiplication by zero gives point at infinity)
			const input = new Uint8Array(160);
			// Point can be anything, scalar = 0 (already zeros)
			const result = bls12G1Mul(input, 20000n);

			expect(result.success).toBe(true);
			// Result should be point at infinity
			expect([...result.output].every((b) => b === 0)).toBe(true);
		});

		it("should return infinity for O * k", () => {
			// Doc states: O * k = O (infinity times any scalar is infinity)
			const input = new Uint8Array(160);
			input[159] = 42; // Set scalar to 42
			// Point is still zeros (infinity)

			const result = bls12G1Mul(input, 20000n);

			expect(result.success).toBe(true);
			// O * 42 = O
			expect([...result.output].every((b) => b === 0)).toBe(true);
		});
	});

	describe("Integration with execute function", () => {
		it("should work via execute with PrecompileAddress.BLS12_G1_MUL", () => {
			const input = new Uint8Array(160);
			const result = execute(
				PrecompileAddress.BLS12_G1_MUL,
				input,
				20000n,
				Hardfork.PRAGUE,
			);

			expect(result.success).toBe(true);
			expect(result.gasUsed).toBe(12000n);
		});

		it("should be available from PRAGUE hardfork", () => {
			// Doc states: Introduced: Prague (EIP-2537)
			const input = new Uint8Array(160);
			const result = execute(
				PrecompileAddress.BLS12_G1_MUL,
				input,
				20000n,
				Hardfork.PRAGUE,
			);
			expect(result.success).toBe(true);
		});

		it("hardfork availability via isPrecompile function", async () => {
			// NOTE: execute() does not enforce hardfork availability
			// Use isPrecompile() to check availability
			const { isPrecompile } = await import("../../../src/evm/precompiles/precompiles.js");
			expect(isPrecompile(PrecompileAddress.BLS12_G1_MUL, Hardfork.PRAGUE)).toBe(true);
			expect(isPrecompile(PrecompileAddress.BLS12_G1_MUL, Hardfork.CANCUN)).toBe(false);
		});
	});

	describe("Comparison with BN254 Mul section", () => {
		it("should use 12000 gas compared to BN254's 6000", () => {
			// Doc states: BLS12-381 G1 Mul: 12000 gas, BN254 Mul: 6000 gas
			const input = new Uint8Array(160);
			const result = bls12G1Mul(input, 20000n);
			expect(result.gasUsed).toBe(12000n);
		});
	});
});

```
