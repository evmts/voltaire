---
title: '[TS/JS] docs/evm/instructions/bitwise/and.test.ts'
source: 'docs/evm/instructions/bitwise/and.test.ts'
---

> Auto-generated from test file: docs/evm/instructions/bitwise/and.test.ts

```typescript
/**
 * Test file for AND (0x16) documentation examples
 * Tests examples from and.mdx
 */
import { describe, expect, it } from "vitest";

describe("AND (0x16) - Documentation Examples", async () => {
	const { AND } = await import("../../../../src/evm/bitwise/index.js");
	const { Frame } = await import("../../../../src/evm/Frame/index.js");

	function createFrame(stack: bigint[], gasRemaining = 1000000n) {
		const frame = Frame({ gas: gasRemaining });
		frame.stack = [...stack];
		return frame;
	}

	describe("Basic Masking", () => {
		it("extracts lower 8 bits", () => {
			const value = 0x123456789abcdefn;
			const mask = 0xffn;
			const frame = createFrame([value, mask]);
			const err = AND(frame);

			expect(err).toBeNull();
			expect(frame.stack).toEqual([0xefn]);
		});
	});

	describe("Truth Table", () => {
		it("follows AND truth table", () => {
			const frame = createFrame([0b1100n, 0b1010n]);
			AND(frame);
			expect(frame.stack).toEqual([0b1000n]);
		});
	});

	describe("Identity Element", () => {
		it("AND with all ones returns original", () => {
			const MAX = (1n << 256n) - 1n;
			const value = 0x123456n;
			const frame = createFrame([value, MAX]);
			AND(frame);

			expect(frame.stack).toEqual([value]);
		});
	});

	describe("Null Element", () => {
		it("AND with zero returns zero", () => {
			const value = 0x123456n;
			const frame = createFrame([value, 0n]);
			AND(frame);

			expect(frame.stack).toEqual([0n]);
		});
	});

	describe("Commutative Property", () => {
		it("a AND b = b AND a", () => {
			const a = 0xaaaaaaaan;
			const b = 0x55555555n;
			const frame1 = createFrame([a, b]);
			AND(frame1);

			const frame2 = createFrame([b, a]);
			AND(frame2);

			expect(frame1.stack[0]).toBe(frame2.stack[0]);
		});
	});

	describe("Edge Cases", () => {
		it("MAX AND MAX = MAX", () => {
			const MAX = (1n << 256n) - 1n;
			const frame = createFrame([MAX, MAX]);
			AND(frame);

			expect(frame.stack).toEqual([MAX]);
		});

		it("alternating patterns AND to zero", () => {
			const pattern1 =
				0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaan;
			const pattern2 =
				0x5555555555555555555555555555555555555555555555555555555555555555n;
			const frame = createFrame([pattern1, pattern2]);
			AND(frame);

			expect(frame.stack).toEqual([0n]);
		});

		it("returns StackUnderflow with insufficient stack", () => {
			const frame = createFrame([0x123n]);
			const err = AND(frame);

			expect(err).toEqual({ type: "StackUnderflow" });
		});

		it("returns OutOfGas when insufficient gas", () => {
			const frame = createFrame([0x123n, 0x456n], 2n);
			const err = AND(frame);

			expect(err).toEqual({ type: "OutOfGas" });
			expect(frame.gasRemaining).toBe(0n);
		});
	});

	describe("Gas Cost", () => {
		it("consumes 3 gas (GasFastestStep)", () => {
			const frame = createFrame([0x123n, 0x456n], 100n);
			const err = AND(frame);

			expect(err).toBeNull();
			expect(frame.gasRemaining).toBe(97n);
		});
	});
});

```
