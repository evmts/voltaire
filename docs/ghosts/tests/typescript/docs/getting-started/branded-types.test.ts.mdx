---
title: '[TS/JS] docs/getting-started/branded-types.test.ts'
source: 'docs/getting-started/branded-types.test.ts'
---

> Auto-generated from test file: docs/getting-started/branded-types.test.ts

```typescript
/**
 * Tests for code examples in branded-types.mdx
 *
 * This file tests the branded types examples from the documentation.
 * Branded types provide type safety by preventing accidental mixing of
 * structurally identical but semantically different types.
 */
import { describe, expect, it } from "vitest";

describe("branded-types.mdx examples", () => {
	describe("The Solution - Branded Types", () => {
		it("creates Address and Bytecode that are type-distinct", async () => {
			const { Address } = await import("../../src/primitives/Address/index.js");
			const { Bytecode } = await import("../../src/primitives/Bytecode/index.js");

			const address = Address("0x742d35Cc6634C0532925a3b844Bc9e7595f51e3e");
			const bytecode = Bytecode("0x60806040");

			// Both are Uint8Array but branded differently
			expect(address).toBeInstanceOf(Uint8Array);
			expect(bytecode).toBeInstanceOf(Uint8Array);

			// Address is 20 bytes, bytecode varies
			expect(address.length).toBe(20);
			expect(bytecode.length).toBe(4);

			// They are different types at compile time (TypeScript prevents mixing)
			// At runtime, we verify they are distinct instances
			expect(address).not.toBe(bytecode);
		});

		it("Address.equals handles casing differences", async () => {
			const { Address } = await import("../../src/primitives/Address/index.js");

			const addr1 = Address("0x742d35cc6634c0532925a3b844bc9e7595f51e3e"); // lowercase
			const addr2 = Address("0x742d35Cc6634C0532925a3b844Bc9e7595f51e3e"); // checksummed

			// Both represent the same address despite different casing
			expect(Address.equals(addr1, addr2)).toBe(true);
		});
	});

	describe("Validation at Construction", () => {
		it("validates addresses at construction", async () => {
			const { Address } = await import("../../src/primitives/Address/index.js");

			// Valid inputs work
			const addr1 = Address("0x742d35Cc6634C0532925a3b844Bc9e7595f51e3e");
			expect(addr1).toBeInstanceOf(Uint8Array);
			expect(addr1.length).toBe(20);

			// bigint input
			const addr2 = Address(0x742d35Cc6634C0532925a3b844Bc9e7595f51e3en);
			expect(addr2).toBeInstanceOf(Uint8Array);
			expect(addr2.length).toBe(20);
		});

		it("throws on invalid hex characters", async () => {
			const { Address } = await import("../../src/primitives/Address/index.js");

			expect(() => Address("0xnot_valid_hex_address_here___")).toThrow();
		});

		it("throws on wrong length (too short)", async () => {
			const { Address } = await import("../../src/primitives/Address/index.js");

			expect(() => Address("0x123")).toThrow();
		});

		it("throws on wrong byte length for Uint8Array input", async () => {
			const { Address } = await import("../../src/primitives/Address/index.js");

			expect(() => Address(new Uint8Array(10))).toThrow();
		});

		// API DISCREPANCY: The docs show Address throwing on invalid EIP-55 checksum,
		// but Address() accepts both checksummed and non-checksummed addresses.
		// Address.isValidChecksum() can be used to validate checksums explicitly.
		it("accepts addresses regardless of checksum (docs say throws on invalid checksum)", async () => {
			const { Address } = await import("../../src/primitives/Address/index.js");

			// The docs example shows this should throw, but actually Address() is permissive
			// It accepts any valid hex address, checksummed or not
			const addr = Address("0x742d35cc6634c0532925a3b844bc9e7595f51e3E");
			expect(addr).toBeInstanceOf(Uint8Array);

			// Use isValidChecksum to check checksum validity
			const isValid = Address.isValidChecksum("0x742d35Cc6634C0532925a3b844Bc9e7595f51e3e");
			expect(typeof isValid).toBe("boolean");
		});
	});
});

```
