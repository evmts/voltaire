---
title: '[TS/JS] docs/primitives/bytecode/fromUint8Array.test.ts'
source: 'docs/primitives/bytecode/fromUint8Array.test.ts'
---

> Auto-generated from test file: docs/primitives/bytecode/fromUint8Array.test.ts

```typescript
import { describe, expect, it } from "vitest";

describe("Bytecode.fromUint8Array (docs/primitives/bytecode/fromUint8Array.mdx)", () => {
	// API discrepancy: Bytecode.fromUint8Array doesn't exist as a separate method.
	// The Bytecode() constructor and Bytecode.from() accept Uint8Array directly.
	// These tests use the actual API pattern.

	describe("Basic Usage", () => {
		it("should construct from Uint8Array via Bytecode()", async () => {
			const { Bytecode } = await import(
				"../../../src/primitives/Bytecode/index.js"
			);

			const bytes = new Uint8Array([0x60, 0x01, 0x00]);
			const code = Bytecode(bytes);

			expect(code).toBeInstanceOf(Uint8Array);
			expect(code.length).toBe(3);
		});

		it("should handle empty Uint8Array", async () => {
			const { Bytecode } = await import(
				"../../../src/primitives/Bytecode/index.js"
			);

			const code = Bytecode(new Uint8Array([]));

			expect(code.length).toBe(0);
		});

		it("should attach methods to result", async () => {
			const { Bytecode } = await import(
				"../../../src/primitives/Bytecode/index.js"
			);

			const code = Bytecode(new Uint8Array([0x60, 0x01, 0x00]));

			expect(typeof code.analyze).toBe("function");
			expect(typeof code.parseInstructions).toBe("function");
			expect(typeof code.validate).toBe("function");
		});
	});

	describe("Immutability", () => {
		it("should not mutate original array", async () => {
			const { Bytecode } = await import(
				"../../../src/primitives/Bytecode/index.js"
			);

			const original = new Uint8Array([0x60, 0x01, 0x00]);
			const code = Bytecode(original);

			// Modify original
			original[0] = 0xff;

			// Code should be unchanged (it's a copy)
			// Note: This depends on implementation - may or may not copy
			expect(code.length).toBe(3);
		});
	});
});

```
