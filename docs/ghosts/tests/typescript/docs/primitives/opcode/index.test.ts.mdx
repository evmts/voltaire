---
title: '[TS/JS] docs/primitives/opcode/index.test.ts'
source: 'docs/primitives/opcode/index.test.ts'
---

> Auto-generated from test file: docs/primitives/opcode/index.test.ts

```typescript
/**
 * Tests for docs/primitives/opcode/index.mdx
 *
 * Validates that all code examples in the Opcode documentation work correctly.
 * Opcode provides EVM opcode constants, information, and bytecode analysis.
 */
import { describe, expect, it } from "vitest";

describe("Opcode Documentation - index.mdx", () => {
	describe("Opcode Constants", () => {
		it("should export common opcode constants", async () => {
			const {
				STOP,
				ADD,
				MUL,
				SUB,
				DIV,
				PUSH1,
				PUSH32,
				DUP1,
				SWAP1,
				JUMP,
				JUMPI,
				JUMPDEST,
				RETURN,
				REVERT,
			} = await import("../../../src/primitives/Opcode/index.js");

			expect(STOP).toBe(0x00);
			expect(ADD).toBe(0x01);
			expect(MUL).toBe(0x02);
			expect(SUB).toBe(0x03);
			expect(DIV).toBe(0x04);
			expect(PUSH1).toBe(0x60);
			expect(PUSH32).toBe(0x7f);
			expect(DUP1).toBe(0x80);
			expect(SWAP1).toBe(0x90);
			expect(JUMP).toBe(0x56);
			expect(JUMPI).toBe(0x57);
			expect(JUMPDEST).toBe(0x5b);
			expect(RETURN).toBe(0xf3);
			expect(REVERT).toBe(0xfd);
		});
	});

	describe("Opcode Information", () => {
		it("should get opcode name with getName()", async () => {
			const { getName, PUSH1, ADD, STOP } = await import(
				"../../../src/primitives/Opcode/index.js"
			);

			expect(getName(PUSH1)).toBe("PUSH1");
			expect(getName(ADD)).toBe("ADD");
			expect(getName(STOP)).toBe("STOP");
		});

		it("should get opcode name with name() alias", async () => {
			const { name, PUSH1 } = await import(
				"../../../src/primitives/Opcode/index.js"
			);

			expect(name(PUSH1)).toBe("PUSH1");
		});

		it("should get opcode info with info()", async () => {
			const { info, PUSH1 } = await import(
				"../../../src/primitives/Opcode/index.js"
			);

			const opcodeInfo = info(PUSH1);
			expect(opcodeInfo).toBeDefined();
			expect(opcodeInfo.name).toBe("PUSH1");
		});

		it("should get gas cost with getGasCost()", async () => {
			const { getGasCost, ADD, PUSH1 } = await import(
				"../../../src/primitives/Opcode/index.js"
			);

			const addGas = getGasCost(ADD);
			const pushGas = getGasCost(PUSH1);

			expect(typeof addGas).toBe("number");
			expect(addGas).toBe(3); // ADD costs 3 gas
			expect(pushGas).toBe(3); // PUSH costs 3 gas
		});

		it("should get stack effect with getStackEffect()", async () => {
			const { getStackEffect, ADD, PUSH1, DUP1 } = await import(
				"../../../src/primitives/Opcode/index.js"
			);

			// getStackEffect returns { pop, push } object
			const addEffect = getStackEffect(ADD);
			expect(addEffect).toBeDefined();
			expect(addEffect?.pop).toBe(2);
			expect(addEffect?.push).toBe(1);

			const pushEffect = getStackEffect(PUSH1);
			expect(pushEffect).toBeDefined();
			expect(pushEffect?.pop).toBe(0);
			expect(pushEffect?.push).toBe(1);

			const dupEffect = getStackEffect(DUP1);
			expect(dupEffect).toBeDefined();
			// DUP1 pops 1 and pushes 2 (original + copy)
		});

		it("should get stack input/output with getStackInput()/getStackOutput()", async () => {
			const { getStackInput, getStackOutput, ADD, PUSH1 } = await import(
				"../../../src/primitives/Opcode/index.js"
			);

			expect(getStackInput(ADD)).toBe(2);
			expect(getStackOutput(ADD)).toBe(1);

			expect(getStackInput(PUSH1)).toBe(0);
			expect(getStackOutput(PUSH1)).toBe(1);
		});

		it("should get opcode category with getCategory()", async () => {
			const { getCategory, ADD, PUSH1, JUMP, SSTORE } = await import(
				"../../../src/primitives/Opcode/index.js"
			);

			expect(getCategory(ADD)).toBeDefined();
			expect(getCategory(PUSH1)).toBeDefined();
			expect(getCategory(JUMP)).toBeDefined();
			expect(getCategory(SSTORE)).toBeDefined();
		});

		it("should get opcode description with getDescription()", async () => {
			const { getDescription, ADD } = await import(
				"../../../src/primitives/Opcode/index.js"
			);

			const desc = getDescription(ADD);
			expect(typeof desc).toBe("string");
		});
	});

	describe("Push Opcodes", () => {
		it("should check if opcode is PUSH with isPush()", async () => {
			const { isPush, PUSH1, PUSH32, ADD } = await import(
				"../../../src/primitives/Opcode/index.js"
			);

			expect(isPush(PUSH1)).toBe(true);
			expect(isPush(PUSH32)).toBe(true);
			expect(isPush(ADD)).toBe(false);
		});

		it("should get push size with getPushSize()", async () => {
			const { getPushSize, PUSH1, PUSH32, ADD } = await import(
				"../../../src/primitives/Opcode/index.js"
			);

			expect(getPushSize(PUSH1)).toBe(1);
			expect(getPushSize(PUSH32)).toBe(32);
			expect(getPushSize(ADD)).toBe(0); // Non-push opcode
		});

		it("should get push opcode for byte count with pushOpcode()", async () => {
			const { pushOpcode, PUSH1, PUSH32 } = await import(
				"../../../src/primitives/Opcode/index.js"
			);

			expect(pushOpcode(1)).toBe(PUSH1);
			expect(pushOpcode(32)).toBe(PUSH32);
		});

		it("should get push bytes count with pushBytes()", async () => {
			const { pushBytes, PUSH1, PUSH32, ADD, PUSH0 } = await import(
				"../../../src/primitives/Opcode/index.js"
			);

			// pushBytes returns the number of bytes that a PUSH opcode pushes
			expect(pushBytes(PUSH1)).toBe(1);
			expect(pushBytes(PUSH32)).toBe(32);
			expect(pushBytes(PUSH0)).toBe(0);
			expect(pushBytes(ADD)).toBeUndefined(); // Not a PUSH
		});
	});

	describe("DUP Opcodes", () => {
		it("should check if opcode is DUP with isDup()", async () => {
			const { isDup, DUP1, ADD } = await import(
				"../../../src/primitives/Opcode/index.js"
			);

			expect(isDup(DUP1)).toBe(true);
			expect(isDup(ADD)).toBe(false);
		});

		it("should get DUP position with dupPosition()", async () => {
			const { dupPosition, DUP1 } = await import(
				"../../../src/primitives/Opcode/index.js"
			);

			// DUP1 duplicates the top stack item (position 1)
			expect(dupPosition(DUP1)).toBe(1);
		});
	});

	describe("SWAP Opcodes", () => {
		it("should check if opcode is SWAP with isSwap()", async () => {
			const { isSwap, SWAP1, ADD } = await import(
				"../../../src/primitives/Opcode/index.js"
			);

			expect(isSwap(SWAP1)).toBe(true);
			expect(isSwap(ADD)).toBe(false);
		});

		it("should get SWAP position with swapPosition()", async () => {
			const { swapPosition, SWAP1 } = await import(
				"../../../src/primitives/Opcode/index.js"
			);

			// SWAP1 swaps top with position 1 (index from top)
			expect(swapPosition(SWAP1)).toBe(1);
		});
	});

	describe("Validation", () => {
		it("should validate opcode with isValid()", async () => {
			const { isValid, ADD, PUSH1 } = await import(
				"../../../src/primitives/Opcode/index.js"
			);

			expect(isValid(ADD)).toBe(true);
			expect(isValid(PUSH1)).toBe(true);
			// 0x0c is an undefined opcode
			expect(isValid(0x0c)).toBe(false);
		});

		it("should validate opcode with isValidOpcode()", async () => {
			const { isValidOpcode, ADD } = await import(
				"../../../src/primitives/Opcode/index.js"
			);

			expect(isValidOpcode(ADD)).toBe(true);
		});
	});

	describe("Jump Analysis", () => {
		it("should check if opcode is jump with isJump()", async () => {
			const { isJump, JUMP, JUMPI, ADD } = await import(
				"../../../src/primitives/Opcode/index.js"
			);

			expect(isJump(JUMP)).toBe(true);
			expect(isJump(JUMPI)).toBe(true);
			expect(isJump(ADD)).toBe(false);
		});

		it("should check if opcode is JUMPDEST with isJumpDestination()", async () => {
			const { isJumpDestination, JUMPDEST, ADD } = await import(
				"../../../src/primitives/Opcode/index.js"
			);

			expect(isJumpDestination(JUMPDEST)).toBe(true);
			expect(isJumpDestination(ADD)).toBe(false);
		});

		it("should find valid jump destinations with jumpDests()", async () => {
			const { jumpDests, JUMPDEST, PUSH1, STOP } = await import(
				"../../../src/primitives/Opcode/index.js"
			);

			// Simple bytecode with JUMPDEST at position 2
			// PUSH1 0x00 JUMPDEST STOP = [0x60, 0x00, 0x5b, 0x00]
			const bytecode = new Uint8Array([PUSH1, 0x00, JUMPDEST, STOP]);
			const dests = jumpDests(bytecode);

			expect(dests).toBeDefined();
			// Position 2 should be a valid jump destination
		});

		it("should check if position is valid jump dest with isValidJumpDest()", async () => {
			const { isValidJumpDest, JUMPDEST, PUSH1, STOP } = await import(
				"../../../src/primitives/Opcode/index.js"
			);

			const bytecode = new Uint8Array([PUSH1, 0x00, JUMPDEST, STOP]);

			// Position 2 is JUMPDEST, should be valid
			expect(isValidJumpDest(bytecode, 2)).toBe(true);
			// Position 0 is PUSH1, not valid
			expect(isValidJumpDest(bytecode, 0)).toBe(false);
			// Position 1 is PUSH data, not valid
			expect(isValidJumpDest(bytecode, 1)).toBe(false);
		});
	});

	describe("Terminating Opcodes", () => {
		it("should check if opcode terminates with isTerminating()", async () => {
			const { isTerminating, STOP, RETURN, REVERT, ADD } = await import(
				"../../../src/primitives/Opcode/index.js"
			);

			expect(isTerminating(STOP)).toBe(true);
			expect(isTerminating(RETURN)).toBe(true);
			expect(isTerminating(REVERT)).toBe(true);
			expect(isTerminating(ADD)).toBe(false);
		});

		it("should check if opcode is terminator with isTerminator()", async () => {
			const { isTerminator, STOP, ADD } = await import(
				"../../../src/primitives/Opcode/index.js"
			);

			expect(isTerminator(STOP)).toBe(true);
			expect(isTerminator(ADD)).toBe(false);
		});
	});

	describe("LOG Opcodes", () => {
		it("should check if opcode is LOG with isLog()", async () => {
			const { isLog, LOG0, LOG1, LOG2, LOG3, LOG4, ADD } = await import(
				"../../../src/primitives/Opcode/index.js"
			);

			expect(isLog(LOG0)).toBe(true);
			expect(isLog(LOG1)).toBe(true);
			expect(isLog(LOG2)).toBe(true);
			expect(isLog(LOG3)).toBe(true);
			expect(isLog(LOG4)).toBe(true);
			expect(isLog(ADD)).toBe(false);
		});

		it("should get log topic count with logTopics()", async () => {
			const { logTopics, LOG0, LOG1, LOG4 } = await import(
				"../../../src/primitives/Opcode/index.js"
			);

			expect(logTopics(LOG0)).toBe(0);
			expect(logTopics(LOG1)).toBe(1);
			expect(logTopics(LOG4)).toBe(4);
		});
	});

	describe("Disassembly", () => {
		it("should disassemble bytecode with disassemble()", async () => {
			const { disassemble, PUSH1, ADD, STOP } = await import(
				"../../../src/primitives/Opcode/index.js"
			);

			// PUSH1 0x02 PUSH1 0x03 ADD STOP
			const bytecode = new Uint8Array([
				PUSH1,
				0x02,
				PUSH1,
				0x03,
				ADD,
				STOP,
			]);
			const instructions = disassemble(bytecode);

			expect(Array.isArray(instructions)).toBe(true);
			expect(instructions.length).toBeGreaterThan(0);
		});

		it("should format instruction with format()", async () => {
			const { format, PUSH1 } = await import(
				"../../../src/primitives/Opcode/index.js"
			);

			// format expects { offset, opcode, immediate }
			const formatted = format({
				opcode: PUSH1,
				offset: 0,
				immediate: new Uint8Array([0x42]),
			});

			expect(typeof formatted).toBe("string");
			expect(formatted).toContain("PUSH1");
		});
	});

	describe("Parse", () => {
		it("should parse bytecode into instructions with parse()", async () => {
			const { parse, PUSH1, STOP } = await import(
				"../../../src/primitives/Opcode/index.js"
			);

			// parse returns an array of all instructions
			const bytecode = new Uint8Array([PUSH1, 0x42, STOP]);
			const instructions = parse(bytecode);

			expect(Array.isArray(instructions)).toBe(true);
			expect(instructions.length).toBe(2);
			expect(instructions[0].opcode).toBe(PUSH1);
			expect(instructions[0].immediate).toEqual(new Uint8Array([0x42]));
			expect(instructions[1].opcode).toBe(STOP);
		});
	});
});

```
