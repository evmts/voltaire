---
title: '[TS/JS] docs/primitives/address/index.test.ts'
source: 'docs/primitives/address/index.test.ts'
---

> Auto-generated from test file: docs/primitives/address/index.test.ts

```typescript
/**
 * Tests for docs/primitives/address/index.mdx
 *
 * Validates that all code examples in the Address documentation work correctly.
 *
 * DOC BUGS FOUND:
 * - Checksummed address in docs is wrong: docs say "0x742d35Cc6634C0532925a3b844Bc9e7595f51e3e"
 *   but actual EIP-55 checksum is "0x742d35CC6634c0532925a3B844bc9e7595f51E3e"
 * - HEX_SIZE is not exported from Address namespace (only in constants.js)
 * - fromPrivateKey docs show hex string but API expects Uint8Array
 * - toChecksummed is not a direct re-export (needs to use Address.toChecksummed)
 */
import { describe, expect, it } from "vitest";

describe("Address Documentation - index.mdx", () => {
	describe("Quick Start - Basic Usage", () => {
		it("should create address from hex string", async () => {
			const { Address } = await import("../../../src/primitives/Address/index.js");

			const addr = Address.from("0x742d35Cc6634C0532925a3b844Bc9e7595f51e3e");

			expect(addr).toBeInstanceOf(Uint8Array);
			expect(addr.length).toBe(20);
		});

		it("should get checksummed representation", async () => {
			const { Address } = await import("../../../src/primitives/Address/index.js");

			const addr = Address.from("0x742d35Cc6634C0532925a3b844Bc9e7595f51e3e");
			const checksummed = Address.toChecksummed(addr);

			// NOTE: Docs have wrong checksum - actual EIP-55 checksum differs
			expect(checksummed).toBe("0x742d35CC6634c0532925a3B844bc9e7595f51E3e");
		});

		it("should get lowercase hex", async () => {
			const { Address } = await import("../../../src/primitives/Address/index.js");

			const addr = Address.from("0x742d35Cc6634C0532925a3b844Bc9e7595f51e3e");
			const hex = Address.toHex(addr);

			expect(hex).toBe("0x742d35cc6634c0532925a3b844bc9e7595f51e3e");
		});

		it("should validate checksum", async () => {
			const { Address } = await import("../../../src/primitives/Address/index.js");

			// The actual EIP-55 checksummed address
			const actualChecksummed = "0x742d35CC6634c0532925a3B844bc9e7595f51E3e";
			expect(Address.isValidChecksum(actualChecksummed)).toBe(true);

			// Invalid checksum (wrong case)
			expect(
				Address.isValidChecksum("0x742D35cc6634c0532925a3b844bc9e7595f51e3e"),
			).toBe(false);
		});
	});

	describe("Quick Start - From Public Key", () => {
		it("should derive address from private key", async () => {
			const { Address } = await import("../../../src/primitives/Address/index.js");
			const { Hex } = await import("../../../src/primitives/Hex/index.js");

			// Known test vector from Foundry anvil - must be Uint8Array, not hex string
			const privateKeyHex =
				"0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80";
			const privateKey = Hex.toBytes(privateKeyHex);
			const addr = Address.fromPrivateKey(privateKey);

			expect(Address.toChecksummed(addr)).toBe(
				"0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266",
			);
		});

		it("should derive from public key", async () => {
			const { Address } = await import("../../../src/primitives/Address/index.js");
			const { Secp256k1 } = await import("../../../src/crypto/Secp256k1/index.js");
			const { Hex } = await import("../../../src/primitives/Hex/index.js");

			const privateKeyHex =
				"0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80";
			const privateKey = Hex.toBytes(privateKeyHex);
			const pubKey = Secp256k1.derivePublicKey(privateKey);

			// DOC BUG: docs show fromPublicKey(x, y) but API takes full 64-byte pubkey
			const addr = Address.fromPublicKey(pubKey);

			expect(Address.toChecksummed(addr)).toBe(
				"0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266",
			);
		});
	});

	describe("Quick Start - Contract Addresses", () => {
		it("should calculate CREATE address", async () => {
			const { Address } = await import("../../../src/primitives/Address/index.js");

			const deployer = Address.from(
				"0x742d35Cc6634C0532925a3b844Bc9e7595f51e3e",
			);
			const nonce = 0n;
			const createAddr = Address.calculateCreateAddress(deployer, nonce);

			// CREATE address is deterministic: keccak256(rlp([sender, nonce]))[12:]
			expect(createAddr).toBeInstanceOf(Uint8Array);
			expect(createAddr.length).toBe(20);
		});

		it("should calculate CREATE2 address", async () => {
			const { Address } = await import("../../../src/primitives/Address/index.js");
			const { Hex } = await import("../../../src/primitives/Hex/index.js");

			const deployer = Address.from(
				"0x742d35Cc6634C0532925a3b844Bc9e7595f51e3e",
			);
			const salt = Hex.toBytes(
				"0x0000000000000000000000000000000000000000000000000000000000001234",
			);
			const initCode = Hex.toBytes("0x6080604052348015600f57600080fd5b50");

			const create2Addr = Address.calculateCreate2Address(
				deployer,
				salt,
				initCode,
			);

			// CREATE2 address is deterministic: keccak256(0xff ++ sender ++ salt ++ keccak256(initCode))[12:]
			expect(create2Addr).toBeInstanceOf(Uint8Array);
			expect(create2Addr.length).toBe(20);
		});
	});

	describe("Developer Experience", () => {
		it("should create address from bigint", async () => {
			const { Address } = await import("../../../src/primitives/Address/index.js");

			// As shown in docs - Address from bigint literal
			const address = Address(
				0x742d35cc6634c0532925a3b844bc9e7595f51e3en,
			);

			expect(address).toBeInstanceOf(Uint8Array);
			expect(address.length).toBe(20);
			expect(Address.toHex(address)).toBe(
				"0x742d35cc6634c0532925a3b844bc9e7595f51e3e",
			);
		});
	});

	describe("Constants", () => {
		it("should have SIZE constant", async () => {
			const { Address } = await import("../../../src/primitives/Address/index.js");

			expect(Address.SIZE).toBe(20);
		});

		it.skip("should have HEX_SIZE constant", async () => {
			// DOC BUG: HEX_SIZE is not exported from Address namespace
			// It's only available in constants.js
			const { Address } = await import("../../../src/primitives/Address/index.js");

			expect(Address.HEX_SIZE).toBe(42);
		});

		it("should have NATIVE_ASSET_ADDRESS constant (ERC-7528)", async () => {
			const { NATIVE_ASSET_ADDRESS } = await import(
				"../../../src/primitives/Address/index.js"
			);

			expect(NATIVE_ASSET_ADDRESS).toBe(
				"0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE",
			);
		});
	});

	describe("Usage Patterns - Validating User Input", () => {
		it("should validate addresses with isValid", async () => {
			const { Address } = await import("../../../src/primitives/Address/index.js");

			expect(
				Address.isValid("0x742d35Cc6634C0532925a3b844Bc9e7595f51e3e"),
			).toBe(true);
			expect(Address.isValid("invalid")).toBe(false);
			expect(Address.isValid("0x123")).toBe(false);
		});
	});

	describe("Usage Patterns - Sorting and Deduplicating", () => {
		it("should sort addresses", async () => {
			const { Address } = await import("../../../src/primitives/Address/index.js");

			const addresses = [
				Address.from("0xcccccccccccccccccccccccccccccccccccccccc"),
				Address.from("0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"),
				Address.from("0xbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb"),
			];

			const sorted = Address.sortAddresses(addresses);

			expect(Address.toHex(sorted[0])).toBe(
				"0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa",
			);
			expect(Address.toHex(sorted[1])).toBe(
				"0xbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb",
			);
			expect(Address.toHex(sorted[2])).toBe(
				"0xcccccccccccccccccccccccccccccccccccccccc",
			);
		});

		it("should deduplicate addresses", async () => {
			const { Address } = await import("../../../src/primitives/Address/index.js");

			const addr1 = Address.from(
				"0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa",
			);
			const addr2 = Address.from(
				"0xbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb",
			);
			// Duplicate of addr1
			const addr3 = Address.from(
				"0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa",
			);

			const unique = Address.deduplicateAddresses([addr1, addr2, addr3]);

			expect(unique.length).toBe(2);
		});
	});

	describe("Tree-Shaking Imports", () => {
		it("should support direct function imports", async () => {
			// DOC BUG: toChecksummed is not a direct export, only available as Address.toChecksummed
			const { fromHex, equals, Address } = await import(
				"../../../src/primitives/Address/index.js"
			);

			const addr = fromHex("0x742d35cc6634c0532925a3b844bc9e7595f51e3e");
			const checksummed = Address.toChecksummed(addr);
			const isEqual = equals(addr, addr);

			// NOTE: Actual checksummed value differs from docs
			expect(checksummed).toBe("0x742d35CC6634c0532925a3B844bc9e7595f51E3e");
			expect(isEqual).toBe(true);
		});
	});

	describe("Zero Address", () => {
		it("should create zero address", async () => {
			const { Address } = await import("../../../src/primitives/Address/index.js");

			const zero = Address.zero();

			expect(Address.toHex(zero)).toBe(
				"0x0000000000000000000000000000000000000000",
			);
			expect(Address.isZero(zero)).toBe(true);
		});
	});

	describe("Equality and Comparison", () => {
		it("should compare addresses for equality", async () => {
			const { Address } = await import("../../../src/primitives/Address/index.js");

			const addr1 = Address.from(
				"0x742d35Cc6634C0532925a3b844Bc9e7595f51e3e",
			);
			const addr2 = Address.from(
				"0x742d35Cc6634C0532925a3b844Bc9e7595f51e3e",
			);
			const addr3 = Address.from(
				"0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045",
			);

			expect(Address.equals(addr1, addr2)).toBe(true);
			expect(Address.equals(addr1, addr3)).toBe(false);
		});

		it("should compare addresses for ordering", async () => {
			const { Address } = await import("../../../src/primitives/Address/index.js");

			const lower = Address.from(
				"0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa",
			);
			const higher = Address.from(
				"0xbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb",
			);

			expect(Address.compare(lower, higher)).toBe(-1);
			expect(Address.compare(higher, lower)).toBe(1);
			expect(Address.compare(lower, lower)).toBe(0);
		});
	});
});

```
