---
title: '[TS/JS] docs/primitives/eventlog/getIndexedTopics.test.ts'
source: 'docs/primitives/eventlog/getIndexedTopics.test.ts'
---

> Auto-generated from test file: docs/primitives/eventlog/getIndexedTopics.test.ts

```typescript
/**
 * Tests for docs/primitives/eventlog/getIndexedTopics.mdx
 * Tests the code examples from the EventLog.getIndexedTopics() documentation
 */

import { describe, expect, it } from "vitest";

describe("EventLog getIndexedTopics.mdx documentation examples", () => {
	describe("Indexed Parameter Limits", () => {
		it("max 3 indexed parameters for non-anonymous events", async () => {
			const EventLog = await import(
				"../../../src/primitives/EventLog/index.js"
			);
			const Address = await import("../../../src/primitives/Address/index.js");
			const Hash = await import("../../../src/primitives/Hash/index.js");

			// MaxIndexed(address indexed param1, address indexed param2, uint256 indexed param3, uint256 param4)
			const eventSig = Hash.from("0x" + "00".repeat(32));
			const param1 = Hash.from("0x" + "11".repeat(32));
			const param2 = Hash.from("0x" + "22".repeat(32));
			const param3 = Hash.from("0x" + "33".repeat(32));

			const log = EventLog.create({
				address: Address.Address.zero(),
				topics: [eventSig, param1, param2, param3],
				data: new Uint8Array([]), // param4 would be in data
			});

			const indexed = EventLog.getIndexedTopics(log);
			expect(indexed.length).toBe(3); // topic1, topic2, topic3
		});

		it("anonymous events can have 4 indexed parameters", async () => {
			const EventLog = await import(
				"../../../src/primitives/EventLog/index.js"
			);
			const Address = await import("../../../src/primitives/Address/index.js");
			const Hash = await import("../../../src/primitives/Hash/index.js");

			const param1 = Hash.from("0x" + "11".repeat(32));
			const param2 = Hash.from("0x" + "22".repeat(32));
			const param3 = Hash.from("0x" + "33".repeat(32));
			const param4 = Hash.from("0x" + "44".repeat(32));

			// Anonymous event: all 4 topics are indexed params (no signature)
			const anonymousLog = EventLog.create({
				address: Address.Address.zero(),
				topics: [param1, param2, param3, param4],
				data: new Uint8Array([]),
			});

			expect(anonymousLog.topics.length).toBe(4);

			// getIndexedTopics returns topic1-3 (3 items)
			const indexed = EventLog.getIndexedTopics(anonymousLog);
			expect(indexed.length).toBe(3);

			// To get ALL indexed params from anonymous event:
			const topic0 = EventLog.getTopic0(anonymousLog);
			const allParams = [topic0, ...indexed].filter(Boolean);
			expect(allParams.length).toBe(4);
		});
	});

	describe("Extracting Transfer Parameters", () => {
		it("decodes Transfer event indexed parameters", async () => {
			const EventLog = await import(
				"../../../src/primitives/EventLog/index.js"
			);
			const Address = await import("../../../src/primitives/Address/index.js");
			const Hash = await import("../../../src/primitives/Hash/index.js");

			// Transfer(address indexed from, address indexed to, uint256 value)
			const TRANSFER_SIG = Hash.from(
				"0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef",
			);
			const fromHash = Hash.from(
				"0x000000000000000000000000a1b2c3d4e5f67890abcdef1234567890abcdef12",
			);
			const toHash = Hash.from(
				"0x000000000000000000000000fedcba0987654321fedcba0987654321fedcba09",
			);

			const log = EventLog.create({
				address: Address.Address.zero(),
				topics: [TRANSFER_SIG, fromHash, toHash],
				data: new Uint8Array(32), // value
			});

			type EventLogType = ReturnType<typeof EventLog.create>;

			function decodeTransfer(log: EventLogType) {
				const sig = EventLog.getTopic0(log);
				if (!sig || !Hash.equals(sig, TRANSFER_SIG)) {
					throw new Error("Not a Transfer event");
				}

				const indexed = EventLog.getIndexedTopics(log);
				const [fromHash, toHash] = indexed;

				// Extract addresses from topic hashes (last 20 bytes)
				const from = Address.Address.fromBytes(
					new Uint8Array(fromHash!).slice(12),
				);
				const to = Address.Address.fromBytes(
					new Uint8Array(toHash!).slice(12),
				);

				return { from, to };
			}

			const transfer = decodeTransfer(log);
			expect(Address.toHex(transfer.from)).toBe(
				"0xa1b2c3d4e5f67890abcdef1234567890abcdef12",
			);
			expect(Address.toHex(transfer.to)).toBe(
				"0xfedcba0987654321fedcba0987654321fedcba09",
			);
		});
	});

	describe("Validating Parameter Count", () => {
		it("validates event structure by indexed param count", async () => {
			const EventLog = await import(
				"../../../src/primitives/EventLog/index.js"
			);
			const Address = await import("../../../src/primitives/Address/index.js");
			const Hash = await import("../../../src/primitives/Hash/index.js");

			type EventLogType = ReturnType<typeof EventLog.create>;

			function validateEventStructure(
				log: EventLogType,
				expectedCount: number,
			): boolean {
				const indexed = EventLog.getIndexedTopics(log);

				if (indexed.length !== expectedCount) {
					return false;
				}

				return true;
			}

			// Transfer has 2 indexed parameters (from, to)
			const transferLog = EventLog.create({
				address: Address.Address.zero(),
				topics: [
					Hash.from("0x" + "00".repeat(32)),
					Hash.from("0x" + "11".repeat(32)),
					Hash.from("0x" + "22".repeat(32)),
				],
				data: new Uint8Array([]),
			});

			// Approval has 2 indexed parameters (owner, spender)
			const approvalLog = EventLog.create({
				address: Address.Address.zero(),
				topics: [
					Hash.from("0x" + "00".repeat(32)),
					Hash.from("0x" + "11".repeat(32)),
					Hash.from("0x" + "22".repeat(32)),
				],
				data: new Uint8Array([]),
			});

			expect(validateEventStructure(transferLog, 2)).toBe(true);
			expect(validateEventStructure(approvalLog, 2)).toBe(true);
		});
	});

	describe("Destructuring Parameters", () => {
		it("destructures indexed parameters", async () => {
			const EventLog = await import(
				"../../../src/primitives/EventLog/index.js"
			);
			const Address = await import("../../../src/primitives/Address/index.js");
			const Hash = await import("../../../src/primitives/Hash/index.js");

			// Approval(address indexed owner, address indexed spender, uint256 value)
			const log = EventLog.create({
				address: Address.Address.zero(),
				topics: [
					Hash.from("0x" + "00".repeat(32)), // event sig
					Hash.from("0x" + "11".repeat(32)), // owner
					Hash.from("0x" + "22".repeat(32)), // spender
				],
				data: new Uint8Array([]),
			});

			// NOTE: Docs show const [ownerHash, spenderHash] = log.getIndexedTopics()
			// Actual API: const [ownerHash, spenderHash] = EventLog.getIndexedTopics(log)
			const [ownerHash, spenderHash] = EventLog.getIndexedTopics(log);

			expect(ownerHash).toBeDefined();
			expect(spenderHash).toBeDefined();
		});
	});

	describe("Empty Indexed Topics", () => {
		it("returns empty array when only topic0 present", async () => {
			const EventLog = await import(
				"../../../src/primitives/EventLog/index.js"
			);
			const Address = await import("../../../src/primitives/Address/index.js");
			const Hash = await import("../../../src/primitives/Hash/index.js");

			// Event with no indexed parameters
			const log = EventLog.create({
				address: Address.Address.zero(),
				topics: [Hash.from("0x" + "00".repeat(32))], // Only signature
				data: new Uint8Array([]),
			});

			const indexed = EventLog.getIndexedTopics(log);
			expect(indexed.length).toBe(0);
		});
	});

	describe("Extracting Addresses from Topics", () => {
		it("extracts address from 32-byte topic hash", async () => {
			const Address = await import("../../../src/primitives/Address/index.js");
			const Hash = await import("../../../src/primitives/Hash/index.js");

			// Addresses in topics are left-padded to 32 bytes
			const topicHash = Hash.from(
				"0x000000000000000000000000a1b2c3d4e5f67890abcdef1234567890abcdef12",
			);

			// Extract address (last 20 bytes)
			const address = Address.Address.fromBytes(
				new Uint8Array(topicHash).slice(12),
			);

			expect(Address.toHex(address)).toBe(
				"0xa1b2c3d4e5f67890abcdef1234567890abcdef12",
			);
		});
	});
});

```
