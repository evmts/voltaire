---
title: '[TS/JS] docs/playbooks/ethers-interface.test.ts'
source: 'docs/playbooks/ethers-interface.test.ts'
---

> Auto-generated from test file: docs/playbooks/ethers-interface.test.ts

```typescript
/**
 * Tests for ethers-style interface playbook
 * @see /docs/playbooks/ethers-interface.mdx
 *
 * Note: The playbook documents a REFERENCE IMPLEMENTATION in examples/ethers-interface/.
 * Tests cover the ABI encoding/decoding patterns using available primitives.
 *
 * API DISCREPANCIES:
 * - Interface class is in examples/ethers-interface/, not library export
 * - Abi primitive IS available for encoding/decoding
 */
import { describe, expect, it } from "vitest";

describe("Ethers Interface Playbook", () => {
	it("should define function ABI item", () => {
		// From playbook: function ABI structure
		const functionAbi = {
			type: "function",
			name: "transfer",
			inputs: [
				{ type: "address", name: "to" },
				{ type: "uint256", name: "amount" },
			],
			outputs: [{ type: "bool", name: "" }],
			stateMutability: "nonpayable",
		} as const;

		expect(functionAbi.name).toBe("transfer");
		expect(functionAbi.inputs).toHaveLength(2);
	});

	it("should define event ABI item", () => {
		// From playbook: event ABI structure
		const eventAbi = {
			type: "event",
			name: "Transfer",
			inputs: [
				{ type: "address", name: "from", indexed: true },
				{ type: "address", name: "to", indexed: true },
				{ type: "uint256", name: "value", indexed: false },
			],
		} as const;

		expect(eventAbi.inputs.filter((i) => i.indexed)).toHaveLength(2);
	});

	it("should define error ABI item", () => {
		// From playbook: custom error structure
		const errorAbi = {
			type: "error",
			name: "InsufficientBalance",
			inputs: [
				{ type: "uint256", name: "available" },
				{ type: "uint256", name: "required" },
			],
		} as const;

		expect(errorAbi.name).toBe("InsufficientBalance");
		expect(errorAbi.inputs).toHaveLength(2);
	});

	it("should compute function selector", async () => {
		const { Keccak256 } = await import("../../src/crypto/index.js");
		const { Hex } = await import("../../src/primitives/Hex/index.js");

		// transfer(address,uint256) selector
		const signature = "transfer(address,uint256)";
		const hash = Keccak256.hash(new TextEncoder().encode(signature));
		const selector = Hex.fromBytes(hash.slice(0, 4));

		expect(selector).toBe("0xa9059cbb");
	});

	it("should compute event topic hash", async () => {
		const { Keccak256 } = await import("../../src/crypto/index.js");
		const { Hex } = await import("../../src/primitives/Hex/index.js");

		// Transfer(address,address,uint256) topic
		const signature = "Transfer(address,address,uint256)";
		const hash = Keccak256.hash(new TextEncoder().encode(signature));
		const topicHash = Hex.fromBytes(hash);

		expect(topicHash).toBe(
			"0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef",
		);
	});

	it("should define Interface methods", () => {
		// From playbook: Interface method list
		const methods = [
			"encodeFunctionData",
			"decodeFunctionData",
			"decodeFunctionResult",
			"encodeFunctionResult",
			"encodeEventLog",
			"decodeEventLog",
			"encodeFilterTopics",
			"encodeErrorResult",
			"decodeErrorResult",
			"encodeDeploy",
			"parseTransaction",
			"parseLog",
			"parseError",
			"getFunction",
			"getEvent",
			"getError",
			"forEachFunction",
			"forEachEvent",
			"forEachError",
			"format",
			"formatJson",
		];

		expect(methods).toContain("encodeFunctionData");
		expect(methods).toContain("decodeEventLog");
		expect(methods).toContain("parseTransaction");
	});

	it("should define FunctionFragment properties", () => {
		// From playbook: FunctionFragment structure
		interface FunctionFragment {
			name: string;
			selector: string;
			inputs: unknown[];
			outputs: unknown[];
			stateMutability: "pure" | "view" | "nonpayable" | "payable";
			constant: boolean;
			payable: boolean;
		}

		const fragment: FunctionFragment = {
			name: "transfer",
			selector: "0xa9059cbb",
			inputs: [],
			outputs: [],
			stateMutability: "nonpayable",
			constant: false,
			payable: false,
		};

		expect(fragment.selector).toBe("0xa9059cbb");
	});

	it("should define EventFragment properties", () => {
		// From playbook: EventFragment structure
		interface EventFragment {
			name: string;
			topicHash: string;
			inputs: unknown[];
			anonymous: boolean;
		}

		const fragment: EventFragment = {
			name: "Transfer",
			topicHash:
				"0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef",
			inputs: [],
			anonymous: false,
		};

		expect(fragment.topicHash.length).toBe(66); // 0x + 64 hex chars
	});

	it("should handle human-readable format modes", () => {
		// From playbook: format options
		const fullFormat = "function transfer(address to, uint256 amount) returns (bool)";
		const minimalFormat = "function transfer(address,uint256) returns (bool)";

		expect(fullFormat).toContain("to");
		expect(minimalFormat).not.toContain("to");
	});

	it("should define ParamType properties", () => {
		// From playbook: ParamType for tuple
		interface ParamType {
			type: string;
			name?: string;
			components?: ParamType[];
		}

		const tupleParam: ParamType = {
			type: "tuple",
			name: "data",
			components: [
				{ type: "uint256", name: "id" },
				{ type: "string", name: "name" },
			],
		};

		expect(tupleParam.type).toBe("tuple");
		expect(tupleParam.components).toHaveLength(2);
	});

	it("should handle filter topics with null for wildcards", () => {
		// From playbook: null for any value
		const filterTopics = [
			"0x742d35Cc6634C0532925a3b844Bc454e4438f44e", // specific from
			null, // any recipient
		];

		expect(filterTopics[0]).toBe("0x742d35Cc6634C0532925a3b844Bc454e4438f44e");
		expect(filterTopics[1]).toBeNull();
	});

	it("should handle constructor encoding", () => {
		// From playbook: encodeDeploy for constructor args
		const constructorAbi = [
			{
				type: "constructor",
				inputs: [
					{ type: "string", name: "name" },
					{ type: "string", name: "symbol" },
				],
			},
		];

		expect(constructorAbi[0].type).toBe("constructor");
		expect(constructorAbi[0].inputs).toHaveLength(2);
	});

	it("should work with Abi primitive", async () => {
		const Abi = await import("../../src/primitives/Abi/index.js");

		// Abi module should exist for encoding/decoding
		expect(Abi).toBeDefined();
	});

	it("should define standard error selectors", async () => {
		const { Keccak256 } = await import("../../src/crypto/index.js");
		const { Hex } = await import("../../src/primitives/Hex/index.js");

		// Error(string) selector
		const errorSig = "Error(string)";
		const errorHash = Keccak256.hash(new TextEncoder().encode(errorSig));
		const errorSelector = Hex.fromBytes(errorHash.slice(0, 4));
		expect(errorSelector).toBe("0x08c379a0");

		// Panic(uint256) selector
		const panicSig = "Panic(uint256)";
		const panicHash = Keccak256.hash(new TextEncoder().encode(panicSig));
		const panicSelector = Hex.fromBytes(panicHash.slice(0, 4));
		expect(panicSelector).toBe("0x4e487b71");
	});
});

```
