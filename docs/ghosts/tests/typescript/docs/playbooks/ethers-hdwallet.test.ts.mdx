---
title: '[TS/JS] docs/playbooks/ethers-hdwallet.test.ts'
source: 'docs/playbooks/ethers-hdwallet.test.ts'
---

> Auto-generated from test file: docs/playbooks/ethers-hdwallet.test.ts

```typescript
/**
 * Tests for ethers HD wallet playbook
 * @see /docs/playbooks/ethers-hdwallet.mdx
 *
 * Note: The playbook documents a REFERENCE IMPLEMENTATION in examples/ethers-hdwallet/.
 * Tests cover the BIP-32/BIP-39 primitives that ARE available.
 *
 * API DISCREPANCIES:
 * - HDNodeWallet is in examples/ethers-hdwallet/, not library export
 * - Bip39 and HDWallet ARE available in src/crypto/
 */
import { describe, expect, it } from "vitest";

describe("Ethers HD Wallet Playbook", () => {
	it("should work with Bip39 mnemonic generation", async () => {
		const { Bip39 } = await import("../../src/crypto/index.js");

		// 12-word mnemonic (128 bits entropy)
		const mnemonic12 = Bip39.generateMnemonic(128);
		const words12 = mnemonic12.split(" ");
		expect(words12).toHaveLength(12);

		// 24-word mnemonic (256 bits entropy)
		const mnemonic24 = Bip39.generateMnemonic(256);
		const words24 = mnemonic24.split(" ");
		expect(words24).toHaveLength(24);
	});

	it("should validate mnemonic phrases", async () => {
		const { Bip39 } = await import("../../src/crypto/index.js");

		const validMnemonic =
			"abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon about";
		const invalidMnemonic = "invalid phrase here";

		expect(Bip39.validateMnemonic(validMnemonic)).toBe(true);
		expect(Bip39.validateMnemonic(invalidMnemonic)).toBe(false);
	});

	it("should derive seed from mnemonic", async () => {
		const { Bip39 } = await import("../../src/crypto/index.js");

		const mnemonic =
			"abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon about";
		const seed = Bip39.mnemonicToSeedSync(mnemonic);

		expect(seed).toBeInstanceOf(Uint8Array);
		expect(seed.length).toBe(64); // 512 bits
	});

	it("should derive seed with passphrase", async () => {
		const { Bip39 } = await import("../../src/crypto/index.js");

		const mnemonic =
			"abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon about";

		const seedNoPass = Bip39.mnemonicToSeedSync(mnemonic);
		const seedWithPass = Bip39.mnemonicToSeedSync(mnemonic, "secret");

		// Different passphrases produce different seeds
		expect(seedNoPass).not.toEqual(seedWithPass);
	});

	it("should work with HDWallet derivation", async () => {
		const { Bip39, HDWallet } = await import("../../src/crypto/index.js");

		const mnemonic =
			"abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon about";
		const seed = Bip39.mnemonicToSeedSync(mnemonic);

		const root = HDWallet.fromSeed(seed);
		expect(root).toBeDefined();
	});

	it("should derive Ethereum accounts with BIP-44 path", async () => {
		const { Bip39, HDWallet } = await import("../../src/crypto/index.js");

		const mnemonic =
			"abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon about";
		const seed = Bip39.mnemonicToSeedSync(mnemonic);
		const root = HDWallet.fromSeed(seed);

		// BIP-44 Ethereum path: m/44'/60'/0'/0/0
		const account0 = HDWallet.deriveEthereum(root, 0, 0);
		const account1 = HDWallet.deriveEthereum(root, 0, 1);

		expect(account0.privateKey).toBeInstanceOf(Uint8Array);
		expect(account1.privateKey).toBeInstanceOf(Uint8Array);
		expect(account0.privateKey).not.toEqual(account1.privateKey);
	});

	it("should define BIP-44 path components", () => {
		// From playbook: BIP-44 path structure
		// m/44'/60'/account'/0/index
		const path = {
			purpose: 44, // BIP-44
			coinType: 60, // Ethereum
			account: 0,
			change: 0, // External
			index: 0,
		};

		const fullPath = `m/${path.purpose}'/${path.coinType}'/${path.account}'/0/${path.index}`;
		expect(fullPath).toBe("m/44'/60'/0'/0/0");
	});

	it("should generate account paths", () => {
		// From playbook: getAccountPath and getIndexedAccountPath
		const getAccountPath = (account: number) => `m/44'/60'/${account}'/0/0`;

		const getIndexedAccountPath = (index: number) => `m/44'/60'/0'/0/${index}`;

		expect(getAccountPath(0)).toBe("m/44'/60'/0'/0/0");
		expect(getAccountPath(1)).toBe("m/44'/60'/1'/0/0");
		expect(getIndexedAccountPath(0)).toBe("m/44'/60'/0'/0/0");
		expect(getIndexedAccountPath(1)).toBe("m/44'/60'/0'/0/1");
	});

	it("should define HDNodeWallet properties", () => {
		// From playbook: HDNodeWallet property list
		const properties = [
			"address",
			"privateKey",
			"publicKey",
			"mnemonic",
			"path",
			"depth",
			"index",
			"chainCode",
			"fingerprint",
			"extendedKey",
		];

		expect(properties).toContain("address");
		expect(properties).toContain("privateKey");
		expect(properties).toContain("chainCode");
	});

	it("should define HDNodeWallet methods", () => {
		// From playbook: HDNodeWallet methods
		const staticMethods = [
			"fromPhrase",
			"fromMnemonic",
			"fromSeed",
			"fromExtendedKey",
			"createRandom",
		];

		const instanceMethods = [
			"derivePath",
			"deriveChild",
			"neuter",
			"signMessage",
			"signTransaction",
			"signTypedData",
		];

		expect(staticMethods).toContain("fromPhrase");
		expect(instanceMethods).toContain("derivePath");
	});

	it("should handle hardened derivation indicator", () => {
		// Hardened derivation uses ' or h suffix
		const hardenedIndex = 0x80000000; // 2^31

		const isHardened = (path: string) => path.includes("'") || path.includes("h");

		expect(isHardened("m/44'/60'/0'/0/0")).toBe(true);
		expect(isHardened("m/44/60/0/0/0")).toBe(false);

		// Hardened index calculation
		const account0Hardened = 0 + hardenedIndex;
		expect(account0Hardened).toBe(2147483648);
	});

	it("should define security best practices", () => {
		// From playbook: security considerations
		const bestPractices = [
			"Never log mnemonics",
			"Use passphrases",
			"Derive fresh addresses",
			"Clear memory when done",
			"Validate inputs",
		];

		expect(bestPractices).toContain("Never log mnemonics");
		expect(bestPractices).toContain("Use passphrases");
	});
});

```
