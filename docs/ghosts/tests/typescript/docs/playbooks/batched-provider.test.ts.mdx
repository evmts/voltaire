---
title: '[TS/JS] docs/playbooks/batched-provider.test.ts'
source: 'docs/playbooks/batched-provider.test.ts'
---

> Auto-generated from test file: docs/playbooks/batched-provider.test.ts

```typescript
/**
 * Tests for batched provider playbook
 * @see /docs/playbooks/batched-provider.mdx
 *
 * Note: The playbook documents a REFERENCE IMPLEMENTATION for JSON-RPC batching.
 * Tests cover the data structures and patterns shown in the guide.
 *
 * API DISCREPANCIES:
 * - createBatchedProvider is a reference implementation, not library export
 * - JSON-RPC batching patterns are documented as copyable implementation
 */
import { describe, expect, it } from "vitest";

describe("Batched Provider Playbook", () => {
	it("should understand JSON-RPC batch request format", () => {
		// From playbook: JSON-RPC batch request structure
		const batchRequest = [
			{ jsonrpc: "2.0", id: 1, method: "eth_blockNumber", params: [] },
			{
				jsonrpc: "2.0",
				id: 2,
				method: "eth_getBalance",
				params: ["0x742d35Cc6634C0532925a3b844Bc454e4438f44e", "latest"],
			},
		];

		expect(batchRequest).toHaveLength(2);
		expect(batchRequest[0].method).toBe("eth_blockNumber");
		expect(batchRequest[1].method).toBe("eth_getBalance");
	});

	it("should understand JSON-RPC batch response format", () => {
		// From playbook: responses may be out of order
		const batchResponse = [
			{ jsonrpc: "2.0", id: 2, result: "0xde0b6b3a7640000" },
			{ jsonrpc: "2.0", id: 1, result: "0x1234567" },
		];

		// Responses matched by id, not position
		const response1 = batchResponse.find((r) => r.id === 1);
		const response2 = batchResponse.find((r) => r.id === 2);

		expect(response1?.result).toBe("0x1234567");
		expect(response2?.result).toBe("0xde0b6b3a7640000");
	});

	it("should handle configuration options", () => {
		// From playbook: provider configuration
		const config = {
			http: {
				url: "https://eth.llamarpc.com",
				headers: { "X-API-Key": "your-key" },
				timeout: 30000,
			},
			wait: 10, // Debounce window (ms)
			maxBatchSize: 100, // Max requests per batch
		};

		expect(config.wait).toBe(10);
		expect(config.maxBatchSize).toBe(100);
		expect(config.http.timeout).toBe(30000);
	});

	it("should calculate performance improvement", () => {
		// From playbook: performance comparison
		const rtt = 50; // Round trip time in ms
		const numRequests = 10;

		const sequentialTime = rtt * numRequests; // 500ms
		const batchedTime = rtt; // 50ms (single batch)

		const improvement = sequentialTime / batchedTime;

		expect(sequentialTime).toBe(500);
		expect(batchedTime).toBe(50);
		expect(improvement).toBe(10); // 10x faster
	});

	it("should handle per-request errors with Promise.allSettled", () => {
		// From playbook: individual requests can fail independently
		type SettledResult<T> =
			| { status: "fulfilled"; value: T }
			| { status: "rejected"; reason: Error };

		const results: SettledResult<string>[] = [
			{ status: "fulfilled", value: "0x1234567" },
			{ status: "rejected", reason: new Error("Call failed") },
		];

		const successful = results.filter((r) => r.status === "fulfilled");
		const failed = results.filter((r) => r.status === "rejected");

		expect(successful).toHaveLength(1);
		expect(failed).toHaveLength(1);
	});

	it("should define error types", () => {
		// From playbook: error types
		const errorTypes = [
			"RpcError",
			"BatchTimeoutError",
			"HttpError",
			"MissingResponseError",
		];

		expect(errorTypes).toContain("RpcError");
		expect(errorTypes).toContain("BatchTimeoutError");
	});

	it("should handle RPC error structure", () => {
		// From playbook: RPC error with code and data
		interface RpcError {
			code: number;
			message: string;
			data?: unknown;
		}

		const error: RpcError = {
			code: -32000,
			message: "execution reverted",
			data: "0x08c379a0...",
		};

		expect(error.code).toBe(-32000);
		expect(error.message).toBe("execution reverted");
	});

	it("should track pending request count", () => {
		// From playbook: getPendingCount pattern
		let pendingCount = 0;

		const addRequest = () => {
			pendingCount++;
		};

		const flush = () => {
			const count = pendingCount;
			pendingCount = 0;
			return count;
		};

		addRequest();
		addRequest();
		expect(pendingCount).toBe(2);

		const flushed = flush();
		expect(flushed).toBe(2);
		expect(pendingCount).toBe(0);
	});

	it("should compare batching vs multicall use cases", () => {
		// From playbook: when to use each approach
		const useCases = {
			batching: {
				multipleRpcMethods: true,
				atomicReads: false,
				noContractDeployment: true,
			},
			multicall: {
				multipleRpcMethods: false,
				atomicReads: true,
				noContractDeployment: false,
			},
		};

		expect(useCases.batching.multipleRpcMethods).toBe(true);
		expect(useCases.multicall.atomicReads).toBe(true);
	});

	it("should handle request ID matching", () => {
		// From playbook: responses matched by ID, not array position
		const requests = [
			{ id: 1, method: "eth_blockNumber" },
			{ id: 2, method: "eth_chainId" },
			{ id: 3, method: "eth_gasPrice" },
		];

		// Response in different order
		const responses = [
			{ id: 3, result: "0x3b9aca00" },
			{ id: 1, result: "0x1234567" },
			{ id: 2, result: "0x1" },
		];

		const matchedResults = requests.map((req) => {
			const resp = responses.find((r) => r.id === req.id);
			return { method: req.method, result: resp?.result };
		});

		expect(matchedResults[0].method).toBe("eth_blockNumber");
		expect(matchedResults[0].result).toBe("0x1234567");
		expect(matchedResults[1].method).toBe("eth_chainId");
		expect(matchedResults[1].result).toBe("0x1");
	});

	it("should handle EIP-1193 provider interface", () => {
		// From playbook: wrapProvider expects EIP-1193 provider
		interface Eip1193Provider {
			request(args: { method: string; params?: unknown[] }): Promise<unknown>;
		}

		// Mock provider
		const mockProvider: Eip1193Provider = {
			request: async ({ method }) => {
				if (method === "eth_chainId") return "0x1";
				return null;
			},
		};

		expect(mockProvider).toHaveProperty("request");
	});
});

```
