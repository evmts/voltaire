---
title: '[TS/JS] docs/concepts/branded-types.test.ts'
source: 'docs/concepts/branded-types.test.ts'
---

> Auto-generated from test file: docs/concepts/branded-types.test.ts

```typescript
/**
 * Tests for code examples in docs/concepts/branded-types.mdx
 *
 * These tests verify that all code examples in the documentation work correctly.
 * API discrepancies are documented as comments.
 */
import { describe, expect, it } from "vitest";

describe("branded-types.mdx code examples", () => {
	// ==========================================================================
	// Section: 1. Branded Type (Strictest) - Example
	// ==========================================================================
	describe("Branded Type - Example", () => {
		it("fromHex creates AddressType, toHex and equals work", async () => {
			// Doc example imports from '@tevm/voltaire/Address'
			// Actual: import from src path
			const { fromHex, toHex, equals } = await import(
				"../../src/primitives/Address/index.js"
			);
			// Note: Type imports use static import at top of file
			// For runtime tests, we just use the values

			const addr = fromHex("0x742d35Cc6634C0532925a3b844Bc9e7595f51e3e");
			const hex = toHex(addr);
			const same = equals(addr, addr);

			expect(hex).toBe("0x742d35cc6634c0532925a3b844bc9e7595f51e3e");
			expect(same).toBe(true);
		});
	});

	// ==========================================================================
	// Section: 2. Namespace API (Most Convenient)
	// ==========================================================================
	describe("Namespace API - Example", () => {
		it("Address namespace functions work", async () => {
			// Doc: import { Address } from '@tevm/voltaire'
			const { Address } = await import(
				"../../src/primitives/Address/index.js"
			);

			const addr = Address("0x742d35Cc6634C0532925a3b844Bc9e7595f51e3e");

			// Namespace functions
			const hex = Address.toHex(addr);
			const isZero = Address.isZero(addr);

			expect(hex).toBe("0x742d35cc6634c0532925a3b844bc9e7595f51e3e");
			expect(isZero).toBe(false);

			// Still a Uint8Array
			expect(addr instanceof Uint8Array).toBe(true);
			expect(addr.length).toBe(20);
		});

		it("Address.toChecksummed works", async () => {
			const { Address } = await import(
				"../../src/primitives/Address/index.js"
			);

			const addr = Address("0x742d35Cc6634C0532925a3b844Bc9e7595f51e3e");
			const checksummed = Address.toChecksummed(addr);

			// EIP-55 checksummed
			// API discrepancy: Doc shows "0x742d35Cc6634c0532925a3b844bc9e7595F51E3E"
			// Actual EIP-55 checksum output for this address
			expect(checksummed).toBe("0x742d35CC6634c0532925a3B844bc9e7595f51E3e");
		});

		it("Address.equals compares two addresses", async () => {
			const { Address } = await import(
				"../../src/primitives/Address/index.js"
			);

			const addr = Address("0x742d35Cc6634C0532925a3b844Bc9e7595f51e3e");
			const other = Address("0x0000000000000000000000000000000000000000");

			expect(Address.equals(addr, addr)).toBe(true);
			expect(Address.equals(addr, other)).toBe(false);
		});
	});

	// ==========================================================================
	// Section: 3. Input Type (Loosest) - Constructor accepts multiple types
	// ==========================================================================
	describe("Input Type - Constructor accepts multiple types", () => {
		it("Address accepts hex string", async () => {
			const { Address } = await import(
				"../../src/primitives/Address/index.js"
			);

			const addr = Address("0x742d35Cc6634C0532925a3b844Bc9e7595f51e3e");
			expect(addr instanceof Uint8Array).toBe(true);
			expect(addr.length).toBe(20);
		});

		it("Address accepts Uint8Array", async () => {
			const { Address } = await import(
				"../../src/primitives/Address/index.js"
			);

			const addr = Address(new Uint8Array(20));
			expect(addr instanceof Uint8Array).toBe(true);
			expect(addr.length).toBe(20);
		});

		it("Address accepts bigint", async () => {
			const { Address } = await import(
				"../../src/primitives/Address/index.js"
			);

			// Doc example uses: 0x742d35Cc6634C0532925a3b844Bc9e7595f51e3en
			const addr = Address(0x742d35cc6634c0532925a3b844bc9e7595f51e3en);
			expect(addr instanceof Uint8Array).toBe(true);
			expect(addr.length).toBe(20);
		});
	});

	// ==========================================================================
	// Section: API Patterns - Namespace API (Default)
	// ==========================================================================
	describe("API Patterns - Namespace API", () => {
		it("static constructors work", async () => {
			const { Address } = await import(
				"../../src/primitives/Address/index.js"
			);

			// Address.fromHex
			const addr1 = Address.fromHex(
				"0x742d35Cc6634C0532925a3b844Bc9e7595f51e3e",
			);
			expect(addr1 instanceof Uint8Array).toBe(true);

			// Address.fromBytes
			const addr2 = Address.fromBytes(new Uint8Array(20));
			expect(addr2 instanceof Uint8Array).toBe(true);

			// Address.zero
			const addr3 = Address.zero();
			expect(Address.isZero(addr3)).toBe(true);
		});

		it("namespace functions return expected values", async () => {
			const { Address } = await import(
				"../../src/primitives/Address/index.js"
			);

			const addr = Address("0x742d35Cc6634C0532925a3b844Bc9e7595f51e3e");

			// toHex returns lowercase
			expect(Address.toHex(addr)).toBe(
				"0x742d35cc6634c0532925a3b844bc9e7595f51e3e",
			);

			// toChecksummed returns EIP-55 format
			// API discrepancy: Doc shows "0x742d35Cc6634c0532925a3b844bc9e7595F51E3E"
			expect(Address.toChecksummed(addr)).toBe(
				"0x742d35CC6634c0532925a3B844bc9e7595f51E3e",
			);

			// isZero
			expect(Address.isZero(addr)).toBe(false);
		});
	});

	// ==========================================================================
	// Section: Tree-Shakeable Imports
	// ==========================================================================
	describe("Tree-Shakeable Imports", () => {
		it("direct function imports work", async () => {
			// API discrepancy: Doc shows toChecksummed as tree-shakeable import
			// Actual: toChecksummed is only available via Address.toChecksummed
			// Only toHex, fromHex, equals are exported as standalone functions
			const { fromHex, toHex, equals, Address } = await import(
				"../../src/primitives/Address/index.js"
			);

			const addr = fromHex("0x742d35Cc6634C0532925a3b844Bc9e7595f51e3e");

			expect(toHex(addr)).toBe("0x742d35cc6634c0532925a3b844bc9e7595f51e3e");
			// toChecksummed is available via Address namespace
			expect(Address.toChecksummed(addr)).toBe(
				"0x742d35CC6634c0532925a3B844bc9e7595f51E3e",
			);

			const other = fromHex("0x0000000000000000000000000000000000000000");
			expect(equals(addr, other)).toBe(false);
			expect(equals(addr, addr)).toBe(true);
		});
	});

	// ==========================================================================
	// Section: Minimal Example (Optimal Bundle Size)
	// ==========================================================================
	describe("Minimal Example", () => {
		it("minimal imports work for basic operations", async () => {
			const { fromHex, toHex, equals } = await import(
				"../../src/primitives/Address/index.js"
			);

			const addr = fromHex("0x742d35Cc6634C0532925a3b844Bc9e7595f51e3e");
			const hex = toHex(addr);
			const same = equals(addr, addr);

			expect(hex).toBe("0x742d35cc6634c0532925a3b844bc9e7595f51e3e");
			expect(same).toBe(true);
		});
	});

	// ==========================================================================
	// Section: Brand Symbol
	// Note: brand symbol is internal implementation detail
	// ==========================================================================
	describe("Brand Symbol", () => {
		it("branded types are Uint8Array with brand", async () => {
			const { Address } = await import(
				"../../src/primitives/Address/index.js"
			);
			const { Hash } = await import("../../src/primitives/Hash/index.js");

			const addr = Address("0x742d35Cc6634C0532925a3b844Bc9e7595f51e3e");
			const hash = Hash.fromHex(
				"0x0000000000000000000000000000000000000000000000000000000000000000",
			);

			// Both are Uint8Arrays
			expect(addr instanceof Uint8Array).toBe(true);
			expect(hash instanceof Uint8Array).toBe(true);

			// Different lengths
			expect(addr.length).toBe(20);
			expect(hash.length).toBe(32);
		});
	});

	// ==========================================================================
	// Section: Type Variants - Hierarchical Types with Boolean Flags
	// Note: ChecksumAddress, LowercaseHex, UppercaseHex are type-level only
	// ==========================================================================
	describe("Type Variants", () => {
		it("toChecksummed, toLowercase, toUppercase produce different formats", async () => {
			const { Address } = await import(
				"../../src/primitives/Address/index.js"
			);

			const addr = Address("0x742d35Cc6634C0532925a3b844Bc9e7595f51e3e");

			const checksummed = Address.toChecksummed(addr);
			const lowercase = Address.toLowercase(addr);
			const uppercase = Address.toUppercase(addr);

			// Checksummed has mixed case per EIP-55
			// API discrepancy: Doc shows different checksum
			expect(checksummed).toBe("0x742d35CC6634c0532925a3B844bc9e7595f51E3e");

			// Lowercase is all lowercase
			expect(lowercase).toBe("0x742d35cc6634c0532925a3b844bc9e7595f51e3e");

			// Uppercase is all uppercase
			expect(uppercase).toBe("0x742D35CC6634C0532925A3B844BC9E7595F51E3E");
		});
	});

	// ==========================================================================
	// Section: Validation
	// ==========================================================================
	describe("Validation", () => {
		it("valid addresses are created successfully", async () => {
			const { Address } = await import(
				"../../src/primitives/Address/index.js"
			);

			// Valid
			const addr = Address("0x742d35Cc6634C0532925a3b844Bc9e7595f51e3e");
			expect(addr instanceof Uint8Array).toBe(true);
		});

		it("invalid hex throws error", async () => {
			const { Address } = await import(
				"../../src/primitives/Address/index.js"
			);

			// Invalid - throws error
			expect(() => Address("0xnot_valid")).toThrow();
		});

		it("invalid length throws error", async () => {
			const { Address } = await import(
				"../../src/primitives/Address/index.js"
			);

			// Too short
			expect(() => Address("0x123")).toThrow();
		});

		it("invalid Uint8Array length throws error", async () => {
			const { Address } = await import(
				"../../src/primitives/Address/index.js"
			);

			// Must be 20 bytes
			expect(() => Address(new Uint8Array(10))).toThrow();
		});
	});

	// ==========================================================================
	// Section: Console Formatting
	// Note: Custom console formatting relies on Symbol.for("nodejs.util.inspect.custom")
	// ==========================================================================
	describe("Console Formatting", () => {
		it("Address from bigint works", async () => {
			const { Address } = await import(
				"../../src/primitives/Address/index.js"
			);

			// Doc example: Address(0x742d35Cc6634C0532925a3b844Bc9e7595f51e3en)
			const addr = Address(0x742d35cc6634c0532925a3b844bc9e7595f51e3en);
			expect(addr instanceof Uint8Array).toBe(true);
			expect(addr.length).toBe(20);
		});
	});

	// ==========================================================================
	// Section: Migration Guide - From String Types
	// ==========================================================================
	describe("Migration - From String Types", () => {
		it("Address validates input and throws on invalid", async () => {
			const { Address } = await import(
				"../../src/primitives/Address/index.js"
			);

			// Doc example: Address('0x123') throws error
			expect(() => Address("0x123")).toThrow();
		});
	});

	// ==========================================================================
	// Section: Best Practices - Validate at Boundaries
	// ==========================================================================
	describe("Best Practices - Validate at Boundaries", () => {
		it("validate external input at boundary, trust internal types", async () => {
			const { Address } = await import(
				"../../src/primitives/Address/index.js"
			);
			// Note: AddressType is a compile-time type alias for branded Uint8Array
			// At runtime we just use Uint8Array

			// Simulating: validate external input at boundary
			function processRequest(req: { to: string; amount: string }) {
				const to = Address(req.to); // Validate here
				return transfer(to, BigInt(req.amount));
			}

			// Internal function trusts the type
			function transfer(to: Uint8Array, amount: bigint): boolean {
				// No validation needed - type guarantees it's valid
				return to.length === 20 && amount > 0n;
			}

			const result = processRequest({
				to: "0x742d35Cc6634C0532925a3b844Bc9e7595f51e3e",
				amount: "100",
			});

			expect(result).toBe(true);
		});
	});

	// ==========================================================================
	// Section: Best Practices - Use Namespace API for Application Code
	// ==========================================================================
	describe("Best Practices - Namespace API for Application Code", () => {
		it("Hash namespace works alongside Address", async () => {
			const { Address } = await import(
				"../../src/primitives/Address/index.js"
			);
			const { Hash } = await import("../../src/primitives/Hash/index.js");

			const addr = Address("0x742d35Cc6634C0532925a3b844Bc9e7595f51e3e");
			const hash = Hash.fromHex(
				"0x0000000000000000000000000000000000000000000000000000000000000001",
			);

			// Namespace functions
			const checksummed = Address.toChecksummed(addr);
			const hashHex = Hash.toHex(hash);

			// API discrepancy: Doc shows different checksum
			expect(checksummed).toBe("0x742d35CC6634c0532925a3B844bc9e7595f51E3e");
			expect(hashHex).toBe(
				"0x0000000000000000000000000000000000000000000000000000000000000001",
			);
		});
	});

	// ==========================================================================
	// Section: Best Practices - Use Tree-Shakeable for Libraries
	// ==========================================================================
	describe("Best Practices - Tree-Shakeable for Libraries", () => {
		it("formatAddress function works with tree-shakeable imports", async () => {
			const { fromHex, toHex } = await import(
				"../../src/primitives/Address/index.js"
			);

			// Doc example: minimal bundle impact
			function formatAddress(input: string) {
				const addr = fromHex(input);
				return toHex(addr);
			}

			const result = formatAddress(
				"0x742d35Cc6634C0532925a3b844Bc9e7595f51e3e",
			);
			expect(result).toBe("0x742d35cc6634c0532925a3b844bc9e7595f51e3e");
		});
	});
});

```
