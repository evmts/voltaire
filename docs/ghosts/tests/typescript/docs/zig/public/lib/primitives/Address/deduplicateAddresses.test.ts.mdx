---
title: '[TS/JS] docs/zig/public/lib/primitives/Address/deduplicateAddresses.test.ts'
source: 'docs/zig/public/lib/primitives/Address/deduplicateAddresses.test.ts'
---

> Auto-generated from test file: docs/zig/public/lib/primitives/Address/deduplicateAddresses.test.ts

```typescript
import { describe, expect, it } from "vitest";
import { Address } from "./index.js";
import { deduplicateAddresses } from "./deduplicateAddresses.js";

describe("deduplicateAddresses", () => {
	it("removes duplicate addresses preserving first occurrence", () => {
		const addr1 = Address.fromHex("0x742d35cc6634c0532925a3b844bc9e7595f251e3");
		const addr2 = Address.fromHex("0x0000000000000000000000000000000000000001");
		const addr3 = Address.fromHex("0x742d35cc6634c0532925a3b844bc9e7595f251e3");

		const result = deduplicateAddresses([addr1, addr2, addr3]);

		expect(result.length).toBe(2);
		expect(Address.equals(result[0], addr1)).toBe(true);
		expect(Address.equals(result[1], addr2)).toBe(true);
	});

	it("preserves order of first occurrences", () => {
		const addr1 = Address.fromHex("0x0000000000000000000000000000000000000001");
		const addr2 = Address.fromHex("0x0000000000000000000000000000000000000002");
		const addr3 = Address.fromHex("0x0000000000000000000000000000000000000003");
		const addr1Dup = Address.fromHex(
			"0x0000000000000000000000000000000000000001",
		);

		const result = deduplicateAddresses([addr1, addr2, addr3, addr1Dup]);

		expect(result.length).toBe(3);
		expect(result[0]?.[19]).toBe(1);
		expect(result[1]?.[19]).toBe(2);
		expect(result[2]?.[19]).toBe(3);
	});

	it("returns empty array for empty input", () => {
		const result = deduplicateAddresses([]);
		expect(result).toEqual([]);
	});

	it("returns single address unchanged", () => {
		const addr = Address.fromHex("0x742d35cc6634c0532925a3b844bc9e7595f251e3");
		const result = deduplicateAddresses([addr]);

		expect(result.length).toBe(1);
		expect(Address.equals(result[0], addr)).toBe(true);
	});

	it("handles all unique addresses", () => {
		const addr1 = Address.fromHex("0x0000000000000000000000000000000000000001");
		const addr2 = Address.fromHex("0x0000000000000000000000000000000000000002");
		const addr3 = Address.fromHex("0x0000000000000000000000000000000000000003");

		const result = deduplicateAddresses([addr1, addr2, addr3]);

		expect(result.length).toBe(3);
		expect(Address.equals(result[0], addr1)).toBe(true);
		expect(Address.equals(result[1], addr2)).toBe(true);
		expect(Address.equals(result[2], addr3)).toBe(true);
	});

	it("handles all duplicate addresses", () => {
		const addr = Address.fromHex("0x742d35cc6634c0532925a3b844bc9e7595f251e3");
		const addr2 = Address.fromHex("0x742d35cc6634c0532925a3b844bc9e7595f251e3");
		const addr3 = Address.fromHex("0x742d35cc6634c0532925a3b844bc9e7595f251e3");

		const result = deduplicateAddresses([addr, addr2, addr3]);

		expect(result.length).toBe(1);
		expect(Address.equals(result[0], addr)).toBe(true);
	});

	it("handles multiple duplicates of different addresses", () => {
		const addr1 = Address.fromHex("0x0000000000000000000000000000000000000001");
		const addr2 = Address.fromHex("0x0000000000000000000000000000000000000002");

		const result = deduplicateAddresses([addr1, addr2, addr1, addr2, addr1]);

		expect(result.length).toBe(2);
		expect(Address.equals(result[0], addr1)).toBe(true);
		expect(Address.equals(result[1], addr2)).toBe(true);
	});

	it("handles zero address duplicates", () => {
		const zero1 = Address.fromHex("0x0000000000000000000000000000000000000000");
		const zero2 = Address.fromHex("0x0000000000000000000000000000000000000000");
		const other = Address.fromHex("0x0000000000000000000000000000000000000001");

		const result = deduplicateAddresses([zero1, other, zero2]);

		expect(result.length).toBe(2);
		expect(Address.equals(result[0], zero1)).toBe(true);
		expect(Address.equals(result[1], other)).toBe(true);
	});

	it("handles max address duplicates", () => {
		const max1 = Address.fromHex("0xffffffffffffffffffffffffffffffffffffffff");
		const max2 = Address.fromHex("0xffffffffffffffffffffffffffffffffffffffff");
		const other = Address.fromHex("0x0000000000000000000000000000000000000001");

		const result = deduplicateAddresses([max1, other, max2]);

		expect(result.length).toBe(2);
		expect(Address.equals(result[0], max1)).toBe(true);
		expect(Address.equals(result[1], other)).toBe(true);
	});

	it("returns new array", () => {
		const addr1 = Address.fromHex("0x0000000000000000000000000000000000000001");
		const addr2 = Address.fromHex("0x0000000000000000000000000000000000000002");
		const input = [addr1, addr2];

		const result = deduplicateAddresses(input);

		expect(result).not.toBe(input);
	});

	it("works with Address namespace method", () => {
		const addr1 = Address.fromHex("0x742d35cc6634c0532925a3b844bc9e7595f251e3");
		const addr2 = Address.fromHex("0x0000000000000000000000000000000000000001");
		const addr3 = Address.fromHex("0x742d35cc6634c0532925a3b844bc9e7595f251e3");

		const result = Address.deduplicateAddresses([addr1, addr2, addr3]);

		expect(result.length).toBe(2);
	});

	it("handles addresses differing by single byte", () => {
		const addr1 = Address.fromHex("0x742d35cc6634c0532925a3b844bc9e7595f251e3");
		const addr2 = Address.fromHex("0x742d35cc6634c0532925a3b844bc9e7595f251e4");
		const addr3 = Address.fromHex("0x742d35cc6634c0532925a3b844bc9e7595f251e3");

		const result = deduplicateAddresses([addr1, addr2, addr3]);

		expect(result.length).toBe(2);
		expect(Address.equals(result[0], addr1)).toBe(true);
		expect(Address.equals(result[1], addr2)).toBe(true);
	});

	it("handles consecutive duplicates", () => {
		const addr1 = Address.fromHex("0x0000000000000000000000000000000000000001");
		const addr2 = Address.fromHex("0x0000000000000000000000000000000000000001");
		const addr3 = Address.fromHex("0x0000000000000000000000000000000000000002");

		const result = deduplicateAddresses([addr1, addr2, addr3]);

		expect(result.length).toBe(2);
	});
});

```
