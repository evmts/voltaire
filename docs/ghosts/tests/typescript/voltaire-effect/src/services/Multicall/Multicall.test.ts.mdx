---
title: '[TS/JS] voltaire-effect/src/services/Multicall/Multicall.test.ts'
source: 'voltaire-effect/src/services/Multicall/Multicall.test.ts'
---

> Auto-generated from test file: voltaire-effect/src/services/Multicall/Multicall.test.ts

```typescript
import { describe, expect, it, vi } from "@effect/vitest";
import { encodeParameters } from "@tevm/voltaire/Abi";
import * as Hex from "@tevm/voltaire/Hex";
import * as Effect from "effect/Effect";
import * as Exit from "effect/Exit";
import * as Layer from "effect/Layer";
import {
	TransportError,
	TransportService,
	type TransportShape,
} from "../Transport/TransportService.js";
import {
	aggregate3,
	MULTICALL3_ADDRESS,
	type MulticallCall,
	MulticallError,
	type MulticallResult,
} from "./MulticallService.js";

type HexType = `0x${string}`;

type Aggregate3ResultEntry = {
	success: boolean;
	returnData: HexType;
};

const AGGREGATE3_OUTPUT_PARAMS = [
	{
		type: "tuple[]" as const,
		name: "returnData",
		components: [
			{ type: "bool" as const, name: "success" },
			{ type: "bytes" as const, name: "returnData" },
		],
	},
] as const;

const encodeAggregate3Result = (results: Aggregate3ResultEntry[]): HexType => {
	const tuples = results.map((result) => ({
		success: result.success,
		returnData: Hex.toBytes(result.returnData),
	}));

	const encoded = encodeParameters(
		// biome-ignore lint/suspicious/noExplicitAny: ABI encoding requires dynamic type casting
		AGGREGATE3_OUTPUT_PARAMS as any,
		// biome-ignore lint/suspicious/noExplicitAny: ABI encoding requires dynamic type casting
		[tuples] as any,
	);
	return Hex.fromBytes(encoded) as HexType;
};

const makeTransportLayer = (request: TransportShape["request"]) =>
	Layer.succeed(TransportService, { request } as TransportShape);

describe("multicall aggregate3", () => {
	describe("MulticallError", () => {
		it("creates error with message", () => {
			const error = new MulticallError({ message: "test error" });
			expect(error.message).toBe("test error");
			expect(error._tag).toBe("MulticallError");
		});

		it("creates error with failed calls", () => {
			const error = new MulticallError({
				message: "Some calls failed",
				failedCalls: [0, 2, 4],
			});
			expect(error.failedCalls).toEqual([0, 2, 4]);
		});

		it("creates error with cause", () => {
			const cause = new Error("underlying");
			const error = new MulticallError({
				message: "Multicall failed",
				cause,
			});
			expect(error.cause).toBe(cause);
		});
	});

	describe("MulticallCall interface", () => {
		it("accepts minimal call", () => {
			const call: MulticallCall = {
				target: "0x1234567890123456789012345678901234567890",
				callData: "0x1234",
			};
			expect(call.target).toBe("0x1234567890123456789012345678901234567890");
			expect(call.callData).toBe("0x1234");
			expect(call.allowFailure).toBeUndefined();
		});

		it("accepts call with allowFailure", () => {
			const call: MulticallCall = {
				target: "0x1234567890123456789012345678901234567890",
				callData: "0x1234",
				allowFailure: true,
			};
			expect(call.allowFailure).toBe(true);
		});
	});

	describe("MulticallResult interface", () => {
		it("represents successful result", () => {
			const result: MulticallResult = {
				success: true,
				returnData:
					"0x00000000000000000000000000000000000000000000000000000000000000ff",
			};
			expect(result.success).toBe(true);
		});

		it("represents failed result", () => {
			const result: MulticallResult = {
				success: false,
				returnData: "0x",
			};
			expect(result.success).toBe(false);
		});
	});

	describe("aggregate3", () => {
		it.effect("returns empty array for empty calls", () =>
			Effect.gen(function* () {
				const request = vi.fn();
				const layer = makeTransportLayer(request as any);

				const result = yield* aggregate3([]).pipe(Effect.provide(layer));

				expect(result).toEqual([]);
				expect(request).not.toHaveBeenCalled();
			}),
		);

		it.effect("propagates transport errors as MulticallError", () =>
			Effect.gen(function* () {
				const request = vi.fn(() =>
					Effect.fail(
						new TransportError({ code: -32000, message: "RPC failed" }),
					),
				);
				const layer = makeTransportLayer(request as any);

				const program = aggregate3([
					{
						target: "0x1234567890123456789012345678901234567890",
						callData: "0x1234",
					},
				]).pipe(Effect.provide(layer));

				const exit = yield* Effect.exit(program);
				expect(Exit.isFailure(exit)).toBe(true);
				if (Exit.isFailure(exit) && exit.cause._tag === "Fail") {
					expect(exit.cause.error._tag).toBe("MulticallError");
					expect(exit.cause.error.message).toContain("Multicall3 call failed");
				}
			}),
		);

		it.effect("encodes calls correctly and sends to multicall3 address", () =>
			Effect.gen(function* () {
				let capturedMethod: string | undefined;
				let capturedParams: unknown[] | undefined;

				const request = vi.fn((method: string, params?: unknown[]) => {
					capturedMethod = method;
					capturedParams = params;
					return Effect.succeed(
						encodeAggregate3Result([{ success: true, returnData: "0x" }]),
					);
				});

				const layer = makeTransportLayer(request as any);

				const result = yield* aggregate3([
					{
						target: "0x1234567890123456789012345678901234567890",
						callData: "0xabcd",
					},
				]).pipe(Effect.provide(layer));

				expect(result.length).toBe(1);
				expect(capturedMethod).toBe("eth_call");
				expect(capturedParams).toBeDefined();
				const [callParams, blockTag] = (capturedParams ?? []) as [
					{ to?: string; data?: string },
					string,
				];
				expect(callParams.to?.toLowerCase()).toBe(
					MULTICALL3_ADDRESS.toLowerCase(),
				);
				expect(callParams.data?.startsWith("0x82ad56cb")).toBe(true);
				expect(blockTag).toBe("latest");
			}),
		);

		it.effect("handles all calls failing with allowFailure=true", () =>
			Effect.gen(function* () {
				const request = vi.fn(() =>
					Effect.succeed(
						encodeAggregate3Result([
							{ success: false, returnData: "0x" },
							{ success: false, returnData: "0x" },
						]),
					),
				);
				const layer = makeTransportLayer(request as any);

				const result = yield* aggregate3([
					{
						target: "0x1234567890123456789012345678901234567890",
						callData: "0x1234",
						allowFailure: true,
					},
					{
						target: "0x1234567890123456789012345678901234567890",
						callData: "0x5678",
						allowFailure: true,
					},
				]).pipe(Effect.provide(layer));

				expect(result.length).toBe(2);
				expect(result[0]?.success).toBe(false);
				expect(result[1]?.success).toBe(false);
			}),
		);

		it.effect("handles partial success (some calls fail, some succeed)", () =>
			Effect.gen(function* () {
				const request = vi.fn(() =>
					Effect.succeed(
						encodeAggregate3Result([
							{ success: true, returnData: "0x" },
							{ success: false, returnData: "0x" },
						]),
					),
				);
				const layer = makeTransportLayer(request as any);

				const result = yield* aggregate3([
					{
						target: "0x1234567890123456789012345678901234567890",
						callData: "0x1234",
						allowFailure: true,
					},
					{
						target: "0x1234567890123456789012345678901234567890",
						callData: "0x5678",
						allowFailure: true,
					},
				]).pipe(Effect.provide(layer));

				expect(result.length).toBe(2);
				expect(result[0]?.success).toBe(true);
				expect(result[1]?.success).toBe(false);
			}),
		);

		it.effect("handles multicall contract not deployed (revert)", () =>
			Effect.gen(function* () {
				const request = vi.fn(() =>
					Effect.fail(
						new TransportError({
							code: -32000,
							message: "execution reverted: contract not found",
						}),
					),
				);
				const layer = makeTransportLayer(request as any);

				const program = aggregate3([
					{
						target: "0x1234567890123456789012345678901234567890",
						callData: "0x1234",
					},
				]).pipe(Effect.provide(layer));

				const exit = yield* Effect.exit(program);
				expect(Exit.isFailure(exit)).toBe(true);
				if (Exit.isFailure(exit) && exit.cause._tag === "Fail") {
					expect(exit.cause.error._tag).toBe("MulticallError");
					expect(exit.cause.error.message).toContain("Multicall3 call failed");
				}
			}),
		);

		it.effect("handles gas limit exceeded in aggregate call", () =>
			Effect.gen(function* () {
				const request = vi.fn(() =>
					Effect.fail(
						new TransportError({
							code: -32000,
							message: "gas required exceeds allowance",
						}),
					),
				);
				const layer = makeTransportLayer(request as any);

				const program = aggregate3([
					{
						target: "0x1234567890123456789012345678901234567890",
						callData: "0x1234",
					},
				]).pipe(Effect.provide(layer));

				const exit = yield* Effect.exit(program);
				expect(Exit.isFailure(exit)).toBe(true);
				if (Exit.isFailure(exit) && exit.cause._tag === "Fail") {
					expect(exit.cause.error._tag).toBe("MulticallError");
					expect(exit.cause.error.message).toContain("gas required exceeds");
				}
			}),
		);

		it.effect("handles very large batch of calls", () =>
			Effect.gen(function* () {
				let capturedData: string | undefined;
				const request = vi.fn((_method: string, params?: unknown[]) => {
					const [callParams] = (params ?? []) as [
						{ to?: string; data?: string },
					];
					capturedData = callParams?.data;
					return Effect.fail(
						new TransportError({
							code: -32000,
							message: "Expected: testing large batch encoding",
						}),
					);
				});
				const layer = makeTransportLayer(request as any);

				const largeBatch: MulticallCall[] = Array.from(
					{ length: 100 },
					(_, i) => ({
						target: `0x${(i + 1).toString(16).padStart(40, "0")}` as HexType,
						callData: `0x${(i + 1).toString(16).padStart(8, "0")}` as HexType,
						allowFailure: true,
					}),
				);

				const program = aggregate3(largeBatch).pipe(Effect.provide(layer));
				yield* Effect.exit(program);

				expect(capturedData).toBeDefined();
				expect(capturedData?.startsWith("0x82ad56cb")).toBe(true);
				expect(capturedData?.length).toBeGreaterThan(1000);
			}),
		);

		it.effect("handles malformed return data", () =>
			Effect.gen(function* () {
				const request = vi.fn(() => Effect.succeed("0xdeadbeef" as HexType));
				const layer = makeTransportLayer(request as any);

				const program = aggregate3([
					{
						target: "0x1234567890123456789012345678901234567890",
						callData: "0x1234",
					},
				]).pipe(Effect.provide(layer));

				const exit = yield* Effect.exit(program);
				expect(Exit.isFailure(exit)).toBe(true);
				if (Exit.isFailure(exit) && exit.cause._tag === "Fail") {
					expect(exit.cause.error._tag).toBe("MulticallError");
					expect(exit.cause.error.message).toContain(
						"Failed to decode multicall result",
					);
				}
			}),
		);
	});

	describe("exports", () => {
		it("exports from index", async () => {
			const { aggregate3, MulticallError, MULTICALL3_ADDRESS } = await import(
				"./index.js"
			);
			expect(aggregate3).toBeDefined();
			expect(MulticallError).toBeDefined();
			expect(MULTICALL3_ADDRESS).toBeDefined();
		});
	});
});

```
