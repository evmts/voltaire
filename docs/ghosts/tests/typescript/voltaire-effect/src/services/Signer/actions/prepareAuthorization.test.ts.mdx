---
title: '[TS/JS] voltaire-effect/src/services/Signer/actions/prepareAuthorization.test.ts'
source: 'voltaire-effect/src/services/Signer/actions/prepareAuthorization.test.ts'
---

> Auto-generated from test file: voltaire-effect/src/services/Signer/actions/prepareAuthorization.test.ts

```typescript
import { describe, expect, it } from "@effect/vitest";
import type {
	BrandedAddress,
	BrandedHex,
	BrandedSignature,
} from "@tevm/voltaire";
import * as Effect from "effect/Effect";
import * as Layer from "effect/Layer";
import type { AccountShape } from "../../Account/AccountService.js";
import { AccountService } from "../../Account/index.js";
import { ProviderService, type ProviderShape } from "../../Provider/index.js";
import { TransportError } from "../../Transport/TransportService.js";
import { prepareAuthorization } from "./prepareAuthorization.js";

type AddressType = BrandedAddress.AddressType;
type HexType = BrandedHex.HexType;
type SignatureType = BrandedSignature.SignatureType;

const mockAddress = new Uint8Array(20).fill(0xab) as AddressType;
const mockSignature = Object.assign(new Uint8Array(65).fill(0x12), {
	algorithm: "secp256k1" as const,
	v: 27,
}) as SignatureType;
const mockPublicKey = `0x04${"00".repeat(64)}` as HexType;

const mockAccount: AccountShape = {
	address: mockAddress,
	type: "local",
	publicKey: mockPublicKey,
	signMessage: () => Effect.succeed(mockSignature),
	sign: () => Effect.succeed(mockSignature),
	signTransaction: () => Effect.succeed(mockSignature),
	signTypedData: () => Effect.succeed(mockSignature),
	signAuthorization: () =>
		Effect.succeed({
			chainId: 1n,
			address: "0x1234567890123456789012345678901234567890",
			nonce: 5n,
			yParity: 0,
			r: `0x${"ab".repeat(32)}` as `0x${string}`,
			s: `0x${"cd".repeat(32)}` as `0x${string}`,
		}),
	clearKey: () => Effect.void,
};

const mockProvider: ProviderShape = {
	request: <T>(method: string, _params?: unknown[]) => {
		switch (method) {
			case "eth_chainId":
				return Effect.succeed("0x1" as T);
			case "eth_getTransactionCount":
				return Effect.succeed("0x5" as T);
			default:
				return Effect.fail(
					new TransportError({ code: -32601, message: `Unknown method: ${method}` }),
				);
		}
	},
};

const TestAccountLayer = Layer.succeed(AccountService, mockAccount);
const TestProviderLayer = Layer.succeed(ProviderService, mockProvider);
const TestLayers = Layer.mergeAll(TestAccountLayer, TestProviderLayer);

describe("prepareAuthorization", () => {
	it("prepares authorization with fetched chain ID and nonce", async () => {
		const program = prepareAuthorization({
			contractAddress: "0x1234567890123456789012345678901234567890",
		});

		const result = await Effect.runPromise(Effect.provide(program, TestLayers));

		expect(result.chainId).toBe(1n);
		expect(result.nonce).toBe(5n);
		expect(result.address).toBe("0x1234567890123456789012345678901234567890");
	});

	it("uses provided chain ID", async () => {
		const program = prepareAuthorization({
			contractAddress: "0x1234567890123456789012345678901234567890",
			chainId: 137n,
		});

		const result = await Effect.runPromise(Effect.provide(program, TestLayers));

		expect(result.chainId).toBe(137n);
	});

	it("fetches nonce with pending block tag", async () => {
		let capturedBlockTag: string | undefined;

		const providerWithCapture: ProviderShape = {
			request: <T>(method: string, params?: unknown[]) => {
				switch (method) {
					case "eth_chainId":
						return Effect.succeed("0x1" as T);
					case "eth_getTransactionCount":
						capturedBlockTag = params?.[1] as string;
						return Effect.succeed("0xa" as T); // 10 in hex
					default:
						return Effect.fail(
							new TransportError({ code: -32601, message: `Unknown method: ${method}` }),
						);
				}
			},
		};

		const customLayers = Layer.mergeAll(
			TestAccountLayer,
			Layer.succeed(ProviderService, providerWithCapture),
		);

		const program = prepareAuthorization({
			contractAddress: "0x1234567890123456789012345678901234567890",
		});

		const result = await Effect.runPromise(
			Effect.provide(program, customLayers),
		);

		expect(capturedBlockTag).toBe("pending");
		expect(result.nonce).toBe(10n);
	});

	it("uses provided nonce without fetching", async () => {
		let getNonceCalled = false;
		const providerWithCapture: ProviderShape = {
			request: <T>(method: string, _params?: unknown[]) => {
				switch (method) {
					case "eth_chainId":
						return Effect.succeed("0x1" as T);
					case "eth_getTransactionCount":
						getNonceCalled = true;
						return Effect.succeed("0xa" as T);
					default:
						return Effect.fail(
							new TransportError({ code: -32601, message: `Unknown method: ${method}` }),
						);
				}
			},
		};

		const customLayers = Layer.mergeAll(
			TestAccountLayer,
			Layer.succeed(ProviderService, providerWithCapture),
		);

		const program = prepareAuthorization({
			contractAddress: "0x1234567890123456789012345678901234567890",
			nonce: 42n,
		});

		const result = await Effect.runPromise(
			Effect.provide(program, customLayers),
		);

		expect(result.nonce).toBe(42n);
		expect(getNonceCalled).toBe(false);
	});

	it("converts AddressType contract address to hex", async () => {
		const contractAddress = new Uint8Array(20).fill(0x12) as AddressType;

		const program = prepareAuthorization({ contractAddress });

		const result = await Effect.runPromise(Effect.provide(program, TestLayers));

		// result.address is already a hex string after prepareAuthorization
		expect((result.address as string).toLowerCase()).toBe(
			"0x1212121212121212121212121212121212121212",
		);
	});

	it("handles provider errors", async () => {
		const providerWithError: ProviderShape = {
			request: <T>(method: string, _params?: unknown[]) => {
				switch (method) {
					case "eth_chainId":
						return Effect.fail(
							new TransportError({ code: -32000, message: "Network error" }),
						);
					default:
						return Effect.fail(
							new TransportError({ code: -32601, message: `Unknown method: ${method}` }),
						);
				}
			},
		};

		const customLayers = Layer.mergeAll(
			TestAccountLayer,
			Layer.succeed(ProviderService, providerWithError),
		);

		const program = prepareAuthorization({
			contractAddress: "0x1234567890123456789012345678901234567890",
		});

		const result = await Effect.runPromiseExit(
			Effect.provide(program, customLayers),
		);

		expect(result._tag).toBe("Failure");
	});
});

```
