---
title: '[TS/JS] voltaire-effect/src/services/Provider/actions/simulateContract.test.ts'
source: 'voltaire-effect/src/services/Provider/actions/simulateContract.test.ts'
---

> Auto-generated from test file: voltaire-effect/src/services/Provider/actions/simulateContract.test.ts

```typescript
import { describe, expect, it } from "@effect/vitest";
import { Address, Hex } from "@tevm/voltaire";
import * as Effect from "effect/Effect";
import * as Layer from "effect/Layer";
import * as S from "effect/Schema";
import { fromArray } from "../../../primitives/Abi/AbiSchema.js";
import { TransportError } from "../../Transport/TransportService.js";
import { ProviderService, type ProviderShape } from "../ProviderService.js";
import { simulateContract } from "./simulateContract.js";

const erc20Abi = S.decodeUnknownSync(fromArray)([
	{
		type: "function",
		name: "transfer",
		inputs: [
			{ name: "to", type: "address" },
			{ name: "amount", type: "uint256" },
		],
		outputs: [{ type: "bool" }],
		stateMutability: "nonpayable",
	},
	{
		type: "function",
		name: "balanceOf",
		inputs: [{ name: "account", type: "address" }],
		outputs: [{ type: "uint256" }],
		stateMutability: "view",
	},
]);

const createMockProvider = (
	callResult: `0x${string}`,
): Layer.Layer<ProviderService> => {
	const mockProvider: ProviderShape = {
		request: <T>(method: string, _params?: unknown[]) => {
			switch (method) {
				case "eth_call":
					return Effect.succeed(callResult as T);
				case "eth_chainId":
					return Effect.succeed("0x1" as T);
				default:
					return Effect.succeed(null as T);
			}
		},
	};
	return Layer.succeed(ProviderService, mockProvider);
};

const createErrorMockProvider = (
	error: TransportError,
): Layer.Layer<ProviderService> => {
	const mockProvider: ProviderShape = {
		request: <T>(method: string, _params?: unknown[]) => {
			switch (method) {
				case "eth_call":
					return Effect.fail(error);
				case "eth_chainId":
					return Effect.succeed("0x1" as T);
				default:
					return Effect.succeed(null as T);
			}
		},
	};
	return Layer.succeed(ProviderService, mockProvider);
};

describe("simulateContract", () => {
	it("returns correct result for transfer simulation", async () => {
		const trueResult =
			"0x0000000000000000000000000000000000000000000000000000000000000001" as const;
		const provider = createMockProvider(trueResult);

		const program = simulateContract({
			address: "0x1234567890123456789012345678901234567890",
			abi: erc20Abi,
			functionName: "transfer",
			args: ["0xabcdef0123456789abcdef0123456789abcdef01", 1000n],
		}).pipe(Effect.provide(provider));

		const result = await Effect.runPromise(program);

		expect(result.result).toBe(true);
	});

	it("populates request object correctly", async () => {
		const trueResult =
			"0x0000000000000000000000000000000000000000000000000000000000000001" as const;
		const provider = createMockProvider(trueResult);

		const contractAddress = "0x1234567890123456789012345678901234567890";
		const recipient = "0xabcdef0123456789abcdef0123456789abcdef01";
		const amount = 1000n;

		const program = simulateContract({
			address: contractAddress,
			abi: erc20Abi,
			functionName: "transfer",
			args: [recipient, amount],
			value: 0n,
			gas: 100000n,
		}).pipe(Effect.provide(provider));

		const result = await Effect.runPromise(program);

		expect(Address.toHex(result.request.address).toLowerCase()).toBe(
			contractAddress.toLowerCase(),
		);
		expect(result.request.functionName).toBe("transfer");
		expect(result.request.args).toEqual([recipient, amount]);
		expect(Address.toHex(result.request.to).toLowerCase()).toBe(
			contractAddress.toLowerCase(),
		);
		expect(result.request.data).toBeDefined();
		expect(Hex.isHex(result.request.data)).toBe(true);
		expect(result.request.value).toBe(0n);
		expect(result.request.gas).toBe(100000n);
	});

	it("handles simulation with account override", async () => {
		const trueResult =
			"0x0000000000000000000000000000000000000000000000000000000000000001" as const;

		let capturedRequest: any;
		const mockProvider: ProviderShape = {
			request: <T>(method: string, params?: unknown[]) => {
				switch (method) {
					case "eth_call":
						capturedRequest = params?.[0];
						return Effect.succeed(trueResult as T);
					case "eth_chainId":
						return Effect.succeed("0x1" as T);
					default:
						return Effect.succeed(null as T);
				}
			},
		};
		const provider = Layer.succeed(ProviderService, mockProvider);

		const senderAddress = "0x9999999999999999999999999999999999999999";

		const program = simulateContract({
			address: "0x1234567890123456789012345678901234567890",
			abi: erc20Abi,
			functionName: "transfer",
			args: ["0xabcdef0123456789abcdef0123456789abcdef01", 1000n],
			account: senderAddress,
		}).pipe(Effect.provide(provider));

		await Effect.runPromise(program);

		expect(capturedRequest.from).toBe(senderAddress);
	});

	it("fails when function not found in ABI", async () => {
		const trueResult =
			"0x0000000000000000000000000000000000000000000000000000000000000001" as const;
		const provider = createMockProvider(trueResult);

		const program = simulateContract({
			address: "0x1234567890123456789012345678901234567890",
			abi: erc20Abi,
			functionName: "nonexistent" as any,
			args: [],
		}).pipe(Effect.provide(provider));

		await expect(Effect.runPromise(program)).rejects.toThrow();
	});

	it("returns false result for failed transfer", async () => {
		const falseResult =
			"0x0000000000000000000000000000000000000000000000000000000000000000" as const;
		const provider = createMockProvider(falseResult);

		const program = simulateContract({
			address: "0x1234567890123456789012345678901234567890",
			abi: erc20Abi,
			functionName: "transfer",
			args: ["0xabcdef0123456789abcdef0123456789abcdef01", 1000n],
		}).pipe(Effect.provide(provider));

		const result = await Effect.runPromise(program);

		expect(result.result).toBe(false);
	});

	it("handles view function simulation", async () => {
		const balanceResult =
			"0x0000000000000000000000000000000000000000000000000de0b6b3a7640000" as const;
		const provider = createMockProvider(balanceResult);

		const program = simulateContract({
			address: "0x1234567890123456789012345678901234567890",
			abi: erc20Abi,
			functionName: "balanceOf",
			args: ["0xabcdef0123456789abcdef0123456789abcdef01"],
		}).pipe(Effect.provide(provider));

		const result = await Effect.runPromise(program);

		expect(result.result).toBe(1000000000000000000n);
	});

	describe("error handling", () => {
		it("fails on execution revert with data", async () => {
			const revertData =
				"0x08c379a0" +
				"0000000000000000000000000000000000000000000000000000000000000020" +
				"0000000000000000000000000000000000000000000000000000000000000015" +
				"5472616e7366657220616d6f756e74206578636565647300000000000000";

			const provider = createErrorMockProvider(
				new TransportError({
					code: 3,
					message: "execution reverted",
					data: revertData,
				}),
			);

			const program = simulateContract({
				address: "0x1234567890123456789012345678901234567890",
				abi: erc20Abi,
				functionName: "transfer",
				args: ["0xabcdef0123456789abcdef0123456789abcdef01", 1000n],
			}).pipe(Effect.provide(provider));

			const exit = await Effect.runPromiseExit(program);
			expect(exit._tag).toBe("Failure");
			if (exit._tag === "Failure" && exit.cause._tag === "Fail") {
				expect(exit.cause.error._tag).toBe("TransportError");
			}
		});

		it("propagates transport errors", async () => {
			const provider = createErrorMockProvider(
				new TransportError({
					code: -32603,
					message: "network error: connection refused",
				}),
			);

			const program = simulateContract({
				address: "0x1234567890123456789012345678901234567890",
				abi: erc20Abi,
				functionName: "transfer",
				args: ["0xabcdef0123456789abcdef0123456789abcdef01", 1000n],
			}).pipe(Effect.provide(provider));

			const exit = await Effect.runPromiseExit(program);
			expect(exit._tag).toBe("Failure");
			if (exit._tag === "Failure" && exit.cause._tag === "Fail") {
				expect(exit.cause.error._tag).toBe("TransportError");
			}
		});

		it("propagates timeout errors", async () => {
			const provider = createErrorMockProvider(
				new TransportError({
					code: -32000,
					message: "request timeout",
				}),
			);

			const program = simulateContract({
				address: "0x1234567890123456789012345678901234567890",
				abi: erc20Abi,
				functionName: "transfer",
				args: ["0xabcdef0123456789abcdef0123456789abcdef01", 1000n],
			}).pipe(Effect.provide(provider));

			const exit = await Effect.runPromiseExit(program);
			expect(exit._tag).toBe("Failure");
			if (exit._tag === "Failure" && exit.cause._tag === "Fail") {
				expect(exit.cause.error._tag).toBe("TransportError");
			}
		});
	});
});

```
