---
title: '[TS/JS] voltaire-effect/src/primitives/Int128/Int128.test.ts'
source: 'voltaire-effect/src/primitives/Int128/Int128.test.ts'
---

> Auto-generated from test file: voltaire-effect/src/primitives/Int128/Int128.test.ts

```typescript
import { describe, expect, it } from "@effect/vitest";
import { BrandedInt128 } from "@tevm/voltaire";
import * as S from "effect/Schema";
import * as Int128 from "./index.js";

const INT128_MIN = -(2n ** 127n);
const INT128_MAX = 2n ** 127n - 1n;

describe("Int128", () => {
	describe("Schema: Int128.Number", () => {
		it("decodes valid positive number", () => {
			const value = S.decodeSync(Int128.Number)(1000000000);
			expect(S.encodeSync(Int128.Number)(value)).toBe(1000000000);
		});

		it("decodes valid negative number", () => {
			const value = S.decodeSync(Int128.Number)(-1000000000);
			expect(S.encodeSync(Int128.Number)(value)).toBe(-1000000000);
		});

		it("decodes zero", () => {
			const value = S.decodeSync(Int128.Number)(0);
			expect(S.encodeSync(Int128.Number)(value)).toBe(0);
		});

		it("fails on non-integer", () => {
			expect(() => S.decodeSync(Int128.Number)(1.5)).toThrow();
		});
	});

	describe("Schema: Int128.String", () => {
		it("decodes valid positive string", () => {
			const value = S.decodeSync(Int128.String)(
				"170141183460469231731687303715884105727",
			);
			expect(S.encodeSync(Int128.String)(value)).toBe(
				"170141183460469231731687303715884105727",
			);
		});

		it("decodes valid negative string", () => {
			const value = S.decodeSync(Int128.String)(
				"-170141183460469231731687303715884105728",
			);
			expect(S.encodeSync(Int128.String)(value)).toBe(
				"-170141183460469231731687303715884105728",
			);
		});

		it("decodes zero string", () => {
			const value = S.decodeSync(Int128.String)("0");
			expect(S.encodeSync(Int128.String)(value)).toBe("0");
		});
	});

	describe("Schema: Int128.BigInt", () => {
		it("decodes valid positive bigint", () => {
			const value = S.decodeSync(Int128.BigInt)(
				1000000000000000000000000000000n,
			);
			expect(S.encodeSync(Int128.BigInt)(value)).toBe(
				1000000000000000000000000000000n,
			);
		});

		it("decodes valid negative bigint", () => {
			const value = S.decodeSync(Int128.BigInt)(
				-1000000000000000000000000000000n,
			);
			expect(S.encodeSync(Int128.BigInt)(value)).toBe(
				-1000000000000000000000000000000n,
			);
		});

		it("decodes zero bigint", () => {
			const value = S.decodeSync(Int128.BigInt)(0n);
			expect(S.encodeSync(Int128.BigInt)(value)).toBe(0n);
		});

		it("decodes INT128_MIN bigint", () => {
			const value = S.decodeSync(Int128.BigInt)(INT128_MIN);
			expect(S.encodeSync(Int128.BigInt)(value)).toBe(INT128_MIN);
		});

		it("decodes INT128_MAX bigint", () => {
			const value = S.decodeSync(Int128.BigInt)(INT128_MAX);
			expect(S.encodeSync(Int128.BigInt)(value)).toBe(INT128_MAX);
		});

		it("fails on overflow bigint", () => {
			expect(() => S.decodeSync(Int128.BigInt)(INT128_MAX + 1n)).toThrow();
		});

		it("fails on underflow bigint", () => {
			expect(() => S.decodeSync(Int128.BigInt)(INT128_MIN - 1n)).toThrow();
		});
	});

	describe("Arithmetic: add (via BrandedInt128.plus)", () => {
		it("adds two positive values", () => {
			const a = S.decodeSync(Int128.BigInt)(1000000000000000000000000000000n);
			const b = S.decodeSync(Int128.BigInt)(500000000000000000000000000000n);
			const result = BrandedInt128.plus(a, b);
			expect(S.encodeSync(Int128.BigInt)(result)).toBe(
				1500000000000000000000000000000n,
			);
		});

		it("adds positive and negative", () => {
			const a = S.decodeSync(Int128.BigInt)(1000000000000000000000000000000n);
			const b = S.decodeSync(Int128.BigInt)(-500000000000000000000000000000n);
			const result = BrandedInt128.plus(a, b);
			expect(S.encodeSync(Int128.BigInt)(result)).toBe(
				500000000000000000000000000000n,
			);
		});

		it("adds two negative values", () => {
			const a = S.decodeSync(Int128.BigInt)(-1000000000000000000000000000000n);
			const b = S.decodeSync(Int128.BigInt)(-500000000000000000000000000000n);
			const result = BrandedInt128.plus(a, b);
			expect(S.encodeSync(Int128.BigInt)(result)).toBe(
				-1500000000000000000000000000000n,
			);
		});

		it("wraps on overflow", () => {
			const max = S.decodeSync(Int128.BigInt)(INT128_MAX);
			const one = S.decodeSync(Int128.BigInt)(1n);
			const result = BrandedInt128.plus(max, one);
			expect(S.encodeSync(Int128.BigInt)(result)).toBe(INT128_MIN);
		});

		it("wraps on underflow", () => {
			const min = S.decodeSync(Int128.BigInt)(INT128_MIN);
			const negOne = S.decodeSync(Int128.BigInt)(-1n);
			const result = BrandedInt128.plus(min, negOne);
			expect(S.encodeSync(Int128.BigInt)(result)).toBe(INT128_MAX);
		});
	});

	describe("Arithmetic: sub", () => {
		it("subtracts two values", () => {
			const a = S.decodeSync(Int128.BigInt)(1000000000000000000000000000000n);
			const b = S.decodeSync(Int128.BigInt)(500000000000000000000000000000n);
			const result = Int128.sub(a, b);
			expect(S.encodeSync(Int128.BigInt)(result)).toBe(
				500000000000000000000000000000n,
			);
		});

		it("subtracts negative (adds)", () => {
			const a = S.decodeSync(Int128.BigInt)(1000000000000000000000000000000n);
			const b = S.decodeSync(Int128.BigInt)(-500000000000000000000000000000n);
			const result = Int128.sub(a, b);
			expect(S.encodeSync(Int128.BigInt)(result)).toBe(
				1500000000000000000000000000000n,
			);
		});

		it("wraps on underflow", () => {
			const min = S.decodeSync(Int128.BigInt)(INT128_MIN);
			const one = S.decodeSync(Int128.BigInt)(1n);
			const result = Int128.sub(min, one);
			expect(S.encodeSync(Int128.BigInt)(result)).toBe(INT128_MAX);
		});
	});

	describe("Arithmetic: mul", () => {
		it("multiplies two positive values", () => {
			const a = S.decodeSync(Int128.BigInt)(1000000000000000n);
			const b = S.decodeSync(Int128.BigInt)(1000000000000000n);
			const result = Int128.mul(a, b);
			expect(S.encodeSync(Int128.BigInt)(result)).toBe(
				1000000000000000000000000000000n,
			);
		});

		it("multiplies positive and negative", () => {
			const a = S.decodeSync(Int128.BigInt)(1000000000000000n);
			const b = S.decodeSync(Int128.BigInt)(-1000000000000000n);
			const result = Int128.mul(a, b);
			expect(S.encodeSync(Int128.BigInt)(result)).toBe(
				-1000000000000000000000000000000n,
			);
		});

		it("multiplies by zero", () => {
			const a = S.decodeSync(Int128.BigInt)(1000000000000000000000000000000n);
			const zero = S.decodeSync(Int128.BigInt)(0n);
			const result = Int128.mul(a, zero);
			expect(S.encodeSync(Int128.BigInt)(result)).toBe(0n);
		});

		it("multiplies by one", () => {
			const a = S.decodeSync(Int128.BigInt)(1000000000000000000000000000000n);
			const one = S.decodeSync(Int128.BigInt)(1n);
			const result = Int128.mul(a, one);
			expect(S.encodeSync(Int128.BigInt)(result)).toBe(
				1000000000000000000000000000000n,
			);
		});
	});

	describe("Arithmetic: div", () => {
		it("divides two values", () => {
			const a = S.decodeSync(Int128.BigInt)(1000000000000000000000000000000n);
			const b = S.decodeSync(Int128.BigInt)(1000000000000000n);
			const result = Int128.div(a, b);
			expect(S.encodeSync(Int128.BigInt)(result)).toBe(1000000000000000n);
		});

		it("truncates toward zero (positive)", () => {
			const a = S.decodeSync(Int128.BigInt)(7n);
			const b = S.decodeSync(Int128.BigInt)(3n);
			const result = Int128.div(a, b);
			expect(S.encodeSync(Int128.BigInt)(result)).toBe(2n);
		});

		it("truncates toward zero (negative)", () => {
			const a = S.decodeSync(Int128.BigInt)(-7n);
			const b = S.decodeSync(Int128.BigInt)(3n);
			const result = Int128.div(a, b);
			expect(S.encodeSync(Int128.BigInt)(result)).toBe(-2n);
		});

		it("divides zero by anything", () => {
			const zero = S.decodeSync(Int128.BigInt)(0n);
			const b = S.decodeSync(Int128.BigInt)(5n);
			const result = Int128.div(zero, b);
			expect(S.encodeSync(Int128.BigInt)(result)).toBe(0n);
		});
	});

	describe("Sign handling: negate", () => {
		it("negates positive value", () => {
			const a = S.decodeSync(Int128.BigInt)(1000000000000000000000000000000n);
			const result = Int128.negate(a);
			expect(S.encodeSync(Int128.BigInt)(result)).toBe(
				-1000000000000000000000000000000n,
			);
		});

		it("negates negative value", () => {
			const a = S.decodeSync(Int128.BigInt)(-1000000000000000000000000000000n);
			const result = Int128.negate(a);
			expect(S.encodeSync(Int128.BigInt)(result)).toBe(
				1000000000000000000000000000000n,
			);
		});

		it("negates zero", () => {
			const zero = S.decodeSync(Int128.BigInt)(0n);
			const result = Int128.negate(zero);
			expect(S.encodeSync(Int128.BigInt)(result)).toBe(0n);
		});

		it("negates INT128_MIN wraps", () => {
			const min = S.decodeSync(Int128.BigInt)(INT128_MIN);
			const result = Int128.negate(min);
			expect(S.encodeSync(Int128.BigInt)(result)).toBe(INT128_MIN);
		});
	});

	describe("Sign handling: abs", () => {
		it("abs of positive value", () => {
			const a = S.decodeSync(Int128.BigInt)(1000000000000000000000000000000n);
			const result = Int128.abs(a);
			expect(S.encodeSync(Int128.BigInt)(result)).toBe(
				1000000000000000000000000000000n,
			);
		});

		it("abs of negative value", () => {
			const a = S.decodeSync(Int128.BigInt)(-1000000000000000000000000000000n);
			const result = Int128.abs(a);
			expect(S.encodeSync(Int128.BigInt)(result)).toBe(
				1000000000000000000000000000000n,
			);
		});

		it("abs of zero", () => {
			const zero = S.decodeSync(Int128.BigInt)(0n);
			const result = Int128.abs(zero);
			expect(S.encodeSync(Int128.BigInt)(result)).toBe(0n);
		});

		it("abs of INT128_MIN throws overflow", () => {
			const min = S.decodeSync(Int128.BigInt)(INT128_MIN);
			expect(() => Int128.abs(min)).toThrow();
		});
	});

	describe("Sign handling: isNegative", () => {
		it("returns false for positive", () => {
			const a = S.decodeSync(Int128.BigInt)(1000000000000000000000000000000n);
			expect(Int128.isNegative(a)).toBe(false);
		});

		it("returns true for negative", () => {
			const a = S.decodeSync(Int128.BigInt)(-1000000000000000000000000000000n);
			expect(Int128.isNegative(a)).toBe(true);
		});

		it("returns false for zero", () => {
			const zero = S.decodeSync(Int128.BigInt)(0n);
			expect(Int128.isNegative(zero)).toBe(false);
		});

		it("returns true for INT128_MIN", () => {
			const min = S.decodeSync(Int128.BigInt)(INT128_MIN);
			expect(Int128.isNegative(min)).toBe(true);
		});
	});

	describe("Comparison: compare", () => {
		it("returns 0 for equal values", () => {
			const a = S.decodeSync(Int128.BigInt)(1000000000000000000000000000000n);
			const b = S.decodeSync(Int128.BigInt)(1000000000000000000000000000000n);
			expect(Int128.compare(a, b)).toBe(0);
		});

		it("returns -1 when a < b", () => {
			const a = S.decodeSync(Int128.BigInt)(100n);
			const b = S.decodeSync(Int128.BigInt)(200n);
			expect(Int128.compare(a, b)).toBe(-1);
		});

		it("returns 1 when a > b", () => {
			const a = S.decodeSync(Int128.BigInt)(200n);
			const b = S.decodeSync(Int128.BigInt)(100n);
			expect(Int128.compare(a, b)).toBe(1);
		});

		it("handles negative comparison", () => {
			const a = S.decodeSync(Int128.BigInt)(-200n);
			const b = S.decodeSync(Int128.BigInt)(-100n);
			expect(Int128.compare(a, b)).toBe(-1);
		});

		it("handles mixed sign comparison", () => {
			const a = S.decodeSync(Int128.BigInt)(-1n);
			const b = S.decodeSync(Int128.BigInt)(1n);
			expect(Int128.compare(a, b)).toBe(-1);
		});
	});

	describe("Utility: isZero", () => {
		it("returns true for zero", () => {
			const zero = S.decodeSync(Int128.BigInt)(0n);
			expect(Int128.isZero(zero)).toBe(true);
		});

		it("returns false for positive", () => {
			const a = S.decodeSync(Int128.BigInt)(1n);
			expect(Int128.isZero(a)).toBe(false);
		});

		it("returns false for negative", () => {
			const a = S.decodeSync(Int128.BigInt)(-1n);
			expect(Int128.isZero(a)).toBe(false);
		});
	});

	describe("Constants", () => {
		it("MIN equals -(2^127)", () => {
			expect(Int128.MIN).toBe(INT128_MIN);
		});

		it("MAX equals 2^127 - 1", () => {
			expect(Int128.MAX).toBe(INT128_MAX);
		});
	});
});

```
