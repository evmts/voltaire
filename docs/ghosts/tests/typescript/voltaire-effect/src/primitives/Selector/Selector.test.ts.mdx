---
title: '[TS/JS] voltaire-effect/src/primitives/Selector/Selector.test.ts'
source: 'voltaire-effect/src/primitives/Selector/Selector.test.ts'
---

> Auto-generated from test file: voltaire-effect/src/primitives/Selector/Selector.test.ts

```typescript
import { describe, expect, it } from "@effect/vitest";
import * as S from "effect/Schema";
import * as Selector from "./index.js";

describe("Selector.Hex", () => {
	describe("decode", () => {
		it("parses valid hex string", () => {
			const result = S.decodeSync(Selector.Hex)("0xa9059cbb");
			expect(result.length).toBe(4);
		});

		it("parses uppercase hex", () => {
			const result = S.decodeSync(Selector.Hex)("0xA9059CBB");
			expect(result.length).toBe(4);
		});

		it("parses mixed case hex", () => {
			const result = S.decodeSync(Selector.Hex)("0xA9059cBb");
			expect(result.length).toBe(4);
		});

		it("fails on wrong size (too short)", () => {
			expect(() => S.decodeSync(Selector.Hex)("0x1234")).toThrow();
		});

		it("fails on wrong size (too long)", () => {
			expect(() => S.decodeSync(Selector.Hex)("0xa9059cbb00")).toThrow();
		});

		it("fails on invalid hex characters", () => {
			expect(() => S.decodeSync(Selector.Hex)("0xgggggggg")).toThrow();
		});

		it("fails on empty string", () => {
			expect(() => S.decodeSync(Selector.Hex)("")).toThrow();
		});

		it("fails on just prefix", () => {
			expect(() => S.decodeSync(Selector.Hex)("0x")).toThrow();
		});

		it("fails on odd length hex", () => {
			expect(() => S.decodeSync(Selector.Hex)("0xa9059cb")).toThrow();
		});
	});

	describe("encode", () => {
		it("encodes to hex with prefix", () => {
			const selector = S.decodeSync(Selector.Hex)("0xa9059cbb");
			const hex = S.encodeSync(Selector.Hex)(selector);
			expect(hex).toBe("0xa9059cbb");
		});

		it("encodes to lowercase", () => {
			const selector = S.decodeSync(Selector.Hex)("0xA9059CBB");
			const hex = S.encodeSync(Selector.Hex)(selector);
			expect(hex).toBe("0xa9059cbb");
		});

		it("round-trips correctly", () => {
			const original = S.decodeSync(Selector.Hex)("0xa9059cbb");
			const encoded = S.encodeSync(Selector.Hex)(original);
			const decoded = S.decodeSync(Selector.Hex)(encoded);
			expect(Selector.equals(original, decoded)).toBe(true);
		});
	});
});

describe("Selector.Bytes", () => {
	describe("decode", () => {
		it("parses 4-byte Uint8Array", () => {
			const input = new Uint8Array([0xa9, 0x05, 0x9c, 0xbb]);
			const result = S.decodeSync(Selector.Bytes)(input);
			expect(result.length).toBe(4);
			expect([...result]).toEqual([...input]);
		});

		it("fails on wrong length (2 bytes)", () => {
			const input = new Uint8Array([0xa9, 0x05]);
			expect(() => S.decodeSync(Selector.Bytes)(input)).toThrow();
		});

		it("fails on wrong length (5 bytes)", () => {
			const input = new Uint8Array([0xa9, 0x05, 0x9c, 0xbb, 0x00]);
			expect(() => S.decodeSync(Selector.Bytes)(input)).toThrow();
		});

		it("fails on empty array", () => {
			expect(() => S.decodeSync(Selector.Bytes)(new Uint8Array())).toThrow();
		});

		it("fails on 1 byte", () => {
			expect(() =>
				S.decodeSync(Selector.Bytes)(new Uint8Array([0xa9])),
			).toThrow();
		});

		it("fails on 3 bytes", () => {
			expect(() =>
				S.decodeSync(Selector.Bytes)(new Uint8Array([0xa9, 0x05, 0x9c])),
			).toThrow();
		});
	});

	describe("encode", () => {
		it("encodes to Uint8Array", () => {
			const selector = S.decodeSync(Selector.Hex)("0xa9059cbb");
			const bytes = S.encodeSync(Selector.Bytes)(selector);
			expect(bytes).toBeInstanceOf(Uint8Array);
			expect(bytes.length).toBe(4);
		});

		it("preserves byte values", () => {
			const selector = S.decodeSync(Selector.Hex)("0xa9059cbb");
			const bytes = S.encodeSync(Selector.Bytes)(selector);
			expect(bytes[0]).toBe(0xa9);
			expect(bytes[1]).toBe(0x05);
			expect(bytes[2]).toBe(0x9c);
			expect(bytes[3]).toBe(0xbb);
		});
	});
});

describe("Selector.Signature", () => {
	describe("decode", () => {
		it("computes selector from function signature", () => {
			const result = S.decodeSync(Selector.Signature)(
				"transfer(address,uint256)",
			);
			expect(result.length).toBe(4);
			const hex = S.encodeSync(Selector.Hex)(result);
			expect(hex).toBe("0xa9059cbb");
		});

		it("computes selector for balanceOf", () => {
			const result = S.decodeSync(Selector.Signature)("balanceOf(address)");
			const hex = S.encodeSync(Selector.Hex)(result);
			expect(hex).toBe("0x70a08231");
		});

		it("computes selector for approve", () => {
			const result = S.decodeSync(Selector.Signature)(
				"approve(address,uint256)",
			);
			const hex = S.encodeSync(Selector.Hex)(result);
			expect(hex).toBe("0x095ea7b3");
		});

		it("computes selector for transferFrom", () => {
			const result = S.decodeSync(Selector.Signature)(
				"transferFrom(address,address,uint256)",
			);
			const hex = S.encodeSync(Selector.Hex)(result);
			expect(hex).toBe("0x23b872dd");
		});

		it("handles function with no params", () => {
			const result = S.decodeSync(Selector.Signature)("totalSupply()");
			const hex = S.encodeSync(Selector.Hex)(result);
			expect(hex).toBe("0x18160ddd");
		});

		it("handles function with array params", () => {
			const result = S.decodeSync(Selector.Signature)(
				"batchTransfer(address[],uint256[])",
			);
			expect(result.length).toBe(4);
		});

		it("handles function with tuple params", () => {
			const result = S.decodeSync(Selector.Signature)(
				"execute((address,uint256,bytes))",
			);
			expect(result.length).toBe(4);
		});
	});

	describe("encode", () => {
		it("encodes to hex string", () => {
			const selector = S.decodeSync(Selector.Signature)(
				"transfer(address,uint256)",
			);
			const hex = S.encodeSync(Selector.Signature)(selector);
			expect(hex).toBe("0xa9059cbb");
		});
	});
});

describe("pure functions", () => {
	it("equals returns true for equal selectors", () => {
		const a = S.decodeSync(Selector.Hex)("0xa9059cbb");
		const b = S.decodeSync(Selector.Hex)("0xa9059cbb");
		expect(Selector.equals(a, b)).toBe(true);
	});

	it("equals returns false for different selectors", () => {
		const a = S.decodeSync(Selector.Hex)("0xa9059cbb");
		const b = S.decodeSync(Selector.Hex)("0x70a08231");
		expect(Selector.equals(a, b)).toBe(false);
	});

	it("equals works with Signature-decoded selectors", () => {
		const a = S.decodeSync(Selector.Hex)("0xa9059cbb");
		const b = S.decodeSync(Selector.Signature)("transfer(address,uint256)");
		expect(Selector.equals(a, b)).toBe(true);
	});

	it("equals works with Bytes-decoded selectors", () => {
		const a = S.decodeSync(Selector.Hex)("0xa9059cbb");
		const b = S.decodeSync(Selector.Bytes)(
			new Uint8Array([0xa9, 0x05, 0x9c, 0xbb]),
		);
		expect(Selector.equals(a, b)).toBe(true);
	});

	it("equals is symmetric", () => {
		const a = S.decodeSync(Selector.Hex)("0xa9059cbb");
		const b = S.decodeSync(Selector.Hex)("0x70a08231");
		expect(Selector.equals(a, b)).toBe(Selector.equals(b, a));
	});

	it("equals is reflexive", () => {
		const a = S.decodeSync(Selector.Hex)("0xa9059cbb");
		expect(Selector.equals(a, a)).toBe(true);
	});
});

describe("edge cases", () => {
	it("handles all-zeros selector", () => {
		const selector = S.decodeSync(Selector.Hex)("0x00000000");
		expect(selector.length).toBe(4);
		expect([...selector]).toEqual([0, 0, 0, 0]);
	});

	it("handles max value selector", () => {
		const selector = S.decodeSync(Selector.Hex)("0xffffffff");
		expect(selector.length).toBe(4);
		expect([...selector]).toEqual([0xff, 0xff, 0xff, 0xff]);
	});

	it("handles all-zeros via Bytes", () => {
		const selector = S.decodeSync(Selector.Bytes)(new Uint8Array(4));
		expect(selector.length).toBe(4);
	});

	it("preserves exact bytes through Hex round-trip", () => {
		const bytes = new Uint8Array([0x12, 0x34, 0x56, 0x78]);
		const selector = S.decodeSync(Selector.Bytes)(bytes);
		const hex = S.encodeSync(Selector.Hex)(selector);
		expect(hex).toBe("0x12345678");
	});

	it("different signatures can produce same selector (collision)", () => {
		const sel1 = S.decodeSync(Selector.Signature)("transfer(address,uint256)");
		const hex1 = S.encodeSync(Selector.Hex)(sel1);
		expect(hex1).toBe("0xa9059cbb");
	});
});

```
