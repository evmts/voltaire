---
title: '[TS/JS] voltaire-effect/src/primitives/PrivateKey/PrivateKey.test.ts'
source: 'voltaire-effect/src/primitives/PrivateKey/PrivateKey.test.ts'
---

> Auto-generated from test file: voltaire-effect/src/primitives/PrivateKey/PrivateKey.test.ts

```typescript
import { describe, expect, it } from "@effect/vitest";
import { Hash } from "@tevm/voltaire";
import { PrivateKey as CorePrivateKey } from "@tevm/voltaire/PrivateKey";
import * as Secp256k1 from "@tevm/voltaire/Secp256k1";
import * as Effect from "effect/Effect";
import * as S from "effect/Schema";
import * as PrivateKey from "./index.js";

const validHex = `0x${"ab".repeat(32)}`;
const validHexNoPrefix = "ab".repeat(32);

describe("PrivateKey.Hex", () => {
	describe("decode", () => {
		it("parses 64-char hex with prefix", () => {
			const pk = S.decodeSync(PrivateKey.Hex)(validHex);
			expect(pk).toBeInstanceOf(Uint8Array);
			expect(pk.length).toBe(32);
		});

		it("parses 64-char hex without prefix", () => {
			const pk = S.decodeSync(PrivateKey.Hex)(validHexNoPrefix);
			expect(pk).toBeInstanceOf(Uint8Array);
			expect(pk.length).toBe(32);
		});

		it("parses uppercase hex", () => {
			const pk = S.decodeSync(PrivateKey.Hex)(validHex.toUpperCase());
			expect(pk.length).toBe(32);
		});

		it("parses mixed case hex", () => {
			const pk = S.decodeSync(PrivateKey.Hex)(`0x${"Ab".repeat(32)}`);
			expect(pk.length).toBe(32);
		});

		it("fails on wrong length (too short)", () => {
			expect(() => S.decodeSync(PrivateKey.Hex)("0x1234")).toThrow();
		});

		it("fails on wrong length (too long)", () => {
			expect(() =>
				S.decodeSync(PrivateKey.Hex)(`0x${"ab".repeat(33)}`),
			).toThrow();
		});

		it("fails on odd length hex", () => {
			expect(() =>
				S.decodeSync(PrivateKey.Hex)(`0x${"ab".repeat(31)}a`),
			).toThrow();
		});

		it("fails on invalid hex characters", () => {
			expect(() =>
				S.decodeSync(PrivateKey.Hex)(`0x${"gg".repeat(32)}`),
			).toThrow();
		});

		it("fails on empty string", () => {
			expect(() => S.decodeSync(PrivateKey.Hex)("")).toThrow();
		});

		it("fails on just prefix", () => {
			expect(() => S.decodeSync(PrivateKey.Hex)("0x")).toThrow();
		});

		it("fails on whitespace", () => {
			expect(() => S.decodeSync(PrivateKey.Hex)("  ")).toThrow();
		});
	});

	describe("encode", () => {
		it("encodes to lowercase hex with prefix", () => {
			const pk = S.decodeSync(PrivateKey.Hex)(validHex);
			const hex = S.encodeSync(PrivateKey.Hex)(pk);
			expect(hex.startsWith("0x")).toBe(true);
			expect(hex.length).toBe(66);
			expect(hex).toBe(hex.toLowerCase());
		});

		it("round-trips correctly", () => {
			const original = S.decodeSync(PrivateKey.Hex)(validHex);
			const encoded = S.encodeSync(PrivateKey.Hex)(original);
			const decoded = S.decodeSync(PrivateKey.Hex)(encoded);
			expect(decoded.length).toBe(original.length);
			expect([...decoded]).toEqual([...original]);
		});
	});
});

describe("PrivateKey.Bytes", () => {
	describe("decode", () => {
		it("parses 32-byte array", () => {
			const bytes = new Uint8Array(32).fill(0xab);
			const pk = S.decodeSync(PrivateKey.Bytes)(bytes);
			expect(pk.length).toBe(32);
		});

		it("fails on 31 bytes", () => {
			const bytes = new Uint8Array(31);
			expect(() => S.decodeSync(PrivateKey.Bytes)(bytes)).toThrow();
		});

		it("fails on 33 bytes", () => {
			const bytes = new Uint8Array(33);
			expect(() => S.decodeSync(PrivateKey.Bytes)(bytes)).toThrow();
		});

		it("fails on empty array", () => {
			expect(() => S.decodeSync(PrivateKey.Bytes)(new Uint8Array())).toThrow();
		});

		it("fails on 64 bytes", () => {
			const bytes = new Uint8Array(64);
			expect(() => S.decodeSync(PrivateKey.Bytes)(bytes)).toThrow();
		});
	});

	describe("encode", () => {
		it("encodes to 32-byte Uint8Array", () => {
			const pk = S.decodeSync(PrivateKey.Hex)(validHex);
			const bytes = S.encodeSync(PrivateKey.Bytes)(pk);
			expect(bytes).toBeInstanceOf(Uint8Array);
			expect(bytes.length).toBe(32);
		});

		it("preserves byte values", () => {
			const pk = S.decodeSync(PrivateKey.Hex)(validHex);
			const bytes = S.encodeSync(PrivateKey.Bytes)(pk);
			expect(bytes[0]).toBe(0xab);
			expect(bytes[31]).toBe(0xab);
		});
	});
});

describe("effect-wrapped functions", () => {
	describe("isValid", () => {
		it("returns true for valid hex with prefix", async () => {
			const result = await Effect.runPromise(PrivateKey.isValid(validHex));
			expect(result).toBe(true);
		});

		it("returns true for valid hex without prefix", async () => {
			const result = await Effect.runPromise(
				PrivateKey.isValid(validHexNoPrefix),
			);
			expect(result).toBe(true);
		});

		it("returns true for valid 32-byte array", async () => {
			const bytes = new Uint8Array(32).fill(0x01);
			const result = await Effect.runPromise(PrivateKey.isValid(bytes));
			expect(result).toBe(true);
		});

		it("returns false for wrong hex length", async () => {
			const result = await Effect.runPromise(PrivateKey.isValid("0x1234"));
			expect(result).toBe(false);
		});

		it("returns false for wrong byte length", async () => {
			const bytes = new Uint8Array(31);
			const result = await Effect.runPromise(PrivateKey.isValid(bytes));
			expect(result).toBe(false);
		});

		it("returns false for invalid hex chars", async () => {
			const result = await Effect.runPromise(
				PrivateKey.isValid(`0x${"gg".repeat(32)}`),
			);
			expect(result).toBe(false);
		});

		it("returns false for empty string", async () => {
			const result = await Effect.runPromise(PrivateKey.isValid(""));
			expect(result).toBe(false);
		});

		it("returns false for empty array", async () => {
			const result = await Effect.runPromise(
				PrivateKey.isValid(new Uint8Array()),
			);
			expect(result).toBe(false);
		});
	});

	describe("random", () => {
		it("generates 32-byte private key", async () => {
			const pk = await Effect.runPromise(PrivateKey.random());
			expect(pk).toBeInstanceOf(Uint8Array);
			expect(pk.length).toBe(32);
		});

		it("generates different keys each time", async () => {
			const pk1 = await Effect.runPromise(PrivateKey.random());
			const pk2 = await Effect.runPromise(PrivateKey.random());
			expect([...pk1]).not.toEqual([...pk2]);
		});

		it("generates valid private key", async () => {
			const pk = await Effect.runPromise(PrivateKey.random());
			const isValid = await Effect.runPromise(PrivateKey.isValid(pk));
			expect(isValid).toBe(true);
		});

		it("can be encoded to hex", async () => {
			const pk = await Effect.runPromise(PrivateKey.random());
			const hex = S.encodeSync(PrivateKey.Hex)(pk);
			expect(hex.startsWith("0x")).toBe(true);
			expect(hex.length).toBe(66);
		});

		it("generates multiple unique keys", async () => {
			const keys = await Promise.all(
				Array.from({ length: 5 }, () => Effect.runPromise(PrivateKey.random())),
			);
			const hexKeys = keys.map((k) => S.encodeSync(PrivateKey.Hex)(k));
			const uniqueKeys = new Set(hexKeys);
			expect(uniqueKeys.size).toBe(5);
		});
	});
});

describe("edge cases", () => {
	it("handles all-zeros private key", () => {
		const zeroBytes = new Uint8Array(32);
		const pk = S.decodeSync(PrivateKey.Bytes)(zeroBytes);
		expect(pk.length).toBe(32);
	});

	it("handles all-ones private key", () => {
		const oneBytes = new Uint8Array(32).fill(0x01);
		const pk = S.decodeSync(PrivateKey.Bytes)(oneBytes);
		expect(pk.length).toBe(32);
	});

	it("handles max value bytes", () => {
		const maxBytes = new Uint8Array(32).fill(0xff);
		const pk = S.decodeSync(PrivateKey.Bytes)(maxBytes);
		expect(pk.length).toBe(32);
	});

	it("handles known test vector", () => {
		const knownKey =
			"0x0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef";
		const pk = S.decodeSync(PrivateKey.Hex)(knownKey);
		expect(pk.length).toBe(32);
		expect(pk[0]).toBe(0x01);
		expect(pk[1]).toBe(0x23);
	});

	it("handles minimum value key", () => {
		const minKey = `0x${"00".repeat(31)}01`;
		const pk = S.decodeSync(PrivateKey.Hex)(minKey);
		expect(pk.length).toBe(32);
		expect(pk[31]).toBe(0x01);
	});

	it("preserves exact byte values through round-trip", () => {
		const bytes = new Uint8Array(32);
		for (let i = 0; i < 32; i++) bytes[i] = i;
		const pk = S.decodeSync(PrivateKey.Bytes)(bytes);
		const encoded = S.encodeSync(PrivateKey.Bytes)(pk);
		expect([...encoded]).toEqual([...bytes]);
	});
});

describe("cryptographic operations", () => {
	describe("deriving public key", () => {
		it("derives public key from private key", () => {
			const pk = S.decodeSync(PrivateKey.Bytes)(new Uint8Array(32).fill(1));
			const publicKey = Secp256k1.derivePublicKey(pk);
			expect(publicKey).toBeInstanceOf(Uint8Array);
			expect(publicKey.length).toBe(64);
		});

		it("derives public key via core PrivateKey.toPublicKey", () => {
			const pk = S.decodeSync(PrivateKey.Bytes)(new Uint8Array(32).fill(3));
			const hex = S.encodeSync(PrivateKey.Hex)(pk);
			const publicKey = CorePrivateKey.toPublicKey(hex);
			const expected = Secp256k1.derivePublicKey(pk);
			expect([...publicKey]).toEqual([...expected]);
		});

		it("produces consistent public key for same private key", () => {
			const pk = S.decodeSync(PrivateKey.Bytes)(new Uint8Array(32).fill(1));
			const pub1 = Secp256k1.derivePublicKey(pk);
			const pub2 = Secp256k1.derivePublicKey(pk);
			expect([...pub1]).toEqual([...pub2]);
		});

		it("produces different public keys for different private keys", () => {
			const pk1 = S.decodeSync(PrivateKey.Bytes)(new Uint8Array(32).fill(1));
			const pk2 = S.decodeSync(PrivateKey.Bytes)(new Uint8Array(32).fill(2));
			const pub1 = Secp256k1.derivePublicKey(pk1);
			const pub2 = Secp256k1.derivePublicKey(pk2);
			expect([...pub1]).not.toEqual([...pub2]);
		});

		it("works with generated random key", async () => {
			const pk = await Effect.runPromise(PrivateKey.random());
			const publicKey = Secp256k1.derivePublicKey(pk);
			expect(publicKey.length).toBe(64);
		});
	});

	describe("signing messages", () => {
		const messageHash = Hash.from(new Uint8Array(32).fill(0x42));

		it("signs message with private key", () => {
			const pk = S.decodeSync(PrivateKey.Bytes)(new Uint8Array(32).fill(1));
			const signature = Secp256k1.sign(messageHash, pk);
			// Signature is {r, s, v} not a Uint8Array
			expect(signature.r).toBeInstanceOf(Uint8Array);
			expect(signature.s).toBeInstanceOf(Uint8Array);
			expect(signature.r.length).toBe(32);
			expect(signature.s.length).toBe(32);
			expect(signature.v).toBeGreaterThanOrEqual(27);
		});

		it("produces deterministic signatures (RFC 6979)", () => {
			const pk = S.decodeSync(PrivateKey.Bytes)(new Uint8Array(32).fill(1));
			const sig1 = Secp256k1.sign(messageHash, pk);
			const sig2 = Secp256k1.sign(messageHash, pk);
			expect([...sig1.r]).toEqual([...sig2.r]);
			expect([...sig1.s]).toEqual([...sig2.s]);
			expect(sig1.v).toEqual(sig2.v);
		});

		it("produces different signatures for different messages", () => {
			const pk = S.decodeSync(PrivateKey.Bytes)(new Uint8Array(32).fill(1));
			const msg1 = Hash.from(new Uint8Array(32).fill(0x11));
			const msg2 = Hash.from(new Uint8Array(32).fill(0x22));
			const sig1 = Secp256k1.sign(msg1, pk);
			const sig2 = Secp256k1.sign(msg2, pk);
			// At least one component should differ
			const rSame = [...sig1.r].every((b, i) => b === sig2.r[i]);
			const sSame = [...sig1.s].every((b, i) => b === sig2.s[i]);
			expect(rSame && sSame && sig1.v === sig2.v).toBe(false);
		});

		it("signature can be verified against derived public key", () => {
			const pk = S.decodeSync(PrivateKey.Bytes)(new Uint8Array(32).fill(1));
			const publicKey = Secp256k1.derivePublicKey(pk);
			const signature = Secp256k1.sign(messageHash, pk);
			const isValid = Secp256k1.verify(signature, messageHash, publicKey);
			expect(isValid).toBe(true);
		});

		it("signature fails verification with wrong public key", () => {
			const pk = S.decodeSync(PrivateKey.Bytes)(new Uint8Array(32).fill(1));
			const otherPk = S.decodeSync(PrivateKey.Bytes)(
				new Uint8Array(32).fill(2),
			);
			const otherPublicKey = Secp256k1.derivePublicKey(otherPk);
			const signature = Secp256k1.sign(messageHash, pk);
			const isValid = Secp256k1.verify(signature, messageHash, otherPublicKey);
			expect(isValid).toBe(false);
		});
	});

	describe("public key recovery", () => {
		it("recovers public key from signature", () => {
			const pk = S.decodeSync(PrivateKey.Bytes)(new Uint8Array(32).fill(1));
			const publicKey = Secp256k1.derivePublicKey(pk);
			const messageHash = Hash.from(new Uint8Array(32).fill(0x42));
			const signature = Secp256k1.sign(messageHash, pk);
			const recoveredPubKey = Secp256k1.recoverPublicKey(
				signature,
				messageHash,
			);
			expect([...recoveredPubKey]).toEqual([...publicKey]);
		});
	});
});

describe("secp256k1 curve constraints", () => {
	it("rejects zero private key", () => {
		const zeroKey = new Uint8Array(32);
		expect(() => Secp256k1.derivePublicKey(zeroKey as any)).toThrow();
	});

	it("rejects key >= curve order", () => {
		const curveOrder = Secp256k1.CURVE_ORDER;
		const overflowKey = new Uint8Array(32);
		let temp = curveOrder;
		for (let i = 31; i >= 0; i--) {
			overflowKey[i] = Number(temp & 0xffn);
			temp >>= 8n;
		}
		expect(() => Secp256k1.derivePublicKey(overflowKey as any)).toThrow();
	});

	it("accepts valid key near curve order", () => {
		const nearCurveOrder = new Uint8Array(32);
		let temp = Secp256k1.CURVE_ORDER - 1n;
		for (let i = 31; i >= 0; i--) {
			nearCurveOrder[i] = Number(temp & 0xffn);
			temp >>= 8n;
		}
		const pubKey = Secp256k1.derivePublicKey(nearCurveOrder as any);
		expect(pubKey.length).toBe(64);
	});

	it("accepts minimum valid key (1)", () => {
		const minKey = new Uint8Array(32);
		minKey[31] = 1;
		const pubKey = Secp256k1.derivePublicKey(minKey as any);
		expect(pubKey.length).toBe(64);
	});
});

```
