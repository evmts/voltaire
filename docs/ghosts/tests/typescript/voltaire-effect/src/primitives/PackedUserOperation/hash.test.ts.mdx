---
title: '[TS/JS] voltaire-effect/src/primitives/PackedUserOperation/hash.test.ts'
source: 'voltaire-effect/src/primitives/PackedUserOperation/hash.test.ts'
---

> Auto-generated from test file: voltaire-effect/src/primitives/PackedUserOperation/hash.test.ts

```typescript
import { describe, expect, it } from "@effect/vitest";
import { Address } from "@tevm/voltaire/Address";
import * as Effect from "effect/Effect";
import * as Exit from "effect/Exit";
import { hash } from "./hash.js";
import type { PackedUserOperationType } from "./PackedUserOperationSchema.js";

const mockPackedUserOp: PackedUserOperationType = {
	sender: new Uint8Array(20) as PackedUserOperationType["sender"],
	nonce: 0n,
	initCode: new Uint8Array(0),
	callData: new Uint8Array(0),
	accountGasLimits: new Uint8Array(32),
	preVerificationGas: 21000n,
	gasFees: new Uint8Array(32),
	paymasterAndData: new Uint8Array(0),
	signature: new Uint8Array(0),
};

const entryPointAddress = "0x0000000071727De22E5E9d8BAf0edAc6f37da032";

describe("PackedUserOperation.hash", () => {
	it("produces deterministic 32-byte hash", async () => {
		const result = await Effect.runPromise(
			hash(mockPackedUserOp, entryPointAddress, 1n),
		);
		expect(result).toBeInstanceOf(Uint8Array);
		expect(result.length).toBe(32);

		const result2 = await Effect.runPromise(
			hash(mockPackedUserOp, entryPointAddress, 1n),
		);
		expect(result).toEqual(result2);
	});

	it("chainId as number vs bigint yields same result", async () => {
		const resultBigInt = await Effect.runPromise(
			hash(mockPackedUserOp, entryPointAddress, 1n),
		);
		const resultNumber = await Effect.runPromise(
			hash(mockPackedUserOp, entryPointAddress, 1),
		);
		expect(resultBigInt).toEqual(resultNumber);
	});

	it("entryPoint as string address works", async () => {
		const result = await Effect.runPromise(
			hash(mockPackedUserOp, entryPointAddress, 1n),
		);
		expect(result.length).toBe(32);
	});

	it("entryPoint as Uint8Array works", async () => {
		const entryPointBytes = Address(entryPointAddress);
		const resultString = await Effect.runPromise(
			hash(mockPackedUserOp, entryPointAddress, 1n),
		);
		const resultBytes = await Effect.runPromise(
			hash(mockPackedUserOp, entryPointBytes, 1n),
		);
		expect(resultString).toEqual(resultBytes);
	});

	it("invalid entryPoint triggers ValidationError", async () => {
		const exit = await Effect.runPromiseExit(
			hash(mockPackedUserOp, "invalid-address", 1n),
		);
		expect(Exit.isFailure(exit)).toBe(true);
	});

	it("empty initCode/callData produces valid hash", async () => {
		const opWithEmptyData: PackedUserOperationType = {
			...mockPackedUserOp,
			initCode: new Uint8Array(0),
			callData: new Uint8Array(0),
		};
		const result = await Effect.runPromise(
			hash(opWithEmptyData, entryPointAddress, 1n),
		);
		expect(result.length).toBe(32);
	});

	it("very large nonce values work correctly", async () => {
		const opWithLargeNonce: PackedUserOperationType = {
			...mockPackedUserOp,
			nonce: 2n ** 192n - 1n,
		};
		const result = await Effect.runPromise(
			hash(opWithLargeNonce, entryPointAddress, 1n),
		);
		expect(result.length).toBe(32);
	});

	it("different chainIds produce different hashes", async () => {
		const hash1 = await Effect.runPromise(
			hash(mockPackedUserOp, entryPointAddress, 1n),
		);
		const hash137 = await Effect.runPromise(
			hash(mockPackedUserOp, entryPointAddress, 137n),
		);
		expect(hash1).not.toEqual(hash137);
	});
});

```
