---
title: How to Get L1 Block Number from L2
description: Read L1 block information from L2 chains using system contracts.
---

## Goal

Get the latest L1 block number from within an L2 context.

## Concepts

L2s expose L1 block info via system contracts:

- **Optimism/Base**: `L1Block` contract at `0x4200000000000000000000000000000000000015`
- **Arbitrum**: `ArbSys` precompile at `0x0000000000000000000000000000000000000064`
- **Scroll**: `L1MessageQueue` at `0x0000000000000000000000000000000000000001`

## Example: Optimism/Base

```typescript
import * as Address from '@voltaire/primitives/Address';
import * as Abi from '@voltaire/primitives/Abi';
import * as Hex from '@voltaire/primitives/Hex';

// L1Block predeploy on OP Stack chains
const L1_BLOCK = Address("0x4200000000000000000000000000000000000015");

// L1Block ABI (subset)
const L1_BLOCK_ABI = Abi.from([
  "function number() view returns (uint64)",
  "function timestamp() view returns (uint64)",
  "function basefee() view returns (uint256)",
  "function hash() view returns (bytes32)",
  "function sequenceNumber() view returns (uint64)",
  "function blobBaseFee() view returns (uint256)",
]);

// Encode call to get L1 block number
const calldata = Abi.encodeFunction(L1_BLOCK_ABI, "number", []);

// Make eth_call to L1Block contract
// const result = await provider.call({ to: L1_BLOCK, data: calldata });
// const l1BlockNumber = Abi.decodeFunction(L1_BLOCK_ABI, "number", result);
```

## Example: Arbitrum

```typescript
import * as Address from '@voltaire/primitives/Address';
import * as Abi from '@voltaire/primitives/Abi';

// ArbSys precompile
const ARB_SYS = Address("0x0000000000000000000000000000000000000064");

const ARB_SYS_ABI = Abi.from([
  "function arbBlockNumber() view returns (uint256)",
  "function arbBlockHash(uint256 blockNum) view returns (bytes32)",
]);

// Get current Arbitrum block (L2 block, not L1)
const calldata = Abi.encodeFunction(ARB_SYS_ABI, "arbBlockNumber", []);
```

## Cross-Chain Block Verification

```typescript
import * as Chain from '@voltaire/primitives/Chain';

async function getL1BlockInfo(l2ChainId: bigint) {
  const chain = Chain.fromId(l2ChainId);

  if (!Chain.isL2(chain)) {
    throw new Error('Not an L2 chain');
  }

  const name = Chain.getName(chain);

  // Route to correct system contract based on L2 type
  if (name.includes('Optimism') || name.includes('Base')) {
    // Use L1Block predeploy
    return { contract: '0x4200000000000000000000000000000000000015', method: 'number' };
  } else if (name.includes('Arbitrum')) {
    // Use ArbSys
    return { contract: '0x0000000000000000000000000000000000000064', method: 'arbBlockNumber' };
  }

  throw new Error(`Unknown L2 type: ${name}`);
}
```

## Key Points

- L1 block info on L2 is delayed (not real-time)
- Optimism: ~1 block delay
- Arbitrum: Batched, can be several blocks behind
- Use for cross-chain proofs and verification

## Related

- `/primitives/chain` - Chain detection
- `/ghosts/l2/how-to-detect-l1-vs-l2` - L1/L2 detection
