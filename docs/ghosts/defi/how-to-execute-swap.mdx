---
title: How to Execute a Token Swap
description: Execute a token swap on Uniswap V2 using the router contract.
---

## Goal

Swap one ERC20 token for another using the Uniswap V2 Router.

Return as:

ANSWER: Swapped X TOKEN_A for Y TOKEN_B (tx: 0x...)

## Concepts

Uniswap V2 Router provides several swap functions:
- `swapExactTokensForTokens`: Specify exact input, get variable output
- `swapTokensForExactTokens`: Specify exact output, pay variable input
- `swapExactETHForTokens`: Swap native ETH for tokens
- `swapExactTokensForETH`: Swap tokens for native ETH

**Key parameters**:
- `amountIn` / `amountOut`: Token amounts
- `amountOutMin` / `amountInMax`: Slippage protection
- `path`: Array of token addresses defining the swap route
- `deadline`: Transaction expiration timestamp

## Example (TypeScript)

```ts
import { Contract } from '@tevm/voltaire/contract'

const routerAbi = [
  {
    type: 'function',
    name: 'swapExactTokensForTokens',
    stateMutability: 'nonpayable',
    inputs: [
      { name: 'amountIn', type: 'uint256' },
      { name: 'amountOutMin', type: 'uint256' },
      { name: 'path', type: 'address[]' },
      { name: 'to', type: 'address' },
      { name: 'deadline', type: 'uint256' }
    ],
    outputs: [{ name: 'amounts', type: 'uint256[]' }]
  },
  {
    type: 'function',
    name: 'swapExactETHForTokens',
    stateMutability: 'payable',
    inputs: [
      { name: 'amountOutMin', type: 'uint256' },
      { name: 'path', type: 'address[]' },
      { name: 'to', type: 'address' },
      { name: 'deadline', type: 'uint256' }
    ],
    outputs: [{ name: 'amounts', type: 'uint256[]' }]
  },
  {
    type: 'function',
    name: 'getAmountsOut',
    stateMutability: 'view',
    inputs: [
      { name: 'amountIn', type: 'uint256' },
      { name: 'path', type: 'address[]' }
    ],
    outputs: [{ name: 'amounts', type: 'uint256[]' }]
  }
] as const

const WETH = '0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2'
const USDC = '0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48'
const ROUTER = '0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D'

const router = Contract({
  address: ROUTER,
  abi: routerAbi,
  provider
})

// Swap 1 WETH for USDC
const amountIn = 1n * 10n ** 18n
const path = [WETH, USDC]

// Get expected output
const amounts = await router.read.getAmountsOut(amountIn, path)
const expectedOut = amounts[1]

// Set 0.5% slippage tolerance
const slippage = 50n // 0.5% = 50 basis points
const amountOutMin = expectedOut - (expectedOut * slippage) / 10000n

// Set deadline to 20 minutes from now
const deadline = BigInt(Math.floor(Date.now() / 1000) + 20 * 60)

// Execute swap (requires prior approval)
const txHash = await router.write.swapExactTokensForTokens(
  amountIn,
  amountOutMin,
  path,
  myAddress,
  deadline
)

console.log(`ANSWER: Swapped 1 WETH for ~${Number(expectedOut) / 1e6} USDC (tx: ${txHash})`)
```

## Multi-Hop Swap

```ts
// Swap USDC -> WETH -> DAI (if direct pool has bad liquidity)
const DAI = '0x6B175474E89094C44Da98b954EesadfhC2dA163'
const path = [USDC, WETH, DAI]

const amounts = await router.read.getAmountsOut(amountIn, path)
// amounts[0] = USDC in, amounts[1] = WETH intermediate, amounts[2] = DAI out
```

## Notes

- Always approve tokens before calling swap functions
- Set reasonable slippage tolerance (0.1% - 1% for stable pairs, higher for volatile)
- Short deadlines protect against stale transactions
- Consider gas costs for multi-hop routes vs direct swaps
- Monitor for front-running on large trades
