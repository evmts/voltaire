---
title: Address.fromHex
description: Create address from hex string
---

<Tabs>

<Tab title="C">

## `primitives_address_from_hex(const char* hex, PrimitivesAddress* out_address): int`

Create address from hex string in C. Accepts hex strings with or without `0x` prefix.

**Parameters:**
- `hex: const char*` - Hex string (with or without `0x` prefix)
- `out_address: PrimitivesAddress*` - Pointer to output address struct (20 bytes)

**Returns:** `int` - `PRIMITIVES_SUCCESS` (0) on success, error code otherwise

**Example:**

```c
#include "primitives.h"

// From hex string
PrimitivesAddress addr1;
int result = primitives_address_from_hex("0x742d35Cc6634C0532925a3b844Bc9e7595f51e3e", &addr1);
if (result != PRIMITIVES_SUCCESS) {
    // Handle error
}

// From hex without prefix
PrimitivesAddress addr2;
result = primitives_address_from_hex("742d35Cc6634C0532925a3b844Bc9e7595f51e3e", &addr2);

// Case insensitive
PrimitivesAddress addr3;
result = primitives_address_from_hex("0x742D35CC6634C0532925A3B844BC9E7595F51E3E", &addr3);
```

**Error Handling:**
- Returns non-zero error code on failure
- Check result before using `out_address`
- Common errors: invalid hex format, incorrect length

**Memory:** No allocation - address is copied to provided struct.

**Defined in:** [primitives.h:103](https://github.com/evmts/voltaire/blob/main/src/primitives.h#L103)

</Tab>
</Tabs>

## Format Requirements

**Length (implementation-dependent):**

**TypeScript implementations (Class API):**
- **Requires** `0x` prefix: exactly 42 characters total

**Zig and C implementations:**
- **Accepts** both formats:
  - With `0x` prefix: exactly 42 characters
  - Without `0x` prefix: exactly 40 characters

**Characters:**
- Valid: `0-9`, `a-f`, `A-F`
- Invalid: `g-z`, `G-Z`, whitespace, special characters

**Case sensitivity:**
- Parsing is case-insensitive
- Both lowercase and uppercase hex are accepted
- Mixed-case (EIP-55 checksummed) addresses are valid

## Error Handling

```typescript
import { Address } from '@tevm/voltaire'

// Missing 0x prefix
try {
  Address.fromHex("742d35Cc6634C0532925a3b844Bc9e7595f51e3e")
} catch (e) {
  console.error(e) // InvalidHexFormatError
}

// Wrong length
try {
  Address.fromHex("0x742d35")
} catch (e) {
  console.error(e) // InvalidHexFormatError
}

// Invalid characters
try {
  Address.fromHex("0xGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGG")
} catch (e) {
  console.error(e) // InvalidHexStringError
}
```

## Validation Before Parsing

Use `Address.isValid()` to check before parsing:

```typescript
const input = "0x742d35Cc6634C0532925a3b844Bc9e7595f51e3e"

if (Address.isValid(input)) {
  const addr = Address.fromHex(input)
  console.log(addr.toHex())
} else {
  console.error("Invalid address format")
}
```

## EIP-55 Checksums

`fromHex()` accepts checksummed addresses but does not validate checksums. Use `isValidChecksum()` to validate before parsing:

```typescript
const checksummed = "0x5aAeb6053F3E94C9b9A09f33669435E7Ef1BeAed"

if (Address.isValidChecksum(checksummed)) {
  const addr = Address.fromHex(checksummed)
  console.log("Checksum valid")
} else {
  console.warn("Invalid checksum, but parsing anyway")
  const addr = Address.fromHex(checksummed)
}
```

## See Also

- [from](/primitives/address/from) - Universal constructor
- [fromBytes](/primitives/address/from-bytes) - Create from Uint8Array
- [toHex](/primitives/address/to-hex) - Convert to hex string
- [toChecksummed](/primitives/address/to-checksummed) - Convert to EIP-55 checksummed hex
- [isValid](/primitives/address/is-valid) - Validate address format
- [isValidChecksum](/primitives/address/is-valid-checksum) - Validate EIP-55 checksum
- [EIP-55: Mixed-case checksum](https://eips.ethereum.org/EIPS/eip-55)
