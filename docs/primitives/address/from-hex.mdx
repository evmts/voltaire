---
title: Address.fromHex
description: Create address from hex string
---

<Tabs>
<Tab title="Class API">

## `Address.fromHex(hex: string): Address`

Creates address from hex string. Requires `0x` prefix and exactly 40 hex characters (42 total including prefix).

**Parameters:**
- `hex: string` - Hex string with `0x` prefix

**Returns:** `Address` - Address instance

**Example:**

```typescript
import { Address } from '@tevm/voltaire'

const addr = Address.fromHex("0x742d35Cc6634C0532925a3b844Bc9e7595f51e3e")

// Works with any casing
const addr2 = Address.fromHex("0x742d35cc6634c0532925a3b844bc9e7595f51e3e")
const addr3 = Address.fromHex("0x742D35CC6634C0532925A3B844BC9E7595F51E3E")

// EIP-55 checksummed addresses work
const addr4 = Address.fromHex("0x5aAeb6053F3E94C9b9A09f33669435E7Ef1BeAed")
```

**Throws:**
- `InvalidHexFormatError` - Missing `0x` prefix or incorrect length
- `InvalidHexStringError` - Invalid hex characters (not 0-9, a-f, A-F)

**Defined in:** [primitives/Address/BrandedAddress/fromHex.js:19](https://github.com/evmts/voltaire/blob/main/src/primitives/Address/BrandedAddress/fromHex.js#L19)

</Tab>
<Tab title="Namespace API">

## `fromHex(hex: string): BrandedAddress`

Creates address from hex string. Requires `0x` prefix and exactly 40 hex characters.

**Parameters:**
- `hex: string` - Hex string with `0x` prefix

**Returns:** `BrandedAddress` - Branded Uint8Array (20 bytes)

**Example:**

```typescript
import * as Address from '@tevm/voltaire/Address'

const addr = Address.fromHex("0x742d35Cc6634C0532925a3b844Bc9e7595f51e3e")

// Access raw bytes
console.log(addr.length) // 20
console.log(addr[0])     // 0x74
```

**Defined in:** [primitives/Address/BrandedAddress/fromHex.js:19](https://github.com/evmts/voltaire/blob/main/src/primitives/Address/BrandedAddress/fromHex.js#L19)

</Tab>
<Tab title="Zig">

## `Address.fromHex(hex: []const u8): !Address`

Parse hex string to address. Accepts hex with or without `0x` prefix.

**Parameters:**
- `hex: []const u8` - Hex string bytes

**Returns:** `Address` - Parsed address

**Errors:**
- `InvalidHexFormat` - Wrong length or format
- `InvalidHexCharacter` - Invalid hex character

**Example:**

```zig
const std = @import("std");
const Address = @import("primitives").Address;

// With 0x prefix
const addr1 = try Address.fromHex("0x742d35Cc6634C0532925a3b844Bc9e7595f51e3e");

// Without 0x prefix
const addr2 = try Address.fromHex("742d35Cc6634C0532925a3b844Bc9e7595f51e3e");

// Case insensitive
const addr3 = try Address.fromHex("0x742D35CC6634C0532925A3B844BC9E7595F51E3E");
```

**Defined in:** [primitives/Address/address.zig:42](https://github.com/evmts/voltaire/blob/main/src/primitives/Address/address.zig#L42)

</Tab>
<Tab title="Effect.ts API">

## `Address.fromHex(hex: string): Address`

Parse hex string to address using Effect Schema. Validates format and returns Address schema instance.

**Parameters:**
- `hex: string` - Hex string with `0x` prefix

**Returns:** `Address` - Effect Schema instance wrapping validated BrandedAddress

**Example:**

```typescript
import { Address } from '@tevm/voltaire/Address/effect'

const addr = Address.fromHex("0x742d35Cc6634C0532925a3b844Bc9e7595f51e3e")

// Works with any casing
const addr2 = Address.fromHex("0x742d35cc6634c0532925a3b844bc9e7595f51e3e")
const addr3 = Address.fromHex("0x742D35CC6634C0532925A3B844BC9E7595F51E3E")

// Access underlying BrandedAddress
const branded = addr.address // BrandedAddress Uint8Array

// Convert to hex
const hex = addr.toHex()
```

**Schema Decoding:**

```typescript
import { Address, AddressFromHex } from '@tevm/voltaire/Address/effect'
import * as Schema from 'effect/Schema'

// Parse and validate hex string
const parseAddress = Schema.decodeSync(AddressFromHex)
const addr = parseAddress("0x742d35Cc6634C0532925a3b844Bc9e7595f51e3e")

// Encode back to hex
const encodeAddress = Schema.encodeSync(AddressFromHex)
const hex = encodeAddress(addr) // "0x742d35cc6634c0532925a3b844bc9e7595f51e3e"
```

**Throws:**
- `InvalidHexFormatError` - Missing `0x` prefix or incorrect length
- `InvalidHexStringError` - Invalid hex characters

**Effect Schema Features:**
- Schema validation and transformation
- Type-safe encoding/decoding
- Integration with Effect's error handling
- Composable with other Effect schemas

**Defined in:** [primitives/Address/effect.ts:52](https://github.com/evmts/voltaire/blob/main/src/primitives/Address/effect.ts#L52)

</Tab>
<Tab title="C">

## `primitives_address_from_hex(const char* hex, PrimitivesAddress* out_address): int`

Create address from hex string in C. Accepts hex strings with or without `0x` prefix.

**Parameters:**
- `hex: const char*` - Hex string (with or without `0x` prefix)
- `out_address: PrimitivesAddress*` - Pointer to output address struct (20 bytes)

**Returns:** `int` - `PRIMITIVES_SUCCESS` (0) on success, error code otherwise

**Example:**

```c
#include "primitives.h"

// From hex string
PrimitivesAddress addr1;
int result = primitives_address_from_hex("0x742d35Cc6634C0532925a3b844Bc9e7595f51e3e", &addr1);
if (result != PRIMITIVES_SUCCESS) {
    // Handle error
}

// From hex without prefix
PrimitivesAddress addr2;
result = primitives_address_from_hex("742d35Cc6634C0532925a3b844Bc9e7595f51e3e", &addr2);

// Case insensitive
PrimitivesAddress addr3;
result = primitives_address_from_hex("0x742D35CC6634C0532925A3B844BC9E7595F51E3E", &addr3);
```

**Error Handling:**
- Returns non-zero error code on failure
- Check result before using `out_address`
- Common errors: invalid hex format, incorrect length

**Memory:** No allocation - address is copied to provided struct.

**Defined in:** [primitives.h:103](https://github.com/evmts/voltaire/blob/main/src/primitives.h#L103)

</Tab>
</Tabs>

## Format Requirements

**Length (implementation-dependent):**

**TypeScript implementations (Class API, Namespace API, Effect.ts):**
- **Requires** `0x` prefix: exactly 42 characters total

**Zig and C implementations:**
- **Accepts** both formats:
  - With `0x` prefix: exactly 42 characters
  - Without `0x` prefix: exactly 40 characters

**Characters:**
- Valid: `0-9`, `a-f`, `A-F`
- Invalid: `g-z`, `G-Z`, whitespace, special characters

**Case sensitivity:**
- Parsing is case-insensitive
- Both lowercase and uppercase hex are accepted
- Mixed-case (EIP-55 checksummed) addresses are valid

## Error Handling

```typescript
import { Address } from '@tevm/voltaire'

// Missing 0x prefix
try {
  Address.fromHex("742d35Cc6634C0532925a3b844Bc9e7595f51e3e")
} catch (e) {
  console.error(e) // InvalidHexFormatError
}

// Wrong length
try {
  Address.fromHex("0x742d35")
} catch (e) {
  console.error(e) // InvalidHexFormatError
}

// Invalid characters
try {
  Address.fromHex("0xGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGG")
} catch (e) {
  console.error(e) // InvalidHexStringError
}
```

## Validation Before Parsing

Use `Address.isValid()` to check before parsing:

```typescript
const input = "0x742d35Cc6634C0532925a3b844Bc9e7595f51e3e"

if (Address.isValid(input)) {
  const addr = Address.fromHex(input)
  console.log(addr.toHex())
} else {
  console.error("Invalid address format")
}
```

## EIP-55 Checksums

`fromHex()` accepts checksummed addresses but does not validate checksums. Use `isValidChecksum()` to validate before parsing:

```typescript
const checksummed = "0x5aAeb6053F3E94C9b9A09f33669435E7Ef1BeAed"

if (Address.isValidChecksum(checksummed)) {
  const addr = Address.fromHex(checksummed)
  console.log("Checksum valid")
} else {
  console.warn("Invalid checksum, but parsing anyway")
  const addr = Address.fromHex(checksummed)
}
```

## See Also

- [from](/primitives/address/from) - Universal constructor
- [fromBytes](/primitives/address/from-bytes) - Create from Uint8Array
- [toHex](/primitives/address/to-hex) - Convert to hex string
- [toChecksummed](/primitives/address/to-checksummed) - Convert to EIP-55 checksummed hex
- [isValid](/primitives/address/is-valid) - Validate address format
- [isValidChecksum](/primitives/address/is-valid-checksum) - Validate EIP-55 checksum
- [EIP-55: Mixed-case checksum](https://eips.ethereum.org/EIPS/eip-55)
