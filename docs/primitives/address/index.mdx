---
title: Address
description: 20-byte Ethereum address with EIP-55 checksumming
---

# Address

Ethereum addresses are 20-byte identifiers for accounts (both externally-owned and contracts). They're derived from public keys (EOAs) or calculated deterministically during contract deployment.

<Tip title="Learn the fundamentals">
New to Ethereum addresses? Start with [Fundamentals](/primitives/address/fundamentals) to learn address derivation, EIP-55 checksumming, and CREATE/CREATE2 contract deployment.
</Tip>

## Overview

Address is represented as a [branded](/getting-started/branded-types) [`Uint8Array`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array) following data-first principles used throughout Voltaire.

```typescript
export type BrandedAddress = Uint8Array & { readonly __tag: "Address" };
```

Addresses use EIP-55 mixed-case checksumming for error detection. Voltaire handles checksums automatically while storing addresses as raw bytes internally to avoid case-sensitivity bugs.

### Developer Experience

Despite being a `Uint8Array`, addresses display formatted in most environments:

```typescript
const address = Address(0x742d35Cc6634C0532925a3b844Bc9e7595f51e3en);
console.log(address);
// Address("0x742d35cc6634c0532925a3b844bc9e7595f51e3e")
```

This makes debugging more readable than raw byte arrays while maintaining the performance and compatibility benefits of `Uint8Array`.

## Quick Start

<Tabs>

</Tabs>

## Practical Examples

See [Fundamentals](/primitives/address/fundamentals) for detailed explanations of address derivation, checksumming, and contract address calculation.

## API Methods

### Constructors

- [`from(value)`](./from) - Universal constructor from any input
- [`fromHex(hex)`](./from-hex) - Parse hex string (with or without 0x prefix)
- [`fromBytes(bytes)`](./from-bytes) - Create from Uint8Array (must be 20 bytes)
- [`fromNumber(value)`](./from-number) - Create from bigint or number
- [`fromPublicKey(x, y)`](./from-public-key) - Derive from secp256k1 public key
- [`fromPrivateKey(privateKey)`](./from-private-key) - Derive from private key
- [`zero()`](./zero) - Create zero address (0x0000...0000)

### Conversions

- [`toHex(address)`](./to-hex) - Convert to lowercase hex string with 0x prefix
- [`toChecksummed(address)`](./to-checksummed) - Convert to EIP-55 mixed-case checksummed hex
- [`toShortHex(address)`](./to-short-hex) - Format for display (0x742dâ€¦1e3e)
- [`toBytes(address)`](./to-bytes) - Return raw Uint8Array

### Validation

- [`isValid(value)`](./is-valid) - Check if value can be converted to address
- [`isValidChecksum(hex)`](./is-valid-checksum) - Verify EIP-55 checksum (case-sensitive)

### Comparisons

- [`equals(a, b)`](./equals) - Check equality
- [`compare(a, b)`](./compare) - Compare for sorting (-1, 0, 1)

### Contract Addresses

- [`calculateCreateAddress(address, nonce)`](./calculate-create-address) - Calculate CREATE deployment address
- [`calculateCreate2Address(address, salt, initCode)`](./calculate-create2-address) - Calculate CREATE2 deployment address

### Reference

- [Fundamentals](./fundamentals) - Address derivation, checksumming, and deployment
- [Usage Patterns](./usage-patterns) - Common patterns and best practices
- [BrandedAddress](./branded-address) - Type definition and branded type pattern
- [Variants](./variants) - Additional utilities and variants
- [WASM](./wasm) - WebAssembly implementation details

### Complete API

<Tabs>

</Tabs>

## Types

<Tabs>
<Tab title="BrandedAddress">

```typescript
export type BrandedAddress = Uint8Array & {
  readonly __tag: "Address";
};
```

Main branded type. Runtime is `Uint8Array` (20 bytes), TypeScript enforces type safety.

</Tab>
<Tab title="AddressLike">

```typescript
type AddressLike =
  | Uint8Array
  | BrandedAddress
  | Address
  | string
  | number
  | bigint;
```

Union type accepting any input that can be coerced to address. Accepted by `Address.from()`.

</Tab>
<Tab title="Checksummed Variants">

```typescript
export type Checksummed = string & { readonly __tag: "Checksummed" };
export type Lowercase = string & { readonly __tag: "Lowercase" };
export type Uppercase = string & { readonly __tag: "Uppercase" };
```

Branded string types for different hex formats. See [variants](./variants) for details.

</Tab>
</Tabs>

## Constants

```typescript
Address.SIZE      // 20 - Address size in bytes
Address.HEX_SIZE  // 42 - Hex string length with "0x" prefix (2 + 40 characters)
```

## Usage Patterns

### Validating User Input

```typescript
// Safe parsing with validation
function parseUserAddress(input: string): Address {
  if (!Address.isValid(input)) {
    throw new Error("Invalid address format");
  }

  const addr = Address(input);

  // Optionally verify checksum if provided
  if (Address.isValidChecksum(input) === false) {
    console.warn("Checksum mismatch - possible typo");
  }

  return addr;
}

// Usage
try {
  const addr = parseUserAddress("0x742d35Cc...");
  console.log(`Valid address: ${addr.toChecksummed()}`);
} catch (e) {
  console.error("Invalid address");
}
```

### Sorting and Deduplicating

```typescript
// Sort addresses for consistent ordering
const addresses = [
  Address("0xCCCC..."),
  Address("0xAAAA..."),
  Address("0xBBBB..."),
];

const sorted = Address.sortAddresses(addresses);
console.log(sorted.map(a => a.toHex()));
// ["0xaaaa...", "0xbbbb...", "0xcccc..."]

// Remove duplicates
const unique = Address.deduplicateAddresses([addr1, addr2, addr1]);
console.log(unique.length); // 2
```

### Predicting Contract Addresses

```typescript
// Predict CREATE2 address before deployment
const factory = Address("0x...");
const salt = Bytes32();
const initCode = compileContract(); // bytecode

// Calculate address deterministically
const predictedAddress = factory.calculateCreate2Address(salt, initCode);

// Deploy contract
await deployer.deploy(initCode, salt);

// Verify prediction
const deployedAddress = await getDeployedAddress();
console.log(predictedAddress.equals(deployedAddress)); // true
```

## Tree-Shaking

Import only what you need for optimal bundle size:

```typescript
// Import specific functions (tree-shakeable)
import { fromHex, toChecksummed, equals } from '@tevm/voltaire/Address';

const addr = fromHex("0x742d35cc...");
const checksummed = toChecksummed(addr);
const isEqual = equals(addr, addr2);

// Only these 3 functions included in bundle
// Unused functions (calculateCreateAddress, fromPublicKey, etc.) excluded
```

<Tip title="Bundle Impact">
Importing from `@tevm/voltaire/Address` instead of the main entry point enables tree-shaking. For example, if you only need `fromHex` and `toChecksummed`, contract address calculation and public key derivation are excluded from your bundle.
</Tip>

## Related

- [Hash](/primitives/hash) - Keccak256 hashing for address derivation and verification
- [Hex](/primitives/hex) - Hex string encoding with EIP-55 checksum support
- [Uint](/primitives/uint) - Unsigned integer types for address arithmetic

## Specification References

- [EIP-55](https://eips.ethereum.org/EIPS/eip-55) - Mixed-case checksum address encoding
- [EIP-1014](https://eips.ethereum.org/EIPS/eip-1014) - CREATE2 opcode and deterministic addresses
- [Ethereum Yellow Paper](https://ethereum.github.io/yellowpaper/paper.pdf) - Address derivation (Section 7)
- [Account Model](https://ethereum.org/en/developers/docs/accounts/) - EOA vs Contract accounts
