---
title: Address.fromNumber
description: Create address from number or bigint
---

<Tabs>
<Tab title="Class API">

## `Address.fromNumber(value: bigint | number): Address`

Creates address from numeric value. Takes lower 160 bits (20 bytes) of the input.

**Parameters:**
- `value: bigint | number` - Numeric value (must be non-negative)

**Returns:** `Address` - Address from lower 160 bits

**Example:**

```typescript
import { Address } from '@tevm/voltaire'

// From bigint
const addr1 = Address.fromNumber(0x742d35Cc6634C0532925a3b844Bc9e7595f251e3n)
console.log(addr1.toHex())
// "0x742d35cc6634c0532925a3b844bc9e7595f251e3"

// From number
const addr2 = Address.fromNumber(69)
console.log(addr2.toHex())
// "0x0000000000000000000000000000000000000045" (69 = 0x45)

// From small number
const addr3 = Address.fromNumber(0)
console.log(addr3.equals(Address.zero())) // true
```

**Throws:**
- `InvalidValueError` - If value is negative

**Defined in:** [primitives/Address/BrandedAddress/fromNumber.js:17](https://github.com/evmts/voltaire/blob/main/src/primitives/Address/BrandedAddress/fromNumber.js#L17)

</Tab>
<Tab title="Namespace API">

## `fromNumber(value: bigint | number): BrandedAddress`

Creates address from numeric value. Takes lower 160 bits.

**Parameters:**
- `value: bigint | number` - Numeric value (must be non-negative)

**Returns:** `BrandedAddress` - Address (20 bytes)

**Example:**

```typescript
import * as Address from '@tevm/voltaire/Address'

const addr = Address.fromNumber(69n)
console.log(Address.toHex(addr))
// "0x0000000000000000000000000000000000000045"
```

**Defined in:** [primitives/Address/BrandedAddress/fromNumber.js:17](https://github.com/evmts/voltaire/blob/main/src/primitives/Address/BrandedAddress/fromNumber.js#L17)

</Tab>
<Tab title="Zig">

## `Address.fromNumber(value: u160): Address`

Create address from 160-bit unsigned integer.

**Parameters:**
- `value: u160` - 160-bit unsigned integer

**Returns:** `Address` - Address

**Example:**

```zig
const std = @import("std");
const Address = @import("primitives").Address;

const addr = Address.fromNumber(69);
std.debug.print("{}\n", .{addr});

// For larger values, use u160
const large: u160 = 0x742d35Cc6634C0532925a3b844Bc9e7595f251e3;
const addr2 = Address.fromNumber(large);
```

**Defined in:** [primitives/Address/address.zig:55](https://github.com/evmts/voltaire/blob/main/src/primitives/Address/address.zig#L55)

</Tab>
<Tab title="Effect.ts">

## `Address.fromNumber(value: number | bigint): Address`

Creates Address using Effect.ts Schema validation. Returns Address instance wrapping validated BrandedAddress.

**Parameters:**
- `value: number | bigint` - Numeric value (must be non-negative)

**Returns:** `Address` - Effect Schema instance wrapping BrandedAddress

**Example:**

```typescript
import { Address } from '@tevm/voltaire/effect'

// From bigint
const addr1 = Address.fromNumber(0x742d35Cc6634C0532925a3b844Bc9e7595f251e3n)
console.log(addr1.toHex())
// "0x742d35cc6634c0532925a3b844bc9e7595f251e3"

// From number
const addr2 = Address.fromNumber(69)
console.log(addr2.toHex())
// "0x0000000000000000000000000000000000000045"

// Access underlying BrandedAddress
const branded = addr1.address

// Chain with other methods
const next = Address.fromNumber(100n)
const isZero = next.isZero() // false
const hex = next.toChecksummed()
```

**Schema Integration:**

```typescript
import { Schema } from 'effect'
import { Address } from '@tevm/voltaire/effect'

// Use in Schema definitions
const AccountSchema = Schema.Struct({
  owner: Schema.instanceOf(Address),
  nonce: Schema.Number,
  balance: Schema.BigIntFromSelf,
})

// Create from number
const addr = Address.fromNumber(42n)

// Validate and parse
const account = Schema.decodeUnknownSync(AccountSchema)({
  owner: addr,
  nonce: 0,
  balance: 1000n,
})
```

**Defined in:** [primitives/Address/effect.ts:68](https://github.com/evmts/voltaire/blob/main/src/primitives/Address/effect.ts#L68)

</Tab>
<Tab title="C API">

## C API Not Available

The C API does not currently expose `address_from_number`. Use `address_from_hex` instead:

```c
#include "primitives.h"
#include <stdio.h>

int main() {
    PrimitivesAddress addr;

    // Convert number to hex string first
    const char* hex = "0x0000000000000000000000000000000000000045"; // 69 decimal

    int result = primitives_address_from_hex(hex, &addr);
    if (result == PRIMITIVES_SUCCESS) {
        printf("Address created successfully\n");
    }

    return 0;
}
```

**Alternative:** Convert numeric values to hex strings before calling C API, or use TypeScript/Zig directly.

**Available C Functions:**
- `primitives_address_from_hex()` - Create from hex string

**Defined in:** [primitives.h](https://github.com/evmts/voltaire/blob/main/src/primitives.h)

</Tab>
</Tabs>

## Bit Masking

Takes **lower 160 bits** (20 bytes) of input value. Higher bits are discarded.

**Formula:** `address = value & ((1 << 160) - 1)`

**Examples:**
```typescript
import { Address } from '@tevm/voltaire'

// Value fits in 160 bits - no truncation
const fits = 0x742d35Cc6634C0532925a3b844Bc9e7595f251e3n
const addr1 = Address.fromNumber(fits)
console.log(addr1.toHex())
// "0x742d35cc6634c0532925a3b844bc9e7595f251e3"

// Value larger than 160 bits - truncates
const large = 0x1234567890abcdef742d35Cc6634C0532925a3b844Bc9e7595f251e3n
const addr2 = Address.fromNumber(large)
console.log(addr2.toHex())
// "0x742d35cc6634c0532925a3b844bc9e7595f251e3" (same as addr1)
```

## Use Cases

### Sequential Addresses

Generate sequential addresses for testing:

```typescript
import { Address } from '@tevm/voltaire'

const testAddresses = Array.from({ length: 10 }, (_, i) =>
  Address.fromNumber(i + 1)
)

testAddresses.forEach((addr, i) => {
  console.log(`Address ${i + 1}: ${addr.toHex()}`)
})
```

### Address Arithmetic

Perform arithmetic on addresses:

```typescript
import { Address } from '@tevm/voltaire'

function nextAddress(addr: Address): Address {
  const n = addr.toU256()
  return Address.fromNumber(n + 1n)
}

const addr = Address.fromNumber(100n)
const next = nextAddress(addr)
console.log(addr.toHex())  // "0x...0064"
console.log(next.toHex())  // "0x...0065"
```

### Numeric Conversions

Convert between numeric and address representations:

```typescript
import { Address } from '@tevm/voltaire'

// Numeric to address
const num = 0x742d35Cc6634C0532925a3b844Bc9e7595f251e3n
const addr = Address.fromNumber(num)

// Address to numeric
const backToNum = addr.toU256()
console.log(num === backToNum) // true
```

### Test Fixtures

Create predictable test addresses:

```typescript
import { Address } from '@tevm/voltaire'

const TEST_ADDRESSES = {
  ZERO: Address.fromNumber(0n),
  ONE: Address.fromNumber(1n),
  MAX: Address.fromNumber((1n << 160n) - 1n),
  ALICE: Address.fromNumber(100n),
  BOB: Address.fromNumber(200n),
  CHARLIE: Address.fromNumber(300n),
}
```

## Number vs Bigint

**Number (JavaScript):** Safe for values up to 2^53 - 1:
```typescript
Address.fromNumber(69)              // ✓ Safe
Address.fromNumber(Number.MAX_SAFE_INTEGER) // ✓ Safe (2^53 - 1)
Address.fromNumber(Number.MAX_VALUE)         // ⚠ May lose precision
```

**Bigint:** Required for larger values:
```typescript
Address.fromNumber(0x742d35Cc6634C0532925a3b844Bc9e7595f251e3n) // ✓ Safe
```

**Recommendation:** Use bigint for address-sized values (160 bits).

## Error Handling

```typescript
import { Address } from '@tevm/voltaire'

// Valid values
console.log(Address.fromNumber(0n))    // ✓ Zero address
console.log(Address.fromNumber(69n))   // ✓ Small value
console.log(Address.fromNumber((1n << 160n) - 1n)) // ✓ Max address

// Invalid: negative
try {
  Address.fromNumber(-1n)
} catch (e) {
  console.error(e) // InvalidValueError: Address value cannot be negative
}

try {
  Address.fromNumber(-69)
} catch (e) {
  console.error(e) // InvalidValueError: Address value cannot be negative
}
```

## Overflow Behavior

Values larger than 160 bits are **truncated** (not an error):

```typescript
import { Address } from '@tevm/voltaire'

// 256-bit value (Hash-sized)
const hash = 0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdefn

// Takes lower 160 bits
const addr = Address.fromNumber(hash)

// Higher bits discarded
console.log(addr.toHex())
// "0x1234567890abcdef1234567890abcdef12345678"
//   ^                                     ^ (last 40 hex chars)
```

## Comparison with Other Constructors

```typescript
import { Address } from '@tevm/voltaire'

const value = 69n

// All produce same address
const addr1 = Address.fromNumber(value)
const addr2 = Address.from(value)
const addr3 = Address.fromHex("0x0000000000000000000000000000000000000045")
const addr4 = Address.fromBytes(new Uint8Array([0, 0, ..., 0x45]))

console.log(addr1.equals(addr2)) // true
console.log(addr1.equals(addr3)) // true
console.log(addr1.equals(addr4)) // true
```

**When to use `fromNumber()`:**
- Have numeric value
- Performing address arithmetic
- Generating test addresses
- Converting from U256

**When to use other constructors:**
- `fromHex()` - Have hex string
- `fromBytes()` - Have byte array
- `from()` - Type unknown or mixed inputs

## See Also

- [from](/primitives/address/from) - Universal constructor
- [fromHex](/primitives/address/from-hex) - Parse from hex string
- [fromBytes](/primitives/address/from-bytes) - Create from bytes
- [toU256](/primitives/address/conversions#tou256) - Convert to numeric
