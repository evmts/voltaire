---
title: Address.fromNumber
description: Create address from number or bigint
---

<Tabs>

</Tabs>

## Bit Masking

Takes **lower 160 bits** (20 bytes) of input value. Higher bits are discarded.

**Formula:** `address = value & ((1 << 160) - 1)`

**Examples:**
```typescript
import { Address } from '@tevm/voltaire'

// Value fits in 160 bits - no truncation
const fits = 0x742d35Cc6634C0532925a3b844Bc9e7595f251e3n
const addr1 = Address(fits)
console.log(addr1.toHex())
// "0x742d35cc6634c0532925a3b844bc9e7595f251e3"

// Value larger than 160 bits - truncates
const large = 0x1234567890abcdef742d35Cc6634C0532925a3b844Bc9e7595f251e3n
const addr2 = Address(large)
console.log(addr2.toHex())
// "0x742d35cc6634c0532925a3b844bc9e7595f251e3" (same as addr1)
```

## Use Cases

### Sequential Addresses

Generate sequential addresses for testing:

```typescript
import { Address } from '@tevm/voltaire'

const testAddresses = Array({ length: 10 }, (_, i) =>
  Address(i + 1)
)

testAddresses.forEach((addr, i) => {
  console.log(`Address ${i + 1}: ${addr.toHex()}`)
})
```

### Address Arithmetic

Perform arithmetic on addresses:

```typescript
import { Address } from '@tevm/voltaire'

function nextAddress(addr: Address): Address {
  const n = addr.toU256()
  return Address(n + 1n)
}

const addr = Address(100n)
const next = nextAddress(addr)
console.log(addr.toHex())  // "0x...0064"
console.log(next.toHex())  // "0x...0065"
```

### Numeric Conversions

Convert between numeric and address representations:

```typescript
import { Address } from '@tevm/voltaire'

// Numeric to address
const num = 0x742d35Cc6634C0532925a3b844Bc9e7595f251e3n
const addr = Address(num)

// Address to numeric
const backToNum = addr.toU256()
console.log(num === backToNum) // true
```

### Test Fixtures

Create predictable test addresses:

```typescript
import { Address } from '@tevm/voltaire'

const TEST_ADDRESSES = {
  ZERO: Address(0n),
  ONE: Address(1n),
  MAX: Address((1n << 160n) - 1n),
  ALICE: Address(100n),
  BOB: Address(200n),
  CHARLIE: Address(300n),
}
```

## Number vs Bigint

**Number (JavaScript):** Safe for values up to 2^53 - 1:
```typescript
Address(69)              // ✓ Safe
Address(Number.MAX_SAFE_INTEGER) // ✓ Safe (2^53 - 1)
Address(Number.MAX_VALUE)         // ⚠ May lose precision
```

**Bigint:** Required for larger values:
```typescript
Address(0x742d35Cc6634C0532925a3b844Bc9e7595f251e3n) // ✓ Safe
```

**Recommendation:** Use bigint for address-sized values (160 bits).

## Error Handling

```typescript
import { Address } from '@tevm/voltaire'

// Valid values
console.log(Address(0n))    // ✓ Zero address
console.log(Address(69n))   // ✓ Small value
console.log(Address((1n << 160n) - 1n)) // ✓ Max address

// Invalid: negative
try {
  Address(-1n)
} catch (e) {
  console.error(e) // InvalidValueError: Address value cannot be negative
}

try {
  Address(-69)
} catch (e) {
  console.error(e) // InvalidValueError: Address value cannot be negative
}
```

## Overflow Behavior

Values larger than 160 bits are **truncated** (not an error):

```typescript
import { Address } from '@tevm/voltaire'

// 256-bit value (Hash-sized)
const hash = 0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdefn

// Takes lower 160 bits
const addr = Address(hash)

// Higher bits discarded
console.log(addr.toHex())
// "0x1234567890abcdef1234567890abcdef12345678"
//   ^                                     ^ (last 40 hex chars)
```

## Comparison with Other Constructors

```typescript
import { Address } from '@tevm/voltaire'

const value = 69n

// All produce same address
const addr1 = Address(value)
const addr2 = Address(value)
const addr3 = Address("0x0000000000000000000000000000000000000045")
const addr4 = Address(new Uint8Array([0, 0, ..., 0x45]))

console.log(addr1.equals(addr2)) // true
console.log(addr1.equals(addr3)) // true
console.log(addr1.equals(addr4)) // true
```

**When to use `fromNumber()`:**
- Have numeric value
- Performing address arithmetic
- Generating test addresses
- Converting from U256

**When to use other constructors:**
- `fromHex()` - Have hex string
- `fromBytes()` - Have byte array
- `from()` - Type unknown or mixed inputs

## See Also

- [from](/primitives/address/from) - Universal constructor
- [fromHex](/primitives/address/from-hex) - Parse from hex string
- [fromBytes](/primitives/address/from-bytes) - Create from bytes
- [toU256](/primitives/address/conversions#tou256) - Convert to numeric
