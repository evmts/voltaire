---
title: Address.fromBase64
description: Create address from base64-encoded string
---

<Tabs>
<Tab title="Class API">

## `Address.fromBase64(b64: string): Address`

Creates address from base64-encoded string. Decodes the base64 string and validates it contains exactly 20 bytes.

**Parameters:**
- `b64: string` - Base64 string encoding 20 bytes

**Returns:** `Address` - Address instance

**Example:**

```typescript
import { Address } from '@tevm/voltaire'

// Standard base64 address (20 bytes = 27 chars + 1 padding)
const addr = Address.fromBase64("dC01zGY0wFMpJaO4RLyedZXyUeM=")

// Zero address
const zero = Address.fromBase64("AAAAAAAAAAAAAAAAAAAAAAAAAAA=")

// Max address (all 0xFF bytes)
const max = Address.fromBase64("//////////////////////////8=")

// Use standard Address methods
console.log(addr.toHex())
// "0x742d35cc6634c0532925a3b844bc9e7595f251e3"
```

**Throws:**
- `Error` - If base64 string has invalid format or characters
- `InvalidAddressLengthError` - If decoded bytes are not exactly 20 bytes

**Defined in:** [primitives/Address/BrandedAddress/fromBase64.js:15](https://github.com/evmts/voltaire/blob/main/src/primitives/Address/BrandedAddress/fromBase64.js#L15)

</Tab>
<Tab title="Namespace API">

## `fromBase64(b64: string): BrandedAddress`

Creates address from base64-encoded string. Returns a branded Uint8Array for type safety.

**Parameters:**
- `b64: string` - Base64 string encoding 20 bytes

**Returns:** `BrandedAddress` - Branded Uint8Array (20 bytes)

**Example:**

```typescript
import * as Address from '@tevm/voltaire/Address'

const addr = Address.fromBase64("dC01zGY0wFMpJaO4RLyedZXyUeM=")

// Access raw bytes
console.log(addr.length) // 20
console.log(addr[0])     // 0x74
console.log(addr[1])     // 0x2d

// Convert to hex
const hex = Address.toHex(addr)
```

**Defined in:** [primitives/Address/BrandedAddress/fromBase64.js:15](https://github.com/evmts/voltaire/blob/main/src/primitives/Address/BrandedAddress/fromBase64.js#L15)

</Tab>
<Tab title="Effect.ts">

## `Address.fromBytes(value: Uint8Array): Address`

Effect.ts doesn't provide a direct `fromBase64` method. Decode base64 to bytes first, then use `fromBytes`:

**Example:**

```typescript
import { Address } from '@tevm/voltaire/Address/effect'

// Decode base64 to Uint8Array (Node.js)
const b64 = "dC01zGY0wFMpJaO4RLyedZXyUeM="
const bytes = Buffer.from(b64, 'base64')
const addr = Address.fromBytes(bytes)

// Or use browser API
const binary = atob(b64)
const decoded = new Uint8Array(binary.length)
for (let i = 0; i < binary.length; i++) {
  decoded[i] = binary.charCodeAt(i)
}
const addr2 = Address.fromBytes(decoded)

// Access underlying BrandedAddress
const branded = addr.address

// Use Schema methods
const hex = addr.toHex()
const checksummed = addr.toChecksummed()
```

**Schema Integration:**

```typescript
import { Schema } from 'effect'

// Decode base64, validate, create Address
const b64String = "dC01zGY0wFMpJaO4RLyedZXyUeM="
const bytes = Buffer.from(b64String, 'base64')
const addr = Address.fromBytes(bytes)

// Use in Schema-validated structures
class Config extends Schema.Class<Config>("Config")({
  owner: Schema.instanceOf(Address),
  operator: Schema.instanceOf(Address)
}) {}

const config = new Config({
  owner: addr,
  operator: Address.fromBytes(Buffer.from("AAAAAAAAAAAAAAAAAAAAAAAAAAA=", 'base64'))
})
```

**Defined in:** [primitives/Address/effect.ts:60](https://github.com/evmts/voltaire/blob/main/src/primitives/Address/effect.ts#L60)

</Tab>
<Tab title="Zig">

## Manual base64 decoding required

Zig doesn't provide built-in base64 address parsing. Decode base64 to bytes using std.base64, then create Address:

**Example:**

```zig
const std = @import("std");
const Address = @import("primitives").Address;

var gpa = std.heap.GeneralPurposeAllocator(.{}){};
defer _ = gpa.deinit();
const allocator = gpa.allocator();

// Decode base64 string
const b64 = "dC01zGY0wFMpJaO4RLyedZXyUeM=";
const decoder = std.base64.standard.Decoder;

// Calculate decoded size
const decoded_len = try decoder.calcSizeForSlice(b64);

// Allocate buffer
const decoded = try allocator.alloc(u8, decoded_len);
defer allocator.free(decoded);

// Decode
try decoder.decode(decoded, b64);

// Validate length and create address
if (decoded.len != 20) return error.InvalidAddressLength;

var bytes: [20]u8 = undefined;
@memcpy(&bytes, decoded);
const addr = Address{ .bytes = bytes };

// Convert to hex
var hex_buf: [42]u8 = undefined;
const hex = try addr.toHex(&hex_buf);
// hex = "0x742d35cc6634c0532925a3b844bc9e7595f251e3"
```

**Defined in:** [primitives/Address/address.zig:8](https://github.com/evmts/voltaire/blob/main/src/primitives/Address/address.zig#L8)

</Tab>
<Tab title="C API">

## Manual base64 decoding required

C API doesn't provide base64 decoding. Use a base64 library to decode, then create address from bytes:

**Example:**

```c
#include "primitives.h"
#include <string.h>
#include <stdint.h>

// Example using a hypothetical base64 decode function
// You'll need to provide your own base64 decoder
extern int base64_decode(const char* input, uint8_t* output, size_t* output_len);

int create_address_from_base64(const char* b64, PrimitivesAddress* out_address) {
    uint8_t decoded[32]; // Buffer larger than needed
    size_t decoded_len = sizeof(decoded);

    // Decode base64
    if (base64_decode(b64, decoded, &decoded_len) != 0) {
        return -1; // Decode error
    }

    // Validate length
    if (decoded_len != 20) {
        return -2; // Invalid address length
    }

    // Copy to address struct
    memcpy(out_address->bytes, decoded, 20);
    return 0;
}

// Usage
int main(void) {
    PrimitivesAddress addr;
    const char* b64 = "dC01zGY0wFMpJaO4RLyedZXyUeM=";

    if (create_address_from_base64(b64, &addr) == 0) {
        // Convert to hex
        char hex_buf[43];
        primitives_address_to_hex(&addr, hex_buf);
        hex_buf[42] = '\0';
        // hex_buf = "0x742d35cc6634c0532925a3b844bc9e7595f251e3"
    }

    return 0;
}
```

**Type Definition:**

```c
typedef struct {
    uint8_t bytes[20];
} PrimitivesAddress;
```

**Defined in:** [c_api.zig:21](https://github.com/evmts/voltaire/blob/main/src/c_api.zig#L21)

</Tab>
</Tabs>

## Base64 Format

**Valid base64 characters:**
- `A-Z`, `a-z`, `0-9`, `+`, `/`
- Padding: `=` (0-2 padding chars)

**20-byte address encoding:**
- 20 bytes = 160 bits
- 160 bits รท 6 bits/char = 26.67 chars
- Encoded as 27 chars + 1 padding `=`
- Total: 28 characters

**Example valid encodings:**
```
dC01zGY0wFMpJaO4RLyedZXyUeM=  (standard address)
AAAAAAAAAAAAAAAAAAAAAAAAAAA=  (zero address)
//////////////////////////8=  (max address: all 0xFF)
```

## Error Handling

### Invalid Base64 Format

```typescript
import { Address } from '@tevm/voltaire'

// Invalid characters
try {
  Address.fromBase64("invalid@chars!")
} catch (e) {
  console.error(e) // Error: Invalid base64 string
}

// Whitespace not allowed
try {
  Address.fromBase64("dC01 zGY0 wFMp")
} catch (e) {
  console.error(e) // Error: Invalid base64 string
}
```

### Invalid Length

```typescript
// Too short (19 bytes)
const short = Buffer.from(new Uint8Array(19)).toString('base64')
try {
  Address.fromBase64(short)
} catch (e) {
  console.error(e) // InvalidAddressLengthError
}

// Too long (21 bytes)
const long = Buffer.from(new Uint8Array(21)).toString('base64')
try {
  Address.fromBase64(long)
} catch (e) {
  console.error(e) // InvalidAddressLengthError
}
```

## Platform Support

**Node.js:**
- Uses `Buffer.from(b64, 'base64')` for decoding
- Native base64 support, high performance

**Browser:**
- Uses `atob()` for decoding
- Standard Web API, widely supported
- Manual Uint8Array conversion required

**Example cross-platform usage:**

```typescript
import { Address } from '@tevm/voltaire'

// Works in both Node.js and browser
const addr = Address.fromBase64("dC01zGY0wFMpJaO4RLyedZXyUeM=")
console.log(addr.toHex())
```

## Common Use Cases

### Decoding API Response

```typescript
// REST API returns base64-encoded address
const response = await fetch('/api/contract')
const data = await response.json()

const contractAddr = Address.fromBase64(data.address)
console.log(contractAddr.toChecksummed())
```

### Database Storage

```typescript
// Store addresses as base64 (more compact than hex)
const addr = Address.fromHex("0x742d35Cc6634C0532925a3b844Bc9e7595f51e3e")
const base64 = addr.toBase64()

// Later, restore from base64
const restored = Address.fromBase64(base64)
console.log(Address.equals(addr, restored)) // true
```

### Binary Protocol

```typescript
// Receive base64-encoded address from binary protocol
const message = receiveMessage() // Returns { address: "dC01..." }
const addr = Address.fromBase64(message.address)

// Process address
if (addr.isZero()) {
  console.log("Zero address received")
}
```

## Validation Before Decoding

Use try-catch for robust base64 validation:

```typescript
function tryDecodeAddress(b64: string): Address | null {
  try {
    return Address.fromBase64(b64)
  } catch (e) {
    console.error('Invalid base64 address:', e.message)
    return null
  }
}

const addr = tryDecodeAddress(userInput)
if (addr) {
  console.log('Valid address:', addr.toHex())
}
```

## Performance

Base64 decoding is fast but adds overhead vs direct hex:
- **fromHex**: Direct hex parsing (fastest)
- **fromBase64**: Base64 decode + validation
- **fromBytes**: Direct copy (zero overhead)

For performance-critical code, prefer `fromHex` or `fromBytes`.

## Encoding Round-trip

```typescript
import { Address } from '@tevm/voltaire'

// Create address
const original = Address.fromHex("0x742d35Cc6634C0532925a3b844Bc9e7595f51e3e")

// Encode to base64
const b64 = original.toBase64()
// "dC01zGY0wFMpJaO4RLyedZXyUeM="

// Decode back
const decoded = Address.fromBase64(b64)

// Verify round-trip
console.log(Address.equals(original, decoded)) // true
```

## See Also

- [from](/primitives/address/from) - Universal constructor
- [fromHex](/primitives/address/from-hex) - Parse from hex string
- [fromBytes](/primitives/address/from-bytes) - Create from Uint8Array
- [toBase64](/primitives/address/variants#tobase64) - Convert to base64 string
- [Base64 on Wikipedia](https://en.wikipedia.org/wiki/Base64)
