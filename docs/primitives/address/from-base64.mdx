---
title: Address.fromBase64
description: Create address from base64-encoded string
---

<Tabs>

</Tabs>

## Base64 Format

**Valid base64 characters:**
- `A-Z`, `a-z`, `0-9`, `+`, `/`
- Padding: `=` (0-2 padding chars)

**20-byte address encoding:**
- 20 bytes = 160 bits
- 160 bits รท 6 bits/char = 26.67 chars
- Encoded as 27 chars + 1 padding `=`
- Total: 28 characters

**Example valid encodings:**
```
dC01zGY0wFMpJaO4RLyedZXyUeM=  (standard address)
AAAAAAAAAAAAAAAAAAAAAAAAAAA=  (zero address)
//////////////////////////8=  (max address: all 0xFF)
```

## Error Handling

### Invalid Base64 Format

```typescript
import { Address } from '@tevm/voltaire'

// Invalid characters
try {
  Address("invalid@chars!")
} catch (e) {
  console.error(e) // Error: Invalid base64 string
}

// Whitespace not allowed
try {
  Address("dC01 zGY0 wFMp")
} catch (e) {
  console.error(e) // Error: Invalid base64 string
}
```

### Invalid Length

```typescript
// Too short (19 bytes)
const short = Buffer(new Uint8Array(19)).toString('base64')
try {
  Address(short)
} catch (e) {
  console.error(e) // InvalidAddressLengthError
}

// Too long (21 bytes)
const long = Buffer(new Uint8Array(21)).toString('base64')
try {
  Address(long)
} catch (e) {
  console.error(e) // InvalidAddressLengthError
}
```

## Platform Support

**Node.js:**
- Uses `Buffer.from(b64, 'base64')` for decoding
- Native base64 support, high performance

**Browser:**
- Uses `atob()` for decoding
- Standard Web API, widely supported
- Manual Uint8Array conversion required

**Example cross-platform usage:**

```typescript
import { Address } from '@tevm/voltaire'

// Works in both Node.js and browser
const addr = Address("dC01zGY0wFMpJaO4RLyedZXyUeM=")
console.log(addr.toHex())
```

## Common Use Cases

### Decoding API Response

```typescript
// REST API returns base64-encoded address
const response = await fetch('/api/contract')
const data = await response.json()

const contractAddr = Address(data.address)
console.log(contractAddr.toChecksummed())
```

### Database Storage

```typescript
// Store addresses as base64 (more compact than hex)
const addr = Address("0x742d35Cc6634C0532925a3b844Bc9e7595f51e3e")
const base64 = addr.toBase64()

// Later, restore from base64
const restored = Address(base64)
console.log(Address.equals(addr, restored)) // true
```

### Binary Protocol

```typescript
// Receive base64-encoded address from binary protocol
const message = receiveMessage() // Returns { address: "dC01..." }
const addr = Address(message.address)

// Process address
if (addr.isZero()) {
  console.log("Zero address received")
}
```

## Validation Before Decoding

Use try-catch for robust base64 validation:

```typescript
function tryDecodeAddress(b64: string): Address | null {
  try {
    return Address(b64)
  } catch (e) {
    console.error('Invalid base64 address:', e.message)
    return null
  }
}

const addr = tryDecodeAddress(userInput)
if (addr) {
  console.log('Valid address:', addr.toHex())
}
```

## Performance

Base64 decoding is fast but adds overhead vs direct hex:
- **fromHex**: Direct hex parsing (fastest)
- **fromBase64**: Base64 decode + validation
- **fromBytes**: Direct copy (zero overhead)

For performance-critical code, prefer `fromHex` or `fromBytes`.

## Encoding Round-trip

```typescript
import { Address } from '@tevm/voltaire'

// Create address
const original = Address("0x742d35Cc6634C0532925a3b844Bc9e7595f51e3e")

// Encode to base64
const b64 = original.toBase64()
// "dC01zGY0wFMpJaO4RLyedZXyUeM="

// Decode back
const decoded = Address(b64)

// Verify round-trip
console.log(Address.equals(original, decoded)) // true
```

## See Also

- [from](/primitives/address/from) - Universal constructor
- [fromHex](/primitives/address/from-hex) - Parse from hex string
- [fromBytes](/primitives/address/from-bytes) - Create from Uint8Array
- [toBase64](/primitives/address/variants#tobase64) - Convert to base64 string
- [Base64 on Wikipedia](https://en.wikipedia.org/wiki/Base64)
