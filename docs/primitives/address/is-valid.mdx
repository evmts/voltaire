---
title: Address.isValid
description: Validate address string format
---

<Tabs>
<Tab title="Class API">

## `Address.isValid(str: string): boolean`

Check if string is valid address format. Accepts hex with or without `0x` prefix.

**Parameters:**
- `str: string` - String to validate

**Returns:** `boolean` - `true` if valid address format

**Example:**

```typescript
import { Address } from '@tevm/voltaire'

// Valid formats
console.log(Address.isValid("0x742d35Cc6634C0532925a3b844Bc9e7595f251e3")) // true
console.log(Address.isValid("742d35Cc6634C0532925a3b844Bc9e7595f251e3"))   // true (no 0x)
console.log(Address.isValid("0x742d35CC6634C0532925A3B844BC9E7595F251E3")) // true (uppercase)

// Invalid formats
console.log(Address.isValid("0x742d35Cc"))                                 // false (too short)
console.log(Address.isValid("0xGGGG..."))                                  // false (invalid chars)
console.log(Address.isValid(""))                                           // false (empty)
console.log(Address.isValid("not an address"))                             // false
```

**Defined in:** [primitives/Address/BrandedAddress/isValid.js:16](https://github.com/evmts/voltaire/blob/main/src/primitives/Address/BrandedAddress/isValid.js#L16)

</Tab>
<Tab title="Namespace API (Tree-shakeable)">

## `isValid(str: string): boolean`

Check if string is valid address format.

**Parameters:**
- `str: string` - String to validate

**Returns:** `boolean` - `true` if valid

**Example:**

```typescript
import * as Address from '@tevm/voltaire/Address'

if (Address.isValid(input)) {
  const addr = Address.fromHex(input)
  console.log('Valid address:', Address.toHex(addr))
} else {
  console.error('Invalid address format')
}
```

**Defined in:** [primitives/Address/BrandedAddress/isValid.js:16](https://github.com/evmts/voltaire/blob/main/src/primitives/Address/BrandedAddress/isValid.js#L16)

</Tab>
<Tab title="Zig">

## `Address.isValid(str: []const u8): bool`

Validate address string format.

**Parameters:**
- `str: []const u8` - String bytes to validate

**Returns:** `bool` - `true` if valid

**Example:**

```zig
const std = @import("std");
const Address = @import("primitives").Address;

const valid1 = Address.isValid("0x742d35Cc6634C0532925a3b844Bc9e7595f51e3e");
try std.testing.expect(valid1);

const valid2 = Address.isValid("742d35Cc6634C0532925a3b844Bc9e7595f51e3e");
try std.testing.expect(valid2);

const invalid = Address.isValid("0x742d35");
try std.testing.expect(!invalid);
```

**Defined in:** [primitives/Address/address.zig:181](https://github.com/evmts/voltaire/blob/main/src/primitives/Address/address.zig#L181)

</Tab>
<Tab title="Effect.ts Schema">

## Static validation method

Effect.ts provides static validation through the underlying branded implementation:

```typescript
import { Address } from '@tevm/voltaire/effect'
import * as BrandedAddress from '@tevm/voltaire/Address'

// Validate before parsing
if (BrandedAddress.isValid(input)) {
  const addr = Address.fromHex(input)
  console.log('Valid address:', addr.toHex())
} else {
  console.error('Invalid address format')
}
```

**Note:** The `Address` schema class doesn't expose `isValid` as a static method. Use the namespace API (`BrandedAddress.isValid()`) for validation.

### Schema validation

Use Effect.ts Schema for runtime validation:

```typescript
import { Address } from '@tevm/voltaire/effect'
import * as Schema from 'effect/Schema'
import * as Effect from 'effect/Effect'

// Validate and parse with Effect
const parseAddress = (input: unknown) =>
  Effect.gen(function* () {
    const decoded = yield* Schema.decodeUnknown(Address)(input)
    return decoded
  })

// Use in Effect pipeline
const program = parseAddress("0x742d35Cc6634C0532925a3b844Bc9e7595f251e3").pipe(
  Effect.map(addr => addr.toHex()),
  Effect.catchAll(err => Effect.succeed("Invalid address"))
)
```

**Defined in:** [primitives/Address/effect.ts](https://github.com/evmts/voltaire/blob/main/src/primitives/Address/effect.ts)

</Tab>
</Tabs>

## Validation Rules

**With `0x` prefix:**
- Exactly 42 characters total
- First 2 characters: `0x`
- Next 40 characters: valid hex (0-9, a-f, A-F)

**Without `0x` prefix:**
- Exactly 40 characters total
- All characters: valid hex (0-9, a-f, A-F)

**Case insensitive:**
- Accepts lowercase, uppercase, or mixed case
- Does not validate EIP-55 checksum

## Use Cases

### Input Validation

Validate user input before parsing:

```typescript
import { Address } from '@tevm/voltaire'

function parseUserAddress(input: string): Address {
  if (!Address.isValid(input)) {
    throw new Error('Invalid address format')
  }

  return Address.fromHex(input)
}

// Safe to parse
try {
  const addr = parseUserAddress(userInput)
  console.log('Address:', addr.toHex())
} catch (e) {
  console.error('Invalid input:', e.message)
}
```

### Form Validation

Validate addresses in forms:

```typescript
import { Address } from '@tevm/voltaire'

function validateAddressField(value: string): string | null {
  if (!value) {
    return 'Address is required'
  }

  if (!Address.isValid(value)) {
    return 'Invalid address format. Expected 40 hex characters with optional 0x prefix.'
  }

  return null // Valid
}

// React example
function AddressInput() {
  const [value, setValue] = useState('')
  const [error, setError] = useState<string | null>(null)

  const handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const input = e.target.value
    setValue(input)
    setError(validateAddressField(input))
  }

  return (
    <div>
      <input
        type="text"
        value={value}
        onChange={handleChange}
        placeholder="0x..."
      />
      {error && <span className="error">{error}</span>}
    </div>
  )
}
```

### API Input Validation

Validate addresses in API requests:

```typescript
import { Address } from '@tevm/voltaire'

app.post('/transfer', (req, res) => {
  const { to, amount } = req.body

  if (!Address.isValid(to)) {
    return res.status(400).json({
      error: 'Invalid recipient address'
    })
  }

  const recipient = Address.fromHex(to)
  // Process transfer...
})
```

### Defensive Programming

Check before processing:

```typescript
import { Address } from '@tevm/voltaire'

function processAddresses(addresses: string[]) {
  const valid = addresses.filter(Address.isValid)
  const invalid = addresses.filter(addr => !Address.isValid(addr))

  console.log(`Valid: ${valid.length}, Invalid: ${invalid.length}`)

  return valid.map(Address.fromHex)
}
```

## Common Invalid Inputs

```typescript
import { Address } from '@tevm/voltaire'

// Too short
console.log(Address.isValid("0x742d35"))                    // false

// Too long
console.log(Address.isValid("0x742d35Cc6634C0532925a3b844Bc9e7595f251e3XX")) // false

// Invalid characters
console.log(Address.isValid("0xGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGG")) // false
console.log(Address.isValid("0x742d35Cc 6634C0532925a3b844Bc9e7595f251e3")) // false (space)

// Wrong prefix
console.log(Address.isValid("x742d35Cc6634C0532925a3b844Bc9e7595f251e3"))  // false

// Empty
console.log(Address.isValid(""))                            // false
console.log(Address.isValid("0x"))                          // false
```

## Validation Without Checksum

`isValid()` does NOT validate EIP-55 checksums:

```typescript
import { Address } from '@tevm/voltaire'

// Valid format, but wrong checksum
const addr = "0x742d35cc6634c0532925a3b844bc9e7595f51e3e"  // all lowercase
console.log(Address.isValid(addr))          // true (format valid)
console.log(Address.isValidChecksum(addr))  // false (checksum incorrect)

// To validate checksum, use isValidChecksum()
if (Address.isValid(addr) && Address.isValidChecksum(addr)) {
  console.log('Valid address with correct checksum')
}
```

## Performance

**Fast validation:** Checks length and character ranges only.

**No parsing:** Does not allocate or parse hex values.

**Use before parsing:** Validate first to avoid exceptions:

```typescript
import { Address } from '@tevm/voltaire'

// Efficient: validate before parsing
if (Address.isValid(input)) {
  const addr = Address.fromHex(input)
  // Process addr...
}

// Inefficient: use try/catch for validation
try {
  const addr = Address.fromHex(input)
  // Process addr...
} catch (e) {
  // Handle invalid format
}
```

## Type Narrowing

Use as type guard in TypeScript:

```typescript
import { Address } from '@tevm/voltaire'

function processInput(input: string | Address) {
  if (typeof input === 'string') {
    if (!Address.isValid(input)) {
      throw new Error('Invalid address string')
    }
    return Address.fromHex(input)
  }

  return input // Already an Address
}
```

## See Also

- [isValidChecksum](/primitives/address/is-valid-checksum) - Validate EIP-55 checksum
- [fromHex](/primitives/address/from-hex) - Parse address from hex
- [from](/primitives/address/from) - Universal constructor
- [EIP-55: Mixed-case checksum](https://eips.ethereum.org/EIPS/eip-55)
