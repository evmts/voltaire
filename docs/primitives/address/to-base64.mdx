---
title: Address.toBase64
description: Convert 20-byte address to base64-encoded string
---

<Tabs>
<Tab title="Class API">

## `address.toBase64(): string`

Converts address to base64-encoded string. 20 bytes encode to 27 characters plus 1 padding character (28 total).

**Returns:** `string` - Base64-encoded address (28 characters)

**Example:**

```typescript
import { Address } from '@tevm/voltaire'

const addr = Address.fromHex("0x742d35Cc6634C0532925a3b844Bc9e7595f51e3e")
const b64 = addr.toBase64()
console.log(b64)
// "dC01zGY0wFMpJaO4RLyedZXyUeM="

// Zero address
const zero = Address.zero()
console.log(zero.toBase64())
// "AAAAAAAAAAAAAAAAAAAAAAAAAAA="

// Max address (all 0xFF bytes)
const max = Address.fromHex("0xffffffffffffffffffffffffffffffffffffffff")
console.log(max.toBase64())
// "//////////////////////////8="
```

**Round-trip encoding:**

```typescript
// Original address
const original = Address.fromHex("0x742d35Cc6634C0532925a3b844Bc9e7595f51e3e")

// Encode to base64
const b64 = original.toBase64()

// Decode back
const decoded = Address.fromBase64(b64)

// Verify identity
console.log(Address.equals(original, decoded)) // true
```

**Defined in:** Uses `Uint8Array.prototype.toBase64` or polyfill in [primitives/Address/BrandedAddress/polyfills.ts:42](https://github.com/evmts/voltaire/blob/main/src/primitives/Address/BrandedAddress/polyfills.ts#L42)

</Tab>
<Tab title="Namespace API">

## `toBase64(address: BrandedAddress): string`

Converts address to base64-encoded string.

**Parameters:**
- `address: BrandedAddress` - Address to encode

**Returns:** `string` - Base64-encoded address (28 characters)

**Example:**

```typescript
import * as Address from '@tevm/voltaire/Address'

const addr = Address.fromHex("0x742d35Cc6634C0532925a3b844Bc9e7595f51e3e")
const b64 = addr.toBase64()
console.log(b64)
// "dC01zGY0wFMpJaO4RLyedZXyUeM="

// Direct call (namespace API doesn't expose toBase64)
// Use instance method: addr.toBase64()
```

**Note:** Namespace API accesses `toBase64` via instance method on BrandedAddress prototype.

**Defined in:** [primitives/Address/BrandedAddress/polyfills.ts:42](https://github.com/evmts/voltaire/blob/main/src/primitives/Address/BrandedAddress/polyfills.ts#L42)

</Tab>
<Tab title="Effect.ts">

## `address.value.toBase64(): string`

Effect.ts Address wraps BrandedAddress. Access base64 encoding via the underlying Uint8Array method:

**Example:**

```typescript
import { Address } from '@tevm/voltaire/Address/effect'

const addr = Address.fromHex("0x742d35Cc6634C0532925a3b844Bc9e7595f51e3e")

// Access underlying BrandedAddress and encode
const b64 = addr.address.toBase64()
console.log(b64)
// "dC01zGY0wFMpJaO4RLyedZXyUeM="

// Round-trip with fromBytes
const decoded = Address.fromBytes(
  typeof Buffer !== 'undefined'
    ? Buffer.from(b64, 'base64')
    : Uint8Array.from(atob(b64), c => c.charCodeAt(0))
)

console.log(addr.equals(decoded)) // true
```

**Schema Integration:**

```typescript
import { Schema } from 'effect'
import { Address } from '@tevm/voltaire/Address/effect'

// Define schema with base64 encoding
class ApiResponse extends Schema.Class<ApiResponse>("ApiResponse")({
  address: Schema.instanceOf(Address)
}) {}

// Encode response
const response = new ApiResponse({
  address: Address.fromHex("0x742d35Cc6634C0532925a3b844Bc9e7595f51e3e")
})

// Convert to JSON with base64
const json = {
  address: response.address.address.toBase64()
}

// Later, decode from base64
const restored = Address.fromBytes(Buffer.from(json.address, 'base64'))
```

**Defined in:** [primitives/Address/effect.ts:22](https://github.com/evmts/voltaire/blob/main/src/primitives/Address/effect.ts#L22)

</Tab>
<Tab title="Zig">

## Manual base64 encoding

Zig doesn't provide automatic base64 encoding for addresses. Use std.base64 encoder:

**Example:**

```zig
const std = @import("std");
const Address = @import("primitives").Address;

var gpa = std.heap.GeneralPurposeAllocator(.{}){};
defer _ = gpa.deinit();
const allocator = gpa.allocator();

// Create address
const addr = try Address.fromHex("0x742d35Cc6634C0532925a3b844Bc9e7595f51e3e");

// Calculate encoded size
const encoder = std.base64.standard.Encoder;
const encoded_len = encoder.calcSize(addr.bytes.len);

// Allocate buffer
const encoded = try allocator.alloc(u8, encoded_len);
defer allocator.free(encoded);

// Encode to base64
const result = encoder.encode(encoded, &addr.bytes);
// result = "dC01zGY0wFMpJaO4RLyedZXyUeM="

// Verify round-trip
const decoder = std.base64.standard.Decoder;
const decoded_len = try decoder.calcSizeForSlice(result);
const decoded = try allocator.alloc(u8, decoded_len);
defer allocator.free(decoded);
try decoder.decode(decoded, result);

// Validate
try std.testing.expectEqualSlices(u8, &addr.bytes, decoded);
```

**Defined in:** [primitives/Address/address.zig:8](https://github.com/evmts/voltaire/blob/main/src/primitives/Address/address.zig#L8)

</Tab>
<Tab title="C API">

## Manual base64 encoding

C API doesn't provide base64 encoding. Use external base64 library:

**Example:**

```c
#include "primitives.h"
#include <string.h>
#include <stdint.h>

// Example using hypothetical base64 encode function
extern int base64_encode(const uint8_t* input, size_t input_len, char* output);

int address_to_base64(const PrimitivesAddress* addr, char* out_b64, size_t buf_size) {
    // 20 bytes encodes to 28 chars (including padding)
    if (buf_size < 29) { // +1 for null terminator
        return -1;
    }

    // Encode address bytes
    if (base64_encode(addr->bytes, 20, out_b64) != 0) {
        return -2;
    }

    out_b64[28] = '\0';
    return 0;
}

// Usage
int main(void) {
    PrimitivesAddress addr;

    // Parse from hex
    if (primitives_address_from_hex(
        "0x742d35Cc6634C0532925a3b844Bc9e7595f51e3e",
        &addr
    ) == 0) {
        char b64[29];
        if (address_to_base64(&addr, b64, sizeof(b64)) == 0) {
            // b64 = "dC01zGY0wFMpJaO4RLyedZXyUeM="
        }
    }

    return 0;
}
```

**Type Definition:**

```c
typedef struct {
    uint8_t bytes[20];
} PrimitivesAddress;
```

**Defined in:** [c_api.zig:21](https://github.com/evmts/voltaire/blob/main/src/c_api.zig#L21)

</Tab>
</Tabs>

## Base64 Format

**20-byte encoding:**
- 20 bytes = 160 bits
- 160 bits ÷ 6 bits/char = 26.67 chars
- Result: 27 chars + 1 padding `=`
- Total: 28 characters

**Character set:**
- `A-Z`, `a-z`, `0-9`, `+`, `/`
- Padding: `=`

**Example encodings:**
```
0x742d35Cc6634C0532925a3b844Bc9e7595f51e3e → dC01zGY0wFMpJaO4RLyedZXyUeM=
0x0000000000000000000000000000000000000000 → AAAAAAAAAAAAAAAAAAAAAAAAAAA=
0xffffffffffffffffffffffffffffffffffffffff → //////////////////////////8=
```

## Use Cases

### API Responses

Base64 encoding produces more compact JSON vs hex:

```typescript
import { Address } from '@tevm/voltaire'

const addr = Address.fromHex("0x742d35Cc6634C0532925a3b844Bc9e7595f51e3e")

// Hex: 42 chars (with 0x prefix)
const hexJson = { address: addr.toHex() }
// { address: "0x742d35cc6634c0532925a3b844bc9e7595f51e3e" }

// Base64: 28 chars (33% smaller)
const b64Json = { address: addr.toBase64() }
// { address: "dC01zGY0wFMpJaO4RLyedZXyUeM=" }

// Savings: 14 bytes per address
```

### Database Storage

Store addresses as base64 for compact binary storage:

```typescript
import { Address } from '@tevm/voltaire'

// Store multiple addresses
const addresses = [
  Address.fromHex("0x742d35Cc6634C0532925a3b844Bc9e7595f51e3e"),
  Address.fromHex("0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045"),
  Address.fromHex("0x5aAeb6053F3E94C9b9A09f33669435E7Ef1BeAed")
]

// Encode for storage
const encoded = addresses.map(addr => addr.toBase64())
// ["dC01zGY0wFMpJaO4RLyedZXyUeM=", "2NprviaUr53u2eA+U0FdN6qWBEU=", ...]

// Later, restore from storage
const restored = encoded.map(b64 => Address.fromBase64(b64))
```

### Binary Protocols

Use base64 for text-based binary protocols:

```typescript
import { Address } from '@tevm/voltaire'

// Prepare message with base64-encoded address
const message = {
  type: 'transfer',
  from: sender.toBase64(),
  to: recipient.toBase64(),
  amount: '1000000000000000000'
}

// Send as JSON
await sendMessage(JSON.stringify(message))

// Receiver decodes addresses
const decoded = JSON.parse(received)
const fromAddr = Address.fromBase64(decoded.from)
const toAddr = Address.fromBase64(decoded.to)
```

### URL-safe Encoding

Base64 is URL-safe when used with proper encoding:

```typescript
import { Address } from '@tevm/voltaire'

const addr = Address.fromHex("0x742d35Cc6634C0532925a3b844Bc9e7595f51e3e")
const b64 = addr.toBase64()

// Safe in URL query params (no special chars except =)
const url = `https://api.example.com/address?id=${encodeURIComponent(b64)}`
// https://api.example.com/address?id=dC01zGY0wFMpJaO4RLyedZXyUeM%3D
```

## Platform Support

**Node.js:**
- Uses `Buffer.toString('base64')`
- Native implementation, optimal performance
- Automatic padding

**Browser:**
- Uses `btoa()` Web API
- Widely supported (all modern browsers)
- Manual Uint8Array → binary string conversion

**Example cross-platform:**

```typescript
import { Address } from '@tevm/voltaire'

// Works identically in Node.js and browser
const addr = Address.fromHex("0x742d35Cc6634C0532925a3b844Bc9e7595f51e3e")
const b64 = addr.toBase64()
// Same result on all platforms
```

## Performance

Base64 encoding overhead:

| Operation | Time | Notes |
|-----------|------|-------|
| `toHex()` | ~300ns | Direct hex encoding (fastest) |
| `toBase64()` | ~800ns | Base64 encoding (2.6x slower) |
| `toBytes()` | ~50ns | No conversion (zero overhead) |

For performance-critical code, prefer `toHex()` or `toBytes()`.

## Round-trip Examples

### Basic Round-trip

```typescript
import { Address } from '@tevm/voltaire'

const original = Address.fromHex("0x742d35Cc6634C0532925a3b844Bc9e7595f51e3e")
const b64 = original.toBase64()
const decoded = Address.fromBase64(b64)

console.log(Address.equals(original, decoded)) // true
console.log(original.toHex() === decoded.toHex()) // true
```

### Multiple Conversions

```typescript
import { Address } from '@tevm/voltaire'

// Start with number
const addr1 = Address.fromNumber(0x742d35Cc)

// Convert through base64
const b64 = addr1.toBase64()

// Restore and verify
const addr2 = Address.fromBase64(b64)
console.log(addr1.toHex() === addr2.toHex()) // true
```

### Checksum Preservation

```typescript
import { Address } from '@tevm/voltaire'

// Checksummed input
const checksummed = "0x742d35Cc6634C0532925a3b844Bc9e7595f51e3e"
const addr = Address.fromHex(checksummed)

// Base64 doesn't preserve checksum (binary encoding)
const b64 = addr.toBase64()
const restored = Address.fromBase64(b64)

// Re-checksum after restoring
console.log(restored.toChecksummed())
// "0x742d35Cc6634C0532925a3b844Bc9e7595f51e3e"
```

## Comparison: Hex vs Base64

| Format | Size | Characters | URL-safe | Binary |
|--------|------|------------|----------|--------|
| Hex (with 0x) | 42 chars | 0-9, a-f, x | Yes | No |
| Hex (no 0x) | 40 chars | 0-9, a-f | Yes | No |
| Base64 | 28 chars | A-Z, a-z, 0-9, +, /, = | Needs encoding | Yes |

**When to use base64:**
- Compact JSON/API responses (33% smaller)
- Binary protocol encoding
- Database storage (more compact)

**When to use hex:**
- Human-readable addresses
- Ethereum tooling compatibility
- Debugging and logging
- EIP-55 checksumming

## Error Handling

Base64 encoding never fails for valid addresses:

```typescript
import { Address } from '@tevm/voltaire'

// Always succeeds for valid addresses
const addr = Address.fromHex("0x742d35Cc6634C0532925a3b844Bc9e7595f51e3e")
const b64 = addr.toBase64() // Never throws

// Zero address encodes successfully
const zero = Address.zero()
console.log(zero.toBase64())
// "AAAAAAAAAAAAAAAAAAAAAAAAAAA="

// Max address encodes successfully
const max = Address.fromBytes(new Uint8Array(20).fill(0xFF))
console.log(max.toBase64())
// "//////////////////////////8="
```

## See Also

- [fromBase64](/primitives/address/from-base64) - Decode base64 to address
- [toHex](/primitives/address/to-hex) - Convert to hex string
- [toBytes](/primitives/address/to-bytes) - Convert to raw bytes
- [toChecksummed](/primitives/address/to-checksummed) - EIP-55 checksummed hex
- [Base64 on Wikipedia](https://en.wikipedia.org/wiki/Base64)
