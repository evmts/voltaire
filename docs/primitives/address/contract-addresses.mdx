---
title: Contract Address Calculation
description: CREATE and CREATE2 address derivation
---

# Contract Address Calculation

Methods for calculating contract addresses from deployer address and deployment parameters.

## Overview

Ethereum provides two opcodes for deploying contracts:
- **CREATE** - Deterministic based on sender address and nonce
- **CREATE2** - Deterministic based on sender address, salt, and init code hash

Both methods produce deterministic 20-byte addresses derived from keccak256 hashing.

## CREATE Address

### `instance.calculateCreateAddress(nonce)`

Calculate CREATE contract address using sender address and transaction nonce.

**Formula:** `keccak256(rlp([sender, nonce]))[12:32]`

```typescript
const deployerAddr = Address.fromHex("0x742d35Cc6634C0532925a3b844Bc9e7595f51e3e")

// First contract deployed (nonce 0)
const contract1 = deployerAddr.calculateCreateAddress(0n)
console.log(contract1.toHex())

// Second contract (nonce 1)
const contract2 = deployerAddr.calculateCreateAddress(1n)
console.log(contract2.toHex())

// Addresses are different for each nonce
contract1.equals(contract2) // false
```

**Parameters:**
- `nonce: bigint` - Transaction nonce (must be â‰¥ 0)

**Returns:** `Address` - Calculated contract address

**Throws:**
- `InvalidValueError` - If nonce is negative

**Static form:**
```typescript
Address.calculateCreateAddress(deployerAddr, nonce)
```

Defined in: [primitives/Address/BrandedAddress/calculateCreateAddress.js:20](https://github.com/evmts/voltaire/blob/main/src/primitives/Address/BrandedAddress/calculateCreateAddress.js)
Tests: [calculateCreateAddress.test.ts](https://github.com/evmts/voltaire/blob/main/src/primitives/Address/BrandedAddress/calculateCreateAddress.test.ts)

**Note:** Uses keccak256 and RLP encoding internally. When using tree-shakeable imports, including this method adds both keccak256 and RLP to bundle.

## CREATE2 Address

### `instance.calculateCreate2Address(salt, initCode)`

Calculate CREATE2 contract address using sender address, salt, and initialization code.

**Formula:** `keccak256(0xff ++ sender ++ salt ++ keccak256(initCode))[12:32]`

```typescript
const deployerAddr = Address.fromHex("0x742d35Cc6634C0532925a3b844Bc9e7595f51e3e")

// Salt can be bigint or Uint8Array
const salt1 = 42n
const salt2 = new Uint8Array(32)

// Contract initialization code (constructor + bytecode)
const initCode = Bytes.fromHex("0x608060405234801561001057600080fd5b50...")

const contractAddr1 = deployerAddr.calculateCreate2Address(salt1, initCode)
const contractAddr2 = deployerAddr.calculateCreate2Address(salt2, initCode)
```

**Parameters:**
- `salt: bigint | Uint8Array` - 32-byte salt value
  - If `bigint`: Converted to 32-byte big-endian representation
  - If `Uint8Array`: Must be exactly 32 bytes
- `initCode: Uint8Array` - Contract initialization code

**Returns:** `Address` - Calculated contract address

**Throws:**
- `Error` - If Uint8Array salt is not exactly 32 bytes
- `InvalidValueError` - If bigint salt is negative

**Static form:**
```typescript
Address.calculateCreate2Address(deployerAddr, salt, initCode)
```

Defined in: [primitives/Address/BrandedAddress/calculateCreate2Address.js:24](https://github.com/evmts/voltaire/blob/main/src/primitives/Address/BrandedAddress/calculateCreate2Address.js)
Tests: [calculateCreate2Address.test.ts](https://github.com/evmts/voltaire/blob/main/src/primitives/Address/BrandedAddress/calculateCreate2Address.test.ts)

**Note:** Uses keccak256 internally (twice - once for initCode, once for final address). When using tree-shakeable imports, including this method adds keccak256 to bundle.

## CREATE vs CREATE2

| Feature | CREATE | CREATE2 |
|---------|--------|---------|
| **Determinism** | Nonce-based (sequential) | Salt-based (arbitrary) |
| **Dependencies** | Keccak256, RLP encoder | Keccak256 only |
| **Parameters** | `(address, nonce)` | `(address, salt, initCode)` |
| **Use case** | Regular deployments | Deterministic/counterfactual deployments |
| **Predictability** | Requires tracking nonce | Fully deterministic always |
| **Redeployment** | Different address each time | Same address if inputs identical |
| **EIP** | Core | [EIP-1014](https://eips.ethereum.org/EIPS/eip-1014) |

## Tree-Shakeable Usage

Both methods available as tree-shakeable imports:

```typescript
import { calculateCreateAddress, calculateCreate2Address } from '@tevm/voltaire/BrandedAddress'
import type { BrandedAddress } from '@tevm/voltaire/BrandedAddress'

const deployer: BrandedAddress = /* ... */

const createAddr = calculateCreateAddress(deployer, 0n)
const create2Addr = calculateCreate2Address(deployer, salt, initCode)
```

**Tree-shaking consideration:** Both methods include keccak256 in bundle. CREATE also includes RLP encoder.

See [BrandedAddress](/primitives/address/branded-address) for details on tree-shakeable API.

## See Also

- [Address Conversions](/primitives/address/conversions) - Convert addresses to various formats
- [Address Validation](/primitives/address/validation) - Validate addresses and checksums
- [EIP-1014: CREATE2](https://eips.ethereum.org/EIPS/eip-1014) - CREATE2 opcode specification
