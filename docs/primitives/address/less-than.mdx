---
title: Address.lessThan
description: Lexicographic less-than comparison of addresses
---

<Tabs>

<Tab title="WASM">

## WASM Implementation

WASM uses the same TypeScript implementation - comparison happens in JavaScript layer.

**Example:**

```typescript
import { Address } from '@tevm/voltaire/wasm'

const addr1 = Address(1n)
const addr2 = Address(2n)

// Same API as native
console.log(Address.lessThan(addr1, addr2)) // true

// Instance method
console.log(addr1.lessThan(addr2)) // true
```

**Performance note:** Lexicographic comparison is performed byte-by-byte in JavaScript. For large-scale sorting operations (>10k addresses), consider native implementation for better performance.

</Tab>
</Tabs>

## Comparison Semantics

**Lexicographic ordering:** Compares byte-by-byte from left to right.

**Return value:**
- `true`: First address is less than second
- `false`: First address is equal to or greater than second

**Implementation:** Returns `true` when `compare(a, b) < 0`

**Example ordering:**
```typescript
import { Address } from '@tevm/voltaire'

const a1 = Address("0x0000000000000000000000000000000000000001")
const a2 = Address("0x0000000000000000000000000000000000000002")
const a3 = Address("0x1000000000000000000000000000000000000000")

console.log(a1.lessThan(a2)) // true
console.log(a2.lessThan(a3)) // true
console.log(a1.lessThan(a3)) // true
console.log(a3.lessThan(a1)) // false
```

## Use Cases

### Sorting Arrays

Sort addresses in ascending order:

```typescript
import { Address } from '@tevm/voltaire'

const addresses = [
  Address("0xffffffffffffffffffffffffffffffffffffffff"),
  Address("0x0000000000000000000000000000000000000001"),
  Address("0x742d35Cc6634C0532925a3b844Bc9e7595f51e3e"),
]

// Sort using lessThan
addresses.sort((a, b) =>
  a.lessThan(b) ? -1 : b.lessThan(a) ? 1 : 0
)

// More efficient: use compare() directly
addresses.sort((a, b) => a.compare(b))
```

### Range Queries

Filter addresses within a range:

```typescript
import { Address } from '@tevm/voltaire'

function getAddressesInRange(
  addresses: Address[],
  min: Address,
  max: Address
): Address[] {
  return addresses.filter(addr =>
    !addr.lessThan(min) && addr.lessThan(max) || addr.equals(max)
  )
}

const allAddresses = [
  Address(5n),
  Address(15n),
  Address(25n),
]

const inRange = getAddressesInRange(
  allAddresses,
  Address(10n),
  Address(20n)
)
// Returns: [Address(15n)]
```

### Binary Search

Efficient lookup in sorted arrays:

```typescript
import { Address } from '@tevm/voltaire'

function binarySearch(sorted: Address[], target: Address): number {
  let left = 0
  let right = sorted.length - 1

  while (left <= right) {
    const mid = Math.floor((left + right) / 2)
    const midAddr = sorted[mid]

    if (midAddr.equals(target)) return mid
    if (midAddr.lessThan(target)) {
      left = mid + 1
    } else {
      right = mid - 1
    }
  }

  return -1 // Not found
}

const sorted = [
  Address(1n),
  Address(5n),
  Address(10n),
  Address(50n),
]

const index = binarySearch(sorted, Address(10n))
console.log(index) // 2
```

### Ordered Data Structures

Maintain sorted set of addresses:

```typescript
import { Address } from '@tevm/voltaire'

class SortedAddressSet {
  private addresses: Address[] = []

  add(address: Address): void {
    // Find insertion point using binary search
    let left = 0
    let right = this.addresses.length

    while (left < right) {
      const mid = Math.floor((left + right) / 2)
      if (this.addresses[mid].lessThan(address)) {
        left = mid + 1
      } else {
        right = mid
      }
    }

    // Check if already exists
    if (left < this.addresses.length &&
        this.addresses[left].equals(address)) {
      return
    }

    this.addresses.splice(left, 0, address)
  }

  has(address: Address): boolean {
    let left = 0
    let right = this.addresses.length - 1

    while (left <= right) {
      const mid = Math.floor((left + right) / 2)
      const midAddr = this.addresses[mid]

      if (midAddr.equals(address)) return true
      if (midAddr.lessThan(address)) {
        left = mid + 1
      } else {
        right = mid - 1
      }
    }

    return false
  }

  toArray(): Address[] {
    return [...this.addresses]
  }
}
```

### Merkle Tree Construction

Build ordered merkle trees:

```typescript
import { Address } from '@tevm/voltaire'
import { keccak256 } from '@tevm/voltaire/crypto'

function buildMerkleTree(addresses: Address[]): Uint8Array {
  // Sort addresses first for deterministic tree
  const sorted = [...addresses].sort((a, b) =>
    a.lessThan(b) ? -1 : b.lessThan(a) ? 1 : 0
  )

  let level = sorted.map(addr => keccak256(addr))

  while (level.length > 1) {
    const nextLevel: Uint8Array[] = []

    for (let i = 0; i < level.length; i += 2) {
      if (i + 1 < level.length) {
        const combined = Bytes64()
        combined.set(level[i], 0)
        combined.set(level[i + 1], 32)
        nextLevel.push(keccak256(combined))
      } else {
        nextLevel.push(level[i])
      }
    }

    level = nextLevel
  }

  return level[0]
}
```

## Performance

**Time complexity:** O(n) where n = 20 bytes (constant time for addresses)

**Implementation:** Single call to `compare()`, which stops at first differing byte

**Optimization:** For repeated comparisons, `compare()` is more efficient than separate `lessThan` calls:

```typescript
import { Address } from '@tevm/voltaire'

// Less efficient (multiple comparisons)
if (a.lessThan(b)) {
  // handle less
} else if (b.lessThan(a)) {
  // handle greater
} else {
  // handle equal
}

// More efficient (single comparison)
const cmp = a.compare(b)
if (cmp < 0) {
  // handle less
} else if (cmp > 0) {
  // handle greater
} else {
  // handle equal
}
```

## Relation to Other Comparisons

`lessThan` is a convenience method built on `compare()`:

```typescript
import { Address } from '@tevm/voltaire'

const a = Address(10n)
const b = Address(20n)

// These are equivalent
a.lessThan(b)           === (a.compare(b) < 0)
a.greaterThan(b)        === (a.compare(b) > 0)
a.equals(b)             === (a.compare(b) === 0)
!a.lessThan(b) && !a.equals(b) === a.greaterThan(b)
```

## See Also

- [compare](/primitives/address/compare) - Full comparison returning -1, 0, or 1
- [equals](/primitives/address/equals) - Equality comparison
- [greaterThan](/primitives/address/comparisons#greaterthan) - Greater than comparison
