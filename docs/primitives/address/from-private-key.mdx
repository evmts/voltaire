---
title: Address.fromPrivateKey
description: Derive address from secp256k1 private key
---

<Tabs>
<Tab title="Class API">

## `Address.fromPrivateKey(privateKey: Uint8Array): Address`

Derives Ethereum address from secp256k1 private key. First derives public key via elliptic curve multiplication, then computes address from public key coordinates.

**Formula:** `fromPublicKey(derivePublicKey(privateKey))`

**Parameters:**
- `privateKey: Uint8Array` - 32-byte secp256k1 private key

**Returns:** `Address` - Derived address

**Example:**

```typescript
import { Address } from '@tevm/voltaire'

// 32-byte secp256k1 private key
const privateKey = new Uint8Array([
  0x12, 0x34, 0x56, 0x78, 0x90, 0xab, 0xcd, 0xef,
  // ... 24 more bytes
])

const addr = Address.fromPrivateKey(privateKey)
console.log(addr.toHex())

// Works with hex-encoded keys
import * as Hex from '@tevm/voltaire/Hex'
const pkHex = "0x1234567890abcdef..."
const pk = Hex.toBytes(pkHex)
const addr2 = Address.fromPrivateKey(pk)
```

**Throws:**
- `InvalidAddressLengthError` - If private key is not exactly 32 bytes
- `InvalidValueError` - If private key value is invalid (e.g., zero, out of range)

**Defined in:** [primitives/Address/BrandedAddress/fromPrivateKey.js:21](https://github.com/evmts/voltaire/blob/main/src/primitives/Address/BrandedAddress/fromPrivateKey.js#L21)

</Tab>
<Tab title="Namespace API">

## `fromPrivateKey(privateKey: Uint8Array): BrandedAddress`

Derives Ethereum address from secp256k1 private key.

**Parameters:**
- `privateKey: Uint8Array` - 32-byte secp256k1 private key

**Returns:** `BrandedAddress` - Derived address (20 bytes)

**Example:**

```typescript
import * as Address from '@tevm/voltaire/Address'

const privateKey = new Uint8Array(32) // Your private key
const addr = Address.fromPrivateKey(privateKey)
```

**Defined in:** [primitives/Address/BrandedAddress/fromPrivateKey.js:21](https://github.com/evmts/voltaire/blob/main/src/primitives/Address/BrandedAddress/fromPrivateKey.js#L21)

</Tab>
<Tab title="Effect.ts">

## `Address.fromPrivateKey(value: Uint8Array): Address`

Derives Effect.ts Address Schema instance from secp256k1 private key. First derives public key via elliptic curve multiplication, then computes address.

**Parameters:**
- `value: Uint8Array` - 32-byte secp256k1 private key

**Returns:** `Address` - Effect Schema instance wrapping BrandedAddress

**Example:**

```typescript
import { Address } from '@tevm/voltaire/Address/effect'

// From private key
const privateKey = new Uint8Array(32) // Your private key
const addr = Address.fromPrivateKey(privateKey)

// Access underlying BrandedAddress
const branded = addr.address

// Use Schema methods
const hex = addr.toHex()
const checksummed = addr.toChecksummed()
const isZero = addr.isZero()

// Schema validation
import { Schema } from 'effect'
const decoded = Schema.decodeUnknownSync(Address)(addr)
```

**Schema Integration:**

The Effect.ts Address class extends `Schema.Class` and provides full Schema validation:

```typescript
import { Address } from '@tevm/voltaire/Address/effect'
import { Schema } from 'effect'

// Define wallet structure with derived address
class Wallet extends Schema.Class<Wallet>("Wallet")({
  address: Schema.instanceOf(Address),
  label: Schema.String
}) {}

// Derive address from private key with validation
const privateKey = new Uint8Array(32) // Secure random key
const addr = Address.fromPrivateKey(privateKey)

const wallet = new Wallet({
  address: addr,
  label: "Main wallet"
})
```

**Pipeline Usage:**

Combine with Effect pipelines for key derivation workflows:

```typescript
import { Address } from '@tevm/voltaire/Address/effect'
import { Effect, pipe } from 'effect'

// Key derivation pipeline
const deriveWalletAddress = (privateKey: Uint8Array) =>
  pipe(
    Effect.sync(() => Address.fromPrivateKey(privateKey)),
    Effect.map(addr => ({
      address: addr.toChecksummed(),
      isDeployed: !addr.isZero()
    }))
  )
```

**Throws:**
- `InvalidAddressLengthError` - If private key is not exactly 32 bytes
- `InvalidValueError` - If private key value is invalid (e.g., zero, out of range)

**Defined in:** [primitives/Address/effect.ts:84](https://github.com/evmts/voltaire/blob/main/src/primitives/Address/effect.ts#L84)

</Tab>
<Tab title="Zig">

## `Address.fromPrivateKey(allocator: Allocator, privateKey: [32]u8): !Address`

Derive address from secp256k1 private key.

**Parameters:**
- `allocator: Allocator` - Memory allocator for intermediate calculations
- `privateKey: [32]u8` - 32-byte private key

**Returns:** `Address` - Derived address

**Errors:**
- `InvalidPrivateKey` - Private key is invalid (zero or >= curve order)

**Example:**

```zig
const std = @import("std");
const Address = @import("primitives").Address;
const Secp256k1 = @import("crypto").Secp256k1;

var gpa = std.heap.GeneralPurposeAllocator(.{}){};
defer _ = gpa.deinit();
const allocator = gpa.allocator();

// Private key (keep secure!)
const private_key: [32]u8 = // ... your key

// Derive address
const addr = try Address.fromPrivateKey(allocator, private_key);
```

**Defined in:** [primitives/Address/address.zig:85](https://github.com/evmts/voltaire/blob/main/src/primitives/Address/address.zig#L85)

</Tab>
<Tab title="C">

## C FFI

The C API does not currently expose `fromPrivateKey` directly. To derive addresses from private keys in C, use the crypto library's secp256k1 functions to derive the public key first, then use `primitives_address_from_public_key`.

**Example workflow:**

```c
#include "voltaire.h"

// 1. Derive public key from private key (using secp256k1)
uint8_t private_key[32] = { /* your private key */ };
uint8_t public_key[64];  // x, y coordinates

// Use secp256k1_pubkey_create or similar (not shown - requires crypto lib)
// secp256k1_derive_public_key(private_key, public_key);

// 2. Convert public key coordinates to address
// Note: This function may not exist yet in C API
// If not available, compute manually:
// - Hash public key with keccak256
// - Take last 20 bytes for address

// Future API (when available):
// PrimitivesAddress addr;
// int result = primitives_address_from_public_key(public_key, 64, &addr);
```

**Note:** For production use with C, consider:
- Using the crypto library directly for secp256k1 operations
- Computing keccak256 hash of the derived public key
- Extracting the last 20 bytes for the address

**Alternative:** Use Zig or TypeScript APIs for key derivation, then pass addresses to C code as hex strings or byte arrays.

**Defined in:** [src/primitives.h](https://github.com/evmts/voltaire/blob/main/src/primitives.h)

</Tab>
</Tabs>

## Algorithm

The address derivation follows this process:

1. **Derive public key** - Multiply generator point G by private key scalar
2. **Extract coordinates** - Get x and y coordinates from resulting point
3. **Hash public key** - Compute keccak256(x || y)
4. **Extract address** - Take last 20 bytes of hash

**Pseudocode:**
```
publicKey = secp256k1.multiply(G, privateKey)  // 64 bytes (x, y)
hash = keccak256(publicKey)                    // 32 bytes
address = hash[12:32]                          // Last 20 bytes
```

## Private Key Requirements

**Size:** Exactly 32 bytes (256 bits)

**Valid range:** `1` to `n-1` where `n` is the secp256k1 curve order:
```
n = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141
```

**Invalid values:**
- All zeros (0x0000...0000)
- Greater than or equal to curve order

## Security Considerations

<Warning title="Private Key Security">
Never hardcode or log private keys. Store securely and transmit only over encrypted channels. Compromised private keys allow complete control of associated addresses.
</Warning>

**Best practices:**
- Generate from cryptographically secure random source
- Never reuse across different accounts/networks
- Store encrypted at rest
- Use hardware wallets for high-value keys
- Implement key rotation policies

## Complete Example

```typescript
import { Address } from '@tevm/voltaire'
import { randomBytes } from 'crypto' // Node.js

// Generate secure random private key
const privateKey = randomBytes(32)

// Derive address
const addr = Address.fromPrivateKey(privateKey)

console.log('Address:', addr.toChecksummed())
console.log('Private key:', Buffer.from(privateKey).toString('hex'))

// Store private key securely (encrypted)
// Store address publicly (for receiving funds)
```

## Use Cases

### Wallet Generation

Generate new Ethereum accounts:

```typescript
import { Address } from '@tevm/voltaire'

function generateAccount() {
  const privateKey = new Uint8Array(32)
  crypto.getRandomValues(privateKey)

  const address = Address.fromPrivateKey(privateKey)

  return {
    address: address.toChecksummed(),
    privateKey: Buffer.from(privateKey).toString('hex')
  }
}

const account = generateAccount()
```

### Key Import

Import existing private keys:

```typescript
import { Address } from '@tevm/voltaire'
import * as Hex from '@tevm/voltaire/Hex'

function importPrivateKey(keyHex: string) {
  // Remove 0x prefix if present
  const cleanHex = keyHex.startsWith('0x') ? keyHex.slice(2) : keyHex

  if (cleanHex.length !== 64) {
    throw new Error('Private key must be 32 bytes (64 hex chars)')
  }

  const privateKey = Hex.toBytes(`0x${cleanHex}`)
  const address = Address.fromPrivateKey(privateKey)

  return address
}
```

### HD Wallets

Derive addresses from HD wallet private keys:

```typescript
import { Address } from '@tevm/voltaire'

// Assume deriveChildKey generates child keys from master seed
function deriveAddresses(masterSeed: Uint8Array, count: number) {
  const addresses = []

  for (let i = 0; i < count; i++) {
    const childKey = deriveChildKey(masterSeed, i) // BIP32/BIP44
    const address = Address.fromPrivateKey(childKey)
    addresses.push(address.toChecksummed())
  }

  return addresses
}
```

## Performance

**Cryptographic operations:**
- secp256k1 scalar multiplication (public key derivation)
- keccak256 hash function

**Bundle size impact:** When using tree-shakeable imports, including this method adds:
- secp256k1 implementation (~15-20 KB)
- keccak256 implementation (~5-10 KB)

**Execution time:** ~0.5-2ms depending on implementation and hardware.

## Error Handling

```typescript
import { Address } from '@tevm/voltaire'

// Wrong length
try {
  const shortKey = new Uint8Array(16)
  Address.fromPrivateKey(shortKey)
} catch (e) {
  console.error(e) // InvalidAddressLengthError: must be 32 bytes
}

// Invalid value (all zeros)
try {
  const zeroKey = new Uint8Array(32)
  Address.fromPrivateKey(zeroKey)
} catch (e) {
  console.error(e) // InvalidValueError: Invalid private key
}

// Out of range
try {
  const invalidKey = new Uint8Array(32).fill(0xFF)
  Address.fromPrivateKey(invalidKey)
} catch (e) {
  console.error(e) // InvalidValueError: Invalid private key
}
```

## See Also

- [fromPublicKey](/primitives/address/from-public-key) - Derive from public key coordinates
- [from](/primitives/address/from) - Universal constructor
- [Secp256k1](/crypto/secp256k1) - secp256k1 cryptography
- [Keccak256](/crypto/keccak256) - Keccak256 hash function
- [Yellow Paper](https://ethereum.github.io/yellowpaper/paper.pdf) - Section 4.2 (Address derivation)
