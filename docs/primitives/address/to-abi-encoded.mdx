---
title: Address.toAbiEncoded
description: Convert address to 32-byte ABI-encoded format
---

<Tabs>
<Tab title="Class API">

## `Address.toAbiEncoded(): Uint8Array`

Converts an address to 32-byte ABI-encoded format. Prepends 12 zero bytes to the 20-byte address to create a 32-byte word.

**Returns:** `Uint8Array` - 32-byte ABI-encoded address

**Example:**

```typescript
import { Address } from '@tevm/voltaire'

// Create address and encode to ABI format
const addr = Address.fromHex("0x742d35cc6634c0532925a3b844bc9e7595f251e3")
const encoded = addr.toAbiEncoded()

console.log(encoded.length) // 32
console.log(encoded.slice(0, 12)) // Uint8Array(12) [0,0,0,0,0,0,0,0,0,0,0,0]
console.log(encoded.slice(12, 32)) // Original 20-byte address

// Round-trip encoding
const decoded = Address.fromAbiEncoded(encoded)
console.log(addr.equals(decoded)) // true
```

**Defined in:** [primitives/Address/BrandedAddress/toAbiEncoded.js:16](https://github.com/evmts/voltaire/blob/main/src/primitives/Address/BrandedAddress/toAbiEncoded.js#L16)

</Tab>
<Tab title="Namespace API">

## `toAbiEncoded(address: BrandedAddress): Uint8Array`

Converts an address to 32-byte ABI-encoded format with left-padding.

**Parameters:**
- `address: BrandedAddress` - Branded Uint8Array (20 bytes)

**Returns:** `Uint8Array` - 32-byte ABI-encoded address

**Example:**

```typescript
import * as Address from '@tevm/voltaire/Address'

// Encode address to ABI format
const addr = Address.fromHex("0x742d35cc6634c0532925a3b844bc9e7595f251e3")
const encoded = Address.toAbiEncoded(addr)

// Structure: [12 bytes zeros][20 bytes address]
console.log(encoded.length) // 32

// Use in contract calls
const calldata = new Uint8Array(36) // 4-byte selector + 32-byte address
calldata.set([0x70, 0xa0, 0x82, 0x31], 0) // balanceOf selector
calldata.set(encoded, 4) // ABI-encoded address
```

**Defined in:** [primitives/Address/BrandedAddress/toAbiEncoded.js:16](https://github.com/evmts/voltaire/blob/main/src/primitives/Address/BrandedAddress/toAbiEncoded.js#L16)

</Tab>
<Tab title="Effect.ts API">

## `Address.toAbiEncoded(): Uint8Array`

Effect.ts Schema API for encoding addresses to ABI format.

**Returns:** `Uint8Array` - 32-byte ABI-encoded address

**Example:**

```typescript
import { Address } from '@tevm/voltaire/effect'
import { Effect } from 'effect'

// Create and encode address
const addr = Address.fromHex("0x742d35cc6634c0532925a3b844bc9e7595f251e3")
const encoded = addr.toAbiEncoded()

// Use with Effect.ts composition
const program = Effect.gen(function* (_) {
  const addr = Address.fromHex("0x742d35cc6634c0532925a3b844bc9e7595f251e3")
  const encoded = addr.toAbiEncoded()

  // Verify round-trip
  const decoded = Address.fromAbiEncoded(encoded)
  const matches = addr.equals(decoded)
  console.log(matches) // true
})

Effect.runSync(program)
```

**Defined in:** [primitives/Address/effect.ts:143](https://github.com/evmts/voltaire/blob/main/src/primitives/Address/effect.ts#L143)

</Tab>
<Tab title="Zig">

## `Address.toAbiEncoded(address: Address): [32]u8`

Convert address to 32-byte ABI-encoded format with left-padding.

**Parameters:**
- `address: Address` - Address to encode

**Returns:** `[32]u8` - 32-byte ABI-encoded array

**Example:**

```zig
const std = @import("std");
const Address = @import("primitives").Address;

// Create address and encode
const addr = try Address.fromHex("0x742d35cc6634c0532925a3b844bc9e7595f251e3");
const encoded = Address.toAbiEncoded(addr);

// Verify structure
try std.testing.expectEqual(32, encoded.len);

// First 12 bytes are zeros
for (encoded[0..12]) |b| {
  try std.testing.expectEqual(0, b);
}

// Last 20 bytes are address
try std.testing.expectEqualSlices(u8, &addr.bytes, encoded[12..32]);

// Round-trip encoding/decoding
const decoded = try Address.fromAbiEncoded(&encoded);
try std.testing.expect(Address.equals(addr, decoded));
```

**Defined in:** [primitives/Address/address.zig:122](https://github.com/evmts/voltaire/blob/main/src/primitives/Address/address.zig#L122)

</Tab>
<Tab title="C">

## C bindings not available

ABI encoding/decoding functions are not currently exposed in the C API.

<Tip>
Use the TypeScript or Zig APIs for ABI encoding operations. C API support may be added in future releases.
</Tip>

</Tab>
</Tabs>

## ABI Encoding Format

EVM ABI encoding represents addresses as 32-byte words with right-aligned data:

**Structure:**
- Bytes 0-11: Zero padding (12 bytes)
- Bytes 12-31: Address data (20 bytes)

**Example:**

```
Original address:
0x742d35cc6634c0532925a3b844bc9e7595f251e3

32-byte ABI-encoded word:
0x000000000000000000000000742d35cc6634c0532925a3b844bc9e7595f251e3
  └─────── padding ─────┘└────────── address ──────────┘
     12 bytes (zeros)         20 bytes (address)
```

## Usage Patterns

### Encoding for Contract Calls

```typescript
import { Address } from '@tevm/voltaire'
import * as Hex from '@tevm/voltaire/Hex'

// Create contract call data
const addr = Address.fromHex("0x742d35cc6634c0532925a3b844bc9e7595f251e3")
const encoded = addr.toAbiEncoded()

// Function: balanceOf(address) returns (uint256)
const selector = Hex.fromString("0x70a08231") // balanceOf selector
const calldata = new Uint8Array(36)
calldata.set(selector, 0)
calldata.set(encoded, 4)

console.log(Hex.toString(calldata))
// 0x70a08231000000000000000000000000742d35cc6634c0532925a3b844bc9e7595f251e3
```

### Round-trip Encoding

```typescript
import { Address } from '@tevm/voltaire'

// Original address
const original = Address.fromHex("0x742d35cc6634c0532925a3b844bc9e7595f251e3")

// Encode to ABI format (32 bytes)
const encoded = original.toAbiEncoded()
console.log(encoded.length) // 32

// Decode back to address (20 bytes)
const decoded = Address.fromAbiEncoded(encoded)
console.log(original.equals(decoded)) // true
console.log(decoded.toHex())
// 0x742d35cc6634c0532925a3b844bc9e7595f251e3
```

### Multiple Addresses in Array

```typescript
import { Address } from '@tevm/voltaire'

// Create array of addresses
const addresses = [
  Address.fromHex("0x742d35cc6634c0532925a3b844bc9e7595f251e3"),
  Address.fromHex("0x1234567890123456789012345678901234567890"),
  Address.fromHex("0xabcdefabcdefabcdefabcdefabcdefabcdefabcd")
]

// Encode each to ABI format
const encoded = addresses.map(addr => addr.toAbiEncoded())

// Concatenate into single buffer (96 bytes = 3 * 32)
const abiData = new Uint8Array(96)
encoded.forEach((enc, i) => {
  abiData.set(enc, i * 32)
})

console.log(abiData.length) // 96
```

### Contract Return Data Preparation

```typescript
import { Address } from '@tevm/voltaire'

// Prepare return data for contract
const owner = Address.fromHex("0x742d35cc6634c0532925a3b844bc9e7595f251e3")
const returnData = owner.toAbiEncoded()

// Return data is ready for EVM
console.log(returnData.length) // 32 bytes
console.log(returnData.slice(0, 12).every(b => b === 0)) // First 12 bytes are zeros
```

## Implementation Notes

- Creates new 32-byte `Uint8Array` with zero-initialized padding
- Copies 20-byte address to last 20 bytes (offset 12)
- First 12 bytes remain zero (padding)
- Efficient single allocation
- No validation performed (address already validated)

## Performance

```typescript
import { Address } from '@tevm/voltaire'

const addr = Address.fromHex("0x742d35cc6634c0532925a3b844bc9e7595f251e3")

// Fast - single allocation + memcpy
const encoded = addr.toAbiEncoded()

// Overhead: 32-byte allocation + 20-byte copy
// No parsing, validation, or complex logic
```

## Validation

```typescript
import { Address } from '@tevm/voltaire'

// No validation needed - address is already valid
const addr = Address.fromHex("0x742d35cc6634c0532925a3b844bc9e7595f251e3")
const encoded = addr.toAbiEncoded()

// Encoding always succeeds for valid addresses
console.log(encoded.length) // Always 32
```

## See Also

- [fromAbiEncoded](/primitives/address/from-abi-encoded) - Decode address from 32-byte ABI format
- [toHex](/primitives/address/to-hex) - Convert to hex string
- [toBytes](/primitives/address/to-bytes) - Get raw 20-byte representation
- [Solidity ABI Specification](https://docs.soliditylang.org/en/latest/abi-spec.html)
