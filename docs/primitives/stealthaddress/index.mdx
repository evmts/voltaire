---
title: StealthAddress
description: Privacy-preserving stealth address generation (ERC-5564)
icon: eye-slash
---

Non-interactive privacy protocol enabling senders to generate one-time addresses that only recipients can detect and spend from.

<Tip title="ERC Reference">
Implements [ERC-5564](https://eips.ethereum.org/EIPS/eip-5564) stealth address specification for SECP256k1.
</Tip>

## Overview

Stealth addresses protect recipient privacy by generating unique one-time addresses for each transaction. The sender can generate these addresses without interacting with the recipient, and only the recipient can:
- Detect payments to their stealth addresses (using viewing key)
- Spend funds from stealth addresses (using spending key)

**Key Properties:**
- Non-interactive: No communication between sender and recipient required
- Forward secrecy: Past transactions remain private if viewing key compromised
- Unlinkability: Stealth addresses appear unrelated to each other and recipient

## Quick Start

<Tabs>
<Tab title="Recipient: Generate Meta-Address">

```typescript
import * as StealthAddress from '@tevm/voltaire/StealthAddress';
import * as Secp256k1 from '@tevm/voltaire/crypto/Secp256k1';

// Generate key pairs
const spendingPrivKey = crypto.getRandomValues(new Uint8Array(32));
const viewingPrivKey = crypto.getRandomValues(new Uint8Array(32));

// Derive public keys
const spendingPubKey = StealthAddress.compressPublicKey(
  Secp256k1.derivePublicKey(spendingPrivKey)
);
const viewingPubKey = StealthAddress.compressPublicKey(
  Secp256k1.derivePublicKey(viewingPrivKey)
);

// Generate meta-address (publish this)
const metaAddress = StealthAddress.generateMetaAddress(
  spendingPubKey,
  viewingPubKey
);

console.log('Meta-address:', Buffer.from(metaAddress).toString('hex'));
// Share meta-address publicly (66 bytes)
```

</Tab>
<Tab title="Sender: Generate Stealth Address">

```typescript
import * as StealthAddress from '@tevm/voltaire/StealthAddress';

// Get recipient's published meta-address
const metaAddress = recipientMetaAddress; // 66 bytes

// Generate ephemeral key
const ephemeralPrivKey = crypto.getRandomValues(new Uint8Array(32));

// Generate stealth address
const result = StealthAddress.generateStealthAddress(
  metaAddress,
  ephemeralPrivKey
);

console.log('Stealth address:', Buffer.from(result.stealthAddress).toString('hex'));
console.log('Ephemeral pubkey:', Buffer.from(result.ephemeralPublicKey).toString('hex'));
console.log('View tag:', result.viewTag);

// Publish announcement: ephemeralPublicKey + viewTag
// Send funds to stealthAddress
```

</Tab>
<Tab title="Recipient: Check & Spend">

```typescript
import * as StealthAddress from '@tevm/voltaire/StealthAddress';

// Scan announcements from blockchain
const announcements = await fetchStealthAnnouncements();

for (const { ephemeralPubKey, viewTag, stealthAddr } of announcements) {
  // Quick check using view tag (1 byte)
  const expectedViewTag = StealthAddress.computeViewTag(
    viewingPrivKey,
    ephemeralPubKey
  );

  if (viewTag !== expectedViewTag) {
    continue; // Not for us, skip expensive check
  }

  // Full check (more expensive)
  const result = StealthAddress.checkStealthAddress(
    viewingPrivKey,
    ephemeralPubKey,
    viewTag,
    spendingPubKey,
    stealthAddr
  );

  if (result.isForRecipient) {
    // Compute spending key for this stealth address
    const stealthPrivKey = StealthAddress.computeStealthPrivateKey(
      spendingPrivKey,
      result.stealthPrivateKey
    );

    // Can now spend funds from stealthAddr using stealthPrivKey
    console.log('Found payment! Can spend from:', stealthAddr);
  }
}
```

</Tab>
</Tabs>

## How It Works

### 1. Setup (Recipient)

Recipient generates two key pairs:
- **Spending keys**: For spending funds (keep spending private key secret)
- **Viewing keys**: For scanning blockchain (can be delegated to scanner)

Combines compressed public keys into 66-byte meta-address and publishes it.

### 2. Payment (Sender)

Sender uses recipient's meta-address to:
1. Generate ephemeral key pair
2. Perform ECDH with recipient's spending public key
3. Derive stealth address using keccak256
4. Generate 1-byte view tag for efficient scanning
5. Publish ephemeral public key and view tag (announcement)
6. Send payment to stealth address

### 3. Detection (Recipient)

Recipient scans announcements:
1. Check view tag first (cheap 1-byte comparison)
2. If view tag matches, perform full check (ECDH + address derivation)
3. If match confirmed, compute stealth private key for spending

## API Documentation

<CardGroup cols={3}>
  <Card title="generateMetaAddress" icon="key" href="/primitives/stealthaddress/generate-meta-address">
    Create 66-byte meta-address from key pairs
  </Card>
  <Card title="parseMetaAddress" icon="scissors" href="/primitives/stealthaddress/parse-meta-address">
    Extract spending and viewing public keys
  </Card>
  <Card title="generateStealthAddress" icon="shield" href="/primitives/stealthaddress/generate-stealth-address">
    Generate stealth address and announcement
  </Card>
  <Card title="checkStealthAddress" icon="magnifying-glass" href="/primitives/stealthaddress/check-stealth-address">
    Check if stealth address is for recipient
  </Card>
  <Card title="computeStealthPrivateKey" icon="lock" href="/primitives/stealthaddress/compute-stealth-private-key">
    Derive private key for spending
  </Card>
  <Card title="computeViewTag" icon="eye" href="/primitives/stealthaddress/compute-view-tag">
    Generate 1-byte view tag for scanning
  </Card>
</CardGroup>

## View Tags Optimization

View tags reduce scanning cost by ~99%:

```typescript
// Without view tag: Check every announcement (expensive)
for (const announcement of announcements) {
  // Perform full ECDH + derivation (~1000 gas equivalent)
  const result = checkStealthAddress(...);
}

// With view tag: Filter first (cheap)
for (const { viewTag, ...announcement } of announcements) {
  const expected = computeViewTag(viewingPrivKey, ephemeralPubKey);
  if (viewTag !== expected) continue; // Skip 99% of announcements

  // Only check 1% that match view tag
  const result = checkStealthAddress(...);
}
```

## Privacy Considerations

**Forward Secrecy:**
- Viewing key compromise: Past stealth addresses remain private
- Spending key compromise: Catastrophic (all funds at risk)
- Best practice: Use hardware wallet for spending key

**Metadata Leakage:**
- Transaction amounts visible on-chain
- Timing correlation possible
- Consider mixing with other privacy techniques

**Key Management:**
- Spending key: Never expose (offline/hardware wallet)
- Viewing key: Can delegate to scanner service
- Ephemeral keys: Generate fresh for each payment

## Specification References

- [ERC-5564](https://eips.ethereum.org/EIPS/eip-5564) - Stealth Address specification
- [ERC-6538](https://eips.ethereum.org/EIPS/eip-6538) - Stealth Meta-Address Registry
- [Stealth Addresses Research](https://ethereum-magicians.org/t/stealth-addresses-research/12545)

## Related

- [Secp256k1](/crypto/secp256k1) - Elliptic curve operations
- [Keccak256](/crypto/keccak256) - Hash function for derivation
- [Address](/primitives/address) - Ethereum address utilities
