---
title: Abi
description: Application Binary Interface encoding and decoding for Ethereum smart contracts
---

# Abi

Complete Application Binary Interface (ABI) encoding and decoding with type safety for Ethereum smart contracts.

<Tip title="New to ABI encoding?">
Start with [ABI Fundamentals](/primitives/abi/fundamentals) to learn about function selectors, encoding rules, and event structure.
</Tip>

## Overview

[Branded](/primitives/branded-types) array of ABI items (functions, events, errors, constructors). Zero-overhead design supports both tree-shakeable namespace methods and class instances, following the same pattern as [Address](/primitives/address).

## Quick Start

<Tabs>
<Tab title="Class API">
```typescript
import { Abi, Function, Event, AbiError } from '@tevm/voltaire'

// Create ABI items using classes
const transferFn = new Function({
  name: "transfer",
  stateMutability: "nonpayable",
  inputs: [
    { type: "address", name: "to" },
    { type: "uint256", name: "amount" }
  ],
  outputs: [{ type: "bool" }]
})

// Encode function call with instance methods
const calldata = transferFn.encodeParams([
  "0x742d35Cc6634C0532925a3b844Bc9e7595f51e3e",
  1000n
])

// Get function selector
const selector = transferFn.getSelector()  // 4 bytes

// Decode return value
const result = transferFn.decodeResult(returnData)  // [true]

// Create Event instance
const transferEvent = new Event({
  name: "Transfer",
  inputs: [
    { type: "address", name: "from", indexed: true },
    { type: "address", name: "to", indexed: true },
    { type: "uint256", name: "value", indexed: false }
  ]
})

// Decode event log
const decoded = transferEvent.decodeLog(logData, logTopics)
// { from: "0x...", to: "0x...", value: 1000n }

// Create Error instance
const insufficientBalance = new AbiError({
  name: "InsufficientBalance",
  inputs: [
    { type: "uint256", name: "balance" },
    { type: "uint256", name: "required" }
  ]
})

// Encode error
const errorData = insufficientBalance.encodeParams([100n, 1000n])
```
</Tab>
<Tab title="Namespace API (Tree-shakeable)">
```typescript
import { Function, Event, AbiError } from '@tevm/voltaire'

// Define function (plain object)
const transferFn = {
  type: "function",
  name: "transfer",
  stateMutability: "nonpayable",
  inputs: [
    { type: "address", name: "to" },
    { type: "uint256", name: "amount" }
  ],
  outputs: [{ type: "bool" }]
}

// Use namespace methods (tree-shakeable)
const calldata = Function.encodeParams(transferFn, [
  "0x742d35Cc6634C0532925a3b844Bc9e7595f51e3e",
  1000n
])

const selector = Function.getSelector(transferFn)  // 4 bytes
const result = Function.decodeResult(transferFn, returnData)  // [true]

// Event namespace methods
const transferEvent = {
  type: "event",
  name: "Transfer",
  inputs: [
    { type: "address", name: "from", indexed: true },
    { type: "address", name: "to", indexed: true },
    { type: "uint256", name: "value", indexed: false }
  ]
}

const decoded = Event.decodeLog(transferEvent, logData, logTopics)
const topics = Event.encodeTopics(transferEvent, {
  from: "0x742d35Cc6634C0532925a3b844Bc9e7595f51e3e"
})

// Error namespace methods
const insufficientBalance = {
  type: "error",
  name: "InsufficientBalance",
  inputs: [
    { type: "uint256", name: "balance" },
    { type: "uint256", name: "required" }
  ]
}

const errorData = AbiError.encodeParams(insufficientBalance, [100n, 1000n])

// See BrandedAbi for complete functional API
```
</Tab>
</Tabs>

## Types

<Tabs>
<Tab title="Abi">
```typescript
// Main ABI type: array of ABI items
export type Abi = ReadonlyArray<
  Function | Event | BrandedError | Constructor | Fallback | Receive
>

// Example ABI
const erc20Abi: Abi = [
  {
    type: "function",
    name: "transfer",
    stateMutability: "nonpayable",
    inputs: [
      { type: "address", name: "to" },
      { type: "uint256", name: "amount" }
    ],
    outputs: [{ type: "bool" }]
  },
  {
    type: "event",
    name: "Transfer",
    inputs: [
      { type: "address", name: "from", indexed: true },
      { type: "address", name: "to", indexed: true },
      { type: "uint256", name: "value" }
    ]
  }
]
```

Source: [Abi.ts:49-51](https://github.com/evmts/voltaire/blob/main/src/primitives/Abi/Abi.ts#L49-L51)
</Tab>
<Tab title="Parameter">
```typescript
export type Parameter<
  TType extends AbiType = AbiType,
  TName extends string = string,
  TInternalType extends string = string
> = {
  type: TType
  name?: TName
  internalType?: TInternalType
  indexed?: boolean  // For event parameters
  components?: readonly Parameter[]  // For tuples
}

// Type conversion utilities
export type ParametersToPrimitiveTypes<TParams extends readonly Parameter[]>
export type ParametersToObject<TParams extends readonly Parameter[]>
```

Source: [Parameter.ts:9-41](https://github.com/evmts/voltaire/blob/main/src/primitives/Abi/Parameter.ts#L9-L41)
</Tab>
<Tab title="AbiType">
```typescript
// All supported Solidity types
export type AbiType =
  // Unsigned integers
  | "uint" | "uint8" | "uint16" | "uint24" | "uint32" | "uint40"
  | "uint48" | "uint56" | "uint64" | "uint72" | "uint80" | "uint88"
  | "uint96" | "uint104" | "uint112" | "uint120" | "uint128" | "uint136"
  | "uint144" | "uint152" | "uint160" | "uint168" | "uint176" | "uint184"
  | "uint192" | "uint200" | "uint208" | "uint216" | "uint224" | "uint232"
  | "uint240" | "uint248" | "uint256"
  // Signed integers
  | "int" | "int8" | "int16" | "int24" | "int32" | "int40"
  | "int48" | "int56" | "int64" | "int72" | "int80" | "int88"
  | "int96" | "int104" | "int112" | "int120" | "int128" | "int136"
  | "int144" | "int152" | "int160" | "int168" | "int176" | "int184"
  | "int192" | "int200" | "int208" | "int216" | "int224" | "int232"
  | "int240" | "int248" | "int256"
  // Other types
  | "address" | "bool" | "string" | "bytes"
  // Fixed-size bytes
  | "bytes1" | "bytes2" | "bytes3" | "bytes4" | "bytes5" | "bytes6"
  | "bytes7" | "bytes8" | "bytes9" | "bytes10" | "bytes11" | "bytes12"
  | "bytes13" | "bytes14" | "bytes15" | "bytes16" | "bytes17" | "bytes18"
  | "bytes19" | "bytes20" | "bytes21" | "bytes22" | "bytes23" | "bytes24"
  | "bytes25" | "bytes26" | "bytes27" | "bytes28" | "bytes29" | "bytes30"
  | "bytes31" | "bytes32"
  // Tuple and arrays
  | "tuple"
  | `${string}[]`  // Dynamic arrays
  | `${string}[${number}]`  // Fixed arrays
```

Source: [Type.ts:1-107](https://github.com/evmts/voltaire/blob/main/src/primitives/Abi/Type.ts#L1-L107)
</Tab>
<Tab title="Item Types">
```typescript
// Function item
export type Function<
  TName extends string = string,
  TStateMutability extends StateMutability = StateMutability,
  TInputs extends readonly Parameter[] = readonly Parameter[],
  TOutputs extends readonly Parameter[] = readonly Parameter[]
> = {
  type: "function"
  name: TName
  stateMutability: TStateMutability
  inputs: TInputs
  outputs: TOutputs
}

// Event item
export type Event<
  TName extends string = string,
  TInputs extends readonly Parameter[] = readonly Parameter[]
> = {
  type: "event"
  name: TName
  inputs: TInputs
  anonymous?: boolean
}

// Error item
export type BrandedError<
  TName extends string = string,
  TInputs extends readonly Parameter[] = readonly Parameter[]
> = {
  type: "error"
  name: TName
  inputs: TInputs
}

// Constructor item
export type BrandedConstructor<
  TStateMutability extends StateMutability = StateMutability,
  TInputs extends readonly Parameter[] = readonly Parameter[]
> = {
  type: "constructor"
  stateMutability: TStateMutability
  inputs: TInputs
}

// Fallback and Receive
export type Fallback<
  TStateMutability extends StateMutability = StateMutability
> = {
  type: "fallback"
  stateMutability: TStateMutability
}

export type Receive = {
  type: "receive"
  stateMutability: "payable"
}

// State mutability
export type StateMutability = "pure" | "view" | "nonpayable" | "payable"
```
</Tab>
</Tabs>

## API Documentation

<Columns>
  <Card title="Fundamentals" icon="open-book">
    Learn ABI encoding structure, function selectors, and data layout.

    [View fundamentals →](/primitives/abi/fundamentals)
  </Card>

  <Card title="Types" icon="seti:config">
    Complete ABI type system: Abi, Parameter, AbiType, Item types, and type utilities.

    [View types →](/primitives/abi/types)
  </Card>

  <Card title="Function" icon="rocket">
    Function encoding/decoding, selectors, signatures, and result handling.

    [View functions →](/primitives/abi/function)
  </Card>

  <Card title="Event" icon="bell">
    Event log encoding/decoding, topic generation, and event filtering.

    [View events →](/primitives/abi/event)
  </Card>

  <Card title="Error" icon="warning">
    Custom error encoding/decoding with type-safe parameter handling.

    [View errors →](/primitives/abi/error)
  </Card>

  <Card title="Constructor" icon="puzzle">
    Constructor parameter encoding for contract deployment.

    [View constructors →](/primitives/abi/constructor)
  </Card>

  <Card title="Encoding" icon="document">
    Low-level ABI encoding patterns and algorithms.

    [View encoding →](/primitives/abi/encoding)
  </Card>

  <Card title="Decoding" icon="open-book">
    Low-level ABI decoding patterns and algorithms.

    [View decoding →](/primitives/abi/decoding)
  </Card>

  <Card title="BrandedAbi" icon="seti:config">
    Tree-shakeable functional API with data-first patterns.

    [View BrandedAbi →](/primitives/abi/branded-abi)
  </Card>

  <Card title="WASM" icon="rocket">
    WebAssembly-accelerated encoding/decoding implementation.

    [View WASM →](/primitives/abi/wasm)
  </Card>

  <Card title="Usage Patterns" icon="list-format">
    Common patterns: contract calls, log parsing, type inference.

    [View patterns →](/primitives/abi/usage-patterns)
  </Card>
</Columns>

## ABI JSON Format

Contract ABIs are typically JSON arrays describing the contract interface:

```typescript
const abi = [
  {
    "type": "function",
    "name": "transfer",
    "stateMutability": "nonpayable",
    "inputs": [
      { "type": "address", "name": "to" },
      { "type": "uint256", "name": "amount" }
    ],
    "outputs": [{ "type": "bool" }]
  },
  {
    "type": "event",
    "name": "Transfer",
    "inputs": [
      { "type": "address", "name": "from", "indexed": true },
      { "type": "address", "name": "to", "indexed": true },
      { "type": "uint256", "name": "value", "indexed": false }
    ]
  },
  {
    "type": "error",
    "name": "InsufficientBalance",
    "inputs": [
      { "type": "uint256", "name": "balance" },
      { "type": "uint256", "name": "required" }
    ]
  }
]
```

## Error Types

```typescript
import {
  AbiEncodingError,
  AbiDecodingError,
  AbiParameterMismatchError,
  AbiItemNotFoundError,
  AbiInvalidSelectorError
} from '@tevm/primitives/Abi'

try {
  const encoded = encodeParameters(params, values)
} catch (error) {
  if (error instanceof AbiEncodingError) {
    // Invalid encoding (out of range, wrong type, etc.)
  } else if (error instanceof AbiParameterMismatchError) {
    // Parameter count mismatch
  }
}
```

Source: [Errors.ts:1-35](https://github.com/evmts/voltaire/blob/main/src/primitives/Abi/Errors.ts#L1-L35)

## Tree-Shaking

Import only what you need for optimal bundle size:

```typescript
// Import specific namespace
import { Function } from '@tevm/primitives/Abi'

// Or import individual functions
import { encodeParameters, decodeParameters } from '@tevm/primitives/Abi'

// Tree-shakeable functional API
import * as BrandedAbi from '@tevm/primitives/Abi/BrandedAbi'
```

<Tip title="Need maximum bundle size optimization?">
For advanced users who need minimal bundle size and maximum tree-shaking benefits, see the [BrandedAbi functional API](/primitives/abi/branded-abi). The class API is recommended for most use cases.
</Tip>

## Sub-Namespaces

The Abi module is organized into specialized sub-namespaces:

- **Function** - Function encoding/decoding and selectors
- **Event** - Event log encoding/decoding and topics
- **Error** - Custom error encoding/decoding
- **Constructor** - Constructor parameter encoding
- **BrandedAbi** - Functional API with ABI array operations
- **Wasm** - WASM-accelerated implementations

Each namespace provides focused functionality with tree-shakeable exports.

## Related Types

<Columns>
  <Card title="Hash" icon="seti:text">
    Keccak256 hashing used for selectors and signatures.

    [View Hash →](/primitives/hash)
  </Card>

  <Card title="Address" icon="document">
    20-byte Ethereum addresses used in ABI encoding.

    [View Address →](/primitives/address)
  </Card>

  <Card title="Uint" icon="open-book">
    Unsigned integer types used in ABI encoding.

    [View Uint →](/primitives/uint)
  </Card>

  <Card title="Bytes" icon="document">
    Fixed and dynamic byte arrays in ABI encoding.

    [View Bytes →](/primitives/bytes)
  </Card>
</Columns>

## Specification References

- [Solidity ABI Specification](https://docs.soliditylang.org/en/latest/abi-spec.html) - Official ABI encoding specification
- [Contract ABI Specification](https://docs.soliditylang.org/en/latest/abi-spec.html#json) - JSON ABI format
- [EIP-712](https://eips.ethereum.org/EIPS/eip-712) - Typed structured data hashing and signing
