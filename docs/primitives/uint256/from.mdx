---
title: Uint.from
description: Universal constructor for creating Uint256 from bigint, number, or string
---

<Tabs>

</Tabs>

## Input Types

`Uint.from` accepts multiple input types for flexibility:

### BigInt (JavaScript)

```typescript
const max = Uint.from(2n ** 256n - 1n)
const large = Uint.from(115792089237316195423570985008687907853269984665640564039457584007913129639935n)
```

<Warning>
BigInt values must be in range [0, 2^256 - 1]. Negative values and values exceeding maximum will throw.
</Warning>

### Number (JavaScript)

```typescript
const small = Uint.from(255)
const zero = Uint.from(0)

// Throws on invalid
Uint.from(-1)      // Error: negative
Uint.from(3.14)    // Error: not integer
Uint.from(NaN)     // Error: invalid
Uint.from(Infinity) // Error: invalid
```

<Warning>
Numbers must be safe integers. Use bigint for values > Number.MAX_SAFE_INTEGER (2^53 - 1).
</Warning>

### String - Decimal

```typescript
const a = Uint.from("12345")
const b = Uint.from("0")
const c = Uint.from("115792089237316195423570985008687907853269984665640564039457584007913129639935")
```

### String - Hexadecimal

Hex strings with or without `0x` prefix:

```typescript
const a = Uint.from("0xff")
const b = Uint.from("FF")
const c = Uint.from("0x0000000000000000000000000000000000000000000000000000000000000001")

// Case insensitive
Uint.from("0xDEADBEEF")  // Same as 0xdeadbeef
```

## Validation

All inputs validated before construction:

**Range checks:**
```typescript
Uint.from(-1n)          // Error: Value cannot be negative
Uint.from(2n ** 256n)   // Error: Value exceeds 2^256 - 1
```

**Format checks:**
```typescript
Uint.from("invalid")    // Error: Invalid format
Uint.from("0xGG")       // Error: Invalid hex
Uint.from(3.14)         // Error: Must be integer
```

**Type checks:**
```typescript
Uint.from(null)         // Error: Invalid type
Uint.from(undefined)    // Error: Invalid type
Uint.from({})           // Error: Invalid type
```

## Usage Patterns

### Constructor Selection

```typescript
// Known bigint - use from
const a = Uint.from(100n)

// Hex string - use fromHex (more explicit)
const b = Uint.fromHex("0xff")

// User input - use tryFrom (safe)
const userInput = "12345"
const c = Uint.tryFrom(userInput)
if (c === undefined) {
  throw new Error("Invalid uint")
}
```

### Safe Parsing

```typescript
function parseUint(input: unknown): BrandedUint256 | null {
  try {
    if (typeof input === "bigint") {
      return Uint.from(input)
    }
    if (typeof input === "number") {
      return Uint.from(input)
    }
    if (typeof input === "string") {
      return Uint.from(input)
    }
  } catch {
    return null
  }
  return null
}

// Better: use tryFrom
function parseUintSafe(input: bigint | number | string): BrandedUint256 | null {
  return Uint.tryFrom(input) ?? null
}
```

### Type Conversion

```typescript
// From other primitives
import { Address, Hash } from '@tevm/voltaire'

const addr = Address.fromHex("0x742d35Cc6634C0532925a3b844Bc9e7595f51e3e")
const addrAsUint = Uint.fromBytes(addr)  // Address is Uint8Array(20)

const hash = Hash.fromHex("0x1234...")
const hashAsUint = Uint.fromBytes(hash)  // Hash is Uint8Array(32)
```

## Performance

**Zero-copy** for direct Uint8Array construction (fromBytes, fromAbiEncoded).

**Conversion required** for strings (parses and allocates new Uint8Array).

For performance-critical code, prefer passing bigint directly or using fromBytes.

## See Also

- [tryFrom](/primitives/uint256/try-from) - Safe constructor (no throw)
- [fromHex](/primitives/uint256/from-hex) - Parse hex string
- [fromBigInt](/primitives/uint256/from-bigint) - From BigInt
- [fromNumber](/primitives/uint256/from-number) - From number
- [fromBytes](/primitives/uint256/from-bytes) - From byte array
- [fromAbiEncoded](/primitives/uint256/from-abi-encoded) - From ABI bytes
