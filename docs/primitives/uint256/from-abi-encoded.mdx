---
title: Uint.fromAbiEncoded
description: Create Uint256 from ABI-encoded 32-byte value
---

## `Uint.fromAbiEncoded(bytes: Uint8Array): BrandedUint256`

Create Uint256 from ABI-encoded bytes. Requires exactly 32 bytes.

**Parameters:**
- `bytes: Uint8Array` - ABI-encoded bytes (exactly 32 bytes, big-endian)

**Returns:** `BrandedUint256` - Uint256 as branded Uint8Array

**Example:**

```typescript
import { Uint } from '@tevm/voltaire'

// ABI-encoded uint256 (always 32 bytes)
const encoded = new Uint8Array(32)
encoded[31] = 0xff  // Last byte = 255

const value = Uint(encoded)  // 255

// Throws if wrong size
const wrong = new Uint8Array(20)
Uint(wrong)  // Error: must be exactly 32 bytes

const tooLarge = new Uint8Array(33)
Uint(tooLarge)  // Error: must be exactly 32 bytes
```

**Defined in:** [primitives/Uint/BrandedUint256/fromAbiEncoded.ts](https://github.com/evmts/voltaire/blob/main/src/primitives/Uint/BrandedUint256/fromAbiEncoded.ts)

## ABI Encoding Format

Solidity ABI encoding for `uint256`:
- **Always 32 bytes** (256 bits)
- **Big-endian** byte order
- **Left-padded** with zeros for smaller values

```
ABI-Encoded uint256 (32 bytes):
┌──────────────────────────────────────┐
│ [0x00][0x00]...[0x00][value bytes]  │
│  padding zeros    actual value       │
└──────────────────────────────────────┘
```

### Examples

```typescript
// Value: 255 (0xff)
// ABI: [0x00, 0x00, ..., 0x00, 0xff]
const bytes1 = new Uint8Array(32)
bytes1[31] = 0xff
Uint(bytes1)  // 255

// Value: 256 (0x0100)
// ABI: [0x00, 0x00, ..., 0x01, 0x00]
const bytes2 = new Uint8Array(32)
bytes2[30] = 0x01
Uint(bytes2)  // 256

// Value: 0
// ABI: [0x00, 0x00, ..., 0x00, 0x00]
const bytes3 = new Uint8Array(32)
Uint(bytes3)  // 0
```

## Strict Length Requirement

Unlike `fromBytes` (1-32 bytes), `fromAbiEncoded` requires **exactly 32 bytes**:

```typescript
// fromBytes - flexible (1-32 bytes)
Uint(new Uint8Array([0xff]))        // OK
Uint(new Uint8Array(32))            // OK

// fromAbiEncoded - strict (exactly 32 bytes)
Uint(new Uint8Array([0xff]))   // Error: wrong size
Uint(new Uint8Array(32))       // OK
```

### Why Strict?

ABI encoding has fixed-size slots for type safety:

```solidity
// Solidity ABI always encodes uint256 as 32 bytes
function example(uint256 x) public { }

// Call data:
// 0x + function_selector (4 bytes) + uint256 (32 bytes)
```

## Decoding ABI Data

### Function Return Values

```typescript
// Decode uint256 return value
const returnData = "0x000000000000000000000000000000000000000000000000000000000000007b"
const bytes = Hex.toBytes(returnData)
const value = Uint(bytes)  // 123
```

### Event Log Data

```typescript
// Decode uint256 from event log
import { EventLog } from '@tevm/voltaire'

const log = EventLog({
  topics: [...],
  data: "0x000000000000000000000000000000000000000000000000000000000000007b"
})

const dataBytes = Hex.toBytes(log.data)
const amount = Uint(dataBytes)  // 123
```

### Multiple uint256 Values

```typescript
// ABI-encoded array of uint256 values
const encoded = "0x" +
  "000000000000000000000000000000000000000000000000000000000000007b" +  // 123
  "00000000000000000000000000000000000000000000000000000000000000ff"    // 255

const bytes = Hex.toBytes(encoded)

// Extract first uint256 (bytes 0-31)
const first = Uint(bytes.slice(0, 32))  // 123

// Extract second uint256 (bytes 32-63)
const second = Uint(bytes.slice(32, 64))  // 255
```

## Usage Patterns

### ABI Decoder Helper

```typescript
class AbiDecoder {
  private offset = 0

  constructor(private data: Uint8Array) {}

  readUint256(): BrandedUint256 {
    const bytes = this.data.slice(this.offset, this.offset + 32)
    if (bytes.length !== 32) {
      throw new Error("Insufficient data for uint256")
    }
    this.offset += 32
    return Uint(bytes)
  }
}

// Usage
const data = Hex.toBytes("0x...")
const decoder = new AbiDecoder(data)
const value1 = decoder.readUint256()
const value2 = decoder.readUint256()
```

### Contract Interaction

```typescript
// Decode contract call result
async function getBalance(address: string): Promise<BrandedUint256> {
  const result = await eth_call({
    to: contractAddress,
    data: encodeCall("balanceOf(address)", [address])
  })

  const bytes = Hex.toBytes(result)
  return Uint(bytes)
}
```

### Type-Safe Validation

```typescript
function decodeUint256Safe(bytes: Uint8Array): BrandedUint256 | null {
  if (bytes.length !== 32) {
    return null  // Wrong size
  }
  return Uint(bytes)
}
```

## Performance

`fromAbiEncoded` is **zero-copy** - the input bytes are used directly as internal storage (no allocation needed).

For decoding large batches of uint256 values, this is the most efficient method.

## See Also

- [toAbiEncoded](/primitives/uint256/to-abi-encoded) - Convert to ABI encoding
- [fromBytes](/primitives/uint256/from-bytes) - From variable-length bytes (1-32)
- [Abi primitive](/primitives/abi) - ABI encoding utilities
