---
title: Uint.fromBytes
description: Create Uint256 from byte array in big-endian format
---

<Tabs>

</Tabs>

## Big-Endian Byte Order

Uint256 uses **big-endian** (network byte order): most significant byte first.

```
Big-Endian Layout (32 bytes):
┌─────────────────────────────────────┐
│ [0] [1] [2] ... [30] [31]          │
│ MSB              ...         LSB    │
│ Most Significant   Least Significant│
└─────────────────────────────────────┘
```

### Examples

```typescript
// Single byte: 255
const a = Uint(new Uint8Array([0xff]))
// Value: 0x000...00ff = 255

// Two bytes: 256
const b = Uint(new Uint8Array([0x01, 0x00]))
// Value: 0x000...0100 = 256

// Four bytes: 255
const c = Uint(new Uint8Array([0x00, 0x00, 0x00, 0xff]))
// Value: 0x000...00ff = 255

// Four bytes: 16909060 (0x01020304)
const d = Uint(new Uint8Array([0x01, 0x02, 0x03, 0x04]))
// Value: 0x000...01020304
```

## Length Handling

### Variable Length (1-32 bytes)

```typescript
// 1 byte
Uint(new Uint8Array([0xff]))  // OK

// 2 bytes
Uint(new Uint8Array([0x01, 0x00]))  // OK

// 20 bytes (Address size)
Uint(new Uint8Array(20))  // OK

// 32 bytes (Hash size)
Uint(new Uint8Array(32))  // OK

// 33 bytes - too large
Uint(new Uint8Array(33))  // Error: exceeds 32 bytes
```

### Leading Zeros

Input is zero-padded on the left to 32 bytes internally:

```typescript
// Input: [0xff] (1 byte)
// Internal: [0x00, 0x00, ..., 0x00, 0xff] (32 bytes)

const a = Uint(new Uint8Array([0xff]))
console.log(a.length)  // 32
```

## Converting from Primitives

### From Address (20 bytes)

```typescript
import { Address } from '@tevm/voltaire'

const addr = Address("0x742d35Cc6634C0532925a3b844Bc9e7595f51e3e")
const addrAsUint = Uint(addr)
// Address is Uint8Array(20), converts to Uint256
```

### From Hash (32 bytes)

```typescript
import { Hash } from '@tevm/voltaire'

const hash = Hash("0x1234...")
const hashAsUint = Uint(hash)
// Hash is Uint8Array(32), converts to Uint256
```

### From Bytecode

```typescript
import { Bytecode } from '@tevm/voltaire'

// Short bytecode (≤32 bytes)
const code = Bytecode("0x6001")
const codeAsUint = Uint(code)  // OK if ≤32 bytes

// Long bytecode (>32 bytes) throws
const longCode = Bytecode("0x" + "60".repeat(100))
Uint(longCode)  // Error: exceeds 32 bytes
```

## Zero-Copy Performance

`fromBytes` is **zero-copy** when possible:

```typescript
// Creates new internal 32-byte array
const bytes = new Uint8Array([0xff])
const uint = Uint(bytes)

// No allocation if already 32 bytes
const bytes32 = new Uint8Array(32)
bytes32[31] = 0xff
const uint2 = Uint(bytes32)  // Efficient
```

## Usage Patterns

### Buffer Conversion

```typescript
// Node.js Buffer to Uint
const buffer = Buffer([0x01, 0x02, 0x03, 0x04])
const uint = Uint(new Uint8Array(buffer))
```

### Slice of Larger Array

```typescript
// Extract 32 bytes from larger array
const data = new Uint8Array(100)
const slice = data.slice(0, 32)
const uint = Uint(slice)
```

### Reading Binary Data

```typescript
async function readUintFromFile(file: File, offset: number): Promise<BrandedUint256> {
  const buffer = await file.arrayBuffer()
  const bytes = new Uint8Array(buffer, offset, 32)
  return Uint(bytes)
}
```

## See Also

- [toBytes](/primitives/uint256/to-bytes) - Convert to byte array
- [fromAbiEncoded](/primitives/uint256/from-abi-encoded) - From ABI-encoded (strict 32 bytes)
- [fromHex](/primitives/uint256/from-hex) - From hex string
