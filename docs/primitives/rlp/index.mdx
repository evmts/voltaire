---
title: Rlp
description: Recursive Length Prefix encoding for Ethereum data structures
---

<Tip>
New to RLP? Start with [Fundamentals](/primitives/rlp/fundamentals) for guided examples and encoding rules.
</Tip>

## Type Definition

[Branded](/concepts/branded-types) data structure for RLP-encoded data following the [data-first pattern](/concepts/data-first).

```typescript
export type BrandedRlp =
  | { type: "bytes"; value: Uint8Array }
  | { type: "list"; value: BrandedRlp[] };
```

RLP provides deterministic serialization for transactions, blocks, state tries, and network protocols. It encodes only structure (not types), making it space-efficient and fast.

## Quick Reference

<Tabs>
<Tab title="Namespace API">

```typescript
import * as Rlp from '@tevm/voltaire/Rlp';

// Encode bytes
const encoded = Rlp.encode(new Uint8Array([1, 2, 3]));

// Decode RLP data
const decoded = Rlp.decode(encoded);

// Validate encoding
Rlp.validate(encoded);
```

</Tab>
<Tab title="Function API">

```typescript
import { Rlp } from '@tevm/voltaire';

// Encode bytes
const encoded = Rlp.encode(new Uint8Array([1, 2, 3]));

// Decode RLP data
const decoded = Rlp.decode(encoded);

// Validate encoding
Rlp.validate(encoded);
```

</Tab>
</Tabs>

## API Methods

<Tabs>
<Tab title="Namespace API">

**Constructors:**
- `from(value)` - Create RLP data structure from bytes or nested arrays

**Encoding:**
- `encode(data)` - Universal encoder (bytes, lists, nested structures)
- `encodeBytes(bytes)` - Encode byte string
- `encodeList(items)` - Encode list of items
- `encodeArray(items, schema)` - Encode array with schema
- `encodeObject(obj, schema)` - Encode object with schema
- `encodeVariadic(...items)` - Encode variadic arguments
- `encodeBatch(items)` - Batch encode multiple items

**Decoding:**
- `decode(bytes, stream?)` - Decode RLP bytes to data structure
- `decodeArray(bytes, schema)` - Decode to array with schema
- `decodeObject(bytes, schema)` - Decode to object with schema
- `decodeBatch(bytes)` - Batch decode multiple items

**Validation:**
- `validate(bytes)` - Validate RLP encoding

**Utilities:**
- `getEncodedLength(data)` - Calculate encoded byte length
- `getLength(bytes, offset)` - Parse length from encoded bytes
- `flatten(data)` - Flatten nested structure to byte arrays
- `equals(a, b)` - Compare RLP data structures
- `toRaw(data)` - Convert to raw nested arrays

**Type Guards:**
- `isData(value)` - Check if value is RLP data
- `isBytesData(value)` - Check if value is bytes data
- `isListData(value)` - Check if value is list data
- `isList(bytes)` - Check if encoded bytes represent list
- `isString(bytes)` - Check if encoded bytes represent string

**Serialization:**
- `toJSON(data)` - Convert to JSON-serializable format
- `fromJSON(json)` - Restore from JSON

</Tab>
<Tab title="Function API">

**Constructors:**
- `Rlp.from(value)` - Create RLP data structure from bytes or nested arrays

**Encoding:**
- `Rlp.encode(data)` - Universal encoder (bytes, lists, nested structures)
- `Rlp.encodeBytes(bytes)` - Encode byte string
- `Rlp.encodeList(items)` - Encode list of items
- `Rlp.encodeArray(items, schema)` - Encode array with schema
- `Rlp.encodeObject(obj, schema)` - Encode object with schema
- `Rlp.encodeVariadic(...items)` - Encode variadic arguments
- `Rlp.encodeBatch(items)` - Batch encode multiple items

**Decoding:**
- `Rlp.decode(bytes, stream?)` - Decode RLP bytes to data structure
- `Rlp.decodeArray(bytes, schema)` - Decode to array with schema
- `Rlp.decodeObject(bytes, schema)` - Decode to object with schema
- `Rlp.decodeBatch(bytes)` - Batch decode multiple items

**Validation:**
- `Rlp.validate(bytes)` - Validate RLP encoding

**Utilities:**
- `Rlp.getEncodedLength(data)` - Calculate encoded byte length
- `Rlp.getLength(bytes, offset)` - Parse length from encoded bytes
- `Rlp.flatten(data)` - Flatten nested structure to byte arrays
- `Rlp.equals(a, b)` - Compare RLP data structures
- `Rlp.toRaw(data)` - Convert to raw nested arrays

**Type Guards:**
- `Rlp.isData(value)` - Check if value is RLP data
- `Rlp.isBytesData(value)` - Check if value is bytes data
- `Rlp.isListData(value)` - Check if value is list data
- `Rlp.isList(bytes)` - Check if encoded bytes represent list
- `Rlp.isString(bytes)` - Check if encoded bytes represent string

**Serialization:**
- `Rlp.toJSON(data)` - Convert to JSON-serializable format
- `Rlp.fromJSON(json)` - Restore from JSON

</Tab>
</Tabs>

## Types

<Tabs>
<Tab title="BrandedRlp">

```typescript
export type BrandedRlp =
  | { type: "bytes"; value: Uint8Array }
  | { type: "list"; value: BrandedRlp[] };
```

Main branded type. Union of bytes data (leaf nodes) and list data (nested arrays).

**BytesData:** Leaf node containing raw bytes
```typescript
{ type: "bytes", value: Uint8Array }
```

**ListData:** Nested array of RLP data
```typescript
{ type: "list", value: BrandedRlp[] }
```

</Tab>
<Tab title="Encodable">

```typescript
type Encodable =
  | Uint8Array
  | BrandedRlp
  | Array<Uint8Array | BrandedRlp | any>;
```

Input type for encoding methods. Accepts raw bytes, RLP data structures, or nested arrays.

See [encode](./encode) for details.

</Tab>
<Tab title="Decoded">

```typescript
type Decoded = {
  data: BrandedRlp;
  remainder: Uint8Array;
};
```

Return type for decode operations. Contains decoded RLP data and any remaining bytes (for stream decoding).

</Tab>
</Tabs>

## Related

- [Fundamentals](/primitives/rlp/fundamentals) - Learn RLP encoding and decoding
- [Transaction](/primitives/transaction) - Uses RLP for serialization
- [Hash](/primitives/hash) - Keccak256 hashing for RLP data
- [Hex](/primitives/hex) - Hex string encoding

## Specification

- [Ethereum Yellow Paper](https://ethereum.github.io/yellowpaper/paper.pdf) - Formal RLP specification (Appendix B)
- [Ethereum Wiki - RLP](https://ethereum.org/en/developers/docs/data-structures-and-encoding/rlp/) - RLP encoding guide
- [EIP-2718](https://eips.ethereum.org/EIPS/eip-2718) - Typed transaction envelope using RLP
