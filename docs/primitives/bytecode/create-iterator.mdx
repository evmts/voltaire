---
title: Bytecode.createIterator
description: Create stateful iterator for manual control over bytecode traversal
icon: arrows-rotate
---

<Tabs>
<Tab title="Class API">

## `bytecode.createIterator(): BytecodeIterator`

Create stateful iterator with manual control for advanced bytecode traversal patterns.

Returns `BytecodeIterator` object with `next()`, `peek()`, and position tracking for fine-grained control.

**Returns:** `BytecodeIterator` - Stateful iterator instance

**Example:**

```typescript
import { Bytecode } from '@tevm/voltaire';

const code = Bytecode.fromHex("0x6001600201");
const iter = code.createIterator();

// Manual iteration with next()
let result = iter.next();
while (!result.done) {
  const inst = result.value;
  console.log(`PC ${inst.pc}: ${inst.opcode}`);
  result = iter.next();
}
```

**Defined in:** [BrandedBytecode/createIterator.js](https://github.com/evmts/voltaire/blob/main/src/primitives/Bytecode/BrandedBytecode/createIterator.js)

</Tab>
<Tab title="Namespace API">

## `createIterator(code: BrandedBytecode): BytecodeIterator`

Create stateful iterator with manual control for advanced bytecode traversal patterns.

**Parameters:**
- `code: BrandedBytecode` - Bytecode to iterate through

**Returns:** `BytecodeIterator` - Stateful iterator instance

**Example:**

```typescript
import * as Bytecode from '@tevm/voltaire/Bytecode';

const code = Bytecode.fromHex("0x6001600201");
const iter = Bytecode.createIterator(code);

while (true) {
  const result = iter.next();
  if (result.done) break;
  console.log(result.value);
}
```

**Tree-shakeable import:**

```typescript
import { createIterator } from '@tevm/voltaire/BrandedBytecode';

const iter = createIterator(code);
```

**Defined in:** [BrandedBytecode/createIterator.js](https://github.com/evmts/voltaire/blob/main/src/primitives/Bytecode/BrandedBytecode/createIterator.js)

</Tab>
</Tabs>

## BytecodeIterator Interface

```typescript
interface BytecodeIterator {
  /** Get next instruction (advances position) */
  next(): IteratorResult<Instruction>

  /** Look ahead without advancing position */
  peek(): Instruction | null

  /** Skip n bytes forward */
  skip(n: number): void

  /** Current program counter position */
  readonly pc: number

  /** Check if at end of bytecode */
  readonly done: boolean

  /** Make iterator iterable (for-of compatible) */
  [Symbol.iterator](): Iterator<Instruction>
}
```

## Methods

### next()

Advance iterator and return next instruction.

```typescript
next(): IteratorResult<Instruction>
```

Returns:
- `{ done: false, value: Instruction }` - Next instruction
- `{ done: true, value: undefined }` - End of bytecode

**Example:**

```typescript
const iter = code.createIterator();

const first = iter.next();
if (!first.done) {
  console.log(first.value); // { pc: 0, opcode: 'PUSH1', ... }
}

const second = iter.next();
if (!second.done) {
  console.log(second.value); // Next instruction
}
```

### peek()

Look ahead at next instruction without advancing position.

```typescript
peek(): Instruction | null
```

Returns:
- `Instruction` - Next instruction (position unchanged)
- `null` - At end of bytecode

**Example:**

```typescript
const iter = code.createIterator();

const next = iter.peek();
if (next) {
  console.log(`Next: ${next.opcode}`);
  // Position NOT advanced
  console.log(iter.pc); // Still at 0
}

iter.next(); // Now advance
console.log(iter.pc); // Position moved forward
```

### skip()

Skip forward n bytes (useful for manual PUSH handling).

```typescript
skip(n: number): void
```

**Parameters:**
- `n: number` - Number of bytes to skip

**Example:**

```typescript
const iter = code.createIterator();

// Skip past PUSH immediate data manually
const inst = iter.next().value;
if (inst.opcode >= 0x60 && inst.opcode <= 0x7F) {
  const pushSize = inst.opcode - 0x5F;
  iter.skip(pushSize); // Skip immediate data bytes
}
```

<Warning>
Manual `skip()` can break iterator state if used incorrectly. Generally unnecessary since `next()` automatically handles PUSH data. Use only for advanced custom parsing.
</Warning>

### pc (property)

Current program counter (byte offset in bytecode).

```typescript
readonly pc: number
```

**Example:**

```typescript
const iter = code.createIterator();
console.log(iter.pc); // 0

iter.next();
console.log(iter.pc); // 2 (if first instruction was PUSH1)
```

### done (property)

Check if iterator has reached end of bytecode.

```typescript
readonly done: boolean
```

**Example:**

```typescript
const iter = code.createIterator();

while (!iter.done) {
  const inst = iter.next().value;
  console.log(inst);
}
```

## Usage Patterns

### Standard Iteration

```typescript
const iter = code.createIterator();

while (!iter.done) {
  const result = iter.next();
  if (!result.done) {
    console.log(result.value);
  }
}
```

### For-of Loop

Iterator implements `Symbol.iterator` for compatibility:

```typescript
const iter = code.createIterator();

for (const inst of iter) {
  console.log(inst);
}
```

### Lookahead Parsing

```typescript
const iter = code.createIterator();

while (!iter.done) {
  const current = iter.next().value;
  const next = iter.peek();

  if (current.opcode === 'PUSH1' && next?.opcode === 'JUMP') {
    console.log(`Static jump to ${current.value}`);
  }
}
```

### Conditional Iteration

```typescript
const iter = code.createIterator();

while (!iter.done) {
  const inst = iter.next().value;

  if (inst.type === 'jumpdest') {
    // Found basic block boundary
    const blockStart = inst.pc;

    // Continue until next JUMPDEST or terminator
    while (!iter.done) {
      const next = iter.peek();
      if (next?.type === 'jumpdest' || isTerminator(next?.opcode)) {
        break;
      }
      iter.next();
    }
  }
}
```

### Backtracking with Position Save

```typescript
const iter = code.createIterator();

// Save position
const savedPc = iter.pc;

// Scan ahead
while (!iter.done && iter.pc < savedPc + 100) {
  iter.next();
}

// Backtrack (create new iterator from saved position)
const backtrackIter = code.createIterator();
while (backtrackIter.pc < savedPc) {
  backtrackIter.next();
}
```

<Note>
Iterator is forward-only. To backtrack, create new iterator and advance to desired position. For random access, use `parseInstructions()` instead.
</Note>

### Block Parsing

```typescript
function parseBlock(iter: BytecodeIterator): Instruction[] {
  const block: Instruction[] = [];

  while (!iter.done) {
    const inst = iter.next().value;
    block.push(inst);

    // Block ends at terminator or next JUMPDEST
    if (isTerminator(inst.opcode)) break;

    const next = iter.peek();
    if (next?.type === 'jumpdest') break;
  }

  return block;
}

const iter = code.createIterator();
const blocks: Instruction[][] = [];

while (!iter.done) {
  blocks.push(parseBlock(iter));
}
```

### Fusion Detection

```typescript
const iter = code.createIterator();

while (!iter.done) {
  const inst = iter.next().value;

  if (inst.type === 'push') {
    const next = iter.peek();

    // Detect PUSH + ADD pattern
    if (next?.opcode === 'ADD') {
      console.log(`Fusion opportunity at PC ${inst.pc}: PUSH_ADD`);
      iter.next(); // Consume ADD
    }
  }
}
```

## Performance

### Memory Efficiency

Iterator maintains minimal state:
- Current position (4-8 bytes)
- Reference to bytecode (8 bytes)
- Total: ~16 bytes vs ~100KB+ for materialized instruction array

### Lazy Evaluation

```typescript
// ✅ Efficient - only processes until found
const iter = code.createIterator();
while (!iter.done) {
  const inst = iter.next().value;
  if (inst.opcode === 'SELFDESTRUCT') {
    console.log('Found SELFDESTRUCT');
    break; // Stop processing
  }
}

// ❌ Inefficient - parses entire bytecode
const instructions = code.parseInstructions();
const hasSelfdestruct = instructions.some(inst => inst.opcode === 'SELFDESTRUCT');
```

## Comparison with scan()

| Feature | createIterator() | scan() |
|---------|-----------------|--------|
| Style | Manual control | Generator/for-of |
| Lookahead | `peek()` method | Not available |
| Skip ahead | `skip()` method | Not available |
| Position tracking | `pc` property | In instruction object |
| Memory | ~16 bytes | ~16 bytes |
| Ease of use | Advanced | Simple |

**Use `createIterator()` when:**
- Need lookahead (peek next instruction)
- Building custom parsers
- Complex state machines
- Manual position tracking

**Use `scan()` when:**
- Simple iteration
- Standard for-of loops
- No lookahead needed

```typescript
// Simple case - use scan()
for (const inst of code.scan()) {
  console.log(inst);
}

// Complex case - use createIterator()
const iter = code.createIterator();
while (!iter.done) {
  const current = iter.next().value;
  const next = iter.peek();
  // Lookahead logic
}
```

## Error Handling

```typescript
const iter = code.createIterator();

try {
  while (!iter.done) {
    const result = iter.next();

    if (result.done) break;

    const inst = result.value;
    // Process instruction
  }
} catch (error) {
  if (error instanceof BytecodeError) {
    console.error(`Error at PC ${iter.pc}: ${error.message}`);
  }
}
```

## TypeScript Integration

Iterator fully implements TypeScript's `Iterator` protocol:

```typescript
interface Iterator<T> {
  next(): IteratorResult<T>
  return?(value?: any): IteratorResult<T>
  throw?(e?: any): IteratorResult<T>
}

interface IteratorResult<T> {
  done: boolean
  value: T | undefined
}
```

This ensures compatibility with TypeScript's type checking and for-of loops.

## See Also

- [scan](/primitives/bytecode/scan) - Simple generator-based iteration
- [Instruction Types](/primitives/bytecode/instruction-types) - OpcodeData union reference
- [parseInstructions](/primitives/bytecode/parseInstructions) - Eager parsing to array
- [analyzeBlocks](/primitives/bytecode/analyze-blocks) - High-level block analysis
