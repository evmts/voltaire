---
title: Bytecode.from
description: Universal constructor for creating bytecode from hex strings or Uint8Array
---

<Tabs>

</Tabs>

## BytecodeLike Type

`BytecodeLike` is a union type accepting any input that can be coerced to bytecode:

```typescript
type BytecodeLike =
  | Uint8Array
  | BrandedBytecode
  | Bytecode
  | Hex
  | string
```

### Accepted Types

**Uint8Array** - Raw byte arrays:
```typescript
const bytes = new Uint8Array([0x60, 0x01])
const code = Bytecode(bytes)
```

**BrandedBytecode** - Branded bytecode (passed through):
```typescript
const branded = Bytecode.fromHex("0x6001")
const code = Bytecode(branded)  // No conversion
```

**Hex String** - With or without `0x` prefix:
```typescript
const code1 = Bytecode("0x6001")
const code2 = Bytecode("6001")  // Also valid
```

<Warning title="String Interpretation">
Strings without `0x` prefix may be treated as UTF-8 text, not hex. Always use `0x` prefix for hex strings.
</Warning>

### Usage in Function Signatures

Use `BytecodeLike` for flexible function parameters:

```typescript
function analyzeBytecode(input: BytecodeLike): Analysis {
  const code = Bytecode(input)
  return code.analyze()
}

// All valid calls
analyzeBytecode("0x6001")
analyzeBytecode(new Uint8Array([0x60, 0x01]))
analyzeBytecode(Bytecode.fromHex("0x6001"))
```

### Performance

**No conversion overhead** for `Uint8Array`, `BrandedBytecode`, and `Bytecode` (zero-copy).

**Conversion required** for strings (parses hex and allocates new Uint8Array).

For performance-critical code, prefer passing `Uint8Array` or `BrandedBytecode` directly.

## See Also

- [fromHex](/primitives/bytecode/fromhex) - Parse hex string directly
- [fromUint8Array](/primitives/bytecode/fromuint8array) - Create from Uint8Array directly
