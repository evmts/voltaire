---
title: Bytecode.from
description: Universal constructor for creating bytecode from hex strings or Uint8Array
---

<Tabs>
<Tab title="Class API (recommended)">

## `Bytecode.from(value: BytecodeLike): Bytecode`

Universal constructor that dispatches based on input type. Accepts hex strings or Uint8Array.

**Parameters:**
- `value: BytecodeLike` - Hex string (with or without `0x` prefix) or Uint8Array

**Returns:** `Bytecode` - Bytecode instance with prototype methods

**Example:**

```typescript
import { Bytecode } from '@tevm/voltaire'

// From hex string
const code1 = Bytecode.from("0x6001")
const code2 = Bytecode.from("6001")  // Works without prefix

// From Uint8Array
const bytes = new Uint8Array([0x60, 0x01])
const code3 = Bytecode.from(bytes)
```

**Defined in:** [primitives/Bytecode/BrandedBytecode/from.js:15](https://github.com/evmts/voltaire/blob/main/src/primitives/Bytecode/BrandedBytecode/from.js#L15)

</Tab>
<Tab title="Namespace API (Tree-shakeable)">

## `from(value: BytecodeLike): BrandedBytecode`

Universal constructor that dispatches based on input type. Accepts hex strings or Uint8Array.

**Parameters:**
- `value: BytecodeLike` - Hex string (with or without `0x` prefix) or Uint8Array

**Returns:** `BrandedBytecode` - Branded Uint8Array

**Example:**

```typescript
import * as Bytecode from '@tevm/voltaire/Bytecode'

// From hex string
const code1 = Bytecode.from("0x6001")
const code2 = Bytecode.from("6001")  // Works without prefix

// From Uint8Array
const bytes = new Uint8Array([0x60, 0x01])
const code3 = Bytecode.from(bytes)
```

**Defined in:** [primitives/Bytecode/BrandedBytecode/from.js:15](https://github.com/evmts/voltaire/blob/main/src/primitives/Bytecode/BrandedBytecode/from.js#L15)

</Tab>
</Tabs>

## BytecodeLike Type

`BytecodeLike` is a union type accepting any input that can be coerced to bytecode:

```typescript
type BytecodeLike =
  | Uint8Array
  | BrandedBytecode
  | Bytecode
  | Hex
  | string
```

### Accepted Types

**Uint8Array** - Raw byte arrays:
```typescript
const bytes = new Uint8Array([0x60, 0x01])
const code = Bytecode.from(bytes)
```

**BrandedBytecode** - Branded bytecode (passed through):
```typescript
const branded = Bytecode.fromHex("0x6001")
const code = Bytecode.from(branded)  // No conversion
```

**Hex String** - With or without `0x` prefix:
```typescript
const code1 = Bytecode.from("0x6001")
const code2 = Bytecode.from("6001")  // Also valid
```

<Warning title="String Interpretation">
Strings without `0x` prefix may be treated as UTF-8 text, not hex. Always use `0x` prefix for hex strings.
</Warning>

### Usage in Function Signatures

Use `BytecodeLike` for flexible function parameters:

```typescript
function analyzeBytecode(input: BytecodeLike): Analysis {
  const code = Bytecode.from(input)
  return code.analyze()
}

// All valid calls
analyzeBytecode("0x6001")
analyzeBytecode(new Uint8Array([0x60, 0x01]))
analyzeBytecode(Bytecode.fromHex("0x6001"))
```

### Performance

**No conversion overhead** for `Uint8Array`, `BrandedBytecode`, and `Bytecode` (zero-copy).

**Conversion required** for strings (parses hex and allocates new Uint8Array).

For performance-critical code, prefer passing `Uint8Array` or `BrandedBytecode` directly.

## See Also

- [fromHex](/primitives/bytecode/fromhex) - Parse hex string directly
- [fromUint8Array](/primitives/bytecode/fromuint8array) - Create from Uint8Array directly
