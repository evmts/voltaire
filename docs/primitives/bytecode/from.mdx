---
title: Bytecode.from
description: Universal constructor for creating bytecode from hex strings or Uint8Array
---

<Tabs>
<Tab title="Class API (recommended)">

## `Bytecode(value: BytecodeLike): Bytecode`

Universal constructor that dispatches based on input type. Accepts hex strings or Uint8Array.

**Parameters:**
- `value: BytecodeLike` - Hex string (with or without `0x` prefix) or Uint8Array

**Returns:** `Bytecode` - Bytecode instance with prototype methods

**Example:**

```typescript
import { Bytecode } from '@tevm/voltaire'

// From hex string
const code1 = Bytecode("0x6001")
const code2 = Bytecode("6001")  // Works without prefix

// From Uint8Array
const bytes = new Uint8Array([0x60, 0x01])
const code3 = Bytecode(bytes)
```

**Alias:** `Bytecode.from(value)` - same behavior

**Defined in:** [primitives/Bytecode/BrandedBytecode/from.js:15](https://github.com/evmts/voltaire/blob/main/src/primitives/Bytecode/BrandedBytecode/from.js#L15)

</Tab>
<Tab title="Namespace API (Tree-shakeable)">

## `from(value: BytecodeLike): BrandedBytecode`

Universal constructor that dispatches based on input type. Accepts hex strings or Uint8Array.

**Parameters:**
- `value: BytecodeLike` - Hex string (with or without `0x` prefix) or Uint8Array

**Returns:** `BrandedBytecode` - Branded Uint8Array

**Example:**

```typescript
import * as Bytecode from '@tevm/voltaire/Bytecode'

// From hex string
const code1 = Bytecode.from("0x6001")
const code2 = Bytecode.from("6001")  // Works without prefix

// From Uint8Array
const bytes = new Uint8Array([0x60, 0x01])
const code3 = Bytecode.from(bytes)
```

**Defined in:** [primitives/Bytecode/BrandedBytecode/from.js:15](https://github.com/evmts/voltaire/blob/main/src/primitives/Bytecode/BrandedBytecode/from.js#L15)

</Tab>
<Tab title="Zig">

## `Bytecode.init(allocator: Allocator, code: []const u8): !Bytecode`

Initialize bytecode with jump destination analysis. Analyzes the bytecode to identify valid JUMPDEST locations while correctly handling PUSH instruction immediate data.

**Parameters:**
- `allocator: Allocator` - Memory allocator for analyzed data
- `code: []const u8` - Raw bytecode bytes

**Returns:** `Bytecode` - Bytecode with pre-analyzed jump destinations

**Example:**

```zig
const std = @import("std");
const Bytecode = @import("primitives").Bytecode;

var gpa = std.heap.GeneralPurposeAllocator(.{}){};
defer _ = gpa.deinit();
const allocator = gpa.allocator();

const code = [_]u8{ 0x60, 0x01, 0x5b, 0x00 }; // PUSH1 1, JUMPDEST, STOP
var bytecode = try Bytecode.init(allocator, &code);
defer bytecode.deinit();

// Bytecode is now ready for use
```

**Memory:** Must call `deinit()` to clean up jump destination map.

**Defined in:** [primitives/Bytecode/bytecode.zig:36](https://github.com/evmts/voltaire/blob/main/src/primitives/Bytecode/bytecode.zig#L36)

</Tab>
</Tabs>

## BytecodeLike Type

`BytecodeLike` is a union type accepting any input that can be coerced to bytecode:

```typescript
type BytecodeLike =
  | Uint8Array
  | BrandedBytecode
  | Bytecode
  | Hex
  | string
```

### Accepted Types

**Uint8Array** - Raw byte arrays:
```typescript
const bytes = new Uint8Array([0x60, 0x01])
const code = Bytecode(bytes)
```

**BrandedBytecode** - Branded bytecode (passed through):
```typescript
const branded = Bytecode.fromHex("0x6001")
const code = Bytecode(branded)  // No conversion
```

**Hex String** - With or without `0x` prefix:
```typescript
const code1 = Bytecode("0x6001")
const code2 = Bytecode("6001")  // Also valid
```

<Warning title="String Interpretation">
Strings without `0x` prefix may be treated as UTF-8 text, not hex. Always use `0x` prefix for hex strings.
</Warning>

### Usage in Function Signatures

Use `BytecodeLike` for flexible function parameters:

```typescript
function analyzeBytecode(input: BytecodeLike): Analysis {
  const code = Bytecode(input)
  return code.analyze()
}

// All valid calls
analyzeBytecode("0x6001")
analyzeBytecode(new Uint8Array([0x60, 0x01]))
analyzeBytecode(Bytecode.fromHex("0x6001"))
```

### Performance

**No conversion overhead** for `Uint8Array`, `BrandedBytecode`, and `Bytecode` (zero-copy).

**Conversion required** for strings (parses hex and allocates new Uint8Array).

For performance-critical code, prefer passing `Uint8Array` or `BrandedBytecode` directly.

## See Also

- [fromHex](/primitives/bytecode/fromhex) - Parse hex string directly
- [fromUint8Array](/primitives/bytecode/fromuint8array) - Create from Uint8Array directly
