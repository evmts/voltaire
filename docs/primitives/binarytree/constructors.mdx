---
title: BinaryTree Constructors
description: Creating BinaryTree instances
---

# Constructors

Methods for creating BinaryTree instances.

## Factory Constructor

<Tabs>
<Tab title="TypeScript">

### `BinaryTree()`

Factory function creates empty binary tree with empty root node.

```typescript
import { BinaryTree } from '@tevm/voltaire'

const tree = BinaryTree()
console.log(tree.root.type) // 'empty'
console.log(tree.root) // { type: 'empty' }
```

**Returns:** `BinaryTree` - Empty tree with `{ root: { type: "empty" } }`

**Usage:**

```typescript
// Create empty tree
const tree = BinaryTree()

// Insert values to build tree
const key = Hash.from('0x' + '00'.repeat(32))
const value = Hash.from('0x' + '00'.repeat(32))
value[0] = 0x42

const tree2 = BinaryTree.insert(tree, key, value)
console.log(tree2.root.type) // 'stem' (no longer empty)
```

Defined in: [primitives/BinaryTree/index.js:30-32](https://github.com/evmts/voltaire/blob/main/src/primitives/BinaryTree/index.js#L30-L32)

</Tab>

</Tabs>

## Static Constructor

### `BinaryTree.init()`

Static method creates empty binary tree. Equivalent to factory function.

```typescript
import { BinaryTree } from '@tevm/voltaire'

const tree = BinaryTree.init()
console.log(tree.root.type) // 'empty'
```

**Returns:** `BinaryTree` - Empty tree

**Namespace Usage:**

```typescript
import { BinaryTree } from '@tevm/voltaire'

// Both are equivalent
const tree1 = BinaryTree()
const tree2 = BinaryTree.init()
```

**Tree-shakeable Usage:**

```typescript
import { init } from '@tevm/voltaire/BrandedBinaryTree'
import type { BinaryTree } from '@tevm/voltaire/BrandedBinaryTree'

const tree: BinaryTree = init()
```

Defined in: [primitives/BinaryTree/BrandedBinaryTree/init.js:12-14](https://github.com/evmts/voltaire/blob/main/src/primitives/BinaryTree/BrandedBinaryTree/init.js#L12-L14)

## Empty Tree Structure

All constructors create identical empty tree:

```typescript
{
  root: { type: "empty" }
}
```

Empty tree properties:
- Root hash is 32 zero bytes
- No storage allocated
- Get operations return `null`
- Insert creates first stem node

## Tree Construction Pattern

Trees built through successive insert operations:

```typescript
import { BinaryTree } from '@tevm/voltaire'

// Start with empty tree
let tree = BinaryTree.init()

// Insert first value (creates stem node)
const key1 = Hash.from('0x' + '00'.repeat(32))
key1[31] = 0  // subindex 0
const value1 = Hash.from('0x' + '00'.repeat(32))
value1[0] = 0x01

tree = BinaryTree.insert(tree, key1, value1)
console.log(tree.root.type) // 'stem'

// Insert second value (same stem, different subindex)
const key2 = Hash.from('0x' + '00'.repeat(32))
key2[31] = 1  // subindex 1
const value2 = Hash.from('0x' + '00'.repeat(32))
value2[0] = 0x02

tree = BinaryTree.insert(tree, key2, value2)
console.log(tree.root.type) // Still 'stem' (same 31-byte stem)

// Insert with different stem (creates internal nodes)
const key3 = Hash.from('0x' + '00'.repeat(32))
key3[0] = 0xFF  // Different stem
key3[31] = 0
const value3 = Hash.from('0x' + '00'.repeat(32))
value3[0] = 0x03

tree = BinaryTree.insert(tree, key3, value3)
console.log(tree.root.type) // 'internal' (branched)
```

## Immutability

All operations return new tree instances:

```typescript
const tree1 = BinaryTree.init()
const tree2 = BinaryTree.insert(tree1, key, value)

// tree1 unchanged
console.log(tree1.root.type) // 'empty'
console.log(tree2.root.type) // 'stem'

// tree1 and tree2 are different objects
console.log(tree1 === tree2) // false
```

Immutability benefits:
- Safe concurrent access
- History tracking
- Rollback capability
- Pure functional operations

## Account Data Initialization

AccountData stored at subindex 0 in account stem:

```typescript
import { BinaryTree } from '@tevm/voltaire'

// Create empty tree
let tree = BinaryTree.init()

// Account address to key
const address = Address.zero()
// ... set address bytes
const accountKey = BinaryTree.addressToKey(address)

// Modify key for basic data (subindex 0)
const basicDataKey = accountKey.slice()
basicDataKey[31] = 0  // Subindex 0 for AccountData

// Pack AccountData (28 bytes)
const accountData = Hash.from('0x' + '00'.repeat(32))
accountData[0] = 1    // version
// accountData[1-3]: code size (3 bytes)
// accountData[4-11]: nonce (8 bytes)
// accountData[12-27]: balance (16 bytes)

tree = BinaryTree.insert(tree, basicDataKey, accountData)
```

AccountData layout:
- **Byte 0**: Version (1 byte)
- **Bytes 1-3**: Code size (3 bytes, 24-bit)
- **Bytes 4-11**: Nonce (8 bytes, 64-bit)
- **Bytes 12-27**: Balance (16 bytes, 128-bit)

See [Usage Patterns](/primitives/binarytree/usage-patterns) for complete account management examples.

## Related

- [Operations](/primitives/binarytree/operations) - Insert and get operations
- [Hashing](/primitives/binarytree/hashing) - Root hash calculation
- [Key Utilities](/primitives/binarytree/key-utilities) - Address to key conversion
- [BrandedBinaryTree](/primitives/binarytree/branded-binarytree) - Tree-shakeable API
