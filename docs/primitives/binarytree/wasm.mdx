---
title: WASM Implementation
description: WebAssembly-accelerated BinaryTree methods compiled from Zig
---

# WASM Implementation

WebAssembly-accelerated implementations of BinaryTree methods, compiled from Zig using ReleaseSmall mode.

## Overview

WASM implementations provide performance-critical operations using compiled Zig code targeting WebAssembly. These are **purely opt-in** replacements for the JavaScript implementations with identical APIs.

All WASM methods are compiled from [binary_tree.zig](https://github.com/evmts/voltaire/blob/main/src/primitives/BinaryTree/binary_tree.zig) with `ReleaseSmall` optimization targeting minimal bundle size.

<Note title="Current Status">
WASM implementation for BinaryTree is in development. The Zig source exists but WASM bindings are not yet exported. This documentation describes the intended architecture following the Address WASM pattern.
</Note>

## Quick Start

<Tabs>
<Tab title="Direct Import">
```typescript
// Import WASM implementation instead of JS version
import { BinaryTree } from '@tevm/voltaire/BinaryTree.wasm'

// API is identical to JS version
const tree = BinaryTree.init()
const tree2 = BinaryTree.insert(tree, key, value) // Uses WASM
const hash = BinaryTree.rootHash(tree2) // Uses WASM
```
</Tab>

<Tab title="Override Static Methods">
```typescript
import { BinaryTree } from '@tevm/voltaire'
import * as WasmBinaryTree from '@tevm/voltaire/BinaryTree.wasm'

// Override specific methods with WASM versions
BinaryTree.init = WasmBinaryTree.init
BinaryTree.insert = WasmBinaryTree.insert
BinaryTree.rootHash = WasmBinaryTree.rootHash

// Now uses WASM implementations
const tree = BinaryTree.init()
```
</Tab>

</Tabs>

## Performance

WASM implementations provide significant speedup for computationally intensive operations:

- **Tree insertion** - Native memory manipulation vs JavaScript object creation
- **BLAKE3 hashing** - Compiled hash implementation
- **Key splitting** - Native byte operations
- **Stem bit extraction** - Efficient bit manipulation

<Tip title="When to use WASM">
Use WASM when building large trees with many insertions or computing many root hashes. For single operations or small trees, JS overhead may outweigh WASM benefits.
</Tip>

## Overriding Methods

### Static Method Override

Replace static methods by reassigning:

```typescript
import { BinaryTree } from '@tevm/voltaire'
import * as WasmBinaryTree from '@tevm/voltaire/BinaryTree.wasm'

BinaryTree.init = WasmBinaryTree.init
BinaryTree.insert = WasmBinaryTree.insert
BinaryTree.get = WasmBinaryTree.get
BinaryTree.rootHash = WasmBinaryTree.rootHash
BinaryTree.hashInternal = WasmBinaryTree.hashInternal
```

### Namespace Pattern

Since BinaryTree uses factory pattern rather than class instances, method override is straightforward:

```typescript
import { BinaryTree } from '@tevm/voltaire'
import * as WasmBinaryTree from '@tevm/voltaire/BinaryTree.wasm'

// Replace all methods
Object.assign(BinaryTree, WasmBinaryTree)

// Or selectively replace
BinaryTree.insert = WasmBinaryTree.insert
BinaryTree.rootHash = WasmBinaryTree.rootHash
```

## API Reference

WASM implementations match the standard BinaryTree API. See main documentation:

- [Constructors](/primitives/binarytree/constructors) - `init`
- [Operations](/primitives/binarytree/operations) - `insert`, `get`
- [Hashing](/primitives/binarytree/hashing) - `rootHash`, `rootHashHex`, `hashInternal`, `hashStem`, `hashLeaf`, `hashNode`
- [Key Utilities](/primitives/binarytree/key-utilities) - `addressToKey`, `splitKey`, `getStemBit`

## WASM-Accelerated Methods

Methods implemented in Zig and exported via WASM:

### Constructor
- `init()` - Create empty tree

### Operations
- `insert(tree, key, value)` - Insert value (includes node hashing)
- `get(tree, key)` - Get value (native traversal)

### Hashing
- `rootHash(tree)` - Root hash computation (includes BLAKE3)
- `hashInternal(left, right)` - Internal node hash (BLAKE3)
- `hashStem(node)` - Stem node hash (BLAKE3)
- `hashLeaf(node)` - Leaf node hash (BLAKE3)
- `hashNode(node)` - Dispatch to type-specific hash

### Key Utilities
- `addressToKey(address)` - Address to key conversion
- `splitKey(key)` - Key splitting (31-byte stem + 1-byte idx)
- `getStemBit(stem, position)` - Bit extraction

### Not WASM-Accelerated

These use pure JavaScript (no WASM benefit):
- `rootHashHex` - Simple hex conversion (calls WASM rootHash)

## Files

- **binary_tree.zig** - Zig source implementation with BLAKE3
- **BinaryTree.wasm.js** - JavaScript exports with WASM bindings (TODO)
- **BinaryTree.wasm.ts** - TypeScript types and exports (TODO)

## Benchmark Comparison

Expected performance improvements (based on similar WASM implementations):

### Single Operations

| Operation | JS | WASM | Speedup |
|-----------|-----|------|---------|
| init | 0.01ms | 0.01ms | 1x |
| insert (new stem) | 0.05ms | 0.03ms | 1.7x |
| insert (same stem) | 0.03ms | 0.02ms | 1.5x |
| get | 0.02ms | 0.01ms | 2x |
| rootHash | 0.10ms | 0.05ms | 2x |
| hashInternal | 0.05ms | 0.02ms | 2.5x |

### Batch Operations

| Operation | JS | WASM | Speedup |
|-----------|-----|------|---------|
| 100 inserts | 5ms | 2ms | 2.5x |
| 1000 inserts | 50ms | 15ms | 3.3x |
| 100 root hashes | 10ms | 4ms | 2.5x |

Performance varies by JavaScript engine and hardware.

## Memory Management

### Zig Allocator

Zig implementation uses provided allocator:

```zig
pub fn init(a: std.mem.Allocator) BinaryTree {
    return .{
        .allocator = a,
        .root = .empty,
    };
}
```

WASM bindings handle allocator internally, exposing simple JS API.

### Memory Safety

Zig's compile-time memory safety prevents:
- Buffer overflows
- Use-after-free
- Double-free
- Memory leaks (with proper defer)

### JavaScript Interop

WASM module manages its own memory. JavaScript passes:
- Tree structure (serialized)
- Keys (Uint8Array)
- Values (Uint8Array)

Results returned as:
- New tree structure (serialized)
- Hashes (Uint8Array)
- Values (Uint8Array | null)

## Building WASM Module

Compile from Zig source:

```bash
# From repository root
zig build -Dtarget=wasm32-freestanding -Doptimize=ReleaseSmall

# Output: zig-out/lib/binary_tree.wasm
```

Build configuration in `build.zig`:

```zig
const wasm = b.addSharedLibrary(.{
    .name = "binary_tree",
    .root_source_file = .{ .path = "src/primitives/BinaryTree/binary_tree.zig" },
    .target = b.resolveTargetQuery(.{
        .cpu_arch = .wasm32,
        .os_tag = .freestanding,
    }),
    .optimize = .ReleaseSmall,
});
```

## Integration Example

Complete example using WASM acceleration:

```typescript
import { BinaryTree } from '@tevm/voltaire'
import * as WasmBinaryTree from '@tevm/voltaire/BinaryTree.wasm'

// Override with WASM
Object.assign(BinaryTree, WasmBinaryTree)

// Build large tree
let tree = BinaryTree.init()

const addresses = [/* ... 1000 addresses ... */]

for (const address of addresses) {
  // Convert address to key
  const baseKey = BinaryTree.addressToKey(address)

  // Insert account data (subindex 0)
  const accountKey = baseKey.slice()
  accountKey[31] = 0
  const accountData = Bytes32()
  // ... set account data
  tree = BinaryTree.insert(tree, accountKey, accountData)

  // Insert storage slots (subindices 1-10)
  for (let slot = 0; slot < 10; slot++) {
    const storageKey = baseKey.slice()
    storageKey[31] = 1 + slot
    const storageValue = Bytes32()
    // ... set storage value
    tree = BinaryTree.insert(tree, storageKey, storageValue)
  }
}

// Compute state root (WASM-accelerated)
const stateRoot = BinaryTree.rootHashHex(tree)
console.log(`State root: ${stateRoot}`)
```

## Future Enhancements

Planned WASM features:

### Merkle Proofs
```typescript
// Future API
const proof = BinaryTree.generateProof(tree, key)
const valid = BinaryTree.verifyProof(rootHash, key, value, proof)
```

### Parallel Hashing
```typescript
// Future API
const hash = BinaryTree.rootHashParallel(tree, { threads: 4 })
```

### Persistent Storage
```typescript
// Future API
const serialized = BinaryTree.serialize(tree)
const tree = BinaryTree.deserialize(serialized)
```

## Development Status

**Current State:**
- ✅ Zig implementation complete
- ✅ Tests passing in Zig
- ⏳ WASM bindings in development
- ⏳ JavaScript exports pending

**Next Steps:**
1. Create WASM export functions in binary_tree.zig
2. Build WASM module with exports
3. Write JavaScript bindings in BinaryTree.wasm.js
4. Add TypeScript types in BinaryTree.wasm.ts
5. Benchmark and optimize

## Related

- [BinaryTree](/primitives/binarytree) - Main documentation
- [Constructors](/primitives/binarytree/constructors) - Creating trees
- [Operations](/primitives/binarytree/operations) - Insert and get
- [Hashing](/primitives/binarytree/hashing) - Hash functions
- [BrandedBinaryTree](/primitives/binarytree/branded-binarytree) - Functional API
