---
title: BinaryTree
description: Binary State Tree implementation for Ethereum state (EIP-7864)
---

# BinaryTree

Binary State Tree implementation following EIP-7864 for unified Ethereum state representation.

<Tip title="New to binary merkle trees?">
Start with [Fundamentals](/primitives/binarytree/fundamentals) to learn tree construction, merkle proofs, SSZ, and EIP-7864 Binary State Trees.
</Tip>

## Overview

[Branded](/concepts/branded-types) binary tree data structure with four node types (Internal, Stem, Leaf, Empty). Designed for Ethereum state trees with 32-byte keys split into 31-byte stems and 1-byte subindices. Uses BLAKE3 hashing.

## Quick Start

<Tabs>
<Tab title="Class API">
```typescript
import { BinaryTree } from '@tevm/voltaire'

// Create empty tree (see Constructors)
const tree = BinaryTree()
console.log(tree.root.type) // 'empty'

// Insert values (see Operations)
const key = new Uint8Array(32)
const value = new Uint8Array(32)
value[0] = 0x42
const tree2 = BinaryTree.insert(tree, key, value)

// Get values (see Operations)
const retrieved = BinaryTree.get(tree2, key)
console.log(retrieved) // Uint8Array [0x42, 0, 0, ...]

// Calculate root hash (see Hashing)
const hash = BinaryTree.rootHash(tree2)
const hex = BinaryTree.rootHashHex(tree2) // "0x..."

// Key utilities (see Key Utilities)
const addr = new Uint8Array(20) // Ethereum address
const treeKey = BinaryTree.addressToKey(addr)
const { stem, idx } = BinaryTree.splitKey(treeKey)
```
</Tab>
<Tab title="Namespace API (Tree-shakeable)">
```typescript
import { BinaryTree } from '@tevm/voltaire'

// Tree-shakeable imports minimize bundle size
const tree = BinaryTree.init()

// Each function imported independently
const tree2 = BinaryTree.insert(tree, key, value)
const retrieved = BinaryTree.get(tree2, key)
const hash = BinaryTree.rootHash(tree2)

// See BrandedBinaryTree for complete functional API
```
</Tab>
</Tabs>

## Types

<Tabs>
<Tab title="interface BinaryTree">
```typescript
export interface BinaryTree {
  readonly root: Node
}

export type Node =
  | { readonly type: "empty" }
  | {
      readonly type: "internal"
      readonly left: Uint8Array   // 32-byte hash
      readonly right: Uint8Array  // 32-byte hash
    }
  | {
      readonly type: "stem"
      readonly stem: Uint8Array       // 31 bytes
      readonly values: (Uint8Array | null)[]  // 256 values
    }
  | {
      readonly type: "leaf"
      readonly value: Uint8Array  // 32 bytes
    }

export type InternalNode = Extract<Node, { type: "internal" }>
export type StemNode = Extract<Node, { type: "stem" }>
export type LeafNode = Extract<Node, { type: "leaf" }>
export type EmptyNode = Extract<Node, { type: "empty" }>
```

Source: [BrandedBinaryTree.ts:7-43](https://github.com/evmts/voltaire/blob/main/src/primitives/BinaryTree/BrandedBinaryTree/BrandedBinaryTree.ts#L7-L43)
</Tab>
<Tab title="AccountData">
```typescript
export interface AccountData {
  readonly version: number    // 1 byte
  readonly codeSize: number   // 3 bytes
  readonly nonce: bigint      // 8 bytes
  readonly balance: bigint    // 16 bytes
}
```

Account basic data layout stored at index 0 in stem node. Total 28 bytes defining Ethereum account state.

Source: [BrandedBinaryTree.ts:37-42](https://github.com/evmts/voltaire/blob/main/src/primitives/BinaryTree/BrandedBinaryTree/BrandedBinaryTree.ts#L37-L42)
</Tab>
</Tabs>

## Tree Structure

Internal nodes branch left/right based on stem bits. Stem nodes at leaves store up to 256 values. Empty nodes represent unused branches (hash = zero bytes).

## Node Types

Binary State Tree uses four distinct node types:

### Empty Node

```typescript
{ type: "empty" }
```

Represents empty tree or empty subtree. Hash is 32 zero bytes.

### Internal Node

```typescript
{
  type: "internal"
  left: Uint8Array   // 32-byte hash of left child
  right: Uint8Array  // 32-byte hash of right child
}
```

Branch node with two children. Each child is represented by its 32-byte hash. Used for tree traversal based on stem bits.

### Stem Node

```typescript
{
  type: "stem"
  stem: Uint8Array       // 31-byte stem (tree path)
  values: (Uint8Array | null)[]  // 256 possible values
}
```

Leaf-level node storing up to 256 values indexed by the last byte (subindex) of the 32-byte key. Stem defines the tree path (first 31 bytes).

### Leaf Node

```typescript
{
  type: "leaf"
  value: Uint8Array  // 32-byte value
}
```

Simple leaf with single value. Currently not actively used in standard Binary State Tree operations.

## API Documentation

### Constructors

Creating BinaryTree instances with init factory function.

    [View constructors →](/primitives/binarytree/constructors)

### Operations

Insert, get, and tree manipulation operations.

    [View operations →](/primitives/binarytree/operations)

### Hashing

BLAKE3 hashing for nodes, root hash calculation, hex conversion.

    [View hashing →](/primitives/binarytree/hashing)

### Key Utilities

Address to key conversion, key splitting, stem bit extraction.

    [View key utilities →](/primitives/binarytree/key-utilities)

### BrandedBinaryTree

Tree-shakeable functional API for minimal bundle size.

    [View BrandedBinaryTree →](/primitives/binarytree/branded-binarytree)

### WASM Implementation

WebAssembly-accelerated methods compiled from Zig for performance.

    [View WASM →](/primitives/binarytree/wasm)

### Usage Patterns

Common patterns for EIP-7864 Binary State Tree implementation.

    [View usage patterns →](/primitives/binarytree/usage-patterns)

## Key Concepts

Keys are 32 bytes: 31-byte stem (tree path) + 1-byte subindex (value selector). Each stem stores up to 256 values. Addresses convert to keys by prepending 12 zero bytes. All operations are immutable. See [Fundamentals](/primitives/binarytree/fundamentals) for details.

## Related Types

### Hash

BLAKE3 hashing for node commitments (used by BinaryTree).

    [View Crypto →](/crypto)

### Bytes

Byte array operations for key and value manipulation.

    [View Bytes →](/primitives/bytes)

### Hex

Hex string utilities for root hash display.

    [View Hex →](/primitives/hex)

### State (Merkle Patricia Trie)

Ethereum state representation using tree structures.

    [View State →](/primitives/state)

### Branded Types

Zero-overhead type branding pattern used throughout primitives.

    [View Branded Types →](/concepts/branded-types)

## See Also

- **Merkle Proofs**: Upcoming proof generation and verification for tree validation
- **Verkle Trees**: Future evolution of binary trees with smaller proofs
- **Ethereum Execution Layer**: Uses similar tree structures for account and storage commitments
