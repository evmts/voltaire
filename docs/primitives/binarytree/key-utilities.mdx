---
title: BinaryTree Key Utilities
description: Address to key conversion, key splitting, and stem bit extraction
---

# Key Utilities

Utility functions for 32-byte key manipulation in Binary State Tree.

## Overview

Binary State Tree uses 32-byte keys split into 31-byte stems (tree path) and 1-byte subindices (value selector). Key utilities handle conversion between Ethereum addresses and tree keys, key parsing, and bit extraction for tree traversal.

## Address to Key

<Tabs>
<Tab title="TypeScript">

### `BinaryTree.addressToKey(address)`

Convert 20-byte Ethereum address to 32-byte tree key by prepending 12 zero bytes.

```typescript
import { BinaryTree } from '@tevm/voltaire'

const address = new Uint8Array(20)
address[0] = 0x74
address[1] = 0x2d
// ... set remaining address bytes

const key = BinaryTree.addressToKey(address)
console.log(key.length) // 32
console.log(key[0]) // 0 (prepended zero)
console.log(key[11]) // 0 (prepended zero)
console.log(key[12]) // 0x74 (first address byte)
console.log(key[13]) // 0x2d (second address byte)
```

**Parameters:**
- `address: Uint8Array` - 20-byte Ethereum address

**Returns:** `Uint8Array` - 32-byte key (12 zero bytes + 20 address bytes)

**Throws:**
- `InvalidAddressLengthError` - If address is not exactly 20 bytes

**Format:**
```
key = [0,0,0,0,0,0,0,0,0,0,0,0, a0,a1,a2,...,a19]
       ← 12 zero bytes →         ← 20 address bytes →
```

</Tab>
<Tab title="Zig">

### `BinaryTree.addressToKey(addr: [20]u8) [32]u8`

Convert 20-byte Ethereum address to 32-byte tree key by prepending 12 zero bytes.

**Parameters:**
- `addr: [20]u8` - 20-byte Ethereum address

**Returns:** `[32]u8` - 32-byte key (12 zero bytes + 20 address bytes)

**Example:**

```zig
const std = @import("std");
const BinaryTree = @import("primitives").BinaryTree;

// Convert address to key
var address: [20]u8 = undefined;
address[0] = 0x74;
address[1] = 0x2d;
@memset(address[2..], 0);

const key = BinaryTree.addressToKey(address);
// key[0..12] are zeros
// key[12..32] contains address bytes
```

**Defined in:** [primitives/BinaryTree/binary_tree.zig:51](https://github.com/evmts/voltaire/blob/main/src/primitives/BinaryTree/binary_tree.zig#L51)

</Tab>
</Tabs>

Defined in: [primitives/BinaryTree/BrandedBinaryTree/addressToKey.js:17-22](https://github.com/evmts/voltaire/blob/main/src/primitives/BinaryTree/BrandedBinaryTree/addressToKey.js#L17-L22)

## Split Key

### `BinaryTree.splitKey(key)`

Split 32-byte key into 31-byte stem (tree path) and 1-byte subindex (value selector).

```typescript
import { BinaryTree } from '@tevm/voltaire'

const key = new Uint8Array(32)
key[0] = 0xAA
key[30] = 0xBB
key[31] = 0x42  // Subindex

const { stem, idx } = BinaryTree.splitKey(key)
console.log(stem.length) // 31
console.log(stem[0]) // 0xAA
console.log(stem[30]) // 0xBB
console.log(idx) // 0x42
```

**Parameters:**
- `key: Uint8Array` - 32-byte key

**Returns:** `{ stem: Uint8Array; idx: number }`
- `stem` - First 31 bytes of key
- `idx` - Last byte of key (0-255)

**Throws:**
- `InvalidKeyLengthError` - If key is not exactly 32 bytes

**Format:**
```
key[0..30]  → stem (31 bytes)
key[31]     → idx (1 byte, 0-255)
```

<Tabs>
<Tab title="Basic Usage">
```typescript
import { BinaryTree } from '@tevm/voltaire'

const key = new Uint8Array(32)
key[31] = 5  // Subindex 5

const { stem, idx } = BinaryTree.splitKey(key)
console.log(idx) // 5
console.log(stem.length) // 31
```
</Tab>
<Tab title="Tree Operations">
```typescript
import { BinaryTree } from '@tevm/voltaire'

// Insert uses splitKey internally
const key = new Uint8Array(32)
const { stem, idx } = BinaryTree.splitKey(key)

// Stem determines tree path
// idx selects value in stem node (0-255)
```
</Tab>
<Tab title="Multiple Subindices">
```typescript
import { BinaryTree } from '@tevm/voltaire'

const address = new Uint8Array(20)
const baseKey = BinaryTree.addressToKey(address)

// Same stem, different subindices
const keys = []
for (let i = 0; i < 10; i++) {
  const key = baseKey.slice()
  key[31] = i

  const { stem, idx } = BinaryTree.splitKey(key)
  console.log(idx) // 0, 1, 2, ..., 9
  // All have same stem
}
```
</Tab>
<Tab title="Validation">
```typescript
import { BinaryTree, InvalidKeyLengthError } from '@tevm/voltaire'

try {
  const invalidKey = new Uint8Array(31) // Wrong length
  const { stem, idx } = BinaryTree.splitKey(invalidKey)
} catch (error) {
  if (error instanceof InvalidKeyLengthError) {
    console.error('Key must be 32 bytes')
  }
}
```
</Tab>
<Tab title="Tree-shakeable">
```typescript
import { splitKey } from '@tevm/voltaire/BrandedBinaryTree'

const { stem, idx } = splitKey(key)
```
</Tab>
</Tabs>

Defined in: [primitives/BinaryTree/BrandedBinaryTree/splitKey.js:19-25](https://github.com/evmts/voltaire/blob/main/src/primitives/BinaryTree/BrandedBinaryTree/splitKey.js#L19-L25)

## Stem Bit Extraction

### `BinaryTree.getStemBit(stem, position)`

Extract bit at position in 31-byte stem (0-247 bits). Used for tree traversal to determine left (0) or right (1) branch.

```typescript
import { BinaryTree } from '@tevm/voltaire'

const stem = new Uint8Array(31)
stem[0] = 0b10101010  // Binary: 1-0-1-0-1-0-1-0

console.log(BinaryTree.getStemBit(stem, 0)) // 1 (leftmost bit)
console.log(BinaryTree.getStemBit(stem, 1)) // 0
console.log(BinaryTree.getStemBit(stem, 2)) // 1
console.log(BinaryTree.getStemBit(stem, 3)) // 0
console.log(BinaryTree.getStemBit(stem, 4)) // 1
```

**Parameters:**
- `stem: Uint8Array` - 31-byte stem
- `position: number` - Bit position (0-247)

**Returns:** `0 | 1` - Bit value at position

**Bit Ordering:**
- Position 0 = bit 7 of byte 0 (leftmost bit)
- Position 7 = bit 0 of byte 0
- Position 8 = bit 7 of byte 1
- Position 247 = bit 0 of byte 30 (rightmost bit)

**Out of Range:** Returns 0 for positions ≥ 248

<Tabs>
<Tab title="Basic Usage">
```typescript
import { BinaryTree } from '@tevm/voltaire'

const stem = new Uint8Array(31)
stem[0] = 0xFF  // All bits set to 1

console.log(BinaryTree.getStemBit(stem, 0)) // 1
console.log(BinaryTree.getStemBit(stem, 7)) // 1
console.log(BinaryTree.getStemBit(stem, 8)) // 0 (next byte is 0x00)
```
</Tab>
<Tab title="Tree Traversal">
```typescript
import { BinaryTree } from '@tevm/voltaire'

const stem = new Uint8Array(31)
stem[0] = 0b10000000

// Tree depth determines bit position
let depth = 0

// At root (depth 0), check bit 0
const bit0 = BinaryTree.getStemBit(stem, depth)
console.log(bit0) // 1 → go right

depth = 1
const bit1 = BinaryTree.getStemBit(stem, depth)
console.log(bit1) // 0 → go left
```
</Tab>
<Tab title="All Bits">
```typescript
import { BinaryTree } from '@tevm/voltaire'

const stem = new Uint8Array(31)
stem[0] = 0xAA  // 10101010

// Extract all 8 bits from first byte
for (let pos = 0; pos < 8; pos++) {
  const bit = BinaryTree.getStemBit(stem, pos)
  console.log(`Bit ${pos}: ${bit}`)
}
// Output:
// Bit 0: 1
// Bit 1: 0
// Bit 2: 1
// Bit 3: 0
// Bit 4: 1
// Bit 5: 0
// Bit 6: 1
// Bit 7: 0
```
</Tab>
<Tab title="Out of Range">
```typescript
import { BinaryTree } from '@tevm/voltaire'

const stem = new Uint8Array(31)

// Valid range: 0-247 (31 bytes × 8 bits)
console.log(BinaryTree.getStemBit(stem, 247)) // 0 (last bit)
console.log(BinaryTree.getStemBit(stem, 248)) // 0 (out of range)
console.log(BinaryTree.getStemBit(stem, 999)) // 0 (out of range)
```
</Tab>
<Tab title="Tree-shakeable">
```typescript
import { getStemBit } from '@tevm/voltaire/BrandedBinaryTree'

const bit = getStemBit(stem, position)
```
</Tab>
</Tabs>

Defined in: [primitives/BinaryTree/BrandedBinaryTree/getStemBit.js:16-23](https://github.com/evmts/voltaire/blob/main/src/primitives/BinaryTree/BrandedBinaryTree/getStemBit.js#L16-L23)

## Key Patterns

### Account Keys

Ethereum accounts mapped to keys with 12 zero byte prefix:

```typescript
import { BinaryTree } from '@tevm/voltaire'

const address = new Uint8Array(20)
// ... set address

// Base key for account
const accountKey = BinaryTree.addressToKey(address)

// Split to access stem and subindex
const { stem, idx } = BinaryTree.splitKey(accountKey)

// Account uses multiple subindices:
// 0: AccountData (version, code size, nonce, balance)
// 1-255: Storage slots or code chunks
```

### Storage Keys

Storage slots accessed via subindices 1-255:

```typescript
import { BinaryTree } from '@tevm/voltaire'

const address = new Uint8Array(20)
const baseKey = BinaryTree.addressToKey(address)

// Storage slot 0 at subindex 1
const storageKey0 = baseKey.slice()
storageKey0[31] = 1

// Storage slot 1 at subindex 2
const storageKey1 = baseKey.slice()
storageKey1[31] = 2

// Up to 255 storage slots per stem
```

### Subindex Ranges

Subindex 0-255 mapped to different data:

```typescript
// Subindex 0: Account basic data
accountDataKey[31] = 0

// Subindices 1-255: Storage slots 0-254
storageSlotKey[31] = 1 + slotNumber  // slot 0 at idx 1, etc.
```

## Tree Traversal Algorithm

Using stem bits for tree navigation:

```typescript
import { BinaryTree } from '@tevm/voltaire'

function traversePath(stem: Uint8Array, maxDepth: number = 10) {
  const path = []

  for (let depth = 0; depth < maxDepth; depth++) {
    const bit = BinaryTree.getStemBit(stem, depth)
    path.push(bit === 0 ? 'left' : 'right')
  }

  return path
}

const stem = new Uint8Array(31)
stem[0] = 0b10110000  // First byte: 1-0-1-1-0-0-0-0

const path = traversePath(stem, 5)
console.log(path)
// ['right', 'left', 'right', 'right', 'left']
```

### Visual: Bit Navigation Through Tree

```
Stem byte 0: 10110000 (0xB0)
Bit positions: 0 1 2 3 4 5 6 7
Bit values:    1 0 1 1 0 0 0 0

Tree navigation (depth = position):
                    Root
            bit[0]=1 ↙ (right)

            bit[1]=0 ↙ (left)

            bit[2]=1 ↙ (right)

            bit[3]=1 ↙ (right)

            bit[4]=0 ↙ (left)

                  Stem Node
                  (at depth 5)

Path taken: right → left → right → right → left → STEM[addr]
```

Each bit in the 31-byte stem determines one level of tree depth:
- 31 bytes × 8 bits = 248 total bits = 248 tree levels possible
- Stem defines complete path to leaf (stem node)
- Subindex selects one of 256 values in that stem

## Bit Indexing

Understanding bit positions in stem:

```
Stem: [byte0, byte1, byte2, ..., byte30]
      31 bytes = 248 bits total

Byte 0: [bit7 bit6 bit5 bit4 bit3 bit2 bit1 bit0]
        pos0  pos1  pos2  pos3  pos4  pos5  pos6  pos7

Byte 1: [bit7 bit6 bit5 bit4 bit3 bit2 bit1 bit0]
        pos8  pos9  pos10 pos11 pos12 pos13 pos14 pos15

...

Byte 30: [bit7 bit6 bit5 bit4 bit3 bit2 bit1 bit0]
         pos240 ...                        pos247
```

Example with specific byte:

```typescript
import { BinaryTree } from '@tevm/voltaire'

const stem = new Uint8Array(31)
stem[0] = 0b11110000  // Binary value

// Bits in byte 0 (positions 0-7):
// Position 0 (bit 7): 1
// Position 1 (bit 6): 1
// Position 2 (bit 5): 1
// Position 3 (bit 4): 1
// Position 4 (bit 3): 0
// Position 5 (bit 2): 0
// Position 6 (bit 1): 0
// Position 7 (bit 0): 0

console.log(BinaryTree.getStemBit(stem, 0)) // 1
console.log(BinaryTree.getStemBit(stem, 3)) // 1
console.log(BinaryTree.getStemBit(stem, 4)) // 0
console.log(BinaryTree.getStemBit(stem, 7)) // 0
```

## Complete Example

Combining all key utilities:

```typescript
import { BinaryTree } from '@tevm/voltaire'

// 1. Start with Ethereum address
const address = new Uint8Array(20)
address[0] = 0x74
// ... set remaining bytes

// 2. Convert to tree key
const baseKey = BinaryTree.addressToKey(address)

// 3. Create key for account data (subindex 0)
const accountDataKey = baseKey.slice()
accountDataKey[31] = 0

// 4. Split key
const { stem, idx } = BinaryTree.splitKey(accountDataKey)
console.log('Stem length:', stem.length) // 31
console.log('Subindex:', idx) // 0

// 5. Examine tree path (first 10 levels)
console.log('Tree path:')
for (let depth = 0; depth < 10; depth++) {
  const bit = BinaryTree.getStemBit(stem, depth)
  console.log(`Depth ${depth}: ${bit === 0 ? 'left' : 'right'}`)
}

// 6. Insert into tree
let tree = BinaryTree.init()
const value = new Uint8Array(32)
tree = BinaryTree.insert(tree, accountDataKey, value)

// 7. Retrieve
const retrieved = BinaryTree.get(tree, accountDataKey)
```

## Error Handling

```typescript
import {
  BinaryTree,
  InvalidAddressLengthError,
  InvalidKeyLengthError
} from '@tevm/voltaire'

// Address validation
try {
  const invalidAddress = new Uint8Array(19)
  const key = BinaryTree.addressToKey(invalidAddress)
} catch (error) {
  if (error instanceof InvalidAddressLengthError) {
    console.error('Address must be 20 bytes')
  }
}

// Key validation
try {
  const invalidKey = new Uint8Array(31)
  const { stem, idx } = BinaryTree.splitKey(invalidKey)
} catch (error) {
  if (error instanceof InvalidKeyLengthError) {
    console.error('Key must be 32 bytes')
  }
}
```

<Tip title="Stem vs Key">
- **Key** = 32 bytes (used for tree operations)
- **Stem** = First 31 bytes (defines tree path)
- **Subindex** = Last byte (selects value 0-255)

Always use full 32-byte keys for insert/get operations. Stem extraction handled internally.
</Tip>

## Related

- [Operations](/primitives/binarytree/operations) - Using keys for insert/get
- [Constructors](/primitives/binarytree/constructors) - Creating trees
- [Hashing](/primitives/binarytree/hashing) - Hashing nodes at path
- [Usage Patterns](/primitives/binarytree/usage-patterns) - Account key patterns
