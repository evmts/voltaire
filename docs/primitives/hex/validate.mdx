---
title: Hex.validate
description: Validate hex format and throw on invalid input
---

<Tabs>

</Tabs>

## Validation Rules

Must meet ALL conditions:
1. Starts with `0x` prefix
2. Contains only valid hex characters: `0-9`, `a-f`, `A-F`
3. Can be empty after prefix (`0x` is valid)

```typescript
// ✓ Valid
Hex.validate("0x")         // Empty hex
Hex.validate("0x0")        // Single digit
Hex.validate("0x1234")     // Multiple digits
Hex.validate("0xabcdef")   // Lowercase
Hex.validate("0xABCDEF")   // Uppercase
Hex.validate("0xAbCdEf")   // Mixed case

// ✗ Invalid - throws
Hex.validate("")           // InvalidFormatError
Hex.validate("0X1234")     // InvalidFormatError (uppercase X)
Hex.validate("1234")       // InvalidFormatError (missing 0x)
Hex.validate("0x 1234")    // InvalidCharacterError (space)
Hex.validate("0xGHIJ")     // InvalidCharacterError
```

## Error Types

**InvalidFormatError:**
```typescript
try {
  Hex.validate("1234")  // Missing 0x
} catch (e) {
  console.error(e.message)
  // "Hex string must start with '0x'"
}

try {
  Hex.validate("")  // Empty string
} catch (e) {
  console.error(e.message)
  // "Hex string must start with '0x'"
}
```

**InvalidCharacterError:**
```typescript
try {
  Hex.validate("0xZZZZ")
} catch (e) {
  console.error(e.message)
  // "Invalid hex character at position X"
}

try {
  Hex.validate("0x12 34")  // Space
} catch (e) {
  console.error(e.message)
  // "Invalid hex character"
}
```

## Common Use Cases

**Invariant Checking:**
```typescript
function processHash(hash: string) {
  Hex.validate(hash)  // Throws if invalid

  // Guaranteed valid hex past this point
  const bytes = Hex.toBytes(hash)
  return keccak256(bytes)
}
```

**API Input Validation:**
```typescript
app.post('/transaction', (req, res) => {
  try {
    const data = Hex.validate(req.body.data)
    const to = Hex.validate(req.body.to)

    // Process transaction...
  } catch (e) {
    return res.status(400).json({ error: e.message })
  }
})
```

**Constructor Validation:**
```typescript
class Transaction {
  constructor(data: string) {
    this.data = Hex.validate(data)  // Ensure valid in constructor
  }
}
```

**Fail-Fast Parsing:**
```typescript
function parseCalldata(input: string) {
  Hex.validate(input)  // Fail immediately if invalid

  const selector = input.slice(0, 10)
  const params = input.slice(10)
  // Continue parsing...
}
```

**Configuration Validation:**
```typescript
const config = {
  privateKey: Hex.validate(process.env.PRIVATE_KEY),
  contractAddress: Hex.validate(process.env.CONTRACT_ADDRESS)
}
```

## vs isHex()

**`validate()` - Throwing:**
```typescript
try {
  Hex.validate(input)  // Throws descriptive error
  // Valid - continue
} catch (e) {
  console.error(e.message)  // Specific error message
}
```

**`isHex()` - Non-throwing:**
```typescript
if (Hex.isHex(input)) {
  // Valid
} else {
  // Invalid - no error details
}
```

Use `validate()` for:
- Fail-fast validation
- Detailed error reporting
- API endpoints
- Constructor validation
- Invariant checking

Use `isHex()` for:
- Conditional logic
- Type guards
- Silent validation
- Filter operations

## Performance

Character-by-character validation with early return on error. Complexity: O(n) where n is string length.

Throws exceptions on invalid input - suitable for error boundaries.

## See Also

- [isHex](/primitives/hex/is-hex) - Non-throwing type guard
- [isSized](/primitives/hex/is-sized) - Check specific byte size
- [assertSize](/primitives/hex/assert-size) - Assert specific byte size
