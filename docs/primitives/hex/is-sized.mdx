---
title: Hex.isSized
description: Check if hex has specific byte size
---

<Tabs>

</Tabs>

## Size Calculation

Size is calculated as: `(hex.length - 2) / 2`

```typescript
// Each pair of hex digits = 1 byte
Hex.isSized("0x12", 1)       // true (1 byte)
Hex.isSized("0x1234", 2)     // true (2 bytes)
Hex.isSized("0x123456", 3)   // true (3 bytes)

// Empty hex
Hex.isSized("0x", 0)         // true (0 bytes)

// Common Ethereum sizes
Hex.isSized("0x" + "ff".repeat(1), 1)    // true (uint8)
Hex.isSized("0x" + "ff".repeat(2), 2)    // true (uint16)
Hex.isSized("0x" + "ff".repeat(4), 4)    // true (uint32)
Hex.isSized("0x" + "ff".repeat(8), 8)    // true (uint64)
Hex.isSized("0x" + "ff".repeat(20), 20)  // true (address)
Hex.isSized("0x" + "ff".repeat(32), 32)  // true (hash/uint256)
```

## Common Ethereum Sizes

**Address (20 bytes / uint160):**
```typescript
const address = "0x742d35Cc6634C0532925a3b844Bc9e7595f12345"
Hex.isSized(address, 20)  // true
```

**Hash (32 bytes / uint256):**
```typescript
const hash = "0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef"
Hex.isSized(hash, 32)  // true
```

**Function Selector (4 bytes):**
```typescript
const selector = "0xa9059cbb"  // transfer(address,uint256)
Hex.isSized(selector, 4)  // true
```

**Signature (65 bytes):**
```typescript
const signature = "0x" + "00".repeat(65)
Hex.isSized(signature, 65)  // true
```

## Common Use Cases

**Type Guards:**
```typescript
function isAddress(hex: string): boolean {
  return Hex.isHex(hex) && Hex.isSized(hex, 20)
}

function isHash(hex: string): boolean {
  return Hex.isHex(hex) && Hex.isSized(hex, 32)
}
```

**Input Validation:**
```typescript
function setAddress(hex: string) {
  if (!Hex.isSized(hex, 20)) {
    throw new Error("Address must be 20 bytes")
  }
  this.address = hex
}
```

**Conditional Processing:**
```typescript
function processValue(hex: string) {
  if (Hex.isSized(hex, 20)) {
    // Handle as address
    return processAddress(hex)
  } else if (Hex.isSized(hex, 32)) {
    // Handle as hash
    return processHash(hex)
  } else {
    throw new Error("Invalid size")
  }
}
```

**Filter Arrays:**
```typescript
const data = [
  "0x1234",           // 2 bytes
  "0x12345678",       // 4 bytes
  "0x123456",         // 3 bytes
]

// Find all 4-byte values
const fourByteValues = data.filter(hex => Hex.isSized(hex, 4))
// ["0x12345678"]
```

**ABI Decoding:**
```typescript
function decodeParameter(hex: string, type: string) {
  if (type === 'address' && !Hex.isSized(hex, 20)) {
    throw new Error("Invalid address size")
  }
  if (type === 'bytes32' && !Hex.isSized(hex, 32)) {
    throw new Error("Invalid bytes32 size")
  }
  // Decode...
}
```

## Performance

Simple arithmetic calculation: `(length - 2) / 2 === targetSize`. Constant time O(1).

No exceptions thrown - safe for validation loops.

## vs assertSize()

**`isSized()` - Non-throwing:**
```typescript
if (Hex.isSized(hex, 20)) {
  // Valid size
} else {
  // Invalid size - handle gracefully
}
```

**`assertSize()` - Throwing:**
```typescript
try {
  Hex.assertSize(hex, 20)  // Throws on mismatch
  // Valid size - continue
} catch (e) {
  // Handle error
}
```

Use `isSized()` for:
- Conditional logic
- Type guards
- Silent validation
- Filter operations

Use `assertSize()` for:
- Fail-fast validation
- Invariant checking
- Error reporting

## See Also

- [assertSize](/primitives/hex/assert-size) - Assert specific size and throw
- [size](/primitives/hex/size) - Get hex byte size
- [isHex](/primitives/hex/is-hex) - Check valid hex format
- [pad](/primitives/hex/pad) - Pad to specific size
