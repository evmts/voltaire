---
title: Hex.trim
description: Remove leading zero bytes from hex string
---

<Tabs>

</Tabs>

## Trim Behavior

Removes all leading `0x00` bytes until first non-zero:

```typescript
// Remove leading zeros
Hex.trim("0x00001234")
// "0x1234"

Hex.trim("0x00000000000000000000000000000001")
// "0x01"

// All zeros = empty
Hex.trim("0x0000")
// "0x"

// No leading zeros = unchanged
Hex.trim("0x1234")
// "0x1234"
```

## Common Use Cases

**Minimize Storage Values:**
```typescript
const storage = await provider.getStorageAt(address, slot)
// "0x0000000000000000000000000000000000000000000000000000000000001234"

const minimal = Hex.trim(storage)
// "0x1234"

// Use minimal representation for display/logging
console.log(`Value: ${minimal}`)
```

**Normalize BigInt Values:**
```typescript
// Create padded uint256
const value = Hex.fromBigInt(42n, 32)
// "0x000000000000000000000000000000000000000000000000000000000000002a"

// Trim for compact representation
const compact = Hex.trim(value)
// "0x2a"
```

**Optimize RPC Responses:**
```typescript
// Trim padded responses before returning
function getBalance(address: string): string {
  const balance = await contract.balanceOf(address)
  return Hex.trim(balance)  // Return minimal form
}
```

**Compare Values:**
```typescript
// Normalize before comparison
const a = "0x00001234"
const b = "0x1234"

Hex.equals(Hex.trim(a), Hex.trim(b))  // true
```

**Display Optimization:**
```typescript
// Shorten for UI display
const hash = "0x0000000000000000123456789abcdef..."
const display = Hex.trim(hash)
// Shorter, easier to read
```

## All Zeros

When all bytes are zero, returns empty hex:

```typescript
Hex.trim("0x00")          // "0x"
Hex.trim("0x0000")        // "0x"
Hex.trim("0x00000000")    // "0x"

// 32-byte zero
Hex.trim(Hex.zero(32))    // "0x"
```

## No Leading Zeros

If no leading zeros, returns unchanged:

```typescript
Hex.trim("0x1234")   // "0x1234" (no change)
Hex.trim("0xff")     // "0xff" (no change)
Hex.trim("0xabcd")   // "0xabcd" (no change)
```

## Error Handling

Throws on invalid input:

```typescript
try {
  Hex.trim("1234")  // Missing 0x
} catch (e) {
  // InvalidFormatError
}

try {
  Hex.trim("0x123")  // Odd length
} catch (e) {
  // OddLengthError
}
```

## Performance

Scans bytes from start until first non-zero. Complexity: O(n) where n is number of leading zero bytes.

Best case (no zeros): O(1)
Worst case (all zeros): O(n)

## See Also

- [pad](/primitives/hex/pad) - Add leading zeros
- [slice](/primitives/hex/slice) - Extract portion
- [size](/primitives/hex/size) - Get byte size
