---
title: Overview
description: Hexadecimal string encoding and manipulation for Ethereum data
---

<Tip>
New to hex encoding? Start with [Fundamentals](/primitives/hex/fundamentals) for guided examples and concepts.
</Tip>

## Type Definition

[Branded](/concepts/branded-types) string following the [data-first pattern](/concepts/data-first) for hexadecimal encoding.

```typescript
export type BrandedHex = `0x${string}` & { readonly __tag: "Hex" };
```

## Quick Reference

<Tabs>
<Tab title="Class API">

```typescript
import { Hex } from '@tevm/voltaire';

const hex = Hex("0x1234");
const bytes = Hex.toBytes(hex);
const size = Hex.size(hex);
```

</Tab>
<Tab title="Namespace API">

```typescript
import * as Hex from '@tevm/voltaire/Hex';

const hex = Hex.from("0x1234");
const bytes = Hex.toBytes(hex);
const size = Hex.size(hex);
```

</Tab>
</Tabs>

## API Methods

<CardGroup>
<Card title="Constructors" icon="rocket">
Create hex from bytes, numbers, strings, and booleans
[View constructors →](./from)
</Card>
<Card title="Conversions" icon="arrow-right-arrow-left">
Convert to bytes, numbers, bigints, strings, and booleans
[View conversions →](./toBytes)
</Card>
<Card title="Validation" icon="check">
Validate hex format, check sizes, and type guards
[View validation →](./isHex)
</Card>
<Card title="Manipulation" icon="scissors">
Concat, slice, pad, trim, and XOR operations
[View manipulation →](./concat)
</Card>
<Card title="Utilities" icon="wrench">
Size, equals, random, zero, and clone utilities
[View utilities →](./size)
</Card>
</CardGroup>

### Methods Reference

- **Constructors**: `from`, `fromBytes`, `fromNumber`, `fromBigInt`, `fromString`, `fromBoolean`
- **Conversions**: `toBytes`, `toNumber`, `toBigInt`, `toString`, `toBoolean`
- **Validation**: `isHex`, `validate`, `isSized`, `assertSize`
- **Manipulation**: `concat`, `slice`, `pad`, `padRight`, `trim`, `xor`
- **Utilities**: `size`, `equals`, `random`, `zero`, `clone`


## Types

<Tabs>
<Tab title="BrandedHex">

```typescript
export type BrandedHex = `0x${string}` & {
  readonly __tag: "Hex";
};
```

Main branded type. Runtime is a string, TypeScript enforces type safety.

</Tab>
<Tab title="Sized<N>">

```typescript
export type Sized<N extends number = number> = `0x${string}` & {
  readonly __tag: "Hex";
  readonly size: N;
};

// Alias for Sized
export type Bytes<N extends number> = Sized<N>;
```

Sized hex type with compile-time byte length tracking. Used for addresses (20 bytes), hashes (32 bytes), and fixed-size data.

Examples:
- `Sized<20>` = 20-byte hex (addresses)
- `Sized<32>` = 32-byte hex (hashes)
- `Sized<4>` = 4-byte hex (function selectors)

</Tab>
<Tab title="HexLike">

```typescript
type HexLike =
  | string
  | Uint8Array
  | BrandedHex
  | Hex
  | number
  | bigint
  | boolean;
```

Union type accepting any input that can be coerced to hex. Accepted by `Hex.from()`.

See [Hex.from](./from#hexlike-type) for details.

</Tab>
</Tabs>


## Tree-Shaking

Import only what you need for optimal bundle size:

```typescript
import { fromBytes, toBytes, concat } from '@tevm/voltaire/BrandedHex';

const hex = fromBytes(new Uint8Array([0x12, 0x34]));
const bytes = toBytes(hex);
const combined = concat(hex, fromBytes([0x56, 0x78]));
```

## Related

- [Fundamentals](/primitives/hex/fundamentals) - Learn hex encoding concepts and examples
- [Address](/primitives/address) - 20-byte addresses using sized hex
- [Hash](/primitives/hash) - 32-byte hash values
- [Bytecode](/primitives/bytecode) - EVM bytecode representation

## Specification

- [Hexadecimal on Wikipedia](https://en.wikipedia.org/wiki/Hexadecimal) - Base-16 number system
- [Ethereum Yellow Paper](https://ethereum.github.io/yellowpaper/paper.pdf) - Formal specification
- [JSON-RPC Specification](https://ethereum.github.io/execution-apis/api-documentation/) - Hex encoding in APIs
- [EIP-55](https://eips.ethereum.org/EIPS/eip-55) - Mixed-case checksum address encoding
