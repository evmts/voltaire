---
title: Overview
description: Hexadecimal string encoding and manipulation for Ethereum data
---

<Tip>
New to hex encoding? Start with [Fundamentals](/primitives/hex/fundamentals) for guided examples and concepts.
</Tip>

## Type Definition

[Branded](/getting-started/branded-types) string following the [data-first pattern](/getting-started/tree-shaking) for hexadecimal encoding.

```typescript
export type BrandedHex = `0x${string}` & { readonly __tag: "Hex" };
```

## Quick Reference

<Note>
Hex supports both **Class API** (instance methods) and **Namespace API** (functional style). See [API Patterns](/getting-started/tree-shaking) to understand the differences and choose the right approach for your use case.
</Note>

<Tabs>
<Tab title="Class API">

```typescript
import { Hex } from '@tevm/voltaire';

const hex = Hex("0x1234");
const bytes = Hex.toBytes(hex);
const size = Hex.size(hex);
```

</Tab>
<Tab title="Namespace API">

```typescript
import * as Hex from '@tevm/voltaire/Hex';

const hex = Hex.from("0x1234");
const bytes = Hex.toBytes(hex);
const size = Hex.size(hex);
```

</Tab>
</Tabs>

## API Methods

### Constructors

- [`from(value)`](./from) - Universal constructor from any input
- [`fromBytes(bytes)`](./from-bytes) - Create from Uint8Array
- [`fromNumber(value, size?)`](./from-number) - Create from number with optional padding
- [`fromBigInt(value, size?)`](./from-bigint) - Create from bigint with optional padding
- [`fromString(value)`](./from-string) - Create from UTF-8 string
- [`fromBoolean(value)`](./from-boolean) - Create from boolean (0x00 or 0x01)
- [`random(size)`](./random) - Generate cryptographically secure random hex
- [`zero(size)`](./zero) - Create zero-filled hex

### Conversions

- [`toBytes(hex)`](./to-bytes) - Convert to Uint8Array
- [`toNumber(hex)`](./to-number) - Convert to number (safe up to MAX_SAFE_INTEGER)
- [`toBigInt(hex)`](./to-bigint) - Convert to bigint (arbitrary precision)
- [`toString(hex)`](./to-string) - Convert to UTF-8 string
- [`toBoolean(hex)`](./to-boolean) - Convert to boolean (non-zero check)

### Validation

- [`isHex(value)`](./is-hex) - Type guard checking if value is valid hex
- [`validate(value)`](./validate) - Validate hex format and throw on error
- [`isSized(hex, size)`](./is-sized) - Check if hex has specific byte size
- [`assertSize(hex, size)`](./assert-size) - Assert hex size, throw on mismatch

### Manipulation

- [`concat(...hexes)`](./concat) - Concatenate multiple hex strings
- [`slice(hex, start?, end?)`](./slice) - Extract portion by byte indices
- [`pad(hex, size)`](./pad) - Left-pad with zeros to target size
- [`padRight(hex, size)`](./pad-right) - Right-pad with zeros to target size
- [`trim(hex)`](./trim) - Remove leading zero bytes
- [`xor(a, b)`](./xor) - Bitwise XOR of two hex strings

### Utilities

- [`size(hex)`](./size) - Get byte length
- [`equals(a, b)`](./equals) - Compare hex equality (case-insensitive)
- [`clone(hex)`](./clone) - Create a copy of hex string


## Types

<Tabs>
<Tab title="BrandedHex">

```typescript
export type BrandedHex = `0x${string}` & {
  readonly __tag: "Hex";
};
```

Main branded type. Runtime is a string, TypeScript enforces type safety.

</Tab>
<Tab title="Sized<N>">

```typescript
export type Sized<N extends number = number> = `0x${string}` & {
  readonly __tag: "Hex";
  readonly size: N;
};

// Alias for Sized
export type Bytes<N extends number> = Sized<N>;
```

Sized hex type with compile-time byte length tracking. Used for addresses (20 bytes), hashes (32 bytes), and fixed-size data.

Examples:
- `Sized<20>` = 20-byte hex (addresses)
- `Sized<32>` = 32-byte hex (hashes)
- `Sized<4>` = 4-byte hex (function selectors)

</Tab>
<Tab title="HexLike">

```typescript
type HexLike =
  | string
  | Uint8Array
  | BrandedHex
  | Hex
  | number
  | bigint
  | boolean;
```

Union type accepting any input that can be coerced to hex. Accepted by `Hex.from()`.

See [Hex.from](./from#hexlike-type) for details.

</Tab>
</Tabs>


## Tree-Shaking

Import only what you need for optimal bundle size:

```typescript
import { fromBytes, toBytes, concat } from '@tevm/voltaire/BrandedHex';

const hex = fromBytes(new Uint8Array([0x12, 0x34]));
const bytes = toBytes(hex);
const combined = concat(hex, fromBytes([0x56, 0x78]));
```

## Related

- [Fundamentals](/primitives/hex/fundamentals) - Learn hex encoding concepts and examples
- [Address](/primitives/address) - 20-byte addresses using sized hex
- [Hash](/primitives/hash) - 32-byte hash values
- [Bytecode](/primitives/bytecode) - EVM bytecode representation

## Specification

- [Hexadecimal on Wikipedia](https://en.wikipedia.org/wiki/Hexadecimal) - Base-16 number system
- [Ethereum Yellow Paper](https://ethereum.github.io/yellowpaper/paper.pdf) - Formal specification
- [JSON-RPC Specification](https://ethereum.github.io/execution-apis/api-documentation/) - Hex encoding in APIs
- [EIP-55](https://eips.ethereum.org/EIPS/eip-55) - Mixed-case checksum address encoding
