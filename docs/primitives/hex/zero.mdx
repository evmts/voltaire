---
title: Hex.zero
description: Create zero-filled hex of specific byte size
---

<Tabs>

</Tabs>

## Common Ethereum Sizes

**uint8 (1 byte):**
```typescript
Hex.zero(1)  // "0x00"
```

**uint16 (2 bytes):**
```typescript
Hex.zero(2)  // "0x0000"
```

**uint32 (4 bytes):**
```typescript
Hex.zero(4)  // "0x00000000"
```

**uint64 (8 bytes):**
```typescript
Hex.zero(8)  // "0x0000000000000000"
```

**Address (20 bytes / uint160):**
```typescript
const zeroAddress = Hex.zero(20)
// "0x0000000000000000000000000000000000000000"
```

**Hash/uint256 (32 bytes):**
```typescript
const zeroHash = Hex.zero(32)
// "0x0000000000000000000000000000000000000000000000000000000000000000"
```

## Common Use Cases

**Zero Address:**
```typescript
const ZERO_ADDRESS = Hex.zero(20)
// "0x0000000000000000000000000000000000000000"

function isZeroAddress(address: string): boolean {
  return Hex.equals(address, ZERO_ADDRESS)
}
```

**Empty Hash:**
```typescript
const EMPTY_HASH = Hex.zero(32)

function isEmptyHash(hash: string): boolean {
  return Hex.equals(hash, EMPTY_HASH)
}
```

**Initialize Storage:**
```typescript
// Initialize empty bytes32 array
const emptySlots = Array.from({ length: 10 }, () => Hex.zero(32))
```

**Default Values:**
```typescript
class Transaction {
  to: string = Hex.zero(20)        // Default to zero address
  value: string = Hex.zero(32)     // Default to zero value
  data: string = Hex.zero(0)       // Default to empty data
}
```

**Padding Base:**
```typescript
// Start with zeros, then set specific bytes
const buffer = Hex.zero(32)
// Modify as needed
```

**XOR Initialization:**
```typescript
// XOR accumulator starts at zero
const checksum = values.reduce(
  (acc, val) => Hex.xor(acc, val),
  Hex.zero(32)  // Identity element for XOR
)
```

**Test Fixtures:**
```typescript
test("handles zero values", () => {
  const zeroBalance = Hex.zero(32)
  const result = processBalance(zeroBalance)
  assert(result === 0n)
})
```

**Clear Sensitive Data:**
```typescript
// Overwrite with zeros for security
let privateKey = "0x..."
// ... use privateKey ...
privateKey = Hex.zero(32)  // Clear
```

## Empty Hex

Zero-size returns empty hex:

```typescript
Hex.zero(0)  // "0x"
```

## vs fromNumber(0)

**`zero(size)` - Fixed size:**
```typescript
Hex.zero(32)
// "0x0000000000000000000000000000000000000000000000000000000000000000"
```

**`fromNumber(0)` - Minimal representation:**
```typescript
Hex.fromNumber(0)
// "0x0"
```

**`fromNumber(0, size)` - Equivalent:**
```typescript
Hex.fromNumber(0, 32)
// "0x0000000000000000000000000000000000000000000000000000000000000000"
// Same as Hex.zero(32)
```

## Performance

Allocates new zero-filled `Uint8Array` then converts to hex. Very fast.

Complexity: O(n) where n is size, but highly optimized by platform.

For repeated use of same-size zeros, consider caching:

```typescript
// Cache common zero values
const ZERO_32 = Hex.zero(32)
const ZERO_20 = Hex.zero(20)

// Reuse cached values
function isZeroHash(hash: string): boolean {
  return Hex.equals(hash, ZERO_32)
}
```

## See Also

- [random](/primitives/hex/random) - Generate random hex
- [fromNumber](/primitives/hex/from-number) - Create from number
- [pad](/primitives/hex/pad) - Pad with zeros
- [equals](/primitives/hex/equals) - Compare with zero
