---
title: Hash.fromBytes
description: Create Hash from raw 32-byte Uint8Array
---

<Tabs>
<Tab title="Class API">

## `Hash.fromBytes(bytes: Uint8Array): Hash`

Creates hash from raw 32-byte array. Zero-copy operation - uses bytes directly.

**Parameters:**
- `bytes: Uint8Array` - Raw byte array (must be exactly 32 bytes)

**Returns:** `Hash` - Hash instance with prototype methods

**Throws:**
- `Error` - If bytes length ≠ 32

**Example:**

```typescript
import { Hash } from '@tevm/voltaire'

// From Uint8Array
const bytes = new Uint8Array(32)
const hash = Hash.fromBytes(bytes)

// From crypto random
const randomBytes = crypto.getRandomValues(new Uint8Array(32))
const randomHash = Hash.fromBytes(randomBytes)

// From ArrayBuffer
const buffer = new ArrayBuffer(32)
const hash2 = Hash.fromBytes(new Uint8Array(buffer))
```

**Defined in:** [primitives/Hash/BrandedHash/fromBytes.js:15](https://github.com/evmts/voltaire/blob/main/src/primitives/Hash/BrandedHash/fromBytes.js#L15)

</Tab>
<Tab title="Namespace API">

## `fromBytes(bytes: Uint8Array): BrandedHash`

Creates hash from raw 32-byte array. Zero-copy operation - uses bytes directly.

**Parameters:**
- `bytes: Uint8Array` - Raw byte array (must be exactly 32 bytes)

**Returns:** `BrandedHash` - Branded Uint8Array (32 bytes)

**Throws:**
- `Error` - If bytes length ≠ 32

**Example:**

```typescript
import * as Hash from '@tevm/voltaire/Hash'

// From Uint8Array
const bytes = new Uint8Array(32)
const hash = Hash.fromBytes(bytes)

// From crypto random
const randomBytes = crypto.getRandomValues(new Uint8Array(32))
const randomHash = Hash.fromBytes(randomBytes)
```

**Defined in:** [primitives/Hash/BrandedHash/fromBytes.js:15](https://github.com/evmts/voltaire/blob/main/src/primitives/Hash/BrandedHash/fromBytes.js#L15)

</Tab>
<Tab title="Zig">

## Direct Array Usage

Zig uses fixed-size `[32]u8` arrays. No constructor needed - arrays are hashes:

**Example:**

```zig
const std = @import("std");

// From literal
const hash: [32]u8 = .{0} ** 32; // All zeros

// From slice (must be exactly 32 bytes)
fn fromSlice(bytes: []const u8) ![32]u8 {
    if (bytes.len != 32) return error.InvalidLength;
    var hash: [32]u8 = undefined;
    @memcpy(&hash, bytes);
    return hash;
}

// From buffer
var buffer: [32]u8 = undefined;
@memcpy(&buffer, some_bytes);
const hash2 = buffer;
```

**Type safety:** Length enforced at compile time for fixed-size arrays.

</Tab>
</Tabs>

## Zero-Copy Behavior

`fromBytes` is a zero-copy operation - it brands the Uint8Array directly without copying:

```typescript
const bytes = new Uint8Array(32)
const hash = Hash.fromBytes(bytes)

// hash IS bytes (same object)
console.log(hash === bytes) // false (different types)
console.log(hash.buffer === bytes.buffer) // true (same underlying buffer)

// Mutations affect both
bytes[0] = 0xff
console.log(hash[0]) // 0xff
```

<Warning title="Shared Memory">
`fromBytes` shares memory with the input. Mutating the input bytes will mutate the hash. Use `clone()` if you need independent copies.
</Warning>

### Safe Usage Pattern

```typescript
// If you need to mutate input later, clone first
const bytes = new Uint8Array(32)
const hash = Hash.fromBytes(bytes).clone()

bytes[0] = 0xff // Doesn't affect hash
console.log(hash[0]) // 0x00
```

## Uint8Array Sources

### From crypto.getRandomValues

```typescript
const randomBytes = crypto.getRandomValues(new Uint8Array(32))
const hash = Hash.fromBytes(randomBytes)
```

### From ArrayBuffer

```typescript
const buffer = new ArrayBuffer(32)
const hash = Hash.fromBytes(new Uint8Array(buffer))

// Or from offset
const bigBuffer = new ArrayBuffer(64)
const hash2 = Hash.fromBytes(new Uint8Array(bigBuffer, 0, 32))
```

### From TypedArray

```typescript
// From other typed arrays (ensure 32 bytes)
const u32Array = new Uint32Array(8) // 8 × 4 = 32 bytes
const hash = Hash.fromBytes(new Uint8Array(u32Array.buffer))
```

### From Slice

```typescript
const bigArray = new Uint8Array(64)
const slice = bigArray.slice(0, 32)
const hash = Hash.fromBytes(slice)
```

### From Concatenation

```typescript
const part1 = new Uint8Array(16)
const part2 = new Uint8Array(16)
const combined = new Uint8Array([...part1, ...part2])
const hash = Hash.fromBytes(combined)
```

## Validation

`fromBytes` only validates length - it does NOT validate that bytes represent a valid hash:

```typescript
// All valid (32 bytes)
Hash.fromBytes(new Uint8Array(32)) // All zeros
Hash.fromBytes(new Uint8Array([0xff, ...new Array(31).fill(0)])) // Any values

// Invalid (wrong length)
Hash.fromBytes(new Uint8Array(31)) // Error: wrong length
Hash.fromBytes(new Uint8Array(33)) // Error: wrong length
Hash.fromBytes(new Uint8Array(0)) // Error: wrong length
```

For type-safe validation, use `isHash` or `assert`:

```typescript
const bytes = new Uint8Array(32)
const hash = Hash.fromBytes(bytes)

if (Hash.isHash(hash)) {
  // Type guard - hash is BrandedHash
}

Hash.assert(hash) // Throws if invalid
```

## Usage Examples

### From Keccak Output

```typescript
import { keccak256 } from '@noble/hashes/sha3'

const data = new Uint8Array([1, 2, 3, 4])
const hashBytes = keccak256(data) // Uint8Array(32)
const hash = Hash.fromBytes(hashBytes)
```

### From RLP Decoding

```typescript
const rlpData = Rlp.decode(encoded)
const hashBytes = rlpData[0] // Assume first field is hash
const hash = Hash.fromBytes(hashBytes)
```

### From Buffer Slice

```typescript
// Extract hash from larger buffer
const response = new Uint8Array(100)
const hashBytes = response.slice(0, 32)
const hash = Hash.fromBytes(hashBytes)
```

### From Fixed Array

```typescript
// Known hash at compile time
const GENESIS_HASH = new Uint8Array([
  0xd4, 0xe5, 0x67, 0x40, 0xf8, 0x76, 0xae, 0xf8,
  0xc0, 0x10, 0xb8, 0x6a, 0x40, 0xd5, 0xf5, 0x67,
  0x45, 0xa1, 0x18, 0xd0, 0x90, 0x6a, 0x34, 0xe6,
  0x9a, 0xec, 0x8c, 0x0d, 0xb1, 0xcb, 0x8f, 0xa3
])

const genesisHash = Hash.fromBytes(GENESIS_HASH)
```

## Performance

**Zero-copy:** `fromBytes` is fastest constructor - no parsing or copying overhead.

**Validation only:** Single length check - no data validation.

**Benchmark comparison:**
```typescript
// Fastest - zero-copy
const bytes = new Uint8Array(32)
const hash1 = Hash.fromBytes(bytes) // ~1ns

// Slower - hex parsing
const hex = "0x1c8aff950685c2ed4bc3174f3472287b56d9517b9c948127319a09a7a36deac8"
const hash2 = Hash.fromHex(hex) // ~50ns

// Slowest - hashing
const data = new Uint8Array([1, 2, 3])
const hash3 = Hash.keccak256(data) // ~1000ns
```

## See Also

- [from](/primitives/hash/from) - Universal constructor (accepts hex or bytes)
- [fromHex](/primitives/hash/from-hex) - Create from hex string
- [clone](/primitives/hash/clone) - Create independent copy
- [toBytes](/primitives/hash/to-bytes) - Convert Hash back to Uint8Array
- [isHash](/primitives/hash/is-hash) - Validate Hash type
