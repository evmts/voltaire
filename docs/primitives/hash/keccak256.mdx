---
title: Hash.keccak256
description: Compute Keccak-256 hash of byte data
---

<Tabs>

<Tab title="Standard API">

## `Hash.keccak256(data: Uint8Array): BrandedHash`

Compute Keccak-256 hash of byte data.

**Parameters:**
- `data: Uint8Array` - Data to hash (0 bytes to unlimited)

**Returns:** `BrandedHash` - 32-byte hash

**Example:**

```typescript
import * as Hash from '@tevm/voltaire/Hash'

const data = new Uint8Array([1, 2, 3, 4])
const hash = Hash.keccak256(data)
```

</Tab>

<Tab title="Factory API">

## `Keccak256({ keccak256 })(data: Uint8Array): BrandedHash`

Tree-shakeable factory pattern with explicit crypto dependencies.

**Dependencies:**
- `keccak256: (data: Uint8Array) => Uint8Array` - Keccak256 hash function

**Example:**

```typescript
import { Keccak256 } from '@tevm/voltaire/Hash'
import { hash as keccak256 } from '@tevm/voltaire/crypto/Keccak256'

const hashData = Keccak256({ keccak256 })
const hash = hashData(new Uint8Array([1, 2, 3, 4]))
```

**Bundle size:** Crypto only included if you import it.

</Tab>

</Tabs>

## Keccak-256 vs SHA3-256

<Warning title="Ethereum uses Keccak-256, not SHA3-256">
Ethereum's "SHA3" is actually Keccak-256 (pre-standardization). The final SHA3-256 standard differs from Keccak-256. Always use Keccak-256 for Ethereum applications.
</Warning>

**Key differences:**
- **Keccak-256:** Used in Ethereum (addresses, transaction hashes, event signatures)
- **SHA3-256:** Finalized NIST standard (different padding)

```typescript
// Ethereum (Keccak-256)
const keccakHash = Hash.keccak256(data)

// NOT compatible with SHA3-256
import { sha3_256 } from '@noble/hashes/sha3'
const sha3Hash = sha3_256(data) // Different result!
```

## Properties

**Input:** Any data (0 bytes to unlimited)
**Output:** Always 32 bytes (256 bits)
**Deterministic:** Same input → same hash
**Avalanche effect:** Change 1 bit → ~50% of output bits flip
**Collision resistant:** Computationally infeasible to find two inputs with same hash
**Pre-image resistant:** Computationally infeasible to find input from hash

## Usage Examples

### Transaction Hashing

```typescript
import { Rlp } from '@tevm/voltaire'

// Hash RLP-encoded transaction
function hashTransaction(tx: Transaction): Hash {
  const encoded = Rlp.encode([
    tx.nonce,
    tx.gasPrice,
    tx.gasLimit,
    tx.to,
    tx.value,
    tx.data
  ])
  return Hash.keccak256(encoded)
}
```

### Content Addressing

```typescript
// Hash file content for storage
async function hashFile(file: File): Promise<Hash> {
  const buffer = await file.arrayBuffer()
  return Hash.keccak256(new Uint8Array(buffer))
}

// Verify content integrity
function verifyContent(content: Uint8Array, expectedHash: Hash): boolean {
  const computedHash = Hash.keccak256(content)
  return computedHash.equals(expectedHash)
}
```

### Merkle Trees

```typescript
function hashPair(left: Hash, right: Hash): Hash {
  // Concatenate and hash
  const combined = new Uint8Array([...left, ...right])
  return Hash.keccak256(combined)
}

function computeMerkleRoot(leaves: Hash[]): Hash {
  if (leaves.length === 0) throw new Error("Empty tree")
  if (leaves.length === 1) return leaves[0]

  const nextLevel: Hash[] = []
  for (let i = 0; i < leaves.length; i += 2) {
    if (i + 1 < leaves.length) {
      nextLevel.push(hashPair(leaves[i], leaves[i + 1]))
    } else {
      nextLevel.push(leaves[i])
    }
  }

  return computeMerkleRoot(nextLevel)
}
```

### Commitment Schemes

```typescript
// Create commitment (hash of secret + salt)
function createCommitment(secret: Uint8Array, salt: Uint8Array): Hash {
  const combined = new Uint8Array([...secret, ...salt])
  return Hash.keccak256(combined)
}

// Reveal and verify
function verifyCommitment(
  commitment: Hash,
  secret: Uint8Array,
  salt: Uint8Array
): boolean {
  const computed = createCommitment(secret, salt)
  return commitment.equals(computed)
}

// Usage
const secret = new TextEncoder().encode("my secret")
const salt = crypto.getRandomValues(new Uint8Array(32))
const commitment = createCommitment(secret, salt)

// Later, reveal
const valid = verifyCommitment(commitment, secret, salt) // true
```

### Data Integrity

```typescript
// Store data with hash
interface StoredData {
  content: Uint8Array
  hash: Hash
}

function storeData(content: Uint8Array): StoredData {
  return {
    content,
    hash: Hash.keccak256(content)
  }
}

function verifyData(stored: StoredData): boolean {
  const computedHash = Hash.keccak256(stored.content)
  return stored.hash.equals(computedHash)
}

// Usage
const data = new Uint8Array([1, 2, 3, 4])
const stored = storeData(data)

// Later, verify
if (verifyData(stored)) {
  console.log("Data integrity verified")
} else {
  console.log("Data corrupted!")
}
```

### Double Hashing

```typescript
// Hash twice for extra security (e.g., Bitcoin addresses)
function doubleHash(data: Uint8Array): Hash {
  const hash1 = Hash.keccak256(data)
  return Hash.keccak256(hash1)
}
```

### Hashing Large Data

```typescript
// Hash large data in chunks (streaming)
async function hashLargeFile(file: File): Promise<Hash> {
  const chunkSize = 1024 * 1024 // 1MB chunks
  let offset = 0
  const chunks: Uint8Array[] = []

  while (offset < file.size) {
    const chunk = await file.slice(offset, offset + chunkSize).arrayBuffer()
    chunks.push(new Uint8Array(chunk))
    offset += chunkSize
  }

  // Concatenate and hash
  const totalSize = chunks.reduce((sum, chunk) => sum + chunk.length, 0)
  const combined = new Uint8Array(totalSize)
  let position = 0
  for (const chunk of chunks) {
    combined.set(chunk, position)
    position += chunk.length
  }

  return Hash.keccak256(combined)
}
```

## Performance

**Implementation:** Uses [@noble/hashes/sha3](https://github.com/paulmillr/noble-hashes) for Keccak-256 (~2-3KB gzipped).

**Speed:** ~1-2 MB/s for pure JS implementation. For high-performance needs, consider:
- WebAssembly implementation (Zig crypto)
- Native bindings for Node.js

**Benchmarks:**
```
Small data (32 bytes):    ~1-2 μs
Medium data (1 KB):       ~10-20 μs
Large data (1 MB):        ~500-1000 μs
```

## Security Notes

**Cryptographically secure:** Keccak-256 is collision-resistant and pre-image resistant.

**Use cases:**
- ✅ Transaction hashing
- ✅ Address derivation
- ✅ Event signatures
- ✅ Content addressing
- ✅ Merkle trees
- ✅ Commitment schemes

**NOT suitable for:**
- ❌ Password hashing (use Argon2, scrypt, or PBKDF2)
- ❌ Key derivation (use HKDF or PBKDF2)

## See Also

- [keccak256String](/primitives/hash/keccak256-string) - Hash UTF-8 string
- [keccak256Hex](/primitives/hash/keccak256-hex) - Hash hex-encoded data
- [equals](/primitives/hash/equals) - Compare computed hashes
- [merkleRoot](/primitives/hash/merkle-root) - Compute Merkle root
- [Keccak-256 Crypto](/crypto/keccak256) - Low-level Keccak-256 implementation
- [Transaction](/primitives/transaction) - Using keccak256 for transaction hashing
