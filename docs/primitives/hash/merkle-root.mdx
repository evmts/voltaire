---
title: Hash.merkleRoot
description: Calculate Merkle root of hash array using Keccak-256
---

<Tabs>

<Tab title="Standard API">

## `Hash.merkleRoot(hashes: BrandedHash[]): BrandedHash`

Calculate Merkle root of hash array using Keccak-256.

**Parameters:**
- `hashes: BrandedHash[]` - Array of hashes (leaf nodes)

**Returns:** `BrandedHash` - Merkle root hash

**Example:**

```typescript
import * as Hash from '@tevm/voltaire/Hash'

const leaves = [
  Hash.keccak256(data1),
  Hash.keccak256(data2),
  Hash.keccak256(data3)
]
const root = Hash.merkleRoot(leaves)
```

</Tab>

<Tab title="Factory API">

## `MerkleRoot({ keccak256 })(hashes: BrandedHash[]): BrandedHash`

Tree-shakeable factory pattern with explicit crypto dependencies.

**Dependencies:**
- `keccak256: (data: Uint8Array) => Uint8Array` - Keccak256 hash function

**Example:**

```typescript
import { MerkleRoot } from '@tevm/voltaire/Hash'
import { hash as keccak256 } from '@tevm/voltaire/crypto/Keccak256'

const getMerkleRoot = MerkleRoot({ keccak256 })
const root = getMerkleRoot([hash1, hash2, hash3])
```

**Bundle size:** Crypto only included if you import it.

</Tab>

</Tabs>

## Algorithm

Builds Merkle tree bottom-up:

1. Start with leaf hashes
2. Pair adjacent hashes and hash them together
3. If odd number of hashes, promote last hash to next level
4. Repeat until single root hash remains

```
Level 3:           ROOT
                 /      \
Level 2:      H(A+B)   H(C+D)
             /    \    /    \
Level 1:    A     B   C     D  <- Leaf hashes
```

## Usage Examples

### Transaction Merkle Root

```typescript
interface Block {
  transactions: Transaction[]
  transactionsRoot: Hash
}

function calculateTransactionsRoot(txs: Transaction[]): Hash {
  const txHashes = txs.map(tx => tx.hash)
  return Hash.merkleRoot(txHashes)
}

function validateBlock(block: Block): boolean {
  const computedRoot = calculateTransactionsRoot(block.transactions)
  return computedRoot.equals(block.transactionsRoot)
}
```

### Merkle Proof Verification

```typescript
function verifyMerkleProof(
  leaf: Hash,
  proof: Hash[],
  root: Hash
): boolean {
  let computedHash = leaf

  for (const proofElement of proof) {
    const combined = new Uint8Array([...computedHash, ...proofElement])
    computedHash = Hash.keccak256(combined)
  }

  return computedHash.equals(root)
}

// Generate proof
function generateMerkleProof(
  leaves: Hash[],
  index: number
): Hash[] {
  const proof: Hash[] = []
  let currentIndex = index

  let currentLevel = leaves
  while (currentLevel.length > 1) {
    const siblingIndex = currentIndex % 2 === 0 ? currentIndex + 1 : currentIndex - 1

    if (siblingIndex < currentLevel.length) {
      proof.push(currentLevel[siblingIndex])
    }

    const nextLevel: Hash[] = []
    for (let i = 0; i < currentLevel.length; i += 2) {
      if (i + 1 < currentLevel.length) {
        nextLevel.push(Hash.concat(currentLevel[i], currentLevel[i + 1]))
      } else {
        nextLevel.push(currentLevel[i])
      }
    }

    currentLevel = nextLevel
    currentIndex = Math.floor(currentIndex / 2)
  }

  return proof
}
```

### Incremental Updates

```typescript
class MerkleTree {
  private leaves: Hash[]

  constructor(leaves: Hash[]) {
    this.leaves = [...leaves]
  }

  getRoot(): Hash {
    return Hash.merkleRoot(this.leaves)
  }

  addLeaf(leaf: Hash): void {
    this.leaves.push(leaf)
  }

  getLeaves(): Hash[] {
    return [...this.leaves]
  }
}
```

## Edge Cases

### Empty Array

```typescript
Hash.merkleRoot([]).equals(Hash.ZERO) // true
```

### Single Hash

```typescript
const single = Hash.keccak256String("test")
Hash.merkleRoot([single]).equals(single) // true
```

### Odd Number of Hashes

```typescript
const leaves = [
  Hash.keccak256String("tx1"),
  Hash.keccak256String("tx2"),
  Hash.keccak256String("tx3") // Odd number
]

// Last hash promoted to next level
const root = Hash.merkleRoot(leaves)
```

## Performance

Complexity: O(n) where n is number of leaves

```typescript
console.time('merkleRoot-1000')
const leaves = Array({ length: 1000 }, (_, i) =>
  Hash.keccak256String(`tx${i}`)
)
Hash.merkleRoot(leaves)
console.timeEnd('merkleRoot-1000') // ~20-30ms
```

## See Also

- [concat](/primitives/hash/concat) - Combine two hashes
- [keccak256](/primitives/hash/keccak256) - Hash individual items
- [BinaryTree](/primitives/binarytree) - Verkle tree implementation
