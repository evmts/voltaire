---
title: Hash.isZero
description: Check if hash is all zeros using constant-time comparison
---

<Tabs>

</Tabs>

## Implementation

Uses constant-time comparison against `Hash.ZERO` constant:

```typescript
let result = 0
for (let i = 0; i < hash.length; i++) {
  result |= hash[i]
}
return result === 0
```

**Constant-time guarantee:** Always checks all 32 bytes, preventing timing attacks.

## Usage Examples

### Checking Transaction Receipt Status

```typescript
async function isTransactionConfirmed(txHash: string): Promise<boolean> {
  const receipt = await provider.getTransactionReceipt(txHash)

  // Zero block hash indicates pending transaction
  const blockHash = Hash(receipt.blockHash)
  return !blockHash.isZero()
}
```

### Filtering Non-Zero Hashes

```typescript
const hashes = [
  Hash.keccak256String("hello"),
  Hash(Bytes32()), // zero hash
  Hash.keccak256String("world"),
  Hash.ZERO,
]

// Remove zero hashes
const nonZero = hashes.filter(hash => !hash.isZero())
console.log(nonZero.length) // 2
```

### Validating Hash Input

```typescript
function validateHash(hash: Hash): void {
  if (hash.isZero()) {
    throw new Error("Hash cannot be zero")
  }
}

// Usage
try {
  const userHash = Hash(userInput)
  validateHash(userHash)
} catch (e) {
  console.error("Invalid hash:", e.message)
}
```

### Merkle Tree Validation

```typescript
function validateMerkleTree(nodes: Hash[][]): void {
  for (let level = 0; level < nodes.length; level++) {
    for (const node of nodes[level]) {
      if (node.isZero() && level < nodes.length - 1) {
        throw new Error(`Invalid zero hash at level ${level}`)
      }
    }
  }
}
```

### Default Value Detection

```typescript
interface Transaction {
  hash: Hash
  blockHash: Hash
  nonce: bigint
}

function isPendingTransaction(tx: Transaction): boolean {
  // Pending transactions have zero block hash
  return tx.blockHash.isZero()
}

function isMinedTransaction(tx: Transaction): boolean {
  return !tx.blockHash.isZero()
}
```

### Cache Invalidation

```typescript
class HashCache {
  private cache = new Map<string, any>()

  set(hash: Hash, value: any): void {
    if (hash.isZero()) {
      throw new Error("Cannot cache zero hash")
    }
    this.cache.set(hash.toHex(), value)
  }

  get(hash: Hash): any | undefined {
    if (hash.isZero()) {
      return undefined
    }
    return this.cache.get(hash.toHex())
  }
}
```

### Sparse Array Processing

```typescript
// Process only non-zero hashes in sparse array
function processSparseHashes(hashes: Hash[]): number {
  let count = 0
  for (const hash of hashes) {
    if (!hash.isZero()) {
      // Process non-zero hash
      processHash(hash)
      count++
    }
  }
  return count
}
```

### State Root Validation

```typescript
function validateStateRoot(stateRoot: Hash): void {
  if (stateRoot.isZero()) {
    throw new Error("Invalid state root: cannot be zero")
  }
}

// Usage in block validation
function validateBlock(block: Block): void {
  validateStateRoot(block.stateRoot)
  validateStateRoot(block.transactionsRoot)
  validateStateRoot(block.receiptsRoot)
}
```

### Receipt Status Check

```typescript
interface Receipt {
  transactionHash: Hash
  blockHash: Hash
  status: number
}

async function waitForConfirmation(txHash: Hash): Promise<Receipt> {
  while (true) {
    const receipt = await provider.getTransactionReceipt(txHash)
    const blockHash = Hash(receipt.blockHash)

    if (!blockHash.isZero()) {
      // Transaction confirmed
      return receipt
    }

    // Wait and retry
    await new Promise(resolve => setTimeout(resolve, 1000))
  }
}
```

## ZERO Constant

Compare with `Hash.ZERO` constant for clarity:

```typescript
const zeroHash = Hash(Bytes32())

// Both equivalent
zeroHash.isZero() // true
zeroHash.equals(Hash.ZERO) // true

// ZERO constant
console.log(Hash.ZERO.toHex())
// "0x0000000000000000000000000000000000000000000000000000000000000000"
```

## Performance

**Constant-time:** Always checks all 32 bytes (~50ns). Same performance as `equals()`.

**Benchmark:**
```typescript
const zeroHash = Hash.ZERO
const nonZeroHash = Hash.keccak256String("hello")

// Zero hash check
console.time('isZero-true')
for (let i = 0; i < 100000; i++) {
  zeroHash.isZero()
}
console.timeEnd('isZero-true') // ~5ms = ~50ns each

// Non-zero hash check (same time)
console.time('isZero-false')
for (let i = 0; i < 100000; i++) {
  nonZeroHash.isZero()
}
console.timeEnd('isZero-false') // ~5ms = ~50ns each
```

## Common Patterns

### Null Object Pattern

```typescript
const NULL_HASH = Hash.ZERO

interface Transaction {
  hash: Hash
  parentHash: Hash
}

function getParentHash(tx: Transaction): Hash | null {
  return tx.parentHash.isZero() ? null : tx.parentHash
}
```

### Optional Hash

```typescript
function formatHash(hash: Hash): string {
  return hash.isZero() ? "None" : hash.format()
}

function displayHash(hash: Hash): string {
  return hash.isZero() ? "â€”" : hash.toHex()
}
```

### Conditional Processing

```typescript
function processTransaction(tx: Transaction): void {
  if (!tx.blockHash.isZero()) {
    // Confirmed transaction
    updateConfirmedBalance(tx)
  } else {
    // Pending transaction
    updatePendingBalance(tx)
  }
}
```

## See Also

- [equals](/primitives/hash/equals) - Compare two hashes (uses constant-time)
- [ZERO constant](/primitives/hash/constants) - Zero hash constant
- [fromBytes](/primitives/hash/from-bytes) - Create zero hash from Bytes32()
