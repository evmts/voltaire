---
title: Hash.fromHex
description: Create Hash from hex string (with or without 0x prefix)
---

<Tabs>

</Tabs>

## Hex Format Requirements

Hash hex strings must follow specific format requirements:

### Length

- **Without prefix:** Exactly 64 hex characters
- **With prefix:** Exactly 66 characters (`0x` + 64 hex chars)

```typescript
// Valid (64 hex chars)
Hash("1c8aff950685c2ed4bc3174f3472287b56d9517b9c948127319a09a7a36deac8")

// Valid (0x + 64 hex chars)
Hash("0x1c8aff950685c2ed4bc3174f3472287b56d9517b9c948127319a09a7a36deac8")

// Invalid (too short)
Hash("0x1c8aff") // Error: wrong length

// Invalid (too long)
Hash("0x1c8aff950685c2ed4bc3174f3472287b56d9517b9c948127319a09a7a36deac800") // Error
```

### Characters

Only valid hex characters allowed: `0-9`, `a-f`, `A-F`

```typescript
// Valid (lowercase)
Hash("0x1c8aff950685c2ed4bc3174f3472287b56d9517b9c948127319a09a7a36deac8")

// Valid (uppercase)
Hash("0x1C8AFF950685C2ED4BC3174F3472287B56D9517B9C948127319A09A7A36DEAC8")

// Valid (mixed case)
Hash("0x1C8aFf950685c2ED4bc3174F3472287b56d9517B9c948127319a09A7a36deAC8")

// Invalid (contains 'g')
Hash("0x1c8agg950685c2ed4bc3174f3472287b56d9517b9c948127319a09a7a36deac8") // Error
```

### Prefix Optional

The `0x` prefix is optional but recommended for clarity:

```typescript
// Both produce identical hashes
const hash1 = Hash("0x1c8aff950685c2ed4bc3174f3472287b56d9517b9c948127319a09a7a36deac8")
const hash2 = Hash("1c8aff950685c2ed4bc3174f3472287b56d9517b9c948127319a09a7a36deac8")

console.log(hash1.equals(hash2)) // true
```

## Usage Examples

### Parsing User Input

```typescript
function parseHashInput(input: string): Hash {
  // Validate before parsing
  if (!Hash.isValidHex(input)) {
    throw new Error("Invalid hash format")
  }
  return Hash(input)
}
```

### Loading from API

```typescript
interface ApiResponse {
  txHash: string
  blockHash: string
}

async function fetchTransaction(id: string) {
  const response: ApiResponse = await fetch(`/api/tx/${id}`).then(r => r.json())

  return {
    txHash: Hash(response.txHash),
    blockHash: Hash(response.blockHash)
  }
}
```

### Event Log Topics

```typescript
interface Log {
  topics: string[]
  data: string
}

function parseLog(log: Log) {
  return {
    topics: log.topics.map(topic => Hash(topic)),
    data: log.data
  }
}
```

### Transaction Receipts

```typescript
async function getReceipt(txHash: string) {
  const receipt = await provider.getTransactionReceipt(txHash)

  return {
    transactionHash: Hash(receipt.transactionHash),
    blockHash: Hash(receipt.blockHash),
    from: Address(receipt.from),
    to: Address(receipt.to)
  }
}
```

## Performance

**Parsing overhead:** Hex parsing requires decoding each pair of hex characters to bytes. For performance-critical code with pre-parsed bytes, use `fromBytes` instead.

**Validation:** `fromHex` validates length and hex characters. Use `isValidHex` to validate before parsing if validation errors are expected.

```typescript
// Fast path: avoid double validation
if (Hash.isValidHex(input)) {
  const hash = Hash(input) // No validation error
} else {
  // Handle invalid input
}

// Slow path: validation happens twice
try {
  const hash = Hash(input)
} catch (e) {
  // Handle error
}
```

## See Also

- [from](/primitives/hash/from) - Universal constructor (accepts hex or bytes)
- [fromBytes](/primitives/hash/from-bytes) - Create from Uint8Array directly
- [isValidHex](/primitives/hash/is-valid-hex) - Validate hex format before parsing
- [toHex](/primitives/hash/to-hex) - Convert Hash back to hex string
- [Hex](/primitives/hex) - Working with hex strings
