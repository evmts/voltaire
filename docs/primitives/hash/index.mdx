---
title: Hash
description: 32-byte Keccak-256 cryptographic hash primitives
---

# Hash

A Hash is a 32-byte cryptographic digest produced by the Keccak-256 algorithm. In Ethereum, hashes uniquely identify transactions, blocks, accounts, and data structures.

<Tip title="New to Hashes?">
Learn cryptographic hash fundamentals, Keccak-256 properties, and Merkle trees in the [Fundamentals Guide](/primitives/hash/fundamentals).
</Tip>

## Overview

Hash is represented as a [branded](/concepts/branded-types) [`Uint8Array`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array) following the [data-first pattern](/concepts/data-first) used throughout Voltaire.

```typescript
export type BrandedHash = Uint8Array & { readonly __tag: "Hash" };
```

## Quick Start

<Tabs>
<Tab title="Class API">

```typescript
import { Hash } from '@tevm/voltaire';

// Hash arbitrary data
const data = new Uint8Array([1, 2, 3, 4]);
const hash = Hash.keccak256(data);
console.log(hash.toHex());  // "0x9c22ff5f21f0b81b113e63f7db6da94fedef11b2119b4088b89664fb9a3cb658"

// Hash strings
const strHash = Hash.keccak256String("hello world");

// Hash hex data
const hexHash = Hash.keccak256Hex("0x1234");

// Compare hashes
if (hash.equals(strHash)) {
  console.log("Hashes match");
}

// Check for zero hash
if (hash.isZero()) {
  console.log("Empty hash");
}
```

</Tab>
<Tab title="Namespace API (Tree-shakeable)">

```typescript
import * as Hash from '@tevm/voltaire/Hash';

// Hash arbitrary data
const data = new Uint8Array([1, 2, 3, 4]);
const hash = Hash.keccak256(data);
console.log(Hash.toHex(hash));  // "0x9c22ff5f21f0b81b113e63f7db6da94fedef11b2119b4088b89664fb9a3cb658"

// Hash strings
const strHash = Hash.keccak256String("hello world");

// Hash hex data
const hexHash = Hash.keccak256Hex("0x1234");

// Compare hashes
if (Hash.equals(hash, strHash)) {
  console.log("Hashes match");
}

// Check for zero hash
if (Hash.isZero(hash)) {
  console.log("Empty hash");
}
```

</Tab>
</Tabs>

## Example: Transaction Identifiers

```typescript
import { Hash } from '@tevm/voltaire';

// Hash transaction data to create unique identifier
const txData = new Uint8Array([/* RLP-encoded transaction */]);
const txHash = Hash.keccak256(txData);

console.log(`Transaction ID: ${txHash.toHex()}`);

// Verify transaction later
const receivedTx = await provider.getTransaction(txHash.toHex());
const verifyHash = Hash.keccak256(receivedTx);
console.log(txHash.equals(verifyHash)); // true
```

## API Documentation

### Constructors

Create hash from hex strings, Uint8Array, or generic input.

    [View constructors →](./from)

### Hashing

Compute Keccak-256 hashes from bytes, strings, and hex data.

    [View hashing →](./keccak256)

### Conversions

Convert hashes to hex strings, bytes, and display formats.

    [View conversions →](./toHex)

### Comparisons

Compare hash equality and check for zero values.

    [View comparisons →](./equals)

### Validation

Validate hash format and check type constraints.

    [View validation →](./isHash)

### Utilities

Generate random hashes, clone, slice, and format for display.

    [View utilities →](./random)

### All Methods

<Tabs>
<Tab title="Class API">

**Constructors:**
- `Hash.from(value)` - Universal constructor from any input
- `Hash.fromHex(hex)` - Parse hex string (with or without 0x prefix)
- `Hash.fromBytes(bytes)` - Create from Uint8Array (must be 32 bytes)

**Hashing:**
- `Hash.keccak256(data)` - Hash Uint8Array data
- `Hash.keccak256String(str)` - Hash UTF-8 string
- `Hash.keccak256Hex(hex)` - Hash hex string (with or without 0x)

**Conversions:**
- `hash.toHex()` - Convert to hex string with 0x prefix
- `hash.toBytes()` - Convert to Uint8Array
- `hash.toString()` - Convert to hex string (alias for toHex)
- `hash.format()` - Format as abbreviated string (0x123456...abcdef)

**Comparisons:**
- `hash.equals(other)` - Compare hash equality
- `hash.isZero()` - Check if hash is all zeros

**Validation:**
- `Hash.isHash(value)` - Type guard checking if value is BrandedHash
- `Hash.isValidHex(hex)` - Check if hex string is valid 32-byte hash
- `Hash.assert(value)` - Assert value is valid hash (throws if not)

**Utilities:**
- `Hash.random()` - Generate cryptographically random hash
- `hash.clone()` - Create copy of hash
- `hash.slice(start, end)` - Extract portion as new Uint8Array
- `Hash.concat(...hashes)` - Concatenate multiple hashes
- `Hash.merkleRoot(hashes)` - Compute Merkle root from hash array

**Constants:**
- `Hash.SIZE` - Hash size in bytes (32)
- `Hash.ZERO` - Zero hash constant (32 zero bytes)

</Tab>
<Tab title="Namespace API (Tree-shakeable)">

**Constructors:**
- `from(value)` - Universal constructor from any input
- `fromHex(hex)` - Parse hex string (with or without 0x prefix)
- `fromBytes(bytes)` - Create from Uint8Array (must be 32 bytes)

**Hashing:**
- `keccak256(data)` - Hash Uint8Array data
- `keccak256String(str)` - Hash UTF-8 string
- `keccak256Hex(hex)` - Hash hex string (with or without 0x)

**Conversions:**
- `toHex(hash)` - Convert to hex string with 0x prefix
- `toBytes(hash)` - Convert to Uint8Array
- `toString(hash)` - Convert to hex string (alias for toHex)
- `format(hash)` - Format as abbreviated string (0x123456...abcdef)

**Comparisons:**
- `equals(a, b)` - Compare hash equality
- `isZero(hash)` - Check if hash is all zeros

**Validation:**
- `isHash(value)` - Type guard checking if value is BrandedHash
- `isValidHex(hex)` - Check if hex string is valid 32-byte hash
- `assert(value)` - Assert value is valid hash (throws if not)

**Utilities:**
- `random()` - Generate cryptographically random hash
- `clone(hash)` - Create copy of hash
- `slice(hash, start, end)` - Extract portion as new Uint8Array
- `concat(...hashes)` - Concatenate multiple hashes
- `merkleRoot(hashes)` - Compute Merkle root from hash array

**Constants:**
- `SIZE` - Hash size in bytes (32)
- `ZERO` - Zero hash constant (32 zero bytes)

</Tab>
</Tabs>

## Types

<Tabs>
<Tab title="BrandedHash">

```typescript
export type BrandedHash = Uint8Array & {
  readonly __tag: "Hash";
};
```

Main branded type. Runtime is `Uint8Array`, TypeScript enforces type safety.

</Tab>
<Tab title="HashLike">

```typescript
type HashLike =
  | Uint8Array
  | BrandedHash
  | Hash
  | Hex
  | string;
```

Union type accepting any input that can be coerced to hash. Accepted by `Hash.from()`.

See [Hash.from](./from#hashlike-type) for details.

</Tab>
</Tabs>


## Tree-Shaking

Import only what you need for optimal bundle size:

```typescript
// Import specific functions (tree-shakeable)
import { keccak256, toHex, equals } from '@tevm/voltaire/BrandedHash';

const hash = keccak256(data);
const hex = toHex(hash);
const isEqual = equals(hash, otherHash);

// Only these 3 functions included in bundle
// Unused functions (random, merkleRoot, etc.) excluded
```

<Tip title="Bundle Impact">
Importing from `@tevm/voltaire/BrandedHash` instead of `@tevm/voltaire` enables tree-shaking. For example, if you only need `keccak256` and `toHex`, Merkle tree computation and random generation are excluded from your bundle.
</Tip>

## Related

### Hex

Hex string encoding and decoding utilities.

    [View →](/primitives/hex)

### Bytecode

EVM bytecode that gets hashed for verification.

    [View →](/primitives/bytecode)

### Address

20-byte addresses derived from Keccak-256 hashes.

    [View →](/primitives/address)

## Specification References

- [Keccak Team](https://keccak.team/keccak.html) - Official Keccak specification
- [Ethereum Yellow Paper](https://ethereum.github.io/yellowpaper/paper.pdf) - Keccak-256 usage in Ethereum
- [NIST FIPS 202](https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.202.pdf) - SHA-3 standard (Keccak basis)
- [EIP-55](https://eips.ethereum.org/EIPS/eip-55) - Mixed-case checksum address encoding using Keccak-256
