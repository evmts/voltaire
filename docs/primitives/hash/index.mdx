---
title: Hash
description: 32-byte Keccak-256 cryptographic hash primitives
---

# Hash

A Hash is a 32-byte cryptographic digest produced by the Keccak-256 algorithm. In Ethereum, hashes uniquely identify transactions, blocks, accounts, and data structures.

<Tip title="New to Hashes?">
Learn cryptographic hash fundamentals, Keccak-256 properties, and Merkle trees in the [Fundamentals Guide](/primitives/hash/fundamentals).
</Tip>

## Overview

Hash is represented as a [branded](/concepts/branded-types) [`Uint8Array`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array) following the [data-first pattern](/concepts/data-first) used throughout Voltaire.

```typescript
export type BrandedHash = Uint8Array & { readonly __tag: "Hash" };
```

## Quick Start

<Tabs>
<Tab title="Class API">

```typescript
import { Hash } from '@tevm/voltaire';

// Hash arbitrary data
const data = new Uint8Array([1, 2, 3, 4]);
const hash = Hash.keccak256(data);
console.log(hash.toHex());  // "0x9c22ff5f21f0b81b113e63f7db6da94fedef11b2119b4088b89664fb9a3cb658"

// Hash strings
const strHash = Hash.keccak256String("hello world");

// Hash hex data
const hexHash = Hash.keccak256Hex("0x1234");

// Compare hashes
if (hash.equals(strHash)) {
  console.log("Hashes match");
}

// Check for zero hash
if (hash.isZero()) {
  console.log("Empty hash");
}
```

</Tab>
<Tab title="Namespace API (Tree-shakeable)">

```typescript
import * as Hash from '@tevm/voltaire/Hash';

// Hash arbitrary data
const data = new Uint8Array([1, 2, 3, 4]);
const hash = Hash.keccak256(data);
console.log(Hash.toHex(hash));  // "0x9c22ff5f21f0b81b113e63f7db6da94fedef11b2119b4088b89664fb9a3cb658"

// Hash strings
const strHash = Hash.keccak256String("hello world");

// Hash hex data
const hexHash = Hash.keccak256Hex("0x1234");

// Compare hashes
if (Hash.equals(hash, strHash)) {
  console.log("Hashes match");
}

// Check for zero hash
if (Hash.isZero(hash)) {
  console.log("Empty hash");
}
```

</Tab>
</Tabs>

## Example: Transaction Identifiers

```typescript
import { Hash } from '@tevm/voltaire';

// Hash transaction data to create unique identifier
const txData = new Uint8Array([/* RLP-encoded transaction */]);
const txHash = Hash.keccak256(txData);

console.log(`Transaction ID: ${txHash.toHex()}`);

// Verify transaction later
const receivedTx = await provider.getTransaction(txHash.toHex());
const verifyHash = Hash.keccak256(receivedTx);
console.log(txHash.equals(verifyHash)); // true
```

## API Methods

### Constructors

- [`from(value)`](./from) - Universal constructor from any input
- [`fromHex(hex)`](./from-hex) - Parse hex string (with or without 0x prefix)
- [`fromBytes(bytes)`](./from-bytes) - Create from Uint8Array (must be 32 bytes)

### Hashing

- [`keccak256(data)`](./keccak256) - Hash Uint8Array data
- [`keccak256String(str)`](./keccak256-string) - Hash UTF-8 string
- [`keccak256Hex(hex)`](./keccak256-hex) - Hash hex string (with or without 0x)

### Conversions

- [`toHex(hash)`](./to-hex) - Convert to hex string with 0x prefix
- [`toBytes(hash)`](./to-bytes) - Convert to Uint8Array
- [`toString(hash)`](./to-string) - Convert to hex string (alias for toHex)
- [`format(hash)`](./format) - Format as abbreviated string (0x123456...abcdef)

### Comparisons

- [`equals(a, b)`](./equals) - Compare hash equality
- [`isZero(hash)`](./is-zero) - Check if hash is all zeros

### Validation

- [`isHash(value)`](./is-hash) - Type guard checking if value is BrandedHash
- [`isValidHex(hex)`](./is-valid-hex) - Check if hex string is valid 32-byte hash
- [`assert(value)`](./assert) - Assert value is valid hash (throws if not)

### Utilities

- [`random()`](./random) - Generate cryptographically random hash
- [`clone(hash)`](./clone) - Create copy of hash
- [`slice(hash, start, end)`](./slice) - Extract portion as new Uint8Array
- [`concat(...hashes)`](./concat) - Concatenate multiple hashes
- [`merkleRoot(hashes)`](./merkle-root) - Compute Merkle root from hash array


## Types

<Tabs>
<Tab title="BrandedHash">

```typescript
export type BrandedHash = Uint8Array & {
  readonly __tag: "Hash";
};
```

Main branded type. Runtime is `Uint8Array`, TypeScript enforces type safety.

</Tab>
<Tab title="HashLike">

```typescript
type HashLike =
  | Uint8Array
  | BrandedHash
  | Hash
  | Hex
  | string;
```

Union type accepting any input that can be coerced to hash. Accepted by `Hash.from()`.

See [Hash.from](./from#hashlike-type) for details.

</Tab>
</Tabs>


## Tree-Shaking

Import only what you need for optimal bundle size:

```typescript
// Import specific functions (tree-shakeable)
import { keccak256, toHex, equals } from '@tevm/voltaire/BrandedHash';

const hash = keccak256(data);
const hex = toHex(hash);
const isEqual = equals(hash, otherHash);

// Only these 3 functions included in bundle
// Unused functions (random, merkleRoot, etc.) excluded
```

<Tip title="Bundle Impact">
Importing from `@tevm/voltaire/BrandedHash` instead of `@tevm/voltaire` enables tree-shaking. For example, if you only need `keccak256` and `toHex`, Merkle tree computation and random generation are excluded from your bundle.
</Tip>

## Related

### Hex

Hex string encoding and decoding utilities.

    [View →](/primitives/hex)

### Bytecode

EVM bytecode that gets hashed for verification.

    [View →](/primitives/bytecode)

### Address

20-byte addresses derived from Keccak-256 hashes.

    [View →](/primitives/address)

## Specification References

- [Keccak Team](https://keccak.team/keccak.html) - Official Keccak specification
- [Ethereum Yellow Paper](https://ethereum.github.io/yellowpaper/paper.pdf) - Keccak-256 usage in Ethereum
- [NIST FIPS 202](https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.202.pdf) - SHA-3 standard (Keccak basis)
- [EIP-55](https://eips.ethereum.org/EIPS/eip-55) - Mixed-case checksum address encoding using Keccak-256
