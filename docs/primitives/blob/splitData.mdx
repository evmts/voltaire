---
title: Blob.splitData
description: Split large data into multiple blobs
---

<Tabs>
<Tab title="Class API">

## Signature

```typescript
Blob.splitData(data: Uint8Array): Blob[]
```

Split large data into multiple blobs with standard encoding. Each blob stores a chunk with length prefix. Maximum 6 blobs per call (transaction limit).

### Parameters

- **data** `Uint8Array` - Data to split (max ~786,384 bytes for 6 blobs)

### Returns

`Blob[]` - Array of blobs containing the data

### Throws

- If data requires more than 6 blobs (transaction limit)

### Example

```typescript
import { Blob } from '@tevm/voltaire';

// Large L2 batch (300 KB)
const largeData = new Uint8Array(300_000);

// Check blob count
const count = Blob.estimateBlobCount(largeData);
console.log(`Requires ${count} blobs`); // 3 blobs

// Split into blobs
const blobs = Blob.splitData(largeData);
console.log(blobs.length); // 3
console.log(blobs[0].length); // 131,072

// Each blob is 131,072 bytes
blobs.forEach((blob, i) => {
  console.log(`Blob ${i}: ${blob.length} bytes`);
});
```

### Example: Transaction with Multiple Blobs

```typescript
import { Blob } from '@tevm/voltaire';

const largeData = new Uint8Array(300_000);
const blobs = Blob.splitData(largeData);

// Generate commitments and proofs
const commitments = blobs.map(b => Blob.toCommitment(b));
const proofs = blobs.map(b => Blob.toProof(b));
const versionedHashes = commitments.map(c =>
  Blob.Commitment.toVersionedHash(c)
);

// Create transaction
const tx = {
  type: '0x03',
  blobVersionedHashes: versionedHashes,
  maxFeePerBlobGas: 100_000_000n,
  blobs: blobs,
  commitments: commitments,
  proofs: proofs,
};

// Later: reconstruct data
const reconstructed = Blob.joinData(blobs);
console.log(Blob.equals(reconstructed, largeData)); // true
```

### Defined in

[src/primitives/Blob/BrandedBlob/splitData.js](https://github.com/tevm/voltaire/blob/main/src/primitives/Blob/BrandedBlob/splitData.js)

</Tab>
<Tab title="Namespace API">

## Signature

```typescript
splitData(data: Uint8Array): BrandedBlob[]
```

Split large data into multiple blobs with standard encoding. Each blob stores a chunk with length prefix. Maximum 6 blobs per call (transaction limit).

### Parameters

- **data** `Uint8Array` - Data to split (max ~786,384 bytes for 6 blobs)

### Returns

`BrandedBlob[]` - Array of blobs containing the data

### Throws

- If data requires more than 6 blobs (transaction limit)

### Example

```typescript
import * as Blob from '@tevm/voltaire/Blob';

const largeData = new Uint8Array(300_000);
const blobs = Blob.splitData(largeData);

console.log(blobs.length); // 3
```

### Defined in

[src/primitives/Blob/BrandedBlob/splitData.js](https://github.com/tevm/voltaire/blob/main/src/primitives/Blob/BrandedBlob/splitData.js)

</Tab>
<Tab title="Zig">

## Signature

```zig
pub fn splitData(allocator: std.mem.Allocator, data: []const u8) ![]Blob
```

Split data into multiple blobs.

### Parameters

- **allocator** `std.mem.Allocator` - Memory allocator
- **data** `[]const u8` - Data to split

### Returns

`[]Blob` - Allocated array of blobs (caller owns memory)

### Errors

- `error.DataTooLarge` - Requires more than 6 blobs

### Example

```zig
const Blob = @import("primitives").Blob;

var large_data: [300_000]u8 = undefined;
const blobs = try Blob.splitData(allocator, &large_data);
defer {
    for (blobs) |blob| blob.deinit(allocator);
    allocator.free(blobs);
}

std.debug.print("Created {} blobs\n", .{blobs.len});
```

</Tab>
</Tabs>

## Data Distribution

Each blob stores a chunk with encoding:

```
Blob 1: [length_1][chunk_1][padding]
Blob 2: [length_2][chunk_2][padding]
Blob 3: [length_3][chunk_3][padding]
...

Max per blob: 131,064 bytes (SIZE - 8 for length prefix)
```

### Example: Size Calculation

```typescript
import { Blob } from '@tevm/voltaire';

const maxPerBlob = Blob.SIZE - 8; // 131,064 bytes
console.log(`Max data per blob: ${maxPerBlob}`);

const data = new Uint8Array(300_000);
const blobCount = Math.ceil(data.length / maxPerBlob);
console.log(`Requires ${blobCount} blobs`); // 3

// Verify with estimateBlobCount
console.log(Blob.estimateBlobCount(data)); // 3
```

## Maximum Data Size

```typescript
import { Blob } from '@tevm/voltaire';

const maxPerBlob = Blob.SIZE - 8;
const maxData = maxPerBlob * Blob.MAX_PER_TRANSACTION;

console.log(`Max per blob: ${maxPerBlob} bytes`); // 131,064
console.log(`Max per tx: ${maxData} bytes`); // 786,384
console.log(`Max blobs per tx: ${Blob.MAX_PER_TRANSACTION}`); // 6

// This succeeds (exactly at limit)
const atLimit = new Uint8Array(maxData);
const blobs = Blob.splitData(atLimit);
console.log(blobs.length); // 6

// This fails (exceeds limit)
try {
  const tooLarge = new Uint8Array(maxData + 1);
  Blob.splitData(tooLarge);
} catch (e) {
  console.error(e); // "Data too large: requires 7 blobs (max 6)"
}
```

## Reconstruction

Use `joinData()` to reconstruct original data:

```typescript
import { Blob } from '@tevm/voltaire';

const original = new Uint8Array(300_000);
// ... fill with data ...

// Split
const blobs = Blob.splitData(original);

// Reconstruct
const reconstructed = Blob.joinData(blobs);

// Verify
console.log(reconstructed.length === original.length); // true
console.log(Blob.equals(reconstructed, original)); // true
```

## Gas Estimation

```typescript
import { Blob } from '@tevm/voltaire';

const data = new Uint8Array(300_000);
const blobCount = Blob.estimateBlobCount(data);

// Calculate gas cost
const blobBaseFee = 50_000_000n; // 50 gwei
const blobGas = Blob.calculateGas(blobCount, blobBaseFee);

console.log(`${blobCount} blobs required`);
console.log(`Blob gas cost: ${blobGas / 10n**9n} gwei`);
```

## See Also

- [joinData](./joinData) - Reconstruct data from blobs
- [estimateBlobCount](./estimateBlobCount) - Estimate blob count
- [fromData](./fromData) - Encode single blob
- [toData](./toData) - Extract blob data
