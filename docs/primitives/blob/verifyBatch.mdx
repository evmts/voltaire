---
title: Blob.verifyBatch
description: Batch verify multiple blob proofs (more efficient)
---

<Tabs>
<Tab title="Class API">

## Signature

```typescript
Blob.verifyBatch(
  blobs: Blob[],
  commitments: Commitment[],
  proofs: Proof[]
): boolean
```

Verify multiple KZG proofs in a single batch operation. More efficient than verifying individually.

### Parameters

- **blobs** `Blob[]` - Array of blobs
- **commitments** `Commitment[]` - Array of commitments (same length as blobs)
- **proofs** `Proof[]` - Array of proofs (same length as blobs)

### Returns

`boolean` - `true` if all proofs valid, `false` if any invalid

### Throws

- If arrays have different lengths
- If any blob/commitment/proof has invalid size
- If KZG library not available

### Example

```typescript
import { Blob } from '@tevm/voltaire';

const blobs = [blob1, blob2, blob3];
const commitments = blobs.map(b => Blob.toCommitment(b));
const proofs = blobs.map(b => Blob.toProof(b));

// Batch verify (faster than 3 individual verifications)
const allValid = Blob.verifyBatch(blobs, commitments, proofs);

if (!allValid) {
  // Find which blob failed
  for (let i = 0; i < blobs.length; i++) {
    const valid = Blob.verify(blobs[i], commitments[i], proofs[i]);
    if (!valid) {
      console.error(`Blob ${i} failed verification`);
    }
  }
}
```

### Example: Transaction Validation

```typescript
import { Blob } from '@tevm/voltaire';

// Received blob transaction
const tx = {
  blobs: [blob1, blob2, blob3],
  commitments: [commitment1, commitment2, commitment3],
  proofs: [proof1, proof2, proof3],
  blobVersionedHashes: [hash1, hash2, hash3],
};

// Verify all blobs at once
const proofsValid = Blob.verifyBatch(
  tx.blobs,
  tx.commitments,
  tx.proofs
);

if (!proofsValid) {
  throw new Error('Invalid blob proofs');
}

// Verify versioned hashes
for (let i = 0; i < tx.blobs.length; i++) {
  const computed = Blob.Commitment.toVersionedHash(tx.commitments[i]);
  if (!Blob.equals(computed, tx.blobVersionedHashes[i])) {
    throw new Error(`Hash mismatch for blob ${i}`);
  }
}

console.log('All blobs verified');
```

### Defined in

[src/primitives/Blob/BrandedBlob/verifyBatch.js](https://github.com/tevm/voltaire/blob/main/src/primitives/Blob/BrandedBlob/verifyBatch.js)

</Tab>
<Tab title="Namespace API">

## Signature

```typescript
verifyBatch(
  blobs: BrandedBlob[],
  commitments: Commitment[],
  proofs: Proof[]
): boolean
```

Verify multiple KZG proofs in a single batch operation. More efficient than verifying individually.

### Parameters

- **blobs** `BrandedBlob[]` - Array of blobs
- **commitments** `Commitment[]` - Array of commitments
- **proofs** `Proof[]` - Array of proofs

### Returns

`boolean` - `true` if all proofs valid, `false` if any invalid

### Example

```typescript
import * as Blob from '@tevm/voltaire/Blob';

const blobs = [blob1, blob2, blob3];
const commitments = blobs.map(b => Blob.toCommitment(b));
const proofs = blobs.map(b => Blob.toProof(b));

const allValid = Blob.verifyBatch(blobs, commitments, proofs);
console.log(allValid); // true
```

### Defined in

[src/primitives/Blob/BrandedBlob/verifyBatch.js](https://github.com/tevm/voltaire/blob/main/src/primitives/Blob/BrandedBlob/verifyBatch.js)

</Tab>
<Tab title="Zig">

## Signature

```zig
pub fn verifyBatch(
    blobs: []const Blob,
    commitments: []const Commitment,
    proofs: []const Proof
) !bool
```

Batch verify multiple blob proofs.

### Parameters

- **blobs** `[]const Blob` - Array of blobs
- **commitments** `[]const Commitment` - Array of commitments
- **proofs** `[]const Proof` - Array of proofs

### Returns

`bool` - `true` if all valid

### Errors

- `error.ArrayLengthMismatch` - Arrays different lengths
- `error.KzgNotAvailable` - KZG library not loaded

### Example

```zig
const Blob = @import("primitives").Blob;

const blobs = [_]Blob{ blob1, blob2, blob3 };
const commitments = [_]Blob.Commitment{ c1, c2, c3 };
const proofs = [_]Blob.Proof{ p1, p2, p3 };

const all_valid = try Blob.verifyBatch(&blobs, &commitments, &proofs);
std.debug.print("Valid: {}\n", .{all_valid});
```

</Tab>
</Tabs>

## Performance

Batch verification is significantly faster than individual verification:

```typescript
import { Blob } from '@tevm/voltaire';

const blobs = [blob1, blob2, blob3, blob4, blob5, blob6];
const commitments = blobs.map(b => b.toCommitment());
const proofs = blobs.map(b => b.toProof());

// Individual verification (slower)
console.time('individual');
const results = blobs.map((blob, i) =>
  Blob.verify(blob, commitments[i], proofs[i])
);
const allValid1 = results.every(r => r);
console.timeEnd('individual'); // ~60ms

// Batch verification (faster)
console.time('batch');
const allValid2 = Blob.verifyBatch(blobs, commitments, proofs);
console.timeEnd('batch'); // ~20ms

console.log(allValid1 === allValid2); // true
```

## Finding Invalid Blobs

If batch verification fails, find which blob is invalid:

```typescript
import { Blob } from '@tevm/voltaire';

const blobs = [blob1, blob2, blob3];
const commitments = [c1, c2, c3];
const proofs = [p1, p2, p3];

// Batch verify
const allValid = Blob.verifyBatch(blobs, commitments, proofs);

if (!allValid) {
  console.error('Batch verification failed');

  // Find invalid blob(s)
  const invalid: number[] = [];
  for (let i = 0; i < blobs.length; i++) {
    const valid = Blob.verify(blobs[i], commitments[i], proofs[i]);
    if (!valid) {
      invalid.push(i);
    }
  }

  console.error(`Invalid blobs: ${invalid.join(', ')}`);
}
```

## Array Length Validation

```typescript
import { Blob } from '@tevm/voltaire';

const blobs = [blob1, blob2];
const commitments = [c1, c2, c3]; // Wrong length
const proofs = [p1, p2];

try {
  Blob.verifyBatch(blobs, commitments, proofs);
} catch (e) {
  console.error(e); // "Array lengths must match"
}
```

## Empty Arrays

```typescript
import { Blob } from '@tevm/voltaire';

// Empty arrays (valid - vacuous truth)
const result = Blob.verifyBatch([], [], []);
console.log(result); // true
```

## Use in Validators

```typescript
import { Blob } from '@tevm/voltaire';

class BlobTransactionValidator {
  validate(tx: BlobTransaction): boolean {
    // Check array lengths
    if (
      tx.blobs.length !== tx.commitments.length ||
      tx.blobs.length !== tx.proofs.length ||
      tx.blobs.length !== tx.blobVersionedHashes.length
    ) {
      return false;
    }

    // Batch verify proofs
    if (!Blob.verifyBatch(tx.blobs, tx.commitments, tx.proofs)) {
      return false;
    }

    // Verify versioned hashes
    for (let i = 0; i < tx.blobs.length; i++) {
      const computed = Blob.Commitment.toVersionedHash(tx.commitments[i]);
      if (!Blob.equals(computed, tx.blobVersionedHashes[i])) {
        return false;
      }
    }

    return true;
  }
}
```

## See Also

- [verify](./verify) - Verify single blob
- [toCommitment](./toCommitment) - Generate commitment
- [toProof](./toProof) - Generate proof
- [KZG](/primitives/blob/kzg) - KZG verification details
