---
title: BloomFilter Operations
description: Adding items and merging bloom filters
---

# Operations

Methods for modifying bloom filters by adding items and merging multiple filters.

## Add Operation

<Tabs>
<Tab title="TypeScript">

### `filter.add(item)` / `BloomFilter.add(filter, item)`

Adds an item to the bloom filter by setting `k` bits based on hash functions.

```typescript
import { BloomFilter } from '@tevm/voltaire'

const filter = BloomFilter.create(2048, 3)

// Add Ethereum address
const address = Address.from("0x742d35Cc6634C0532925a3b844Bc9e7595f51e3e")
filter.add(address)

// Add event topic hash
const topic = keccak256(new TextEncoder().encode("Transfer(address,address,uint256)"))
filter.add(topic)

// Add arbitrary data
const data = new TextEncoder().encode("custom-identifier")
filter.add(data)
```

**Parameters:**
- `filter: BrandedBloomFilter` - Bloom filter to modify
- `item: Uint8Array` - Item to add (arbitrary byte array)

**Returns:** `void` - Modifies filter in place

**Behavior:**
1. Computes `k` hash values from `item` using different seeds (0 to k-1)
2. For each hash value `h`:
   - Calculates byte index: `idx = floor(h / 8)`
   - Calculates bit position: `bit = h % 8`
   - Sets bit: `filter[idx] |= (1 << bit)`
3. If bit already set, no change (idempotent operation)

```typescript
// Example with k=3, m=2048
const filter = BloomFilter.create(2048, 3)
const item = new TextEncoder().encode("Transfer")

// Computes 3 hashes:
//   hash(item, 0, 2048) → sets bit at position h0
//   hash(item, 1, 2048) → sets bit at position h1
//   hash(item, 2, 2048) → sets bit at position h2

filter.add(item)

// Adding same item again has no effect (bits already set)
filter.add(item)
```

Defined in: [BrandedBloomFilter/add.js:3-27](https://github.com/evmts/voltaire/blob/main/src/primitives/BloomFilter/BrandedBloomFilter/add.js#L3-L27)

</Tab>
<Tab title="Zig">

### `BloomFilter.add(self: *BloomFilter, item: []const u8) void`

Adds item to bloom filter by setting `k` bits based on hash functions. Mutates filter in place.

**Parameters:**
- `self: *BloomFilter` - Pointer to bloom filter
- `item: []const u8` - Item to add (arbitrary byte slice)

**Returns:** `void` - Modifies filter in place

**Example:**

```zig
const std = @import("std");
const BloomFilter = @import("primitives").BloomFilter;

var gpa = std.heap.GeneralPurposeAllocator(.{}){};
defer _ = gpa.deinit();
const allocator = gpa.allocator();

var filter = try BloomFilter.init(allocator, 1000, 3);
defer filter.deinit(allocator);

// Add item
const item = "Transfer";
filter.add(item);

// Add multiple items
filter.add("Approval");
filter.add("Swap");

// Idempotent - adding same item again has no effect
filter.add("Transfer");
```

**Defined in:** [primitives/BloomFilter/bloom_filter.zig:26](https://github.com/evmts/voltaire/blob/main/src/primitives/BloomFilter/bloom_filter.zig#L26)

</Tab>
</Tabs>

### Adding Multiple Items

```typescript
import { BloomFilter } from '@tevm/voltaire'

const filter = BloomFilter.create(2048, 3)

// Add multiple addresses
const addresses = [
  "0x742d35Cc6634C0532925a3b844Bc9e7595f51e3e",
  "0x1234567890123456789012345678901234567890",
  "0xabcdefabcdefabcdefabcdefabcdefabcdefabcd"
]

for (const addr of addresses) {
  filter.add(Address.from(addr))
}

// Add multiple event topics
const events = ["Transfer", "Approval", "Swap"]
for (const event of events) {
  const topic = keccak256(new TextEncoder().encode(`${event}(address,address,uint256)`))
  filter.add(topic)
}
```

### Mutation Warning

<Warning title="In-Place Modification">
`add()` modifies the filter in place. Create a copy if you need to preserve the original:

```typescript
const original = BloomFilter.create(2048, 3)

// Create copy before modifying
const modified = original.slice()
modified.add(item)

// original unchanged, modified contains item
```
</Warning>

## Merge Operation

### `filter.merge(other)` / `BloomFilter.merge(filter1, filter2)`

Merges two bloom filters using bitwise OR. Returns new filter containing union of both sets.

<Tabs>
<Tab title="Instance Method">
```typescript
import { BloomFilter } from '@tevm/voltaire'

// Create filters for different blocks
const block1Filter = BloomFilter.create(2048, 3)
block1Filter.add(address1)
block1Filter.add(topic1)

const block2Filter = BloomFilter.create(2048, 3)
block2Filter.add(address2)
block2Filter.add(topic2)

// Merge into single filter
const rangeFilter = block1Filter.merge(block2Filter)

// rangeFilter contains items from both blocks
console.log(rangeFilter.contains(address1))  // true
console.log(rangeFilter.contains(address2))  // true
console.log(rangeFilter.contains(topic1))    // true
console.log(rangeFilter.contains(topic2))    // true
```
</Tab>
<Tab title="Static Method">
```typescript
import { BloomFilter } from '@tevm/voltaire'

const filter1 = BloomFilter.create(2048, 3)
const filter2 = BloomFilter.create(2048, 3)

// Static method - data-first pattern
const merged = BloomFilter.merge(filter1, filter2)
```
</Tab>
</Tabs>

**Parameters:**
- `filter1: BrandedBloomFilter` - First bloom filter
- `filter2: BrandedBloomFilter` - Second bloom filter

**Returns:** `BloomFilter` - New filter containing union of both sets

**Throws:**
- `InvalidBloomFilterParameterError` - If filters have different `m` or `k` values
- `InvalidBloomFilterParameterError` - If filters have different byte lengths

**Requirements:**
- Both filters must have same `m` (bit count)
- Both filters must have same `k` (hash function count)
- Both filters must have same byte length

```typescript
// Valid merge (same parameters)
const f1 = BloomFilter.create(2048, 3)
const f2 = BloomFilter.create(2048, 3)
const merged = f1.merge(f2)  // ✓ works

// Invalid merge (different parameters)
const f3 = BloomFilter.create(1024, 2)
try {
  f1.merge(f3)  // ✗ throws
} catch (e) {
  console.log(e.message)  // "Cannot merge filters with different parameters"
}
```

Defined in: [BrandedBloomFilter/merge.js:3-60](https://github.com/evmts/voltaire/blob/main/src/primitives/BloomFilter/BrandedBloomFilter/merge.js#L3-L60)

### Merge Algorithm

Merge performs bitwise OR on each byte:

```typescript
// For each byte i in range [0, length):
//   result[i] = filter1[i] | filter2[i]

// Example:
// filter1[0] = 0b00001111
// filter2[0] = 0b11110000
// result[0]  = 0b11111111

const f1 = BloomFilter.create(2048, 3)
f1.add(new TextEncoder().encode("item1"))

const f2 = BloomFilter.create(2048, 3)
f2.add(new TextEncoder().encode("item2"))

const merged = f1.merge(f2)

// merged contains both items
console.log(merged.contains(new TextEncoder().encode("item1")))  // true
console.log(merged.contains(new TextEncoder().encode("item2")))  // true
```

### Merging Multiple Filters

```typescript
import { BloomFilter } from '@tevm/voltaire'

// Merge block range filters
function mergeBlockRange(startBlock: number, endBlock: number): BloomFilter {
  let rangeFilter = BloomFilter.create(2048, 3)

  for (let i = startBlock; i <= endBlock; i++) {
    const blockFilter = await fetchBlockBloomFilter(i)
    rangeFilter = rangeFilter.merge(blockFilter)
  }

  return rangeFilter
}

// Usage: Check if address appears in block range
const rangeFilter = await mergeBlockRange(1000, 1100)
const address = Address.from("0x...")

if (rangeFilter.contains(address)) {
  // Address might appear in blocks 1000-1100
  // Scan individual blocks for confirmation
}
```

### Functional Reduce Pattern

```typescript
import { BloomFilter } from '@tevm/voltaire'

// Merge array of filters using reduce
const filters: BloomFilter[] = [
  BloomFilter.fromHex(block1.logsBloom, 2048, 3),
  BloomFilter.fromHex(block2.logsBloom, 2048, 3),
  BloomFilter.fromHex(block3.logsBloom, 2048, 3)
]

const combined = filters.reduce(
  (acc, filter) => acc.merge(filter),
  BloomFilter.create(2048, 3)  // Initial empty filter
)

// Check if any block contains address
if (combined.contains(address)) {
  // At least one block might contain this address
}
```

## Performance Considerations

### Add Performance

```typescript
// Time complexity: O(k)
// Space complexity: O(1)

const filter = BloomFilter.create(2048, 3)  // k=3

// Each add() performs:
// - 3 hash computations
// - 3 byte reads
// - 3 byte writes

filter.add(item)  // ~O(3) operations
```

### Merge Performance

```typescript
// Time complexity: O(m/8) where m is bit count
// Space complexity: O(m/8) for result

const f1 = BloomFilter.create(2048, 3)  // 256 bytes
const f2 = BloomFilter.create(2048, 3)  // 256 bytes

// merge() performs:
// - 256 byte reads from f1
// - 256 byte reads from f2
// - 256 OR operations
// - 256 byte writes to result

const merged = f1.merge(f2)  // ~O(256) operations
```

### Batch Operations

```typescript
import { BloomFilter } from '@tevm/voltaire'

// Efficient: Single filter for batch
const filter = BloomFilter.create(2048, 3)
items.forEach(item => filter.add(item))  // O(n * k)

// Inefficient: Merge after each add
let filter2 = BloomFilter.create(2048, 3)
for (const item of items) {
  const temp = BloomFilter.create(2048, 3)
  temp.add(item)
  filter2 = filter2.merge(temp)  // O(n * m/8) - much slower!
}
```

## Tree-Shakeable Usage

```typescript
import { add, merge } from '@tevm/voltaire/BrandedBloomFilter'
import type { BrandedBloomFilter } from '@tevm/voltaire/BrandedBloomFilter'

// Tree-shakeable add
const filter: BrandedBloomFilter = create(2048, 3)
add(filter, item)

// Tree-shakeable merge
const merged = merge(filter1, filter2)
```

See [BrandedBloomFilter](/primitives/bloomfilter/branded-bloomfilter) for complete functional API.

## Use Cases

### Log Aggregation

```typescript
// Aggregate logs across multiple sources
class LogAggregator {
  private filter: BloomFilter

  constructor() {
    this.filter = BloomFilter.create(2048, 3)
  }

  addLog(log: Log) {
    // Add address
    this.filter.add(Address.from(log.address))

    // Add topics
    for (const topic of log.topics) {
      this.filter.add(Hex.toBytes(topic))
    }
  }

  mightContainAddress(address: string): boolean {
    return this.filter.contains(Address.from(address))
  }
}
```

### Block Range Queries

```typescript
// Build filter for block range
async function buildRangeFilter(
  start: number,
  end: number
): Promise<BloomFilter> {
  let rangeFilter = BloomFilter.create(2048, 3)

  for (let blockNum = start; blockNum <= end; blockNum++) {
    const block = await fetchBlock(blockNum)
    const blockFilter = BloomFilter.fromHex(block.logsBloom, 2048, 3)
    rangeFilter = rangeFilter.merge(blockFilter)
  }

  return rangeFilter
}

// Quick check before scanning blocks
const filter = await buildRangeFilter(1000000, 1001000)
if (filter.contains(targetAddress)) {
  // Address might be in range, scan blocks
} else {
  // Definitely not in range, skip
}
```

### Event Indexing

```typescript
// Index events by type
class EventIndex {
  private filters = new Map<string, BloomFilter>()

  addEvent(eventType: string, address: Uint8Array) {
    if (!this.filters.has(eventType)) {
      this.filters.set(eventType, BloomFilter.create(2048, 3))
    }

    const filter = this.filters.get(eventType)!
    filter.add(address)
  }

  mightContainEvent(eventType: string, address: Uint8Array): boolean {
    const filter = this.filters.get(eventType)
    return filter ? filter.contains(address) : false
  }
}
```

## Related

- [Queries](/primitives/bloomfilter/queries) - Testing membership and state
- [Constructors](/primitives/bloomfilter/constructors) - Creating filters
- [Algorithm](/primitives/bloomfilter/algorithm) - Understanding hash functions
- [Log Filtering](/primitives/bloomfilter/log-filtering) - Ethereum use cases
- [BrandedBloomFilter](/primitives/bloomfilter/branded-bloomfilter) - Tree-shakeable API
