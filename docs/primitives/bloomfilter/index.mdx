---
title: Overview
description: Probabilistic data structure for efficient set membership testing
---

<Tip>
New to bloom filters? Start with [Fundamentals](/primitives/bloomfilter/fundamentals) for guided examples and concepts.
</Tip>

## Type Definition

[Branded](/getting-started/branded-types) `Uint8Array` representing a bloom filter with `m` bits and `k` hash functions. Zero-overhead design supports both tree-shakeable namespace methods and class instances. Used extensively in Ethereum for log filtering.

```typescript
export type BrandedBloomFilter = Uint8Array & {
  readonly __tag: "BloomFilter";
  readonly k: number;  // Number of hash functions
  readonly m: number;  // Number of bits
};
```

### Ethereum Constants

Ethereum uses standard bloom filter parameters for block headers:

```typescript
const SIZE = 256;                // 256 bytes (2048 bits)
const BITS = 2048;               // 2048 bits
const DEFAULT_HASH_COUNT = 3;    // 3 hash functions
```

<Note>
Ethereum block headers contain a 256-byte bloom filter for efficient log filtering. Each log topic is hashed 3 times into the filter.
</Note>

## Quick Reference

<Tabs>
<Tab title="Class API">

```typescript
import { BloomFilter } from '@tevm/voltaire';

const filter = BloomFilter.create(2048, 3);
const item = new TextEncoder().encode("Transfer");

filter.add(item);
const exists = filter.contains(item);
const hex = filter.toHex();
```

</Tab>
<Tab title="Namespace API">

```typescript
import * as BloomFilter from '@tevm/voltaire/BloomFilter';

const filter = BloomFilter.create(2048, 3);
BloomFilter.add(filter, item);
const exists = BloomFilter.contains(filter, item);
const hex = BloomFilter.toHex(filter);
```

</Tab>
</Tabs>

## API Methods

### Constructors

- [`create(m, k)`](./constructors#create) - Create filter with m bits and k hash functions
- [`fromHex(hex, m, k)`](./constructors#fromhex) - Parse filter from hex string

### Operations

- [`add(filter, item)`](./operations#add) - Add item to filter (mutates)
- [`merge(a, b)`](./operations#merge) - Merge two filters via bitwise OR
- [`combine(filters)`](./operations#combine) - Combine multiple filters

### Queries

- [`contains(filter, item)`](./queries#contains) - Test if item might be in set
- [`isEmpty(filter)`](./queries#isempty) - Check if filter has no items
- [`density(filter)`](./queries#density) - Calculate percentage of set bits
- [`expectedFalsePositiveRate(filter)`](./queries#expectedfalsepositiverate) - Estimate false positive rate

### Conversions

- [`toHex(filter)`](./conversions#tohex) - Convert to hex string
- [`hash(item, seed, m)`](./conversions#hash) - Compute hash for item

### Reference

- [Algorithm](./algorithm) - Bloom filter theory and false positives
- [Log Filtering](./log-filtering) - Ethereum log filtering patterns
- [BrandedBloomFilter](./branded-bloomfilter) - Tree-shakeable functional API

## Types

<Tabs>
<Tab title="BrandedBloomFilter">

```typescript
export type BrandedBloomFilter = Uint8Array & {
  readonly __tag: "BloomFilter";
  readonly k: number;  // Number of hash functions
  readonly m: number;  // Number of bits
};
```

Main branded type wrapping `Uint8Array` with filter parameters. Runtime is `Uint8Array`, TypeScript enforces type safety.

</Tab>
<Tab title="BloomFilter Class">

```typescript
class BloomFilter extends Uint8Array {
  readonly k: number;      // Number of hash functions
  readonly m: number;      // Number of bits

  static create(m: number, k: number): BloomFilter;
  static fromHex(hex: string, m: number, k: number): BloomFilter;

  add(item: Uint8Array): void;
  merge(other: BloomFilter): BloomFilter;
  contains(item: Uint8Array): boolean;
  isEmpty(): boolean;
  toHex(): string;
}
```

Class API extending `Uint8Array` with methods. Inherits all `Uint8Array` methods (slice, subarray, etc.).

</Tab>
<Tab title="Constants">

```typescript
export const SIZE = 256;                // Ethereum filter size (bytes)
export const BITS = 2048;               // Ethereum filter size (bits)
export const DEFAULT_HASH_COUNT = 3;    // Ethereum hash function count
```

Standard Ethereum bloom filter parameters for block headers.

</Tab>
</Tabs>

## Usage Patterns

### Creating and Using Filters

```typescript
import { BloomFilter, BITS, DEFAULT_HASH_COUNT } from '@tevm/voltaire';

// Create filter with Ethereum parameters
const filter = BloomFilter.create(BITS, DEFAULT_HASH_COUNT);

// Add items
const topic1 = new TextEncoder().encode("Transfer(address,address,uint256)");
const topic2 = new TextEncoder().encode("Approval(address,address,uint256)");

filter.add(topic1);
filter.add(topic2);

// Query membership
if (filter.contains(topic1)) {
  console.log("Topic might be in filter");
}

// Check if empty
if (!filter.isEmpty()) {
  console.log("Filter contains items");
}
```

### Ethereum Log Filtering

```typescript
// Create filter from block header
const blockFilter = BloomFilter.fromHex(block.logsBloom, BITS, DEFAULT_HASH_COUNT);

// Check if block might contain logs for topic
const transferTopic = keccak256("Transfer(address,address,uint256)");

if (blockFilter.contains(transferTopic)) {
  // Block might contain Transfer events - fetch logs
  const logs = await provider.getLogs({
    fromBlock: block.number,
    toBlock: block.number,
    topics: [transferTopic],
  });
}
```

### Merging Filters

```typescript
// Combine filters from multiple blocks
const filter1 = BloomFilter.fromHex(block1.logsBloom, BITS, DEFAULT_HASH_COUNT);
const filter2 = BloomFilter.fromHex(block2.logsBloom, BITS, DEFAULT_HASH_COUNT);

// Merge via bitwise OR
const merged = BloomFilter.merge(filter1, filter2);

// Check if either block contains topic
if (merged.contains(topic)) {
  console.log("Topic might be in block1 or block2");
}
```

### Analyzing False Positive Rate

```typescript
// Create filter and add items
const filter = BloomFilter.create(BITS, DEFAULT_HASH_COUNT);

for (let i = 0; i < 100; i++) {
  const item = new TextEncoder().encode(`item${i}`);
  filter.add(item);
}

// Check density and false positive rate
const d = BloomFilter.density(filter);
const fpr = BloomFilter.expectedFalsePositiveRate(filter);

console.log(`Density: ${(d * 100).toFixed(2)}%`);
console.log(`Expected FPR: ${(fpr * 100).toFixed(4)}%`);
```

### Batch Operations

```typescript
// Add multiple items efficiently
const items = [
  "Transfer(address,address,uint256)",
  "Approval(address,address,uint256)",
  "Swap(address,uint256,uint256,uint256,uint256,address)",
].map(sig => new TextEncoder().encode(sig));

const filter = BloomFilter.create(BITS, DEFAULT_HASH_COUNT);
items.forEach(item => filter.add(item));

// Serialize for storage
const hex = filter.toHex();
localStorage.setItem('eventFilter', hex);

// Restore from storage
const restored = BloomFilter.fromHex(hex, BITS, DEFAULT_HASH_COUNT);
```

## Tree-Shaking

Import only what you need for optimal bundle size:

```typescript
// Import specific functions (tree-shakeable)
import { create, add, contains, toHex } from '@tevm/voltaire/BrandedBloomFilter';

const filter = create(2048, 3);
add(filter, item);
const exists = contains(filter, item);
const hex = toHex(filter);

// Only these 4 functions included in bundle
```

**Bundle size impact:**
- Core operations: ~1KB
- Hashing functions: ~2KB
- Full BloomFilter namespace: ~3KB

## Related

### Core Documentation

- [Fundamentals](/primitives/bloomfilter/fundamentals) - Learn bloom filter theory
- [Algorithm](/primitives/bloomfilter/algorithm) - False positives and hash functions
- [Log Filtering](/primitives/bloomfilter/log-filtering) - Ethereum event filtering

### API Documentation

- [Constructors](/primitives/bloomfilter/constructors) - Creating filter instances
- [Operations](/primitives/bloomfilter/operations) - Add items and merge filters
- [Queries](/primitives/bloomfilter/queries) - Membership testing and statistics
- [Conversions](/primitives/bloomfilter/conversions) - Hex encoding and hashing

### Related Primitives

- [EventLog](/primitives/eventlog) - Ethereum event logs
- [Hash](/primitives/hash) - Keccak256 hashing for log topics
- [Hex](/primitives/hex) - Hex string encoding

## Specification

- [Ethereum Yellow Paper](https://ethereum.github.io/yellowpaper/paper.pdf) - Section 4.3.1 (Bloom Filter)
- [Wikipedia: Bloom Filter](https://en.wikipedia.org/wiki/Bloom_filter) - Mathematical analysis
- [EIP-234](https://eips.ethereum.org/EIPS/eip-234) - JSON-RPC filter API specification
