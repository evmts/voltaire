---
title: BloomFilter Conversions
description: Serialization and hash utilities
---

# Conversions

Methods for converting bloom filters to hex format and hashing item data.

## Serialization

### `filter.toHex()` / `BloomFilter.toHex(filter)`

Converts bloom filter to hex string representation for storage and transmission.

<Tabs>
<Tab title="Instance Method">
```typescript
import { BloomFilter } from '@tevm/voltaire'

const filter = BloomFilter.create(2048, 3)
filter.add(new TextEncoder().encode("Transfer"))

// Convert to hex string
const hex = filter.toHex()
console.log(hex)
// "0x0000000000000000000000000000000000000000000000000000000000000000..."

// 512 hex characters (256 bytes * 2 chars/byte) + "0x" prefix
console.log(hex.length)  // 514
```
</Tab>
<Tab title="Static Method">
```typescript
import { BloomFilter } from '@tevm/voltaire'

const filter = BloomFilter.create(2048, 3)

// Static method - data-first pattern
const hex = BloomFilter.toHex(filter)
```
</Tab>
</Tabs>

**Parameters:**
- `filter: BrandedBloomFilter` - Bloom filter to serialize

**Returns:** `string` - Hex string with `0x` prefix

**Format:**
- Prefix: `0x`
- Each byte encoded as 2 hex characters (lowercase)
- Total length: `2 + (filter.length * 2)` characters
- Example: 256-byte filter → 514 character string

```typescript
const filter = BloomFilter.create(2048, 3)  // 256 bytes

// Empty filter
console.log(filter.toHex())
// "0x" + "00".repeat(256)
// "0x0000000000000000000000000000000000000000000000000000000000000000..."

// After adding items
filter.add(new TextEncoder().encode("item"))
console.log(filter.toHex())
// "0x0004000000000000001000000000000000000000000000000000000000020000..."
//     ^^                   ^^                                         ^^
//     Set bits from hash functions
```

Defined in: [BrandedBloomFilter/toHex.js:3-20](https://github.com/evmts/voltaire/blob/main/src/primitives/BloomFilter/BrandedBloomFilter/toHex.js#L3-L20)

### Round-Trip Serialization

```typescript
import { BloomFilter } from '@tevm/voltaire'

// Create and populate filter
const original = BloomFilter.create(2048, 3)
original.add(new TextEncoder().encode("event1"))
original.add(new TextEncoder().encode("event2"))
original.add(new TextEncoder().encode("event3"))

// Serialize to hex
const hex = original.toHex()

// Store hex string (database, file, network)
await storage.save({
  logsBloom: hex,
  m: original.m,
  k: original.k
})

// Later: deserialize from hex
const data = await storage.load()
const restored = BloomFilter(data.logsBloom, data.m, data.k)

// Verify restoration
console.log(restored.contains(new TextEncoder().encode("event1")))  // true
console.log(restored.contains(new TextEncoder().encode("event2")))  // true
console.log(restored.contains(new TextEncoder().encode("event3")))  // true
```

### Ethereum Block Headers

```typescript
// Bloom filter hex from block header
interface BlockHeader {
  number: number
  logsBloom: string  // Hex string (514 chars)
  // ... other fields
}

// Parse block bloom filter
function parseBlockBloom(block: BlockHeader): BloomFilter {
  return BloomFilter(block.logsBloom, 2048, 3)
}

// Create block header bloom filter
function createBlockBloom(logs: Log[]): string {
  const filter = BloomFilter.create(2048, 3)

  for (const log of logs) {
    // Add address
    filter.add(Address(log.address))

    // Add topics
    for (const topic of log.topics) {
      filter.add(Hex.toBytes(topic))
    }
  }

  return filter.toHex()
}
```

## Hash Utilities

### `BloomFilter.hash(item, seed, m)`

Internal hash function for computing bit positions. Exposed for testing and custom implementations.

```typescript
import { BloomFilter } from '@tevm/voltaire'

const item = new TextEncoder().encode("Transfer")
const m = 2048  // Number of bits

// Compute hash with different seeds (0 to k-1)
const h0 = BloomFilter.hash(item, 0, m)
const h1 = BloomFilter.hash(item, 1, m)
const h2 = BloomFilter.hash(item, 2, m)

console.log(h0)  // e.g., 1247 (bit position in range [0, 2048))
console.log(h1)  // e.g., 892
console.log(h2)  // e.g., 1653
```

**Parameters:**
- `item: Uint8Array` - Item to hash
- `seed: number` - Hash seed/index (typically 0 to k-1)
- `m: number` - Number of bits in filter (hash result modulo m)

**Returns:** `number` - Hash value in range `[0, m)`

**Algorithm:**
Uses simple multiplicative hashing:

```typescript
// Pseudocode:
let h = seed
for (let i = 0; i < item.length; i++) {
  h = (h * 31 + item[i]) >>> 0  // Unsigned 32-bit
}
return h % m
```

**Properties:**
- **Deterministic**: Same item + seed → same hash
- **Independent**: Different seeds → different hashes
- **Uniform**: Hash values distributed across `[0, m)`
- **Fast**: O(n) where n is item length

Defined in: [BrandedBloomFilter/hash.js:3-16](https://github.com/evmts/voltaire/blob/main/src/primitives/BloomFilter/BrandedBloomFilter/hash.js#L3-L16)

### Computing Bit Positions

```typescript
import { BloomFilter } from '@tevm/voltaire'

// Understand which bits an item sets
function analyzeBitPositions(item: Uint8Array, k: number, m: number) {
  const positions: number[] = []

  for (let i = 0; i < k; i++) {
    const h = BloomFilter.hash(item, i, m)
    positions.push(h)
  }

  return positions
}

// Example usage
const item = new TextEncoder().encode("Transfer")
const positions = analyzeBitPositions(item, 3, 2048)

console.log(`Item sets bits at positions: ${positions.join(", ")}`)
// "Item sets bits at positions: 1247, 892, 1653"

// Verify by checking filter
const filter = BloomFilter.create(2048, 3)
filter.add(item)

for (const pos of positions) {
  const byteIdx = Math.floor(pos / 8)
  const bitPos = pos % 8
  const byte = filter[byteIdx]
  const bitSet = (byte & (1 << bitPos)) !== 0
  console.log(`Bit ${pos}: ${bitSet ? "SET" : "NOT SET"}`)
}
```

### Hash Distribution Testing

```typescript
// Test hash uniformity across bit range
function testHashDistribution(
  items: Uint8Array[],
  seed: number,
  m: number
): Map<number, number> {
  const distribution = new Map<number, number>()

  for (const item of items) {
    const h = BloomFilter.hash(item, seed, m)
    distribution.set(h, (distribution.get(h) || 0) + 1)
  }

  return distribution
}

// Generate test items
const testItems = Array({ length: 1000 }, (_, i) =>
  new TextEncoder().encode(`item-${i}`)
)

// Check distribution
const dist = testHashDistribution(testItems, 0, 2048)
console.log(`Unique hash values: ${dist.size} / 1000`)
// Expected: ~950-1000 (high uniqueness)

// Check collisions
const collisions = Array(dist.values()).filter(count => count > 1).length
console.log(`Hash collisions: ${collisions}`)
// Expected: Low collision rate
```

## Conversion Patterns

### Storage Format

```typescript
// Database schema for bloom filters
interface StoredBloomFilter {
  hex: string       // Serialized bloom filter
  m: number         // Number of bits
  k: number         // Number of hash functions
  itemCount?: number // Optional: items added
}

// Save filter
async function saveFilter(filter: BloomFilter, itemCount: number) {
  await db.filters.insert({
    hex: filter.toHex(),
    m: filter.m,
    k: filter.k,
    itemCount
  })
}

// Load filter
async function loadFilter(id: number): Promise<BloomFilter> {
  const data = await db.filters.findById(id)
  return BloomFilter(data.hex, data.m, data.k)
}
```

### JSON Serialization

```typescript
// Custom JSON serialization
class SerializableBloomFilter {
  constructor(private filter: BloomFilter) {}

  toJSON() {
    return {
      hex: this.filter.toHex(),
      m: this.filter.m,
      k: this.filter.k
    }
  }

  static fromJSON(json: any): BloomFilter {
    return BloomFilter(json.hex, json.m, json.k)
  }
}

// Usage
const filter = BloomFilter.create(2048, 3)
filter.add(new TextEncoder().encode("item"))

const serializable = new SerializableBloomFilter(filter)
const json = JSON.stringify(serializable)
// {"hex":"0x000...","m":2048,"k":3}

const parsed = JSON.parse(json)
const restored = SerializableBloomFilter.fromJSON(parsed)
```

### Network Transmission

```typescript
// Efficient network protocol
interface BloomFilterMessage {
  type: "bloom_filter"
  data: string  // Hex string
  params: {
    m: number
    k: number
  }
}

// Send filter
async function sendFilter(ws: WebSocket, filter: BloomFilter) {
  const message: BloomFilterMessage = {
    type: "bloom_filter",
    data: filter.toHex(),
    params: {
      m: filter.m,
      k: filter.k
    }
  }

  ws.send(JSON.stringify(message))
}

// Receive filter
ws.on("message", (data: string) => {
  const message: BloomFilterMessage = JSON.parse(data)

  if (message.type === "bloom_filter") {
    const filter = BloomFilter(
      message.data,
      message.params.m,
      message.params.k
    )

    // Process filter...
  }
})
```

## Performance Considerations

### toHex Performance

```typescript
// Time complexity: O(m/8)
// Space complexity: O(m/4) for hex string

const filter = BloomFilter.create(2048, 3)  // 256 bytes

// toHex() performs:
// - 256 byte reads
// - 256 hex conversions (byte → 2 chars)
// - String concatenation

const hex = filter.toHex()  // ~O(256) operations
```

### hash Performance

```typescript
// Time complexity: O(n) where n is item length
// Space complexity: O(1)

const item = Hex('0x' + '00'.repeat(100)) // 100-byte item

// hash() performs:
// - 100 byte reads
// - 100 multiply-add operations
// - 1 modulo operation

const h = BloomFilter.hash(item, 0, 2048)  // ~O(100) operations
```

## Related

- [Constructors](/primitives/bloomfilter/constructors) - Creating from hex
- [Algorithm](/primitives/bloomfilter/algorithm) - Understanding hash functions
- [Log Filtering](/primitives/bloomfilter/log-filtering) - Ethereum serialization patterns
- [BrandedBloomFilter](/primitives/bloomfilter/branded-bloomfilter) - Tree-shakeable API
