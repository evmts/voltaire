---
title: "BrandedAuthorization"
description: Tree-shakeable functional API for EIP-7702 authorization operations
---

# BrandedAuthorization

Tree-shakeable functional API for EIP-7702 authorization with optimal bundle size.

## Overview

`BrandedAuthorization` provides:
- **Zero-overhead** operations on authorization objects
- **Tree-shakeable** individual function exports
- **Data-first** unopinionated methods
- **Bundle optimization** through selective imports
- **EIP-7702 compliant** authorization handling

Primary benefit: Import only what you need, minimize bundle size.

## Type Definition

```typescript
export type BrandedAuthorization = {
  /** Chain ID where authorization is valid */
  chainId: bigint;
  /** Address to delegate code execution to */
  address: BrandedAddress;
  /** Nonce of the authorizing account */
  nonce: bigint;
  /** Signature Y parity (0 or 1) */
  yParity: number;
  /** Signature r value */
  r: bigint;
  /** Signature s value */
  s: bigint;
};
```

`BrandedAuthorization` represents an EIP-7702 authorization that allows an EOA to delegate code execution to another address.

## EIP-7702 Authorization

EIP-7702 introduces a new transaction type that allows externally owned accounts (EOAs) to temporarily delegate their code execution to a contract address. This enables:

- **Account abstraction** for EOAs
- **Batch operations** from EOAs
- **Temporary delegation** with nonce-based expiration
- **Cross-chain** authorization scoping

## Tree-Shaking Benefits

### Minimal Bundle

```typescript
import { create, isValid } from '@tevm/primitives/Authorization/BrandedAuthorization'

const auth = create({
  chainId: 1n,
  address: contractAddress,
  nonce: 0n,
  yParity: 0,
  r: 0n,
  s: 0n
})

if (isValid(auth)) {
  // Use authorization
}
```

**Bundle:** Only create and isValid functions. No encoding/decoding logic.

### Encoding Only

```typescript
import { encode } from '@tevm/primitives/Authorization/BrandedAuthorization'

const encoded = encode(auth)
```

**Bundle:** Encoding logic only. No decoding or validation code.

### Decoding Only

```typescript
import { decode } from '@tevm/primitives/Authorization/BrandedAuthorization'

const auth = decode(encodedData)
```

**Bundle:** Decoding logic only. No encoding or validation code.

## Data-First Pattern

All functions follow data-first pattern:

```typescript
// Data is first parameter
create(authData)
isValid(auth)
encode(auth)
decode(data)
```

This enables functional composition:

```typescript
import { create, encode } from '@tevm/primitives/Authorization/BrandedAuthorization'

// Composition
const createAndEncode = (authData) => encode(create(authData))

// Array methods
const auths = authDataArray.map(create)
const validAuths = auths.filter(isValid)
```

## Type Safety

Branded type prevents mixing with plain objects:

```typescript
type BrandedAuthorization = {
  chainId: bigint;
  address: BrandedAddress;
  nonce: bigint;
  yParity: number;
  r: bigint;
  s: bigint;
};

// Type-safe functions require BrandedAuthorization
function processAuth(auth: BrandedAuthorization) { ... }

const plainObject = { chainId: 1n, address: addr, nonce: 0n, ... }
processAuth(plainObject) // Type error!

// Must use constructor
const auth = Authorization.create(plainObject)
processAuth(auth) // OK
```

## Usage Examples

### Creating Authorization

```typescript
import * as BrandedAuthorization from '@tevm/primitives/Authorization/BrandedAuthorization'

// Create from authorization data
const auth = BrandedAuthorization.create({
  chainId: 1n,
  address: BrandedAddress.fromHex('0x742d35Cc6634C0532925a3b844Bc9e7595f51e3e'),
  nonce: 5n,
  yParity: 0,
  r: 0x123456789abcdef0n,
  s: 0xfedcba987654321n
})
```

### Validating Authorization

```typescript
import { isValid } from '@tevm/primitives/Authorization/BrandedAuthorization'

if (isValid(auth)) {
  console.log('Valid authorization')
} else {
  console.log('Invalid authorization')
}
```

### Encoding Authorization

```typescript
import { encode } from '@tevm/primitives/Authorization/BrandedAuthorization'

const encoded = encode(auth)
// Use in EIP-7702 transaction
```

### Decoding Authorization

```typescript
import { decode } from '@tevm/primitives/Authorization/BrandedAuthorization'

const auth = decode(encodedData)
console.log(`Authorized to: ${auth.address}`)
console.log(`Chain ID: ${auth.chainId}`)
console.log(`Nonce: ${auth.nonce}`)
```

## Benefits

### Type Safety

```typescript
type BrandedAuthorization = {
  chainId: bigint;
  address: BrandedAddress;
  nonce: bigint;
  yParity: number;
  r: bigint;
  s: bigint;
};

function verifyAuth(auth: BrandedAuthorization) { ... }

const auth = Authorization.create(authData)
verifyAuth(auth)    // OK

const plain = { chainId: 1n, ... }
verifyAuth(plain)   // Type error
```

### Self-Documenting

```typescript
// Clear what's expected
function submitAuth(auth: BrandedAuthorization): void { ... }

// vs unclear plain object
function submitAuth(auth: object): void { ... }
```

### Zero Runtime Cost

```typescript
const auth: BrandedAuthorization = Authorization.create(data)
// auth is plain object at runtime
console.log(auth) // { chainId: 1n, address: ..., nonce: 0n, ... }
```

## Related

- [Authorization](/primitives/authorization) - Main Authorization documentation
- [Address](/primitives/address) - Address type used in authorization
- [Transaction](/primitives/transaction) - EIP-7702 transaction type
- [Branded Types](/getting-started/branded-types) - Type-level branding pattern