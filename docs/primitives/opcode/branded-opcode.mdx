---
title: "BrandedOpcode"
description: Tree-shakeable functional API for EVM opcode operations
---

# BrandedOpcode

Tree-shakeable functional API for EVM opcode handling with optimal bundle size.

## Overview

`BrandedOpcode` provides:
- **Zero-overhead** opcode operations
- **Tree-shakeable** individual function exports
- **Data-first** unopinionated methods
- **Bundle optimization** through selective imports
- **Type-safe** opcode handling

Primary benefit: Import only what you need, minimize bundle size.

## Type Definition

```typescript
/**
 * Branded type for EVM opcodes (number 0x00-0xFF)
 */
export type BrandedOpcode = number & { readonly __tag: "Opcode" };

/**
 * Instruction with opcode and optional immediate data
 */
export type Instruction = {
  /** Program counter offset */
  offset: number;
  /** The opcode */
  opcode: BrandedOpcode;
  /** Immediate data for PUSH operations */
  immediate?: Uint8Array;
};

/**
 * Opcode metadata structure
 */
export type Info = {
  /** Base gas cost (may be dynamic at runtime) */
  gasCost: number;
  /** Number of stack items consumed */
  stackInputs: number;
  /** Number of stack items produced */
  stackOutputs: number;
  /** Opcode name */
  name: string;
};
```

`BrandedOpcode` represents a valid EVM opcode (0x00-0xFF) with compile-time type safety.

## EVM Opcodes

Opcodes are the instructions that make up EVM bytecode:
- **0x00-0x0F**: Arithmetic/comparison operations
- **0x10-0x1F**: Cryptographic operations
- **0x20-0x2F**: Environmental information
- **0x30-0x3F**: Block information
- **0x40-0x4F**: Stack/memory/storage
- **0x50-0x5F**: Control flow
- **0x60-0x7F**: PUSH operations
- **0x80-0x8F**: Duplication operations
- **0x90-0x9F**: Exchange operations
- **0xA0-0xAF**: Logging operations
- **0xF0-0xFF**: System operations

## Namespace API

```typescript
import * as BrandedOpcode from '@tevm/primitives/Opcode/BrandedOpcode'

// Create opcode
const opcode = BrandedOpcode.from(0x01) // ADD

// Get opcode info
const info = BrandedOpcode.getInfo(opcode)
console.log(info.name)         // "ADD"
console.log(info.gasCost)      // 3
console.log(info.stackInputs)  // 2
console.log(info.stackOutputs) // 1

// Check opcode type
const isPush = BrandedOpcode.isPush(opcode)
const isDup = BrandedOpcode.isDup(opcode)
const isSwap = BrandedOpcode.isSwap(opcode)

// Get PUSH size
if (isPush) {
  const pushSize = BrandedOpcode.getPushSize(opcode) // 1-32
}

// Parse bytecode into instructions
const instructions = BrandedOpcode.parseInstructions(bytecode)
for (const instr of instructions) {
  console.log(`${instr.offset}: ${BrandedOpcode.getName(instr.opcode)}`)
}
```

## Tree-Shaking Benefits

### Minimal Bundle - Info Only

```typescript
import { getInfo } from '@tevm/primitives/Opcode/BrandedOpcode'

const info = getInfo(opcode)
console.log(info.name)
```

**Bundle:** Only opcode info lookup. No parsing or validation.

### Parsing Only

```typescript
import { parseInstructions } from '@tevm/primitives/Opcode/BrandedOpcode'

const instructions = parseInstructions(bytecode)
```

**Bundle:** Bytecode parsing only. No info or validation.

### Type Checks Only

```typescript
import { isPush, isDup, isSwap } from '@tevm/primitives/Opcode/BrandedOpcode'

if (isPush(opcode)) {
  // Handle PUSH
}
```

**Bundle:** Type checking only. No parsing or info.

## Data-First Pattern

All functions follow data-first pattern:

```typescript
// Data is first parameter
from(value)
getInfo(opcode)
getName(opcode)
isPush(opcode)
parseInstructions(bytecode)
```

This enables functional composition:

```typescript
import { from, getName, isPush } from '@tevm/primitives/Opcode/BrandedOpcode'

// Composition
const getOpcodeName = (value) => getName(from(value))

// Array methods
const opcodes = [0x01, 0x02, 0x60].map(from)
const pushOpcodes = opcodes.filter(isPush)
```

## Type Safety

Branded type prevents mixing numbers with opcodes:

```typescript
function executeOpcode(opcode: BrandedOpcode) { ... }

const plainNumber = 0x01
executeOpcode(plainNumber) // Type error!

// Must use constructor
const opcode = Opcode.from(0x01)
executeOpcode(opcode) // OK
```

## Usage Examples

### Creating Opcodes

```typescript
import * as BrandedOpcode from '@tevm/primitives/Opcode/BrandedOpcode'

// From number
const add = BrandedOpcode.from(0x01)
const push1 = BrandedOpcode.from(0x60)
const sstore = BrandedOpcode.from(0x55)

// From name
const addByName = BrandedOpcode.fromName('ADD')
const push1ByName = BrandedOpcode.fromName('PUSH1')
```

### Getting Opcode Information

```typescript
import { getInfo } from '@tevm/primitives/Opcode/BrandedOpcode'

const add = BrandedOpcode.from(0x01)
const info = getInfo(add)

console.log(info.name)          // "ADD"
console.log(info.gasCost)       // 3
console.log(info.stackInputs)   // 2 (pops 2 items)
console.log(info.stackOutputs)  // 1 (pushes 1 item)
```

### Checking Opcode Types

```typescript
import { isPush, isDup, isSwap, isLog } from '@tevm/primitives/Opcode/BrandedOpcode'

const opcode = BrandedOpcode.from(0x60)

if (isPush(opcode)) {
  console.log('PUSH operation')
  const size = BrandedOpcode.getPushSize(opcode) // 1-32
}

if (isDup(opcode)) {
  console.log('DUP operation')
  const depth = BrandedOpcode.getDupDepth(opcode) // 1-16
}

if (isSwap(opcode)) {
  console.log('SWAP operation')
  const depth = BrandedOpcode.getSwapDepth(opcode) // 1-16
}

if (isLog(opcode)) {
  console.log('LOG operation')
  const topicCount = BrandedOpcode.getLogTopicCount(opcode) // 0-4
}
```

### Parsing Bytecode

```typescript
import { parseInstructions } from '@tevm/primitives/Opcode/BrandedOpcode'

const bytecode = new Uint8Array([
  0x60, 0x01,  // PUSH1 0x01
  0x60, 0x02,  // PUSH1 0x02
  0x01,        // ADD
  0x00         // STOP
])

const instructions = parseInstructions(bytecode)

for (const instr of instructions) {
  console.log(`${instr.offset}: ${BrandedOpcode.getName(instr.opcode)}`)
  if (instr.immediate) {
    console.log(`  Data: ${Hex.fromBytes(instr.immediate)}`)
  }
}

// Output:
// 0: PUSH1
//   Data: 0x01
// 2: PUSH1
//   Data: 0x02
// 4: ADD
// 5: STOP
```

### Analyzing Instructions

```typescript
import { parseInstructions, getInfo } from '@tevm/primitives/Opcode/BrandedOpcode'

const instructions = parseInstructions(bytecode)

// Calculate total gas cost (base costs only)
let totalGas = 0
for (const instr of instructions) {
  const info = getInfo(instr.opcode)
  totalGas += info.gasCost
}

// Find all PUSH operations
const pushInstructions = instructions.filter(instr =>
  BrandedOpcode.isPush(instr.opcode)
)

// Calculate stack depth
let stackDepth = 0
for (const instr of instructions) {
  const info = getInfo(instr.opcode)
  stackDepth -= info.stackInputs
  stackDepth += info.stackOutputs
}
```

### Disassembling Bytecode

```typescript
import { parseInstructions, getName } from '@tevm/primitives/Opcode/BrandedOpcode'

function disassemble(bytecode: Uint8Array): string {
  const instructions = parseInstructions(bytecode)
  const lines: string[] = []

  for (const instr of instructions) {
    const name = getName(instr.opcode)
    const hex = instr.opcode.toString(16).padStart(2, '0')

    if (instr.immediate) {
      const data = Hex.fromBytes(instr.immediate)
      lines.push(`${instr.offset.toString().padStart(6)}: ${hex} ${name} ${data}`)
    } else {
      lines.push(`${instr.offset.toString().padStart(6)}: ${hex} ${name}`)
    }
  }

  return lines.join('\n')
}

console.log(disassemble(bytecode))
// Output:
//      0: 60 PUSH1 0x01
//      2: 60 PUSH1 0x02
//      4: 01 ADD
//      5: 00 STOP
```

### Validating Bytecode

```typescript
import { parseInstructions, getInfo } from '@tevm/primitives/Opcode/BrandedOpcode'

function validateBytecode(bytecode: Uint8Array): { valid: boolean; errors: string[] } {
  const errors: string[] = []
  const instructions = parseInstructions(bytecode)

  let stackDepth = 0
  for (const instr of instructions) {
    const info = getInfo(instr.opcode)

    // Check stack underflow
    if (stackDepth < info.stackInputs) {
      errors.push(`Stack underflow at offset ${instr.offset}`)
    }

    stackDepth -= info.stackInputs
    stackDepth += info.stackOutputs

    // Check stack overflow (max 1024 items)
    if (stackDepth > 1024) {
      errors.push(`Stack overflow at offset ${instr.offset}`)
    }
  }

  return { valid: errors.length === 0, errors }
}
```

## Benefits

### Type Safety

```typescript
type BrandedOpcode = number & { readonly __tag: "Opcode" };

function execute(opcode: BrandedOpcode) { ... }

const opcode = Opcode.from(0x01)
execute(opcode)    // OK

const number = 0x01
execute(number)    // Type error
```

### Self-Documenting

```typescript
// Clear what's expected
function analyzeOpcode(opcode: BrandedOpcode): Info { ... }

// vs unclear plain number
function analyzeOpcode(opcode: number): Info { ... }
```

### Zero Runtime Cost

```typescript
const opcode: BrandedOpcode = Opcode.from(0x01)
// opcode is plain number at runtime
console.log(opcode) // 1
console.log(opcode.__tag) // undefined (brand doesn't exist at runtime)
```

## Instruction Type

```typescript
export type Instruction = {
  /** Program counter offset */
  offset: number;
  /** The opcode */
  opcode: BrandedOpcode;
  /** Immediate data for PUSH operations */
  immediate?: Uint8Array;
};
```

Instructions combine an opcode with its position in bytecode and any immediate data (for PUSH operations).

## Info Type

```typescript
export type Info = {
  /** Base gas cost (may be dynamic at runtime) */
  gasCost: number;
  /** Number of stack items consumed */
  stackInputs: number;
  /** Number of stack items produced */
  stackOutputs: number;
  /** Opcode name */
  name: string;
};
```

Info provides metadata about an opcode's behavior and cost.

## Patterns

### Type Guards

```typescript
function isBrandedOpcode(value: unknown): value is BrandedOpcode {
  return typeof value === 'number' && value >= 0x00 && value <= 0xFF
}

// Usage
if (isBrandedOpcode(unknownValue)) {
  // unknownValue is BrandedOpcode
  const info = getInfo(unknownValue)
}
```

### Filtering Instructions

```typescript
// Find all storage operations
const storageOps = instructions.filter(instr => {
  const name = getName(instr.opcode)
  return name === 'SLOAD' || name === 'SSTORE'
})

// Find all jumps
const jumps = instructions.filter(instr => {
  const name = getName(instr.opcode)
  return name === 'JUMP' || name === 'JUMPI'
})
```

## Related

- [Opcode](/primitives/opcode) - Main Opcode documentation
- [Bytecode](/primitives/bytecode) - Bytecode type for contract code
- [GasConstants](/primitives/gasconstants) - Gas cost calculations
- [Hex](/primitives/hex) - Hex encoding for opcodes
- [Branded Types](/getting-started/branded-types) - Type-level branding pattern
