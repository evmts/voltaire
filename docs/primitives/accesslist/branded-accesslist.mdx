---
title: "BrandedAccessList"
description: "Type system and branded types for AccessList"
---

# BrandedAccessList

Type system and branded types for AccessList.

## Type Definition

```typescript
export type BrandedAccessList = readonly Item[] & {
  readonly __brand?: typeof accessListSymbol;
};
```

**Properties:**
- Extends readonly array of Items
- Phantom `__brand` property for type safety
- Brand symbol prevents accidental type mixing

## Item Type

```typescript
export type Item<
  TAddress extends BrandedAddress = BrandedAddress,
  TStorageKeys extends readonly BrandedHash[] = readonly BrandedHash[],
> = {
  address: TAddress;
  storageKeys: TStorageKeys;
};
```

**Properties:**
- `address`: 20-byte BrandedAddress
- `storageKeys`: Readonly array of 32-byte BrandedHash

**Generic Parameters:**
- `TAddress`: Address type (defaults to BrandedAddress)
- `TStorageKeys`: Storage keys type (defaults to readonly BrandedHash[])

## Brand Symbol

```typescript
export const accessListSymbol = Symbol("AccessList");
```

**Purpose:**
- Unique identifier for AccessList brand
- Prevents mixing with other array types
- Enables TypeScript type discrimination

## Type Safety

### Brand vs Unbranded

```typescript
// Branded - type safe
const branded: BrandedAccessList = AccessList.create();

// Unbranded - no type safety
const unbranded: Item[] = [
  { address: addr, storageKeys: [] }
];

// Type error - brand mismatch
const mixed: BrandedAccessList = unbranded;  // Error!

// Must convert explicitly
const safe: BrandedAccessList = AccessList.from(unbranded);
```

### Type Guards

```typescript
// Runtime type check
if (AccessList.is(value)) {
  // TypeScript knows value is BrandedAccessList
  value.gasCost();
}

// Compile-time type assertion
function processAccessList(list: BrandedAccessList) {
  // list is guaranteed to be AccessList
}
```

## Pattern

### Data-Oriented Design

All methods operate on data passed as first argument:

```typescript
// Static method with data parameter
const cost = AccessList.gasCost(list);

// Instance method (delegates to static)
const cost = list.gasCost();
```

**Benefits:**
- Tree-shakable functions
- No prototype pollution
- Clear data flow
- Testable in isolation

### Namespace Pattern

```typescript
// All methods in BrandedAccessList namespace
namespace BrandedAccessList {
  export function gasCost(list: BrandedAccessList): bigint;
  export function withAddress(list: BrandedAccessList, addr: BrandedAddress): BrandedAccessList;
  // ...
}

// Usage
import * as BrandedAccessList from './BrandedAccessList/index.js';
const cost = BrandedAccessList.gasCost(list);
```

**Benefits:**
- Clear organization
- Explicit imports
- No global pollution
- Tree-shaking friendly

## Type Relationships

### Structural Typing

```typescript
// Any array matching structure is compatible
const array: readonly Item[] = [
  { address: addr, storageKeys: [] }
];

// Can be used as AccessList after validation
if (AccessList.is(array)) {
  AccessList.gasCost(array);
}
```

### Generic Item Type

```typescript
// Specific address types
type SpecificItem = Item<
  ChecksumAddress,
  readonly BrandedHash[]
>;

// Generic item
type GenericItem = Item;

// Both compatible with AccessList
const list1: BrandedAccessList = [specific];
const list2: BrandedAccessList = [generic];
```

## Patterns

### Type-Safe Construction

```typescript
function createTypeSafeList(
  items: readonly Item[]
): BrandedAccessList {
  // Validate structure
  if (!AccessList.is(items)) {
    throw new Error('Invalid items');
  }

  // Validate content
  AccessList.assertValid(items);

  return items;
}
```

### Generic Functions

```typescript
function mapItems<T>(
  list: BrandedAccessList,
  fn: (item: Item) => T
): T[] {
  return [...list].map(fn);
}

const addresses = mapItems(list, item => item.address);
const keyCounts = mapItems(list, item => item.storageKeys.length);
```

### Type Narrowing

```typescript
function processUnknown(value: unknown) {
  if (!AccessList.is(value)) {
    throw new Error('Not an access list');
  }

  // TypeScript knows value is BrandedAccessList
  const cost = value.gasCost();
  const addresses = value.addressCount();
}
```

### Branded Return Types

```typescript
// Methods return branded types
function build(): BrandedAccessList {
  let list = AccessList.create();  // BrandedAccessList
  list = list.withAddress(addr);   // BrandedAccessList
  return list;                     // BrandedAccessList
}

// Type preserved through chain
const list = AccessList.create()
  .withAddress(addr1)
  .withAddress(addr2)
  .deduplicate();  // Still BrandedAccessList
```

## Implementation Details

### Phantom Brand

```typescript
// Brand is optional (phantom property)
type BrandedAccessList = readonly Item[] & {
  readonly __brand?: typeof accessListSymbol;
};

// Never actually set at runtime
const list = AccessList.create();
console.log(list.__brand);  // undefined

// Only for TypeScript type checking
```

### Readonly Semantics

```typescript
// All arrays are readonly
const list: BrandedAccessList = AccessList.create();

// Cannot mutate
list.push(item);     // Error: push doesn't exist
list[0] = item;      // Error: Index signature is readonly

// Must use immutable methods
const newList = list.withAddress(addr);
```

### Array Compatibility

```typescript
// Can use array methods
const list: BrandedAccessList = AccessList.create();

// Readonly array operations
list.length;           // number
list.map(fn);          // array
list.filter(fn);       // array
[...list];             // array
```

## Best Practices

1. **Always use branded types in signatures**
   ```typescript
   // Good
   function process(list: BrandedAccessList): bigint

   // Bad
   function process(list: Item[]): bigint
   ```

2. **Validate unbranded data before use**
   ```typescript
   function accept(items: Item[]): BrandedAccessList {
     const list = AccessList.from(items);
     AccessList.assertValid(list);
     return list;
   }
   ```

3. **Use type guards for unknown data**
   ```typescript
   if (AccessList.is(data)) {
     return processAccessList(data);
   }
   ```

4. **Preserve branding through transformations**
   ```typescript
   // Good: Returns BrandedAccessList
   function optimize(list: BrandedAccessList): BrandedAccessList {
     return list.deduplicate();
   }

   // Bad: Loses branding
   function optimize(list: BrandedAccessList): Item[] {
     return [...list.deduplicate()];
   }
   ```

5. **Don't rely on runtime brand**
   ```typescript
   // Bad: Brand is phantom
   if (list.__brand === accessListSymbol) {
     // Never true!
   }

   // Good: Use type guard
   if (AccessList.is(list)) {
     // Proper runtime check
   }
   ```

## Type Aliases

### Convenience Aliases

```typescript
// Main type
export type { BrandedAccessList };

// Alternative name
export type { BrandedAccessList as Type };

// Item type
export type { Item };
```

### Usage

```typescript
import type { BrandedAccessList, Item } from './BrandedAccessList.js';

// Or with alias
import type { Type as AccessList } from './BrandedAccessList.js';
```
