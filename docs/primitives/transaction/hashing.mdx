---
title: Transaction Hashing
description: Compute transaction and signing hashes
---

# Transaction Hashing

Keccak256 hashing for transaction identification and signing.

## hash

Compute transaction hash (keccak256 of serialized transaction).

```typescript
function hash(tx: Any): BrandedHash
```

### Parameters

- `tx: Any` - Any transaction type

### Returns

`BrandedHash` - 32-byte keccak256 hash

### Throws

- `Error("Unknown transaction type")` - If transaction type is invalid
- `Error("Not implemented")` - If type-specific hashing not implemented yet

### Usage

```typescript
import { hash } from '@tevm/voltaire/Transaction'

const tx: Transaction.EIP1559 = {
  type: Transaction.Type.EIP1559,
  chainId: 1n,
  nonce: 0n,
  maxPriorityFeePerGas: 1000000000n,
  maxFeePerGas: 20000000000n,
  gasLimit: 21000n,
  to: recipientAddress,
  value: 1000000000000000000n,
  data: new Uint8Array(),
  accessList: [],
  yParity: 0,
  r: signatureR,
  s: signatureS,
}

// Compute transaction hash
const txHash = hash(tx)
// Uint8Array(32) [0x3a, 0xc2, 0x25, ...]

// Transaction hash is used as unique identifier
console.log('Transaction ID:', Hex.fromBytes(txHash))
// "0x3ac225..."
```

Source: [hash.ts:12-27](https://github.com/evmts/voltaire/blob/main/src/primitives/Transaction/hash.ts#L12-L27)

## getSigningHash

Get hash that should be signed (excludes signature fields).

```typescript
function getSigningHash(tx: Any): BrandedHash
```

### Parameters

- `tx: Any` - Any transaction type (signature fields ignored)

### Returns

`BrandedHash` - 32-byte keccak256 signing hash

### Throws

- `Error("Unknown transaction type")` - If transaction type is invalid
- `Error("Not implemented")` - If type-specific signing hash not implemented yet

### Usage

```typescript
import { getSigningHash } from '@tevm/voltaire/Transaction'

// Unsigned transaction (signature fields can be zeros)
const unsignedTx: Transaction.EIP1559 = {
  type: Transaction.Type.EIP1559,
  chainId: 1n,
  nonce: 0n,
  maxPriorityFeePerGas: 1000000000n,
  maxFeePerGas: 20000000000n,
  gasLimit: 21000n,
  to: recipientAddress,
  value: 1000000000000000000n,
  data: new Uint8Array(),
  accessList: [],
  yParity: 0,
  r: new Uint8Array(32),
  s: new Uint8Array(32),
}

// Get hash to sign
const signingHash = getSigningHash(unsignedTx)

// Sign with private key
const signature = secp256k1.sign(signingHash, privateKey)

// Add signature to transaction
const signedTx = {
  ...unsignedTx,
  yParity: signature.recovery,
  r: signature.r,
  s: signature.s,
}
```

Source: [getSigningHash.ts:12-27](https://github.com/evmts/voltaire/blob/main/src/primitives/Transaction/getSigningHash.ts#L12-L27)

## Hash vs Signing Hash

The difference between `hash` and `getSigningHash`:

### Transaction Hash

`hash(tx)` computes hash of **complete** transaction including signature:

```typescript
// Legacy format
hash = keccak256(rlp([nonce, gasPrice, gasLimit, to, value, data, v, r, s]))
                                                                  ^^^^^^^
                                                                  includes signature

// EIP-1559 format
hash = keccak256(0x02 || rlp([chainId, nonce, ..., yParity, r, s]))
                                                    ^^^^^^^^^^^^^^^^
                                                    includes signature
```

Used as transaction identifier in:
- Block transactions
- Transaction receipts
- eth_getTransactionByHash RPC

### Signing Hash

`getSigningHash(tx)` computes hash **without** signature fields:

```typescript
// Legacy format (EIP-155)
signingHash = keccak256(rlp([nonce, gasPrice, gasLimit, to, value, data, chainId, 0, 0]))
                                                                          ^^^^^^^^^^^^^^^
                                                                          no signature, chain ID added

// EIP-1559 format
signingHash = keccak256(0x02 || rlp([chainId, nonce, ..., accessList]))
                                                          ^^^^^^^^^^
                                                          no signature fields
```

Used for:
- Creating signatures
- Verifying signatures
- Recovering sender address

## Type-Specific Hashing

### Transaction.Legacy.hash

```typescript
function hash(tx: BrandedTransactionLegacy): BrandedHash

// Usage
import { Legacy } from '@tevm/voltaire/Transaction'
const txHash = Legacy.hash.call(legacyTx)
```

### Transaction.Legacy.getSigningHash

```typescript
function getSigningHash(tx: BrandedTransactionLegacy): BrandedHash

// Usage
import { Legacy } from '@tevm/voltaire/Transaction'
const signingHash = Legacy.getSigningHash.call(legacyTx)
```

### Transaction.EIP1559.hash

```typescript
function hash(tx: BrandedTransactionEIP1559): BrandedHash

// Usage
import { EIP1559 } from '@tevm/voltaire/Transaction'
const txHash = EIP1559.hash(eip1559Tx)
```

### Transaction.EIP1559.getSigningHash

```typescript
function getSigningHash(tx: BrandedTransactionEIP1559): BrandedHash

// Usage
import { EIP1559 } from '@tevm/voltaire/Transaction'
const signingHash = EIP1559.getSigningHash(eip1559Tx)
```

Similar methods exist for EIP2930, EIP4844, and EIP7702.

## Hash Usage Patterns

### Transaction Identification

```typescript
import { hash } from '@tevm/voltaire/Transaction'

// Store in database
const txHash = hash(tx)
await db.transactions.put(txHash, tx)

// Retrieve by hash
const retrievedTx = await db.transactions.get(txHash)
```

### Block Transaction List

```typescript
import { hash } from '@tevm/voltaire/Transaction'

const block = {
  number: 18000000n,
  transactions: txList.map(tx => hash(tx)),
  // ... other block fields
}
```

### Transaction Pool

```typescript
import { hash } from '@tevm/voltaire/Transaction'

class TransactionPool {
  private txs = new Map<string, Transaction.Any>()

  add(tx: Transaction.Any) {
    const txHash = Hex.fromBytes(hash(tx))
    this.txs.set(txHash, tx)
  }

  get(txHash: string): Transaction.Any | undefined {
    return this.txs.get(txHash)
  }
}
```

### Signing Workflow

```typescript
import { getSigningHash, hash } from '@tevm/voltaire/Transaction'

// 1. Create unsigned transaction
const unsignedTx: Transaction.EIP1559 = {
  type: Transaction.Type.EIP1559,
  chainId: 1n,
  nonce: 0n,
  maxPriorityFeePerGas: 1000000000n,
  maxFeePerGas: 20000000000n,
  gasLimit: 21000n,
  to: recipientAddress,
  value: 1000000000000000000n,
  data: new Uint8Array(),
  accessList: [],
  yParity: 0,
  r: new Uint8Array(32),
  s: new Uint8Array(32),
}

// 2. Get signing hash
const signingHash = getSigningHash(unsignedTx)

// 3. Sign
const { r, s, recovery } = sign(signingHash, privateKey)

// 4. Create signed transaction
const signedTx = {
  ...unsignedTx,
  yParity: recovery,
  r,
  s,
}

// 5. Compute final transaction hash
const txHash = hash(signedTx)
console.log('Transaction hash:', Hex.fromBytes(txHash))
```

### Signature Verification

```typescript
import { getSigningHash, getSender } from '@tevm/voltaire/Transaction'

// Verify signature by recovering sender
const signingHash = getSigningHash(tx)
const recoveredSender = getSender(tx)

// Or verify manually
const expectedSender = recoverAddress(signingHash, {
  r: tx.r,
  s: tx.s,
  v: tx.yParity
})

if (!Address.equals(recoveredSender, expectedSender)) {
  throw new Error('Invalid signature')
}
```

## Legacy Transaction Signing Hash

Legacy transactions have special signing hash logic for EIP-155:

```typescript
// Pre-EIP-155 (v = 27 or 28)
signingHash = keccak256(rlp([nonce, gasPrice, gasLimit, to, value, data]))

// Post-EIP-155 (v = chainId * 2 + 35 + yParity)
signingHash = keccak256(rlp([nonce, gasPrice, gasLimit, to, value, data, chainId, 0, 0]))
                                                                          ^^^^^^^^^^^^^^
                                                                          adds chain ID + zeros
```

Example:
```typescript
import { Legacy } from '@tevm/voltaire/Transaction'

const legacyTx: Transaction.Legacy = {
  type: Transaction.Type.Legacy,
  nonce: 0n,
  gasPrice: 20000000000n,
  gasLimit: 21000n,
  to: recipientAddress,
  value: 1000000000000000000n,
  data: new Uint8Array(),
  v: 37n,  // Chain ID 1: (37 - 35) / 2 = 1
  r: signatureR,
  s: signatureS,
}

// Signing hash includes chain ID
const signingHash = Legacy.getSigningHash.call(legacyTx)
// keccak256(rlp([..., 1, 0, 0]))
```

## EIP-4844 Signing Hash

EIP-4844 blob transactions exclude blob versioned hashes from signing hash:

```typescript
// Transaction hash (includes blobs)
hash = keccak256(0x03 || rlp([..., maxFeePerBlobGas, blobVersionedHashes, yParity, r, s]))

// Signing hash (excludes signature but includes blobs)
signingHash = keccak256(0x03 || rlp([..., maxFeePerBlobGas, blobVersionedHashes]))
```

Blob hashes ARE included in signing hash, but the actual blob data is not.

## Performance Considerations

Hashing is cryptographically expensive (keccak256):

```typescript
import { hash } from '@tevm/voltaire/Transaction'

// Cache hashes for repeated use
const cache = new Map<Transaction.Any, BrandedHash>()

function getCachedHash(tx: Transaction.Any): BrandedHash {
  if (!cache.has(tx)) {
    cache.set(tx, hash(tx))
  }
  return cache.get(tx)!
}
```

For batch processing:
```typescript
// Parallelize if possible
const hashes = await Promise.all(
  transactions.map(tx => Promise.resolve(hash(tx)))
)
```

## Implementation Status

| Type | hash | getSigningHash | Status |
|------|------|----------------|--------|
| Legacy | Partial | Partial | In progress |
| EIP-2930 | Partial | Partial | In progress |
| EIP-1559 | Partial | Partial | In progress |
| EIP-4844 | Partial | Partial | In progress |
| EIP-7702 | Partial | Partial | In progress |

Many methods currently throw "Not implemented" - check test files for implementation status.

## EIP References

- [EIP-155: Simple replay attack protection](https://eips.ethereum.org/EIPS/eip-155)
- [EIP-2718: Typed Transaction Envelope](https://eips.ethereum.org/EIPS/eip-2718)
- [Yellow Paper: Transaction signing](https://ethereum.github.io/yellowpaper/paper.pdf)
