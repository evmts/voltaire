---
title: Bytes<N>
description: Foundation of Voltaire's type system - generic fixed-size byte types with compile-time length validation
---

# Bytes<N>

Generic fixed-size byte types that form the foundation of Voltaire's type system. Bytes<N> represents N bytes with compile-time type safety through TypeScript branding and hardcoded length properties.

<Info>
**Type System Foundation** - Bytes<N> is the base pattern for all fixed-size types in Voltaire. Address (Bytes20), Keccak256Hash (Bytes32), and all other fixed-size primitives extend this pattern.
</Info>

## Overview

Bytes<N> is a branded `Uint8Array` with:
- **Symbol-based branding** - Uses `Symbol.for("type")` for nominal typing
- **Hardcoded length** - Type-level `{ readonly length: N }` (not `number`)
- **Zero runtime overhead** - Pure TypeScript compile-time checking
- **Curried implementation** - `Bytes(32)` returns `Bytes32` type

```typescript
import * as Bytes from '@tevm/voltaire/primitives/Bytes';

// Generic bytes
const data = Bytes.from('0x1234');

// Fixed-size variants
const b32 = Bytes32('0x' + 'ab'.repeat(32));
const b20 = Bytes20('0x' + '12'.repeat(20));
const b8 = Bytes8('0x1234567890abcdef');

// Type-safe operations
const hex = Bytes32.toHex(b32);
```

## Type Definition

All Bytes<N> types use symbol-based branding:

```typescript
import { brand } from './brand.js';

// Generic bytes (unsized)
export type BrandedBytes = Uint8Array & {
  readonly [brand]: "Bytes";
};

// Fixed-size Bytes32
export type BrandedBytes32 = Uint8Array & {
  readonly [brand]: "Bytes32";
  readonly size: 32;  // Hardcoded, not number
};

// Fixed-size Bytes20
export type BrandedBytes20 = Uint8Array & {
  readonly [brand]: "Bytes20";
  readonly size: 20;  // Hardcoded, not number
};
```

**Symbol branding:**
```typescript
// Import and use the brand symbol
import { brand } from '@tevm/voltaire/brand';

type MyBytes = Uint8Array & {
  readonly [brand]: "MyCustomBytes";
};

// The symbol is global and shared across all branded types
export declare const brand: unique symbol;
```

## Quick Start

<Tabs>
<Tab title="Namespace API">

```typescript
import * as Bytes from '@tevm/voltaire/primitives/Bytes/BrandedBytes';
import * as Bytes32 from '@tevm/voltaire/primitives/Bytes/Bytes32';

// Generic bytes
const generic = Bytes.from('0x1234');
const hex1 = Bytes.toHex(generic);

// Fixed-size
const fixed = Bytes32.from('0x' + '00'.repeat(32));
const hex2 = Bytes32.toHex(fixed);
const bigint = Bytes32.toBigint(fixed);
```

</Tab>
<Tab title="Class API">

```typescript
import { Bytes, Bytes32 } from '@tevm/voltaire';

// Generic bytes
const generic = Bytes('0x1234');
const hex1 = generic.toHex();

// Fixed-size
const fixed = Bytes32(42);
const hex2 = fixed.toHex();
const bigint = fixed.toBigint();
```

</Tab>
</Tabs>

## HexBytes Variants

Hex string representations with fixed sizes:

```typescript
// HexBytes<N> = hex string with exactly N bytes
type HexBytes32 = `0x${string}` & {
  readonly [brand]: "Hex";
  readonly size: 32;
};

type HexBytes20 = `0x${string}` & {
  readonly [brand]: "Hex";
  readonly size: 20;
};

// Usage
const hex: HexBytes32 = '0x' + 'ab'.repeat(32);
const bytes = Bytes32.fromHex(hex);
```

**Relationship to Hex:**
- Hex types use `brand: "Hex"` with size property
- Bytes types use `brand: "BytesN"` with size property
- Both leverage the same symbol-based branding pattern

## Type Hierarchy

Bytes<N> is the foundation for all fixed-size types:

```typescript
// Base pattern: Bytes<N>
type BrandedBytes<N> = Uint8Array & {
  readonly [brand]: string;
  readonly size: N;
};

// Specialized types extend the pattern
type BrandedAddress = Uint8Array & {
  readonly [brand]: "Address";
  readonly size: 20;  // Bytes20
};

type BrandedKeccak256Hash = Uint8Array & {
  readonly [brand]: "Keccak256Hash";
  readonly size: 32;  // Bytes32
};

// All fixed-size types are conceptually Bytes<N>
Address      → Bytes20 semantic extension
Hash         → Bytes32 semantic extension
Bytes32      → Bytes<32> concrete type
Bytes20      → Bytes<20> concrete type
Bytes8       → Bytes<8> concrete type
```

## Common Sizes

Voltaire provides pre-defined Bytes<N> types:

### Bytes8 (64-bit)
```typescript
import * as Bytes8 from '@tevm/voltaire/primitives/Bytes/Bytes8';

const b8 = Bytes8.from('0x1234567890abcdef');
console.log(Bytes8.size(b8)); // 8
```

### Bytes16 (128-bit)
```typescript
import * as Bytes16 from '@tevm/voltaire/primitives/Bytes/Bytes16';

const b16 = Bytes16.from('0x' + '12'.repeat(16));
console.log(Bytes16.size(b16)); // 16
```

### Bytes20 (160-bit)
```typescript
import * as Bytes20 from '@tevm/voltaire/primitives/Bytes/Bytes20';

const b20 = Bytes20.from('0x' + '12'.repeat(20));

// Address is a semantic extension of Bytes20
const addr = Address.from('0x742d35Cc6634C0532925a3b844Bc9e7595f51e3e');
console.log(addr.length); // 20
```

### Bytes32 (256-bit)
```typescript
import * as Bytes32 from '@tevm/voltaire/primitives/Bytes/Bytes32';

const b32 = Bytes32.from(42);
const value = Bytes32.toBigint(b32);

// Most critical size - storage slots, hashes, merkle nodes
```

### Bytes64 (512-bit)
```typescript
import * as Bytes64 from '@tevm/voltaire/primitives/Bytes/Bytes64';

const b64 = Bytes64.from('0x' + 'ab'.repeat(64));
console.log(Bytes64.size(b64)); // 64

// Used for ECDSA signatures (r + s)
```

## Symbol Branding

All Bytes<N> types use the global `brand` symbol:

```typescript
import { brand } from '@tevm/voltaire/brand';

// The symbol is unique and global
export declare const brand: unique symbol;

// Used consistently across all branded types
type BrandedBytes = Uint8Array & {
  readonly [brand]: "Bytes";
};

type BrandedBytes32 = Uint8Array & {
  readonly [brand]: "Bytes32";
  readonly size: 32;
};

// Import the symbol to create custom types
import { brand } from './brand.js';
type MyBytes = Uint8Array & { readonly [brand]: "MyType" };
```

**Benefits:**
- Zero runtime overhead (compile-time only)
- Prevents accidental mixing of types
- Enables tree-shakeable namespace APIs
- Hardcoded lengths for stricter validation

## API Methods

All Bytes<N> types share common methods:

### Constructors
- `from(value)` - Universal constructor
- `fromHex(hex)` - From hex string
- `fromBytes(bytes)` - From Uint8Array
- `fromNumber(n)` - From number (padded)
- `zero()` - Create zero-filled bytes

### Conversions
- `toHex(bytes)` - To hex string
- `toBytes(bytes)` - To Uint8Array
- `toString(bytes)` - To UTF-8 string

### Comparisons
- `equals(a, b)` - Check equality
- `compare(a, b)` - Compare for sorting

### Operations
- `concat(...bytes)` - Concatenate multiple
- `slice(bytes, start?, end?)` - Extract portion
- `clone(bytes)` - Create independent copy
- `size(bytes)` - Get byte length
- `isEmpty(bytes)` - Check if empty

### Size-Specific (Bytes32)
- `toBigint(bytes)` - Convert to bigint
- `toAddress(bytes)` - Extract last 20 bytes
- `toHash(bytes)` - Convert to Hash type

## Type Safety

Bytes<N> prevents mixing different sizes:

```typescript
const b32 = Bytes32(42);
const b16 = Bytes16('0x' + '12'.repeat(16));
const b8 = Bytes8('0x1234567890abcdef');

// Type error: cannot assign Bytes16 to Bytes32
const wrong1: Bytes32.BrandedBytes32 = b16;

// Type error: cannot assign Bytes8 to Bytes32
const wrong2: Bytes32.BrandedBytes32 = b8;

// Must convert explicitly
const converted = Bytes32(concat([b16, b16]));
```

**Hardcoded lengths:**
```typescript
// Type knows exact length at compile time
type Bytes32 = Uint8Array & {
  readonly size: 32;  // Literal 32, not number
};

// TypeScript enforces exact size
function acceptBytes32(b: Bytes32.BrandedBytes32) {
  console.log(b.length); // Always 32
}
```

## Usage Patterns

### Generic Byte Manipulation
```typescript
import * as Bytes from '@tevm/voltaire/primitives/Bytes/BrandedBytes';

// Concatenate multiple byte arrays
const a = Bytes.from('0x1234');
const b = Bytes.from('0x5678');
const combined = Bytes.concat(a, b);
console.log(Bytes.toHex(combined)); // "0x12345678"

// Slice portions
const slice = Bytes.slice(combined, 1, 3);
console.log(Bytes.toHex(slice)); // "0x3456"
```

### Fixed-Size Operations
```typescript
import * as Bytes32 from '@tevm/voltaire/primitives/Bytes/Bytes32';

// Storage slot
const slot = Bytes32.zero();

// Convert to/from bigint
const value = 42n;
const bytes = Bytes32.fromBigint(value);
const restored = Bytes32.toBigint(bytes);
console.log(restored === value); // true

// Extract address from slot
const addrBytes = Bytes32.toAddress(bytes);
console.log(addrBytes.length); // 20
```

### Type Hierarchy
```typescript
import * as Bytes32 from '@tevm/voltaire/primitives/Bytes/Bytes32';
import * as Hash from '@tevm/voltaire/primitives/Hash';

// Hash extends Bytes32 semantically
const hash = Hash.keccak256(data);
const bytes = Bytes32.from(hash); // Convert to generic Bytes32

// Both are 32 bytes but different semantics
console.log(hash.length); // 32
console.log(bytes.length); // 32
```

## Tree-Shaking

Import specific sizes for optimal bundles:

```typescript
// Import only what you need
import * as Bytes32 from '@tevm/voltaire/primitives/Bytes/Bytes32';
import * as Bytes20 from '@tevm/voltaire/primitives/Bytes/Bytes20';

// Only Bytes32 and Bytes20 included in bundle
// Bytes8, Bytes16, Bytes64 excluded

const b32 = Bytes32.from(42);
const b20 = Bytes20.from('0x' + '12'.repeat(20));
```

## Related

- [Bytes32](/primitives/bytes/bytes32) - 256-bit fixed-size bytes (most critical)
- [Bytes16](/primitives/bytes/bytes16) - 128-bit fixed-size bytes
- [Bytes64](/primitives/bytes/bytes64) - 512-bit fixed-size bytes
- [Address](/primitives/address) - 160-bit Ethereum addresses (extends Bytes20)
- [Hash](/primitives/hash) - 256-bit Keccak256 hashes (extends Bytes32)
- [Hex](/primitives/hex) - Hex string types with optional sizing

## Specification References

- [Ethereum Yellow Paper](https://ethereum.github.io/yellowpaper/paper.pdf) - Word size (Section 3)
- [EIP-712](https://eips.ethereum.org/EIPS/eip-712) - Typed structured data hashing
- [ABI Encoding](https://docs.soliditylang.org/en/latest/abi-spec.html) - Fixed-size types
