---
title: "Bundle"
description: "Transaction bundles for MEV strategies with Flashbots integration"
---

## Overview

Bundle represents atomic transaction bundles for MEV (Maximal Extractable Value) strategies. Bundles are submitted to block builders via MEV relays like Flashbots. All transactions in a bundle execute sequentially in the same block or the entire bundle is discarded.

```typescript
import * as Bundle from '@tevm/voltaire/Bundle'

const bundle = Bundle.from({
  transactions: [signedTx1, signedTx2],
  blockNumber: 18500000n,
  minTimestamp: 1700000000n,
  maxTimestamp: 1700001000n,
})

// Submit to Flashbots
const params = Bundle.toFlashbotsParams(bundle)
await flashbots.request({ method: 'eth_sendBundle', params: [params] })
```

## API

### from

Creates a Bundle from various input types.

```typescript
function from(value: BundleLike): BundleType
```

**Parameters:**
- `transactions` - Array of signed transactions (Uint8Array or hex strings)
- `blockNumber` - Target block number (optional)
- `minTimestamp` - Minimum block timestamp (optional)
- `maxTimestamp` - Maximum block timestamp (optional)
- `revertingTxHashes` - Transaction hashes allowed to revert (optional)

```typescript
// From bytes
const bundle = Bundle.from({
  transactions: [tx1Bytes, tx2Bytes],
  blockNumber: 18500000n,
})

// From hex strings
const bundle = Bundle.from({
  transactions: ['0x02f8...', '0x02f8...'],
  blockNumber: '0x11a5ec0',
})

// With timestamp constraints
const bundle = Bundle.from({
  transactions: [signedTx],
  minTimestamp: BigInt(Math.floor(Date.now() / 1000)),
  maxTimestamp: BigInt(Math.floor(Date.now() / 1000) + 120),
})

// With revert allowlist
const bundle = Bundle.from({
  transactions: [backrunTx, targetTx],
  revertingTxHashes: [targetTxHash],
})
```

Throws `InvalidBundleError` if:
- `transactions` is empty or not an array
- Transaction format is invalid
- Reverting hash is not 32 bytes

### addTransaction

Adds a transaction to the bundle, returning a new bundle (immutable).

```typescript
function addTransaction(
  bundle: BundleType,
  transaction: Uint8Array | string
): BundleType
```

```typescript
const bundle = Bundle.from({ transactions: [tx1] })
const newBundle = Bundle.addTransaction(bundle, tx2)

console.log(Bundle.size(bundle))    // 1 (original unchanged)
console.log(Bundle.size(newBundle)) // 2
```

### size

Returns the number of transactions in the bundle.

```typescript
function size(bundle: BundleType): number
```

```typescript
const bundle = Bundle.from({
  transactions: [tx1, tx2, tx3],
})

console.log(Bundle.size(bundle)) // 3
```

### toHash

Computes the bundle hash (keccak256 of concatenated transaction hashes).

```typescript
function toHash(
  bundle: BundleType,
  crypto: { keccak256: (data: Uint8Array) => Uint8Array }
): HashType
```

```typescript
import * as Keccak256 from '@tevm/voltaire/Keccak256'

const bundle = Bundle.from({ transactions: [tx1, tx2] })
const hash = Bundle.toHash(bundle, { keccak256: Keccak256.hash })

console.log(hash) // Uint8Array(32)
```

### toFlashbotsParams

Converts bundle to Flashbots `eth_sendBundle` RPC parameters.

```typescript
function toFlashbotsParams(bundle: BundleType): {
  txs: string[]
  blockNumber?: string
  minTimestamp?: number
  maxTimestamp?: number
  revertingTxHashes?: string[]
}
```

```typescript
const bundle = Bundle.from({
  transactions: [tx1, tx2],
  blockNumber: 18500000n,
  minTimestamp: 1700000000n,
})

const params = Bundle.toFlashbotsParams(bundle)
// {
//   txs: ['0x02f8...', '0x02f8...'],
//   blockNumber: '0x11a5ec0',
//   minTimestamp: 1700000000
// }

// Submit to Flashbots relay
const response = await fetch('https://relay.flashbots.net', {
  method: 'POST',
  body: JSON.stringify({
    jsonrpc: '2.0',
    method: 'eth_sendBundle',
    params: [params],
    id: 1,
  }),
})
```

## Types

### BundleType

```typescript
type BundleType = {
  /** Ordered array of signed transaction bytes */
  readonly transactions: readonly Uint8Array[]

  /** Target block number for inclusion */
  readonly blockNumber?: BlockNumberType

  /** Minimum block timestamp for inclusion */
  readonly minTimestamp?: Uint256Type

  /** Maximum block timestamp for inclusion */
  readonly maxTimestamp?: Uint256Type

  /** Transaction hashes allowed to revert without failing bundle */
  readonly revertingTxHashes?: readonly HashType[]
}
```

### BundleLike

Flexible input type accepted by `from()`:

```typescript
type BundleLike = BundleType | {
  transactions: (Uint8Array | string)[]
  blockNumber?: BlockNumberType | bigint | number | string
  minTimestamp?: Uint256Type | bigint | number | string
  maxTimestamp?: Uint256Type | bigint | number | string
  revertingTxHashes?: (HashType | string)[]
}
```

## Errors

### InvalidBundleError

Thrown when bundle construction fails.

```typescript
import { InvalidBundleError } from '@tevm/voltaire/Bundle'

try {
  const bundle = Bundle.from({ transactions: [] })
} catch (error) {
  if (error instanceof InvalidBundleError) {
    console.log(error.message)  // 'Bundle must contain at least one transaction'
    console.log(error.details)  // { value: { transactions: [] } }
  }
}
```

## MEV Concepts

### Atomic Execution

Bundles guarantee atomicity: all transactions execute in order or none execute. This enables:
- **Arbitrage** - Capture price differences across DEXs
- **Liquidations** - Execute liquidations with guaranteed profit
- **Backrunning** - Follow target transactions with profitable trades

### Reverting Transaction Allowlist

Some MEV strategies require allowing specific transactions to revert:

```typescript
// Backrun strategy: target tx might revert, but backrun should still execute
const bundle = Bundle.from({
  transactions: [targetTx, backrunTx],
  revertingTxHashes: [targetTxHash],
})
```

If `targetTx` reverts, the bundle continues. If `backrunTx` reverts, the entire bundle fails.

### Timestamp Constraints

Control when a bundle is valid:

```typescript
const now = BigInt(Math.floor(Date.now() / 1000))

const bundle = Bundle.from({
  transactions: [timeSensitiveTx],
  minTimestamp: now,           // Not before now
  maxTimestamp: now + 120n,    // Expires in 2 minutes
})
```

## See Also

- [Transaction](/primitives/transaction) - Transaction encoding
- [Keccak256](/crypto/keccak256) - Hash functions for bundle hashing
- [Flashbots Docs](https://docs.flashbots.net/flashbots-auction/overview) - Flashbots Auction documentation
