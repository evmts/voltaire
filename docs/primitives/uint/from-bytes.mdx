---
title: Uint.fromBytes
description: Create Uint256 from byte array in big-endian format
---

<Tabs>
<Tab title="Class API (recommended)">

## `Uint.fromBytes(bytes: Uint8Array): BrandedUint`

Create Uint256 from byte array (big-endian, up to 32 bytes).

**Parameters:**
- `bytes: Uint8Array` - Byte array (1-32 bytes, big-endian)

**Returns:** `BrandedUint` - Uint256 as branded Uint8Array

**Example:**

```typescript
import { Uint } from '@tevm/voltaire'

// Single byte
const a = Uint.fromBytes(new Uint8Array([0xff]))           // 255

// Multiple bytes (big-endian)
const b = Uint.fromBytes(new Uint8Array([0x01, 0x00]))     // 256
const c = Uint.fromBytes(new Uint8Array([0x00, 0x00, 0x00, 0xff]))  // 255

// Full 32 bytes
const d = Uint.fromBytes(new Uint8Array(32))  // 0

// Throws if too large
const tooBig = new Uint8Array(33)
Uint.fromBytes(tooBig)  // Error: cannot exceed 32 bytes
```

**Defined in:** [primitives/Uint/BrandedUint/fromBytes.ts:16](https://github.com/evmts/voltaire/blob/main/src/primitives/Uint/BrandedUint/fromBytes.ts#L16)

</Tab>
<Tab title="Namespace API (Tree-shakeable)">

## `fromBytes(bytes: Uint8Array): BrandedUint`

Create Uint256 from byte array.

**Example:**

```typescript
import * as Uint from '@tevm/voltaire/Uint'

const a = Uint.fromBytes(new Uint8Array([0xff]))
const b = Uint.fromBytes(new Uint8Array([0x01, 0x00]))
```

**Defined in:** [primitives/Uint/BrandedUint/fromBytes.ts:16](https://github.com/evmts/voltaire/blob/main/src/primitives/Uint/BrandedUint/fromBytes.ts#L16)

</Tab>
<Tab title="Zig">

## `Uint.fromBytes(bytes: []const u8): !Uint`

Create from byte slice (big-endian, max 32 bytes).

**Example:**

```zig
const Uint = @import("primitives").Uint;

const bytes = [_]u8{ 0xff };
const a = try Uint.fromBytes(&bytes);

const multi = [_]u8{ 0x01, 0x00 };
const b = try Uint.fromBytes(&multi);
```

**Defined in:** [primitives/Uint/uint.zig](https://github.com/evmts/voltaire/blob/main/src/primitives/Uint/uint.zig)

</Tab>
</Tabs>

## Big-Endian Byte Order

Uint256 uses **big-endian** (network byte order): most significant byte first.

```
Big-Endian Layout (32 bytes):
┌─────────────────────────────────────┐
│ [0] [1] [2] ... [30] [31]          │
│ MSB              ...         LSB    │
│ Most Significant   Least Significant│
└─────────────────────────────────────┘
```

### Examples

```typescript
// Single byte: 255
const a = Uint.fromBytes(new Uint8Array([0xff]))
// Value: 0x000...00ff = 255

// Two bytes: 256
const b = Uint.fromBytes(new Uint8Array([0x01, 0x00]))
// Value: 0x000...0100 = 256

// Four bytes: 255
const c = Uint.fromBytes(new Uint8Array([0x00, 0x00, 0x00, 0xff]))
// Value: 0x000...00ff = 255

// Four bytes: 16909060 (0x01020304)
const d = Uint.fromBytes(new Uint8Array([0x01, 0x02, 0x03, 0x04]))
// Value: 0x000...01020304
```

## Length Handling

### Variable Length (1-32 bytes)

```typescript
// 1 byte
Uint.fromBytes(new Uint8Array([0xff]))  // OK

// 2 bytes
Uint.fromBytes(new Uint8Array([0x01, 0x00]))  // OK

// 20 bytes (Address size)
Uint.fromBytes(new Uint8Array(20))  // OK

// 32 bytes (Hash size)
Uint.fromBytes(new Uint8Array(32))  // OK

// 33 bytes - too large
Uint.fromBytes(new Uint8Array(33))  // Error: exceeds 32 bytes
```

### Leading Zeros

Input is zero-padded on the left to 32 bytes internally:

```typescript
// Input: [0xff] (1 byte)
// Internal: [0x00, 0x00, ..., 0x00, 0xff] (32 bytes)

const a = Uint.fromBytes(new Uint8Array([0xff]))
console.log(a.length)  // 32
```

## Converting from Primitives

### From Address (20 bytes)

```typescript
import { Address } from '@tevm/voltaire'

const addr = Address.fromHex("0x742d35Cc6634C0532925a3b844Bc9e7595f51e3e")
const addrAsUint = Uint.fromBytes(addr)
// Address is Uint8Array(20), converts to Uint256
```

### From Hash (32 bytes)

```typescript
import { Hash } from '@tevm/voltaire'

const hash = Hash.fromHex("0x1234...")
const hashAsUint = Uint.fromBytes(hash)
// Hash is Uint8Array(32), converts to Uint256
```

### From Bytecode

```typescript
import { Bytecode } from '@tevm/voltaire'

// Short bytecode (≤32 bytes)
const code = Bytecode.fromHex("0x6001")
const codeAsUint = Uint.fromBytes(code)  // OK if ≤32 bytes

// Long bytecode (>32 bytes) throws
const longCode = Bytecode.fromHex("0x" + "60".repeat(100))
Uint.fromBytes(longCode)  // Error: exceeds 32 bytes
```

## Zero-Copy Performance

`fromBytes` is **zero-copy** when possible:

```typescript
// Creates new internal 32-byte array
const bytes = new Uint8Array([0xff])
const uint = Uint.fromBytes(bytes)

// No allocation if already 32 bytes
const bytes32 = new Uint8Array(32)
bytes32[31] = 0xff
const uint2 = Uint.fromBytes(bytes32)  // Efficient
```

## Usage Patterns

### Buffer Conversion

```typescript
// Node.js Buffer to Uint
const buffer = Buffer.from([0x01, 0x02, 0x03, 0x04])
const uint = Uint.fromBytes(new Uint8Array(buffer))
```

### Slice of Larger Array

```typescript
// Extract 32 bytes from larger array
const data = new Uint8Array(100)
const slice = data.slice(0, 32)
const uint = Uint.fromBytes(slice)
```

### Reading Binary Data

```typescript
async function readUintFromFile(file: File, offset: number): Promise<BrandedUint> {
  const buffer = await file.arrayBuffer()
  const bytes = new Uint8Array(buffer, offset, 32)
  return Uint.fromBytes(bytes)
}
```

## See Also

- [toBytes](/primitives/uint/to-bytes) - Convert to byte array
- [fromAbiEncoded](/primitives/uint/from-abi-encoded) - From ABI-encoded (strict 32 bytes)
- [fromHex](/primitives/uint/from-hex) - From hex string
