---
title: Uint.fromAbiEncoded
description: Create Uint256 from ABI-encoded 32-byte value
---

<Tabs>
<Tab title="Class API (recommended)">

## `Uint.fromAbiEncoded(bytes: Uint8Array): BrandedUint`

Create Uint256 from ABI-encoded bytes. Requires exactly 32 bytes.

**Parameters:**
- `bytes: Uint8Array` - ABI-encoded bytes (exactly 32 bytes, big-endian)

**Returns:** `BrandedUint` - Uint256 as branded Uint8Array

**Example:**

```typescript
import { Uint } from '@tevm/voltaire'

// ABI-encoded uint256 (always 32 bytes)
const encoded = new Uint8Array(32)
encoded[31] = 0xff  // Last byte = 255

const value = Uint.fromAbiEncoded(encoded)  // 255

// Throws if wrong size
const wrong = new Uint8Array(20)
Uint.fromAbiEncoded(wrong)  // Error: must be exactly 32 bytes

const tooLarge = new Uint8Array(33)
Uint.fromAbiEncoded(tooLarge)  // Error: must be exactly 32 bytes
```

**Defined in:** [primitives/Uint/BrandedUint/fromAbiEncoded.ts](https://github.com/evmts/voltaire/blob/main/src/primitives/Uint/BrandedUint/fromAbiEncoded.ts)

</Tab>
<Tab title="Namespace API (Tree-shakeable)">

## `fromAbiEncoded(bytes: Uint8Array): BrandedUint`

Create Uint256 from ABI-encoded bytes.

**Example:**

```typescript
import * as Uint from '@tevm/voltaire/Uint'

const encoded = new Uint8Array(32)
encoded[31] = 0xff

const value = Uint.fromAbiEncoded(encoded)
```

**Defined in:** [primitives/Uint/BrandedUint/fromAbiEncoded.ts](https://github.com/evmts/voltaire/blob/main/src/primitives/Uint/BrandedUint/fromAbiEncoded.ts)

</Tab>
<Tab title="Zig">

## `Uint.fromAbiEncoded(bytes: *const [32]u8): Uint`

Create from ABI-encoded bytes (exactly 32 bytes).

**Example:**

```zig
const Uint = @import("primitives").Uint;

var encoded: [32]u8 = [_]u8{0} ** 32;
encoded[31] = 0xff;

const value = Uint.fromAbiEncoded(&encoded);
```

**Defined in:** [primitives/Uint/uint.zig](https://github.com/evmts/voltaire/blob/main/src/primitives/Uint/uint.zig)

</Tab>
</Tabs>

## ABI Encoding Format

Solidity ABI encoding for `uint256`:
- **Always 32 bytes** (256 bits)
- **Big-endian** byte order
- **Left-padded** with zeros for smaller values

```
ABI-Encoded uint256 (32 bytes):
┌──────────────────────────────────────┐
│ [0x00][0x00]...[0x00][value bytes]  │
│  padding zeros    actual value       │
└──────────────────────────────────────┘
```

### Examples

```typescript
// Value: 255 (0xff)
// ABI: [0x00, 0x00, ..., 0x00, 0xff]
const bytes1 = new Uint8Array(32)
bytes1[31] = 0xff
Uint.fromAbiEncoded(bytes1)  // 255

// Value: 256 (0x0100)
// ABI: [0x00, 0x00, ..., 0x01, 0x00]
const bytes2 = new Uint8Array(32)
bytes2[30] = 0x01
Uint.fromAbiEncoded(bytes2)  // 256

// Value: 0
// ABI: [0x00, 0x00, ..., 0x00, 0x00]
const bytes3 = new Uint8Array(32)
Uint.fromAbiEncoded(bytes3)  // 0
```

## Strict Length Requirement

Unlike `fromBytes` (1-32 bytes), `fromAbiEncoded` requires **exactly 32 bytes**:

```typescript
// fromBytes - flexible (1-32 bytes)
Uint.fromBytes(new Uint8Array([0xff]))        // OK
Uint.fromBytes(new Uint8Array(32))            // OK

// fromAbiEncoded - strict (exactly 32 bytes)
Uint.fromAbiEncoded(new Uint8Array([0xff]))   // Error: wrong size
Uint.fromAbiEncoded(new Uint8Array(32))       // OK
```

### Why Strict?

ABI encoding has fixed-size slots for type safety:

```solidity
// Solidity ABI always encodes uint256 as 32 bytes
function example(uint256 x) public { }

// Call data:
// 0x + function_selector (4 bytes) + uint256 (32 bytes)
```

## Decoding ABI Data

### Function Return Values

```typescript
// Decode uint256 return value
const returnData = "0x000000000000000000000000000000000000000000000000000000000000007b"
const bytes = Hex.toBytes(returnData)
const value = Uint.fromAbiEncoded(bytes)  // 123
```

### Event Log Data

```typescript
// Decode uint256 from event log
import { EventLog } from '@tevm/voltaire'

const log = EventLog.from({
  topics: [...],
  data: "0x000000000000000000000000000000000000000000000000000000000000007b"
})

const dataBytes = Hex.toBytes(log.data)
const amount = Uint.fromAbiEncoded(dataBytes)  // 123
```

### Multiple uint256 Values

```typescript
// ABI-encoded array of uint256 values
const encoded = "0x" +
  "000000000000000000000000000000000000000000000000000000000000007b" +  // 123
  "00000000000000000000000000000000000000000000000000000000000000ff"    // 255

const bytes = Hex.toBytes(encoded)

// Extract first uint256 (bytes 0-31)
const first = Uint.fromAbiEncoded(bytes.slice(0, 32))  // 123

// Extract second uint256 (bytes 32-63)
const second = Uint.fromAbiEncoded(bytes.slice(32, 64))  // 255
```

## Usage Patterns

### ABI Decoder Helper

```typescript
class AbiDecoder {
  private offset = 0

  constructor(private data: Uint8Array) {}

  readUint256(): BrandedUint {
    const bytes = this.data.slice(this.offset, this.offset + 32)
    if (bytes.length !== 32) {
      throw new Error("Insufficient data for uint256")
    }
    this.offset += 32
    return Uint.fromAbiEncoded(bytes)
  }
}

// Usage
const data = Hex.toBytes("0x...")
const decoder = new AbiDecoder(data)
const value1 = decoder.readUint256()
const value2 = decoder.readUint256()
```

### Contract Interaction

```typescript
// Decode contract call result
async function getBalance(address: string): Promise<BrandedUint> {
  const result = await eth_call({
    to: contractAddress,
    data: encodeCall("balanceOf(address)", [address])
  })

  const bytes = Hex.toBytes(result)
  return Uint.fromAbiEncoded(bytes)
}
```

### Type-Safe Validation

```typescript
function decodeUint256Safe(bytes: Uint8Array): BrandedUint | null {
  if (bytes.length !== 32) {
    return null  // Wrong size
  }
  return Uint.fromAbiEncoded(bytes)
}
```

## Performance

`fromAbiEncoded` is **zero-copy** - the input bytes are used directly as internal storage (no allocation needed).

For decoding large batches of uint256 values, this is the most efficient method.

## See Also

- [toAbiEncoded](/primitives/uint/to-abi-encoded) - Convert to ABI encoding
- [fromBytes](/primitives/uint/from-bytes) - From variable-length bytes (1-32)
- [Abi primitive](/primitives/abi) - ABI encoding utilities
