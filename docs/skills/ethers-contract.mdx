---
title: "Ethers-style Contract"
description: "Reference implementation of ethers v6 Contract patterns using Voltaire primitives"
---

<Info>
**Skill** â€” Copyable reference implementation. Use as-is or customize. See [Skills Philosophy](/concepts/skills).
</Info>

# Ethers-style Contract

A copyable reference implementation that follows [ethers v6](https://docs.ethers.org/v6/) Contract patterns, built on Voltaire primitives.

## Overview

This Skill provides:

- **EthersContract**: Main contract abstraction with ethers v6 API
- **ContractFactory**: Deploy new contracts
- **Type-safe**: Full TypeScript inference from ABI
- **Ethers-compatible**: Familiar API for ethers users

## Quick Start

```typescript
import { EthersContract, ContractFactory } from './ethers-contract';

// ERC20 ABI (as const for type inference)
const erc20Abi = [
  {
    type: 'function',
    name: 'balanceOf',
    stateMutability: 'view',
    inputs: [{ name: 'account', type: 'address' }],
    outputs: [{ name: '', type: 'uint256' }],
  },
  {
    type: 'function',
    name: 'transfer',
    stateMutability: 'nonpayable',
    inputs: [
      { name: 'to', type: 'address' },
      { name: 'amount', type: 'uint256' },
    ],
    outputs: [{ name: '', type: 'bool' }],
  },
  {
    type: 'event',
    name: 'Transfer',
    inputs: [
      { name: 'from', type: 'address', indexed: true },
      { name: 'to', type: 'address', indexed: true },
      { name: 'value', type: 'uint256', indexed: false },
    ],
  },
] as const;

// Create contract instance
const usdc = EthersContract({
  target: '0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48',
  abi: erc20Abi,
  runner: provider,
});

// Call view function (uses staticCall by default)
const balance = await usdc.balanceOf(address);

// Send transaction (uses send by default for nonpayable)
const tx = await usdc.transfer(recipient, 1000n);
await tx.wait();
```

## API Reference

### EthersContract

Create a contract instance for interacting with deployed contracts.

```typescript
const contract = EthersContract({
  target: string,      // Address or ENS name
  abi: readonly Item[], // Contract ABI
  runner?: ContractRunner, // Provider or Signer
});
```

### Properties

| Property | Type | Description |
|----------|------|-------------|
| `target` | `string` | Original target (address/ENS) |
| `interface` | `Abi` | Parsed ABI interface |
| `runner` | `ContractRunner \| null` | Connected provider/signer |
| `filters` | `ContractFilters` | Event filter factory |

### Core Methods

#### `getAddress(): Promise<string>`

Resolve and return the contract address.

```typescript
const address = await contract.getAddress();
```

#### `connect(runner): EthersContract`

Return new instance with different runner.

```typescript
const withSigner = contract.connect(signer);
```

#### `attach(target): EthersContract`

Return new instance with different address.

```typescript
const otherToken = contract.attach('0x...');
```

#### `getDeployedCode(): Promise<string | null>`

Get deployed bytecode (or null if not deployed).

```typescript
const code = await contract.getDeployedCode();
```

#### `waitForDeployment(): Promise<EthersContract>`

Wait until contract is deployed.

```typescript
const deployed = await factory.deploy(...args);
await deployed.waitForDeployment();
```

### Function Methods

Each ABI function becomes a callable with additional methods:

```typescript
// Default behavior based on stateMutability
await contract.functionName(...args);

// Explicit variants
await contract.functionName.staticCall(...args);  // eth_call
await contract.functionName.send(...args);        // eth_sendTransaction
await contract.functionName.estimateGas(...args); // eth_estimateGas
await contract.functionName.populateTransaction(...args); // Build tx
```

#### Default Behavior

| stateMutability | Default Method |
|-----------------|---------------|
| `view`, `pure` | `staticCall` |
| `nonpayable`, `payable` | `send` |

#### Transaction Overrides

Pass overrides as the last argument:

```typescript
const tx = await contract.transfer(to, amount, {
  gasLimit: 100000n,
  maxFeePerGas: 50_000_000_000n,
});
```

### Event Methods

#### `filters.EventName(...args)`

Create event filter for subscriptions/queries.

```typescript
// All Transfer events
const allTransfers = contract.filters.Transfer();

// Filtered by indexed params
const fromMe = contract.filters.Transfer({ from: myAddress });
```

#### `queryFilter(event, fromBlock?, toBlock?)`

Query historical logs.

```typescript
const logs = await contract.queryFilter(
  contract.filters.Transfer({ from: myAddress }),
  fromBlock,
  toBlock
);

for (const log of logs) {
  console.log(log.eventName, log.args);
}
```

#### Event Subscriptions

```typescript
// Subscribe
await contract.on('Transfer', (from, to, value, event) => {
  console.log(`${from} -> ${to}: ${value}`);
});

// Subscribe once
await contract.once('Transfer', listener);

// Unsubscribe
await contract.off('Transfer', listener);

// Remove all listeners
await contract.removeAllListeners('Transfer');
await contract.removeAllListeners(); // All events

// List listeners
const count = await contract.listenerCount('Transfer');
const listeners = await contract.listeners('Transfer');
```

## ContractFactory

Deploy new contracts.

```typescript
const factory = ContractFactory({
  abi: myTokenAbi,
  bytecode: '0x608060405234801561001057600080fd5b50...',
  runner: signer,
});

// Deploy with constructor args
const contract = await factory.deploy('MyToken', 'MTK', 18);
await contract.waitForDeployment();

console.log('Deployed at:', await contract.getAddress());
```

### Factory Methods

#### `getDeployTransaction(...args)`

Build deployment transaction without sending.

```typescript
const tx = await factory.getDeployTransaction('MyToken', 'MTK', 18);
console.log(tx.data); // bytecode + encoded constructor args
```

#### `deploy(...args)`

Deploy contract and return instance.

```typescript
const contract = await factory.deploy('MyToken', 'MTK', 18);
```

#### `attach(target)`

Create contract instance at existing address.

```typescript
const existing = factory.attach('0x...');
```

#### `connect(runner)`

Return new factory with different runner.

```typescript
const withSigner = factory.connect(newSigner);
```

### Static Methods

#### `ContractFactory.fromSolidity(output, runner?)`

Create from Solidity compiler output.

```typescript
import artifact from './MyToken.json';

const factory = ContractFactory.fromSolidity(artifact, signer);
```

## Error Handling

### Error Types

```typescript
import {
  UnsupportedOperationError,  // Runner lacks capability
  CallExceptionError,         // Contract reverted
  InvalidArgumentError,       // Bad input
  FunctionNotFoundError,      // Function not in ABI
  EventNotFoundError,         // Event not in ABI
} from './ethers-contract';
```

### Revert Decoding

```typescript
import { decodeRevertReason, PanicReasons } from './ethers-contract';

try {
  await contract.transfer(to, amount);
} catch (error) {
  if (error instanceof CallExceptionError) {
    console.log('Revert reason:', error.revert?.name);
  }
}
```

## Type Safety

The implementation provides full type inference from ABI:

```typescript
const abi = [
  {
    type: 'function',
    name: 'balanceOf',
    stateMutability: 'view',
    inputs: [{ name: 'account', type: 'address' }],
    outputs: [{ name: '', type: 'uint256' }],
  },
] as const;

const contract = EthersContract({ target: '0x...', abi, runner: provider });

// TypeScript knows:
// - balanceOf takes 1 address argument
// - balanceOf returns bigint
const balance = await contract.balanceOf('0x...');
//    ^? Promise<bigint>
```

## Differences from ethers v6

| Feature | ethers v6 | This Implementation |
|---------|-----------|---------------------|
| Constructor | `new Contract(...)` | `EthersContract({...})` |
| ENS Resolution | Built-in | Simplified (address only) |
| Multicall | Not built-in | Not included |
| Provider Events | Full support | Basic polling |
| Error Decoding | Full custom errors | Basic + Panic |

## Migration from ethers

```typescript
// ethers v6
import { Contract } from 'ethers';
const contract = new Contract(address, abi, provider);

// Voltaire ethers-contract
import { EthersContract } from './ethers-contract';
const contract = EthersContract({ target: address, abi, runner: provider });

// API is otherwise identical
const balance = await contract.balanceOf(address);
const tx = await contract.transfer(to, amount);
```

## Installation

Copy the `examples/ethers-contract/` directory into your project:

```
your-project/
  contracts/
    EthersContract.js
    ContractFactory.js
    EthersContractTypes.ts
    errors.ts
    index.ts
```

Then import and use:

```typescript
import { EthersContract, ContractFactory } from './contracts';
```

## See Also

- [Contract (Voltaire native)](/docs/contract) - Voltaire's native contract abstraction
- [EventStream](/docs/contract/events) - Robust event streaming
- [Abi](/docs/primitives/abi) - ABI encoding/decoding primitives
