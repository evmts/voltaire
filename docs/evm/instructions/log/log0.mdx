---
title: "LOG0 (0xa0)"
description: "Emit log with no indexed topics"
---

## Overview

**Opcode:** `0xa0`
**Introduced:** Frontier (EVM genesis)

LOG0 emits a log entry with no indexed topics. Only the event data (non-indexed parameters) is logged, making it useful for simple event tracking where filtering by topics is not needed.

## Specification

**Stack Input:**
```
offset (top)
length
```

**Stack Output:**
```
(none)
```

**Gas Cost:** `375 + (8 × data_length) + memory_expansion_cost`

**Operation:**
```
data = memory[offset : offset + length]
log_entry = { address: msg.sender, topics: [], data: data }
append log_entry to logs
```

## Behavior

LOG0 pops offset and length from the stack, reads data from memory, and appends a log entry:

- **Offset**: Starting position in memory (256-bit value)
- **Length**: Number of bytes to read from memory (256-bit value)
- **Data**: Bytes read from memory, padded with zeros if beyond allocated memory
- **Topics**: Empty array (0 indexed parameters)

### Memory Expansion

If the data range extends beyond current memory allocation, memory expands to word boundaries:

```
new_memory_size = (ceil((offset + length) / 32)) * 32
```

### Static Call Protection

LOG0 cannot execute in static call context (EIP-214):

```solidity
function badLog() external view {
    // Reverts: StaticCallViolation
}
```

## Examples

### Empty Log

```typescript
import { handler_0xa0_LOG0 } from '@tevm/voltaire/evm/log';

const frame = createFrame({
  address: "0x1234567890123456789012345678901234567890",
  stack: [0n, 0n],  // offset=0, length=0
  gasRemaining: 1000000n,
});

const err = handler_0xa0_LOG0(frame);
console.log(err); // null (success)
console.log(frame.logs); // [{ address, topics: [], data: Uint8Array(0) }]
console.log(frame.gasRemaining); // 999625n (1000000 - 375)
```

### Log with Data

```typescript
const frame = createFrame({
  address: "0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa",
  memory: new Map([
    [0, 0xde], [1, 0xad], [2, 0xbe], [3, 0xef]
  ]),
  stack: [0n, 4n],  // offset=0, length=4
  gasRemaining: 1000000n,
});

handler_0xa0_LOG0(frame);

const log = frame.logs[0];
console.log(log.data); // Uint8Array(4) [0xde, 0xad, 0xbe, 0xef]
console.log(frame.gasRemaining); // 999617n (375 base + 32 memory + 32 data)
```

### Solidity Event with No Topics

```solidity
event SimpleLog(string message);

contract Logger {
  function log(string memory msg) public {
    emit SimpleLog(msg);  // Compiler generates LOG0
  }
}

// Usage
Logger logger = new Logger();
logger.log("Hello, world!");
// Transaction receipt includes log with empty topics
```

### Non-Indexed Event Parameters

```solidity
event Transfer(uint256 indexed id, address from, address to, uint256 value);

// If only 'id' is indexed, Solidity uses LOG1
// But we can emit an event with all non-indexed params using LOG0:

event Data(string text, uint256 amount, bytes payload);

contract DataLogger {
  function logData(string memory text, uint256 amount, bytes memory payload) public {
    emit Data(text, amount, payload);  // LOG0 (no indexed params)
  }
}
```

## Gas Cost

**Base Cost:** 375 gas

**Data Cost:** 8 gas per byte

**Memory Expansion:** Proportional to new memory range

**Examples:**
- Empty: 375 gas
- 1 byte: 375 + 8 = 383 gas
- 32 bytes: 375 + 256 = 631 gas
- 64 bytes: 375 + 512 + 3 (memory expansion) = 890 gas

## Edge Cases

### Zero-Length Log

```typescript
const frame = createFrame({ stack: [100n, 0n] });
handler_0xa0_LOG0(frame);
// Valid: logs empty data, no memory expansion
```

### Large Data

```typescript
const frame = createFrame({
  stack: [0n, 10000n],
  gasRemaining: 100000n,
});
handler_0xa0_LOG0(frame);
// Gas: 375 + 80000 (data) + memory expansion
// Result: OutOfGas (insufficient gas)
```

### Out of Bounds Memory

```typescript
const frame = createFrame({
  stack: [0n, 1000n],
  memory: new Map(),  // Empty
  gasRemaining: 100000n,
});
handler_0xa0_LOG0(frame);
// Memory fills with zeros from current_size to 1000
// log.data = Uint8Array(1000) filled with zeros
```

### Stack Underflow

```typescript
const frame = createFrame({ stack: [0n] });  // Only 1 item
const err = handler_0xa0_LOG0(frame);
console.log(err); // { type: "StackUnderflow" }
```

### Out of Gas

```typescript
const frame = createFrame({
  stack: [0n, 0n],
  gasRemaining: 374n,  // Not enough for base cost
});
const err = handler_0xa0_LOG0(frame);
console.log(err); // { type: "OutOfGas" }
```

## Common Usage

### Simple State Changes

```solidity
event Minted(uint256 amount);
event Burned(uint256 amount);

contract Token {
  function mint(uint256 amount) public {
    totalSupply += amount;
    emit Minted(amount);  // LOG0
  }

  function burn(uint256 amount) public {
    totalSupply -= amount;
    emit Burned(amount);  // LOG0
  }
}
```

### Unindexed Data Logging

```solidity
event ConfigUpdated(string newConfig);

contract Config {
  function updateConfig(string memory newConfig) public {
    config = newConfig;
    emit ConfigUpdated(newConfig);  // LOG0 (newConfig is non-indexed)
  }
}
```

### Status Events

```solidity
event StatusChanged(string status);

contract Service {
  function shutdown() public {
    isActive = false;
    emit StatusChanged("OFFLINE");  // LOG0
  }
}
```

## Security

### Cannot Block On-Chain Filtering

Since LOG0 has no topics, external systems cannot efficiently filter by indexed parameters. This is intentional—use LOG1-LOG4 when filtering capability is needed.

```solidity
// INEFFICIENT: No topic filtering
event EventWithoutTopics(address user, uint256 amount);

// BETTER: Use indexed parameters
event EventWithTopics(address indexed user, uint256 amount);
```

### Static Call Context Restrictions

LOG0 reverts in view/pure functions or during staticcall operations:

```solidity
function badView() external view {
  emit SomeEvent();  // Reverts: cannot log in view context
}

contract Caller {
  function staticCallBad(address target) public {
    target.staticcall(abi.encodeCall(Logger.log, ()));  // Reverts
  }
}
```

### Memory Boundaries

LOG0 reads memory up to offset + length. Uninitialized memory is zero-filled:

```solidity
// Be aware of what's written to memory
function logUninitialized() public {
  // If no data written to memory[0:100], emits 100 zero bytes
  emit Data();
}
```

## Implementation

<Tabs>
<Tab title="TypeScript">
```typescript
/**
 * LOG0 opcode (0xa0) - Emit log with no indexed topics
 */
export function handler_0xa0_LOG0(frame: BrandedFrame): EvmError | null {
  // Check static call (EIP-214)
  if (frame.isStatic) {
    return { type: "WriteProtection" };
  }

  // Check stack (need offset, length)
  if (frame.stack.length < 2) {
    return { type: "StackUnderflow" };
  }

  // Pop offset and length
  const offset = frame.stack.pop();
  const length = frame.stack.pop();

  // Validate bounds (u32 max)
  if (offset > Number.MAX_SAFE_INTEGER || length > Number.MAX_SAFE_INTEGER) {
    return { type: "OutOfBounds" };
  }

  const offsetNum = Number(offset);
  const lengthNum = Number(length);

  // Calculate gas: 375 base + 8 per byte
  const logGas = 375n;
  const dataGas = BigInt(lengthNum) * 8n;
  const totalGas = logGas + dataGas;

  // Memory expansion cost
  if (lengthNum > 0) {
    const endByte = offsetNum + lengthNum;
    const newMemWords = Math.ceil(endByte / 32);
    const newMemSize = newMemWords * 32;
    const memExpansion = calculateMemoryExpansion(frame.memorySize, newMemSize);
    frame.memorySize = newMemSize;
    frame.gasRemaining -= BigInt(memExpansion);
  }

  // Consume gas
  frame.gasRemaining -= totalGas;
  if (frame.gasRemaining < 0n) {
    return { type: "OutOfGas" };
  }

  // Read data from memory
  const data = new Uint8Array(lengthNum);
  for (let i = 0; i < lengthNum; i++) {
    data[i] = frame.memory.get(offsetNum + i) ?? 0;
  }

  // Create and append log entry
  const logEntry = {
    address: frame.address,
    topics: [],
    data,
  };

  if (!frame.logs) frame.logs = [];
  frame.logs.push(logEntry);

  // Increment PC
  frame.pc += 1;

  return null;
}
```
</Tab>

<Tab title="Zig">
```zig
/// LOG0 opcode (0xa0) - Emit log with no indexed topics
pub fn log0(frame: *FrameType) FrameType.EvmError!void {
    // EIP-214: LOG cannot be used in static call context
    if (frame.is_static) return error.StaticCallViolation;

    const topic_count: u8 = 0;
    const offset = try frame.popStack();
    const length = try frame.popStack();

    // Cast to u32 (check bounds)
    const off_u32 = std.math.cast(u32, offset) orelse return error.OutOfBounds;
    const length_u32 = std.math.cast(u32, length) orelse return error.OutOfBounds;

    // Calculate gas cost: 375 base + 8 per byte data
    const log_cost = 375 + @as(u64, length_u32) * 8;
    try frame.consumeGas(log_cost);

    // Memory expansion
    if (length_u32 > 0) {
        const end_bytes: u64 = @as(u64, off_u32) + @as(u64, length_u32);
        const mem_cost = frame.memoryExpansionCost(end_bytes);
        try frame.consumeGas(mem_cost);
        const aligned = wordAlignedSize(end_bytes);
        if (aligned > frame.memory_size) frame.memory_size = aligned;
    }

    const evm = frame.getEvm();

    // Read data from memory
    var data_slice: []u8 = &[_]u8{};
    if (length_u32 > 0) {
        const alloc = evm.arena.allocator();
        const buf = try alloc.alloc(u8, length_u32);
        var idx: u32 = 0;
        while (idx < length_u32) : (idx += 1) {
            buf[idx] = frame.readMemory(off_u32 + idx);
        }
        data_slice = buf;
    }

    // Create log entry
    const log_entry = call_result.Log{
        .address = frame.address,
        .topics = &[_]u256{},
        .data = data_slice,
    };

    try evm.logs.append(evm.arena.allocator(), log_entry);
    frame.pc += 1;
}
```
</Tab>
</Tabs>

## Testing

### Test Cases

```typescript
import { describe, it, expect } from 'vitest';
import { handler_0xa0_LOG0 } from './0xa0_LOG0.js';

describe('LOG0 (0xa0)', () => {
  it('emits log with empty data', () => {
    const frame = createFrame({
      stack: [0n, 0n],
      gasRemaining: 1000000n,
    });
    const err = handler_0xa0_LOG0(frame);
    expect(err).toBeNull();
    expect(frame.logs).toHaveLength(1);
    expect(frame.logs[0].topics).toEqual([]);
    expect(frame.gasRemaining).toBe(999625n);
  });

  it('reads data from memory', () => {
    const frame = createFrame({
      memory: new Map([[0, 0xde], [1, 0xad], [2, 0xbe], [3, 0xef]]),
      stack: [0n, 4n],
      gasRemaining: 1000000n,
    });
    handler_0xa0_LOG0(frame);
    const log = frame.logs[0];
    expect(log.data).toEqual(new Uint8Array([0xde, 0xad, 0xbe, 0xef]));
  });

  it('returns WriteProtection in static context', () => {
    const frame = createFrame({ isStatic: true, stack: [0n, 0n] });
    const err = handler_0xa0_LOG0(frame);
    expect(err).toEqual({ type: "WriteProtection" });
  });

  it('returns StackUnderflow with insufficient stack', () => {
    const frame = createFrame({ stack: [0n] });
    const err = handler_0xa0_LOG0(frame);
    expect(err).toEqual({ type: "StackUnderflow" });
  });

  it('returns OutOfGas when insufficient gas', () => {
    const frame = createFrame({
      stack: [0n, 0n],
      gasRemaining: 374n,
    });
    const err = handler_0xa0_LOG0(frame);
    expect(err).toEqual({ type: "OutOfGas" });
  });

  it('expands memory correctly', () => {
    const frame = createFrame({
      stack: [0n, 100n],
      gasRemaining: 1000000n,
    });
    handler_0xa0_LOG0(frame);
    expect(frame.memorySize).toBe(128); // ceil(100/32)*32
  });
});
```

## References

- [LOG0 Instruction (evm.codes)](https://www.evm.codes/#a0)
- [EIP-214: New opcode STATICCALL](https://eips.ethereum.org/EIPS/eip-214)
- [Solidity Events](https://docs.soliditylang.org/en/latest/contracts.html#events)
- [Yellow Paper](https://ethereum.github.io/yellowpaper/paper.pdf) - Section 9.4.1 (Logging)
