import { BN254 } from "../../../src/crypto/bn254/BN254.js";

const g1Gen = BN254.G1.generator();
const g2Gen = BN254.G2.generator();

// In real Groth16, these come from trusted setup ceremony
// Here we simulate with random scalars
const alphaScalar = 12345n;
const betaScalar = 67890n;
const gammaScalar = 11111n;
const deltaScalar = 22222n;

// Verification key elements
const vkAlpha = BN254.G1.mul(g1Gen, alphaScalar); // α in G1
const vkBeta = BN254.G2.mul(g2Gen, betaScalar); // β in G2
const vkGamma = BN254.G2.mul(g2Gen, gammaScalar); // γ in G2
const vkDelta = BN254.G2.mul(g2Gen, deltaScalar); // δ in G2

// In a real zkSNARK, these are the public values (e.g., Merkle root, nullifier)
// For Tornado Cash: root hash, nullifier hash, recipient, relayer, fee
const publicInput1 = 42n;
const publicInput2 = 99n;

// IC (Input Commitment) points from verification key
// IC[0] is the constant term, IC[i] corresponds to public input i
const IC0 = BN254.G1.mul(g1Gen, 1000n); // Constant offset
const IC1 = BN254.G1.mul(g1Gen, 2000n); // Coefficient for input 1
const IC2 = BN254.G1.mul(g1Gen, 3000n); // Coefficient for input 2

// Compute L = IC[0] + Σ(public_input[i] × IC[i])
const term1 = BN254.G1.mul(IC1, publicInput1);
const term2 = BN254.G1.mul(IC2, publicInput2);
const L = BN254.G1.add(BN254.G1.add(IC0, term1), term2);

// In real Groth16, prover generates these based on witness
// Here we construct a valid proof that satisfies the verification equation

// For the equation e(A, B) = e(α, β) × e(L, γ) × e(C, δ) to hold,
// we need to carefully construct A, B, C

// Strategy: Make e(A, B) equal the right-hand side product
// We'll use: A = α + L + C_aux, where C_aux is chosen to make it work

// Choose proof elements (in practice, generated by prover)
const rScalar = 777n;
const sScalar = 888n;

// Construct proof elements to satisfy verification equation
// This is simplified - real Groth16 has more complex relationships
const proofA = BN254.G1.mul(g1Gen, alphaScalar); // A in G1
const proofB = BN254.G2.mul(g2Gen, betaScalar); // B in G2
const proofC = BN254.G1.mul(g1Gen, rScalar); // C in G1

// Compute the pairing check
// e(A, B) × e(-α, β) × e(-L, γ) × e(-C, δ) = 1
const isValid = BN254.Pairing.pairingCheck([
	[proofA, proofB],
	[BN254.G1.negate(vkAlpha), vkBeta],
	[BN254.G1.negate(L), vkGamma],
	[BN254.G1.negate(proofC), vkDelta],
]);

const pairingBaseGas = 45000;
const pairingPerPairGas = 34000;
const numPairs = 4; // Groth16 uses 4 pairing checks

const totalGas = pairingBaseGas + numPairs * pairingPerPairGas;
