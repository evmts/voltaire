import { BN254 } from "../../../src/crypto/bn254/BN254.js";

/**
 * Groth16 zkSNARK Verification
 *
 * Demonstrates how Groth16 proofs are verified using BN254 pairings.
 * Groth16 is the most widely used zkSNARK system (Tornado Cash, zkSync, etc.)
 *
 * Verification equation:
 * e(A, B) = e(α, β) × e(L, γ) × e(C, δ)
 *
 * Where:
 * - (A, B, C) are the proof elements
 * - (α, β, γ, δ) are the verification key (public parameters)
 * - L is computed from public inputs
 */

console.log("=== Groth16 zkSNARK Verification ===\n");

// 1. Setup - Verification Key (Public Parameters)
console.log("1. Verification Key Setup");
console.log("-".repeat(40));

const g1Gen = BN254.G1.generator();
const g2Gen = BN254.G2.generator();

// In real Groth16, these come from trusted setup ceremony
// Here we simulate with random scalars
const alphaScalar = 12345n;
const betaScalar = 67890n;
const gammaScalar = 11111n;
const deltaScalar = 22222n;

// Verification key elements
const vkAlpha = BN254.G1.mul(g1Gen, alphaScalar); // α in G1
const vkBeta = BN254.G2.mul(g2Gen, betaScalar); // β in G2
const vkGamma = BN254.G2.mul(g2Gen, gammaScalar); // γ in G2
const vkDelta = BN254.G2.mul(g2Gen, deltaScalar); // δ in G2

console.log("Verification key generated:");
console.log("- α (G1 point)");
console.log("- β (G2 point)");
console.log("- γ (G2 point)");
console.log("- δ (G2 point)");
console.log("\nThese would come from trusted setup in production\n");

// 2. Public Inputs
console.log("2. Public Inputs");
console.log("-".repeat(40));

// In a real zkSNARK, these are the public values (e.g., Merkle root, nullifier)
// For Tornado Cash: root hash, nullifier hash, recipient, relayer, fee
const publicInput1 = 42n;
const publicInput2 = 99n;

console.log(`Public input 1: ${publicInput1}`);
console.log(`Public input 2: ${publicInput2}`);

// IC (Input Commitment) points from verification key
// IC[0] is the constant term, IC[i] corresponds to public input i
const IC0 = BN254.G1.mul(g1Gen, 1000n); // Constant offset
const IC1 = BN254.G1.mul(g1Gen, 2000n); // Coefficient for input 1
const IC2 = BN254.G1.mul(g1Gen, 3000n); // Coefficient for input 2

// Compute L = IC[0] + Σ(public_input[i] × IC[i])
const term1 = BN254.G1.mul(IC1, publicInput1);
const term2 = BN254.G1.mul(IC2, publicInput2);
const L = BN254.G1.add(BN254.G1.add(IC0, term1), term2);

console.log("\nComputed L = IC[0] + x₁×IC[1] + x₂×IC[2]");
console.log("L encodes the public inputs in G1\n");

// 3. Proof Elements
console.log("3. Proof Generation (Simulated)");
console.log("-".repeat(40));

// In real Groth16, prover generates these based on witness
// Here we construct a valid proof that satisfies the verification equation

// For the equation e(A, B) = e(α, β) × e(L, γ) × e(C, δ) to hold,
// we need to carefully construct A, B, C

// Strategy: Make e(A, B) equal the right-hand side product
// We'll use: A = α + L + C_aux, where C_aux is chosen to make it work

// Choose proof elements (in practice, generated by prover)
const rScalar = 777n;
const sScalar = 888n;

// Construct proof elements to satisfy verification equation
// This is simplified - real Groth16 has more complex relationships
const proofA = BN254.G1.mul(g1Gen, alphaScalar); // A in G1
const proofB = BN254.G2.mul(g2Gen, betaScalar); // B in G2
const proofC = BN254.G1.mul(g1Gen, rScalar); // C in G1

console.log("Proof elements:");
console.log("- A (G1 point)");
console.log("- B (G2 point)");
console.log("- C (G1 point)");
console.log("\nThese would be generated by prover with witness\n");

// 4. Verification Equation
console.log("4. Verification Equation");
console.log("-".repeat(40));

console.log("Checking: e(A, B) = e(α, β) × e(L, γ) × e(C, δ)");
console.log("Rearranged: e(A, B) × e(-α, β) × e(-L, γ) × e(-C, δ) = 1\n");

// Compute the pairing check
// e(A, B) × e(-α, β) × e(-L, γ) × e(-C, δ) = 1
const isValid = BN254.Pairing.pairingCheck([
	[proofA, proofB],
	[BN254.G1.negate(vkAlpha), vkBeta],
	[BN254.G1.negate(L), vkGamma],
	[BN254.G1.negate(proofC), vkDelta],
]);

console.log(`Verification result: ${isValid ? "VALID ✓" : "INVALID ✗"}`);
console.log("\nNote: This simplified example may not pass due to");
console.log("not implementing full Groth16 proof generation.\n");

// 5. Breaking Down the Verification
console.log("5. Understanding the Verification");
console.log("-".repeat(40));

console.log("Each pairing term has a purpose:");
console.log("- e(A, B): Main proof commitment");
console.log("- e(α, β): Verifies proof structure (from trusted setup)");
console.log("- e(L, γ): Binds public inputs to proof");
console.log("- e(C, δ): Additional proof element for soundness\n");

console.log("The equation ensures:");
console.log("1. Prover knows a valid witness");
console.log("2. Witness satisfies the circuit constraints");
console.log("3. Public inputs are correctly incorporated\n");

// 6. Security Properties
console.log("6. Groth16 Security Properties");
console.log("-".repeat(40));

console.log("Completeness: Valid proofs always verify");
console.log("Soundness: Invalid proofs fail (with high probability)");
console.log("Zero-knowledge: Proof reveals nothing about witness\n");

// 7. Real-world Usage Pattern
console.log("7. Real-world Usage Pattern");
console.log("-".repeat(40));

console.log("Tornado Cash example:");
console.log("Public inputs:");
console.log("  - Merkle root (proves deposit exists)");
console.log("  - Nullifier hash (prevents double-spend)");
console.log("  - Recipient address");
console.log("  - Relayer address");
console.log("  - Fee amount");
console.log("\nWitness (private):");
console.log("  - Secret value");
console.log("  - Nullifier");
console.log("  - Merkle path\n");

console.log('The proof proves: "I know a secret that corresponds to');
console.log('a deposit in the Merkle tree, without revealing which one"\n');

// 8. Gas Cost Analysis
console.log("8. Gas Cost (EIP-1108 Istanbul)");
console.log("-".repeat(40));

const pairingBaseGas = 45000;
const pairingPerPairGas = 34000;
const numPairs = 4; // Groth16 uses 4 pairing checks

const totalGas = pairingBaseGas + numPairs * pairingPerPairGas;

console.log(`Base cost: ${pairingBaseGas} gas`);
console.log(`Per-pair cost: ${pairingPerPairGas} gas × ${numPairs} pairs`);
console.log(`Total: ${totalGas} gas`);
console.log("\nThis makes zkSNARK verification affordable on Ethereum!\n");

// 9. Verification Key Serialization Format
console.log("9. Verification Key Structure");
console.log("-".repeat(40));

console.log("On-chain verification key contains:");
console.log("- α (G1): 64 bytes");
console.log("- β (G2): 128 bytes");
console.log("- γ (G2): 128 bytes");
console.log("- δ (G2): 128 bytes");
console.log("- IC[] (G1 array): 64 bytes × (num_public_inputs + 1)");
console.log("\nTotal for 2 public inputs: 576 bytes\n");

console.log("=== Complete ===");
console.log("\nKey Takeaways:");
console.log("- Groth16 uses 4 pairings for verification");
console.log("- Constant proof size (3 group elements)");
console.log("- Fast verification (~182k gas on Ethereum)");
console.log("- Requires trusted setup per circuit");
console.log("- Most widely deployed zkSNARK (Tornado, zkSync, Aztec)");
