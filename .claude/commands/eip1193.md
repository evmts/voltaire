---
description: Implement strongly-typed EIP-1193 Ethereum Provider interface for Voltaire
---

# EIP-1193 Provider Implementation Plan

Implement a type-safe, generic EIP-1193 Ethereum Provider interface in `src/provider/` that supports strongly-typed JSON-RPC methods and standardized events.

## EIP-1193 Specification Context

<eip1193-spec>
<abstract>
EIP-1193 formalizes the Ethereum Provider JavaScript API to promote wallet interoperability. The specification defines a minimal, event-driven interface that is agnostic of transport and RPC protocols. The Provider is the primary interface for web applications (dapps) to interact with Ethereum wallets and nodes.
</abstract>

<core-interface>
### Request Method

Primary interaction method:

```typescript
interface RequestArguments {
  readonly method: string;
  readonly params?: readonly unknown[] | object;
}

Provider.request(args: RequestArguments): Promise<unknown>;
```

- Identifies RPC methods by `method` string
- Accepts parameters via optional `params` (array or object)
- Returns Promise resolving with RPC result or rejecting with ProviderRpcError
</core-interface>

<events>
### Standard EIP-1193 Events

Providers MUST implement these five events using EventEmitter patterns:

1. **connect** - Emitted when Provider connects to a chain
   ```typescript
   interface ProviderConnectInfo {
     readonly chainId: string;
   }
   ```

2. **disconnect** - Emitted when disconnected from ALL chains
   ```typescript
   on('disconnect', (error: ProviderRpcError) => void)
   ```

3. **chainChanged** - Emitted when active chain changes
   ```typescript
   on('chainChanged', (chainId: string) => void)
   ```

4. **accountsChanged** - Emitted when available accounts change
   ```typescript
   on('accountsChanged', (accounts: string[]) => void)
   ```

5. **message** - Emitted for arbitrary notifications (subscriptions, etc)
   ```typescript
   interface ProviderMessage {
     readonly type: string;
     readonly data: unknown;
   }
   on('message', (message: ProviderMessage) => void)
   ```
</events>

<error-codes>
### Standard Error Codes

ProviderRpcError interface:

```typescript
interface ProviderRpcError extends Error {
  code: number;
  data?: unknown;
}
```

Standard codes:

| Code | Name | Meaning |
|------|------|---------|
| 4001 | User Rejected Request | User declined the operation |
| 4100 | Unauthorized | Method/account lacks user authorization |
| 4200 | Unsupported Method | Provider doesn't support the method |
| 4900 | Disconnected | Provider disconnected from all chains |
| 4901 | Chain Disconnected | Provider not connected to requested chain |
</error-codes>

<connectivity-semantics>
### Connectivity Definitions

- **Connected**: Provider can service RPC requests to at least one chain
- **Disconnected**: Provider unable to service any chain requests

Provider MUST:
- Accurately reflect configured chain via `eth_chainId`
- Emit `chainChanged` whenever chain changes
- Return correct values for `eth_accounts` and emit `accountsChanged` on modification
- Support authorization methods like `eth_requestAccounts`
</connectivity-semantics>
</eip1193-spec>

## TEVM Implementation Analysis

<tevm-patterns>
### Type System Architecture

TEVM's strongly-typed EIP-1193 implementation uses these patterns:

<rpc-schema>
**RPC Schema Base Type**:

```typescript
// viem-inspired pattern (tevm-monorepo/packages/decorators/src/eip1193/RpcSchema.ts)
export type RpcSchema = readonly {
  Method: string
  Parameters?: unknown
  ReturnType: unknown
}[]
```

This is a **readonly array** of method definitions. Each entry maps:
- `Method`: JSON-RPC method name (e.g., "eth_call")
- `Parameters`: Input parameter types
- `ReturnType`: Expected return type
</rpc-schema>

<request-function>
**Generic Request Function**:

```typescript
// tevm-monorepo/packages/decorators/src/eip1193/EIP1993RequestFn.ts
export type EIP1193RequestFn<TRpcSchema extends RpcSchema | undefined = undefined> = <
  TRpcSchemaOverride extends RpcSchemaOverride | undefined = undefined,
  TParameters extends EIP1193Parameters<DerivedRpcSchema<TRpcSchema, TRpcSchemaOverride>> =
    EIP1193Parameters<DerivedRpcSchema<TRpcSchema, TRpcSchemaOverride>>,
  _ReturnType = DerivedRpcSchema<TRpcSchema, TRpcSchemaOverride> extends RpcSchema
    ? Extract<DerivedRpcSchema<TRpcSchema, TRpcSchemaOverride>[number],
        { Method: TParameters['method'] }>['ReturnType']
    : unknown,
>(
  args: TParameters,
  options?: EIP1193RequestOptions,
) => Promise<_ReturnType>
```

Key features:
- Generic over `TRpcSchema` (base schema) and `TRpcSchemaOverride` (extension schema)
- Type-safe: return type extracted from schema based on method name
- Supports `options` parameter for retry/delay configuration
</request-function>

<provider-interface>
**Provider Type**:

```typescript
// tevm-monorepo/packages/decorators/src/request/Eip1193RequestProvider.ts
export type Eip1193RequestProvider = {
  request: EIP1193RequestFn<
    [
      ...PublicRpcSchema,           // Standard eth_* methods (from viem)
      ...TestRpcSchema<'anvil' | 'ganache' | 'hardhat'>,  // Test methods
      JsonRpcSchemaTevm['tevm_call'],        // Custom tevm methods
      JsonRpcSchemaTevm['tevm_dumpState'],
      JsonRpcSchemaTevm['tevm_loadState'],
      JsonRpcSchemaTevm['tevm_getAccount'],
      JsonRpcSchemaTevm['tevm_setAccount'],
    ]
  >
}
```

Schema composition via array spread to combine:
- Public methods (eth namespace)
- Test methods (anvil, hardhat, ganache)
- Custom methods (tevm namespace)
</provider-interface>

<event-emitter>
**Event System**:

```typescript
// tevm-monorepo/packages/node/src/EIP1193EventEmitterTypes.ts
export type EIP1193EventMap = {
  accountsChanged(accounts: Address[]): void
  chainChanged(chainId: string): void
  connect(connectInfo: ProviderConnectInfo): void
  disconnect(error: ProviderRpcError): void
  message(message: ProviderMessage): void
  // Non-standard extensions (internal use):
  newPendingTransaction(tx: TypedTransaction | ImpersonatedTx): void
  newReceipt(receipt: TxReceipt): void
  newBlock(block: Block): void
  newLog(log: GetFilterLogsReturnType[number]): void
}

export type EIP1193Events = {
  on<TEvent extends keyof EIP1193EventMap>(
    event: TEvent,
    listener: EIP1193EventMap[TEvent]
  ): void
  removeListener<TEvent extends keyof EIP1193EventMap>(
    event: TEvent,
    listener: EIP1193EventMap[TEvent]
  ): void
}

export type EIP1193EventEmitter = EIP1193Events & {
  emit(eventName: keyof EIP1193EventMap, ...args: any[]): boolean
}
```

Pattern: Typed event map + generic on/removeListener + emit
</event-emitter>

<error-handling>
**Error Class**:

```typescript
// tevm-monorepo/packages/node/src/EIP1193EventEmitterTypes.ts
export class ProviderRpcError extends Error {
  code: number
  details: string

  constructor(code: number, message: string) {
    super(message)
    this.code = code
    this.details = message
  }
}
```

Simple Error extension with numeric code and details string.
</error-handling>

<schema-composition>
**Custom Method Schemas**:

```typescript
// tevm-monorepo/packages/decorators/src/eip1193/JsonRpcSchemaTevm.ts
export type JsonRpcSchemaTevm = {
  tevm_call: {
    Method: 'tevm_call'
    Parameters: CallJsonRpcRequest['params']
    ReturnType: SerializeToJson<CallResult<never>>
  }
  tevm_getAccount: {
    Method: 'tevm_getAccount'
    Parameters: GetAccountJsonRpcRequest['params']
    ReturnType: SerializeToJson<GetAccountResult<never>>
  }
  // ... etc
}
```

Pattern: Object type with method names as keys, each containing Method/Parameters/ReturnType
</schema-composition>
</tevm-patterns>

## Voltaire JSON-RPC Package Analysis

<voltaire-jsonrpc>
### Current Structure

```
src/jsonrpc/
├── JsonRpc.js              # Root: exports all namespaces + types
├── index.ts                # Public entrypoint
├── types/                  # Shared primitives
│   ├── Address.js
│   ├── Hash.js
│   ├── Quantity.js
│   ├── BlockTag.js
│   ├── BlockSpec.js
│   ├── JsonRpcError.js
│   └── index.js
├── eth/
│   ├── methods.js          # EthMethod enum + all exports
│   ├── call/
│   │   └── eth_call.js     # Individual method: method, Params, Result
│   ├── blockNumber/
│   │   └── eth_blockNumber.js
│   └── ... (38 methods total)
├── debug/
│   └── methods.js
└── engine/
    └── methods.js
```

<method-definition-pattern>
**Individual Method Pattern** (e.g., `eth/call/eth_call.js`):

```javascript
/** The JSON-RPC method name */
export const method = "eth_call";

/**
 * Parameters for `eth_call`
 * @typedef {Object} Params
 * @property {Quantity} transaction - Transaction object
 * @property {BlockSpec} block - Block number, tag, or hash
 */

/**
 * Result for `eth_call`
 * @typedef {Quantity} Result
 */
```

Each method exports:
- `method`: string literal
- `Params` typedef (JSDoc)
- `Result` typedef (JSDoc)
</method-definition-pattern>

<namespace-aggregation>
**Namespace Aggregation** (e.g., `eth/methods.js`):

```javascript
import * as eth_call from "./call/eth_call.js";
import * as eth_blockNumber from "./blockNumber/eth_blockNumber.js";
// ... 36 more imports

export const EthMethod = {
  eth_call: "eth_call",
  eth_blockNumber: "eth_blockNumber",
  // ... enum of all method names
};

export {
  eth_call,
  eth_blockNumber,
  // ... re-export all namespaces
};
```

Pattern:
- Import each method as namespace
- Export enum of method names
- Re-export individual method namespaces for tree-shaking
</namespace-aggregation>

<root-export>
**Root Export** (`JsonRpc.js`):

```javascript
export * from "./engine/methods.js";
export * from "./eth/methods.js";
export * from "./debug/methods.js";
export * as types from "./types/index.js";

/** @typedef {EngineMethod | EthMethod | DebugMethod} JsonRpcMethod */
```

Union of all method enums for type-safe method names.
</root-export>
</voltaire-jsonrpc>

## Architecture Design

<architecture>
### Package Structure

```
src/provider/
├── index.ts                          # Public entrypoint
├── Provider.ts                       # Generic Provider interface
├── EIP1193Provider.ts                # Base EIP-1193 types
├── RpcSchema.ts                      # RPC schema type system
├── events/
│   ├── index.ts
│   ├── EIP1193Events.ts             # Standard event types
│   ├── EIP1193EventEmitter.ts       # EventEmitter interface
│   └── ProviderRpcError.ts          # Error class
├── request/
│   ├── index.ts
│   ├── RequestArguments.ts          # EIP-1193 request args
│   ├── EIP1193RequestFn.ts          # Generic request function type
│   └── EIP1193RequestOptions.ts     # Request options (retry, etc)
└── schemas/
    ├── index.ts
    ├── VoltaireRpcSchema.ts         # Default schema (eth + debug + engine)
    └── DerivedRpcSchema.ts          # Schema composition utilities
```

### Core Types

<provider-interface-design>
**Generic Provider Interface** (`Provider.ts`):

```typescript
import type { EIP1193RequestFn } from './request/EIP1193RequestFn.js';
import type { EIP1193EventEmitter } from './events/EIP1193EventEmitter.js';
import type { RpcSchema } from './RpcSchema.js';

/**
 * Generic Ethereum Provider interface
 *
 * @template TRpcSchema - RPC schema defining supported methods
 * @template TEventMap - Event map defining supported events (defaults to standard EIP-1193)
 *
 * @example
 * ```typescript
 * import type { Provider, VoltaireRpcSchema, EIP1193EventMap } from './provider/index.js';
 *
 * // Provider with Voltaire's full JSON-RPC schema
 * type VoltaireProvider = Provider<VoltaireRpcSchema, EIP1193EventMap>;
 *
 * // Provider with custom schema
 * type CustomProvider = Provider<MyCustomSchema, MyEventMap>;
 * ```
 */
export interface Provider<
  TRpcSchema extends RpcSchema = RpcSchema,
  TEventMap extends Record<string, (...args: any[]) => void> = EIP1193EventMap
> {
  /**
   * Execute JSON-RPC request
   *
   * @param args - Request arguments (method + params)
   * @param options - Optional request configuration (retry, timeout)
   * @returns Promise resolving to method-specific return type
   *
   * @example
   * ```typescript
   * const blockNumber = await provider.request({
   *   method: 'eth_blockNumber',
   *   params: []
   * });
   * ```
   */
  request: EIP1193RequestFn<TRpcSchema>;

  /**
   * Register event listener
   *
   * @param event - Event name
   * @param listener - Event handler
   *
   * @example
   * ```typescript
   * provider.on('chainChanged', (chainId: string) => {
   *   console.log('Chain changed to:', chainId);
   * });
   * ```
   */
  on<TEvent extends keyof TEventMap>(
    event: TEvent,
    listener: TEventMap[TEvent]
  ): this;

  /**
   * Remove event listener
   *
   * @param event - Event name
   * @param listener - Event handler to remove
   */
  removeListener<TEvent extends keyof TEventMap>(
    event: TEvent,
    listener: TEventMap[TEvent]
  ): this;
}
```

Key design decisions:
- Generic over `TRpcSchema` (supports custom method sets)
- Generic over `TEventMap` (extensible event system)
- Default to standard EIP-1193 types
- Returns `this` from event methods for chaining
</provider-interface-design>

<rpc-schema-design>
**RPC Schema Type System** (`RpcSchema.ts`):

```typescript
/**
 * Base RPC schema type
 *
 * Readonly array of method definitions. Each entry maps:
 * - Method: JSON-RPC method name
 * - Parameters: Input parameter types (optional)
 * - ReturnType: Expected return type
 *
 * @example
 * ```typescript
 * const MySchema = [
 *   {
 *     Method: 'eth_blockNumber',
 *     Parameters: [],
 *     ReturnType: string
 *   },
 *   {
 *     Method: 'eth_call',
 *     Parameters: [{ to: string, data: string }, string],
 *     ReturnType: string
 *   }
 * ] as const satisfies RpcSchema;
 * ```
 */
export type RpcSchema = readonly {
  Method: string;
  Parameters?: unknown;
  ReturnType: unknown;
}[];

/**
 * Extract method names from schema
 *
 * @example
 * ```typescript
 * type Methods = RpcMethodNames<VoltaireRpcSchema>;
 * // => 'eth_blockNumber' | 'eth_call' | 'debug_traceTransaction' | ...
 * ```
 */
export type RpcMethodNames<TSchema extends RpcSchema> =
  TSchema[number]['Method'];

/**
 * Extract parameters for specific method
 *
 * @example
 * ```typescript
 * type CallParams = RpcMethodParameters<VoltaireRpcSchema, 'eth_call'>;
 * // => [{ to: string, data: string, ... }, string]
 * ```
 */
export type RpcMethodParameters<
  TSchema extends RpcSchema,
  TMethod extends RpcMethodNames<TSchema>
> = Extract<TSchema[number], { Method: TMethod }>['Parameters'];

/**
 * Extract return type for specific method
 *
 * @example
 * ```typescript
 * type CallReturn = RpcMethodReturnType<VoltaireRpcSchema, 'eth_call'>;
 * // => string (hex-encoded bytes)
 * ```
 */
export type RpcMethodReturnType<
  TSchema extends RpcSchema,
  TMethod extends RpcMethodNames<TSchema>
> = Extract<TSchema[number], { Method: TMethod }>['ReturnType'];
```
</rpc-schema-design>

<request-function-design>
**Generic Request Function** (`request/EIP1193RequestFn.ts`):

```typescript
import type { RequestArguments } from './RequestArguments.js';
import type { EIP1193RequestOptions } from './EIP1193RequestOptions.js';
import type { RpcSchema, RpcMethodNames, RpcMethodReturnType } from '../RpcSchema.js';

/**
 * Type-safe EIP-1193 request function
 *
 * @template TRpcSchema - RPC schema defining supported methods
 *
 * Generic request function that:
 * - Accepts method name and parameters
 * - Returns Promise with method-specific return type
 * - Supports optional request configuration
 *
 * @example
 * ```typescript
 * const request: EIP1193RequestFn<VoltaireRpcSchema> = async (args, options) => {
 *   // Implementation
 * };
 *
 * // Type-safe: return type inferred as string
 * const blockNumber = await request({
 *   method: 'eth_blockNumber'
 * });
 *
 * // Type-safe: params validated, return type inferred
 * const balance = await request({
 *   method: 'eth_getBalance',
 *   params: ['0x123...', 'latest']
 * });
 * ```
 */
export type EIP1193RequestFn<TRpcSchema extends RpcSchema> = <
  TMethod extends RpcMethodNames<TRpcSchema>
>(
  args: RequestArguments<TRpcSchema, TMethod>,
  options?: EIP1193RequestOptions
) => Promise<RpcMethodReturnType<TRpcSchema, TMethod>>;
```

**Request Arguments** (`request/RequestArguments.ts`):

```typescript
import type { RpcSchema, RpcMethodNames, RpcMethodParameters } from '../RpcSchema.js';

/**
 * EIP-1193 request arguments
 *
 * @template TRpcSchema - RPC schema
 * @template TMethod - Specific method name
 *
 * @example
 * ```typescript
 * const args: RequestArguments<VoltaireRpcSchema, 'eth_call'> = {
 *   method: 'eth_call',
 *   params: [{ to: '0x...', data: '0x...' }, 'latest']
 * };
 * ```
 */
export interface RequestArguments<
  TRpcSchema extends RpcSchema,
  TMethod extends RpcMethodNames<TRpcSchema> = RpcMethodNames<TRpcSchema>
> {
  readonly method: TMethod;
  readonly params?: RpcMethodParameters<TRpcSchema, TMethod>;
}
```

**Request Options** (`request/EIP1193RequestOptions.ts`):

```typescript
/**
 * Optional request configuration
 *
 * @example
 * ```typescript
 * const result = await provider.request(
 *   { method: 'eth_blockNumber' },
 *   { retryCount: 3, retryDelay: 1000 }
 * );
 * ```
 */
export interface EIP1193RequestOptions {
  /** Max number of retries (default: 0) */
  retryCount?: number;
  /** Base delay between retries in ms (default: 0) */
  retryDelay?: number;
  /** Request timeout in ms (optional) */
  timeout?: number;
}
```
</request-function-design>

<event-system-design>
**Event System** (`events/EIP1193Events.ts`):

```typescript
import type { ProviderConnectInfo, ProviderMessage } from './EIP1193Provider.js';
import type { ProviderRpcError } from './ProviderRpcError.js';

/**
 * Standard EIP-1193 event map
 *
 * Defines the five standard events specified in EIP-1193.
 * Providers MAY extend this with custom events.
 *
 * @example
 * ```typescript
 * // Standard events only
 * type StandardProvider = {
 *   on<TEvent extends keyof EIP1193EventMap>(
 *     event: TEvent,
 *     listener: EIP1193EventMap[TEvent]
 *   ): void;
 * };
 *
 * // Extended events
 * type ExtendedEventMap = EIP1193EventMap & {
 *   newBlock(block: Block): void;
 *   newTransaction(tx: Transaction): void;
 * };
 * ```
 */
export interface EIP1193EventMap {
  /**
   * Emitted when Provider connects to a chain
   *
   * @param connectInfo - Chain connection information
   *
   * @example
   * ```typescript
   * provider.on('connect', ({ chainId }) => {
   *   console.log('Connected to chain:', chainId);
   * });
   * ```
   */
  connect(connectInfo: ProviderConnectInfo): void;

  /**
   * Emitted when Provider disconnects from ALL chains
   *
   * @param error - Disconnect error (code from CloseEvent spec)
   *
   * @example
   * ```typescript
   * provider.on('disconnect', (error) => {
   *   console.error('Disconnected:', error.message, error.code);
   * });
   * ```
   */
  disconnect(error: ProviderRpcError): void;

  /**
   * Emitted when active chain changes
   *
   * @param chainId - New chain ID (hex string per eth_chainId)
   *
   * @example
   * ```typescript
   * provider.on('chainChanged', (chainId) => {
   *   console.log('Switched to chain:', parseInt(chainId, 16));
   * });
   * ```
   */
  chainChanged(chainId: string): void;

  /**
   * Emitted when available accounts change
   *
   * @param accounts - New accounts array (per eth_accounts)
   *
   * @example
   * ```typescript
   * provider.on('accountsChanged', (accounts) => {
   *   if (accounts.length === 0) {
   *     console.log('Disconnected');
   *   } else {
   *     console.log('Active account:', accounts[0]);
   *   }
   * });
   * ```
   */
  accountsChanged(accounts: string[]): void;

  /**
   * Emitted for arbitrary notifications (subscriptions, etc)
   *
   * @param message - Provider message
   *
   * @example
   * ```typescript
   * provider.on('message', ({ type, data }) => {
   *   if (type === 'eth_subscription') {
   *     console.log('Subscription update:', data);
   *   }
   * });
   * ```
   */
  message(message: ProviderMessage): void;
}

/**
 * Generic event emitter interface
 *
 * @template TEventMap - Event map defining available events
 */
export interface EIP1193EventEmitter<
  TEventMap extends Record<string, (...args: any[]) => void> = EIP1193EventMap
> {
  /**
   * Register event listener
   */
  on<TEvent extends keyof TEventMap>(
    event: TEvent,
    listener: TEventMap[TEvent]
  ): this;

  /**
   * Remove event listener
   */
  removeListener<TEvent extends keyof TEventMap>(
    event: TEvent,
    listener: TEventMap[TEvent]
  ): this;

  /**
   * Emit event (internal use)
   * @internal
   */
  emit(eventName: keyof TEventMap, ...args: any[]): boolean;
}
```

**Supporting Types** (`events/EIP1193Provider.ts`):

```typescript
/**
 * Connection information
 *
 * Provided in 'connect' event
 */
export interface ProviderConnectInfo {
  /** Chain ID as hex string (per eth_chainId) */
  readonly chainId: string;
}

/**
 * Provider message
 *
 * Used for 'message' event (subscriptions, notifications)
 */
export interface ProviderMessage {
  /** Message type identifier */
  readonly type: string;
  /** Message payload */
  readonly data: unknown;
}

/**
 * Ethereum subscription message
 *
 * Specialized message for eth_subscribe notifications
 */
export interface EthSubscription extends ProviderMessage {
  readonly type: 'eth_subscription';
  readonly data: {
    subscription: string;
    result: unknown;
  };
}
```

**Error Class** (`events/ProviderRpcError.ts`):

```typescript
/**
 * Provider RPC error
 *
 * Extends Error with numeric code and optional data.
 * Codes follow EIP-1193 and JSON-RPC 2.0 specifications.
 *
 * @example
 * ```typescript
 * // Standard EIP-1193 error
 * throw new ProviderRpcError(4001, 'User rejected request');
 *
 * // With additional data
 * throw new ProviderRpcError(
 *   4200,
 *   'Unsupported method',
 *   { method: 'eth_customMethod' }
 * );
 * ```
 */
export class ProviderRpcError extends Error {
  /** Numeric error code (EIP-1193 or JSON-RPC 2.0) */
  code: number;

  /** Optional error data */
  data?: unknown;

  constructor(code: number, message: string, data?: unknown) {
    super(message);
    this.name = 'ProviderRpcError';
    this.code = code;
    this.data = data;
  }
}

/**
 * Standard EIP-1193 error codes
 */
export const EIP1193ErrorCode = {
  /** User rejected the request */
  UserRejectedRequest: 4001,
  /** Method/account not authorized */
  Unauthorized: 4100,
  /** Method not supported */
  UnsupportedMethod: 4200,
  /** Provider disconnected from all chains */
  Disconnected: 4900,
  /** Provider not connected to requested chain */
  ChainDisconnected: 4901,
} as const;

/**
 * JSON-RPC 2.0 error codes
 */
export const JsonRpcErrorCode = {
  /** Invalid JSON */
  ParseError: -32700,
  /** Invalid request object */
  InvalidRequest: -32600,
  /** Method not found */
  MethodNotFound: -32601,
  /** Invalid parameters */
  InvalidParams: -32602,
  /** Internal error */
  InternalError: -32603,
} as const;
```
</event-system-design>

<schema-composition-design>
**Voltaire Default Schema** (`schemas/VoltaireRpcSchema.ts`):

```typescript
import type { RpcSchema } from '../RpcSchema.js';
import type * as eth from '../../jsonrpc/eth/methods.js';
import type * as debug from '../../jsonrpc/debug/methods.js';
import type * as engine from '../../jsonrpc/engine/methods.js';

/**
 * Voltaire's default RPC schema
 *
 * Combines all JSON-RPC methods from:
 * - eth namespace (38 methods)
 * - debug namespace
 * - engine namespace
 *
 * @example
 * ```typescript
 * import type { Provider, VoltaireRpcSchema } from './provider/index.js';
 *
 * type VoltaireProvider = Provider<VoltaireRpcSchema>;
 *
 * const provider: VoltaireProvider = {
 *   request: async ({ method, params }) => {
 *     // Implementation
 *   },
 *   on: (event, listener) => this,
 *   removeListener: (event, listener) => this,
 * };
 * ```
 */
export type VoltaireRpcSchema = readonly [
  // eth namespace
  {
    Method: 'eth_accounts';
    Parameters: [];
    ReturnType: string[];
  },
  {
    Method: 'eth_blockNumber';
    Parameters: [];
    ReturnType: string;
  },
  {
    Method: 'eth_call';
    Parameters: [eth.eth_call.Params];
    ReturnType: eth.eth_call.Result;
  },
  {
    Method: 'eth_chainId';
    Parameters: [];
    ReturnType: string;
  },
  {
    Method: 'eth_getBalance';
    Parameters: [eth.eth_getBalance.Params];
    ReturnType: eth.eth_getBalance.Result;
  },
  // ... (all 38 eth methods)

  // debug namespace
  {
    Method: 'debug_traceTransaction';
    Parameters: [debug.debug_traceTransaction.Params];
    ReturnType: debug.debug_traceTransaction.Result;
  },
  // ... (all debug methods)

  // engine namespace
  {
    Method: 'engine_newPayloadV1';
    Parameters: [engine.engine_newPayloadV1.Params];
    ReturnType: engine.engine_newPayloadV1.Result;
  },
  // ... (all engine methods)
];

/**
 * Helper to create schema from existing JSON-RPC method definitions
 *
 * Converts Voltaire's existing method definitions into RpcSchema format.
 * This allows reusing existing type definitions without duplication.
 */
type MethodToSchemaEntry<T extends { method: string; Params: any; Result: any }> = {
  Method: T['method'];
  Parameters: T['Params'];
  ReturnType: T['Result'];
};
```
</schema-composition-design>
</architecture>

## Implementation Plan

<implementation-phases>
### Phase 1: Core Type System (No Implementation)

**Goal**: Establish type foundation without runtime code

**Files to create**:

1. `src/provider/RpcSchema.ts`
   - `RpcSchema` base type
   - `RpcMethodNames<T>` utility
   - `RpcMethodParameters<T, M>` utility
   - `RpcMethodReturnType<T, M>` utility
   - JSDoc with comprehensive examples

2. `src/provider/request/RequestArguments.ts`
   - `RequestArguments<TSchema, TMethod>` interface
   - JSDoc examples

3. `src/provider/request/EIP1193RequestOptions.ts`
   - `EIP1193RequestOptions` interface
   - JSDoc examples

4. `src/provider/request/EIP1193RequestFn.ts`
   - `EIP1193RequestFn<TSchema>` type
   - JSDoc examples
   - Reference EIP-1193 spec

5. `src/provider/request/index.ts`
   - Re-export all request types

**Tests**: None yet (pure types)

**Validation**:
- `bun run build:types` succeeds
- No runtime code generated

### Phase 2: Event System

**Goal**: Define event types and error handling

**Files to create**:

1. `src/provider/events/ProviderRpcError.ts`
   - `ProviderRpcError` class
   - `EIP1193ErrorCode` constants
   - `JsonRpcErrorCode` constants
   - Unit tests for error construction

2. `src/provider/events/EIP1193Provider.ts`
   - `ProviderConnectInfo` interface
   - `ProviderMessage` interface
   - `EthSubscription` interface
   - JSDoc with spec references

3. `src/provider/events/EIP1193Events.ts`
   - `EIP1193EventMap` interface
   - `EIP1193EventEmitter<TEventMap>` interface
   - JSDoc for each event with examples

4. `src/provider/events/index.ts`
   - Re-export all event types

**Tests**:
- `src/provider/events/ProviderRpcError.test.ts`
  - Error construction
  - Standard error codes
  - Error serialization

**Validation**:
- `bun run test:run provider/events`
- All tests pass

### Phase 3: Provider Interface

**Goal**: Define generic Provider interface

**Files to create**:

1. `src/provider/Provider.ts`
   - `Provider<TRpcSchema, TEventMap>` interface
   - Generic over schema and events
   - Defaults to standard EIP-1193
   - Comprehensive JSDoc

2. `src/provider/EIP1193Provider.ts`
   - Type alias: `EIP1193Provider = Provider<RpcSchema, EIP1193EventMap>`
   - Standard EIP-1193 provider (no custom schema/events)

**Tests**: None (interface only)

**Validation**:
- Type-checks with example usage
- JSDoc examples compile

### Phase 4: Voltaire Schema Integration

**Goal**: Connect Provider types to existing JSON-RPC definitions

**Files to create**:

1. `src/provider/schemas/VoltaireRpcSchema.ts`
   - Generate schema from existing `src/jsonrpc/` types
   - Map all eth methods
   - Map all debug methods
   - Map all engine methods
   - Use helper types to avoid duplication

2. `src/provider/schemas/DerivedRpcSchema.ts`
   - `DerivedRpcSchema<TBase, TOverride>` utility
   - Schema composition/extension
   - Allow adding custom methods to base schema

3. `src/provider/schemas/index.ts`
   - Re-export schema types

**Tests**:
- `src/provider/schemas/VoltaireRpcSchema.test.ts`
  - Type-level tests (using tsd or similar)
  - Verify method names match jsonrpc package
  - Verify parameter types match
  - Verify return types match

**Validation**:
- `bun run test:run provider/schemas`
- Type-checks against real JSON-RPC definitions

### Phase 5: Documentation & Examples

**Goal**: Document usage patterns

**Files to create**:

1. `src/provider/README.md`
   - Overview of Provider interface
   - EIP-1193 compliance
   - Type safety features
   - Extension patterns

2. `src/provider/index.ts`
   - Barrel export all public APIs
   - JSDoc module documentation

3. Examples in JSDoc:
   - Basic provider usage
   - Custom schema extension
   - Event handling
   - Error handling
   - Type-safe request calls

**Validation**:
- `bun run docs:build` succeeds
- Examples compile
- No broken links

### Phase 6: Future Extensibility

**Preparation for future implementation**:

1. Define extension points:
   - Custom RPC methods (via schema composition)
   - Custom events (via event map extension)
   - Custom error codes (via ProviderRpcError subclassing)

2. Document patterns:
   - How to add custom namespace
   - How to add custom events
   - How to implement Provider interface

3. Type-level validation:
   - Ensure type safety with custom schemas
   - Ensure event type safety
   - Ensure error type safety
</implementation-phases>

## Success Criteria

<success-criteria>
### Must Have

- [ ] `Provider<TRpcSchema, TEventMap>` generic interface defined
- [ ] Full type safety for request calls (method name → params → return type)
- [ ] All five standard EIP-1193 events typed
- [ ] `ProviderRpcError` class with standard error codes
- [ ] `VoltaireRpcSchema` integrating existing JSON-RPC types
- [ ] Schema composition utilities (`DerivedRpcSchema`)
- [ ] Zero runtime implementation (types only for now)
- [ ] Comprehensive JSDoc on all public APIs
- [ ] All examples in JSDoc are valid TypeScript
- [ ] `bun run build:types` succeeds
- [ ] No circular dependencies

### Should Have

- [ ] Unit tests for ProviderRpcError
- [ ] Type-level tests for VoltaireRpcSchema
- [ ] README with usage examples
- [ ] Extension patterns documented
- [ ] Tree-shakable exports

### Nice to Have

- [ ] JSON-RPC 2.0 batch request support (types only)
- [ ] Subscription event types (eth_subscribe/eth_unsubscribe)
- [ ] Provider capability detection types
- [ ] Transport abstraction (HTTP, WebSocket, IPC)
</success-criteria>

## Future Work

<future-work>
### Phase 7+: Implementation (Future)

After type system is stable:

1. **HTTP Provider**: Fetch-based implementation
2. **WebSocket Provider**: WebSocket with subscriptions
3. **IPC Provider**: Node.js IPC transport
4. **Test Provider**: In-memory for testing
5. **Proxy Provider**: Forward to window.ethereum
6. **Batch Provider**: Aggregate multiple requests

### Integration Points

1. **EVM Executor**: Connect Provider to EVM execution
2. **State Manager**: Provider → State queries
3. **Transaction Pool**: Provider → Transaction submission
4. **Event Bus**: EVM events → Provider events
5. **Filter Manager**: eth_newFilter → Event subscriptions

### Advanced Features

1. **Request Middleware**: Intercept/transform requests
2. **Response Caching**: Cache eth_call, eth_getCode, etc
3. **Automatic Retries**: Exponential backoff
4. **Request Queuing**: Limit concurrent requests
5. **Rate Limiting**: Respect RPC endpoint limits
</future-work>

## References

<references>
### Specifications

- [EIP-1193: Ethereum Provider JavaScript API](https://eips.ethereum.org/EIPS/eip-1193)
- [JSON-RPC 2.0 Specification](https://www.jsonrpc.org/specification)
- [Ethereum JSON-RPC API](https://ethereum.org/en/developers/docs/apis/json-rpc/)

### Implementations

- [TEVM @tevm/decorators](tevm-monorepo/packages/decorators/src/eip1193/)
- [TEVM @tevm/node](tevm-monorepo/packages/node/src/EIP1193EventEmitterTypes.ts)
- [Viem EIP-1193 Types](https://github.com/wevm/viem/blob/main/src/types/eip1193.ts)

### Voltaire Codebase

- [JSON-RPC Package](src/jsonrpc/)
- [Eth Methods](src/jsonrpc/eth/methods.js)
- [Debug Methods](src/jsonrpc/debug/methods.js)
- [Engine Methods](src/jsonrpc/engine/methods.js)
</references>

## Notes

<implementation-notes>
### Design Principles

1. **Type Safety First**: Leverage TypeScript's type system for correctness
2. **Tree Shakable**: Users only import what they use
3. **Extensible**: Easy to add custom methods/events
4. **Standards Compliant**: Follow EIP-1193 exactly
5. **Zero Runtime (Phase 1)**: Pure type system to start
6. **Reuse Existing**: Leverage voltaire's jsonrpc package types

### Anti-Patterns to Avoid

1. **Don't duplicate types**: Reuse jsonrpc package definitions
2. **Don't break tree-shaking**: Keep exports granular
3. **Don't add runtime code yet**: Types only for Phase 1-5
4. **Don't ignore EIP-1193 spec**: Follow it exactly
5. **Don't use `any`**: Maintain full type safety

### Testing Strategy

1. **Type-level tests**: Use tsd or ts-expect-error patterns
2. **Runtime tests**: Unit tests for error classes
3. **Integration tests**: (Future) Test full provider implementations
4. **Example validation**: Ensure JSDoc examples compile

### Naming Conventions

- **Files**: PascalCase for types (`Provider.ts`), camelCase for utils
- **Interfaces**: PascalCase (`Provider`, `EIP1193EventMap`)
- **Type aliases**: PascalCase (`VoltaireRpcSchema`)
- **Constants**: SCREAMING_SNAKE_CASE (`EIP1193ErrorCode`)
- **Generics**: `T` prefix (`TRpcSchema`, `TEventMap`, `TMethod`)
</implementation-notes>
