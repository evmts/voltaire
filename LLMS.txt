# Ethereum Primitives & Cryptography for Zig

Zig 0.15.1+ | https://github.com/evmts/voltaire | Mission-critical crypto infrastructure - zero error tolerance

---

## Critical Context

<zig_version_breaking_changes>
**Zig 0.15.1 ArrayList API (LLMs get this wrong):**
```zig
// ✅ CORRECT - UNMANAGED, allocator required every call
var list = std.ArrayList(T){};
defer list.deinit(allocator);
try list.append(allocator, item);

// ❌ WRONG - old API
var list = std.ArrayList(T).init(allocator);  // No init() method!
list.deinit();  // Missing allocator
```
</zig_version_breaking_changes>

---

## Library Scope

<modules>
**primitives:** Uint256, Address, Hex, RLP, ABI, Transactions (Legacy, EIP-1559, EIP-2930, EIP-4844, EIP-7702), Event Logs, Access Lists, Bytecode, Opcodes, Hardforks, Merkle Patricia Trie

**crypto:**
- **Production-ready**: Keccak-256, secp256k1 ECDSA (via @noble/curves), EIP-712 (via @noble), BLS12-381 (via BLST), BN254 alt_bn128 (via Arkworks Rust + Pure TS @noble), KZG (via c-kzg-4844), SHA256, RIPEMD160, Blake2
- **⚠️ Unaudited**: Pure Zig implementations of secp256k1, BN254, ModExp (use for testing only)

**precompiles:** All Ethereum precompiles (0x01-0x13)

External C libs: blst, c-kzg-4844, arkworks (Rust)
</modules>

<usage>
**Import modules:**
```zig
const primitives = @import("primitives");
const crypto = @import("crypto");
```

**Add to build.zig.zon:**
```zig
.dependencies = .{
    .primitives = .{
        .url = "https://github.com/evmts/voltaire/archive/<commit>.tar.gz",
        .hash = "<hash>",
    },
},
```

**Add to build.zig:**
```zig
const primitives = b.dependency("primitives", .{
    .target = target,
    .optimize = optimize,
});
exe.root_module.addImport("primitives", primitives.module("primitives"));
exe.root_module.addImport("crypto", primitives.module("crypto"));
```
</usage>

---

## API Quick Reference

### Address

```zig
const addr = try Address.fromHex("0xa0cf798816d4b9b9866b5330eea46a18382f251e");
const addr_u256 = Address.fromU256(some_u256);
const addr_bytes = try Address.fromBytes(bytes_20);
const addr_pubkey = Address.fromPublicKey(public_key_x, public_key_y);

const as_u256 = addr.toU256();
const hex = addr.toHex();  // [42]u8
const checksummed = addr.toChecksumHex();  // EIP-55

const is_valid = Address.isValid(hex_string);
const is_checksum_valid = Address.isValidChecksum(hex_string);
const zero_addr = Address.zero();

// Contract addresses
const create_addr = try Address.calculateCreateAddress(allocator, deployer, nonce);
const create2_addr = try Address.calculateCreate2Address(allocator, deployer, salt, init_code);
```

### Hex

```zig
const valid = Hex.isHex("0x1234abcd");  // Requires 0x prefix

const bytes = try Hex.hexToBytes(allocator, "0x1234");
defer allocator.free(bytes);

const hex = try Hex.bytesToHex(allocator, &bytes);
defer allocator.free(hex);

const value = try Hex.hexToU256("0xdeadbeef");
const hex_str = try Hex.u256ToHex(allocator, value);
defer allocator.free(hex_str);

const padded = try Hex.padLeft(allocator, &bytes, 32);
defer allocator.free(padded);

const trimmed = Hex.trimLeftZeros(&bytes);  // No alloc
```

### RLP

```zig
const encoded = try Rlp.encode(allocator, value);
defer allocator.free(encoded);

const decoded = try Rlp.decode(allocator, encoded, false);
defer decoded.data.deinit(allocator);

switch (decoded.data) {
    .String => |str| { /* bytes */ },
    .List => |items| { /* nested items */ },
}

// Stream mode for multiple items
const item = try Rlp.decode(allocator, data, true);  // Stream=true
remaining = item.remainder;
```

### ABI

**Zig API:**
```zig
const selector = abi.computeSelector("transfer(address,uint256)");

const params = [_]abi.AbiValue{
    abi.addressValue(recipient),
    abi.uint256_value(amount),
};

const calldata = try abi.encodeFunctionData(allocator, selector, &params);
defer allocator.free(calldata);

const types = [_]abi.AbiType{ .address, .uint256 };
const result = try abi.decodeFunctionData(allocator, calldata, &types);
defer {
    for (result.parameters) |param| {
        switch (param) {
            .string, .bytes => |slice| allocator.free(slice),
            else => {},
        }
    }
    allocator.free(result.parameters);
}

const packed = try abi.encodePacked(allocator, &values);  // No padding
defer allocator.free(packed);
```

**TypeScript API (Namespace Pattern):**
```typescript
import { Abi } from '@tevm/voltaire';

// Define ABI items with full type inference
const transferFunction: Abi.Function = {
    type: 'function',
    name: 'transfer',
    stateMutability: 'nonpayable',
    inputs: [
        { type: 'address', name: 'to' },
        { type: 'uint256', name: 'amount' }
    ],
    outputs: [{ type: 'bool' }]
};

// Function operations
const selector = Abi.Function.getSelector.call(transferFunction);  // 4 bytes
const signature = Abi.Function.getSignature.call(transferFunction);  // "transfer(address,uint256)"
const calldata = Abi.Function.encodeParams.call(transferFunction, [address, amount]);
const result = Abi.Function.decodeResult.call(transferFunction, returnData);

// Event operations
const transferEvent: Abi.Event = {
    type: 'event',
    name: 'Transfer',
    inputs: [
        { type: 'address', name: 'from', indexed: true },
        { type: 'address', name: 'to', indexed: true },
        { type: 'uint256', name: 'value' }
    ]
};

const eventSelector = Abi.Event.getSelector.call(transferEvent);  // 32 bytes (topic0)
const topics = Abi.Event.encodeTopics.call(transferEvent, { from, to });
const decoded = Abi.Event.decodeLog.call(transferEvent, logData, logTopics);

// Direct parameter encoding
const encoded = Abi.encodeParameters(
    [{ type: 'address' }, { type: 'uint256' }],
    [address, amount]
);

const decoded = Abi.decodeParameters(
    [{ type: 'address' }, { type: 'uint256' }],
    data
);

// Packed encoding (no padding)
const packed = Abi.encodePacked(['address', 'uint256'], [address, amount]);

// ABI-level operations (work with full ABI arrays)
const abi: Abi = [transferFunction, transferEvent];
const calldata = Abi.encode.call(abi, 'transfer', [address, amount]);
const result = Abi.decode.call(abi, 'transfer', returnData);
const { functionName, args } = Abi.decodeData.call(abi, calldata);  // Infer from selector
const parsedLogs = Abi.parseLogs.call(abi, logs);
```

### Keccak-256

**Zig API:**
```zig
const hash = HashUtils.keccak256("hello");
const hash_hex = try HashUtils.fromHex("0x1234...");

const hex_lower = HashUtils.toHex(hash);  // [66]u8
const message_hash = try HashUtils.eip191HashMessage("Sign this", allocator);

const are_equal = HashUtils.equal(hash1, hash2);  // Constant-time
const selector = HashUtils.selectorFromSignature("transfer(address,uint256)");
```

**TypeScript API:**
```typescript
import { Hash, Keccak256 } from '@tevm/voltaire';

// Compute hash
const hash = Keccak256.hash(new Uint8Array([1, 2, 3]));  // Returns Hash (Uint8Array)
const hashString = Keccak256.hashString('hello');  // Hash UTF-8 encoded string
const hashHex = Keccak256.hashHex('0x1234');  // Hash hex-decoded data

// Hash operations
const hex = Hash.toHex.call(hash);  // "0x..." (66 chars)
const hash2 = Hash.fromHex('0x...');
const hash3 = Hash.fromBytes(bytes);
const isEqual = Hash.equals.call(hash, hash2);  // Constant-time comparison
const isZero = Hash.isZero.call(hash);

// Ethereum-specific
const funcSelector = Hash.keccak256String('transfer(address,uint256)').slice(0, 4);
const eventTopic = Hash.keccak256String('Transfer(address,address,uint256)');
```

### secp256k1

**Zig API (⚠️ UNAUDITED in pure Zig, use Arkworks bindings for production):**
```zig
const private_key = try Crypto.unaudited_randomPrivateKey();
const public_key = try Crypto.unaudited_getPublicKey(private_key);
const address = Crypto.publicKeyToAddress(public_key);

const signature = try Crypto.unaudited_signMessage("Hello", private_key);
const hash_sig = try Crypto.unaudited_signHash(hash, private_key);

const is_valid = try Crypto.unaudited_verifyMessage(message, signature, address);
const recovered = try Crypto.unaudited_recoverAddress(hash, signature);

const sig_valid = signature.isValid();  // Validates r, s, v
const sig_bytes = signature.toBytes();  // [65]u8
```

**TypeScript API (using audited @noble/curves):**
```typescript
import { Secp256k1, Signature } from '@tevm/voltaire';

// Key operations
const privateKey = Secp256k1.generatePrivateKey();  // Random 32 bytes
const publicKey = Secp256k1.derivePublicKey(privateKey);  // 64 bytes (uncompressed)
const address = Secp256k1.publicKeyToAddress(publicKey);

// Signing
const signature = Secp256k1.sign(hash, privateKey);  // Returns Signature (65 bytes: r, s, v)
const msgSignature = Secp256k1.signMessage('Hello', privateKey);

// Verification
const isValid = Secp256k1.verify(hash, signature, publicKey);
const isMsgValid = Secp256k1.verifyMessage('Hello', msgSignature, address);

// Recovery
const recoveredPubkey = Secp256k1.recover(hash, signature);
const recoveredAddr = Secp256k1.recoverAddress(hash, signature);

// Signature operations
const sigBytes = Signature.toBytes.call(signature);  // [65]u8
const sigCompact = Signature.toCompact.call(signature);  // [64]u8 (ERC-2098)
const sig2 = Signature.fromBytes(bytes);
const sig3 = Signature.fromCompact(compactBytes);
const isCanonical = Signature.isCanonical.call(signature);  // Check low-s
const normalized = Signature.normalize.call(signature);  // Force low-s

// Validation
const isValidSig = Secp256k1.isValidSignature(signature);
const isValidKey = Secp256k1.isValidPrivateKey(privateKey);
const isValidPub = Secp256k1.isValidPublicKey(publicKey);
```

### Transactions

```zig
const tx = LegacyTransaction{
    .nonce = 0,
    .gas_price = 20_000_000_000,  // 20 gwei
    .gas_limit = 21000,
    .to = recipient,
    .value = 1_000_000_000_000_000_000,  // 1 ETH
    .data = &[_]u8{},
    .v = 0, .r = [_]u8{0} ** 32, .s = [_]u8{0} ** 32,
};

const encoded = try Transaction.encodeLegacyForSigning(allocator, tx, chain_id);
defer allocator.free(encoded);

const signed = try Transaction.signLegacyTransaction(allocator, tx, private_key, chain_id);
const hash = try Transaction.computeLegacyTransactionHash(allocator, signed);
const tx_type = Transaction.detectTransactionType(raw_data);

// EIP-1559
const eip1559 = Eip1559Transaction{
    .chain_id = 1,
    .nonce = 0,
    .max_priority_fee_per_gas = 2_000_000_000,  // 2 gwei tip
    .max_fee_per_gas = 30_000_000_000,  // 30 gwei max
    .gas_limit = 21000,
    .to = recipient,
    .value = amount,
    .data = &[_]u8{},
    .access_list = &[_]AccessListItem{},
    .v = 0, .r = [_]u8{0} ** 32, .s = [_]u8{0} ** 32,
};
```

### EIP-712 (⚠️ UNAUDITED)

```zig
const domain = try Eip712.create_domain(allocator, "MyDApp", "1.0.0", 1, null);
defer {
    var mut_domain = domain;
    mut_domain.deinit(allocator);
}

var typed_data = try Eip712.create_simple_typed_data(allocator, domain, "Transfer");
defer typed_data.deinit(allocator);

const props = [_]Eip712.TypeProperty{
    .{ .name = "from", .type = "address" },
    .{ .name = "to", .type = "address" },
    .{ .name = "amount", .type = "uint256" },
};
try typed_data.types.put(allocator, "Transfer", &props);

const hash = try Eip712.unaudited_hashTypedData(allocator, &typed_data);
const signature = try Eip712.unaudited_signTypedData(allocator, &typed_data, private_key);
const recovered = try Eip712.unaudited_recoverTypedDataAddress(allocator, &typed_data, signature);
```

---

## TypeScript/JavaScript API

<ts_overview>
The library provides TypeScript bindings in two forms:
1. **Pure TypeScript** (no dependencies) - primitives, ABI, numeric, bytecode, opcodes, gas, logs
2. **Bun FFI wrappers** (requires native lib) - Keccak-256, EIP-191

Install: `npm install @tevm/voltaire` or `bun add @tevm/voltaire`
</ts_overview>

### ABI Encoding/Decoding (Pure TypeScript)

```typescript
import {
  encodeAbiParameters,
  decodeAbiParameters,
  encodeFunctionData,
  decodeFunctionData,
  encodeEventTopics,
  encodePacked,
  computeSelector,
  uint256Value,
  addressValue,
  bytesValue
} from '@tevm/voltaire';

// Basic encoding
const encoded = encodeAbiParameters(
  [{ type: 'address' }, { type: 'uint256' }],
  ['0xa0Ee7A142d267C1f36714E4a8F75612F20a79720', 1000000000000000000n]
);

// Decoding
const [address, amount] = decodeAbiParameters(
  [{ type: 'address' }, { type: 'uint256' }],
  encoded
);

// Function data
const calldata = encodeFunctionData(
  'transfer(address,uint256)',
  [{ type: 'address' }, { type: 'uint256' }],
  ['0x1234...', 1000n]
);

const { selector, parameters } = decodeFunctionData(
  [{ type: 'address' }, { type: 'uint256' }],
  calldata
);

// Event topics
const topics = encodeEventTopics(
  'Transfer(address,address,uint256)',
  [{ type: 'address', indexed: true }, { type: 'address', indexed: true }, { type: 'uint256' }],
  ['0xfrom...', '0xto...', null]  // null = not indexed
);

// Packed encoding (for keccak256)
const packed = encodePacked(
  [{ type: 'address' }, { type: 'uint256' }],
  ['0x1234...', 42n]
);

// Compute function selector
const selector = computeSelector('transfer(address,uint256)');  // 0xa9059cbb

// Type-safe value helpers
const params = [
  addressValue('0x1234...'),
  uint256Value(1000n),
  bytesValue(new Uint8Array([1, 2, 3]))
];
```

### Numeric Conversions (Pure TypeScript)

```typescript
import {
  parseEther,
  formatEther,
  parseGwei,
  formatGwei,
  parseUnits,
  formatUnits,
  gweiToWei,
  weiToGwei,
  etherToWei,
  weiToEther
} from '@tevm/voltaire';

// Parse string to wei
const oneEth = parseEther('1.0');  // 1000000000000000000n
const gasPrice = parseGwei('20');  // 20000000000n
const custom = parseUnits('1.5', 6);  // 1500000n (6 decimals)

// Format wei to string
const ethStr = formatEther(1000000000000000000n);  // "1.0"
const gweiStr = formatGwei(20000000000n);  // "20"
const customStr = formatUnits(1500000n, 6);  // "1.5"

// Direct conversions
const wei1 = gweiToWei(20n);  // 20000000000n
const gwei1 = weiToGwei(20000000000n);  // 20n
const wei2 = etherToWei(1n);  // 1000000000000000000n
const eth1 = weiToEther(1000000000000000000n);  // 1n
```

### Keccak-256 (Bun FFI - Requires Native Lib)

```typescript
import { keccak256, keccak256Empty } from '@tevm/voltaire';

// Hash string or Uint8Array
const hash1 = keccak256('hello world');
const hash2 = keccak256(new Uint8Array([1, 2, 3]));

// Pre-computed empty hash constant
const emptyHash = keccak256Empty;  // Hash of empty input

// Returns Uint8Array (32 bytes)
```

### EIP-191 Personal Message (Bun FFI - Requires Native Lib)

```typescript
import { hashMessage } from '@tevm/voltaire';

// Hash message with EIP-191 prefix
const msgHash = hashMessage('Sign this message');
// Adds prefix: "\x19Ethereum Signed Message:\n{length}{message}"

// Returns Uint8Array (32 bytes)
```

### Bytecode Analysis (Pure TypeScript)

```typescript
import {
  analyzeJumpDestinations,
  validateBytecode,
  isValidJumpDest,
  isBytecodeBoundary
} from '@tevm/voltaire';

const bytecode = new Uint8Array([0x60, 0x80, 0x60, 0x40, 0x5b]); // PUSH1 0x80, PUSH1 0x40, JUMPDEST

// Analyze all valid JUMPDEST positions
const jumpDests = analyzeJumpDestinations(bytecode);  // Set { 4 }

// Validate bytecode structure
const isValid = validateBytecode(bytecode);  // true

// Check specific position
const canJump = isValidJumpDest(bytecode, 4);  // true
const isBoundary = isBytecodeBoundary(bytecode, 2);  // true
```

### Opcode Utilities (Pure TypeScript)

```typescript
import { Opcode, isPush, isDup, isSwap, isStateModifying } from '@tevm/voltaire';

// Check opcode types
isPush(Opcode.PUSH1);  // true
isDup(Opcode.DUP1);  // true
isSwap(Opcode.SWAP1);  // true
isStateModifying(Opcode.SSTORE);  // true

// Gas costs and stack operations available
```

### Gas Calculations (Pure TypeScript)

```typescript
import {
  calculateNextBaseFee,
  calculateIntrinsicGas,
  calculateMemoryGasCost
} from '@tevm/voltaire';

// EIP-1559 base fee calculation
const nextBaseFee = calculateNextBaseFee(
  1000000000n,  // current base fee
  15000000,     // gas used
  15000000      // gas target
);

// Transaction intrinsic gas
const intrinsicGas = calculateIntrinsicGas(
  new Uint8Array([1, 2, 3]),  // calldata
  false,  // not contract creation
  []      // access list
);

// Memory expansion gas
const memoryGas = calculateMemoryGasCost(1024);  // bytes
```

### Hardfork Utilities (Pure TypeScript)

```typescript
import { Hardfork, isAtLeast, isBefore } from '@tevm/voltaire';

// Version comparisons
isAtLeast(Hardfork.LONDON, Hardfork.BERLIN);  // true
isBefore(Hardfork.BERLIN, Hardfork.LONDON);  // true

// Supported: FRONTIER, HOMESTEAD, DAO, TANGERINE, SPURIOUS, BYZANTIUM,
// CONSTANTINOPLE, PETERSBURG, ISTANBUL, MUIR_GLACIER, BERLIN, LONDON,
// ARROW_GLACIER, GRAY_GLACIER, PARIS, SHANGHAI, CANCUN, PRAGUE
```

### SIWE (Sign-In with Ethereum) (Pure TypeScript)

```typescript
import { parseSiweMessage, validateSiweMessage } from '@tevm/voltaire';

const message = `example.com wants you to sign in with your Ethereum account:
0x1234567890123456789012345678901234567890

Sign in to Example

URI: https://example.com
Version: 1
Chain ID: 1
Nonce: 32891757
Issued At: 2023-01-01T00:00:00Z`;

// Parse SIWE message
const parsed = parseSiweMessage(message);

// Validate message structure and expiration
const isValid = validateSiweMessage(parsed);
```

### Event Logs (Pure TypeScript)

```typescript
import { parseEventLog, filterLogsByTopics } from '@tevm/voltaire';

// Parse event log
const log = parseEventLog(
  'Transfer(address,address,uint256)',
  logData  // { topics: [...], data: '0x...' }
);

// Filter logs by topics
const filtered = filterLogsByTopics(logs, [
  '0x...',  // topic0 (event signature)
  '0x...',  // topic1
  null      // any topic2
]);
```

<ts_status>
**Implementation Status:**
- ✅ Fully implemented: All primitives, all crypto modules use audited libraries (@noble, c-kzg-4844)
- ✅ WASM bindings: Available for performance-critical primitives (see WASM section below)

**Requirements:**
- Pure TypeScript modules work in any JS environment (Node.js, Bun, Deno, browsers)
- WASM modules provide optional performance boost, fallback to TypeScript if unavailable
- Build WASM: `zig build` → creates WebAssembly modules
</ts_status>

---

## WASM Bindings

<wasm_overview>
The library provides WebAssembly bindings for performance-critical operations. WASM modules are colocated with TypeScript implementations (e.g., `address.ts` + `address.wasm.ts` in same directory).

**Architecture:**
- TypeScript implementations are primary (always available)
- WASM modules are performance optimization layer
- Automatic fallback if WASM unavailable
- Zero-copy operations where possible

**Available WASM modules** (all in `src/` directories):
</wasm_overview>

<wasm_primitives>
### Primitives WASM

- **`address.wasm.ts`**: Address operations (checksum, CREATE/CREATE2 addresses)
- **`bytecode.wasm.ts`**: Bytecode analysis (JUMPDEST detection, opcode parsing)
- **`hash.wasm.ts`**: SHA256, RIPEMD160, BLAKE2b hash functions
- **`hex.wasm.ts`**: Hex encoding/decoding
- **`rlp.wasm.ts`**: RLP encoding/decoding
- **`transaction.wasm.ts`**: Transaction type detection
- **`uint256.wasm.ts`**: U256 operations
- **`wallet.wasm.ts`**: Key generation, public key compression
- **`abi.wasm.ts`**: ABI encoding/decoding (awaiting C API layer)

**Usage Pattern:**
```typescript
import { isWasmAvailable, addressFromHexWasm } from './address.wasm.js';

// Check availability
if (isWasmAvailable()) {
    const addr = addressFromHexWasm('0x...');  // Fast WASM path
} else {
    const addr = Address.fromHex('0x...');  // TypeScript fallback
}
```
</wasm_primitives>

<wasm_crypto>
### Crypto WASM

- **`blake2.wasm.ts`**: BLAKE2b with variable output lengths
- **`bn254.wasm.ts`**: BN254 curve operations (G1, G2, pairing) - **Pure TS only**
- **`bn254.ark.ts`**: BN254 via Arkworks Rust library (audited, production-ready)
- **`eip712.wasm.ts`**: EIP-712 typed data hashing
- **`keccak256.wasm.ts`**: Keccak-256 with hardware acceleration detection
- **`ripemd160.wasm.ts`**: RIPEMD-160 hash
- **`secp256k1.wasm.ts`**: ECDSA operations (sign, verify, recover)
- **`sha256.wasm.ts`**: SHA-256 with hardware acceleration

**BN254 Implementations:**
1. **Pure TypeScript** (`bn254.ts`): Field arithmetic, curve ops, pairing - complete, audited by @noble
2. **Pure Zig** (`bn254_c.zig`): Native implementation - ⚠️ UNAUDITED, use for testing only
3. **Arkworks** (`bn254.ark.ts` + `bn254_ark_c.zig`): Rust library via FFI - audited, production-ready

**Usage:**
```typescript
import { Bn254 } from '@tevm/voltaire';  // Pure TS (always available)
import { bn254AddWasm } from './bn254.wasm.js';  // WASM (faster, optional)
import { bn254AddArk } from './bn254.ark.js';  // Arkworks (fastest, requires native)

// Automatic selection based on availability
const result = Bn254.G1.add(point1, point2);  // Uses best available
```
</wasm_crypto>

---

## Memory Patterns

```zig
// Same scope: defer allocator.destroy(thing);
// Ownership transfer: errdefer allocator.destroy(thing);
// GPA setup:
var gpa = std.heap.GeneralPurposeAllocator(.{}){};
defer _ = gpa.deinit();
const allocator = gpa.allocator();
```

---

## Security Requirements

<crypto_safety>
**Constant-time ops required. All crypto must:**
- Validate inputs (sig components, curve points)
- Never panic (return errors)
- Clear sensitive memory
- No timing leaks (no early returns in comparisons)

```zig
// ✅ Constant-time compare
var result: u8 = 0;
for (a, b) |byte_a, byte_b| { result |= byte_a ^ byte_b; }
return result == 0;
// ❌ if (byte_a != byte_b) return false;  // Leaks timing
```
</crypto_safety>

<unaudited_functions>
**Unaudited (DO NOT use in prod):** All `unaudited_*` functions, all `Eip712.unaudited_*`, RIPEMD160, Blake2, ModExp, pure Zig BN254
**Audited libs:** BLS12-381 (BLST), KZG (c-kzg-4844), BN254 (Arkworks), SHA256
</unaudited_functions>

---

## Documentation

<docs_base_url>
Base: https://github.com/evmts/voltaire/blob/main/docs
</docs_base_url>

<main_docs>
- [Documentation Overview](https://github.com/evmts/voltaire/blob/main/docs/DOCUMENTATION.md)
- [README](https://github.com/evmts/voltaire/blob/main/docs/README.md)
</main_docs>

<crypto_docs>
**Cryptography:**
- [Crypto Module](https://github.com/evmts/voltaire/blob/main/docs/crypto/crypto.zig.md)
- [Hash Utils](https://github.com/evmts/voltaire/blob/main/docs/crypto/hash.zig.md)
- [Hash Algorithms](https://github.com/evmts/voltaire/blob/main/docs/crypto/hash_algorithms.zig.md)
- [secp256k1](https://github.com/evmts/voltaire/blob/main/docs/crypto/secp256k1.zig.md)
</crypto_docs>

<primitives_docs>
**Primitives:**
- [Event Logs](https://github.com/evmts/voltaire/blob/main/docs/primitives/logs.md)
- [Hardforks](https://github.com/evmts/voltaire/blob/main/docs/primitives/hardfork.md)
- [Sign-In with Ethereum (SIWE)](https://github.com/evmts/voltaire/blob/main/docs/primitives/siwe.md)
</primitives_docs>

<precompiles_docs>
**Precompiles:**
- [Overview](https://github.com/evmts/voltaire/blob/main/docs/precompiles/README.md)
- [Common Types](https://github.com/evmts/voltaire/blob/main/docs/precompiles/common.md)
- [Utils](https://github.com/evmts/voltaire/blob/main/docs/precompiles/utils.md)
- [ECRecover (0x01)](https://github.com/evmts/voltaire/blob/main/docs/precompiles/ecrecover.md)
- [SHA256 (0x02)](https://github.com/evmts/voltaire/blob/main/docs/precompiles/sha256.md)
- [RIPEMD160 (0x03)](https://github.com/evmts/voltaire/blob/main/docs/precompiles/ripemd160.md)
- [Identity (0x04)](https://github.com/evmts/voltaire/blob/main/docs/precompiles/identity.md)
- [ModExp (0x05)](https://github.com/evmts/voltaire/blob/main/docs/precompiles/modexp.md)
- [BN254 Add (0x06)](https://github.com/evmts/voltaire/blob/main/docs/precompiles/bn254_add.md)
- [BN254 Mul (0x07)](https://github.com/evmts/voltaire/blob/main/docs/precompiles/bn254_mul.md)
- [BN254 Pairing (0x08)](https://github.com/evmts/voltaire/blob/main/docs/precompiles/bn254_pairing.md)
- [Blake2F (0x09)](https://github.com/evmts/voltaire/blob/main/docs/precompiles/blake2f.md)
- [Point Evaluation (0x0a)](https://github.com/evmts/voltaire/blob/main/docs/precompiles/point_evaluation.md)
- [BLS12-381 G1 Add (0x0b)](https://github.com/evmts/voltaire/blob/main/docs/precompiles/bls12_g1_add.md)
- [BLS12-381 G1 Mul (0x0c)](https://github.com/evmts/voltaire/blob/main/docs/precompiles/bls12_g1_mul.md)
- [BLS12-381 G1 MSM (0x0d)](https://github.com/evmts/voltaire/blob/main/docs/precompiles/bls12_g1_msm.md)
- [BLS12-381 G2 Add (0x0e)](https://github.com/evmts/voltaire/blob/main/docs/precompiles/bls12_g2_add.md)
- [BLS12-381 G2 Mul (0x0f)](https://github.com/evmts/voltaire/blob/main/docs/precompiles/bls12_g2_mul.md)
- [BLS12-381 G2 MSM (0x10)](https://github.com/evmts/voltaire/blob/main/docs/precompiles/bls12_g2_msm.md)
- [BLS12-381 Pairing (0x11)](https://github.com/evmts/voltaire/blob/main/docs/precompiles/bls12_pairing.md)
- [BLS12-381 Map Fp to G1 (0x12)](https://github.com/evmts/voltaire/blob/main/docs/precompiles/bls12_map_fp_to_g1.md)
- [BLS12-381 Map Fp2 to G2 (0x13)](https://github.com/evmts/voltaire/blob/main/docs/precompiles/bls12_map_fp2_to_g2.md)
</precompiles_docs>

<benchmarking_docs>
**Benchmarking & Performance:**
- [BENCHMARKING.md](https://github.com/evmts/voltaire/blob/main/BENCHMARKING.md) — How to run benchmarks
- [BENCHMARK_RESULTS.md](https://github.com/evmts/voltaire/blob/main/BENCHMARK_RESULTS.md) — TypeScript/FFI performance comparisons
- [ZIG_BENCHMARK_RESULTS.md](https://github.com/evmts/voltaire/blob/main/ZIG_BENCHMARK_RESULTS.md) — Native Zig performance data
</benchmarking_docs>

<examples_docs>
**Examples:**
- [Examples Overview](https://github.com/evmts/voltaire/blob/main/examples/README.md) — Zig and TypeScript examples
- [TypeScript Examples](https://github.com/evmts/voltaire/blob/main/examples/typescript/) — Organized TypeScript examples
</examples_docs>

<external_resources>
**External Resources:**
- [Zig 0.15.1 Docs](https://ziglang.org/documentation/0.15.1/)
- [Ethereum EIPs](https://eips.ethereum.org/)
- [Repository](https://github.com/evmts/voltaire)
</external_resources>
