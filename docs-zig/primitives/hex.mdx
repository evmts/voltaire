---
title: Hex (Deprecated)
description: The Hex primitive has been replaced by typed hex variants
---

<Warning>
**Deprecated** - The `Hex` primitive has been replaced by typed variants for better type safety and clarity.
</Warning>

## Migration Guide

The legacy `Hex` type provided a generic hex string representation. It has been replaced with **typed hex variants** that provide compile-time size checking and clearer semantics.

### Old API (Deprecated)

```zig
const Hex = @import("primitives").Hex;

// Generic untyped hex
const bytes = try Hex.fromHex(allocator, "0x1234");
defer allocator.free(bytes);
```

### New API (Recommended)

Use typed variants based on your data's semantic meaning:

<Tabs>
<Tab title="Fixed-Size Bytes">

For fixed-size hex values, use `Bytes<N>` variants:

```zig
const primitives = @import("primitives");

// 32-byte values (hashes, storage slots)
var hash: [32]u8 = try primitives.Hex.hexToBytesFixed(32, "0x0000000000000000000000000000000000000000000000000000000000000000");
const hex_hash = primitives.Hex.bytesToHexFixed(32, hash);

// 16-byte values
var uuid: [16]u8 = try primitives.Hex.hexToBytesFixed(16, "0x00000000000000000000000000000000");
```

Available sizes: `Bytes1`, `Bytes2`, `Bytes3`, `Bytes4`, `Bytes5`, `Bytes6`, `Bytes7`, `Bytes8`, `Bytes16`, `Bytes32`, `Bytes64`

</Tab>
<Tab title="Addresses">

For Ethereum addresses (20 bytes), use the `Address` type:

```zig
const primitives = @import("primitives");

// 20-byte address with EIP-55 checksumming
const addr = try primitives.Address.fromHex("0x742d35Cc6634C0532925a3b844Bc9e7595f51e3e");
const checksummed = addr.toChecksummed();
```

</Tab>
<Tab title="Hashes">

For cryptographic hashes (32 bytes), use the `Keccak256` module:

```zig
const crypto = @import("crypto");

// Keccak256 hash (32 bytes)
const hash = crypto.keccak256.hash("hello");
const hex = @import("primitives").Hex.bytesToHexFixed(32, hash);
```

</Tab>
</Tabs>

## Why Typed Variants?

The typed variants provide several advantages over the generic `Hex` type:

1. **Compile-time size checking** - Catch size mismatches during development
2. **Semantic clarity** - Type names reflect data meaning (Address vs Hash vs Bytes32)
3. **Better IDE support** - Type-specific methods and documentation
4. **Prevents mixing types** - Can't accidentally use an Address where a Hash is expected

## Migration Examples

### Generic Hex → Bytes32

```zig
// Before (deprecated)
const Hex = @import("primitives").Hex;
const value_bytes = try Hex.fromHex(allocator, "0x0000000000000000000000000000000000000000000000000000000000000000");
defer allocator.free(value_bytes);

// After: prefer fixed-size types where applicable
var value: [32]u8 = try Hex.hexToBytesFixed(32, "0x0000000000000000000000000000000000000000000000000000000000000000");
```

### Hex with Size → Fixed Bytes

```zig
// Before (deprecated)
const Hex = @import("primitives").Hex;
var selector4 = try Hex.hexToBytesFixed(4, "0x12345678");

// After: use typed encoding helpers for selectors
const Abi = @import("primitives").AbiEncoding;
const sel = Abi.computeSelector("transfer(address,uint256)"); // [4]u8
```

### Hex Address → Address

```zig
// Before (deprecated): raw hex
const Hex = @import("primitives").Hex;
var addr_bytes = try Hex.hexToBytesFixed(20, "0x742d35Cc6634C0532925a3b844Bc9e7595f51e3e");

// After: semantic Address type
const primitives = @import("primitives");
const addr = try primitives.Address.fromHex("0x742d35Cc6634C0532925a3b844Bc9e7595f51e3e");
const checksummed = addr.toChecksummed();
```

## Where to Find Replacements

### Fixed-Size Types

All fixed-size hex types are now under bytes:

- [Bytes1 - Bytes8](/primitives/bytes/bytes1) - Small fixed sizes (selectors, flags)
- [Bytes16](/primitives/bytes/bytes16) - 128-bit values (UUIDs)
- [Bytes32](/primitives/bytes/bytes32) - 256-bit values (hashes, storage slots, merkle nodes)
- [Bytes64](/primitives/bytes/bytes64) - 512-bit values (public keys, signatures)

### Semantic Types

Domain-specific types with specialized methods:

- [Address](/primitives/address/index) - 20-byte Ethereum addresses with EIP-55 checksumming
- [Keccak256](/crypto/keccak256) - 32-byte cryptographic hash values
- [Signature](/crypto/secp256k1) - ECDSA signatures (r, s, v)

## Related

- [Bytes Types](/primitives/bytes/index) - All fixed-size byte variants
- [Address](/primitives/address/index) - Ethereum addresses
- [Keccak256](/crypto/keccak256) - Cryptographic hashes
