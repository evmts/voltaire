---
title: TraceResult
description: Complete execution trace result from debug_trace* methods
---

# TraceResult

Complete execution trace result returned by `debug_traceTransaction` and `debug_traceCall`. Contains either opcode-level logs or call tree depending on tracer configuration.

## Overview

TraceResult is the top-level response from Geth's debug tracing methods. It provides execution outcome (gas used, success/failure, return data) plus optional detailed trace data.

## JSON Shape (from RPC)

```zig
// debug_traceTransaction returns fields like: gas, failed, returnValue, structLogs
// debug_traceCall (with callTracer) returns callTrace
```

## Usage

### Creating TraceResults

```zig
// See RPC examples for fields; convert hex strings to bytes/ints as needed.
```

### Accessing Trace Data

```zig
// Access structLogs or callTrace depending on tracer config.
```

## RPC Usage

### debug_traceTransaction

```zig
// Default tracer (opcode logs)
// {"method":"debug_traceTransaction","params":["0xTX_HASH",{"disableStorage":true,"disableMemory":true}]}
```

### debug_traceCall

```zig
// Trace a call without mining (callTracer)
// {"method":"debug_traceCall","params":[{"from":"0x...","to":"0x...","data":"0x..."},"latest",{"tracer":"callTracer"}]}
```

## Common Patterns

### Analyzing Failed Transactions

```zig
// Analyze failures: scan structLogs for REVERT, or callTrace for error/revertReason.
```

### Gas Profiling

```zig
// Gas profiling ideas: sum gasCost across structLogs, or gasUsed per call in callTrace.
```

### Finding Expensive Operations

```zig
function findExpensiveOps(result: TraceResultType, threshold: bigint): StructLogType[] {
  const logs = TraceResult.getStructLogs(result);
  return logs.filter(log => log.gasCost >= threshold);
}
```

### Extracting Storage Changes

```zig
function extractStorageChanges(result: TraceResultType): Record<string, string> {
  const logs = TraceResult.getStructLogs(result);
  const changes: Record<string, string> = {};

  for (const log of logs) {
    if (log.storage) {
      Object.assign(changes, log.storage);
    }
  }

  return changes;
}
```

### Call Flow Visualization

```zig
function visualizeCallFlow(result: TraceResultType): string {
  const trace = TraceResult.getCallTrace(result);
  if (!trace) return "No call trace available";

  function formatCall(call: CallTraceType, depth: number): string[] {
    const indent = "  ".repeat(depth);
    const status = CallTrace.hasError(call) ? "❌" : "✅";
    const to = call.to ? Address.toHex(call.to).slice(0, 10) : "CREATE";

    const lines = [
      `${indent}${status} ${call.type} ${to} (${call.gasUsed} gas)`
    ];

    if (call.error) {
      lines.push(`${indent}   Error: ${call.error}`);
    }

    for (const subcall of CallTrace.getCalls(call)) {
      lines.push(...formatCall(subcall, depth + 1));
    }

    return lines;
  }

  return formatCall(trace, 0).join("\n");
}
```

## Tracer-Specific Results

### Default Tracer (structLogs)

```zig
const config = TraceConfig.from({});
const result = await rpc.debug_traceTransaction(txHash, config);

// Result contains structLogs
const logs = TraceResult.getStructLogs(result);
for (const log of logs) {
  console.log(`${log.pc}: ${log.op} (${log.gasCost} gas)`);
}
```

### callTracer

```zig
const config = TraceConfig.withTracer({}, "callTracer");
const result = await rpc.debug_traceTransaction(txHash, config);

// Result contains callTrace
const trace = TraceResult.getCallTrace(result);
if (trace) {
  console.log(`${trace.type} from ${Address.toHex(trace.from)}`);
}
```

### prestateTracer

```zig
const config = TraceConfig.withTracer({}, "prestateTracer");
const result = await rpc.debug_traceTransaction(txHash, config);

// Result is account state map (not in TraceResult schema)
// Custom parsing needed for prestateTracer
```

## Performance Considerations

### Memory Usage

- `structLogs` can be very large (10k+ entries for complex transactions)
- Each log contains stack/memory/storage snapshots
- Use `TraceConfig.disableAll()` for minimal memory

### Processing Time

- Opcode-level tracing is slow (10-100x slower than normal execution)
- callTracer is faster (only tracks calls, not every opcode)
- Use timeouts in TraceConfig for long-running traces

### Best Practices

```zig
// Fast: Just need to know if it failed
const minimalConfig = TraceConfig.disableAll();

// Medium: Need call tree
const callConfig = TraceConfig.withTracer(
  TraceConfig.disableAll(),
  "callTracer"
);

// Slow: Need every opcode
const fullConfig = TraceConfig.from({
  enableMemory: true,
  enableReturnData: true,
});
```

## Security Analysis

### Reentrancy Detection

```zig
function detectReentrancy(result: TraceResultType): boolean {
  const trace = TraceResult.getCallTrace(result);
  if (!trace) return false;

  const visited = new Set<string>();

  function check(call: CallTraceType): boolean {
    if (!call.to) return false;

    const addr = Address.toHex(call.to);
    if (visited.has(addr)) return true;

    visited.add(addr);
    for (const subcall of CallTrace.getCalls(call)) {
      if (check(subcall)) return true;
    }
    visited.delete(addr);

    return false;
  }

  return check(trace);
}
```

### SELFDESTRUCT Detection

```zig
function findSelfDestructs(result: TraceResultType): AddressType[] {
  const trace = TraceResult.getCallTrace(result);
  if (!trace) return [];

  return CallTrace.flatten(trace)
    .filter(call => call.type === "SELFDESTRUCT")
    .map(call => call.from);
}
```

## See Also

- [TraceConfig](/primitives/trace-config) - Trace configuration options
- [StructLog](/primitives/struct-log) - Opcode-level trace entry
- [CallTrace](/primitives/call-trace) - Call tree structure
- [OpStep](/primitives/op-step) - Typed opcode step
