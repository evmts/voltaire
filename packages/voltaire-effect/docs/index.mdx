---
title: voltaire-effect
description: Effect.ts integration for Voltaire Ethereum primitives
---

The production grade robust abstraction layer for blockchain application development for the institutional era of ethereum

[Effect.ts](https://effect.website) integration for [Voltaire](https://voltaire.tevm.sh) Ethereum primitives. Type-safe contract interactions with composable, error-handled operations.

<Tabs>
  <Tab title="voltaire-effect">
```typescript
import { Effect, Layer } from 'effect'
import { ContractRegistryService, makeContractRegistry, HttpProvider } from 'voltaire-effect'

const Contracts = makeContractRegistry({
USDC: { abi: erc20Abi, address: '0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48' },
WETH: { abi: erc20Abi, address: '0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2' },
})

// Compose layers first
const AppLayer = Contracts.pipe(
Layer.provide(HttpProvider('https://eth.llamarpc.com'))
)

const program = Effect.gen(function* () {
const { USDC, WETH } = yield* ContractRegistryService
const usdcBalance = yield* USDC.read.balanceOf(userAddress)
const wethBalance = yield* WETH.read.balanceOf(userAddress)
return { usdcBalance, wethBalance }
}).pipe(
Effect.retry({ times: 3 }), // explicit retry policy
Effect.timeout('10 seconds'), // explicit timeout
Effect.provide(AppLayer) // single provide
)

const { usdcBalance, wethBalance } = await Effect.runPromise(program)

````
  </Tab>
  <Tab title="viem">
```typescript
import { createPublicClient, http } from 'viem'

const client = createPublicClient({
  transport: http('https://eth.llamarpc.com', { retryCount: 3 }) // hidden default
})

const balance = await client.readContract({
  address: '0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48',
  abi: erc20Abi,
  functionName: 'balanceOf',
  args: [userAddress]
})
````

viem implicitly retries 3 times via transport config. voltaire-effect makes retry, timeout, and error handling explicit and composable.

  </Tab>
</Tabs>

### Type Safety: Branded Primitives

<Tabs>
  <Tab title="voltaire">
```typescript
import * as Address from '@tevm/voltaire/Address'
import * as Bytecode from '@tevm/voltaire/Bytecode'

const address = Address.from('0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48')
const bytecode = Bytecode.from('0x608060405234801561001057600080fd5b50')

await client.readContract({
address: bytecode, // Type error: Bytecode is not assignable to Address
...
})

````
  </Tab>
  <Tab title="viem">
```typescript
import { type Address, type Hex } from 'viem'

const address: Address = '0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48'
const bytecode: Hex = '0x608060405234801561001057600080fd5b50'

// Compiles fine - runtime bug waiting to happen
await client.readContract({
  address: bytecode,  // oops, passed bytecode as address!
  abi: erc20Abi,
  functionName: 'balanceOf',
  args: [address]
})
````

viem's `Address` and `Hex` are both `0x${string}` - TypeScript can't catch when you mix them up.

  </Tab>
</Tabs>

### Performance: encodeFunctionData

Both encode the same calldata, but Voltaire's WASM-optimized keccak256 (used for function selectors) is ~9x faster:

<Tabs>
  <Tab title="voltaire-effect">
```typescript
import { Effect } from 'effect'
import { encodeFunctionData } from 'voltaire-effect/primitives/Abi'

const calldata = await Effect.runPromise(
encodeFunctionData(erc20Abi, 'transfer', [recipient, amount])
)
// Effect<Hex, AbiItemNotFoundError | AbiEncodingError>
// Errors in type signature, not hidden exceptions

````
  </Tab>
  <Tab title="voltaire">
```typescript
import * as Abi from '@tevm/voltaire/Abi'

const calldata = Abi.encodeFunction(erc20Abi, 'transfer', [recipient, amount])
````

  </Tab>
  <Tab title="viem">
```typescript
import { encodeFunctionData } from 'viem'

const calldata = encodeFunctionData({
abi: erc20Abi,
functionName: 'transfer',
args: [recipient, amount]
})
// Throws on error - must wrap in try/catch

````
  </Tab>
</Tabs>

| Operation | viem | voltaire | Speedup |
|-----------|------|----------|---------|
| keccak256 (32B) | 3.22 µs | 349 ns | **9.2x** |
| keccak256 (256B) | 6.23 µs | 571 ns | **10.9x** |
| keccak256 (1KB) | 24.4 µs | 1.87 µs | **13x** |

<Note>
Benchmarks on Apple M3 Max, bun 1.3.4. Voltaire uses WASM-compiled Zig keccak256 vs viem's pure JavaScript @noble/hashes.
</Note>

<CardGroup cols={2}>
  <Card title="Getting Started" icon="rocket" href="/getting-started">
    Install and run your first program in 2 minutes
  </Card>
  <Card title="Effect Primer" icon="graduation-cap" href="/concepts/effect-primer">
    5-minute Effect.ts crash course for Ethereum devs
  </Card>
  <Card title="Examples" icon="code" href="/examples/index">
    Copy-paste patterns for common tasks
  </Card>
  <Card title="Cheatsheet" icon="bolt" href="/cheatsheet">
    Quick reference for schemas, services, and layers
  </Card>
</CardGroup>

## Install

<CodeGroup>
```bash pnpm
pnpm add voltaire-effect @tevm/voltaire effect
````

```bash npm
npm install voltaire-effect @tevm/voltaire effect
```

```bash bun
bun add voltaire-effect @tevm/voltaire effect
```

</CodeGroup>

<Info>Requires **Effect 3.x**, **Voltaire 0.x**, and **TypeScript 5.4+**.</Info>

## Key Features

<Accordion title="Typed Errors" icon="shield-check">
Errors appear in the type signature, not as invisible exceptions. Use `catchTag` for type-safe handling:

```typescript
S.decode(Address.Hex)(input).pipe(
  Effect.catchTag("ParseError", (e) => Effect.succeed(fallback)),
);
// Effect<AddressType, ParseError, never>
```

</Accordion>

<Accordion title="Testable Services" icon="flask">
Swap production layers for test layers without changing business logic:

```typescript
// Production
await Effect.runPromise(program.pipe(Effect.provide(MainLayer)));

// Test - same code, different wiring
await Effect.runPromise(program.pipe(Effect.provide(TestLayer)));
```

</Accordion>

<Accordion title="Composable Operations" icon="puzzle-piece">
Built-in retry, timeout, and fallback. No external libraries needed:

```typescript
getBlockNumber().pipe(
  Effect.retry(Schedule.exponential("100 millis").pipe(Schedule.recurs(5))),
  Effect.timeout(Duration.seconds(10)),
  Effect.orElse(() => getBlockNumber()), // with different provider layer
);
```

</Accordion>

## Ecosystem

<CardGroup cols={3}>
  <Card
    title="Voltaire"
    icon="arrow-up-right-from-square"
    href="https://voltaire.tevm.sh"
  >
    Core Ethereum primitives and crypto
  </Card>
  <Card
    title="Effect"
    icon="arrow-up-right-from-square"
    href="https://effect.website/docs/getting-started/introduction/"
  >
    Typed errors, services, and composition
  </Card>
  <Card title="GitHub" icon="github" href="https://github.com/evmts/voltaire">
    Source code and issues
  </Card>
</CardGroup>

## Next Steps

<Steps>
  <Step title="Install">
    Add `voltaire-effect`, `@tevm/voltaire`, and `effect` to your project.
  </Step>
  <Step title="Learn Effect">
    Read the [Effect Primer](/concepts/effect-primer) for a 5-minute intro.
  </Step>
  <Step title="Build">
    Follow [Getting Started](/getting-started) to fetch your first block.
  </Step>
</Steps>
