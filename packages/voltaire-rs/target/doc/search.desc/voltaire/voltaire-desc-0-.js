searchState.loadedDescShard("voltaire", 0, "Voltaire\nCryptographic operations.\nError types for Voltaire operations.\nPrelude for common imports\nEthereum primitive types.\nStreaming BLAKE2b hasher.\nStreaming BLAKE2s hasher.\n64-byte compact signature format (r || s).\nIncremental HMAC-SHA256.\nIncremental HMAC-SHA512.\nStreaming Keccak-256 hasher.\nRecovery ID for ECDSA signatures.\n65-byte Ethereum signature format (r || s || v).\nsecp256k1 operations.\nECDSA signature (r, s components).\nDerive Ethereum address from private key.\nConvert to bytes.\nCompute BLAKE2b hash with specified output length.\nCompute BLAKE2s hash with specified output length.\nEIP-712 Typed Structured Data Hashing and Signing.\nFinalize and return hash.\nFinalize and return hash.\nFinalize and return hash.\nFinalize and return MAC.\nFinalize and return MAC.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nParse from 64-byte compact format.\nCreate from raw 65 bytes (r || s || v).\nParse from 65-byte format (r || s || v).\nCreate from r and s components.\nCreate signature from r, s, v components.\nCreate from r, s, v components.\nCreate from Ethereum v value (27 or 28).\nHash a message using EIP-191 personal message format.\nCompute HMAC-SHA256.\nCompute HMAC-SHA512.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCheck if signature components are within valid curve range.\nCheck if signature is canonical (valid range + normalized).\nCheck if signature is already normalized (low-s).\nCheck if signature is normalized (low-s).\nCheck if signature is valid (basic check without FFI).\nPure Rust keccak256 implementation.\nCreate new hasher.\nCreate new BLAKE2b hasher with specified output length.\nCreate new BLAKE2s hasher with specified output length.\nCreate new HMAC-SHA256 instance.\nCreate new HMAC-SHA512 instance.\nCreate recovery ID (0 or 1).\nCreate signature from r and s components.\nCreate from raw bytes.\nCreate from signature and recovery ID.\nNormalize signature to low-s form (EIP-2).\nNormalize signature to low-s form.\nDerive public key from private key (requires native …\nGet r component.\nGet r component.\nR component (32 bytes).\nRecover address (requires native feature for key recovery).\nRecover public key (requires native feature).\nThe recovery ID.\nPure Rust RIPEMD-160 implementation.\nGet s component.\nGet s component.\nS component (32 bytes).\nPure Rust SHA-256 implementation.\nThe signature (r, s components).\nConvert to 64-byte compact format.\nConvert to 65 bytes (r || s || v).\nConvert to 65-byte format with recovery ID.\nExtract r, s, v components from signature.\nConvert to Signature.\nConvert to Ethereum v value (27 or 28).\nUpdate with more data.\nUpdate hasher with more data.\nUpdate hasher with more data.\nUpdate with more data.\nUpdate with more data.\nGet v value (27 or 28).\nValidate signature components (basic check without FFI).\nAddress value.\nArray of values.\nBoolean value.\nDynamic bytes.\nEIP-712 Domain separator.\nFixed bytes (bytes1 to bytes32).\nHash/bytes32.\nSigned integer.\nMessage value that can be encoded according to EIP-712.\nString value.\nNested struct.\nType definitions map.\nType property definition.\nComplete EIP-712 typed data structure.\nUnsigned integer (any size up to 256 bits).\nLarge unsigned integer (up to 256 bits) as bytes.\nSet the chain ID.\nEIP-155 chain ID.\nDomain separator parameters.\nEncode type string for EIP-712 hashing.\nEncode a single value according to EIP-712.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCompute the domain separator hash.\nCompute the EIP-712 hash for signing.\nHash domain separator.\nHash a struct according to EIP-712.\nHash a type string.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nMessage data to sign.\nSet the domain name.\nHuman-readable name of the signing domain.\nField name.\nCreate a new empty domain.\nCreate a new type property.\nCreate new typed data.\nName of the primary type being signed.\nSet the salt.\nDisambiguating salt for the protocol.\nHash typed data for signing.\nField type (e.g., “string”, “uint256”, “address…\nType definitions mapping type names to their properties.\nValidate the typed data structure.\nSet the verifying contract address.\nAddress of the contract that will verify the signature.\nSet the domain version.\nVersion of the signing domain.\nAdd an address field to the message.\nAdd an array field to the message.\nAdd a bool field to the message.\nAdd a dynamic bytes field to the message.\nAdd a bytes32/hash field to the message.\nAdd a string field to the message.\nAdd a nested struct field to the message.\nAdd a uint256 field to the message.\nAdd a uint256 field from 32 bytes.\nAdd any MessageValue field to the message.\nBlock not found.\nContains the error value\nErrors that can occur during Voltaire operations.\nFFI error from native library.\nInvalid access list.\nInvalid authorization (EIP-7702).\nInvalid checksum (EIP-55).\nInvalid hexadecimal string.\nInvalid input data.\nInvalid length for the operation.\nInvalid parent block.\nInvalid function selector.\nInvalid cryptographic signature.\nInvalid snapshot ID.\nMaximum length exceeded.\nNo pending RPC request.\nContains the success value\nOut of memory during operation.\nOutput buffer too small.\nResult type alias using Voltaire’s Error type.\nRPC request failed.\nRPC request is pending (async pattern).\nUnsupported type in ABI encoding.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCreate an InvalidHex error.\nCreate an InvalidInput error.\nCreate an InvalidLength error.\nCreate an InvalidSignature error.\nCreate an OutputTooSmall error.\nActual length provided.\nBytes available.\nExpected length in bytes.\nMaximum allowed length.\nBytes needed.\nAn EIP-2930 access list specifying addresses and storage …\nA single access list entry containing an address and its …\n20-byte Ethereum address.\nAn EIP-7702 authorization tuple.\nA list of signed authorizations for an EIP-7702 …\nEIP-1559: Dynamic fee transaction.\nEIP-1559 dynamic fee transaction (type 2).\nEIP-1559 dynamic fee transaction (type 2).\nEIP-2930: Access list transaction.\nEIP-2930 access list transaction (type 1).\nEIP-2930 access list transaction (type 1).\nEIP-4844: Blob transaction.\nEIP-4844 blob transaction (type 3).\nEIP-4844 blob transaction (type 3).\nEIP-7702: EOA code delegation.\nEIP-7702 authorization transaction (type 4).\nEIP-7702 authorization transaction (type 4).\n32-byte hash value.\nHex encoding/decoding utilities.\nAddress byte length.\nHash byte length.\nByte length.\nLegacy transaction (pre-EIP-2718).\nLegacy transaction (type 0).\nLegacy transaction (type 0).\nMaximum value (2^256 - 1).\nMaximum entries in an access list (DoS protection).\nMaximum authorizations per transaction (DoS protection).\nMaximum storage keys per entry (DoS protection).\nOne constant.\nA signed EIP-7702 authorization.\nUnified transaction enum.\nTransaction envelope type.\n256-bit unsigned integer.\nZero address constant.\nZero hash constant.\nZero constant.\nZero address constant (0x0000…0000).\nZero hash constant (0x0000…0000).\nABI encoding and decoding for Ethereum.\nGet the access list.\nAccess list.\nAccess list.\nAccess list.\nAccess list.\nGet the delegate contract address.\nContract address to delegate execution to.\nThe contract address being accessed.\nCreate an entry with just an address (no storage keys).\nGet the raw bytes.\nGet the raw bytes.\nGet the raw bytes (big-endian).\nGet mutable reference to raw bytes.\nGet mutable reference to raw bytes.\nThe authorization tuple.\nGet number of authorizations.\nAuthorization list.\nGet underlying authorizations.\nGet number of blobs.\nBlob versioned hashes.\nGet the chain ID.\nGet chain ID from EIP-155 v value.\nGet the chain ID.\nChain ID this authorization is valid for (0 = any chain).\nChain ID.\nChain ID.\nChain ID.\nChain ID.\nChecked addition.\nChecked subtraction.\nCheck if the list contains a specific address.\nCheck if a specific storage key is in this entry.\nCheck if a specific storage key is present for an address.\nCompute CREATE2 address from sender, salt, and init code …\nConstant-time equality comparison.\nConstant-time equality comparison.\nGet the input data.\nInput data.\nInput data.\nInput data.\nInput data.\nInput data.\nDecode hex string to bytes.\nDecode hex string to fixed-size array.\nGet the byte length that a hex string would decode to.\nDeduplicate storage keys within each entry.\nDetect transaction type from raw RLP-encoded bytes.\nCalculate effective gas price given a base fee.\nCalculate effective gas price given a base fee.\nCalculate effective gas price given a base fee.\nCreate an empty list.\nCreate an empty access list.\nEncode bytes to hex string with 0x prefix.\nEncode bytes to hex string without prefix.\nGet the underlying entries.\nFilter authorizations valid for a specific chain.\nFind entry for a specific address.\nCreate an authorization valid on any chain.\nCreate an authorization for a specific chain.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nParse address from hex string.\nParse hash from hex string.\nParse from hex string.\nCreate from little-endian bytes.\nCreate from authorization and signature bytes.\nDerive address from uncompressed public key (64 bytes).\nCreate address from byte slice.\nCreate hash from byte slice.\nCreate from byte slice.\nCalculate gas cost for authorization list.\nCalculate gas cost for this access list.\nGet the gas limit.\nGas limit.\nGas limit.\nGas limit.\nGas limit.\nGas limit.\nGas price in wei.\nGas price in wei.\nGet authorization by index.\nGet entry by index.\nCheck if access list is non-empty.\nCheck if access list is non-empty.\nCheck if access list is non-empty.\nCheck if access list is non-empty.\nCheck if the transaction has a non-empty access list.\nCheck if entry has any storage keys.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConsume and return authorizations.\nConsume and return the underlying entries.\nCheck if this authorization is chain-specific.\nCheck if this authorization is chain-specific.\nCheck if this is a contract creation transaction.\nCheck if this is a contract creation transaction.\nCheck if this is a contract creation transaction.\nBlob transactions cannot be contract creation.\nCheck if this is a contract creation transaction.\nCheck if this is a contract creation transaction.\nCheck if this transaction type uses EIP-1559 fee market.\nCheck if empty.\nCheck if the access list is empty.\nCheck if this transaction is signed.\nCheck if this transaction is signed.\nCheck if this transaction is signed.\nCheck if this transaction is signed.\nCheck if this transaction is signed.\nCheck if this transaction is signed.\nCheck if this is a typed transaction (EIP-2718).\nCheck if string is valid hex.\nValidate EIP-55 checksum.\nCheck if authorization is valid for a given chain.\nCheck if authorization is valid for a given chain.\nCheck if this is the zero address.\nCheck if this is the zero hash.\nCheck if value is zero.\nIterate over authorizations.\nIterate over entries.\nNumber of authorizations.\nNumber of entries in the access list.\nMaximum fee per blob gas.\nMaximum total fee per gas.\nMaximum total fee per gas.\nMaximum total fee per gas.\nMaximum priority fee per gas (tip).\nMaximum priority fee per gas (tip).\nMaximum priority fee per gas (tip).\nMerge another access list into this one.\nCreate address from raw bytes.\nCreate a new authorization.\nCreate a new signed authorization.\nCreate a new authorization list.\nCreate hash from raw bytes.\nCreate from raw bytes (big-endian).\nCreate a new access list from entries.\nCreate a new access list entry.\nGet the nonce.\nGet the nonce.\nNonce to prevent replay attacks.\nTransaction nonce.\nTransaction nonce.\nTransaction nonce.\nTransaction nonce.\nTransaction nonce.\nAdd an authorization.\nAdd an entry to the access list.\nAdd an address with no storage keys.\nAdd an address with storage keys.\nSignature r value.\nSignature r value.\nSignature r value.\nSignature r value.\nSignature r value.\nSignature r value.\nGet the recovery ID (0 or 1).\nRLP (Recursive Length Prefix) encoding and decoding.\nSignature s value.\nSignature s value.\nSignature s value.\nSignature s value.\nSignature s value.\nSignature s value.\nGet the 65-byte signature (r || s || y_parity).\nNumber of storage keys in this entry.\nStorage keys accessed within this contract.\nCheck if this transaction type supports access lists.\nCheck if any authorization targets a specific address.\nGet the recipient address.\nRecipient address (None for contract creation).\nRecipient address (None for contract creation).\nRecipient address (None for contract creation).\nRecipient address (must be non-null for blob transactions).\nRecipient address (None for contract creation).\nConvert to fixed-size byte array.\nConvert to fixed-size byte array.\nConvert to bytes (big-endian).\nConvert to EIP-55 checksummed hex string (pure Rust).\nConvert to lowercase hex string with 0x prefix.\nConvert to hex string with 0x prefix.\nConvert to hex string with 0x prefix.\nConvert to minimal hex string (no leading zeros).\nConvert to little-endian bytes.\nConvert to u128 if value fits.\nConvert to u64 if value fits.\nTotal number of storage keys across all entries.\nGet the transaction type.\nGet the type byte for typed transactions.\nGet the v value (27 or 28 for legacy compatibility).\nSignature v value (includes chain ID for EIP-155).\nValidate the authorization.\nValidate the signed authorization.\nValidate all authorizations.\nValidate the access list against size limits.\nValidate the entry against size limits.\nGet the value in wei.\nValue to transfer in wei.\nValue to transfer in wei.\nValue to transfer in wei.\nValue to transfer in wei.\nValue to transfer in wei.\nCreate access list with pre-allocated capacity.\nGet y-parity from v value.\nSignature y-parity (0 or 1).\nSignature y-parity (0 or 1).\nSignature y-parity (0 or 1).\nSignature y-parity (0 or 1).\nSignature y-parity (0 or 1).\nABI type specification.\nABI-encoded value.\n20-byte Ethereum address.\n20-byte Ethereum address.\nDynamic array of a type.\nDynamic array.\nBoolean.\nBoolean value.\nDynamic byte array.\nDynamic byte array.\nFixed 1-byte array.\nFixed 1-byte array.\nFixed 16-byte array.\nFixed 16-byte array.\nFixed 2-byte array.\nFixed 2-byte array.\nFixed 3-byte array.\nFixed 3-byte array.\nFixed 32-byte array.\nFixed 32-byte array.\nFixed 4-byte array.\nFixed 4-byte array.\nFixed 8-byte array.\nFixed 8-byte array.\nFixed-size array.\nFixed-size array.\nSigned 128-bit integer.\nSigned 128-bit integer.\nSigned 16-bit integer.\nSigned 16-bit integer.\nSigned 256-bit integer.\nSigned 256-bit integer (32-byte big-endian).\nSigned 32-bit integer.\nSigned 32-bit integer.\nSigned 64-bit integer.\nSigned 64-bit integer.\nSigned 8-bit integer.\nSigned 8-bit integer.\nMaximum ABI encoding size (10 MB).\nMaximum recursion depth for nested types.\n4-byte function selector.\nDynamic UTF-8 string.\nUTF-8 string.\nTuple of types.\nTuple of values.\nUnsigned 128-bit integer.\nUnsigned 128-bit integer.\nUnsigned 16-bit integer.\nUnsigned 16-bit integer.\nUnsigned 256-bit integer.\nUnsigned 256-bit integer (32-byte big-endian).\nUnsigned 32-bit integer.\nUnsigned 32-bit integer.\nUnsigned 64-bit integer.\nUnsigned 64-bit integer.\nUnsigned 8-bit integer.\nUnsigned 8-bit integer.\nGet as Address if this is an Address.\nGet as array if this is an Array.\nGet as bool if this is a Bool.\nGet as bytes if this is Bytes.\nGet as string if this is a String.\nGet as tuple if this is a Tuple.\nGet as U256 if this is a Uint256.\nGet the canonical type string for signature computation.\nDecode function call data (with selector).\nDecode function return data (without selector).\nDecode ABI parameters.\nEncode function call data (selector + parameters).\nEncode ABI parameters.\nCompute 32-byte event topic from signature.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreate Uint256 from U256.\nCreate Uint256 from u64.\nCompute 4-byte function selector from signature.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCheck if this type is dynamic (variable-length encoding).\nParse type from canonical string.\nParse function signature and extract name and parameter …\nByte string.\nContains the error value\nInput has extra bytes after the encoded data.\nInput is too short (truncated).\nInvalid length field.\nExtra data after decoding (in non-stream mode).\nLeading zeros in length encoding.\nList of items.\nMaximum recursion depth to prevent stack overflow attacks.\nNon-canonical size encoding (e.g., using long form for …\nContains the success value\nRecursion depth exceeded.\nTrait for types that can be RLP decoded.\nRLP streaming decoder.\nTrait for types that can be RLP encoded.\nRLP-specific errors.\nDecoded RLP item.\nResult type for RLP operations.\nUnexpected input format.\nGet bytes if this is a bytes item.\nGet list if this is a list item.\nDecode RLP bytes to raw bytes.\nDecode the next item as bytes.\nDecode a single RLP item.\nDecode the next item.\nDecode RLP to a list of items.\nDecode RLP to an unsigned integer.\nDecode the next item as an unsigned integer.\nEncode bytes as RLP.\nEncode an RLP item.\nEncode a list of RLP items.\nEncode an unsigned integer as RLP.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCheck if this is a bytes item.\nCheck if RLP encoding is canonical.\nCheck if there is more data to decode.\nCheck if this is a list item.\nCreate a new decoder from a byte slice.\nGet remaining bytes.\nDecode this value from RLP.\nEncode this value as RLP.\nValidate RLP encoded data without fully decoding.")