# EIP-712 Typed Structured Data

Implementation of [EIP-712](https://eips.ethereum.org/EIPS/eip-712) for typed structured data hashing and signing.

## Overview

EIP-712 defines a standard for hashing and signing typed structured data. It enables:

- **Human-readable signatures**: Wallets can display meaningful information about what's being signed
- **Replay protection**: Domain separators prevent cross-contract and cross-chain replay attacks
- **Structured data**: Type definitions ensure data integrity

## Quick Start

```rust
use voltaire::crypto::eip712::{TypedData, Domain, TypeProperty};

// Define domain separator
let domain = Domain::new()
    .name("My dApp")
    .version("1")
    .chain_id(1);

// Define type schema
let types = vec![
    ("Message".to_string(), vec![
        TypeProperty::new("content", "string"),
    ]),
];

// Create typed data with message
let typed_data = TypedData::new(domain, types, "Message")
    .with_string("content", "Hello, EIP-712!");

// Get hash for signing
let hash = typed_data.hash();
```

## Domain Separator

The domain separator provides context for the signature:

```rust
use voltaire::crypto::eip712::Domain;
use voltaire::Address;

let domain = Domain::new()
    .name("My dApp")                           // Application name
    .version("1")                              // Schema version
    .chain_id(1)                               // Ethereum mainnet
    .verifying_contract(contract_address)      // Contract that verifies
    .salt(salt_hash);                          // Additional entropy

// Compute domain separator hash
let separator = domain.hash();
```

All fields are optional. Include only what's needed for your use case.

## Type Definitions

Define your data structures with `TypeProperty`:

```rust
use voltaire::crypto::eip712::TypeProperty;

// Simple struct
let person_type = vec![
    TypeProperty::new("name", "string"),
    TypeProperty::new("wallet", "address"),
];

// Nested structs
let mail_type = vec![
    TypeProperty::new("from", "Person"),    // References Person type
    TypeProperty::new("to", "Person"),
    TypeProperty::new("contents", "string"),
];
```

### Supported Types

| Type | Description |
|------|-------------|
| `string` | UTF-8 string (hashed) |
| `bytes` | Dynamic bytes (hashed) |
| `bytesN` | Fixed N bytes (1-32), left-aligned |
| `address` | 20-byte Ethereum address |
| `bool` | Boolean |
| `uintN` | Unsigned integer (8-256 bits) |
| `intN` | Signed integer (8-256 bits) |
| `T[]` | Dynamic array of type T |
| `T[N]` | Fixed-size array of type T |
| Custom | Reference to another struct type |

## Message Values

Build message data using the fluent API:

```rust
use voltaire::crypto::eip712::{TypedData, MessageValue};
use std::collections::BTreeMap;

let typed_data = TypedData::new(domain, types, "Transfer")
    .with_address("from", sender_address)
    .with_address("to", recipient_address)
    .with_uint("amount", 1_000_000_000_000_000_000) // 1 ETH in wei
    .with_uint("nonce", 0)
    .with_string("memo", "Payment for services");

// For nested structs
let mut person = BTreeMap::new();
person.insert("name".to_string(), MessageValue::String("Alice".into()));
person.insert("wallet".to_string(), MessageValue::Address(alice_addr));

let typed_data = typed_data.with_struct("sender", person);
```

## Core Functions

### encode_type

Encode type schema as string:

```rust
use voltaire::crypto::eip712::encode_type;

let encoded = encode_type("Mail", &types)?;
// "Mail(Person from,Person to,string contents)Person(string name,address wallet)"
```

### hash_type

Hash the encoded type string:

```rust
use voltaire::crypto::eip712::hash_type;

let type_hash = hash_type("Mail", &types)?;
```

### hash_struct

Hash a struct instance:

```rust
use voltaire::crypto::eip712::hash_struct;

let struct_hash = hash_struct("Person", &person_data, &types)?;
```

### hash_domain

Hash domain separator:

```rust
use voltaire::crypto::eip712::hash_domain;

let domain_separator = hash_domain(&domain);
```

### sign_typed_data

Compute the final hash for signing:

```rust
use voltaire::crypto::eip712::sign_typed_data;

// Computes: keccak256("\x19\x01" || domainSeparator || hashStruct(message))
let hash = sign_typed_data(&typed_data);
```

## Common Patterns

### ERC-2612 Permit

Gasless token approvals:

```rust
let domain = Domain::new()
    .name("USD Coin")
    .version("2")
    .chain_id(1)
    .verifying_contract(usdc_address);

let types = vec![(
    "Permit".to_string(),
    vec![
        TypeProperty::new("owner", "address"),
        TypeProperty::new("spender", "address"),
        TypeProperty::new("value", "uint256"),
        TypeProperty::new("nonce", "uint256"),
        TypeProperty::new("deadline", "uint256"),
    ],
)];

let permit = TypedData::new(domain, types, "Permit")
    .with_address("owner", owner)
    .with_address("spender", spender)
    .with_uint("value", amount)
    .with_uint("nonce", nonce)
    .with_uint("deadline", deadline);

let hash = permit.hash();
```

### Meta-Transactions

Gasless transaction execution:

```rust
let types = vec![(
    "ForwardRequest".to_string(),
    vec![
        TypeProperty::new("from", "address"),
        TypeProperty::new("to", "address"),
        TypeProperty::new("value", "uint256"),
        TypeProperty::new("gas", "uint256"),
        TypeProperty::new("nonce", "uint256"),
        TypeProperty::new("data", "bytes"),
    ],
)];
```

### DAO Voting

Off-chain voting with on-chain verification:

```rust
let types = vec![(
    "Vote".to_string(),
    vec![
        TypeProperty::new("proposalId", "uint256"),
        TypeProperty::new("support", "bool"),
        TypeProperty::new("voter", "address"),
    ],
)];
```

## Validation

Validate typed data before signing:

```rust
let typed_data = TypedData::new(domain, types, "Message")
    .with_string("content", "Hello");

match typed_data.validate() {
    Ok(()) => println!("Valid typed data"),
    Err(e) => println!("Invalid: {}", e),
}
```

Validation checks:
- Primary type exists in type definitions
- All required fields are present in message

## Security Considerations

1. **Domain Separation**: Always include relevant domain fields to prevent replay attacks
2. **Chain ID**: Include chain ID to prevent cross-chain replay
3. **Verifying Contract**: Include contract address when signatures are verified on-chain
4. **Nonce**: Use nonces for operations that should only execute once
5. **Deadline**: Include expiration timestamps for time-sensitive operations

## Error Handling

```rust
use voltaire::Error;

match encode_type("Unknown", &types) {
    Ok(encoded) => { /* use encoded */ }
    Err(Error::InvalidInput(msg)) => {
        println!("Type not found: {}", msg);
    }
    Err(e) => panic!("Unexpected error: {}", e),
}
```

## Integration with Signing

The hash returned by `TypedData::hash()` can be signed with any secp256k1 signing library:

```rust
let hash = typed_data.hash();

// Sign with your preferred method
let signature = sign_hash(hash.as_bytes(), private_key);
```

## References

- [EIP-712 Specification](https://eips.ethereum.org/EIPS/eip-712)
- [EIP-2612 Permit](https://eips.ethereum.org/EIPS/eip-2612)
- [EIP-4361 Sign-In with Ethereum](https://eips.ethereum.org/EIPS/eip-4361)
