---
title: Tree-Shakeable
description: Data-first design enables maximum tree-shakeability and bundle optimization
---

Voltaire prioritizes **developer ergonomics** over tree-shaking in its default API. Our documentation shows the Class API by default because it's more intuitive and readable. However, everything is implemented as tree-shakable standalone functions under the hood.

<Note>
**Bundle size sensitive?** Consider [viem.sh](https://viem.sh) - a production-proven library with excellent tree-shaking and minimal overhead. Voltaire focuses on ergonomics and advanced features over minimal bundle size.
</Note>

## Shared Dependencies

Voltaire reuses code from [ox](https://github.com/wevm/ox) and [abitype](https://github.com/wevm/abitype) wherever possible. If your application also uses viem, wagmi, or other wevm ecosystem tools, bundle size is **amortized** - the shared code only appears once in your final bundle.

## Data-First Design

Voltaire takes a **data-first approach** to Ethereum primitives. Core types are validated [branded types](/getting-started/branded-types) that separate data from operations, enabling maximum tree-shakeability.

**Data comes first.** Ethereum primitives are represented using the most idiomatic data type for each language:

<Tabs>
<Tab title="TypeScript">

- **Addresses** → 20-byte `Uint8Array`
- **Hashes** → 32-byte `Uint8Array`
- **Bytecode** → Variable-length `Uint8Array`
- **Hex strings** → Tagged `string`

These [branded types](/getting-started/branded-types) provide TypeScript safety with minimal runtime overhead. Methods operate on these types rather than encapsulating them in classes.

</Tab>

</Tabs>

## How It Works: Tree-Shakable Methods → Class API

Every method is implemented as a standalone, tree-shakable function. The Class API is a thin wrapper that delegates to these functions:

```typescript
// 1. Standalone tree-shakable function (toHex.js)
export function toHex(address) {
  return `0x${Array.from(address, (b) => b.toString(16).padStart(2, "0")).join("")}`;
}

// 2. Class API wraps the function (index.ts)
import * as BrandedAddress from "./internal-index.js";

export function Address(value) {
  const result = BrandedAddress.from(value);
  Object.setPrototypeOf(result, Address.prototype);
  return result;
}

// Static method delegates to tree-shakable function
Address.toHex = BrandedAddress.toHex;

// Instance method delegates to same function
Address.prototype.toHex = function() {
  return BrandedAddress.toHex(this);
};
```

This architecture:
- Keeps data and operations decoupled
- Single source of truth in standalone functions
- Classes are thin wrappers - no duplicated logic
- Import functions directly for tree-shaking

## Direct Function Imports

For bundle-size sensitive applications, import standalone functions:

```typescript
// Tree-shakeable - only imports what you use
import { fromHex, toHex, equals } from '@tevm/voltaire/Address'

const addr = fromHex('0x742d35Cc6634C0532925a3b844Bc9e7595f51e3e')
const hex = toHex(addr)
```

Compared to the namespace API (default in docs):

```typescript
// Namespace API - intuitive, consistent across all entrypoints
import { Address } from '@tevm/voltaire'

const addr = Address('0x742d35Cc6634C0532925a3b844Bc9e7595f51e3e')
const hex = Address.toHex(addr)
```

<Tip>
Importing from `@tevm/voltaire/Address` instead of `@tevm/voltaire` enables better tree-shaking. Avoiding methods like `toChecksummed()` excludes the keccak256 implementation (~50kb).
</Tip>

## Factory Pattern for Crypto Dependencies

Methods requiring crypto can use factory functions to inject dependencies:

```typescript
// Tree-shakeable: bring your own keccak256
import { ToChecksummed } from '@tevm/voltaire/Address'
import { keccak256 } from '@noble/hashes/sha3'

const toChecksummed = ToChecksummed({ keccak256 })
const checksummed = toChecksummed(addr)
```

The default export auto-injects dependencies for convenience:

```typescript
// Convenient but includes keccak256 in bundle
import { toChecksummed } from '@tevm/voltaire/Address'

const checksummed = toChecksummed(addr)
```

## Performance

The Class API has negligible runtime overhead:

- **Direct function imports**: Best for tree-shaking and bundle size
- **Class instances**: Prototype lookup adds ~0.5ns per method call (negligible)
- **Memory**: Class API uses ~100 bytes more per primitive type (prototype chain)

For typical applications, performance differences are unmeasurable. Choose based on bundle size requirements.
