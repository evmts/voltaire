---
title: Multiplatform
description: Works everywhere - TypeScript, Zig, and any language with C-FFI
---

Works everywhere. TypeScript, Zig, any language with C-FFI.

## TypeScript Entrypoints

Voltaire provides three entrypoints with identical APIs for different performance profiles:

```typescript
import { Address, Keccak256 } from '@tevm/voltaire'        // JS (default)
import { Address, Keccak256 } from '@tevm/voltaire/wasm'   // WASM
import { Address, Keccak256 } from '@tevm/voltaire/native' // Native FFI (Bun only)
```

All entrypoints implement the same [`VoltaireAPI` interface](https://github.com/evmts/voltaire/blob/main/src/api-interface.ts) - switch by changing the import path.

<Tip>
For detailed performance comparisons and choosing the right entrypoint, see [Runtime Implementations](/getting-started/wasm).
</Tip>

## Installation by Language

<Tabs>
<Tab title="TypeScript/JavaScript">

```bash
npm install @tevm/voltaire
# or: bun add @tevm/voltaire / pnpm add @tevm/voltaire / yarn add @tevm/voltaire
```

Then import from any entrypoint:

```typescript
// JS (default) - works everywhere
import { Address, Keccak256 } from '@tevm/voltaire'

// WASM - for browser/edge crypto performance
import { Address, Keccak256 } from '@tevm/voltaire/wasm'

// Native - for Bun maximum performance
import { Address, Keccak256 } from '@tevm/voltaire/native'
```

</Tab>

<Tab title="Zig">

<Warning>
**Important:** Voltaire requires native C/Rust libraries that must be built before use. `zig fetch` alone will not work because the Rust crypto wrappers (`libcrypto_wrappers.a`) are built at compile time via Cargo.
</Warning>

**Option 1: Git Submodule (Recommended)**

Add as a git submodule in your project:

```bash
git submodule add https://github.com/evmts/voltaire.git lib/voltaire
cd lib/voltaire
zig build  # Builds Rust/C dependencies via Cargo
```

Then in your `build.zig`:

```zig
const voltaire = b.dependency("voltaire", .{
    .target = target,
    .optimize = optimize,
});

// Add modules to your executable/library
exe.root_module.addImport("primitives", voltaire.module("primitives"));
exe.root_module.addImport("crypto", voltaire.module("crypto"));

// Link required native libraries
exe.linkLibrary(voltaire.artifact("blst"));
exe.linkLibrary(voltaire.artifact("c_kzg"));
```

And in your `build.zig.zon`:

```zig
.dependencies = .{
    .voltaire = .{ .path = "lib/voltaire" },
},
```

**Option 2: Build from Source**

Clone and build once, then reference by path:

```bash
git clone https://github.com/evmts/voltaire.git
cd voltaire
zig build  # Requires Cargo/Rust installed
```

**Prerequisites for Zig builds:**
- [Zig 0.15.1+](https://ziglang.org/download/)
- [Rust/Cargo](https://rustup.rs/) - Required for native crypto wrappers

</Tab>

<Tab title="C-FFI">

Build the C library:

```bash
git clone https://github.com/evmts/voltaire.git
cd voltaire
zig build -Dwith-c-api=true
```

This produces:
- `zig-out/lib/libprimitives_c.a` (static library)
- `zig-out/lib/libprimitives_c.dylib` (dynamic library, macOS)
- `zig-out/include/primitives.h` (C header)

Link against the library and include the header in your project.

</Tab>
</Tabs>

<CardGroup cols={2}>
  <Card title="First Class Support" icon="star">
    TypeScript, Zig, and C - fully supported with complete APIs and documentation
  </Card>
  <Card title="C-FFI Support" icon="globe">
    Swift, Go, Python, Kotlin, and any language with foreign function interface support
  </Card>
</CardGroup>

<Warning>
C-FFI bindings require manual memory management. Always call corresponding `_free` functions to prevent leaks.
</Warning>

## Consistent API

The Voltaire API is consistent across all languages.

<Tabs>
<Tab title="TypeScript">

```typescript
import { Address } from '@tevm/voltaire'

const address = Address('0x742d35Cc6634C0532925a3b844Bc9e7595f51e3e')

Address.toChecksummed(address)
Address.toHex(address)
Address.isZero(address)
Address.equals(address, otherAddress)

// Also available as instance methods
address.toChecksummed()
address.toHex()
address.isZero()
address.equals(otherAddress)
```

</Tab>

<Tab title="Zig">

```zig
const Address = @import("primitives").Address;

pub fn main() !void {
    const address = try Address.fromHex("0x742d35Cc6634C0532925a3b844Bc9e7595f51e3e");

    _ = address.toChecksummed();
    _ = address.toHex();
    _ = address.isZero();
    _ = address.equals(otherAddress);
}
```

</Tab>

<Tab title="C">

```c
#include "primitives.h"

int main() {
    Address* address = tevm_address_from_hex("0x742d35Cc6634C0532925a3b844Bc9e7595f51e3e");

    char* checksummed = tevm_address_to_checksummed(address);
    char* hex = tevm_address_to_hex(address);
    bool is_zero = tevm_address_is_zero(address);
    bool equal = tevm_address_equals(address, other_address);

    // Free memory
    tevm_string_free(checksummed);
    tevm_string_free(hex);
    tevm_address_free(address);
}
```

</Tab>

<Tab title="Swift">

```swift
import Voltaire

// Idiomatic Swift wrappers over C-FFI
let address = try Address(hex: "0x742d35Cc6634C0532925a3b844Bc9e7595f51e3e")
print(address.checksumHex)
print(address.hex)
print(address.isZero)

let other = try Address(hex: "0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045")
print(address == other)
```

</Tab>

<Tab title="Kotlin (Experimental)">

```kotlin
import com.tevm.voltaire.Address

// JNI bindings over C-FFI
val address = Address.fromHex("0x742d35Cc6634C0532925a3b844Bc9e7595f51e3e")
println(address.checksumHex)
println(address.hex)
println(address.isZero)

val other = Address.fromHex("0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045")
println(address == other)
```

</Tab>

<Tab title="Go (Experimental)">

```go
package main

import "github.com/evmts/voltaire-go"

func main() {
    address, _ := voltaire.AddressFromHex("0x742d35Cc6634C0532925a3b844Bc9e7595f51e3e")
    fmt.Println(address.ChecksumHex())
    fmt.Println(address.Hex())
    fmt.Println(address.IsZero())

    other, _ := voltaire.AddressFromHex("0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045")
    fmt.Println(address.Equals(other))
}
```

</Tab>

<Tab title="Python (Experimental)">

```python
from voltaire import Address

# ctypes/cffi bindings over C-FFI
address = Address.from_hex("0x742d35Cc6634C0532925a3b844Bc9e7595f51e3e")
print(address.checksum_hex)
print(address.hex)
print(address.is_zero)

other = Address.from_hex("0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045")
print(address == other)
```

</Tab>
</Tabs>

## Looking for Help

We're looking for contributors to help build idiomatic wrappers for:

- **Go** - Native bindings via cgo
- **Python** - Bindings via ctypes/cffi
- **Swift** - Fully implemented but lacking tests and complete documentation
- **Kotlin** - Android/JVM bindings

<Tip>
Interested in contributing? Check out [src/c_api.zig](https://github.com/evmts/voltaire/blob/main/src/c_api.zig) for the C-FFI interface and [src/primitives.h](https://github.com/evmts/voltaire/blob/main/src/primitives.h) for the generated C header. Join our [Telegram](https://t.me/+ANThR9bHDLAwMjUx) or open an issue on [GitHub](https://github.com/evmts/voltaire/issues).
</Tip>
