---
title: Proof
description: Generic Merkle proof for verifying inclusion in Merkle trees
---

# Proof

Generic Merkle proof structure for verifying inclusion in a Merkle tree.

## Overview

Proof represents a Merkle proof consisting of a leaf value and an array of sibling hashes forming the path from leaf to root. This generic structure serves as the basis for more specific proof types like StateProof and StorageProof.

## Type Definition

```typescript
type ProofType = {
  /** The leaf value being proven for inclusion */
  readonly value: Uint8Array;

  /** Array of sibling hashes forming the Merkle branch */
  readonly proof: readonly Uint8Array[];
};

type ProofLike = ProofType | {
  value: Uint8Array;
  proof: readonly Uint8Array[];
};
```

## Usage

### Create Proof

```typescript
import * as Proof from './primitives/Proof/index.js';

const proof = Proof.from({
  value: new Uint8Array([0x01, 0x02, 0x03]),
  proof: [
    new Uint8Array(32), // sibling hash 1
    new Uint8Array(32), // sibling hash 2
  ],
});
```

### Compare Proofs

```typescript
const isEqual = Proof.equals(proof1, proof2);
```

## API Reference

### Constructors

| Function | Description |
|----------|-------------|
| `from(proof)` | Create from ProofLike object |

### Methods

| Function | Description |
|----------|-------------|
| `equals(a, b)` | Check if two proofs are equal |

## Merkle Proof Verification

A Merkle proof demonstrates that a leaf exists in a tree without revealing the entire tree:

```
        Root Hash
       /         \
    Hash01      Hash23
   /    \      /    \
Hash0 Hash1 Hash2 Hash3
  |     |     |     |
Leaf0 Leaf1 Leaf2 Leaf3
```

To prove Leaf1 exists:
1. Provide Leaf1 (the value)
2. Provide proof: [Hash0, Hash23]
3. Verifier computes: hash(Hash0 || hash(Leaf1)) = Hash01
4. Verifier computes: hash(Hash01 || Hash23) = Root Hash
5. Compare with known root

## Verification Process

```typescript
import * as Hash from './primitives/Hash/index.js';

function verifyProof(
  proof: ProofType,
  expectedRoot: Uint8Array,
  index: number
): boolean {
  let current = Hash.keccak256(proof.value);

  for (const sibling of proof.proof) {
    if (index % 2 === 0) {
      current = Hash.keccak256(concat(current, sibling));
    } else {
      current = Hash.keccak256(concat(sibling, current));
    }
    index = Math.floor(index / 2);
  }

  return equals(current, expectedRoot);
}
```

## Related Proof Types

This generic Proof type is the foundation for Ethereum-specific proofs:

| Type | Description |
|------|-------------|
| [StateProof](/primitives/state-proof) | EIP-1186 account state proofs |
| [StorageProof](/primitives/storage-proof) | EIP-1186 storage slot proofs |

## See Also

- [StateProof](/primitives/state-proof) - Account state proofs
- [StorageProof](/primitives/storage-proof) - Storage slot proofs
- [StateRoot](/primitives/state-root) - State trie root hash
- [Hash](/primitives/hash) - Hash primitives
