---
title: FunctionSignature
description: Extended function selector with metadata
---

# FunctionSignature

A **FunctionSignature** represents a complete Ethereum function signature with metadata, including the 4-byte selector, function name, and parameter types.

## Type Definition

```typescript
type FunctionSignatureType = {
  readonly selector: SelectorType;
  readonly signature: string;
  readonly name: string;
  readonly inputs: readonly string[];
};
```

## Creating Function Signatures

### From Signature String

```typescript
import * as FunctionSignature from '@tevm/primitives';

const sig = FunctionSignature.fromSignature('transfer(address,uint256)');

console.log(sig.name);                          // 'transfer'
console.log(sig.inputs);                        // ['address', 'uint256']
console.log(sig.signature);                     // 'transfer(address,uint256)'
console.log(FunctionSignature.toHex(sig));      // '0xa9059cbb'
```

### From Selector

```typescript
import * as Selector from '@tevm/primitives';

const selector = Selector.fromHex('0xa9059cbb');
const sig = FunctionSignature.from(selector);

console.log(sig.name);    // '' (unknown)
console.log(sig.inputs);  // [] (unknown)
```

## Operations

### Parse Signature

Extract function name and parameter types:

```typescript
const { name, inputs } = FunctionSignature.parseSignature(
  'swap(uint256,uint256,address,bytes)'
);

console.log(name);    // 'swap'
console.log(inputs);  // ['uint256', 'uint256', 'address', 'bytes']
```

### Compare Signatures

Comparison is based on selector equality:

```typescript
const sig1 = FunctionSignature.fromSignature('transfer(address,uint256)');
const sig2 = FunctionSignature.fromSignature('transfer(address,uint256)');
const equal = FunctionSignature.equals(sig1, sig2); // true
```

### Convert to Hex

```typescript
const hex = FunctionSignature.toHex(sig);
// '0xa9059cbb'
```

## Complex Type Support

### Tuples

```typescript
const sig = FunctionSignature.fromSignature(
  'execute((address,uint256,bytes)[])'
);

console.log(sig.name);    // 'execute'
console.log(sig.inputs);  // ['(address,uint256,bytes)[]']
```

### Arrays

```typescript
const sig = FunctionSignature.fromSignature(
  'batchTransfer(address[],uint256[])'
);

console.log(sig.inputs);  // ['address[]', 'uint256[]']
```

### Nested Structures

```typescript
const sig = FunctionSignature.fromSignature(
  'complexCall((address,(uint256,bytes)[])[])'
);

console.log(sig.inputs);  // ['(address,(uint256,bytes)[])[]']
```

## Common Function Signatures

### ERC-20

```typescript
const transfer = FunctionSignature.fromSignature('transfer(address,uint256)');
const approve = FunctionSignature.fromSignature('approve(address,uint256)');
const balanceOf = FunctionSignature.fromSignature('balanceOf(address)');
```

### ERC-721

```typescript
const transferFrom = FunctionSignature.fromSignature(
  'transferFrom(address,address,uint256)'
);
const safeTransferFrom = FunctionSignature.fromSignature(
  'safeTransferFrom(address,address,uint256)'
);
```

### Uniswap V2

```typescript
const swap = FunctionSignature.fromSignature(
  'swap(uint256,uint256,address,bytes)'
);
// selector: 0x022c0d9f
```

## Use Cases

### ABI Encoding

Use with ABI encoding to construct function calls:

```typescript
const sig = FunctionSignature.fromSignature('transfer(address,uint256)');
const data = Abi.encodeFunctionData(sig, [recipient, amount]);
```

### Function Routing

Build function dispatch tables:

```typescript
const handlers = new Map();
handlers.set(
  FunctionSignature.toHex(transferSig),
  handleTransfer
);
handlers.set(
  FunctionSignature.toHex(approveSig),
  handleApprove
);
```

### Contract Introspection

Identify functions from transaction data:

```typescript
const selector = txData.slice(0, 4);
const sig = FunctionSignature.from(selector);
console.log(`Function: ${sig.name || 'unknown'}`);
```

## API Reference

### Constructors

- `from(value: FunctionSignatureLike): FunctionSignatureType` - Create from various inputs
- `fromSignature(signature: string): FunctionSignatureType` - Create from signature string

### Operations

- `toHex(sig: FunctionSignatureType): string` - Get selector as hex
- `equals(a: FunctionSignatureType, b: FunctionSignatureType): boolean` - Compare signatures
- `parseSignature(signature: string): { name: string, inputs: string[] }` - Parse signature string

## See Also

- [Selector](/primitives/selector) - 4-byte function selector
- [EventSignature](/primitives/event-signature) - 32-byte event topic
- [ErrorSignature](/primitives/error-signature) - 4-byte error selector
- [ABI](/primitives/abi) - ABI encoding and decoding
