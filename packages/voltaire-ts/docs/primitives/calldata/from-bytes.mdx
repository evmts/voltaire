---
title: fromBytes
description: Create CallData from Uint8Array
---

Creates CallData from a raw byte array. Specialized constructor for binary input with zero-copy optimization.

## Signature

<Tabs>
<Tab title="Namespace">

```typescript
function fromBytes(bytes: Uint8Array): CallDataType
```

</Tab>
<Tab title="Class">

```typescript
CallData.fromBytes(bytes: Uint8Array): CallDataType
```

</Tab>
</Tabs>

## Parameters

- **bytes** - Raw byte array representing calldata

## Returns

`CallDataType` - Branded Uint8Array with CallData semantics

## Examples

<Tabs>
<Tab title="Basic Usage">

```typescript
import { CallData } from '@tevm/voltaire';

const bytes = new Uint8Array([
  0xa9, 0x05, 0x9c, 0xbb, // transfer(address,uint256) selector
  // ... encoded parameters
]);

const calldata = CallData.fromBytes(bytes);
console.log(CallData.getSelector(calldata));
// [0xa9, 0x05, 0x9c, 0xbb]
```

</Tab>
<Tab title="From Buffer">

```typescript
import { CallData } from '@tevm/voltaire';
import { readFileSync } from 'fs';

// Read binary calldata from file
const buffer = readFileSync('calldata.bin');
const bytes = new Uint8Array(buffer);

const calldata = CallData.fromBytes(bytes);
console.log("Size:", calldata.length, "bytes");
```

</Tab>
<Tab title="Namespace API">

```typescript
import * as CallData from '@tevm/voltaire/CallData';

const bytes = new Uint8Array([0xa9, 0x05, 0x9c, 0xbb]);
const calldata = CallData.fromBytes(bytes);
```

</Tab>
</Tabs>

## Zero-Copy Optimization

`fromBytes` uses zero-copy when possible:

```typescript
import { CallData } from '@tevm/voltaire';

const bytes = new Uint8Array([0xa9, 0x05, 0x9c, 0xbb]);
const calldata = CallData.fromBytes(bytes);

// Same underlying buffer (no copy)
console.log(calldata.buffer === bytes.buffer); // true
```

This makes `fromBytes` the most efficient constructor for binary data.

## Validation

Validates byte array structure:

```typescript
import { CallData } from '@tevm/voltaire';

// Too short (must be at least 4 bytes for selector)
try {
  const bytes = new Uint8Array([0xa9, 0x05]);
  CallData.fromBytes(bytes);
} catch (error) {
  console.error("CallData must be at least 4 bytes");
}

// Valid (selector only)
const bytes = new Uint8Array([0xa9, 0x05, 0x9c, 0xbb]);
const calldata = CallData.fromBytes(bytes);
console.log(calldata.length); // 4
```

## Use Cases

### Binary Protocol

```typescript
import { CallData } from '@tevm/voltaire';

// Receive binary data over network
function handleBinaryMessage(data: ArrayBuffer) {
  const bytes = new Uint8Array(data);
  const calldata = CallData.fromBytes(bytes);

  // Process calldata
  const selector = CallData.getSelector(calldata);
  return routeBySelector(selector, calldata);
}
```

### Performance-Critical Path

```typescript
import { CallData } from '@tevm/voltaire';

// Avoid hex encoding/decoding overhead
function fastEncode(selector: Uint8Array, params: Uint8Array): CallDataType {
  const bytes = new Uint8Array(selector.length + params.length);
  bytes.set(selector, 0);
  bytes.set(params, selector.length);

  return CallData.fromBytes(bytes); // Zero-copy
}
```

### Buffer Slicing

```typescript
import { CallData } from '@tevm/voltaire';

// Extract calldata from larger buffer
function extractCallData(
  buffer: Uint8Array,
  offset: number,
  length: number
): CallDataType {
  const slice = buffer.slice(offset, offset + length);
  return CallData.fromBytes(slice);
}
```

### Web APIs

```typescript
import { CallData } from '@tevm/voltaire';

// From Blob
async function fromBlob(blob: Blob): Promise<CallDataType> {
  const arrayBuffer = await blob.arrayBuffer();
  const bytes = new Uint8Array(arrayBuffer);
  return CallData.fromBytes(bytes);
}

// From Response
async function fromResponse(response: Response): Promise<CallDataType> {
  const arrayBuffer = await response.arrayBuffer();
  const bytes = new Uint8Array(arrayBuffer);
  return CallData.fromBytes(bytes);
}
```

## Type Safety

Enforces CallData brand at compile time:

```typescript
import { CallData, type CallDataType } from '@tevm/voltaire';

// Type error: Uint8Array not assignable
const bytes = new Uint8Array([0xa9, 0x05, 0x9c, 0xbb]);
const calldata: CallDataType = bytes; // ❌

// Correct: Use fromBytes
const calldata: CallDataType = CallData.fromBytes(bytes); // ✅
```

## Performance Comparison

<Tabs>
<Tab title="fromHex vs fromBytes">

```typescript
import { CallData } from '@tevm/voltaire';

const hex = "0xa9059cbb..."; // 136 characters
const bytes = new Uint8Array([0xa9, 0x05, 0x9c, 0xbb, ...]); // 68 bytes

// fromHex: Parse + allocate
console.time("fromHex");
CallData.fromHex(hex);
console.timeEnd("fromHex"); // ~50μs

// fromBytes: Zero-copy
console.time("fromBytes");
CallData.fromBytes(bytes);
console.timeEnd("fromBytes"); // ~5μs (10x faster)
```

</Tab>
<Tab title="Benchmarks">

**Results** (1M iterations):
- `fromHex`: ~50ms (parsing overhead)
- `fromBytes`: ~5ms (zero-copy)
- `from` (hex): ~50ms (delegates to fromHex)
- `from` (bytes): ~5ms (delegates to fromBytes)

</Tab>
</Tabs>

## Related

- [from](/primitives/calldata/from) - Universal constructor
- [fromHex](/primitives/calldata/from-hex) - From hex string
- [toBytes](/primitives/calldata/to-bytes) - Convert to Uint8Array
- [encode](/primitives/calldata/encode) - Encode function call
