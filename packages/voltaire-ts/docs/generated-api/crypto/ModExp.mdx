---
title: "crypto/ModExp"
description: Auto-generated API documentation
---

[**@tevm/voltaire**](../index.mdx)

***

[@tevm/voltaire](../index.mdx) / crypto/ModExp

# crypto/ModExp

## Variables

### ModExp

> `const` **ModExp**: (`base`, `exp`, `modulus`) => `bigint` & `object`

Defined in: [src/crypto/ModExp/ModExp.js:35](https://github.com/evmts/voltaire/blob/bd6ec34405c15ad8cd51d11579d495dc53813482/src/crypto/ModExp/ModExp.js#L35)

ModExp - Modular Exponentiation

Computes base^exp mod modulus for arbitrary-precision integers.
Used by MODEXP precompile (0x05) per EIP-198/EIP-2565.

#### Type Declaration

##### calculateGas()

> **calculateGas**: (`baseLen`, `expLen`, `modLen`, `expHead`) => `bigint`

Calculate gas cost for MODEXP operation per EIP-2565

Gas formula: max(200, floor(mult_complexity * iteration_count / 3))

###### Parameters

###### baseLen

`bigint`

Length of base in bytes

###### expLen

`bigint`

Length of exponent in bytes

###### modLen

`bigint`

Length of modulus in bytes

###### expHead

`bigint`

First 32 bytes of exponent as BigInt (for leading zeros calc)

###### Returns

`bigint`

Gas cost

###### See

https://eips.ethereum.org/EIPS/eip-2565

###### Since

0.0.0

###### Example

```javascript
import { ModExp } from './crypto/ModExp/index.js';

// Calculate gas for 2^3 mod 5
const gas = ModExp.calculateGas(1n, 1n, 1n, 3n);
console.log(gas); // 200n (minimum)
```

##### modexp()

> **modexp**: (`base`, `exp`, `modulus`) => `bigint`

Modular exponentiation: base^exp mod modulus

Computes arbitrary-precision modular exponentiation using native BigInt.
Used by MODEXP precompile (0x05) per EIP-198.

WARNING: This implementation is for general use. For cryptographic
applications, consider timing attack resistance.

###### Parameters

###### base

`bigint`

Base value

###### exp

`bigint`

Exponent value

###### modulus

`bigint`

Modulus value (must be > 0)

###### Returns

`bigint`

Result of base^exp mod modulus

###### See

https://eips.ethereum.org/EIPS/eip-198

###### Since

0.0.0

###### Throws

If modulus is zero

###### Example

```javascript
import { ModExp } from './crypto/ModExp/index.js';

// Compute 2^10 mod 1000 = 24
const result = ModExp.modexp(2n, 10n, 1000n);
console.log(result); // 24n

// RSA verification: signature^e mod n
const verified = ModExp.modexp(signature, e, n);
```

##### modexpBytes()

> **modexpBytes**: (`baseBytes`, `expBytes`, `modBytes`) => `Uint8Array`\<`ArrayBufferLike`\>

Modular exponentiation with byte array inputs/outputs

Computes base^exp mod modulus where inputs are big-endian byte arrays.
Output is padded to modulus length per EIP-198 spec.

###### Parameters

###### baseBytes

`Uint8Array`\<`ArrayBufferLike`\>

Base as big-endian bytes

###### expBytes

`Uint8Array`\<`ArrayBufferLike`\>

Exponent as big-endian bytes

###### modBytes

`Uint8Array`\<`ArrayBufferLike`\>

Modulus as big-endian bytes

###### Returns

`Uint8Array`\<`ArrayBufferLike`\>

Result as big-endian bytes, padded to modulus length

###### See

https://eips.ethereum.org/EIPS/eip-198

###### Since

0.0.0

###### Throws

If modulus is zero

###### Example

```javascript
import { ModExp } from './crypto/ModExp/index.js';

const base = new Uint8Array([0x02]); // 2
const exp = new Uint8Array([0x03]);  // 3
const mod = new Uint8Array([0x05]);  // 5

const result = ModExp.modexpBytes(base, exp, mod);
console.log(result); // Uint8Array([0x03]) = 3
```

#### See

 - https://eips.ethereum.org/EIPS/eip-198 - ModExp precompile
 - https://eips.ethereum.org/EIPS/eip-2565 - Gas cost repricing

#### Since

0.0.0

#### Example

```javascript
import { ModExp } from './crypto/ModExp/index.js';

// Using BigInt directly
const result = ModExp.modexp(2n, 10n, 1000n); // 24n

// Using byte arrays (EIP-198 format)
const base = new Uint8Array([0x02]);
const exp = new Uint8Array([0x0a]);
const mod = new Uint8Array([0x03, 0xe8]);
const resultBytes = ModExp.modexpBytes(base, exp, mod);

// Calculate gas cost
const gas = ModExp.calculateGas(1n, 1n, 2n, 10n);
```

## Functions

### calculateGas()

> **calculateGas**(`baseLen`, `expLen`, `modLen`, `expHead`): `bigint`

Defined in: [src/crypto/ModExp/calculateGas.js:22](https://github.com/evmts/voltaire/blob/bd6ec34405c15ad8cd51d11579d495dc53813482/src/crypto/ModExp/calculateGas.js#L22)

Calculate gas cost for MODEXP operation per EIP-2565

Gas formula: max(200, floor(mult_complexity * iteration_count / 3))

#### Parameters

##### baseLen

`bigint`

Length of base in bytes

##### expLen

`bigint`

Length of exponent in bytes

##### modLen

`bigint`

Length of modulus in bytes

##### expHead

`bigint`

First 32 bytes of exponent as BigInt (for leading zeros calc)

#### Returns

`bigint`

Gas cost

#### See

https://eips.ethereum.org/EIPS/eip-2565

#### Since

0.0.0

#### Example

```javascript
import { ModExp } from './crypto/ModExp/index.js';

// Calculate gas for 2^3 mod 5
const gas = ModExp.calculateGas(1n, 1n, 1n, 3n);
console.log(gas); // 200n (minimum)
```

***

### modexp()

> **modexp**(`base`, `exp`, `modulus`): `bigint`

Defined in: [src/crypto/ModExp/compute.js:29](https://github.com/evmts/voltaire/blob/bd6ec34405c15ad8cd51d11579d495dc53813482/src/crypto/ModExp/compute.js#L29)

Modular exponentiation: base^exp mod modulus

Computes arbitrary-precision modular exponentiation using native BigInt.
Used by MODEXP precompile (0x05) per EIP-198.

WARNING: This implementation is for general use. For cryptographic
applications, consider timing attack resistance.

#### Parameters

##### base

`bigint`

Base value

##### exp

`bigint`

Exponent value

##### modulus

`bigint`

Modulus value (must be > 0)

#### Returns

`bigint`

Result of base^exp mod modulus

#### See

https://eips.ethereum.org/EIPS/eip-198

#### Since

0.0.0

#### Throws

If modulus is zero

#### Example

```javascript
import { ModExp } from './crypto/ModExp/index.js';

// Compute 2^10 mod 1000 = 24
const result = ModExp.modexp(2n, 10n, 1000n);
console.log(result); // 24n

// RSA verification: signature^e mod n
const verified = ModExp.modexp(signature, e, n);
```

***

### modexpBytes()

> **modexpBytes**(`baseBytes`, `expBytes`, `modBytes`): `Uint8Array`\<`ArrayBufferLike`\>

Defined in: [src/crypto/ModExp/modexpBytes.js:28](https://github.com/evmts/voltaire/blob/bd6ec34405c15ad8cd51d11579d495dc53813482/src/crypto/ModExp/modexpBytes.js#L28)

Modular exponentiation with byte array inputs/outputs

Computes base^exp mod modulus where inputs are big-endian byte arrays.
Output is padded to modulus length per EIP-198 spec.

#### Parameters

##### baseBytes

`Uint8Array`\<`ArrayBufferLike`\>

Base as big-endian bytes

##### expBytes

`Uint8Array`\<`ArrayBufferLike`\>

Exponent as big-endian bytes

##### modBytes

`Uint8Array`\<`ArrayBufferLike`\>

Modulus as big-endian bytes

#### Returns

`Uint8Array`\<`ArrayBufferLike`\>

Result as big-endian bytes, padded to modulus length

#### See

https://eips.ethereum.org/EIPS/eip-198

#### Since

0.0.0

#### Throws

If modulus is zero

#### Example

```javascript
import { ModExp } from './crypto/ModExp/index.js';

const base = new Uint8Array([0x02]); // 2
const exp = new Uint8Array([0x03]);  // 3
const mod = new Uint8Array([0x05]);  // 5

const result = ModExp.modexpBytes(base, exp, mod);
console.log(result); // Uint8Array([0x03]) = 3
```
