---
title: "native"
description: Auto-generated API documentation
---

[**@tevm/voltaire**](index.mdx)

***

[@tevm/voltaire](index.mdx) / native

# native

## Enumerations

### NativeErrorCode

Defined in: [src/native-loader/types.ts:204](https://github.com/evmts/voltaire/blob/bd6ec34405c15ad8cd51d11579d495dc53813482/src/native-loader/types.ts#L204)

Runtime error codes from native library

#### Enumeration Members

##### BUFFER\_TOO\_SMALL

> **BUFFER\_TOO\_SMALL**: `-4`

Defined in: [src/native-loader/types.ts:209](https://github.com/evmts/voltaire/blob/bd6ec34405c15ad8cd51d11579d495dc53813482/src/native-loader/types.ts#L209)

##### DECODING\_ERROR

> **DECODING\_ERROR**: `-10`

Defined in: [src/native-loader/types.ts:215](https://github.com/evmts/voltaire/blob/bd6ec34405c15ad8cd51d11579d495dc53813482/src/native-loader/types.ts#L215)

##### ENCODING\_ERROR

> **ENCODING\_ERROR**: `-9`

Defined in: [src/native-loader/types.ts:214](https://github.com/evmts/voltaire/blob/bd6ec34405c15ad8cd51d11579d495dc53813482/src/native-loader/types.ts#L214)

##### INVALID\_CHECKSUM

> **INVALID\_CHECKSUM**: `-3`

Defined in: [src/native-loader/types.ts:208](https://github.com/evmts/voltaire/blob/bd6ec34405c15ad8cd51d11579d495dc53813482/src/native-loader/types.ts#L208)

##### INVALID\_HEX

> **INVALID\_HEX**: `-1`

Defined in: [src/native-loader/types.ts:206](https://github.com/evmts/voltaire/blob/bd6ec34405c15ad8cd51d11579d495dc53813482/src/native-loader/types.ts#L206)

##### INVALID\_LENGTH

> **INVALID\_LENGTH**: `-2`

Defined in: [src/native-loader/types.ts:207](https://github.com/evmts/voltaire/blob/bd6ec34405c15ad8cd51d11579d495dc53813482/src/native-loader/types.ts#L207)

##### INVALID\_PRIVATE\_KEY

> **INVALID\_PRIVATE\_KEY**: `-7`

Defined in: [src/native-loader/types.ts:212](https://github.com/evmts/voltaire/blob/bd6ec34405c15ad8cd51d11579d495dc53813482/src/native-loader/types.ts#L212)

##### INVALID\_PUBLIC\_KEY

> **INVALID\_PUBLIC\_KEY**: `-8`

Defined in: [src/native-loader/types.ts:213](https://github.com/evmts/voltaire/blob/bd6ec34405c15ad8cd51d11579d495dc53813482/src/native-loader/types.ts#L213)

##### INVALID\_RECOVERY\_ID

> **INVALID\_RECOVERY\_ID**: `-6`

Defined in: [src/native-loader/types.ts:211](https://github.com/evmts/voltaire/blob/bd6ec34405c15ad8cd51d11579d495dc53813482/src/native-loader/types.ts#L211)

##### INVALID\_SIGNATURE

> **INVALID\_SIGNATURE**: `-5`

Defined in: [src/native-loader/types.ts:210](https://github.com/evmts/voltaire/blob/bd6ec34405c15ad8cd51d11579d495dc53813482/src/native-loader/types.ts#L210)

##### NULL\_POINTER

> **NULL\_POINTER**: `-11`

Defined in: [src/native-loader/types.ts:216](https://github.com/evmts/voltaire/blob/bd6ec34405c15ad8cd51d11579d495dc53813482/src/native-loader/types.ts#L216)

##### OUT\_OF\_MEMORY

> **OUT\_OF\_MEMORY**: `-12`

Defined in: [src/native-loader/types.ts:217](https://github.com/evmts/voltaire/blob/bd6ec34405c15ad8cd51d11579d495dc53813482/src/native-loader/types.ts#L217)

##### SUCCESS

> **SUCCESS**: `0`

Defined in: [src/native-loader/types.ts:205](https://github.com/evmts/voltaire/blob/bd6ec34405c15ad8cd51d11579d495dc53813482/src/native-loader/types.ts#L205)

##### UNKNOWN\_ERROR

> **UNKNOWN\_ERROR**: `-99`

Defined in: [src/native-loader/types.ts:218](https://github.com/evmts/voltaire/blob/bd6ec34405c15ad8cd51d11579d495dc53813482/src/native-loader/types.ts#L218)

## Type Aliases

### Platform

> **Platform** = `"darwin-arm64"` \| `"darwin-x64"` \| `"linux-arm64"` \| `"linux-x64"` \| `"win32-x64"`

Defined in: [src/native-loader/platform.ts:5](https://github.com/evmts/voltaire/blob/bd6ec34405c15ad8cd51d11579d495dc53813482/src/native-loader/platform.ts#L5)

Platform detection utilities for native bindings

## Variables

### Keccak256

> `const` **Keccak256**: (`input`) => `Promise`\<[`Keccak256Hash`](index/index.mdx#keccak256hash)\> & `object` = `Keccak256Hash`

Defined in: [src/crypto/Keccak256/Keccak256.native.ts:150](https://github.com/evmts/voltaire/blob/bd6ec34405c15ad8cd51d11579d495dc53813482/src/crypto/Keccak256/Keccak256.native.ts#L150)

#### Type Declaration

##### DIGEST\_SIZE

> **DIGEST\_SIZE**: `number` = `32`

##### from()

> **from**: (`input`) => `Promise`\<[`Keccak256Hash`](index/index.mdx#keccak256hash)\>

Universal constructor - accepts hex, string, or bytes

###### Parameters

###### input

Hex string, UTF-8 string, or Uint8Array

`string` | `Uint8Array`\<`ArrayBufferLike`\>

###### Returns

`Promise`\<[`Keccak256Hash`](index/index.mdx#keccak256hash)\>

32-byte hash

###### Throws

Error if native operation fails

##### fromHex()

> **fromHex**: (`hex`) => `Promise`\<[`Keccak256Hash`](index/index.mdx#keccak256hash)\> = `hashHex`

Hash hex string with Keccak-256 using native implementation

###### Parameters

###### hex

`string`

Hex string to hash

###### Returns

`Promise`\<[`Keccak256Hash`](index/index.mdx#keccak256hash)\>

32-byte hash

###### Throws

Error if native operation fails

##### fromString()

> **fromString**: (`str`) => `Promise`\<[`Keccak256Hash`](index/index.mdx#keccak256hash)\> = `hashString`

Hash UTF-8 string with Keccak-256 using native implementation

###### Parameters

###### str

`string`

String to hash

###### Returns

`Promise`\<[`Keccak256Hash`](index/index.mdx#keccak256hash)\>

32-byte hash

###### Throws

Error if native operation fails

##### hash()

> **hash**: (`data`) => `Promise`\<[`Keccak256Hash`](index/index.mdx#keccak256hash)\>

Hash data with Keccak-256 using native implementation

###### Parameters

###### data

`Uint8Array`

Data to hash

###### Returns

`Promise`\<[`Keccak256Hash`](index/index.mdx#keccak256hash)\>

32-byte hash

###### Throws

Error if native operation fails

##### hashHex()

> **hashHex**: (`hex`) => `Promise`\<[`Keccak256Hash`](index/index.mdx#keccak256hash)\>

Hash hex string with Keccak-256 using native implementation

###### Parameters

###### hex

`string`

Hex string to hash

###### Returns

`Promise`\<[`Keccak256Hash`](index/index.mdx#keccak256hash)\>

32-byte hash

###### Throws

Error if native operation fails

##### hashString()

> **hashString**: (`str`) => `Promise`\<[`Keccak256Hash`](index/index.mdx#keccak256hash)\>

Hash UTF-8 string with Keccak-256 using native implementation

###### Parameters

###### str

`string`

String to hash

###### Returns

`Promise`\<[`Keccak256Hash`](index/index.mdx#keccak256hash)\>

32-byte hash

###### Throws

Error if native operation fails

##### hashSync()

> **hashSync**: (`data`) => [`Keccak256Hash`](index/index.mdx#keccak256hash)

Synchronous hash (for backward compatibility)
Throws if native library not loaded

###### Parameters

###### data

`Uint8Array`

###### Returns

[`Keccak256Hash`](index/index.mdx#keccak256hash)

##### RATE

> **RATE**: `number` = `136`

##### selector()

> **selector**: (`signature`) => `Promise`\<`string`\>

Compute function selector (first 4 bytes of keccak256)

###### Parameters

###### signature

`string`

Function signature (e.g., "transfer(address,uint256)")

###### Returns

`Promise`\<`string`\>

First 4 bytes of hash as hex string

##### STATE\_SIZE

> **STATE\_SIZE**: `number` = `200`

##### topic()

> **topic**: (`signature`) => `Promise`\<[`Keccak256Hash`](index/index.mdx#keccak256hash)\>

Compute event topic hash

###### Parameters

###### signature

`string`

Event signature (e.g., "Transfer(address,address,uint256)")

###### Returns

`Promise`\<[`Keccak256Hash`](index/index.mdx#keccak256hash)\>

32-byte topic hash

***

### Keccak256HashNative

> `const` **Keccak256HashNative**: (`input`) => `Promise`\<[`Keccak256Hash`](index/index.mdx#keccak256hash)\> & `object`

Defined in: [src/crypto/Keccak256/Keccak256.native.ts:134](https://github.com/evmts/voltaire/blob/bd6ec34405c15ad8cd51d11579d495dc53813482/src/crypto/Keccak256/Keccak256.native.ts#L134)

Native Keccak256 namespace object

#### Type Declaration

##### DIGEST\_SIZE

> **DIGEST\_SIZE**: `number` = `32`

##### from()

> **from**: (`input`) => `Promise`\<[`Keccak256Hash`](index/index.mdx#keccak256hash)\>

Universal constructor - accepts hex, string, or bytes

###### Parameters

###### input

Hex string, UTF-8 string, or Uint8Array

`string` | `Uint8Array`\<`ArrayBufferLike`\>

###### Returns

`Promise`\<[`Keccak256Hash`](index/index.mdx#keccak256hash)\>

32-byte hash

###### Throws

Error if native operation fails

##### fromHex()

> **fromHex**: (`hex`) => `Promise`\<[`Keccak256Hash`](index/index.mdx#keccak256hash)\> = `hashHex`

Hash hex string with Keccak-256 using native implementation

###### Parameters

###### hex

`string`

Hex string to hash

###### Returns

`Promise`\<[`Keccak256Hash`](index/index.mdx#keccak256hash)\>

32-byte hash

###### Throws

Error if native operation fails

##### fromString()

> **fromString**: (`str`) => `Promise`\<[`Keccak256Hash`](index/index.mdx#keccak256hash)\> = `hashString`

Hash UTF-8 string with Keccak-256 using native implementation

###### Parameters

###### str

`string`

String to hash

###### Returns

`Promise`\<[`Keccak256Hash`](index/index.mdx#keccak256hash)\>

32-byte hash

###### Throws

Error if native operation fails

##### hash()

> **hash**: (`data`) => `Promise`\<[`Keccak256Hash`](index/index.mdx#keccak256hash)\>

Hash data with Keccak-256 using native implementation

###### Parameters

###### data

`Uint8Array`

Data to hash

###### Returns

`Promise`\<[`Keccak256Hash`](index/index.mdx#keccak256hash)\>

32-byte hash

###### Throws

Error if native operation fails

##### hashHex()

> **hashHex**: (`hex`) => `Promise`\<[`Keccak256Hash`](index/index.mdx#keccak256hash)\>

Hash hex string with Keccak-256 using native implementation

###### Parameters

###### hex

`string`

Hex string to hash

###### Returns

`Promise`\<[`Keccak256Hash`](index/index.mdx#keccak256hash)\>

32-byte hash

###### Throws

Error if native operation fails

##### hashString()

> **hashString**: (`str`) => `Promise`\<[`Keccak256Hash`](index/index.mdx#keccak256hash)\>

Hash UTF-8 string with Keccak-256 using native implementation

###### Parameters

###### str

`string`

String to hash

###### Returns

`Promise`\<[`Keccak256Hash`](index/index.mdx#keccak256hash)\>

32-byte hash

###### Throws

Error if native operation fails

##### hashSync()

> **hashSync**: (`data`) => [`Keccak256Hash`](index/index.mdx#keccak256hash)

Synchronous hash (for backward compatibility)
Throws if native library not loaded

###### Parameters

###### data

`Uint8Array`

###### Returns

[`Keccak256Hash`](index/index.mdx#keccak256hash)

##### RATE

> **RATE**: `number` = `136`

##### selector()

> **selector**: (`signature`) => `Promise`\<`string`\>

Compute function selector (first 4 bytes of keccak256)

###### Parameters

###### signature

`string`

Function signature (e.g., "transfer(address,uint256)")

###### Returns

`Promise`\<`string`\>

First 4 bytes of hash as hex string

##### STATE\_SIZE

> **STATE\_SIZE**: `number` = `200`

##### topic()

> **topic**: (`signature`) => `Promise`\<[`Keccak256Hash`](index/index.mdx#keccak256hash)\>

Compute event topic hash

###### Parameters

###### signature

`string`

Event signature (e.g., "Transfer(address,address,uint256)")

###### Returns

`Promise`\<[`Keccak256Hash`](index/index.mdx#keccak256hash)\>

32-byte topic hash

***

### nativeAPI

> `const` **nativeAPI**: `object`

Defined in: [src/native/index.ts:376](https://github.com/evmts/voltaire/blob/bd6ec34405c15ad8cd51d11579d495dc53813482/src/native/index.ts#L376)

Native API object - satisfies VoltaireAPI interface
This ensures compile-time errors if the native API doesn't have all required namespaces.

Note: The actual Keccak256 export is the native async version from Keccak256.native.js,
but we use JS Keccak256 here for type checking since native methods are async.

#### Type Declaration

##### Abi

> **Abi**: *typeof* [`Abi`](primitives/Abi/index.mdx#abi)

##### AccessList

> **AccessList**: `object`

Namespace for AccessList operations

###### AccessList.ADDRESS\_COST

> **ADDRESS\_COST**: `bigint`

Gas cost per address in access list (EIP-2930)

###### AccessList.addressCount()

> **addressCount**: (`list`) => `number`

###### Parameters

###### list

[`BrandedAccessList`](primitives/AccessList.mdx#brandedaccesslist)

###### Returns

`number`

###### AccessList.assertValid()

> **assertValid**: (`list`) => `void`

###### Parameters

###### list

[`BrandedAccessList`](primitives/AccessList.mdx#brandedaccesslist)

###### Returns

`void`

###### AccessList.COLD\_ACCOUNT\_ACCESS\_COST

> **COLD\_ACCOUNT\_ACCESS\_COST**: `bigint`

Cold account access cost (pre-EIP-2930)

###### AccessList.COLD\_STORAGE\_ACCESS\_COST

> **COLD\_STORAGE\_ACCESS\_COST**: `bigint`

Cold storage access cost (pre-EIP-2930)

###### AccessList.create()

> **create**: () => [`BrandedAccessList`](primitives/AccessList.mdx#brandedaccesslist)

###### Returns

[`BrandedAccessList`](primitives/AccessList.mdx#brandedaccesslist)

###### AccessList.deduplicate()

> **deduplicate**: (`list`) => [`BrandedAccessList`](primitives/AccessList.mdx#brandedaccesslist)

###### Parameters

###### list

[`BrandedAccessList`](primitives/AccessList.mdx#brandedaccesslist)

###### Returns

[`BrandedAccessList`](primitives/AccessList.mdx#brandedaccesslist)

###### AccessList.from()

> **from**: (`value`) => [`BrandedAccessList`](primitives/AccessList.mdx#brandedaccesslist)

###### Parameters

###### value

`Uint8Array`\<`ArrayBufferLike`\> | readonly [`Item`](primitives/AccessList.mdx#item)[]

###### Returns

[`BrandedAccessList`](primitives/AccessList.mdx#brandedaccesslist)

###### AccessList.fromBytes()

> **fromBytes**: (`bytes`) => [`BrandedAccessList`](primitives/AccessList.mdx#brandedaccesslist)

###### Parameters

###### bytes

`Uint8Array`

###### Returns

[`BrandedAccessList`](primitives/AccessList.mdx#brandedaccesslist)

###### AccessList.gasCost()

> **gasCost**: (`list`) => `bigint`

###### Parameters

###### list

[`BrandedAccessList`](primitives/AccessList.mdx#brandedaccesslist)

###### Returns

`bigint`

###### AccessList.gasSavings()

> **gasSavings**: (`list`) => `bigint`

###### Parameters

###### list

[`BrandedAccessList`](primitives/AccessList.mdx#brandedaccesslist)

###### Returns

`bigint`

###### AccessList.hasSavings()

> **hasSavings**: (`list`) => `boolean`

###### Parameters

###### list

[`BrandedAccessList`](primitives/AccessList.mdx#brandedaccesslist)

###### Returns

`boolean`

###### AccessList.includesAddress()

> **includesAddress**: (`list`, `address`) => `boolean`

###### Parameters

###### list

[`BrandedAccessList`](primitives/AccessList.mdx#brandedaccesslist)

###### address

[`AddressType`](primitives/Address.mdx#addresstype)

###### Returns

`boolean`

###### AccessList.includesStorageKey()

> **includesStorageKey**: (`list`, `address`, `storageKey`) => `boolean`

###### Parameters

###### list

[`BrandedAccessList`](primitives/AccessList.mdx#brandedaccesslist)

###### address

[`AddressType`](primitives/Address.mdx#addresstype)

###### storageKey

[`HashType`](index/namespaces/HashType.mdx#hashtype)

###### Returns

`boolean`

###### AccessList.is()

> **is**: (`value`) => `value is BrandedAccessList`

###### Parameters

###### value

`unknown`

###### Returns

`value is BrandedAccessList`

###### AccessList.isEmpty()

> **isEmpty**: (`list`) => `boolean`

###### Parameters

###### list

[`BrandedAccessList`](primitives/AccessList.mdx#brandedaccesslist)

###### Returns

`boolean`

###### AccessList.isItem()

> **isItem**: (`value`) => `value is Item`

###### Parameters

###### value

`unknown`

###### Returns

`value is Item`

###### AccessList.keysFor()

> **keysFor**: (`list`, `address`) => readonly [`HashType`](index/namespaces/HashType.mdx#hashtype)[] \| `undefined`

###### Parameters

###### list

[`BrandedAccessList`](primitives/AccessList.mdx#brandedaccesslist)

###### address

[`AddressType`](primitives/Address.mdx#addresstype)

###### Returns

readonly [`HashType`](index/namespaces/HashType.mdx#hashtype)[] \| `undefined`

###### AccessList.merge()

> **merge**: (...`accessLists`) => [`BrandedAccessList`](primitives/AccessList.mdx#brandedaccesslist)

###### Parameters

###### accessLists

...[`BrandedAccessList`](primitives/AccessList.mdx#brandedaccesslist)[]

###### Returns

[`BrandedAccessList`](primitives/AccessList.mdx#brandedaccesslist)

###### AccessList.STORAGE\_KEY\_COST

> **STORAGE\_KEY\_COST**: `bigint`

Gas cost per storage key in access list (EIP-2930)

###### AccessList.storageKeyCount()

> **storageKeyCount**: (`list`) => `number`

###### Parameters

###### list

[`BrandedAccessList`](primitives/AccessList.mdx#brandedaccesslist)

###### Returns

`number`

###### AccessList.toBytes()

> **toBytes**: (`list`) => `Uint8Array`

###### Parameters

###### list

[`BrandedAccessList`](primitives/AccessList.mdx#brandedaccesslist)

###### Returns

`Uint8Array`

###### AccessList.WARM\_STORAGE\_ACCESS\_COST

> **WARM\_STORAGE\_ACCESS\_COST**: `bigint`

Warm storage access cost (post-EIP-2929)

###### AccessList.withAddress()

> **withAddress**: (`list`, `address`) => [`BrandedAccessList`](primitives/AccessList.mdx#brandedaccesslist)

###### Parameters

###### list

[`BrandedAccessList`](primitives/AccessList.mdx#brandedaccesslist)

###### address

[`AddressType`](primitives/Address.mdx#addresstype)

###### Returns

[`BrandedAccessList`](primitives/AccessList.mdx#brandedaccesslist)

###### AccessList.withStorageKey()

> **withStorageKey**: (`list`, `address`, `storageKey`) => [`BrandedAccessList`](primitives/AccessList.mdx#brandedaccesslist)

###### Parameters

###### list

[`BrandedAccessList`](primitives/AccessList.mdx#brandedaccesslist)

###### address

[`AddressType`](primitives/Address.mdx#addresstype)

###### storageKey

[`HashType`](index/namespaces/HashType.mdx#hashtype)

###### Returns

[`BrandedAccessList`](primitives/AccessList.mdx#brandedaccesslist)

##### Address

> **Address**: *typeof* [`Address`](primitives/Address.mdx#address)

##### ~~Blake2~~

> **Blake2**: (`input`, `outputLength?`) => [`Blake2Hash`](index/index.mdx#blake2hash) & `object`

###### Type Declaration

###### ~~from()~~

> **from**: (`input`, `outputLength?`) => [`Blake2Hash`](index/index.mdx#blake2hash)

Hash input with BLAKE2b (constructor pattern)

Auto-detects input type and hashes accordingly:
- Uint8Array: hash directly
- string: UTF-8 encode then hash

###### Parameters

###### input

Data to hash

`string` | `Uint8Array`\<`ArrayBufferLike`\>

###### outputLength?

`number` = `64`

Output length in bytes (1-64, default 64)

###### Returns

[`Blake2Hash`](index/index.mdx#blake2hash)

BLAKE2b hash

###### See

https://voltaire.tevm.sh/crypto/blake2 for crypto documentation

###### Since

0.0.0

###### Throws

If outputLength is invalid

###### Example

```javascript
import { Blake2Hash } from './crypto/Blake2/index.js';

const hash1 = Blake2Hash.from("hello");              // String, 64 bytes
const hash2 = Blake2Hash.from("hello", 32);          // String, 32 bytes
const hash3 = Blake2Hash.from(uint8array);           // Bytes, 64 bytes
const hash4 = Blake2Hash.from(uint8array, 48);       // Bytes, 48 bytes
```

###### ~~fromString()~~

> **fromString**: (`str`, `outputLength?`) => [`Blake2Hash`](index/index.mdx#blake2hash) = `hashString`

Hash string with BLAKE2b (convenience function)

###### Parameters

###### str

`string`

Input string to hash

###### outputLength?

`number` = `64`

Output length in bytes (1-64, default 64)

###### Returns

[`Blake2Hash`](index/index.mdx#blake2hash)

BLAKE2b hash

###### See

https://voltaire.tevm.sh/crypto for crypto documentation

###### Since

0.0.0

###### Throws

If outputLength is invalid

###### Example

```javascript
import * as Blake2 from './crypto/Blake2/index.js';
const hash = Blake2.hashString("hello world");
const hash48 = Blake2.hashString("hello world", 48);
```

###### ~~hash()~~

> **hash**: (`data`, `outputLength?`) => [`Blake2Hash`](index/index.mdx#blake2hash)

Hash data with BLAKE2b

###### Parameters

###### data

Input data to hash (Uint8Array or string)

`string` | `Uint8Array`\<`ArrayBufferLike`\>

###### outputLength?

`number` = `64`

Output length in bytes (1-64, default 64)

###### Returns

[`Blake2Hash`](index/index.mdx#blake2hash)

BLAKE2b hash

###### See

https://voltaire.tevm.sh/crypto for crypto documentation

###### Since

0.0.0

###### Throws

If outputLength is invalid

###### Example

```javascript
import * as Blake2 from './crypto/Blake2/index.js';
const hash = Blake2.hash(new Uint8Array([1, 2, 3]));
const hash32 = Blake2.hash("hello", 32);
```

###### ~~hashString()~~

> **hashString**: (`str`, `outputLength?`) => [`Blake2Hash`](index/index.mdx#blake2hash)

Hash string with BLAKE2b (convenience function)

###### Parameters

###### str

`string`

Input string to hash

###### outputLength?

`number` = `64`

Output length in bytes (1-64, default 64)

###### Returns

[`Blake2Hash`](index/index.mdx#blake2hash)

BLAKE2b hash

###### See

https://voltaire.tevm.sh/crypto for crypto documentation

###### Since

0.0.0

###### Throws

If outputLength is invalid

###### Example

```javascript
import * as Blake2 from './crypto/Blake2/index.js';
const hash = Blake2.hashString("hello world");
const hash48 = Blake2.hashString("hello world", 48);
```

###### ~~SIZE~~

> **SIZE**: `number`

###### Deprecated

Use Blake2Hash instead
Blake2 alias maintained for backward compatibility

##### Blob

> **Blob**: *typeof* [`Blob`](primitives/Blob.mdx#blob)

##### BloomFilter

> **BloomFilter**: *typeof* [`BloomFilter`](primitives/BloomFilter.mdx#bloomfilter)

##### Bls12381

> **Bls12381**: `object`

Bls12381 main export

###### Example

```javascript
import { Bls12381 } from './crypto/Bls12381/index.js';

// Generate keypair
const privateKey = Bls12381.randomPrivateKey();
const publicKey = Bls12381.derivePublicKey(privateKey);

// Sign and verify
const message = new TextEncoder().encode('Hello');
const signature = Bls12381.sign(message, privateKey);
const isValid = Bls12381.verify(signature, message, publicKey);
```

###### Bls12381.aggregate()

> **aggregate**: (`signatures`) => `Uint8Array`\<`ArrayBufferLike`\>

Aggregate multiple BLS signatures into one

The aggregated signature can be verified against an aggregated public key
(when all signers signed the same message) or via batch verification
(when signers signed different messages).

###### Parameters

###### signatures

`Uint8Array`\<`ArrayBufferLike`\>[]

Array of compressed G1 signatures (48 bytes each)

###### Returns

`Uint8Array`\<`ArrayBufferLike`\>

Aggregated signature (48 bytes compressed G1)

###### Throws

If aggregation fails or no signatures provided

###### Example

```javascript
import { Bls12381 } from './crypto/Bls12381/index.js';

const message = new TextEncoder().encode('Vote for proposal');

const pk1 = Bls12381.randomPrivateKey();
const pk2 = Bls12381.randomPrivateKey();

const sig1 = Bls12381.sign(message, pk1);
const sig2 = Bls12381.sign(message, pk2);

const aggSig = Bls12381.aggregate([sig1, sig2]);
```

###### Bls12381.aggregatePublicKeys()

> **aggregatePublicKeys**: (`publicKeys`) => `Uint8Array`\<`ArrayBufferLike`\>

Aggregate multiple public keys into one

Used when multiple signers sign the same message and you want
to verify against a single aggregated public key.

###### Parameters

###### publicKeys

`Uint8Array`\<`ArrayBufferLike`\>[]

Array of compressed G2 public keys (96 bytes each)

###### Returns

`Uint8Array`\<`ArrayBufferLike`\>

Aggregated public key (96 bytes compressed G2)

###### Throws

If aggregation fails or no public keys provided

###### Example

```javascript
import { Bls12381 } from './crypto/Bls12381/index.js';

const pk1 = Bls12381.randomPrivateKey();
const pk2 = Bls12381.randomPrivateKey();

const pubKey1 = Bls12381.derivePublicKey(pk1);
const pubKey2 = Bls12381.derivePublicKey(pk2);

const aggPubKey = Bls12381.aggregatePublicKeys([pubKey1, pubKey2]);
```

###### Bls12381.aggregateVerify()

> **aggregateVerify**: (`aggregatedSignature`, `message`, `publicKeys`) => `boolean`

Verify an aggregated signature where all signers signed the same message

This is the most common case in Ethereum consensus - multiple validators
sign the same block/attestation.

###### Parameters

###### aggregatedSignature

`Uint8Array`\<`ArrayBufferLike`\>

Aggregated signature (96 bytes)

###### message

`Uint8Array`\<`ArrayBufferLike`\>

The message that was signed by all parties

###### publicKeys

`Uint8Array`\<`ArrayBufferLike`\>[]

Public keys of all signers (48 bytes each)

###### Returns

`boolean`

True if the aggregated signature is valid

###### Example

```javascript
import { Bls12381 } from './crypto/Bls12381/index.js';

const message = new TextEncoder().encode('Block attestation');

const pk1 = Bls12381.randomPrivateKey();
const pk2 = Bls12381.randomPrivateKey();
const pubKey1 = Bls12381.derivePublicKey(pk1);
const pubKey2 = Bls12381.derivePublicKey(pk2);

const sig1 = Bls12381.sign(message, pk1);
const sig2 = Bls12381.sign(message, pk2);
const aggSig = Bls12381.aggregate([sig1, sig2]);

const isValid = Bls12381.aggregateVerify(aggSig, message, [pubKey1, pubKey2]);
console.log(isValid); // true
```

###### Bls12381.batchVerify()

> **batchVerify**: (`aggregatedSignature`, `messages`, `publicKeys`) => `boolean`

Verify an aggregated signature where each signer signed a different message

Uses multi-pairing verification: product of e(pk_i, H(msg_i)) == e(G1, aggSig)

###### Parameters

###### aggregatedSignature

`Uint8Array`\<`ArrayBufferLike`\>

Aggregated signature (96 bytes)

###### messages

`Uint8Array`\<`ArrayBufferLike`\>[]

Messages that were signed (one per signer)

###### publicKeys

`Uint8Array`\<`ArrayBufferLike`\>[]

Public keys (one per signer, same order as messages)

###### Returns

`boolean`

True if the aggregated signature is valid

###### Throws

If messages and publicKeys have different lengths

###### Example

```javascript
import { Bls12381 } from './crypto/Bls12381/index.js';

const pk1 = Bls12381.randomPrivateKey();
const pk2 = Bls12381.randomPrivateKey();
const pubKey1 = Bls12381.derivePublicKey(pk1);
const pubKey2 = Bls12381.derivePublicKey(pk2);

const msg1 = new TextEncoder().encode('Message 1');
const msg2 = new TextEncoder().encode('Message 2');

const sig1 = Bls12381.sign(msg1, pk1);
const sig2 = Bls12381.sign(msg2, pk2);
const aggSig = Bls12381.aggregate([sig1, sig2]);

const isValid = Bls12381.batchVerify(aggSig, [msg1, msg2], [pubKey1, pubKey2]);
console.log(isValid); // true
```

###### Bls12381.derivePublicKey()

> **derivePublicKey**: (`privateKey`) => `Uint8Array`\<`ArrayBufferLike`\>

Derive a BLS12-381 public key from a private key

Public key = privateKey * G2_generator

###### Parameters

###### privateKey

`Uint8Array`\<`ArrayBufferLike`\>

32-byte private key (scalar in Fr)

###### Returns

`Uint8Array`\<`ArrayBufferLike`\>

Compressed G2 public key (96 bytes)

###### Throws

If private key is invalid

###### Example

```javascript
import { Bls12381 } from './crypto/Bls12381/index.js';

const privateKey = Bls12381.randomPrivateKey();
const publicKey = Bls12381.derivePublicKey(privateKey);
console.log(publicKey.length); // 96
```

###### Bls12381.derivePublicKeyPoint()

> **derivePublicKeyPoint**: (`privateKey`) => [`Bls12381G1PointType`](index/index.mdx#bls12381g1pointtype)

Derive a BLS12-381 public key as a G1 point (uncompressed)

###### Parameters

###### privateKey

`Uint8Array`\<`ArrayBufferLike`\>

32-byte private key

###### Returns

[`Bls12381G1PointType`](index/index.mdx#bls12381g1pointtype)

Public key as G1 point

###### Throws

If private key is invalid

###### Bls12381.fastAggregateVerify()

> **fastAggregateVerify**: (`aggregatedSignature`, `message`, `aggregatedPublicKey`) => `boolean`

Fast aggregate verify (same message case)

Optimized for the common case where all signers signed the same message.
This is faster than aggregateVerify when you already have the aggregated public key.

###### Parameters

###### aggregatedSignature

`Uint8Array`\<`ArrayBufferLike`\>

Aggregated signature (96 bytes)

###### message

`Uint8Array`\<`ArrayBufferLike`\>

The message that was signed

###### aggregatedPublicKey

`Uint8Array`\<`ArrayBufferLike`\>

Pre-computed aggregated public key (48 bytes)

###### Returns

`boolean`

True if valid

###### Bls12381.Fp

> **Fp**: [`Fp`](crypto/Bls12381/namespaces/Fp.mdx)

###### Bls12381.Fp2

> **Fp2**: [`Fp2`](crypto/Bls12381/namespaces/Fp2.mdx)

###### Bls12381.Fr

> **Fr**: [`Fr`](crypto/Bls12381/namespaces/Fr.mdx)

###### Bls12381.G1

> **G1**: [`G1`](crypto/Bls12381/namespaces/G1.mdx)

###### Bls12381.G2

> **G2**: [`G2`](crypto/Bls12381/namespaces/G2.mdx)

###### Bls12381.isValidPrivateKey()

> **isValidPrivateKey**: (`privateKey`) => `boolean`

Check if a private key is valid

A valid private key must be:
- 32 bytes
- Non-zero
- Less than the curve order (Fr modulus)

###### Parameters

###### privateKey

`Uint8Array`\<`ArrayBufferLike`\>

Private key to validate

###### Returns

`boolean`

True if valid

###### Example

```javascript
import { Bls12381 } from './crypto/Bls12381/index.js';

const pk = Bls12381.randomPrivateKey();
console.log(Bls12381.isValidPrivateKey(pk)); // true

const invalid = new Uint8Array(32); // all zeros
console.log(Bls12381.isValidPrivateKey(invalid)); // false
```

###### Bls12381.Pairing

> **Pairing**: [`Pairing`](crypto/Bls12381/namespaces/Pairing.mdx)

BLS12-381 Pairing Operations

Optimal Ate pairing implementation for BLS12-381.
e: G1 x G2 -> GT

NOTE: Full pairing implementation requires Fp6, Fp12 tower extensions
and Miller loop computation. For production use, the native blst
library should be used via the Zig FFI bindings.

This module provides the interface and simplified implementations
for testing and educational purposes.

###### See

https://hackmd.io/@benjaminion/bls12-381 for pairing details

###### Since

0.0.0

###### Bls12381.randomPrivateKey()

> **randomPrivateKey**: () => `Uint8Array`\<`ArrayBufferLike`\>

Generate a random BLS12-381 private key

Uses cryptographically secure random number generation.
The key is guaranteed to be valid (non-zero and less than curve order).

###### Returns

`Uint8Array`\<`ArrayBufferLike`\>

32-byte private key

###### Example

```javascript
import { Bls12381 } from './crypto/Bls12381/index.js';

const privateKey = Bls12381.randomPrivateKey();
const publicKey = Bls12381.derivePublicKey(privateKey);
```

###### Bls12381.sign()

> **sign**: (`message`, `privateKey`) => `Uint8Array`\<`ArrayBufferLike`\>

Sign a message using BLS12-381

Uses the Ethereum consensus "short signatures" scheme:
- Signature = privateKey * H(message) where H maps to G1
- Signatures are 48 bytes (compressed G1 point)

###### Parameters

###### message

`Uint8Array`\<`ArrayBufferLike`\>

Message to sign

###### privateKey

`Uint8Array`\<`ArrayBufferLike`\>

32-byte private key (scalar in Fr)

###### Returns

`Uint8Array`\<`ArrayBufferLike`\>

Signature as compressed G1 point (48 bytes)

###### Throws

If private key is invalid

###### Throws

If signing fails

###### Example

```javascript
import { Bls12381 } from './crypto/Bls12381/index.js';

const privateKey = Bls12381.randomPrivateKey();
const message = new TextEncoder().encode('Hello, Ethereum!');
const signature = Bls12381.sign(message, privateKey);
```

###### Bls12381.signPoint()

> **signPoint**: (`messagePoint`, `privateKey`) => [`Bls12381G2PointType`](index/index.mdx#bls12381g2pointtype)

Sign a pre-hashed message (G2 point) using BLS12-381

For advanced use when you have already hashed the message to G2.

###### Parameters

###### messagePoint

[`Bls12381G2PointType`](index/index.mdx#bls12381g2pointtype)

Message as G2 point

###### privateKey

`Uint8Array`\<`ArrayBufferLike`\>

32-byte private key (scalar in Fr)

###### Returns

[`Bls12381G2PointType`](index/index.mdx#bls12381g2pointtype)

Signature as G2 point (projective)

###### Throws

If private key is invalid

###### Throws

If signing fails

###### Bls12381.verify()

> **verify**: (`signature`, `message`, `publicKey`) => `boolean`

Verify a BLS12-381 signature

Uses pairing check for verification.

###### Parameters

###### signature

`Uint8Array`\<`ArrayBufferLike`\>

Compressed G1 signature (48 bytes)

###### message

`Uint8Array`\<`ArrayBufferLike`\>

Original message that was signed

###### publicKey

`Uint8Array`\<`ArrayBufferLike`\>

Compressed G2 public key (96 bytes)

###### Returns

`boolean`

True if signature is valid

###### Throws

If verification fails due to invalid inputs

###### Example

```javascript
import { Bls12381 } from './crypto/Bls12381/index.js';

const privateKey = Bls12381.randomPrivateKey();
const publicKey = Bls12381.derivePublicKey(privateKey);
const message = new TextEncoder().encode('Hello!');
const signature = Bls12381.sign(message, privateKey);

const isValid = Bls12381.verify(signature, message, publicKey);
console.log(isValid); // true
```

###### Bls12381.verifyPoint()

> **verifyPoint**: (`signaturePoint`, `messagePoint`, `publicKeyPoint`) => `boolean`

Verify a BLS signature with pre-computed points (advanced)

For use when you have already deserialized the points.

###### Parameters

###### signaturePoint

[`Bls12381G2PointType`](index/index.mdx#bls12381g2pointtype)

Signature as G2 point

###### messagePoint

[`Bls12381G2PointType`](index/index.mdx#bls12381g2pointtype)

Message hash as G2 point

###### publicKeyPoint

[`Bls12381G1PointType`](index/index.mdx#bls12381g1pointtype)

Public key as G1 point

###### Returns

`boolean`

True if signature is valid

##### BN254

> **BN254**: `object`

BN254 main export

###### BN254.deserializeG1()

> **deserializeG1**: (`bytes`) => `G1PointType`

Deserialize G1 point from bytes

###### Parameters

###### bytes

`Uint8Array`\<`ArrayBufferLike`\>

64-byte serialization

###### Returns

`G1PointType`

G1 point

###### See

https://voltaire.tevm.sh/crypto for BN254 cryptography documentation

###### Since

0.0.0

###### Throws

If bytes length is invalid (must be 64 bytes)

###### Example

```javascript
import { deserializeG1 } from './crypto/bn254/deserializeG1.js';
const bytes = new Uint8Array(64);
const point = deserializeG1(bytes);
```

###### BN254.deserializeG2()

> **deserializeG2**: (`bytes`) => `G2PointType`

Deserialize G2 point from bytes

###### Parameters

###### bytes

`Uint8Array`\<`ArrayBufferLike`\>

128-byte serialization

###### Returns

`G2PointType`

G2 point

###### See

https://voltaire.tevm.sh/crypto for BN254 cryptography documentation

###### Since

0.0.0

###### Throws

If bytes length is invalid (must be 128 bytes)

###### Example

```javascript
import { deserializeG2 } from './crypto/bn254/deserializeG2.js';
const bytes = new Uint8Array(128);
const point = deserializeG2(bytes);
```

###### BN254.Fp

> **Fp**: `__module`

###### BN254.Fp2

> **Fp2**: `__module`

###### BN254.Fr

> **Fr**: `__module`

###### BN254.G1

> **G1**: `__module`

###### BN254.G2

> **G2**: `__module`

###### BN254.Pairing

> **Pairing**: `__module`

###### BN254.serializeG1()

> **serializeG1**: (`point`) => `Uint8Array`\<`ArrayBufferLike`\>

Serialize G1 point to bytes (64 bytes: x || y)

###### Parameters

###### point

`G1PointType`

G1 point

###### Returns

`Uint8Array`\<`ArrayBufferLike`\>

64-byte serialization

###### See

https://voltaire.tevm.sh/crypto for BN254 cryptography documentation

###### Since

0.0.0

###### Throws

###### Example

```javascript
import { serializeG1 } from './crypto/bn254/serializeG1.js';
import * as G1 from './crypto/bn254/G1/index.js';
const point = G1.generator();
const bytes = serializeG1(point);
```

###### BN254.serializeG2()

> **serializeG2**: (`point`) => `Uint8Array`\<`ArrayBufferLike`\>

Serialize G2 point to bytes (128 bytes: x.c0 || x.c1 || y.c0 || y.c1)

###### Parameters

###### point

`G2PointType`

G2 point

###### Returns

`Uint8Array`\<`ArrayBufferLike`\>

128-byte serialization

###### See

https://voltaire.tevm.sh/crypto for BN254 cryptography documentation

###### Since

0.0.0

###### Throws

###### Example

```javascript
import { serializeG2 } from './crypto/bn254/serializeG2.js';
import * as G2 from './crypto/bn254/G2/index.js';
const point = G2.generator();
const bytes = serializeG2(point);
```

##### Bytecode

> **Bytecode**: *typeof* [`Bytecode`](primitives/Bytecode.mdx#bytecode)

##### Bytes

> **Bytes**: *typeof* [`Bytes`](index/index.mdx#bytes)

##### Bytes32

> **Bytes32**: *typeof* [`Bytes32`](index/namespaces/BrandedBytes32.mdx#bytes32)

##### Chain

> **Chain**: *typeof* [`Chain`](index/namespaces/BrandedChain.mdx#chain-1)

##### Ed25519

> **Ed25519**: `object`

Ed25519 Digital Signature Algorithm

Edwards-curve Digital Signature Algorithm (EdDSA) using Curve25519.
Fast, secure, and deterministic signatures without requiring a hash function.
Used in many modern protocols including SSH, TLS 1.3, and cryptocurrency.

###### Example

```typescript
import { Ed25519 } from './Ed25519/index.js';

// Generate keypair from seed
const seed = new Uint8Array(32); // Random seed
const keypair = Ed25519.keypairFromSeed(seed);

// Sign a message
const message = new TextEncoder().encode('Hello, world!');
const signature = Ed25519.sign(message, keypair.secretKey);

// Verify signature
const valid = Ed25519.verify(signature, message, keypair.publicKey);
```

###### Ed25519.derivePublicKey()

> **derivePublicKey**: (`secretKey`) => `PublicKey`

Derive Ed25519 public key from secret key.

###### Parameters

###### secretKey

`SecretKey`

32-byte Ed25519 secret key (seed)

###### Returns

`PublicKey`

32-byte Ed25519 public key

###### See

https://voltaire.tevm.sh/crypto for crypto documentation

###### Since

0.0.0

###### Throws

If secret key length is invalid or derivation fails

###### Example

```javascript
import * as Ed25519 from './crypto/Ed25519/index.js';
const secretKey = new Uint8Array(32); // Your secret key
const publicKey = Ed25519.derivePublicKey(secretKey);
```

###### Ed25519.keypairFromSeed()

> **keypairFromSeed**: (`seed`) => `object`

Generate Ed25519 keypair from seed deterministically.

###### Parameters

###### seed

`Seed`

32-byte seed for deterministic keypair generation

###### Returns

`object`

Object containing 32-byte secretKey and 32-byte publicKey

###### publicKey

> **publicKey**: `PublicKey`

###### secretKey

> **secretKey**: `SecretKey`

###### See

https://voltaire.tevm.sh/crypto for crypto documentation

###### Since

0.0.0

###### Throws

If seed length is not 32 bytes

###### Throws

If keypair generation fails

###### Example

```javascript
import * as Ed25519 from './crypto/Ed25519/index.js';
const seed = crypto.getRandomValues(new Uint8Array(32));
const keypair = Ed25519.keypairFromSeed(seed);
console.log(keypair.publicKey); // Uint8Array(32)
```

###### Ed25519.PUBLIC\_KEY\_SIZE

> **PUBLIC\_KEY\_SIZE**: `32`

Ed25519 public key size in bytes.

###### See

https://voltaire.tevm.sh/crypto for crypto documentation

###### Since

0.0.0

###### Example

```javascript
import { PUBLIC_KEY_SIZE } from './crypto/Ed25519/constants.js';
const publicKey = new Uint8Array(PUBLIC_KEY_SIZE);
```

###### Ed25519.SECRET\_KEY\_SIZE

> **SECRET\_KEY\_SIZE**: `32`

Ed25519 secret key size in bytes.

###### See

https://voltaire.tevm.sh/crypto for crypto documentation

###### Since

0.0.0

###### Example

```javascript
import { SECRET_KEY_SIZE } from './crypto/Ed25519/constants.js';
const secretKey = new Uint8Array(SECRET_KEY_SIZE);
```

###### Ed25519.SEED\_SIZE

> **SEED\_SIZE**: `32`

Ed25519 seed size in bytes.

###### See

https://voltaire.tevm.sh/crypto for crypto documentation

###### Since

0.0.0

###### Example

```javascript
import { SEED_SIZE } from './crypto/Ed25519/constants.js';
const seed = crypto.getRandomValues(new Uint8Array(SEED_SIZE));
```

###### Ed25519.sign()

> **sign**: (`message`, `secretKey`) => `Signature`

Sign message with Ed25519 secret key.

Produces deterministic signatures using EdDSA.

###### Parameters

###### message

`Uint8Array`\<`ArrayBufferLike`\>

Message bytes to sign (any length)

###### secretKey

`SecretKey`

32-byte Ed25519 secret key

###### Returns

`Signature`

64-byte Ed25519 signature

###### See

https://voltaire.tevm.sh/crypto for crypto documentation

###### Since

0.0.0

###### Throws

If secret key length is not 32 bytes

###### Throws

If signing operation fails

###### Example

```javascript
import * as Ed25519 from './crypto/Ed25519/index.js';
const message = new TextEncoder().encode('Hello, world!');
const signature = Ed25519.sign(message, secretKey);
```

###### Ed25519.SIGNATURE\_SIZE

> **SIGNATURE\_SIZE**: `64`

Ed25519 signature size in bytes.

###### See

https://voltaire.tevm.sh/crypto for crypto documentation

###### Since

0.0.0

###### Example

```javascript
import { SIGNATURE_SIZE } from './crypto/Ed25519/constants.js';
const signature = new Uint8Array(SIGNATURE_SIZE);
```

###### Ed25519.validatePublicKey()

> **validatePublicKey**: (`publicKey`) => `boolean`

Validate Ed25519 public key format and curve membership.

###### Parameters

###### publicKey

`PublicKey`

Ed25519 public key to validate

###### Returns

`boolean`

True if public key is valid and on curve, false otherwise

###### See

https://voltaire.tevm.sh/crypto for crypto documentation

###### Since

0.0.0

###### Throws

###### Example

```javascript
import * as Ed25519 from './crypto/Ed25519/index.js';
const isValid = Ed25519.validatePublicKey(publicKey);
if (!isValid) console.log('Invalid public key');
```

###### Ed25519.validateSecretKey()

> **validateSecretKey**: (`secretKey`) => `boolean`

Validate Ed25519 secret key format.

Checks length and attempts public key derivation.

###### Parameters

###### secretKey

`SecretKey`

Ed25519 secret key to validate

###### Returns

`boolean`

True if secret key is valid (32 bytes and can derive public key), false otherwise

###### See

https://voltaire.tevm.sh/crypto for crypto documentation

###### Since

0.0.0

###### Throws

###### Example

```javascript
import * as Ed25519 from './crypto/Ed25519/index.js';
const isValid = Ed25519.validateSecretKey(secretKey);
if (!isValid) console.log('Invalid secret key');
```

###### Ed25519.validateSeed()

> **validateSeed**: (`seed`) => `boolean`

Validate Ed25519 seed format.

Checks if seed has correct 32-byte length.

###### Parameters

###### seed

`Seed`

Ed25519 seed to validate

###### Returns

`boolean`

True if seed is exactly 32 bytes, false otherwise

###### See

https://voltaire.tevm.sh/crypto for crypto documentation

###### Since

0.0.0

###### Throws

###### Example

```javascript
import * as Ed25519 from './crypto/Ed25519/index.js';
const seed = crypto.getRandomValues(new Uint8Array(32));
const isValid = Ed25519.validateSeed(seed); // true
```

###### Ed25519.verify()

> **verify**: (`signature`, `message`, `publicKey`) => `boolean`

Verify Ed25519 signature.

Returns false on verification failure instead of throwing.

###### Parameters

###### signature

`Signature`

64-byte Ed25519 signature to verify

###### message

`Uint8Array`\<`ArrayBufferLike`\>

Original message bytes that were signed

###### publicKey

`PublicKey`

32-byte Ed25519 public key

###### Returns

`boolean`

True if signature is cryptographically valid, false otherwise

###### See

https://voltaire.tevm.sh/crypto for crypto documentation

###### Since

0.0.0

###### Throws

If public key length is not 32 bytes

###### Throws

If signature length is not 64 bytes

###### Example

```javascript
import * as Ed25519 from './crypto/Ed25519/index.js';
const valid = Ed25519.verify(signature, message, publicKey);
if (valid) console.log('Signature verified');
```

##### EIP712

> **EIP712**: `object`

EIP-712 Typed Data Signing

Complete implementation of EIP-712 typed structured data hashing and signing.

###### Example

```typescript
import { EIP712 } from './EIP712.js';

// Define typed data
const typedData = {
  domain: {
    name: 'MyApp',
    version: '1',
    chainId: 1n,
    verifyingContract: contractAddress,
  },
  types: {
    Person: [
      { name: 'name', type: 'string' },
      { name: 'wallet', type: 'address' },
    ],
    Mail: [
      { name: 'from', type: 'Person' },
      { name: 'to', type: 'Person' },
      { name: 'contents', type: 'string' },
    ],
  },
  primaryType: 'Mail',
  message: {
    from: { name: 'Alice', wallet: '0x...' },
    to: { name: 'Bob', wallet: '0x...' },
    contents: 'Hello!',
  },
};

// Hash typed data
const hash = EIP712.hashTypedData(typedData);

// Sign typed data
const signature = EIP712.signTypedData(typedData, privateKey);

// Verify signature
const valid = EIP712.verifyTypedData(signature, typedData, address);
```

###### EIP712.Domain

> **Domain**: `object`

###### EIP712.Domain.hash()

> **hash**: (`domain`) => [`HashType`](index/namespaces/HashType.mdx#hashtype) = `hashDomain`

###### Parameters

###### domain

[`Domain`](crypto/EIP712.mdx#domain)

###### Returns

[`HashType`](index/namespaces/HashType.mdx#hashtype)

###### EIP712.encodeData()

> **encodeData**: (`primaryType`, `data`, `types`) => `Uint8Array`

###### Parameters

###### primaryType

`string`

###### data

[`Message`](crypto/EIP712.mdx#message)

###### types

[`TypeDefinitions`](crypto/EIP712.mdx#typedefinitions)

###### Returns

`Uint8Array`

###### EIP712.EncodeData()

> **EncodeData**: (`deps`) => (`primaryType`, `data`, `types`) => `Uint8Array`

Factory: Encode struct data according to EIP-712.

###### Parameters

###### deps

Crypto dependencies

###### encodeValue

(`type`, `value`, `types`) => `Uint8Array`

Encode value function

###### hashType

(`primaryType`, `types`) => [`HashType`](index/namespaces/HashType.mdx#hashtype)

Hash type function

###### Returns

Function that encodes data

> (`primaryType`, `data`, `types`): `Uint8Array`

###### Parameters

###### primaryType

`string`

###### data

[`Message`](crypto/EIP712.mdx#message)

###### types

[`TypeDefinitions`](crypto/EIP712.mdx#typedefinitions)

###### Returns

`Uint8Array`

###### See

https://voltaire.tevm.sh/crypto for crypto documentation

###### Since

0.0.0

###### Throws

If primaryType is not found in types

###### Throws

If required field is missing from data

###### Example

```javascript
import { EncodeData } from './crypto/EIP712/encodeData.js';
import { HashType } from './hashType.js';
import { EncodeValue } from './encodeValue.js';
import { hash as keccak256 } from '../Keccak256/hash.js';
const hashType = HashType({ keccak256 });
const encodeValue = EncodeValue({ keccak256, hashStruct });
const encodeData = EncodeData({ hashType, encodeValue });
const types = { Person: [{ name: 'name', type: 'string' }, { name: 'wallet', type: 'address' }] };
const encoded = encodeData('Person', { name: 'Alice', wallet: '0x...' }, types);
```

###### EIP712.encodeType()

> **encodeType**: (`primaryType`, `types`) => `string`

Encode type string for EIP-712 hashing.

Produces type encoding like "Mail(Person from,Person to,string contents)Person(string name,address wallet)"

###### Parameters

###### primaryType

`string`

Primary type name to encode

###### types

[`TypeDefinitions`](crypto/EIP712.mdx#typedefinitions)

Type definitions mapping

###### Returns

`string`

Encoded type string with primary type followed by referenced types in alphabetical order

###### See

https://voltaire.tevm.sh/crypto for crypto documentation

###### Since

0.0.0

###### Throws

If primaryType or any referenced type is not found

###### Example

```javascript
import * as EIP712 from './crypto/EIP712/index.js';
const types = { Mail: [{ name: 'from', type: 'Person' }], Person: [{ name: 'name', type: 'string' }] };
const typeString = EIP712.encodeType('Mail', types);
// Returns: "Mail(Person from)Person(string name)"
```

###### EIP712.encodeValue()

> **encodeValue**: (`type`, `value`, `types`) => `Uint8Array`

###### Parameters

###### type

`string`

###### value

[`MessageValue`](crypto/EIP712.mdx#messagevalue)

###### types

[`TypeDefinitions`](crypto/EIP712.mdx#typedefinitions)

###### Returns

`Uint8Array`

###### EIP712.EncodeValue()

> **EncodeValue**: (`deps`) => (`type`, `value`, `types`) => `Uint8Array`

Factory: Encode single value to 32 bytes according to EIP-712.

Handles primitive types, arrays, strings, bytes, and custom structs.
Addresses must be pre-validated BrandedAddress types.

###### Parameters

###### deps

Crypto dependencies

###### hashStruct

(`type`, `data`, `types`) => [`HashType`](index/namespaces/HashType.mdx#hashtype)

Hash struct function

###### keccak256

(`data`) => `Uint8Array`

Keccak256 hash function

###### Returns

Function that encodes value

> (`type`, `value`, `types`): `Uint8Array`

###### Parameters

###### type

`string`

###### value

[`MessageValue`](crypto/EIP712.mdx#messagevalue)

###### types

[`TypeDefinitions`](crypto/EIP712.mdx#typedefinitions)

###### Returns

`Uint8Array`

###### See

https://voltaire.tevm.sh/crypto for crypto documentation

###### Since

0.0.0

###### Throws

If type is unsupported or value format is invalid

###### Example

```javascript
import { EncodeValue } from './crypto/EIP712/encodeValue.js';
import { hash as keccak256 } from '../Keccak256/hash.js';
import { HashStruct } from './hashStruct.js';
const hashStruct = HashStruct({ keccak256, encodeData });
const encodeValue = EncodeValue({ keccak256, hashStruct });
const encoded = encodeValue('uint256', 42n, types);
```

###### EIP712.format()

> **format**: (`typedData`) => `string`

Format typed data for human-readable display.

###### Parameters

###### typedData

[`TypedData`](crypto/EIP712.mdx#typeddata)

Typed data to format

###### Returns

`string`

Human-readable multi-line string representation

###### See

https://voltaire.tevm.sh/crypto for crypto documentation

###### Since

0.0.0

###### Throws

###### Example

```javascript
import * as EIP712 from './crypto/EIP712/index.js';
const formatted = EIP712.format(typedData);
console.log(formatted);
```

###### EIP712.HashDomain()

> **HashDomain**: (`deps`) => (`domain`) => [`HashType`](index/namespaces/HashType.mdx#hashtype)

Factory: Hash EIP-712 domain separator.

Only includes fields that are defined in the domain object.

###### Parameters

###### deps

Crypto dependencies

###### hashStruct

(`primaryType`, `data`, `types`) => [`HashType`](index/namespaces/HashType.mdx#hashtype)

Hash struct function

###### Returns

Function that hashes domain

> (`domain`): [`HashType`](index/namespaces/HashType.mdx#hashtype)

###### Parameters

###### domain

[`Domain`](crypto/EIP712.mdx#domain)

###### Returns

[`HashType`](index/namespaces/HashType.mdx#hashtype)

###### See

https://voltaire.tevm.sh/crypto for crypto documentation

###### Since

0.0.0

###### Throws

If domain type encoding fails

###### Example

```javascript
import { Hash as HashDomain } from './crypto/EIP712/Domain/hash.js';
import { HashStruct } from '../hashStruct.js';
import { hash as keccak256 } from '../../Keccak256/hash.js';
const hashStruct = HashStruct({ keccak256, encodeData });
const hashDomain = HashDomain({ hashStruct });
const domain = { name: 'MyApp', version: '1', chainId: 1n };
const domainHash = hashDomain(domain);
```

###### EIP712.hashStruct()

> **hashStruct**: (`primaryType`, `data`, `types`) => [`HashType`](index/namespaces/HashType.mdx#hashtype)

###### Parameters

###### primaryType

`string`

###### data

[`Message`](crypto/EIP712.mdx#message)

###### types

[`TypeDefinitions`](crypto/EIP712.mdx#typedefinitions)

###### Returns

[`HashType`](index/namespaces/HashType.mdx#hashtype)

###### EIP712.HashStruct()

> **HashStruct**: (`deps`) => (`primaryType`, `data`, `types`) => [`HashType`](index/namespaces/HashType.mdx#hashtype)

Factory: Hash struct according to EIP-712 specification.

Computes keccak256 of the encoded struct data.

###### Parameters

###### deps

Crypto dependencies

###### encodeData

(`primaryType`, `data`, `types`) => `Uint8Array`

Encode data function

###### keccak256

(`data`) => `Uint8Array`

Keccak256 hash function

###### Returns

Function that hashes struct

> (`primaryType`, `data`, `types`): [`HashType`](index/namespaces/HashType.mdx#hashtype)

###### Parameters

###### primaryType

`string`

###### data

[`Message`](crypto/EIP712.mdx#message)

###### types

[`TypeDefinitions`](crypto/EIP712.mdx#typedefinitions)

###### Returns

[`HashType`](index/namespaces/HashType.mdx#hashtype)

###### See

https://voltaire.tevm.sh/crypto for crypto documentation

###### Since

0.0.0

###### Throws

If type is not found

###### Throws

If message data is invalid

###### Example

```javascript
import { HashStruct } from './crypto/EIP712/hashStruct.js';
import { hash as keccak256 } from '../Keccak256/hash.js';
import { EncodeData } from './encodeData.js';
const encodeData = EncodeData({ hashType, encodeValue });
const hashStruct = HashStruct({ keccak256, encodeData });
const types = { Person: [{ name: 'name', type: 'string' }] };
const hash = hashStruct('Person', { name: 'Alice' }, types);
```

###### EIP712.hashType()

> **hashType**: (`primaryType`, `types`) => [`HashType`](index/namespaces/HashType.mdx#hashtype)

###### Parameters

###### primaryType

`string`

###### types

[`TypeDefinitions`](crypto/EIP712.mdx#typedefinitions)

###### Returns

[`HashType`](index/namespaces/HashType.mdx#hashtype)

###### EIP712.HashType()

> **HashType**: (`deps`) => (`primaryType`, `types`) => [`HashType`](index/namespaces/HashType.mdx#hashtype)

Factory: Hash type string according to EIP-712.

Computes keccak256 of the encoded type string.

###### Parameters

###### deps

Crypto dependencies

###### keccak256

(`data`) => `Uint8Array`

Keccak256 hash function

###### Returns

Function that hashes type string

> (`primaryType`, `types`): [`HashType`](index/namespaces/HashType.mdx#hashtype)

###### Parameters

###### primaryType

`string`

###### types

[`TypeDefinitions`](crypto/EIP712.mdx#typedefinitions)

###### Returns

[`HashType`](index/namespaces/HashType.mdx#hashtype)

###### See

https://voltaire.tevm.sh/crypto for crypto documentation

###### Since

0.0.0

###### Throws

If type is not found

###### Example

```javascript
import { HashType } from './crypto/EIP712/hashType.js';
import { hash as keccak256 } from '../Keccak256/hash.js';
const hashType = HashType({ keccak256 });
const types = { Mail: [{ name: 'contents', type: 'string' }] };
const typeHash = hashType('Mail', types);
```

###### EIP712.hashTypedData()

> **hashTypedData**: (`typedData`) => [`HashType`](index/namespaces/HashType.mdx#hashtype)

###### Parameters

###### typedData

[`TypedData`](crypto/EIP712.mdx#typeddata)

###### Returns

[`HashType`](index/namespaces/HashType.mdx#hashtype)

###### EIP712.HashTypedData()

> **HashTypedData**: (`deps`) => (`typedData`) => [`HashType`](index/namespaces/HashType.mdx#hashtype)

Factory: Hash typed data according to EIP-712 specification.

Computes: keccak256("\x19\x01"  domainSeparator  hashStruct(message))

###### Parameters

###### deps

Crypto dependencies

###### hashDomain

(`domain`) => [`HashType`](index/namespaces/HashType.mdx#hashtype)

Hash domain function

###### hashStruct

(`primaryType`, `data`, `types`) => [`HashType`](index/namespaces/HashType.mdx#hashtype)

Hash struct function

###### keccak256

(`data`) => `Uint8Array`

Keccak256 hash function

###### Returns

Function that hashes typed data

> (`typedData`): [`HashType`](index/namespaces/HashType.mdx#hashtype)

###### Parameters

###### typedData

[`TypedData`](crypto/EIP712.mdx#typeddata)

###### Returns

[`HashType`](index/namespaces/HashType.mdx#hashtype)

###### See

https://voltaire.tevm.sh/crypto for crypto documentation

###### Since

0.0.0

###### Throws

If types are not found

###### Throws

If message data is invalid

###### Example

```javascript
import { HashTypedData } from './crypto/EIP712/hashTypedData.js';
import { hash as keccak256 } from '../Keccak256/hash.js';
import { Hash as HashDomain } from './Domain/hash.js';
import { HashStruct } from './hashStruct.js';
const hashDomain = HashDomain({ hashStruct });
const hashStruct = HashStruct({ keccak256, encodeData });
const hashTypedData = HashTypedData({ keccak256, hashDomain, hashStruct });
const hash = hashTypedData(typedData);
```

###### EIP712.recoverAddress()

> **recoverAddress**: (`signature`, `typedData`) => [`AddressType`](primitives/Address.mdx#addresstype)

###### Parameters

###### signature

[`Signature`](crypto/EIP712.mdx#signature)

###### typedData

[`TypedData`](crypto/EIP712.mdx#typeddata)

###### Returns

[`AddressType`](primitives/Address.mdx#addresstype)

###### EIP712.RecoverAddress()

> **RecoverAddress**: (`deps`) => (`signature`, `typedData`) => [`AddressType`](primitives/Address.mdx#addresstype)

Factory: Recover Ethereum address from EIP-712 typed data signature.

Uses ECDSA public key recovery to determine the signer's address.

###### Parameters

###### deps

Crypto dependencies

###### hashTypedData

(`typedData`) => [`HashType`](index/namespaces/HashType.mdx#hashtype)

Hash typed data function

###### keccak256

(`data`) => `Uint8Array`

Keccak256 hash function

###### recoverPublicKey

(`signature`, `hash`, `recoveryBit`) => `Uint8Array`

Secp256k1 public key recovery function

###### Returns

Function that recovers address

> (`signature`, `typedData`): [`AddressType`](primitives/Address.mdx#addresstype)

###### Parameters

###### signature

[`Signature`](crypto/EIP712.mdx#signature)

###### typedData

[`TypedData`](crypto/EIP712.mdx#typeddata)

###### Returns

[`AddressType`](primitives/Address.mdx#addresstype)

###### See

https://voltaire.tevm.sh/crypto for crypto documentation

###### Since

0.0.0

###### Throws

If signature recovery fails or public key format is invalid

###### Example

```javascript
import { RecoverAddress } from './crypto/EIP712/recoverAddress.js';
import { hash as keccak256 } from '../Keccak256/hash.js';
import { recoverPublicKey } from '../Secp256k1/recoverPublicKey.js';
import { HashTypedData } from './hashTypedData.js';
const hashTypedData = HashTypedData({ keccak256, hashDomain, hashStruct });
const recoverAddress = RecoverAddress({ keccak256, recoverPublicKey, hashTypedData });
const address = recoverAddress(signature, typedData);
```

###### EIP712.signTypedData()

> **signTypedData**: (`typedData`, `privateKey`) => [`Signature`](crypto/EIP712.mdx#signature)

###### Parameters

###### typedData

`any`

###### privateKey

`any`

###### Returns

[`Signature`](crypto/EIP712.mdx#signature)

###### EIP712.SignTypedData()

> **SignTypedData**: (`deps`) => (`typedData`, `privateKey`) => [`Signature`](crypto/EIP712.mdx#signature)

Factory: Sign EIP-712 typed data with ECDSA private key.

Produces a signature that can be verified against the signer's address.

###### Parameters

###### deps

Crypto dependencies

###### hashTypedData

(`typedData`) => [`HashType`](index/namespaces/HashType.mdx#hashtype)

Hash typed data function

###### sign

(`hash`, `privateKey`) => [`Signature`](crypto/EIP712.mdx#signature)

Secp256k1 sign function

###### Returns

Function that signs typed data

> (`typedData`, `privateKey`): [`Signature`](crypto/EIP712.mdx#signature)

###### Parameters

###### typedData

[`TypedData`](crypto/EIP712.mdx#typeddata)

###### privateKey

`Uint8Array`

###### Returns

[`Signature`](crypto/EIP712.mdx#signature)

###### See

https://voltaire.tevm.sh/crypto for crypto documentation

###### Since

0.0.0

###### Throws

If private key length is invalid or signing fails

###### Example

```javascript
import { SignTypedData } from './crypto/EIP712/signTypedData.js';
import { HashTypedData } from './hashTypedData.js';
import { sign } from '../Secp256k1/sign.js';
import { hash as keccak256 } from '../Keccak256/hash.js';
const hashTypedData = HashTypedData({ keccak256, hashDomain, hashStruct });
const signTypedData = SignTypedData({ hashTypedData, sign });
const privateKey = new Uint8Array(32);
const signature = signTypedData(typedData, privateKey);
```

###### EIP712.validate()

> **validate**: (`typedData`) => `void`

Validate typed data structure against EIP-712 specification.

Checks domain, types, primaryType, and message structure.

###### Parameters

###### typedData

[`TypedData`](crypto/EIP712.mdx#typeddata)

Typed data to validate

###### Returns

`void`

###### See

https://voltaire.tevm.sh/crypto for crypto documentation

###### Since

0.0.0

###### Throws

If structure is invalid or missing required fields

###### Example

```javascript
import * as EIP712 from './crypto/EIP712/index.js';
EIP712.validate(typedData); // Throws if invalid
```

###### EIP712.verifyTypedData()

> **verifyTypedData**: (`signature`, `typedData`, `address`) => `boolean`

###### Parameters

###### signature

[`Signature`](crypto/EIP712.mdx#signature)

###### typedData

[`TypedData`](crypto/EIP712.mdx#typeddata)

###### address

[`AddressType`](primitives/Address.mdx#addresstype)

###### Returns

`boolean`

###### EIP712.VerifyTypedData()

> **VerifyTypedData**: (`deps`) => (`signature`, `typedData`, `address`) => `boolean`

Factory: Verify EIP-712 typed data signature against expected signer address.

Uses constant-time comparison to prevent timing attacks.

###### Parameters

###### deps

Crypto dependencies

###### recoverAddress

(`signature`, `typedData`) => [`AddressType`](primitives/Address.mdx#addresstype)

Recover address function

###### Returns

Function that verifies signature

> (`signature`, `typedData`, `address`): `boolean`

###### Parameters

###### signature

[`Signature`](crypto/EIP712.mdx#signature)

###### typedData

[`TypedData`](crypto/EIP712.mdx#typeddata)

###### address

[`AddressType`](primitives/Address.mdx#addresstype)

###### Returns

`boolean`

###### See

https://voltaire.tevm.sh/crypto for crypto documentation

###### Since

0.0.0

###### Throws

###### Example

```javascript
import { VerifyTypedData } from './crypto/EIP712/verifyTypedData.js';
import { RecoverAddress } from './recoverAddress.js';
import { hash as keccak256 } from '../Keccak256/hash.js';
import { recoverPublicKey } from '../Secp256k1/recoverPublicKey.js';
const recoverAddress = RecoverAddress({ keccak256, recoverPublicKey, hashTypedData });
const verifyTypedData = VerifyTypedData({ recoverAddress });
const valid = verifyTypedData(signature, typedData, signerAddress);
```

##### Ether

> **Ether**: `EtherConstructor`

##### Gwei

> **Gwei**: `GweiConstructor`

##### Hash

> **Hash**: `HashConstructor`

##### Hex

> **Hex**: *typeof* [`Hex`](index/index.mdx#hex)

##### Keccak256

> **Keccak256**: (`input`) => [`Keccak256Hash`](index/index.mdx#keccak256hash) & `object` = `Keccak256JS`

###### Type Declaration

###### contractAddress()

> **contractAddress**: (`sender`, `nonce`) => `Uint8Array`\<`ArrayBufferLike`\>

Compute contract address from deployer and nonce

Uses CREATE formula: keccak256(rlp([sender, nonce]))[12:]

###### Parameters

###### sender

`Uint8Array`\<`ArrayBufferLike`\>

Deployer address (20 bytes)

###### nonce

`bigint`

Transaction nonce

###### Returns

`Uint8Array`\<`ArrayBufferLike`\>

Contract address (20 bytes)

###### See

https://voltaire.tevm.sh/crypto for crypto documentation

###### Since

0.0.0

###### Throws

If sender is not 20 bytes

###### Example

```javascript
import * as Keccak256 from './crypto/Keccak256/index.js';
const sender = new Uint8Array(20);
const address = Keccak256.contractAddress(sender, 0n);
```

###### create2Address()

> **create2Address**: (`sender`, `salt`, `initCodeHash`) => `Uint8Array`\<`ArrayBufferLike`\>

Compute CREATE2 address

Uses CREATE2 formula: keccak256(0xff ++ sender ++ salt ++ keccak256(init_code))[12:]

###### Parameters

###### sender

`Uint8Array`\<`ArrayBufferLike`\>

Deployer address (20 bytes)

###### salt

`Uint8Array`\<`ArrayBufferLike`\>

32-byte salt

###### initCodeHash

`Uint8Array`\<`ArrayBufferLike`\>

Hash of initialization code

###### Returns

`Uint8Array`\<`ArrayBufferLike`\>

Contract address (20 bytes)

###### See

https://voltaire.tevm.sh/crypto for crypto documentation

###### Since

0.0.0

###### Throws

If sender is not 20 bytes

###### Throws

If salt is not 32 bytes

###### Throws

If initCodeHash is not 32 bytes

###### Example

```javascript
import * as Keccak256 from './crypto/Keccak256/index.js';
const sender = new Uint8Array(20);
const salt = new Uint8Array(32);
const initCodeHash = new Uint8Array(32);
const address = Keccak256.create2Address(sender, salt, initCodeHash);
```

###### DIGEST\_SIZE

> **DIGEST\_SIZE**: `number`

Digest size in bytes (32 bytes = 256 bits)

###### Since

0.0.0

###### from()

> **from**: (`input`) => [`Keccak256Hash`](index/index.mdx#keccak256hash)

Hash input with Keccak-256 (constructor pattern)

Auto-detects input type and hashes accordingly:
- Uint8Array: hash directly
- string starting with 0x: parse as hex
- string: UTF-8 encode then hash

###### Parameters

###### input

Data to hash

`string` | `Uint8Array`\<`ArrayBufferLike`\>

###### Returns

[`Keccak256Hash`](index/index.mdx#keccak256hash)

32-byte hash

###### See

https://voltaire.tevm.sh/crypto/keccak256 for crypto documentation

###### Since

0.0.0

###### Throws

If hex string is invalid

###### Example

```javascript
import { Keccak256Hash } from './crypto/Keccak256/index.js';

const hash1 = Keccak256Hash.from("0x1234");      // Hex
const hash2 = Keccak256Hash.from("hello");       // String
const hash3 = Keccak256Hash.from(uint8array);    // Bytes
```

###### fromHex()

> **fromHex**: (`hex`) => [`Keccak256Hash`](index/index.mdx#keccak256hash) = `hashHex`

Hash hex string with Keccak-256

###### Parameters

###### hex

`string`

Hex string to hash (with or without 0x prefix)

###### Returns

[`Keccak256Hash`](index/index.mdx#keccak256hash)

32-byte hash

###### See

https://voltaire.tevm.sh/crypto for crypto documentation

###### Since

0.0.0

###### Throws

If hex string is invalid or has odd length

###### Example

```javascript
import { Keccak256Hash } from './crypto/Keccak256/index.js';
const hash = Keccak256Hash.fromHex('0x1234abcd');
```

###### fromString()

> **fromString**: (`str`) => [`Keccak256Hash`](index/index.mdx#keccak256hash) = `hashString`

Hash string with Keccak-256

String is UTF-8 encoded before hashing.

###### Parameters

###### str

`string`

String to hash

###### Returns

[`Keccak256Hash`](index/index.mdx#keccak256hash)

32-byte hash

###### See

https://voltaire.tevm.sh/crypto for crypto documentation

###### Since

0.0.0

###### Throws

###### Example

```javascript
import { Keccak256Hash } from './crypto/Keccak256/index.js';
const hash = Keccak256Hash.fromString('hello');
```

###### fromTopic()

> **fromTopic**: (`signature`) => [`Keccak256Hash`](index/index.mdx#keccak256hash) = `topic`

Compute event topic (32-byte Keccak-256 hash)

Used for Ethereum event signatures.

###### Parameters

###### signature

`string`

Event signature string

###### Returns

[`Keccak256Hash`](index/index.mdx#keccak256hash)

32-byte topic

###### See

https://voltaire.tevm.sh/crypto for crypto documentation

###### Since

0.0.0

###### Throws

###### Example

```javascript
import { Keccak256Hash } from './crypto/Keccak256/index.js';
const topic = Keccak256Hash.fromTopic('Transfer(address,address,uint256)');
```

###### hash()

> **hash**: (`data`) => [`Keccak256Hash`](index/index.mdx#keccak256hash)

Hash data with Keccak-256

###### Parameters

###### data

`Uint8Array`\<`ArrayBufferLike`\>

Data to hash

###### Returns

[`Keccak256Hash`](index/index.mdx#keccak256hash)

32-byte hash

###### See

https://voltaire.tevm.sh/crypto for crypto documentation

###### Since

0.0.0

###### Throws

###### Example

```javascript
import { Keccak256Hash } from './crypto/Keccak256/index.js';
const hash = Keccak256Hash.from(data);
```

###### hashHex()

> **hashHex**: (`hex`) => [`Keccak256Hash`](index/index.mdx#keccak256hash)

Hash hex string with Keccak-256

###### Parameters

###### hex

`string`

Hex string to hash (with or without 0x prefix)

###### Returns

[`Keccak256Hash`](index/index.mdx#keccak256hash)

32-byte hash

###### See

https://voltaire.tevm.sh/crypto for crypto documentation

###### Since

0.0.0

###### Throws

If hex string is invalid or has odd length

###### Example

```javascript
import { Keccak256Hash } from './crypto/Keccak256/index.js';
const hash = Keccak256Hash.fromHex('0x1234abcd');
```

###### hashMultiple()

> **hashMultiple**: (`chunks`) => [`Keccak256Hash`](index/index.mdx#keccak256hash)

Hash multiple data chunks in sequence

Equivalent to hashing the concatenation of all chunks.

###### Parameters

###### chunks

readonly `Uint8Array`\<`ArrayBufferLike`\>[]

Array of data chunks to hash

###### Returns

[`Keccak256Hash`](index/index.mdx#keccak256hash)

32-byte hash

###### See

https://voltaire.tevm.sh/crypto for crypto documentation

###### Since

0.0.0

###### Throws

###### Example

```javascript
import { Keccak256Hash } from './crypto/Keccak256/index.js';
const hash = Keccak256Hash.from(combined);
```

###### hashString()

> **hashString**: (`str`) => [`Keccak256Hash`](index/index.mdx#keccak256hash)

Hash string with Keccak-256

String is UTF-8 encoded before hashing.

###### Parameters

###### str

`string`

String to hash

###### Returns

[`Keccak256Hash`](index/index.mdx#keccak256hash)

32-byte hash

###### See

https://voltaire.tevm.sh/crypto for crypto documentation

###### Since

0.0.0

###### Throws

###### Example

```javascript
import { Keccak256Hash } from './crypto/Keccak256/index.js';
const hash = Keccak256Hash.fromString('hello');
```

###### RATE

> **RATE**: `number`

Rate in bytes for Keccak256 (136 bytes = 1088 bits)

###### Since

0.0.0

###### selector()

> **selector**: (`signature`) => `Uint8Array`\<`ArrayBufferLike`\>

Compute function selector (first 4 bytes of Keccak-256 hash)

Used for Ethereum function signatures.

###### Parameters

###### signature

`string`

Function signature string

###### Returns

`Uint8Array`\<`ArrayBufferLike`\>

4-byte selector

###### See

https://voltaire.tevm.sh/crypto for crypto documentation

###### Since

0.0.0

###### Throws

###### Example

```javascript
import * as Keccak256 from './crypto/Keccak256/index.js';
const selector = Keccak256.selector('transfer(address,uint256)');
// Uint8Array(4) [0xa9, 0x05, 0x9c, 0xbb]
```

###### STATE\_SIZE

> **STATE\_SIZE**: `number`

State size (25 u64 words = 1600 bits)

###### Since

0.0.0

###### topic()

> **topic**: (`signature`) => [`Keccak256Hash`](index/index.mdx#keccak256hash)

Compute event topic (32-byte Keccak-256 hash)

Used for Ethereum event signatures.

###### Parameters

###### signature

`string`

Event signature string

###### Returns

[`Keccak256Hash`](index/index.mdx#keccak256hash)

32-byte topic

###### See

https://voltaire.tevm.sh/crypto for crypto documentation

###### Since

0.0.0

###### Throws

###### Example

```javascript
import { Keccak256Hash } from './crypto/Keccak256/index.js';
const topic = Keccak256Hash.fromTopic('Transfer(address,address,uint256)');
```

##### KZG

> **KZG**: *typeof* [`KZG`](index/index.mdx#kzg)

##### ModExp

> **ModExp**: (`base`, `exp`, `modulus`) => `bigint` & `object`

ModExp - Modular Exponentiation

Computes base^exp mod modulus for arbitrary-precision integers.
Used by MODEXP precompile (0x05) per EIP-198/EIP-2565.

###### Type Declaration

###### calculateGas()

> **calculateGas**: (`baseLen`, `expLen`, `modLen`, `expHead`) => `bigint`

Calculate gas cost for MODEXP operation per EIP-2565

Gas formula: max(200, floor(mult_complexity * iteration_count / 3))

###### Parameters

###### baseLen

`bigint`

Length of base in bytes

###### expLen

`bigint`

Length of exponent in bytes

###### modLen

`bigint`

Length of modulus in bytes

###### expHead

`bigint`

First 32 bytes of exponent as BigInt (for leading zeros calc)

###### Returns

`bigint`

Gas cost

###### See

https://eips.ethereum.org/EIPS/eip-2565

###### Since

0.0.0

###### Example

```javascript
import { ModExp } from './crypto/ModExp/index.js';

// Calculate gas for 2^3 mod 5
const gas = ModExp.calculateGas(1n, 1n, 1n, 3n);
console.log(gas); // 200n (minimum)
```

###### modexp()

> **modexp**: (`base`, `exp`, `modulus`) => `bigint`

Modular exponentiation: base^exp mod modulus

Computes arbitrary-precision modular exponentiation using native BigInt.
Used by MODEXP precompile (0x05) per EIP-198.

WARNING: This implementation is for general use. For cryptographic
applications, consider timing attack resistance.

###### Parameters

###### base

`bigint`

Base value

###### exp

`bigint`

Exponent value

###### modulus

`bigint`

Modulus value (must be > 0)

###### Returns

`bigint`

Result of base^exp mod modulus

###### See

https://eips.ethereum.org/EIPS/eip-198

###### Since

0.0.0

###### Throws

If modulus is zero

###### Example

```javascript
import { ModExp } from './crypto/ModExp/index.js';

// Compute 2^10 mod 1000 = 24
const result = ModExp.modexp(2n, 10n, 1000n);
console.log(result); // 24n

// RSA verification: signature^e mod n
const verified = ModExp.modexp(signature, e, n);
```

###### modexpBytes()

> **modexpBytes**: (`baseBytes`, `expBytes`, `modBytes`) => `Uint8Array`\<`ArrayBufferLike`\>

Modular exponentiation with byte array inputs/outputs

Computes base^exp mod modulus where inputs are big-endian byte arrays.
Output is padded to modulus length per EIP-198 spec.

###### Parameters

###### baseBytes

`Uint8Array`\<`ArrayBufferLike`\>

Base as big-endian bytes

###### expBytes

`Uint8Array`\<`ArrayBufferLike`\>

Exponent as big-endian bytes

###### modBytes

`Uint8Array`\<`ArrayBufferLike`\>

Modulus as big-endian bytes

###### Returns

`Uint8Array`\<`ArrayBufferLike`\>

Result as big-endian bytes, padded to modulus length

###### See

https://eips.ethereum.org/EIPS/eip-198

###### Since

0.0.0

###### Throws

If modulus is zero

###### Example

```javascript
import { ModExp } from './crypto/ModExp/index.js';

const base = new Uint8Array([0x02]); // 2
const exp = new Uint8Array([0x03]);  // 3
const mod = new Uint8Array([0x05]);  // 5

const result = ModExp.modexpBytes(base, exp, mod);
console.log(result); // Uint8Array([0x03]) = 3
```

###### See

 - https://eips.ethereum.org/EIPS/eip-198 - ModExp precompile
 - https://eips.ethereum.org/EIPS/eip-2565 - Gas cost repricing

###### Since

0.0.0

###### Example

```javascript
import { ModExp } from './crypto/ModExp/index.js';

// Using BigInt directly
const result = ModExp.modexp(2n, 10n, 1000n); // 24n

// Using byte arrays (EIP-198 format)
const base = new Uint8Array([0x02]);
const exp = new Uint8Array([0x0a]);
const mod = new Uint8Array([0x03, 0xe8]);
const resultBytes = ModExp.modexpBytes(base, exp, mod);

// Calculate gas cost
const gas = ModExp.calculateGas(1n, 1n, 2n, 10n);
```

##### Opcode

> **Opcode**: *typeof* [`Opcode`](index/index.mdx#opcode)

##### P256

> **P256**: [`P256Constructor`](crypto/P256.mdx#p256constructor)

P256 namespace with cryptographic operations

##### ~~Ripemd160~~

> **Ripemd160**: (`input`) => [`Ripemd160Hash`](index/index.mdx#ripemd160hash) & `object`

###### Type Declaration

###### ~~from()~~

> **from**: (`input`) => [`Ripemd160Hash`](index/index.mdx#ripemd160hash)

Hash input with RIPEMD160 (constructor pattern)

Auto-detects input type and hashes accordingly:
- Uint8Array: hash directly
- string: UTF-8 encode then hash

###### Parameters

###### input

Data to hash

`string` | `Uint8Array`\<`ArrayBufferLike`\>

###### Returns

[`Ripemd160Hash`](index/index.mdx#ripemd160hash)

20-byte hash

###### See

https://voltaire.tevm.sh/crypto/ripemd160 for crypto documentation

###### Since

0.0.0

###### Throws

###### Example

```javascript
import { Ripemd160Hash } from './crypto/Ripemd160/index.js';

const hash1 = Ripemd160Hash.from("hello");           // String
const hash2 = Ripemd160Hash.from(uint8array);        // Bytes
```

###### ~~fromHex()~~

> **fromHex**: (`hex`) => [`Ripemd160Hash`](index/index.mdx#ripemd160hash) = `hashHex`

Compute RIPEMD160 hash of hex string (without 0x prefix)

###### Parameters

###### hex

`string`

Hex string (with or without 0x prefix)

###### Returns

[`Ripemd160Hash`](index/index.mdx#ripemd160hash)

20-byte hash

###### See

https://voltaire.tevm.sh/crypto for crypto documentation

###### Since

0.0.0

###### Throws

###### Example

```javascript
import { Ripemd160 } from './crypto/Ripemd160/index.js';
const hash = Ripemd160.hashHex("0xdeadbeef");
console.log(hash.length); // 20
```

###### ~~fromString()~~

> **fromString**: (`str`) => [`Ripemd160Hash`](index/index.mdx#ripemd160hash) = `hashString`

Compute RIPEMD160 hash of UTF-8 string

###### Parameters

###### str

`string`

Input string

###### Returns

[`Ripemd160Hash`](index/index.mdx#ripemd160hash)

20-byte hash

###### See

https://voltaire.tevm.sh/crypto for crypto documentation

###### Since

0.0.0

###### Throws

###### Example

```javascript
import { Ripemd160 } from './crypto/Ripemd160/index.js';
const hash = Ripemd160.hashString("hello");
console.log(hash.length); // 20
```

###### ~~hash()~~

> **hash**: (`data`) => [`Ripemd160Hash`](index/index.mdx#ripemd160hash)

Compute RIPEMD160 hash (20 bytes)

###### Parameters

###### data

Input data (Uint8Array or string)

`string` | `Uint8Array`\<`ArrayBufferLike`\>

###### Returns

[`Ripemd160Hash`](index/index.mdx#ripemd160hash)

20-byte hash

###### See

https://voltaire.tevm.sh/crypto for crypto documentation

###### Since

0.0.0

###### Throws

###### Example

```javascript
import { Ripemd160 } from './crypto/Ripemd160/index.js';
const hash = Ripemd160.hash(new Uint8Array([1, 2, 3]));
console.log(hash.length); // 20
```

###### ~~hashHex()~~

> **hashHex**: (`hex`) => [`Ripemd160Hash`](index/index.mdx#ripemd160hash)

Compute RIPEMD160 hash of hex string (without 0x prefix)

###### Parameters

###### hex

`string`

Hex string (with or without 0x prefix)

###### Returns

[`Ripemd160Hash`](index/index.mdx#ripemd160hash)

20-byte hash

###### See

https://voltaire.tevm.sh/crypto for crypto documentation

###### Since

0.0.0

###### Throws

###### Example

```javascript
import { Ripemd160 } from './crypto/Ripemd160/index.js';
const hash = Ripemd160.hashHex("0xdeadbeef");
console.log(hash.length); // 20
```

###### ~~hashString()~~

> **hashString**: (`str`) => [`Ripemd160Hash`](index/index.mdx#ripemd160hash)

Compute RIPEMD160 hash of UTF-8 string

###### Parameters

###### str

`string`

Input string

###### Returns

[`Ripemd160Hash`](index/index.mdx#ripemd160hash)

20-byte hash

###### See

https://voltaire.tevm.sh/crypto for crypto documentation

###### Since

0.0.0

###### Throws

###### Example

```javascript
import { Ripemd160 } from './crypto/Ripemd160/index.js';
const hash = Ripemd160.hashString("hello");
console.log(hash.length); // 20
```

###### ~~HEX\_SIZE~~

> **HEX\_SIZE**: `number`

Size of RIPEMD160 hash in hex characters (without 0x prefix)

###### See

https://voltaire.tevm.sh/crypto for crypto documentation

###### Since

0.0.0

###### Throws

###### Example

```javascript
import { HEX_SIZE } from './crypto/Ripemd160/index.js';
console.log(HEX_SIZE); // 40
```

###### ~~SIZE~~

> **SIZE**: `number`

Size of RIPEMD160 hash in bytes (160 bits)

###### See

https://voltaire.tevm.sh/crypto for crypto documentation

###### Since

0.0.0

###### Throws

###### Example

```javascript
import { SIZE } from './crypto/Ripemd160/index.js';
console.log(SIZE); // 20
```

###### Deprecated

Use Ripemd160Hash instead
Ripemd160 alias maintained for backward compatibility

##### Rlp

> **Rlp**: *typeof* [`Rlp`](primitives/Rlp.mdx#rlp)

##### Secp256k1

> **Secp256k1**: `object`

secp256k1/ECDSA Cryptography namespace

Complete ECDSA signing and verification using the secp256k1 elliptic curve.
All operations use the audited @noble/curves library for security.
Full Ethereum compatibility with v = 27/28 recovery IDs.

###### See

https://voltaire.tevm.sh/crypto for crypto documentation

###### Since

0.0.0

###### Throws

###### Example

```javascript
import { Secp256k1 } from './crypto/Secp256k1/index.js';
import * as Hash from './primitives/Hash/index.js';

// Sign a message hash
const messageHash = Hash.keccak256String('Hello, Ethereum!');
const privateKey = new Uint8Array(32);
const signature = Secp256k1.sign(messageHash, privateKey);

// Verify signature
const publicKey = Secp256k1.derivePublicKey(privateKey);
const valid = Secp256k1.verify(signature, messageHash, publicKey);

// Recover public key from signature
const recovered = Secp256k1.recoverPublicKey(signature, messageHash);

// Hash-level API for interop with other libraries
const hash = Hash.keccak256String('Hello');
const hashSig = Secp256k1.signHash(hash, privateKey);
const hashValid = Secp256k1.verifyHash(hashSig, hash, publicKey);
```

###### Secp256k1.addPoints()

> **addPoints**: (`pubKey1`, `pubKey2`) => [`Secp256k1PublicKeyType`](crypto/Secp256k1.mdx#secp256k1publickeytype)

Add two secp256k1 public key points

Performs elliptic curve point addition: P1 + P2.
Used in ERC-5564 stealth address generation.

###### Parameters

###### pubKey1

[`Secp256k1PublicKeyType`](crypto/Secp256k1.mdx#secp256k1publickeytype)

First 64-byte uncompressed public key

###### pubKey2

[`Secp256k1PublicKeyType`](crypto/Secp256k1.mdx#secp256k1publickeytype)

Second 64-byte uncompressed public key

###### Returns

[`Secp256k1PublicKeyType`](crypto/Secp256k1.mdx#secp256k1publickeytype)

Result 64-byte uncompressed public key

###### See

 - https://voltaire.tevm.sh/crypto for crypto documentation
 - https://eips.ethereum.org/EIPS/eip-5564 for ERC-5564 stealth addresses

###### Since

0.0.0

###### Throws

If either public key is invalid

###### Throws

If point addition fails

###### Example

```javascript
import * as Secp256k1 from './crypto/Secp256k1/index.js';
const pubKey1 = Secp256k1.derivePublicKey(privateKey1);
const pubKey2 = Secp256k1.derivePublicKey(privateKey2);
const sum = Secp256k1.addPoints(pubKey1, pubKey2);
console.log(sum.length); // 64
```

###### Secp256k1.createKeyPair()

> **createKeyPair**: () => `object`

Generate a new secp256k1 key pair

###### Returns

`object`

Key pair with 32-byte private key and 65-byte uncompressed public key

###### privateKey

> **privateKey**: `Uint8Array`

###### publicKey

> **publicKey**: `Uint8Array`

###### Example

```javascript
import { Secp256k1 } from './crypto/Secp256k1/index.js';
const { privateKey, publicKey } = Secp256k1.createKeyPair();
```

###### Secp256k1.CURVE\_ORDER

> **CURVE\_ORDER**: `bigint`

secp256k1 curve order (number of points on the curve)

###### See

https://voltaire.tevm.sh/crypto for crypto documentation

###### Since

0.0.0

###### Throws

###### Example

```javascript
import { CURVE_ORDER } from './crypto/Secp256k1/index.js';
console.log(CURVE_ORDER); // 0xffffffffffff...
```

###### Secp256k1.derivePublicKey()

> **derivePublicKey**: (`privateKey`) => [`Secp256k1PublicKeyType`](crypto/Secp256k1.mdx#secp256k1publickeytype)

Derive public key from private key

Computes the public key point from a private key using scalar
multiplication on the secp256k1 curve.

###### Parameters

###### privateKey

[`PrivateKeyType`](primitives/PrivateKey.mdx#privatekeytype)

32-byte private key

###### Returns

[`Secp256k1PublicKeyType`](crypto/Secp256k1.mdx#secp256k1publickeytype)

64-byte uncompressed public key

###### See

https://voltaire.tevm.sh/crypto for crypto documentation

###### Since

0.0.0

###### Throws

If private key is invalid

###### Example

```javascript
import * as Secp256k1 from './crypto/Secp256k1/index.js';
import * as PrivateKey from './primitives/PrivateKey/index.js';
const privateKey = PrivateKey.from(new Uint8Array(32));
const publicKey = Secp256k1.derivePublicKey(privateKey);
console.log(publicKey.length); // 64
```

###### Secp256k1.ecdh()

> **ecdh**: (`privateKey`, `publicKey`) => `Uint8Array`\<`ArrayBufferLike`\>

Perform ECDH key exchange

Computes shared secret from your private key and their public key.
Returns the x-coordinate of the shared point (32 bytes).

###### Parameters

###### privateKey

[`PrivateKeyType`](primitives/PrivateKey.mdx#privatekeytype)

Your 32-byte private key

###### publicKey

[`Secp256k1PublicKeyType`](crypto/Secp256k1.mdx#secp256k1publickeytype)

Their 64-byte uncompressed public key

###### Returns

`Uint8Array`\<`ArrayBufferLike`\>

32-byte shared secret (x-coordinate)

###### See

 - https://voltaire.tevm.sh/crypto for crypto documentation
 - https://eips.ethereum.org/EIPS/eip-5564 for ERC-5564 stealth addresses

###### Since

0.0.0

###### Throws

If private key is invalid

###### Throws

If public key is invalid

###### Throws

If ECDH computation fails

###### Example

```javascript
import * as Secp256k1 from './crypto/Secp256k1/index.js';
const myPrivateKey = new Uint8Array(32);
const theirPublicKey = Secp256k1.derivePublicKey(theirPrivateKey);
const sharedSecret = Secp256k1.ecdh(myPrivateKey, theirPublicKey);
console.log(sharedSecret.length); // 32
```

###### Secp256k1.getSharedSecret()

> **getSharedSecret**: (`privateKey`, `publicKey`) => `Uint8Array`\<`ArrayBufferLike`\> = `ecdh`

Perform ECDH key exchange

Computes shared secret from your private key and their public key.
Returns the x-coordinate of the shared point (32 bytes).

###### Parameters

###### privateKey

[`PrivateKeyType`](primitives/PrivateKey.mdx#privatekeytype)

Your 32-byte private key

###### publicKey

[`Secp256k1PublicKeyType`](crypto/Secp256k1.mdx#secp256k1publickeytype)

Their 64-byte uncompressed public key

###### Returns

`Uint8Array`\<`ArrayBufferLike`\>

32-byte shared secret (x-coordinate)

###### See

 - https://voltaire.tevm.sh/crypto for crypto documentation
 - https://eips.ethereum.org/EIPS/eip-5564 for ERC-5564 stealth addresses

###### Since

0.0.0

###### Throws

If private key is invalid

###### Throws

If public key is invalid

###### Throws

If ECDH computation fails

###### Example

```javascript
import * as Secp256k1 from './crypto/Secp256k1/index.js';
const myPrivateKey = new Uint8Array(32);
const theirPublicKey = Secp256k1.derivePublicKey(theirPrivateKey);
const sharedSecret = Secp256k1.ecdh(myPrivateKey, theirPublicKey);
console.log(sharedSecret.length); // 32
```

###### Secp256k1.isValidPrivateKey()

> **isValidPrivateKey**: (`privateKey`) => `boolean`

Validate private key

Checks that the private key is within valid range [1, n-1] where n
is the curve order.

###### Parameters

###### privateKey

`Uint8Array`\<`ArrayBufferLike`\>

32-byte private key

###### Returns

`boolean`

true if private key is valid, false otherwise

###### See

https://voltaire.tevm.sh/crypto for crypto documentation

###### Since

0.0.0

###### Throws

###### Example

```javascript
import * as Secp256k1 from './crypto/Secp256k1/index.js';
const privateKey = new Uint8Array(32);
const valid = Secp256k1.isValidPrivateKey(privateKey);
```

###### Secp256k1.isValidPublicKey()

> **isValidPublicKey**: (`publicKey`) => `publicKey is Secp256k1PublicKeyType`

Validate public key

Checks that the public key is a valid point on the secp256k1 curve.

###### Parameters

###### publicKey

`Uint8Array`\<`ArrayBufferLike`\>

64-byte uncompressed public key

###### Returns

`publicKey is Secp256k1PublicKeyType`

true if public key is valid, false otherwise

###### See

https://voltaire.tevm.sh/crypto for crypto documentation

###### Since

0.0.0

###### Throws

###### Example

```javascript
import * as Secp256k1 from './crypto/Secp256k1/index.js';
const publicKey = new Uint8Array(64);
if (Secp256k1.isValidPublicKey(publicKey)) {
  const branded = publicKey; // now Secp256k1PublicKeyType
}
```

###### Secp256k1.isValidSignature()

> **isValidSignature**: (`signature`) => `boolean`

Validate signature components

Checks that r and s are within valid range [1, n-1] where n is the
curve order. Also enforces low-s values to prevent malleability.

###### Parameters

###### signature

[`Secp256k1SignatureType`](crypto/Secp256k1.mdx#secp256k1signaturetype)

ECDSA signature to validate (r and s are HashType)

###### Returns

`boolean`

true if signature is valid, false otherwise

###### See

https://voltaire.tevm.sh/crypto for crypto documentation

###### Since

0.0.0

###### Throws

###### Example

```javascript
import * as Secp256k1 from './crypto/Secp256k1/index.js';
import * as Hash from './primitives/Hash/index.js';
const signature = { r: Hash.from(new Uint8Array(32)), s: Hash.from(new Uint8Array(32)), v: 27 };
const valid = Secp256k1.isValidSignature(signature);
```

###### Secp256k1.PRIVATE\_KEY\_SIZE

> **PRIVATE\_KEY\_SIZE**: `number`

Private key size in bytes

###### See

https://voltaire.tevm.sh/crypto for crypto documentation

###### Since

0.0.0

###### Throws

###### Example

```javascript
import { PRIVATE_KEY_SIZE } from './crypto/Secp256k1/index.js';
console.log(PRIVATE_KEY_SIZE); // 32
```

###### Secp256k1.PrivateKey

> **PrivateKey**: `__module` = `PrivateKeyMethods`

###### Secp256k1.PUBLIC\_KEY\_SIZE

> **PUBLIC\_KEY\_SIZE**: `number`

Uncompressed public key size in bytes (64 bytes, no prefix)

###### See

https://voltaire.tevm.sh/crypto for crypto documentation

###### Since

0.0.0

###### Throws

###### Example

```javascript
import { PUBLIC_KEY_SIZE } from './crypto/Secp256k1/index.js';
console.log(PUBLIC_KEY_SIZE); // 64
```

###### Secp256k1.PublicKey

> **PublicKey**: `__module` = `PublicKeyMethods`

###### Secp256k1.randomPrivateKey()

> **randomPrivateKey**: () => `Uint8Array`\<`ArrayBufferLike`\>

Generate a cryptographically secure random secp256k1 private key

###### Returns

`Uint8Array`\<`ArrayBufferLike`\>

32-byte private key

###### Example

```javascript
import { Secp256k1 } from './crypto/Secp256k1/index.js';
const privateKey = Secp256k1.randomPrivateKey();
const publicKey = Secp256k1.derivePublicKey(privateKey);
```

###### Secp256k1.recoverPublicKey()

> **recoverPublicKey**: (`signature`, `messageHash`) => [`Secp256k1PublicKeyType`](crypto/Secp256k1.mdx#secp256k1publickeytype)

Recover public key from signature and message hash

Uses the recovery id (v) to recover the exact public key that created
the signature. This is what enables Ethereum's address recovery from
transaction signatures.

###### Parameters

###### signature

ECDSA signature components

###### r

`Uint8Array`\<`ArrayBufferLike`\>

32-byte signature component r

###### s

`Uint8Array`\<`ArrayBufferLike`\>

32-byte signature component s

###### v

`number`

Recovery id (27/28 or 0/1)

###### messageHash

[`HashType`](index/namespaces/HashType.mdx#hashtype)

32-byte message hash that was signed

###### Returns

[`Secp256k1PublicKeyType`](crypto/Secp256k1.mdx#secp256k1publickeytype)

64-byte uncompressed public key

###### See

https://voltaire.tevm.sh/crypto for crypto documentation

###### Since

0.0.0

###### Throws

If signature or recovery fails

###### Example

```javascript
import * as Secp256k1 from './crypto/Secp256k1/index.js';
import * as Hash from './primitives/Hash/index.js';
const messageHash = Hash.keccak256String('Hello');
const recovered = Secp256k1.recoverPublicKey(
  { r: rBytes, s: sBytes, v: 27 },
  messageHash
);
```

###### Secp256k1.recoverPublicKeyFromHash()

> **recoverPublicKeyFromHash**: (`signature`, `hash`) => [`Secp256k1PublicKeyType`](crypto/Secp256k1.mdx#secp256k1publickeytype)

Recover public key from signature and pre-hashed message

This is the hash-level API that operates directly on a 32-byte hash.
Use this when you need custom hashing schemes or interop with other libraries.
For standard Ethereum signing, use recoverPublicKey() instead.

Uses the recovery id (v) to recover the exact public key that created
the signature. This is what enables Ethereum's address recovery from
transaction signatures.

###### Parameters

###### signature

ECDSA signature components

###### r

`Uint8Array`\<`ArrayBufferLike`\>

32-byte signature component r

###### s

`Uint8Array`\<`ArrayBufferLike`\>

32-byte signature component s

###### v

`number`

Recovery id (27/28 or 0/1)

###### hash

[`HashType`](index/namespaces/HashType.mdx#hashtype)

32-byte hash that was signed (pre-hashed message)

###### Returns

[`Secp256k1PublicKeyType`](crypto/Secp256k1.mdx#secp256k1publickeytype)

64-byte uncompressed public key

###### See

https://voltaire.tevm.sh/crypto for crypto documentation

###### Since

0.0.0

###### Throws

If signature or recovery fails

###### Throws

If hash is not 32 bytes

###### Example

```javascript
import * as Secp256k1 from './crypto/Secp256k1/index.js';
import * as Hash from './primitives/Hash/index.js';

// Recover public key from a pre-hashed message (hash-level API)
const hash = Hash.keccak256String('Hello');
const recovered = Secp256k1.recoverPublicKeyFromHash(
  { r: rBytes, s: sBytes, v: 27 },
  hash
);

// For comparison, recoverPublicKey() hashes internally (message-level API)
const recovered2 = Secp256k1.recoverPublicKey(
  { r: rBytes, s: sBytes, v: 27 },
  messageHash
);
```

###### Secp256k1.scalarMultiply()

> **scalarMultiply**: (`scalar`) => [`Secp256k1PublicKeyType`](crypto/Secp256k1.mdx#secp256k1publickeytype)

Multiply generator point by scalar

Performs scalar multiplication: scalar * G (generator point).
Used in ERC-5564 stealth address generation.

###### Parameters

###### scalar

`Uint8Array`\<`ArrayBufferLike`\>

32-byte scalar value

###### Returns

[`Secp256k1PublicKeyType`](crypto/Secp256k1.mdx#secp256k1publickeytype)

Result 64-byte uncompressed public key

###### See

 - https://voltaire.tevm.sh/crypto for crypto documentation
 - https://eips.ethereum.org/EIPS/eip-5564 for ERC-5564 stealth addresses

###### Since

0.0.0

###### Throws

If scalar multiplication fails

###### Example

```javascript
import * as Secp256k1 from './crypto/Secp256k1/index.js';
const scalar = new Uint8Array(32);
scalar[31] = 5; // scalar = 5
const result = Secp256k1.scalarMultiply(scalar);
console.log(result.length); // 64
```

###### Secp256k1.sign()

> **sign**: (`messageHash`, `privateKey`) => [`Secp256k1SignatureType`](crypto/Secp256k1.mdx#secp256k1signaturetype)

Sign a message hash with a private key

Uses deterministic ECDSA (RFC 6979) for signature generation.
Returns signature with Ethereum-compatible v value (27 or 28).

###### Parameters

###### messageHash

[`HashType`](index/namespaces/HashType.mdx#hashtype)

32-byte message hash to sign

###### privateKey

[`PrivateKeyType`](primitives/PrivateKey.mdx#privatekeytype)

32-byte private key

###### Returns

[`Secp256k1SignatureType`](crypto/Secp256k1.mdx#secp256k1signaturetype)

ECDSA signature with r, s, v components

###### See

https://voltaire.tevm.sh/crypto for crypto documentation

###### Since

0.0.0

###### Throws

If private key is invalid

###### Throws

If signing fails

###### Example

```javascript
import * as Secp256k1 from './crypto/Secp256k1/index.js';
import * as Hash from './primitives/Hash/index.js';
import * as PrivateKey from './primitives/PrivateKey/index.js';
const messageHash = Hash.keccak256String('Hello!');
const privateKey = PrivateKey.from(new Uint8Array(32));
const signature = Secp256k1.sign(messageHash, privateKey);
```

###### Secp256k1.Signature

> **Signature**: `__module` = `SignatureMethods`

###### Secp256k1.SIGNATURE\_COMPONENT\_SIZE

> **SIGNATURE\_COMPONENT\_SIZE**: `number`

Signature component size in bytes (r and s are each 32 bytes)

###### See

https://voltaire.tevm.sh/crypto for crypto documentation

###### Since

0.0.0

###### Throws

###### Example

```javascript
import { SIGNATURE_COMPONENT_SIZE } from './crypto/Secp256k1/index.js';
console.log(SIGNATURE_COMPONENT_SIZE); // 32
```

###### Secp256k1.signHash()

> **signHash**: (`hash`, `privateKey`) => [`Secp256k1SignatureType`](crypto/Secp256k1.mdx#secp256k1signaturetype)

Sign a pre-hashed message with a private key

This is the hash-level API that operates directly on a 32-byte hash.
Use this when you need custom hashing schemes or interop with other libraries.
For standard Ethereum signing, use sign() instead.

Uses deterministic ECDSA (RFC 6979) for signature generation.
Returns signature with Ethereum-compatible v value (27 or 28).

###### Parameters

###### hash

[`HashType`](index/namespaces/HashType.mdx#hashtype)

32-byte hash to sign (pre-hashed message)

###### privateKey

[`PrivateKeyType`](primitives/PrivateKey.mdx#privatekeytype)

32-byte private key

###### Returns

[`Secp256k1SignatureType`](crypto/Secp256k1.mdx#secp256k1signaturetype)

ECDSA signature with r, s, v components

###### See

https://voltaire.tevm.sh/crypto for crypto documentation

###### Since

0.0.0

###### Throws

If private key is invalid

###### Throws

If signing fails or hash is not 32 bytes

###### Example

```javascript
import * as Secp256k1 from './crypto/Secp256k1/index.js';
import * as Hash from './primitives/Hash/index.js';
import * as PrivateKey from './primitives/PrivateKey/index.js';

// Sign a pre-hashed message (hash-level API)
const hash = Hash.keccak256String('Hello!');
const privateKey = PrivateKey.from(new Uint8Array(32));
const signature = Secp256k1.signHash(hash, privateKey);

// For comparison, sign() hashes internally (message-level API)
const signature2 = Secp256k1.sign(Hash.keccak256String('Hello!'), privateKey);
```

###### Secp256k1.verify()

> **verify**: (`signature`, `messageHash`, `publicKey`) => `boolean`

Verify an ECDSA signature

###### Parameters

###### signature

[`Secp256k1SignatureType`](crypto/Secp256k1.mdx#secp256k1signaturetype)

ECDSA signature with r, s, v components (r and s are HashType)

###### messageHash

[`HashType`](index/namespaces/HashType.mdx#hashtype)

32-byte message hash that was signed

###### publicKey

[`Secp256k1PublicKeyType`](crypto/Secp256k1.mdx#secp256k1publickeytype)

64-byte uncompressed public key

###### Returns

`boolean`

true if signature is valid, false otherwise

###### See

https://voltaire.tevm.sh/crypto for crypto documentation

###### Since

0.0.0

###### Throws

If signature v is invalid

###### Example

```javascript
import * as Secp256k1 from './crypto/Secp256k1/index.js';
import * as Hash from './primitives/Hash/index.js';
const r = Hash.from(rBytes);
const s = Hash.from(sBytes);
const valid = Secp256k1.verify({ r, s, v: 27 }, messageHash, publicKey);
```

###### Secp256k1.verifyHash()

> **verifyHash**: (`signature`, `hash`, `publicKey`) => `boolean`

Verify an ECDSA signature against a pre-hashed message

This is the hash-level API that operates directly on a 32-byte hash.
Use this when you need custom hashing schemes or interop with other libraries.
For standard Ethereum signing, use verify() instead.

###### Parameters

###### signature

[`Secp256k1SignatureType`](crypto/Secp256k1.mdx#secp256k1signaturetype)

ECDSA signature with r, s, v components (r and s are HashType)

###### hash

[`HashType`](index/namespaces/HashType.mdx#hashtype)

32-byte hash that was signed (pre-hashed message)

###### publicKey

[`Secp256k1PublicKeyType`](crypto/Secp256k1.mdx#secp256k1publickeytype)

64-byte uncompressed public key

###### Returns

`boolean`

true if signature is valid, false otherwise

###### See

https://voltaire.tevm.sh/crypto for crypto documentation

###### Since

0.0.0

###### Throws

If hash is not 32 bytes

###### Example

```javascript
import * as Secp256k1 from './crypto/Secp256k1/index.js';
import * as Hash from './primitives/Hash/index.js';

// Verify a signature against a pre-hashed message (hash-level API)
const hash = Hash.keccak256String('Hello!');
const valid = Secp256k1.verifyHash({ r, s, v: 27 }, hash, publicKey);

// For comparison, verify() hashes internally (message-level API)
const valid2 = Secp256k1.verify({ r, s, v: 27 }, messageHash, publicKey);
```

##### ~~SHA256~~

> **SHA256**: (`input`) => [`SHA256Hash`](index/index.mdx#sha256hash) & `object`

###### Type Declaration

###### ~~BLOCK\_SIZE~~

> **BLOCK\_SIZE**: `number`

SHA256 block size in bytes

###### See

https://voltaire.tevm.sh/crypto for crypto documentation

###### Since

0.0.0

###### Throws

###### Example

```javascript
import { BLOCK_SIZE } from './crypto/SHA256/index.js';
console.log(BLOCK_SIZE); // 64
```

###### ~~create()~~

> **create**: () => `object`

Incremental hasher for streaming data

###### Returns

`object`

Hasher instance

###### ~~digest()~~

> **digest**: () => `Uint8Array`

###### Returns

`Uint8Array`

###### ~~update()~~

> **update**: (`data`) => `void`

###### Parameters

###### data

`Uint8Array`

###### Returns

`void`

###### See

https://voltaire.tevm.sh/crypto for crypto documentation

###### Since

0.0.0

###### Throws

###### Example

```javascript
import { SHA256 } from './crypto/SHA256/index.js';
const hasher = SHA256.create();
hasher.update(new Uint8Array([1, 2, 3]));
hasher.update(new Uint8Array([4, 5, 6]));
const hash = hasher.digest();
```

###### ~~from()~~

> **from**: (`input`) => [`SHA256Hash`](index/index.mdx#sha256hash)

Hash input with SHA256 (constructor pattern)

Auto-detects input type and hashes accordingly:
- Uint8Array: hash directly
- string starting with 0x: parse as hex
- string: UTF-8 encode then hash

###### Parameters

###### input

Data to hash

`string` | `Uint8Array`\<`ArrayBufferLike`\>

###### Returns

[`SHA256Hash`](index/index.mdx#sha256hash)

32-byte hash

###### See

https://voltaire.tevm.sh/crypto/sha256 for crypto documentation

###### Since

0.0.0

###### Throws

###### Example

```javascript
import { SHA256Hash } from './crypto/SHA256/index.js';

const hash1 = SHA256Hash.from("0x1234");      // Hex
const hash2 = SHA256Hash.from("hello");       // String
const hash3 = SHA256Hash.from(uint8array);    // Bytes
```

###### ~~fromHex()~~

> **fromHex**: (`hex`) => [`SHA256Hash`](index/index.mdx#sha256hash) = `hashHex`

Compute SHA256 hash of hex string (without 0x prefix)

###### Parameters

###### hex

`string`

Hex string (with or without 0x prefix)

###### Returns

[`SHA256Hash`](index/index.mdx#sha256hash)

32-byte hash

###### See

https://voltaire.tevm.sh/crypto for crypto documentation

###### Since

0.0.0

###### Throws

###### Example

```javascript
import { SHA256 } from './crypto/SHA256/index.js';
const hash = SHA256.hashHex("0xdeadbeef");
console.log(hash.length); // 32
```

###### ~~fromString()~~

> **fromString**: (`str`) => [`SHA256Hash`](index/index.mdx#sha256hash) = `hashString`

Compute SHA256 hash of UTF-8 string

###### Parameters

###### str

`string`

Input string

###### Returns

[`SHA256Hash`](index/index.mdx#sha256hash)

32-byte hash

###### See

https://voltaire.tevm.sh/crypto for crypto documentation

###### Since

0.0.0

###### Throws

###### Example

```javascript
import { SHA256 } from './crypto/SHA256/index.js';
const hash = SHA256.hashString("hello world");
console.log(hash.length); // 32
```

###### ~~hash()~~

> **hash**: (`data`) => [`SHA256Hash`](index/index.mdx#sha256hash)

Compute SHA256 hash of input data

###### Parameters

###### data

`Uint8Array`\<`ArrayBufferLike`\>

Input data as Uint8Array

###### Returns

[`SHA256Hash`](index/index.mdx#sha256hash)

32-byte hash

###### See

https://voltaire.tevm.sh/crypto for crypto documentation

###### Since

0.0.0

###### Throws

###### Example

```javascript
import { SHA256Hash } from './crypto/SHA256/index.js';
const hash = SHA256Hash.from(new Uint8Array([1, 2, 3]));
console.log(hash.length); // 32
```

###### ~~hashHex()~~

> **hashHex**: (`hex`) => [`SHA256Hash`](index/index.mdx#sha256hash)

Compute SHA256 hash of hex string (without 0x prefix)

###### Parameters

###### hex

`string`

Hex string (with or without 0x prefix)

###### Returns

[`SHA256Hash`](index/index.mdx#sha256hash)

32-byte hash

###### See

https://voltaire.tevm.sh/crypto for crypto documentation

###### Since

0.0.0

###### Throws

###### Example

```javascript
import { SHA256 } from './crypto/SHA256/index.js';
const hash = SHA256.hashHex("0xdeadbeef");
console.log(hash.length); // 32
```

###### ~~hashString()~~

> **hashString**: (`str`) => [`SHA256Hash`](index/index.mdx#sha256hash)

Compute SHA256 hash of UTF-8 string

###### Parameters

###### str

`string`

Input string

###### Returns

[`SHA256Hash`](index/index.mdx#sha256hash)

32-byte hash

###### See

https://voltaire.tevm.sh/crypto for crypto documentation

###### Since

0.0.0

###### Throws

###### Example

```javascript
import { SHA256 } from './crypto/SHA256/index.js';
const hash = SHA256.hashString("hello world");
console.log(hash.length); // 32
```

###### ~~OUTPUT\_SIZE~~

> **OUTPUT\_SIZE**: `number`

SHA256 output size in bytes (256 bits / 8)

###### See

https://voltaire.tevm.sh/crypto for crypto documentation

###### Since

0.0.0

###### Throws

###### Example

```javascript
import { OUTPUT_SIZE } from './crypto/SHA256/index.js';
console.log(OUTPUT_SIZE); // 32
```

###### ~~toHex()~~

> **toHex**: (`hash`) => `string`

Convert hash output to hex string

###### Parameters

###### hash

`Uint8Array`\<`ArrayBufferLike`\>

Hash bytes

###### Returns

`string`

Hex string with 0x prefix

###### See

https://voltaire.tevm.sh/crypto for crypto documentation

###### Since

0.0.0

###### Throws

###### Example

```javascript
import { SHA256 } from './crypto/SHA256/index.js';
const hash = SHA256.hash(new Uint8Array([1, 2, 3]));
const hexStr = SHA256.toHex(hash);
console.log(hexStr); // "0x..."
```

###### Deprecated

Use SHA256Hash instead
SHA256 alias maintained for backward compatibility

##### Siwe

> **Siwe**: *typeof* [`Siwe`](primitives/Siwe.mdx#siwe)

##### StorageKey

> **StorageKey**: `object`

###### StorageKey.create()

> **create**: (`address`, `slot`) => [`StorageKeyType`](primitives/State.mdx#storagekeytype)

###### Parameters

###### address

[`AddressType`](primitives/Address.mdx#addresstype)

###### slot

`bigint`

###### Returns

[`StorageKeyType`](primitives/State.mdx#storagekeytype)

###### StorageKey.equals()

> **equals**: (`a`, `b`) => `boolean`

###### Parameters

###### a

[`StorageKeyLike`](primitives/State.mdx#storagekeylike)

###### b

[`StorageKeyLike`](primitives/State.mdx#storagekeylike)

###### Returns

`boolean`

###### StorageKey.from()

> **from**: (`value`) => [`StorageKeyType`](primitives/State.mdx#storagekeytype)

###### Parameters

###### value

[`StorageKeyLike`](primitives/State.mdx#storagekeylike)

###### Returns

[`StorageKeyType`](primitives/State.mdx#storagekeytype)

###### StorageKey.fromString()

> **fromString**: (`str`) => [`StorageKeyType`](primitives/State.mdx#storagekeytype) \| `undefined`

###### Parameters

###### str

`string`

###### Returns

[`StorageKeyType`](primitives/State.mdx#storagekeytype) \| `undefined`

###### StorageKey.hashCode()

> **hashCode**: (`key`) => `number`

###### Parameters

###### key

[`StorageKeyLike`](primitives/State.mdx#storagekeylike)

###### Returns

`number`

###### StorageKey.is()

> **is**: (`value`) => `value is StorageKeyType`

###### Parameters

###### value

`unknown`

###### Returns

`value is StorageKeyType`

###### StorageKey.toString()

> **toString**: (`key`) => `string`

###### Parameters

###### key

[`StorageKeyLike`](primitives/State.mdx#storagekeylike)

###### Returns

`string`

##### Uint

> **Uint**: *typeof* [`Uint`](index/index.mdx#uint)

##### Wei

> **Wei**: `WeiConstructor`

##### X25519

> **X25519**: `object`

X25519 Elliptic Curve Diffie-Hellman

Curve25519 key exchange algorithm for secure shared secret generation.
Fast, simple, and designed for ECDH key agreement.
Used in modern protocols like TLS 1.3, WireGuard, Signal, and SSH.

###### See

https://voltaire.tevm.sh/crypto for crypto documentation

###### Since

0.0.0

###### Throws

###### Example

```javascript
import { X25519 } from './crypto/X25519/index.js';

// Generate two keypairs
const seed1 = crypto.getRandomValues(new Uint8Array(32));
const seed2 = crypto.getRandomValues(new Uint8Array(32));
const keypair1 = X25519.keypairFromSeed(seed1);
const keypair2 = X25519.keypairFromSeed(seed2);

// Perform key exchange
const shared1 = X25519.scalarmult(keypair1.secretKey, keypair2.publicKey);
const shared2 = X25519.scalarmult(keypair2.secretKey, keypair1.publicKey);
// shared1 === shared2 (same shared secret from both sides)
```

###### X25519.derivePublicKey()

> **derivePublicKey**: (`secretKey`) => [`PublicKey`](crypto/X25519.mdx#publickey)

Derive public key from secret key

###### Parameters

###### secretKey

[`SecretKey`](crypto/X25519.mdx#secretkey)

32-byte secret key

###### Returns

[`PublicKey`](crypto/X25519.mdx#publickey)

32-byte public key

###### See

https://voltaire.tevm.sh/crypto for crypto documentation

###### Since

0.0.0

###### Throws

If secret key is invalid

###### Example

```javascript
import { X25519 } from './crypto/X25519/index.js';
const secretKey = crypto.getRandomValues(new Uint8Array(32));
const publicKey = X25519.derivePublicKey(secretKey);
console.log(publicKey.length); // 32
```

###### X25519.generateKeypair()

> **generateKeypair**: () => `object`

Generate random keypair

Uses crypto.getRandomValues for secure random generation

###### Returns

`object`

Object with secretKey and publicKey

###### publicKey

> **publicKey**: [`PublicKey`](crypto/X25519.mdx#publickey)

###### secretKey

> **secretKey**: [`SecretKey`](crypto/X25519.mdx#secretkey)

###### See

https://voltaire.tevm.sh/crypto for crypto documentation

###### Since

0.0.0

###### Throws

###### Example

```javascript
import { X25519 } from './crypto/X25519/index.js';
const keypair = X25519.generateKeypair();
console.log(keypair.secretKey.length); // 32
console.log(keypair.publicKey.length); // 32
```

###### X25519.generateSecretKey()

> **generateSecretKey**: () => [`SecretKey`](crypto/X25519.mdx#secretkey)

Generate random secret key

Uses crypto.getRandomValues for secure random generation

###### Returns

[`SecretKey`](crypto/X25519.mdx#secretkey)

32-byte random secret key

###### See

https://voltaire.tevm.sh/crypto for crypto documentation

###### Since

0.0.0

###### Throws

###### Example

```javascript
import { X25519 } from './crypto/X25519/index.js';
const secretKey = X25519.generateSecretKey();
const publicKey = X25519.derivePublicKey(secretKey);
console.log(secretKey.length); // 32
```

###### X25519.keypairFromSeed()

> **keypairFromSeed**: (`seed`) => `object`

Generate X25519 keypair from seed

###### Parameters

###### seed

`Uint8Array`\<`ArrayBufferLike`\>

32-byte seed for deterministic generation

###### Returns

`object`

Object with secretKey and publicKey

###### publicKey

> **publicKey**: [`PublicKey`](crypto/X25519.mdx#publickey)

###### secretKey

> **secretKey**: [`SecretKey`](crypto/X25519.mdx#secretkey)

###### See

https://voltaire.tevm.sh/crypto for crypto documentation

###### Since

0.0.0

###### Throws

If seed length is invalid

###### Example

```javascript
import { X25519 } from './crypto/X25519/index.js';
const seed = crypto.getRandomValues(new Uint8Array(32));
const keypair = X25519.keypairFromSeed(seed);
console.log(keypair.secretKey.length); // 32
console.log(keypair.publicKey.length); // 32
```

###### X25519.PUBLIC\_KEY\_SIZE

> **PUBLIC\_KEY\_SIZE**: `32`

Public key size in bytes

###### See

https://voltaire.tevm.sh/crypto for crypto documentation

###### Since

0.0.0

###### Throws

###### Example

```javascript
import { PUBLIC_KEY_SIZE } from './crypto/X25519/index.js';
console.log(PUBLIC_KEY_SIZE); // 32
```

###### X25519.scalarmult()

> **scalarmult**: (`secretKey`, `publicKey`) => [`SharedSecret`](crypto/X25519.mdx#sharedsecret)

Perform X25519 scalar multiplication (ECDH)

Computes shared secret from your secret key and their public key.

###### Parameters

###### secretKey

[`SecretKey`](crypto/X25519.mdx#secretkey)

Your 32-byte secret key

###### publicKey

[`PublicKey`](crypto/X25519.mdx#publickey)

Their 32-byte public key

###### Returns

[`SharedSecret`](crypto/X25519.mdx#sharedsecret)

32-byte shared secret

###### See

https://voltaire.tevm.sh/crypto for crypto documentation

###### Since

0.0.0

###### Throws

If secret key is invalid

###### Throws

If public key is invalid

###### Throws

If scalar multiplication fails

###### Example

```javascript
import { X25519 } from './crypto/X25519/index.js';
const mySecret = crypto.getRandomValues(new Uint8Array(32));
const theirPublic = X25519.derivePublicKey(theirSecret);
const shared = X25519.scalarmult(mySecret, theirPublic);
console.log(shared.length); // 32
```

###### X25519.SECRET\_KEY\_SIZE

> **SECRET\_KEY\_SIZE**: `32`

Secret key size in bytes

###### See

https://voltaire.tevm.sh/crypto for crypto documentation

###### Since

0.0.0

###### Throws

###### Example

```javascript
import { SECRET_KEY_SIZE } from './crypto/X25519/index.js';
console.log(SECRET_KEY_SIZE); // 32
```

###### X25519.SHARED\_SECRET\_SIZE

> **SHARED\_SECRET\_SIZE**: `32`

Shared secret size in bytes

###### See

https://voltaire.tevm.sh/crypto for crypto documentation

###### Since

0.0.0

###### Throws

###### Example

```javascript
import { SHARED_SECRET_SIZE } from './crypto/X25519/index.js';
console.log(SHARED_SECRET_SIZE); // 32
```

###### X25519.validatePublicKey()

> **validatePublicKey**: (`publicKey`) => `boolean`

Validate a public key

Checks if the public key has correct length

###### Parameters

###### publicKey

[`PublicKey`](crypto/X25519.mdx#publickey)

Public key to validate

###### Returns

`boolean`

True if valid, false otherwise

###### See

https://voltaire.tevm.sh/crypto for crypto documentation

###### Since

0.0.0

###### Throws

###### Example

```javascript
import { X25519 } from './crypto/X25519/index.js';
const publicKey = new Uint8Array(32);
const valid = X25519.validatePublicKey(publicKey);
```

###### X25519.validateSecretKey()

> **validateSecretKey**: (`secretKey`) => `boolean`

Validate a secret key

Checks if the secret key has correct length and can derive a public key

###### Parameters

###### secretKey

[`SecretKey`](crypto/X25519.mdx#secretkey)

Secret key to validate

###### Returns

`boolean`

True if valid, false otherwise

###### See

https://voltaire.tevm.sh/crypto for crypto documentation

###### Since

0.0.0

###### Throws

###### Example

```javascript
import { X25519 } from './crypto/X25519/index.js';
const secretKey = new Uint8Array(32);
const valid = X25519.validateSecretKey(secretKey);
```

## Functions

### allocateOutput()

> **allocateOutput**(`size`): `Uint8Array`

Defined in: [src/native-loader/index.ts:64](https://github.com/evmts/voltaire/blob/bd6ec34405c15ad8cd51d11579d495dc53813482/src/native-loader/index.ts#L64)

Helper to allocate buffer for output

#### Parameters

##### size

`number`

#### Returns

`Uint8Array`

***

### allocateStringOutput()

> **allocateStringOutput**(`size`): `object`

Defined in: [src/native-loader/index.ts:71](https://github.com/evmts/voltaire/blob/bd6ec34405c15ad8cd51d11579d495dc53813482/src/native-loader/index.ts#L71)

Helper to allocate buffer for string output

#### Parameters

##### size

`number`

#### Returns

`object`

##### buffer

> **buffer**: `Uint8Array`

##### ptr

> **ptr**: `Uint8Array`

***

### checkError()

> **checkError**(`code`, `operation`): `void`

Defined in: [src/native-loader/index.ts:53](https://github.com/evmts/voltaire/blob/bd6ec34405c15ad8cd51d11579d495dc53813482/src/native-loader/index.ts#L53)

Check error code and throw if non-zero

#### Parameters

##### code

`number`

##### operation

`string`

#### Returns

`void`

***

### getNativeErrorMessage()

> **getNativeErrorMessage**(`code`): `string`

Defined in: [src/native-loader/types.ts:224](https://github.com/evmts/voltaire/blob/bd6ec34405c15ad8cd51d11579d495dc53813482/src/native-loader/types.ts#L224)

Convert native error code to error message

#### Parameters

##### code

`number`

#### Returns

`string`

***

### getNativeExtension()

> **getNativeExtension**(): `string`

Defined in: [src/native-loader/platform.ts:45](https://github.com/evmts/voltaire/blob/bd6ec34405c15ad8cd51d11579d495dc53813482/src/native-loader/platform.ts#L45)

Get file extension for native libraries on current platform

#### Returns

`string`

***

### getPlatform()

> **getPlatform**(): [`Platform`](#platform)

Defined in: [src/native-loader/platform.ts:15](https://github.com/evmts/voltaire/blob/bd6ec34405c15ad8cd51d11579d495dc53813482/src/native-loader/platform.ts#L15)

Get current platform identifier

#### Returns

[`Platform`](#platform)

***

### isBun()

> **isBun**(): `boolean`

Defined in: [src/native-loader/index.ts:19](https://github.com/evmts/voltaire/blob/bd6ec34405c15ad8cd51d11579d495dc53813482/src/native-loader/index.ts#L19)

Runtime environment detection

#### Returns

`boolean`

***

### isNativeSupported()

> **isNativeSupported**(): `boolean`

Defined in: [src/native-loader/platform.ts:63](https://github.com/evmts/voltaire/blob/bd6ec34405c15ad8cd51d11579d495dc53813482/src/native-loader/platform.ts#L63)

Check if native bindings are supported on current platform

#### Returns

`boolean`

***

### isNode()

> **isNode**(): `boolean`

Defined in: [src/native-loader/index.ts:23](https://github.com/evmts/voltaire/blob/bd6ec34405c15ad8cd51d11579d495dc53813482/src/native-loader/index.ts#L23)

#### Returns

`boolean`

***

### loadNative()

> **loadNative**(): `Promise`\<`NativeModule` \| `ConvertFns`\<\{ `primitives_abi_compute_selector`: \{ `args`: readonly \[`cstring`, `ptr`\]; `returns`: `int32_t`; \}; `primitives_address_equals`: \{ `args`: readonly \[`ptr`, `ptr`\]; `returns`: `bool`; \}; `primitives_address_from_hex`: \{ `args`: readonly \[`cstring`, `ptr`\]; `returns`: `int32_t`; \}; `primitives_address_is_zero`: \{ `args`: readonly \[`ptr`\]; `returns`: `bool`; \}; `primitives_address_to_checksum_hex`: \{ `args`: readonly \[`ptr`, `ptr`\]; `returns`: `int32_t`; \}; `primitives_address_to_hex`: \{ `args`: readonly \[`ptr`, `ptr`\]; `returns`: `int32_t`; \}; `primitives_blake2b`: \{ `args`: readonly \[`ptr`, `uint64_t`, `ptr`\]; `returns`: `int32_t`; \}; `primitives_bytes_to_hex`: \{ `args`: readonly \[`ptr`, `uint64_t`, `ptr`, `ptr`\]; `returns`: `int32_t`; \}; `primitives_hash_equals`: \{ `args`: readonly \[`ptr`, `ptr`\]; `returns`: `bool`; \}; `primitives_hash_from_hex`: \{ `args`: readonly \[`cstring`, `ptr`\]; `returns`: `int32_t`; \}; `primitives_hash_to_hex`: \{ `args`: readonly \[`ptr`, `ptr`\]; `returns`: `int32_t`; \}; `primitives_hex_to_bytes`: \{ `args`: readonly \[`cstring`, `ptr`, `ptr`\]; `returns`: `int32_t`; \}; `primitives_keccak256`: \{ `args`: readonly \[`ptr`, `uint64_t`, `ptr`\]; `returns`: `int32_t`; \}; `primitives_ripemd160`: \{ `args`: readonly \[`ptr`, `uint64_t`, `ptr`\]; `returns`: `int32_t`; \}; `primitives_secp256k1_recover_address`: \{ `args`: readonly \[`ptr`, `int32_t`, `ptr`, `ptr`\]; `returns`: `int32_t`; \}; `primitives_sha256`: \{ `args`: readonly \[`ptr`, `uint64_t`, `ptr`\]; `returns`: `int32_t`; \}; `primitives_solidity_keccak256`: \{ `args`: readonly \[`ptr`, `uint64_t`, `ptr`\]; `returns`: `int32_t`; \}; `primitives_solidity_sha256`: \{ `args`: readonly \[`ptr`, `uint64_t`, `ptr`\]; `returns`: `int32_t`; \}; `secp256k1DerivePublicKey`: \{ `args`: readonly \[`ptr`, `ptr`\]; `returns`: `int32_t`; \}; `secp256k1Sign`: \{ `args`: readonly \[`ptr`, `ptr`, `ptr`\]; `returns`: `int32_t`; \}; `secp256k1Verify`: \{ `args`: readonly \[`ptr`, `ptr`, `ptr`\]; `returns`: `bool`; \}; \}\>\>

Defined in: [src/native-loader/index.ts:34](https://github.com/evmts/voltaire/blob/bd6ec34405c15ad8cd51d11579d495dc53813482/src/native-loader/index.ts#L34)

Load native library using appropriate loader

#### Returns

`Promise`\<`NativeModule` \| `ConvertFns`\<\{ `primitives_abi_compute_selector`: \{ `args`: readonly \[`cstring`, `ptr`\]; `returns`: `int32_t`; \}; `primitives_address_equals`: \{ `args`: readonly \[`ptr`, `ptr`\]; `returns`: `bool`; \}; `primitives_address_from_hex`: \{ `args`: readonly \[`cstring`, `ptr`\]; `returns`: `int32_t`; \}; `primitives_address_is_zero`: \{ `args`: readonly \[`ptr`\]; `returns`: `bool`; \}; `primitives_address_to_checksum_hex`: \{ `args`: readonly \[`ptr`, `ptr`\]; `returns`: `int32_t`; \}; `primitives_address_to_hex`: \{ `args`: readonly \[`ptr`, `ptr`\]; `returns`: `int32_t`; \}; `primitives_blake2b`: \{ `args`: readonly \[`ptr`, `uint64_t`, `ptr`\]; `returns`: `int32_t`; \}; `primitives_bytes_to_hex`: \{ `args`: readonly \[`ptr`, `uint64_t`, `ptr`, `ptr`\]; `returns`: `int32_t`; \}; `primitives_hash_equals`: \{ `args`: readonly \[`ptr`, `ptr`\]; `returns`: `bool`; \}; `primitives_hash_from_hex`: \{ `args`: readonly \[`cstring`, `ptr`\]; `returns`: `int32_t`; \}; `primitives_hash_to_hex`: \{ `args`: readonly \[`ptr`, `ptr`\]; `returns`: `int32_t`; \}; `primitives_hex_to_bytes`: \{ `args`: readonly \[`cstring`, `ptr`, `ptr`\]; `returns`: `int32_t`; \}; `primitives_keccak256`: \{ `args`: readonly \[`ptr`, `uint64_t`, `ptr`\]; `returns`: `int32_t`; \}; `primitives_ripemd160`: \{ `args`: readonly \[`ptr`, `uint64_t`, `ptr`\]; `returns`: `int32_t`; \}; `primitives_secp256k1_recover_address`: \{ `args`: readonly \[`ptr`, `int32_t`, `ptr`, `ptr`\]; `returns`: `int32_t`; \}; `primitives_sha256`: \{ `args`: readonly \[`ptr`, `uint64_t`, `ptr`\]; `returns`: `int32_t`; \}; `primitives_solidity_keccak256`: \{ `args`: readonly \[`ptr`, `uint64_t`, `ptr`\]; `returns`: `int32_t`; \}; `primitives_solidity_sha256`: \{ `args`: readonly \[`ptr`, `uint64_t`, `ptr`\]; `returns`: `int32_t`; \}; `secp256k1DerivePublicKey`: \{ `args`: readonly \[`ptr`, `ptr`\]; `returns`: `int32_t`; \}; `secp256k1Sign`: \{ `args`: readonly \[`ptr`, `ptr`, `ptr`\]; `returns`: `int32_t`; \}; `secp256k1Verify`: \{ `args`: readonly \[`ptr`, `ptr`, `ptr`\]; `returns`: `bool`; \}; \}\>\>

## References

### Abi

Re-exports [Abi](primitives/Abi/index.mdx#abi)

***

### AbstractError

Re-exports [AbstractError](index/index.mdx#abstracterror)

***

### AccessList

Re-exports [AccessList](primitives/AccessList.mdx#accesslist)

***

### Address

Re-exports [Address](primitives/Address.mdx#address)

***

### AesGcm

Re-exports [AesGcm](crypto/AesGcm.mdx#aesgcm)

***

### Authorization

Renames and re-exports [primitives/Authorization](primitives/Authorization.mdx)

***

### Base64

Renames and re-exports [primitives/Base64](primitives/Base64.mdx)

***

### BeaconBlockRoot

Renames and re-exports [primitives/BeaconBlockRoot](primitives/BeaconBlockRoot.mdx)

***

### BinaryTree

Renames and re-exports [primitives/BinaryTree](primitives/BinaryTree.mdx)

***

### Bip39

Re-exports [Bip39](crypto/Bip39.mdx#bip39)

***

### Blake2

Re-exports [Blake2](crypto/Blake2.mdx#blake2)

***

### Blake2Hash

Re-exports [Blake2Hash](index/index.mdx#blake2hash)

***

### Blake2HashType

Renames and re-exports [Blake2Hash](index/index.mdx#blake2hash)

***

### Blob

Re-exports [Blob](primitives/Blob.mdx#blob)

***

### Block

Renames and re-exports [primitives/Block](primitives/Block.mdx)

***

### BlockBody

Renames and re-exports [primitives/BlockBody](primitives/BlockBody.mdx)

***

### BlockFilter

Renames and re-exports [primitives/BlockFilter](primitives/BlockFilter.mdx)

***

### BlockHash

Renames and re-exports [primitives/BlockHash](primitives/BlockHash.mdx)

***

### BlockHeader

Renames and re-exports [primitives/BlockHeader](primitives/BlockHeader.mdx)

***

### BlockNumber

Renames and re-exports [primitives/BlockNumber](primitives/BlockNumber.mdx)

***

### BloomFilter

Re-exports [BloomFilter](primitives/BloomFilter.mdx#bloomfilter)

***

### Bls12381

Re-exports [Bls12381](crypto/Bls12381/index.mdx#bls12381)

***

### Bls12381Fp2Type

Re-exports [Bls12381Fp2Type](index/index.mdx#bls12381fp2type)

***

### Bls12381G1PointType

Re-exports [Bls12381G1PointType](index/index.mdx#bls12381g1pointtype)

***

### Bls12381G2PointType

Re-exports [Bls12381G2PointType](index/index.mdx#bls12381g2pointtype)

***

### BN254

Re-exports [BN254](index/index.mdx#bn254)

***

### BrandedAbi

Renames and re-exports [primitives/Abi](primitives/Abi/index.mdx)

***

### BrandedAccessList

Renames and re-exports [primitives/AccessList](primitives/AccessList.mdx)

***

### BrandedAddress

Re-exports [BrandedAddress](index/namespaces/BrandedAddress/index.mdx)

***

### BrandedAuthorization

Renames and re-exports [primitives/Authorization](primitives/Authorization.mdx)

***

### BrandedBase64

Re-exports [BrandedBase64](index/namespaces/BrandedBase64.mdx)

***

### BrandedBinaryTree

Renames and re-exports [primitives/BinaryTree](primitives/BinaryTree.mdx)

***

### BrandedBlob

Renames and re-exports [primitives/Blob](primitives/Blob.mdx)

***

### BrandedBloomFilter

Renames and re-exports [primitives/BloomFilter](primitives/BloomFilter.mdx)

***

### BrandedBytecode

Renames and re-exports [primitives/Bytecode](primitives/Bytecode.mdx)

***

### BrandedBytes

Re-exports [BrandedBytes](index/namespaces/BrandedBytes.mdx)

***

### BrandedBytes1

Re-exports [BrandedBytes1](index/namespaces/BrandedBytes1.mdx)

***

### BrandedBytes16

Re-exports [BrandedBytes16](index/namespaces/BrandedBytes16.mdx)

***

### BrandedBytes2

Re-exports [BrandedBytes2](index/namespaces/BrandedBytes2.mdx)

***

### BrandedBytes3

Re-exports [BrandedBytes3](index/namespaces/BrandedBytes3.mdx)

***

### BrandedBytes32

Re-exports [BrandedBytes32](index/namespaces/BrandedBytes32.mdx)

***

### BrandedBytes4

Re-exports [BrandedBytes4](index/namespaces/BrandedBytes4.mdx)

***

### BrandedBytes5

Re-exports [BrandedBytes5](index/namespaces/BrandedBytes5.mdx)

***

### BrandedBytes6

Re-exports [BrandedBytes6](index/namespaces/BrandedBytes6.mdx)

***

### BrandedBytes64

Re-exports [BrandedBytes64](index/namespaces/BrandedBytes64.mdx)

***

### BrandedBytes7

Re-exports [BrandedBytes7](index/namespaces/BrandedBytes7.mdx)

***

### BrandedBytes8

Re-exports [BrandedBytes8](index/namespaces/BrandedBytes8.mdx)

***

### BrandedChain

Re-exports [BrandedChain](index/namespaces/BrandedChain.mdx)

***

### BrandedEther

Re-exports [BrandedEther](index/namespaces/BrandedEther.mdx)

***

### BrandedEventLog

Renames and re-exports [primitives/EventLog](primitives/EventLog.mdx)

***

### BrandedFeeMarket

Re-exports [BrandedFeeMarket](index/namespaces/BrandedFeeMarket.mdx)

***

### BrandedGwei

Re-exports [BrandedGwei](index/namespaces/BrandedGwei.mdx)

***

### BrandedHash

Renames and re-exports [primitives/Hash](primitives/Hash.mdx)

***

### BrandedHex

Re-exports [BrandedHex](index/namespaces/BrandedHex.mdx)

***

### BrandedInt128

Renames and re-exports [primitives/Int128](primitives/Int128.mdx)

***

### BrandedInt16

Renames and re-exports [primitives/Int16](primitives/Int16.mdx)

***

### BrandedInt256

Renames and re-exports [primitives/Int256](primitives/Int256.mdx)

***

### BrandedInt32

Renames and re-exports [primitives/Int32](primitives/Int32.mdx)

***

### BrandedInt64

Renames and re-exports [primitives/Int64](primitives/Int64.mdx)

***

### BrandedInt8

Renames and re-exports [primitives/Int8](primitives/Int8.mdx)

***

### BrandedOpcode

Re-exports [BrandedOpcode](index/namespaces/BrandedOpcode.mdx)

***

### BrandedRlp

Re-exports [BrandedRlp](index/namespaces/BrandedRlp.mdx)

***

### BrandedSiwe

Renames and re-exports [primitives/Siwe](primitives/Siwe.mdx)

***

### BrandedStorageKey

Renames and re-exports [primitives/State](primitives/State.mdx)

***

### BrandedUint

Renames and re-exports [primitives/Uint](primitives/Uint.mdx)

***

### BrandedUint128

Renames and re-exports [primitives/Uint128](primitives/Uint128.mdx)

***

### BrandedUint16

Renames and re-exports [primitives/Uint16](primitives/Uint16.mdx)

***

### BrandedUint32

Renames and re-exports [primitives/Uint32](primitives/Uint32.mdx)

***

### BrandedUint64

Renames and re-exports [primitives/Uint64](primitives/Uint64.mdx)

***

### BrandedUint8

Renames and re-exports [primitives/Uint8](primitives/Uint8.mdx)

***

### BrandedWei

Re-exports [BrandedWei](index/namespaces/BrandedWei.mdx)

***

### Bytecode

Re-exports [Bytecode](primitives/Bytecode.mdx#bytecode)

***

### Bytes

Re-exports [Bytes](index/index.mdx#bytes)

***

### Bytes1

Re-exports [Bytes1](index/namespaces/BrandedBytes1.mdx#bytes1)

***

### Bytes16

Re-exports [Bytes16](index/namespaces/BrandedBytes16.mdx#bytes16)

***

### Bytes2

Re-exports [Bytes2](index/index.mdx#bytes2)

***

### Bytes3

Re-exports [Bytes3](index/index.mdx#bytes3)

***

### Bytes32

Re-exports [Bytes32](index/namespaces/BrandedBytes32.mdx#bytes32)

***

### Bytes4

Re-exports [Bytes4](index/namespaces/BrandedBytes4.mdx#bytes4)

***

### Bytes5

Re-exports [Bytes5](index/index.mdx#bytes5)

***

### Bytes6

Re-exports [Bytes6](index/index.mdx#bytes6)

***

### Bytes64

Re-exports [Bytes64](index/namespaces/BrandedBytes64.mdx#bytes64)

***

### Bytes7

Re-exports [Bytes7](index/index.mdx#bytes7)

***

### Bytes8

Re-exports [Bytes8](index/namespaces/BrandedBytes8.mdx#bytes8)

***

### CallTrace

Renames and re-exports [primitives/CallTrace](primitives/CallTrace.mdx)

***

### ChaCha20Poly1305

Re-exports [ChaCha20Poly1305](crypto/ChaCha20Poly1305.mdx#chacha20poly1305)

***

### Chain

Re-exports [Chain](index/namespaces/BrandedChain.mdx#chain-1)

***

### ChainHead

Renames and re-exports [primitives/ChainHead](primitives/ChainHead.mdx)

***

### CompilerVersion

Renames and re-exports [primitives/CompilerVersion](primitives/CompilerVersion.mdx)

***

### ContractCode

Renames and re-exports [primitives/ContractCode](primitives/ContractCode.mdx)

***

### ContractResult

Renames and re-exports [primitives/ContractResult](primitives/ContractResult.mdx)

***

### ContractSignature

Renames and re-exports [primitives/ContractSignature](primitives/ContractSignature.mdx)

***

### CryptoError

Re-exports [CryptoError](index/index.mdx#cryptoerror)

***

### DecodedData

Renames and re-exports [primitives/DecodedData](primitives/DecodedData.mdx)

***

### DecodingError

Re-exports [DecodingError](index/index.mdx#decodingerror)

***

### Domain

Renames and re-exports [primitives/Domain](primitives/Domain.mdx)

***

### DomainSeparator

Renames and re-exports [primitives/DomainSeparator](primitives/DomainSeparator.mdx)

***

### Ed25519

Re-exports [Ed25519](crypto/Ed25519.mdx#ed25519)

***

### EIP712

Re-exports [EIP712](crypto/EIP712.mdx#eip712)

***

### EncodedData

Renames and re-exports [primitives/EncodedData](primitives/EncodedData.mdx)

***

### EncodingError

Re-exports [EncodingError](index/index.mdx#encodingerror)

***

### Ens

Renames and re-exports [primitives/Ens](primitives/Ens.mdx)

***

### Epoch

Renames and re-exports [primitives/Epoch](primitives/Epoch.mdx)

***

### ERC1155

Re-exports [ERC1155](index/namespaces/ERC1155.mdx)

***

### ERC165

Re-exports [ERC165](index/namespaces/ERC165.mdx)

***

### ERC20

Re-exports [ERC20](index/namespaces/ERC20.mdx)

***

### ERC721

Re-exports [ERC721](index/namespaces/ERC721.mdx)

***

### ErrorSignature

Renames and re-exports [primitives/ErrorSignature](primitives/ErrorSignature.mdx)

***

### Ether

Re-exports [Ether](index/index.mdx#ether-1)

***

### EventLog

Renames and re-exports [primitives/EventLog](primitives/EventLog.mdx)

***

### EventSignature

Renames and re-exports [primitives/EventSignature](primitives/EventSignature.mdx)

***

### evm

Re-exports [evm](evm/index.mdx)

***

### FeeMarket

Re-exports [FeeMarket](index/namespaces/FeeMarket.mdx)

***

### FilterId

Renames and re-exports [primitives/FilterId](primitives/FilterId.mdx)

***

### ForkId

Renames and re-exports [primitives/ForkId](primitives/ForkId.mdx)

***

### FunctionSignature

Renames and re-exports [primitives/FunctionSignature](primitives/FunctionSignature.mdx)

***

### Gas

Renames and re-exports [primitives/Gas](primitives/Gas.mdx)

***

### GasConstants

Renames and re-exports [primitives/GasConstants](primitives/GasConstants/index.mdx)

***

### GasCosts

Re-exports [GasCosts](GasCosts.mdx)

***

### GasEstimate

Renames and re-exports [primitives/GasEstimate](primitives/GasEstimate.mdx)

***

### GasRefund

Renames and re-exports [primitives/GasRefund](primitives/GasRefund.mdx)

***

### GasUsed

Renames and re-exports [primitives/GasUsed](primitives/GasUsed.mdx)

***

### Gwei

Re-exports [Gwei](index/index.mdx#gwei-1)

***

### Hardfork

Renames and re-exports [primitives/Hardfork](primitives/Hardfork.mdx)

***

### Hash

Re-exports [Hash](index/index.mdx#hash)

***

### HashType

Re-exports [HashType](index/namespaces/HashType.mdx)

***

### HDWallet

Re-exports [HDWallet](HDWallet.mdx)

***

### Hex

Re-exports [Hex](index/index.mdx#hex)

***

### InitCode

Renames and re-exports [primitives/InitCode](primitives/InitCode.mdx)

***

### Int128

Re-exports [Int128](index/index.mdx#int128)

***

### Int16

Re-exports [Int16](index/index.mdx#int16)

***

### Int256

Re-exports [Int256](index/index.mdx#int256)

***

### Int32

Re-exports [Int32](index/index.mdx#int32)

***

### Int64

Re-exports [Int64](index/index.mdx#int64)

***

### Int8

Re-exports [Int8](index/index.mdx#int8)

***

### IntegerOverflowError

Re-exports [IntegerOverflowError](index/index.mdx#integeroverflowerror)

***

### IntegerUnderflowError

Re-exports [IntegerUnderflowError](index/index.mdx#integerunderflowerror)

***

### InvalidChecksumError

Re-exports [InvalidChecksumError](index/index.mdx#invalidchecksumerror)

***

### InvalidFormatError

Re-exports [InvalidFormatError](index/index.mdx#invalidformaterror)

***

### InvalidLengthError

Re-exports [InvalidLengthError](index/index.mdx#invalidlengtherror)

***

### InvalidPrivateKeyError

Re-exports [InvalidPrivateKeyError](index/index.mdx#invalidprivatekeyerror)

***

### InvalidPublicKeyError

Re-exports [InvalidPublicKeyError](index/index.mdx#invalidpublickeyerror)

***

### InvalidRangeError

Re-exports [InvalidRangeError](index/index.mdx#invalidrangeerror)

***

### InvalidSignatureError

Re-exports [InvalidSignatureError](index/index.mdx#invalidsignatureerror)

***

### InvalidSignerError

Re-exports [InvalidSignerError](index/index.mdx#invalidsignererror)

***

### InvalidSizeError

Re-exports [InvalidSizeError](index/index.mdx#invalidsizeerror)

***

### InvalidTransactionTypeError

Re-exports [InvalidTransactionTypeError](index/index.mdx#invalidtransactiontypeerror)

***

### Keccak256Hash

Re-exports [Keccak256Hash](index/index.mdx#keccak256hash)

***

### Keccak256HashType

Renames and re-exports [Keccak256Hash](index/index.mdx#keccak256hash)

***

### Keccak256Native

Renames and re-exports [Keccak256](#keccak256)

***

### Keystore

Renames and re-exports [crypto/Keystore](crypto/Keystore.mdx)

***

### KZG

Re-exports [KZG](index/index.mdx#kzg)

***

### KzgBlobType

Renames and re-exports [BlobType](crypto/KZG.mdx#blobtype)

***

### KzgCommitmentType

Re-exports [KzgCommitmentType](crypto/KZG.mdx#kzgcommitmenttype)

***

### KzgProofType

Re-exports [KzgProofType](crypto/KZG.mdx#kzgprooftype)

***

### License

Renames and re-exports [primitives/License](primitives/License.mdx)

***

### LogFilter

Renames and re-exports [primitives/LogFilter](primitives/LogFilter.mdx)

***

### LogIndex

Renames and re-exports [primitives/LogIndex](primitives/LogIndex.mdx)

***

### MemoryDump

Renames and re-exports [primitives/MemoryDump](primitives/MemoryDump.mdx)

***

### Metadata

Renames and re-exports [primitives/Metadata](primitives/Metadata.mdx)

***

### ModExp

Re-exports [ModExp](crypto/ModExp.mdx#modexp)

***

### NativeErrorCodeType

Renames and re-exports [NativeErrorCode](#nativeerrorcode)

***

### NetworkId

Renames and re-exports [primitives/NetworkId](primitives/NetworkId.mdx)

***

### NodeInfo

Renames and re-exports [primitives/NodeInfo](primitives/NodeInfo.mdx)

***

### Opcode

Re-exports [Opcode](index/index.mdx#opcode)

***

### OpStep

Renames and re-exports [primitives/OpStep](primitives/OpStep.mdx)

***

### P256

Re-exports [P256](crypto/P256.mdx#p256)

***

### PeerId

Renames and re-exports [primitives/PeerId](primitives/PeerId.mdx)

***

### PeerInfo

Renames and re-exports [primitives/PeerInfo](primitives/PeerInfo.mdx)

***

### PendingTransactionFilter

Renames and re-exports [primitives/PendingTransactionFilter](primitives/PendingTransactionFilter.mdx)

***

### Permit

Renames and re-exports [primitives/Permit](primitives/Permit/index.mdx)

***

### precompiles

Re-exports [precompiles](index/namespaces/precompiles.mdx)

***

### PrimitiveError

Re-exports [PrimitiveError](index/index.mdx#primitiveerror)

***

### ProtocolVersion

Renames and re-exports [primitives/ProtocolVersion](primitives/ProtocolVersion.mdx)

***

### Proxy

Re-exports [Proxy](Proxy.mdx)

***

### Receipt

Renames and re-exports [primitives/Receipt](primitives/Receipt.mdx)

***

### ReturnData

Renames and re-exports [primitives/ReturnData](primitives/ReturnData.mdx)

***

### RevertReason

Renames and re-exports [primitives/RevertReason](primitives/RevertReason.mdx)

***

### Ripemd160

Re-exports [Ripemd160](crypto/Ripemd160.mdx#ripemd160)

***

### Ripemd160Hash

Re-exports [Ripemd160Hash](index/index.mdx#ripemd160hash)

***

### Ripemd160HashType

Renames and re-exports [Ripemd160Hash](index/index.mdx#ripemd160hash)

***

### Rlp

Re-exports [Rlp](primitives/Rlp.mdx#rlp)

***

### RuntimeCode

Renames and re-exports [primitives/RuntimeCode](primitives/RuntimeCode.mdx)

***

### Secp256k1

Re-exports [Secp256k1](crypto/Secp256k1.mdx#secp256k1)

***

### Selector

Renames and re-exports [primitives/Selector](primitives/Selector.mdx)

***

### SerializationError

Re-exports [SerializationError](index/index.mdx#serializationerror)

***

### SHA256

Re-exports [SHA256](crypto/SHA256.mdx#sha256)

***

### SHA256Hash

Re-exports [SHA256Hash](index/index.mdx#sha256hash)

***

### SHA256HashType

Renames and re-exports [SHA256Hash](index/index.mdx#sha256hash)

***

### SignedData

Renames and re-exports [primitives/SignedData](primitives/SignedData.mdx)

***

### Siwe

Re-exports [Siwe](primitives/Siwe.mdx#siwe)

***

### Slot

Renames and re-exports [primitives/Slot](primitives/Slot.mdx)

***

### SourceMap

Renames and re-exports [primitives/SourceMap](primitives/SourceMap.mdx)

***

### Ssz

Re-exports [Ssz](Ssz.mdx)

***

### State

Renames and re-exports [primitives/State](primitives/State.mdx)

***

### StateDiff

Renames and re-exports [primitives/StateDiff](primitives/StateDiff.mdx)

***

### StealthAddress

Renames and re-exports [primitives/StealthAddress](primitives/StealthAddress.mdx)

***

### Storage

Re-exports [Storage](Storage.mdx)

***

### StorageDiff

Renames and re-exports [primitives/StorageDiff](primitives/StorageDiff.mdx)

***

### StorageKey

Re-exports [StorageKey](primitives/State.mdx#storagekey)

***

### StructLog

Renames and re-exports [primitives/StructLog](primitives/StructLog.mdx)

***

### SyncStatus

Renames and re-exports [primitives/SyncStatus](primitives/SyncStatus.mdx)

***

### TopicFilter

Renames and re-exports [primitives/TopicFilter](primitives/TopicFilter.mdx)

***

### TraceConfig

Renames and re-exports [primitives/TraceConfig](primitives/TraceConfig.mdx)

***

### TraceResult

Renames and re-exports [primitives/TraceResult](primitives/TraceResult.mdx)

***

### Transaction

Renames and re-exports [primitives/Transaction](primitives/Transaction/index.mdx)

***

### TransactionError

Re-exports [TransactionError](index/index.mdx#transactionerror)

***

### TransactionHash

Renames and re-exports [primitives/TransactionHash](primitives/TransactionHash.mdx)

***

### TransactionIndex

Renames and re-exports [primitives/TransactionIndex](primitives/TransactionIndex.mdx)

***

### TransactionStatus

Renames and re-exports [primitives/TransactionStatus](primitives/TransactionStatus.mdx)

***

### TransactionUrl

Re-exports [TransactionUrl](TransactionUrl.mdx)

***

### TypedData

Renames and re-exports [primitives/TypedData](primitives/TypedData.mdx)

***

### Uint

Re-exports [Uint](index/index.mdx#uint)

***

### Uint128

Re-exports [Uint128](index/index.mdx#uint128)

***

### Uint16

Re-exports [Uint16](index/index.mdx#uint16)

***

### Uint256

Renames and re-exports [primitives/Uint](primitives/Uint.mdx)

***

### Uint32

Re-exports [Uint32](index/index.mdx#uint32)

***

### Uint64

Re-exports [Uint64](index/index.mdx#uint64)

***

### Uint8

Re-exports [Uint8](index/index.mdx#uint8)

***

### Uncle

Renames and re-exports [primitives/Uncle](primitives/Uncle.mdx)

***

### ValidationError

Re-exports [ValidationError](index/index.mdx#validationerror)

***

### ValidatorIndex

Renames and re-exports [primitives/ValidatorIndex](primitives/ValidatorIndex.mdx)

***

### wasm

Re-exports [wasm](index/namespaces/wasm/index.mdx)

***

### Wei

Re-exports [Wei](index/index.mdx#wei-1)

***

### Withdrawal

Renames and re-exports [primitives/Withdrawal](primitives/Withdrawal.mdx)

***

### WithdrawalIndex

Renames and re-exports [primitives/WithdrawalIndex](primitives/WithdrawalIndex.mdx)

***

### X25519

Re-exports [X25519](crypto/X25519.mdx#x25519)
