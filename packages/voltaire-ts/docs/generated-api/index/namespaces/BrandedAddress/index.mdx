---
description: Auto-generated TypeScript API documentation from source code
title: Generated API Reference
---

[**@tevm/voltaire**](../../../index.mdx)

***

[@tevm/voltaire](../../../index.mdx) / [index](../../index.mdx) / BrandedAddress

# BrandedAddress

## Namespaces

- [Checksummed](namespaces/Checksummed.mdx)
- [Lowercase](namespaces/Lowercase.mdx)
- [Uppercase](namespaces/Uppercase.mdx)

## Variables

### BrandedAddress

> `const` **BrandedAddress**: `object`

Defined in: [src/primitives/Address/internal-index.ts:156](https://github.com/evmts/voltaire/blob/bd6ec34405c15ad8cd51d11579d495dc53813482/src/primitives/Address/internal-index.ts#L156)

#### Type Declaration

##### assert()

> **assert**: (`value`, `options?`) => [`AddressType`](../../../primitives/Address.mdx#addresstype) = `assertWithKeccak`

###### Parameters

###### value

`string` | `Uint8Array`\<`ArrayBufferLike`\>

###### options?

###### strict?

`boolean`

###### Returns

[`AddressType`](../../../primitives/Address.mdx#addresstype)

##### Assert()

> **Assert**: (`deps`) => (`value`, `options?`) => [`AddressType`](../../../primitives/Address.mdx#addresstype)

Factory: Create assert function with keccak256 injected

###### Parameters

###### deps

Crypto dependencies

###### keccak256

(`data`) => `Uint8Array`

###### Returns

> (`value`, `options?`): [`AddressType`](../../../primitives/Address.mdx#addresstype)

###### Parameters

###### value

`string` | `Uint8Array`\<`ArrayBufferLike`\>

###### options?

###### strict?

`boolean`

###### Returns

[`AddressType`](../../../primitives/Address.mdx#addresstype)

##### calculateCreate2Address()

> **calculateCreate2Address**: (`arg0`, `arg1`, `arg2`) => [`AddressType`](../../../primitives/Address.mdx#addresstype)

Calculate CREATE2 contract address (with auto-injected keccak256)

For tree-shakeable version without auto-injected crypto, use `CalculateCreate2Address({ keccak256 })` factory

###### Parameters

###### arg0

[`AddressType`](../../../primitives/Address.mdx#addresstype)

###### arg1

[`HashType`](../HashType.mdx#hashtype)

###### arg2

`BrandedBytecode`

###### Returns

[`AddressType`](../../../primitives/Address.mdx#addresstype)

##### CalculateCreate2Address()

> **CalculateCreate2Address**: (`deps`) => (`arg0`, `arg1`, `arg2`) => [`AddressType`](../../../primitives/Address.mdx#addresstype) = `CalculateCreate2AddressFactory`

Factory function to create calculateCreate2Address with injected keccak256 dependency

###### Parameters

###### deps

Dependencies

###### keccak256

(`data`) => `Uint8Array`

Keccak256 hash function

###### Returns

> (`arg0`, `arg1`, `arg2`): [`AddressType`](../../../primitives/Address.mdx#addresstype)

###### Parameters

###### arg0

[`AddressType`](../../../primitives/Address.mdx#addresstype)

###### arg1

[`HashType`](../HashType.mdx#hashtype)

###### arg2

`BrandedBytecode`

###### Returns

[`AddressType`](../../../primitives/Address.mdx#addresstype)

##### calculateCreateAddress()

> **calculateCreateAddress**: (`address`, `nonce`) => [`AddressType`](../../../primitives/Address.mdx#addresstype)

Calculate CREATE contract address (with auto-injected keccak256 and rlpEncode)

For tree-shakeable version without auto-injected crypto, use `CalculateCreateAddress({ keccak256, rlpEncode })` factory

###### Parameters

###### address

[`AddressType`](../../../primitives/Address.mdx#addresstype)

###### nonce

`bigint`

###### Returns

[`AddressType`](../../../primitives/Address.mdx#addresstype)

##### CalculateCreateAddress()

> **CalculateCreateAddress**: (`deps`) => (`address`, `nonce`) => [`AddressType`](../../../primitives/Address.mdx#addresstype) = `CalculateCreateAddressFactory`

Factory for CREATE contract address calculation with injected dependencies

###### Parameters

###### deps

Dependencies

###### keccak256

(`data`) => `Uint8Array`

Keccak256 hash function

###### rlpEncode

(`items`) => `Uint8Array`

RLP encode function

###### Returns

> (`address`, `nonce`): [`AddressType`](../../../primitives/Address.mdx#addresstype)

###### Parameters

###### address

[`AddressType`](../../../primitives/Address.mdx#addresstype)

###### nonce

`bigint`

###### Returns

[`AddressType`](../../../primitives/Address.mdx#addresstype)

###### Example

```typescript
import { hash } from '../../../crypto/Keccak256/hash.js'
import { encode } from '../../Rlp/encode.js'
const calculateCreateAddress = CalculateCreateAddress({
  keccak256: hash,
  rlpEncode: encode
})
const contractAddr = calculateCreateAddress(deployerAddr, 5n);
```

##### Checksummed

> **Checksummed**: [`Checksummed`](namespaces/Checksummed.mdx)

##### clone()

> **clone**: (`address`) => [`AddressType`](../../../primitives/Address.mdx#addresstype)

Create a deep copy of an Address

###### Parameters

###### address

[`AddressType`](../../../primitives/Address.mdx#addresstype)

Address to clone

###### Returns

[`AddressType`](../../../primitives/Address.mdx#addresstype)

Deep copy

###### Example

```typescript
const addr1 = Address.from("0x742d35Cc6634C0532925a3b844Bc9e7595f251e3");
const addr2 = Address.clone(addr1);
console.log(Address.equals(addr1, addr2)); // true
console.log(addr1 === addr2); // false
```

##### compare()

> **compare**: (`address`, `other`) => `number`

Compare two addresses lexicographically

###### Parameters

###### address

[`AddressType`](../../../primitives/Address.mdx#addresstype)

First address

###### other

[`AddressType`](../../../primitives/Address.mdx#addresstype)

Address to compare with

###### Returns

`number`

-1 if address < other, 0 if equal, 1 if address > other

###### Example

```typescript
const sorted = addresses.sort((a, b) => Address.compare(a, b));
```

##### deduplicateAddresses()

> **deduplicateAddresses**: (`addresses`) => [`AddressType`](../../../primitives/Address.mdx#addresstype)[]

Remove duplicate addresses from array
Preserves first occurrence of each unique address

###### Parameters

###### addresses

[`AddressType`](../../../primitives/Address.mdx#addresstype)[]

Addresses to deduplicate

###### Returns

[`AddressType`](../../../primitives/Address.mdx#addresstype)[]

Deduplicated addresses (new array)

###### Example

```typescript
const unique = Address.deduplicateAddresses([addr1, addr2, addr1, addr3]);
// Returns [addr1, addr2, addr3]
```

##### equals()

> **equals**: (`address`, `other`) => `boolean`

Check if two addresses are equal

###### Parameters

###### address

[`AddressType`](../../../primitives/Address.mdx#addresstype)

First address

###### other

[`AddressType`](../../../primitives/Address.mdx#addresstype)

Address to compare with

###### Returns

`boolean`

True if addresses are identical

###### Example

```typescript
if (Address.equals(addr1, addr2)) {
  console.log("Addresses match");
}
```

##### from()

> **from**: (`value`) => [`AddressType`](../../../primitives/Address.mdx#addresstype)

Create Address from various input types (universal constructor)

###### Parameters

###### value

Number, bigint, hex string, Uint8Array, or number array

`string` | `number` | `bigint` | `Uint8Array`\<`ArrayBufferLike`\> | `number`[]

###### Returns

[`AddressType`](../../../primitives/Address.mdx#addresstype)

Address

###### Throws

If value type is unsupported or invalid

###### Throws

If hex string is invalid

###### Throws

If bytes length is not 20

###### Example

```typescript
const addr1 = Address.from(0x742d35Cc6634C0532925a3b844Bc9e7595f251e3n);
const addr2 = Address.from(12345);
const _addr3 = Address.from("0x742d35Cc6634C0532925a3b844Bc9e7595f251e3");
const addr4 = Address.from(new Uint8Array(20));
const addr5 = Address.from([0x74, 0x2d, 0x35, ...]);
```

##### fromAbiEncoded()

> **fromAbiEncoded**: (`bytes`) => [`AddressType`](../../../primitives/Address.mdx#addresstype)

Decode Address from ABI-encoded bytes (32 bytes)

Extracts the last 20 bytes from 32-byte ABI-encoded address data.

###### Parameters

###### bytes

`Uint8Array`\<`ArrayBufferLike`\>

32-byte ABI-encoded data

###### Returns

[`AddressType`](../../../primitives/Address.mdx#addresstype)

Decoded Address

###### Throws

If bytes length is not 32

###### Example

```typescript
const encoded = new Uint8Array(32);
// ... set encoded[12:32] to address bytes ...
const addr = Address.fromAbiEncoded(encoded);
```

##### fromBase64()

> **fromBase64**: (`b64`) => [`AddressType`](../../../primitives/Address.mdx#addresstype)

Create Address from base64 string

###### Parameters

###### b64

`string`

Base64 encoded string

###### Returns

[`AddressType`](../../../primitives/Address.mdx#addresstype)

Address

###### Throws

If decoded length is not 20 bytes

###### Example

```typescript
const addr = Address.fromBase64("dC01zGY0wFMpJaO4RLyedZXyUeM=");
```

##### fromBytes()

> **fromBytes**: (`bytes`) => [`AddressType`](../../../primitives/Address.mdx#addresstype)

Create Address from raw bytes (standard form)

###### Parameters

###### bytes

`Uint8Array`\<`ArrayBufferLike`\>

Raw 20-byte array

###### Returns

[`AddressType`](../../../primitives/Address.mdx#addresstype)

Address

###### Throws

If length is not 20 bytes

###### Example

```typescript
const bytes = new Uint8Array(20);
const addr = Address.fromBytes(bytes);
```

##### fromHex()

> **fromHex**: (`hex`) => [`AddressType`](../../../primitives/Address.mdx#addresstype)

Parse hex string to Address (standard form)

###### Parameters

###### hex

`string`

Hex string with 0x prefix

###### Returns

[`AddressType`](../../../primitives/Address.mdx#addresstype)

Address bytes

###### Throws

If invalid format or length

###### Throws

If hex contains invalid characters

###### Example

```typescript
const addr = Address.fromHex("0x742d35Cc6634C0532925a3b844Bc9e7595f251e3");
```

##### fromNumber()

> **fromNumber**: (`value`) => [`AddressType`](../../../primitives/Address.mdx#addresstype)

Create Address from number value (takes lower 160 bits) (standard form)

###### Parameters

###### value

Number or bigint value

`number` | `bigint`

###### Returns

[`AddressType`](../../../primitives/Address.mdx#addresstype)

Address from lower 160 bits

###### Throws

If value is negative

###### Example

```typescript
const addr = Address.fromNumber(0x742d35Cc6634C0532925a3b844Bc9e7595f251e3n);
const addr2 = Address.fromNumber(12345);
```

##### fromPrivateKey()

> **fromPrivateKey**: (`privateKey`) => [`AddressType`](../../../primitives/Address.mdx#addresstype)

Create Address from secp256k1 private key (with auto-injected crypto)

For tree-shakeable version without auto-injected crypto, use `FromPrivateKey({ keccak256, derivePublicKey })` factory

###### Parameters

###### privateKey

`any`

###### Returns

[`AddressType`](../../../primitives/Address.mdx#addresstype)

##### FromPrivateKey()

> **FromPrivateKey**: (`deps`) => (`privateKey`) => [`AddressType`](../../../primitives/Address.mdx#addresstype) = `FromPrivateKeyFactory`

Factory: Create Address from secp256k1 private key

###### Parameters

###### deps

Crypto dependencies

###### derivePublicKey

(`privateKey`) => `Uint8Array`

Secp256k1 public key derivation function

###### keccak256

(`data`) => `Uint8Array`

Keccak256 hash function

###### Returns

Function that creates Address from private key

> (`privateKey`): [`AddressType`](../../../primitives/Address.mdx#addresstype)

###### Parameters

###### privateKey

`any`

###### Returns

[`AddressType`](../../../primitives/Address.mdx#addresstype)

###### Example

```typescript
import { FromPrivateKey } from '@tevm/voltaire/Address/BrandedAddress'
import { hash as keccak256 } from '@tevm/voltaire/crypto/Keccak256'
import { derivePublicKey } from '@tevm/voltaire/crypto/Secp256k1'

const fromPrivateKey = FromPrivateKey({ keccak256, derivePublicKey })
const addr = fromPrivateKey(privateKey)
```

##### fromPublicKey()

> **fromPublicKey**: (`xOrPublicKey`, `y?`) => [`AddressType`](../../../primitives/Address.mdx#addresstype)

Create Address from secp256k1 public key coordinates (with auto-injected keccak256)

For tree-shakeable version without auto-injected crypto, use `FromPublicKey({ keccak256 })` factory

###### Parameters

###### xOrPublicKey

`bigint` | `Uint8Array`\<`ArrayBufferLike`\>

###### y?

`bigint`

###### Returns

[`AddressType`](../../../primitives/Address.mdx#addresstype)

##### FromPublicKey()

> **FromPublicKey**: (`deps`) => (`xOrPublicKey`, `y?`) => [`AddressType`](../../../primitives/Address.mdx#addresstype) = `FromPublicKeyFactory`

Factory: Create Address from secp256k1 public key

###### Parameters

###### deps

Crypto dependencies

###### keccak256

(`data`) => `Uint8Array`

Keccak256 hash function

###### Returns

Function that creates Address from public key

> (`xOrPublicKey`, `y?`): [`AddressType`](../../../primitives/Address.mdx#addresstype)

###### Parameters

###### xOrPublicKey

`bigint` | `Uint8Array`\<`ArrayBufferLike`\>

###### y?

`bigint`

###### Returns

[`AddressType`](../../../primitives/Address.mdx#addresstype)

###### Example

```typescript
import { FromPublicKey } from '@tevm/voltaire/Address/BrandedAddress'
import { hash as keccak256 } from '@tevm/voltaire/crypto/Keccak256'

const fromPublicKey = FromPublicKey({ keccak256 })
// From coordinates
const addr1 = fromPublicKey(xCoord, yCoord)
// From 64-byte public key
const addr2 = fromPublicKey(publicKeyBytes)
```

##### greaterThan()

> **greaterThan**: (`address`, `other`) => `boolean`

Check if this address is greater than other

###### Parameters

###### address

[`AddressType`](../../../primitives/Address.mdx#addresstype)

First address

###### other

[`AddressType`](../../../primitives/Address.mdx#addresstype)

Address to compare with

###### Returns

`boolean`

True if address > other

##### is()

> **is**: (`value`) => `value is AddressType`

Type guard for Address (standard form)

###### Parameters

###### value

`unknown`

Value to check

###### Returns

`value is AddressType`

True if value is an Address

###### Example

```typescript
if (Address.is(value)) {
  const hex = Address.toHex(value);
}
```

##### isValid()

> **isValid**: (`value`) => `boolean`

Check if value is a valid address (accepts string, Uint8Array, or Address instance)

###### Parameters

###### value

Value to validate

`string` | `Uint8Array`\<`ArrayBufferLike`\>

###### Returns

`boolean`

True if valid address format

###### Example

```typescript
// Validate hex string
Address.isValid("0x742d35Cc6634C0532925a3b844Bc9e7595f251e3"); // true

// Validate Uint8Array (including Address instances)
const addr = Address.fromHex("0x742d35Cc6634C0532925a3b844Bc9e7595f251e3");
Address.isValid(addr); // true

// Invalid cases
Address.isValid("0xinvalid"); // false
Address.isValid(new Uint8Array(10)); // false (wrong length)
```

##### isValidChecksum()

> **isValidChecksum**: (`str`) => `boolean`

Check if string has valid EIP-55 checksum (with auto-injected keccak256)

For tree-shakeable version without auto-injected crypto, use `IsValidChecksum({ keccak256 })` factory

###### Parameters

###### str

`string`

###### Returns

`boolean`

##### IsValidChecksum()

> **IsValidChecksum**: (`deps`) => (`str`) => `boolean` = `IsValidChecksumFactory`

Factory: Check if string has valid EIP-55 checksum

###### Parameters

###### deps

Crypto dependencies

###### keccak256

(`data`) => `Uint8Array`

Keccak256 hash function

###### Returns

Function that validates EIP-55 checksum

> (`str`): `boolean`

###### Parameters

###### str

`string`

###### Returns

`boolean`

###### Example

```typescript
import { IsValidChecksum } from '@tevm/voltaire/Address/BrandedAddress'
import { hash as keccak256 } from '@tevm/voltaire/crypto/Keccak256'

const isValidChecksum = IsValidChecksum({ keccak256 })
if (isValidChecksum("0x742d35Cc6634C0532925a3b844Bc9e7595f251e3")) {
  console.log("Valid checksum")
}
```

##### isZero()

> **isZero**: (`address`) => `boolean`

Check if address is zero address

###### Parameters

###### address

[`AddressType`](../../../primitives/Address.mdx#addresstype)

Address to check

###### Returns

`boolean`

True if all bytes are zero

###### Example

```typescript
if (Address.isZero(addr)) {
  console.log("Zero address");
}
```

##### lessThan()

> **lessThan**: (`address`, `other`) => `boolean`

Check if this address is less than other

###### Parameters

###### address

[`AddressType`](../../../primitives/Address.mdx#addresstype)

First address

###### other

[`AddressType`](../../../primitives/Address.mdx#addresstype)

Address to compare with

###### Returns

`boolean`

True if address < other

##### Lowercase

> **Lowercase**: [`Lowercase`](namespaces/Lowercase.mdx)

##### SIZE

> **SIZE**: `20`

Address size in bytes

##### sortAddresses()

> **sortAddresses**: (`addresses`) => [`AddressType`](../../../primitives/Address.mdx#addresstype)[]

Sort addresses lexicographically

###### Parameters

###### addresses

[`AddressType`](../../../primitives/Address.mdx#addresstype)[]

Addresses to sort

###### Returns

[`AddressType`](../../../primitives/Address.mdx#addresstype)[]

Sorted addresses (new array)

###### Example

```typescript
const sorted = Address.sortAddresses([addr3, addr1, addr2]);
```

##### toAbiEncoded()

> **toAbiEncoded**: (`address`) => `Uint8Array`\<`ArrayBufferLike`\>

Convert Address to ABI-encoded bytes (32 bytes, left-padded)

Ethereum ABI encoding pads addresses to 32 bytes by prepending 12 zero bytes.

###### Parameters

###### address

[`AddressType`](../../../primitives/Address.mdx#addresstype)

Address to encode

###### Returns

`Uint8Array`\<`ArrayBufferLike`\>

32-byte ABI-encoded Uint8Array

###### Example

```typescript
const addr = Address.fromHex("0x742d35Cc6634C0532925a3b844Bc9e7595f251e3");
const encoded = Address.toAbiEncoded(addr);
// encoded.length === 32
```

##### toBytes()

> **toBytes**: (`address`) => `Uint8Array`\<`ArrayBufferLike`\>

Convert Address to Uint8Array

###### Parameters

###### address

[`AddressType`](../../../primitives/Address.mdx#addresstype)

Address to convert

###### Returns

`Uint8Array`\<`ArrayBufferLike`\>

Underlying Uint8Array

###### Example

```typescript
const addr = Address.from("0x742d35Cc6634C0532925a3b844Bc9e7595f251e3");
const bytes = Address.toBytes(addr);
console.log(bytes); // Uint8Array(20) [...]
```

##### toChecksummed()

> **toChecksummed**: (`address`) => [`Checksummed`](namespaces/Checksummed.mdx#checksummed)

Convert Address to EIP-55 checksummed hex string (with auto-injected keccak256)

For tree-shakeable version without auto-injected crypto, use `ToChecksummed({ keccak256 })` factory

###### Parameters

###### address

[`AddressType`](../../../primitives/Address.mdx#addresstype)

###### Returns

[`Checksummed`](namespaces/Checksummed.mdx#checksummed)

##### ToChecksummed()

> **ToChecksummed**: (`deps`) => (`address`) => [`Checksummed`](namespaces/Checksummed.mdx#checksummed) = `ToChecksummedFactory`

Factory: Convert Address to EIP-55 checksummed hex string

###### Parameters

###### deps

Crypto dependencies

###### keccak256

(`data`) => `Uint8Array`

Keccak256 hash function

###### Returns

Function that converts Address to checksummed hex string

> (`address`): [`Checksummed`](namespaces/Checksummed.mdx#checksummed)

###### Parameters

###### address

[`AddressType`](../../../primitives/Address.mdx#addresstype)

###### Returns

[`Checksummed`](namespaces/Checksummed.mdx#checksummed)

###### Example

```typescript
import { ToChecksummed } from '@tevm/voltaire/Address/BrandedAddress'
import { hash as keccak256 } from '@tevm/voltaire/crypto/Keccak256'

const toChecksummed = ToChecksummed({ keccak256 })
const checksummed = toChecksummed(addr)
// "0x742d35Cc6634C0532925a3b844Bc9e7595f251e3"
```

##### toHex()

> **toHex**: (`address`) => [`HexType`](../../../primitives/Hex.mdx#hextype)

Convert Address to hex string

###### Parameters

###### address

[`AddressType`](../../../primitives/Address.mdx#addresstype)

Address to convert

###### Returns

[`HexType`](../../../primitives/Hex.mdx#hextype)

Lowercase hex string with 0x prefix

###### Example

```typescript
const hex = Address.toHex(addr);
// "0x742d35cc6634c0532925a3b844bc9e7595f251e3"
```

##### toLowercase()

> **toLowercase**: (`address`) => [`Lowercase`](namespaces/Lowercase.mdx#lowercase)

Convert Address to lowercase hex string

###### Parameters

###### address

[`AddressType`](../../../primitives/Address.mdx#addresstype)

Address to convert

###### Returns

[`Lowercase`](namespaces/Lowercase.mdx#lowercase)

Lowercase hex string

###### Example

```typescript
const lower = Address.toLowercase(addr);
// "0x742d35cc6634c0532925a3b844bc9e7595f251e3"
```

##### toShortHex()

> **toShortHex**: (`address`, `prefixLength?`, `suffixLength?`) => `string`

Format address with shortened display

###### Parameters

###### address

[`AddressType`](../../../primitives/Address.mdx#addresstype)

Address to format

###### prefixLength?

`number`

Number of chars to show at start

###### suffixLength?

`number`

Number of chars to show at end

###### Returns

`string`

Shortened address like "0x742d...51e3"

###### Example

```typescript
const short = Address.toShortHex(addr);
// "0x742d...51e3"
const custom = Address.toShortHex(addr, 8, 6);
// "0x742d35...251e3"
```

##### toU256()

> **toU256**: (`address`) => `bigint`

Convert Address to uint256

###### Parameters

###### address

[`AddressType`](../../../primitives/Address.mdx#addresstype)

Address to convert

###### Returns

`bigint`

Bigint representation

###### Example

```typescript
const value = Address.toU256(addr);
```

##### toUppercase()

> **toUppercase**: (`address`) => [`Uppercase`](namespaces/Uppercase.mdx#uppercase)

Convert Address to uppercase hex string

###### Parameters

###### address

[`AddressType`](../../../primitives/Address.mdx#addresstype)

Address to convert

###### Returns

[`Uppercase`](namespaces/Uppercase.mdx#uppercase)

Uppercase hex string

###### Example

```typescript
const upper = Address.toUppercase(addr);
// "0x742D35CC6634C0532925A3B844BC9E7595F251E3"
```

##### Uppercase

> **Uppercase**: [`Uppercase`](namespaces/Uppercase.mdx)

##### zero()

> **zero**: () => [`AddressType`](../../../primitives/Address.mdx#addresstype)

Create zero address (standard form)

###### Returns

[`AddressType`](../../../primitives/Address.mdx#addresstype)

Zero address (0x0000...0000)

###### Example

```typescript
const zero = Address.zero();
```

***

### calculateCreate2Address()

> `const` **calculateCreate2Address**: (`arg0`, `arg1`, `arg2`) => [`AddressType`](../../../primitives/Address.mdx#addresstype)

Defined in: [src/primitives/Address/internal-index.ts:61](https://github.com/evmts/voltaire/blob/bd6ec34405c15ad8cd51d11579d495dc53813482/src/primitives/Address/internal-index.ts#L61)

Calculate CREATE2 contract address (with auto-injected keccak256)

For tree-shakeable version without auto-injected crypto, use `CalculateCreate2Address({ keccak256 })` factory

#### Parameters

##### arg0

[`AddressType`](../../../primitives/Address.mdx#addresstype)

##### arg1

[`HashType`](../HashType.mdx#hashtype)

##### arg2

`BrandedBytecode`

#### Returns

[`AddressType`](../../../primitives/Address.mdx#addresstype)

***

### calculateCreateAddress()

> `const` **calculateCreateAddress**: (`address`, `nonce`) => [`AddressType`](../../../primitives/Address.mdx#addresstype)

Defined in: [src/primitives/Address/internal-index.ts:51](https://github.com/evmts/voltaire/blob/bd6ec34405c15ad8cd51d11579d495dc53813482/src/primitives/Address/internal-index.ts#L51)

Calculate CREATE contract address (with auto-injected keccak256 and rlpEncode)

For tree-shakeable version without auto-injected crypto, use `CalculateCreateAddress({ keccak256, rlpEncode })` factory

#### Parameters

##### address

[`AddressType`](../../../primitives/Address.mdx#addresstype)

##### nonce

`bigint`

#### Returns

[`AddressType`](../../../primitives/Address.mdx#addresstype)

***

### fromPrivateKey()

> `const` **fromPrivateKey**: (`privateKey`) => [`AddressType`](../../../primitives/Address.mdx#addresstype)

Defined in: [src/primitives/Address/internal-index.ts:77](https://github.com/evmts/voltaire/blob/bd6ec34405c15ad8cd51d11579d495dc53813482/src/primitives/Address/internal-index.ts#L77)

Create Address from secp256k1 private key (with auto-injected crypto)

For tree-shakeable version without auto-injected crypto, use `FromPrivateKey({ keccak256, derivePublicKey })` factory

#### Parameters

##### privateKey

`any`

#### Returns

[`AddressType`](../../../primitives/Address.mdx#addresstype)

***

### fromPublicKey()

> `const` **fromPublicKey**: (`xOrPublicKey`, `y?`) => [`AddressType`](../../../primitives/Address.mdx#addresstype)

Defined in: [src/primitives/Address/internal-index.ts:70](https://github.com/evmts/voltaire/blob/bd6ec34405c15ad8cd51d11579d495dc53813482/src/primitives/Address/internal-index.ts#L70)

Create Address from secp256k1 public key coordinates (with auto-injected keccak256)

For tree-shakeable version without auto-injected crypto, use `FromPublicKey({ keccak256 })` factory

#### Parameters

##### xOrPublicKey

`bigint` | `Uint8Array`\<`ArrayBufferLike`\>

##### y?

`bigint`

#### Returns

[`AddressType`](../../../primitives/Address.mdx#addresstype)

***

### isValidChecksum()

> `const` **isValidChecksum**: (`str`) => `boolean`

Defined in: [src/primitives/Address/internal-index.ts:44](https://github.com/evmts/voltaire/blob/bd6ec34405c15ad8cd51d11579d495dc53813482/src/primitives/Address/internal-index.ts#L44)

Check if string has valid EIP-55 checksum (with auto-injected keccak256)

For tree-shakeable version without auto-injected crypto, use `IsValidChecksum({ keccak256 })` factory

#### Parameters

##### str

`string`

#### Returns

`boolean`

***

### toChecksummed()

> `const` **toChecksummed**: (`address`) => [`Checksummed`](namespaces/Checksummed.mdx#checksummed)

Defined in: [src/primitives/Address/internal-index.ts:37](https://github.com/evmts/voltaire/blob/bd6ec34405c15ad8cd51d11579d495dc53813482/src/primitives/Address/internal-index.ts#L37)

Convert Address to EIP-55 checksummed hex string (with auto-injected keccak256)

For tree-shakeable version without auto-injected crypto, use `ToChecksummed({ keccak256 })` factory

#### Parameters

##### address

[`AddressType`](../../../primitives/Address.mdx#addresstype)

#### Returns

[`Checksummed`](namespaces/Checksummed.mdx#checksummed)

## Functions

### assert()

> **assert**(`value`, `options?`): [`AddressType`](../../../primitives/Address.mdx#addresstype)

Defined in: [src/primitives/Address/internal-index.ts:118](https://github.com/evmts/voltaire/blob/bd6ec34405c15ad8cd51d11579d495dc53813482/src/primitives/Address/internal-index.ts#L118)

#### Parameters

##### value

`string` | `Uint8Array`\<`ArrayBufferLike`\>

##### options?

###### strict?

`boolean`

#### Returns

[`AddressType`](../../../primitives/Address.mdx#addresstype)

***

### Assert()

> **Assert**(`deps`): (`value`, `options?`) => [`AddressType`](../../../primitives/Address.mdx#addresstype)

Defined in: [src/primitives/Address/assert.js:106](https://github.com/evmts/voltaire/blob/bd6ec34405c15ad8cd51d11579d495dc53813482/src/primitives/Address/assert.js#L106)

Factory: Create assert function with keccak256 injected

#### Parameters

##### deps

Crypto dependencies

###### keccak256

(`data`) => `Uint8Array`

#### Returns

> (`value`, `options?`): [`AddressType`](../../../primitives/Address.mdx#addresstype)

##### Parameters

###### value

`string` | `Uint8Array`\<`ArrayBufferLike`\>

###### options?

###### strict?

`boolean`

##### Returns

[`AddressType`](../../../primitives/Address.mdx#addresstype)

***

### CalculateCreate2Address()

> **CalculateCreate2Address**(`deps`): (`arg0`, `arg1`, `arg2`) => [`AddressType`](../../../primitives/Address.mdx#addresstype)

Defined in: [src/primitives/Address/calculateCreate2Address.js:8](https://github.com/evmts/voltaire/blob/bd6ec34405c15ad8cd51d11579d495dc53813482/src/primitives/Address/calculateCreate2Address.js#L8)

Factory function to create calculateCreate2Address with injected keccak256 dependency

#### Parameters

##### deps

Dependencies

###### keccak256

(`data`) => `Uint8Array`

Keccak256 hash function

#### Returns

> (`arg0`, `arg1`, `arg2`): [`AddressType`](../../../primitives/Address.mdx#addresstype)

##### Parameters

###### arg0

[`AddressType`](../../../primitives/Address.mdx#addresstype)

###### arg1

[`HashType`](../HashType.mdx#hashtype)

###### arg2

`BrandedBytecode`

##### Returns

[`AddressType`](../../../primitives/Address.mdx#addresstype)

***

### CalculateCreateAddress()

> **CalculateCreateAddress**(`deps`): (`address`, `nonce`) => [`AddressType`](../../../primitives/Address.mdx#addresstype)

Defined in: [src/primitives/Address/calculateCreateAddress.js:51](https://github.com/evmts/voltaire/blob/bd6ec34405c15ad8cd51d11579d495dc53813482/src/primitives/Address/calculateCreateAddress.js#L51)

Factory for CREATE contract address calculation with injected dependencies

#### Parameters

##### deps

Dependencies

###### keccak256

(`data`) => `Uint8Array`

Keccak256 hash function

###### rlpEncode

(`items`) => `Uint8Array`

RLP encode function

#### Returns

> (`address`, `nonce`): [`AddressType`](../../../primitives/Address.mdx#addresstype)

##### Parameters

###### address

[`AddressType`](../../../primitives/Address.mdx#addresstype)

###### nonce

`bigint`

##### Returns

[`AddressType`](../../../primitives/Address.mdx#addresstype)

#### Example

```typescript
import { hash } from '../../../crypto/Keccak256/hash.js'
import { encode } from '../../Rlp/encode.js'
const calculateCreateAddress = CalculateCreateAddress({
  keccak256: hash,
  rlpEncode: encode
})
const contractAddr = calculateCreateAddress(deployerAddr, 5n);
```

***

### clone()

> **clone**(`address`): [`AddressType`](../../../primitives/Address.mdx#addresstype)

Defined in: [src/primitives/Address/clone.js:17](https://github.com/evmts/voltaire/blob/bd6ec34405c15ad8cd51d11579d495dc53813482/src/primitives/Address/clone.js#L17)

Create a deep copy of an Address

#### Parameters

##### address

[`AddressType`](../../../primitives/Address.mdx#addresstype)

Address to clone

#### Returns

[`AddressType`](../../../primitives/Address.mdx#addresstype)

Deep copy

#### Example

```typescript
const addr1 = Address.from("0x742d35Cc6634C0532925a3b844Bc9e7595f251e3");
const addr2 = Address.clone(addr1);
console.log(Address.equals(addr1, addr2)); // true
console.log(addr1 === addr2); // false
```

***

### compare()

> **compare**(`address`, `other`): `number`

Defined in: [src/primitives/Address/compare.js:15](https://github.com/evmts/voltaire/blob/bd6ec34405c15ad8cd51d11579d495dc53813482/src/primitives/Address/compare.js#L15)

Compare two addresses lexicographically

#### Parameters

##### address

[`AddressType`](../../../primitives/Address.mdx#addresstype)

First address

##### other

[`AddressType`](../../../primitives/Address.mdx#addresstype)

Address to compare with

#### Returns

`number`

-1 if address < other, 0 if equal, 1 if address > other

#### Example

```typescript
const sorted = addresses.sort((a, b) => Address.compare(a, b));
```

***

### deduplicateAddresses()

> **deduplicateAddresses**(`addresses`): [`AddressType`](../../../primitives/Address.mdx#addresstype)[]

Defined in: [src/primitives/Address/deduplicateAddresses.js:16](https://github.com/evmts/voltaire/blob/bd6ec34405c15ad8cd51d11579d495dc53813482/src/primitives/Address/deduplicateAddresses.js#L16)

Remove duplicate addresses from array
Preserves first occurrence of each unique address

#### Parameters

##### addresses

[`AddressType`](../../../primitives/Address.mdx#addresstype)[]

Addresses to deduplicate

#### Returns

[`AddressType`](../../../primitives/Address.mdx#addresstype)[]

Deduplicated addresses (new array)

#### Example

```typescript
const unique = Address.deduplicateAddresses([addr1, addr2, addr1, addr3]);
// Returns [addr1, addr2, addr3]
```

***

### equals()

> **equals**(`address`, `other`): `boolean`

Defined in: [src/primitives/Address/equals.js:15](https://github.com/evmts/voltaire/blob/bd6ec34405c15ad8cd51d11579d495dc53813482/src/primitives/Address/equals.js#L15)

Check if two addresses are equal

#### Parameters

##### address

[`AddressType`](../../../primitives/Address.mdx#addresstype)

First address

##### other

[`AddressType`](../../../primitives/Address.mdx#addresstype)

Address to compare with

#### Returns

`boolean`

True if addresses are identical

#### Example

```typescript
if (Address.equals(addr1, addr2)) {
  console.log("Addresses match");
}
```

***

### from()

> **from**(`value`): [`AddressType`](../../../primitives/Address.mdx#addresstype)

Defined in: [src/primitives/Address/from.js:24](https://github.com/evmts/voltaire/blob/bd6ec34405c15ad8cd51d11579d495dc53813482/src/primitives/Address/from.js#L24)

Create Address from various input types (universal constructor)

#### Parameters

##### value

Number, bigint, hex string, Uint8Array, or number array

`string` | `number` | `bigint` | `Uint8Array`\<`ArrayBufferLike`\> | `number`[]

#### Returns

[`AddressType`](../../../primitives/Address.mdx#addresstype)

Address

#### Throws

If value type is unsupported or invalid

#### Throws

If hex string is invalid

#### Throws

If bytes length is not 20

#### Example

```typescript
const addr1 = Address.from(0x742d35Cc6634C0532925a3b844Bc9e7595f251e3n);
const addr2 = Address.from(12345);
const _addr3 = Address.from("0x742d35Cc6634C0532925a3b844Bc9e7595f251e3");
const addr4 = Address.from(new Uint8Array(20));
const addr5 = Address.from([0x74, 0x2d, 0x35, ...]);
```

***

### From()

> **From**(`deps`): (`value`) => [`Checksummed`](namespaces/Checksummed.mdx#checksummed)

Defined in: [src/primitives/Address/ChecksumAddress.js:27](https://github.com/evmts/voltaire/blob/bd6ec34405c15ad8cd51d11579d495dc53813482/src/primitives/Address/ChecksumAddress.js#L27)

Factory: Create checksummed address from any input

#### Parameters

##### deps

Crypto dependencies

###### keccak256

(`data`) => `Uint8Array`

Keccak256 hash function

#### Returns

Function that converts to checksummed address

> (`value`): [`Checksummed`](namespaces/Checksummed.mdx#checksummed)

##### Parameters

###### value

`string` | `number` | `bigint` | `Uint8Array`\<`ArrayBufferLike`\>

##### Returns

[`Checksummed`](namespaces/Checksummed.mdx#checksummed)

#### Example

```typescript
import { From } from '@tevm/voltaire/Address/ChecksumAddress'
import { hash as keccak256 } from '@tevm/voltaire/crypto/Keccak256'

const from = From({ keccak256 })
const checksummed = from("0x742d35cc6634c0532925a3b844bc9e7595f251e3")
// "0x742d35Cc6634c0532925a3b844bc9e7595F251E3"
```

***

### fromAbiEncoded()

> **fromAbiEncoded**(`bytes`): [`AddressType`](../../../primitives/Address.mdx#addresstype)

Defined in: [src/primitives/Address/fromAbiEncoded.js:17](https://github.com/evmts/voltaire/blob/bd6ec34405c15ad8cd51d11579d495dc53813482/src/primitives/Address/fromAbiEncoded.js#L17)

Decode Address from ABI-encoded bytes (32 bytes)

Extracts the last 20 bytes from 32-byte ABI-encoded address data.

#### Parameters

##### bytes

`Uint8Array`\<`ArrayBufferLike`\>

32-byte ABI-encoded data

#### Returns

[`AddressType`](../../../primitives/Address.mdx#addresstype)

Decoded Address

#### Throws

If bytes length is not 32

#### Example

```typescript
const encoded = new Uint8Array(32);
// ... set encoded[12:32] to address bytes ...
const addr = Address.fromAbiEncoded(encoded);
```

***

### fromBase64()

> **fromBase64**(`b64`): [`AddressType`](../../../primitives/Address.mdx#addresstype)

Defined in: [src/primitives/Address/fromBase64.js:16](https://github.com/evmts/voltaire/blob/bd6ec34405c15ad8cd51d11579d495dc53813482/src/primitives/Address/fromBase64.js#L16)

Create Address from base64 string

#### Parameters

##### b64

`string`

Base64 encoded string

#### Returns

[`AddressType`](../../../primitives/Address.mdx#addresstype)

Address

#### Throws

If decoded length is not 20 bytes

#### Example

```typescript
const addr = Address.fromBase64("dC01zGY0wFMpJaO4RLyedZXyUeM=");
```

***

### fromBytes()

> **fromBytes**(`bytes`): [`AddressType`](../../../primitives/Address.mdx#addresstype)

Defined in: [src/primitives/Address/fromBytes.js:17](https://github.com/evmts/voltaire/blob/bd6ec34405c15ad8cd51d11579d495dc53813482/src/primitives/Address/fromBytes.js#L17)

Create Address from raw bytes (standard form)

#### Parameters

##### bytes

`Uint8Array`\<`ArrayBufferLike`\>

Raw 20-byte array

#### Returns

[`AddressType`](../../../primitives/Address.mdx#addresstype)

Address

#### Throws

If length is not 20 bytes

#### Example

```typescript
const bytes = new Uint8Array(20);
const addr = Address.fromBytes(bytes);
```

***

### fromHex()

> **fromHex**(`hex`): [`AddressType`](../../../primitives/Address.mdx#addresstype)

Defined in: [src/primitives/Address/fromHex.js:19](https://github.com/evmts/voltaire/blob/bd6ec34405c15ad8cd51d11579d495dc53813482/src/primitives/Address/fromHex.js#L19)

Parse hex string to Address (standard form)

#### Parameters

##### hex

`string`

Hex string with 0x prefix

#### Returns

[`AddressType`](../../../primitives/Address.mdx#addresstype)

Address bytes

#### Throws

If invalid format or length

#### Throws

If hex contains invalid characters

#### Example

```typescript
const addr = Address.fromHex("0x742d35Cc6634C0532925a3b844Bc9e7595f251e3");
```

***

### fromNumber()

> **fromNumber**(`value`): [`AddressType`](../../../primitives/Address.mdx#addresstype)

Defined in: [src/primitives/Address/fromNumber.js:17](https://github.com/evmts/voltaire/blob/bd6ec34405c15ad8cd51d11579d495dc53813482/src/primitives/Address/fromNumber.js#L17)

Create Address from number value (takes lower 160 bits) (standard form)

#### Parameters

##### value

Number or bigint value

`number` | `bigint`

#### Returns

[`AddressType`](../../../primitives/Address.mdx#addresstype)

Address from lower 160 bits

#### Throws

If value is negative

#### Example

```typescript
const addr = Address.fromNumber(0x742d35Cc6634C0532925a3b844Bc9e7595f251e3n);
const addr2 = Address.fromNumber(12345);
```

***

### FromPrivateKey()

> **FromPrivateKey**(`deps`): (`privateKey`) => [`AddressType`](../../../primitives/Address.mdx#addresstype)

Defined in: [src/primitives/Address/fromPrivateKey.js:23](https://github.com/evmts/voltaire/blob/bd6ec34405c15ad8cd51d11579d495dc53813482/src/primitives/Address/fromPrivateKey.js#L23)

Factory: Create Address from secp256k1 private key

#### Parameters

##### deps

Crypto dependencies

###### derivePublicKey

(`privateKey`) => `Uint8Array`

Secp256k1 public key derivation function

###### keccak256

(`data`) => `Uint8Array`

Keccak256 hash function

#### Returns

Function that creates Address from private key

> (`privateKey`): [`AddressType`](../../../primitives/Address.mdx#addresstype)

##### Parameters

###### privateKey

`any`

##### Returns

[`AddressType`](../../../primitives/Address.mdx#addresstype)

#### Example

```typescript
import { FromPrivateKey } from '@tevm/voltaire/Address/BrandedAddress'
import { hash as keccak256 } from '@tevm/voltaire/crypto/Keccak256'
import { derivePublicKey } from '@tevm/voltaire/crypto/Secp256k1'

const fromPrivateKey = FromPrivateKey({ keccak256, derivePublicKey })
const addr = fromPrivateKey(privateKey)
```

***

### FromPublicKey()

> **FromPublicKey**(`deps`): (`xOrPublicKey`, `y?`) => [`AddressType`](../../../primitives/Address.mdx#addresstype)

Defined in: [src/primitives/Address/fromPublicKey.js:20](https://github.com/evmts/voltaire/blob/bd6ec34405c15ad8cd51d11579d495dc53813482/src/primitives/Address/fromPublicKey.js#L20)

Factory: Create Address from secp256k1 public key

#### Parameters

##### deps

Crypto dependencies

###### keccak256

(`data`) => `Uint8Array`

Keccak256 hash function

#### Returns

Function that creates Address from public key

> (`xOrPublicKey`, `y?`): [`AddressType`](../../../primitives/Address.mdx#addresstype)

##### Parameters

###### xOrPublicKey

`bigint` | `Uint8Array`\<`ArrayBufferLike`\>

###### y?

`bigint`

##### Returns

[`AddressType`](../../../primitives/Address.mdx#addresstype)

#### Example

```typescript
import { FromPublicKey } from '@tevm/voltaire/Address/BrandedAddress'
import { hash as keccak256 } from '@tevm/voltaire/crypto/Keccak256'

const fromPublicKey = FromPublicKey({ keccak256 })
// From coordinates
const addr1 = fromPublicKey(xCoord, yCoord)
// From 64-byte public key
const addr2 = fromPublicKey(publicKeyBytes)
```

***

### greaterThan()

> **greaterThan**(`address`, `other`): `boolean`

Defined in: [src/primitives/Address/greaterThan.js:10](https://github.com/evmts/voltaire/blob/bd6ec34405c15ad8cd51d11579d495dc53813482/src/primitives/Address/greaterThan.js#L10)

Check if this address is greater than other

#### Parameters

##### address

[`AddressType`](../../../primitives/Address.mdx#addresstype)

First address

##### other

[`AddressType`](../../../primitives/Address.mdx#addresstype)

Address to compare with

#### Returns

`boolean`

True if address > other

***

### is()

> **is**(`value`): `value is AddressType`

Defined in: [src/primitives/Address/is.js:16](https://github.com/evmts/voltaire/blob/bd6ec34405c15ad8cd51d11579d495dc53813482/src/primitives/Address/is.js#L16)

Type guard for Address (standard form)

#### Parameters

##### value

`unknown`

Value to check

#### Returns

`value is AddressType`

True if value is an Address

#### Example

```typescript
if (Address.is(value)) {
  const hex = Address.toHex(value);
}
```

***

### isValid()

> **isValid**(`value`): `boolean`

Defined in: [src/primitives/Address/isValid.js:21](https://github.com/evmts/voltaire/blob/bd6ec34405c15ad8cd51d11579d495dc53813482/src/primitives/Address/isValid.js#L21)

Check if value is a valid address (accepts string, Uint8Array, or Address instance)

#### Parameters

##### value

Value to validate

`string` | `Uint8Array`\<`ArrayBufferLike`\>

#### Returns

`boolean`

True if valid address format

#### Example

```typescript
// Validate hex string
Address.isValid("0x742d35Cc6634C0532925a3b844Bc9e7595f251e3"); // true

// Validate Uint8Array (including Address instances)
const addr = Address.fromHex("0x742d35Cc6634C0532925a3b844Bc9e7595f251e3");
Address.isValid(addr); // true

// Invalid cases
Address.isValid("0xinvalid"); // false
Address.isValid(new Uint8Array(10)); // false (wrong length)
```

***

### IsValid()

> **IsValid**(`deps`): (`str`) => `boolean`

Defined in: [src/primitives/Address/ChecksumAddress.js:74](https://github.com/evmts/voltaire/blob/bd6ec34405c15ad8cd51d11579d495dc53813482/src/primitives/Address/ChecksumAddress.js#L74)

Factory: Check if string has valid EIP-55 checksum

#### Parameters

##### deps

Crypto dependencies

###### keccak256

(`data`) => `Uint8Array`

Keccak256 hash function

#### Returns

Function that validates EIP-55 checksum

> (`str`): `boolean`

##### Parameters

###### str

`string`

##### Returns

`boolean`

#### Example

```typescript
import { IsValid } from '@tevm/voltaire/Address/ChecksumAddress'
import { hash as keccak256 } from '@tevm/voltaire/crypto/Keccak256'

const isValid = IsValid({ keccak256 })
if (isValid("0x742d35Cc6634C0532925a3b844Bc9e7595f251e3")) {
  console.log("Valid checksum")
}
```

***

### IsValidChecksum()

> **IsValidChecksum**(`deps`): (`str`) => `boolean`

Defined in: [src/primitives/Address/isValidChecksum.js:21](https://github.com/evmts/voltaire/blob/bd6ec34405c15ad8cd51d11579d495dc53813482/src/primitives/Address/isValidChecksum.js#L21)

Factory: Check if string has valid EIP-55 checksum

#### Parameters

##### deps

Crypto dependencies

###### keccak256

(`data`) => `Uint8Array`

Keccak256 hash function

#### Returns

Function that validates EIP-55 checksum

> (`str`): `boolean`

##### Parameters

###### str

`string`

##### Returns

`boolean`

#### Example

```typescript
import { IsValidChecksum } from '@tevm/voltaire/Address/BrandedAddress'
import { hash as keccak256 } from '@tevm/voltaire/crypto/Keccak256'

const isValidChecksum = IsValidChecksum({ keccak256 })
if (isValidChecksum("0x742d35Cc6634C0532925a3b844Bc9e7595f251e3")) {
  console.log("Valid checksum")
}
```

***

### isZero()

> **isZero**(`address`): `boolean`

Defined in: [src/primitives/Address/isZero.js:14](https://github.com/evmts/voltaire/blob/bd6ec34405c15ad8cd51d11579d495dc53813482/src/primitives/Address/isZero.js#L14)

Check if address is zero address

#### Parameters

##### address

[`AddressType`](../../../primitives/Address.mdx#addresstype)

Address to check

#### Returns

`boolean`

True if all bytes are zero

#### Example

```typescript
if (Address.isZero(addr)) {
  console.log("Zero address");
}
```

***

### lessThan()

> **lessThan**(`address`, `other`): `boolean`

Defined in: [src/primitives/Address/lessThan.js:10](https://github.com/evmts/voltaire/blob/bd6ec34405c15ad8cd51d11579d495dc53813482/src/primitives/Address/lessThan.js#L10)

Check if this address is less than other

#### Parameters

##### address

[`AddressType`](../../../primitives/Address.mdx#addresstype)

First address

##### other

[`AddressType`](../../../primitives/Address.mdx#addresstype)

Address to compare with

#### Returns

`boolean`

True if address < other

***

### sortAddresses()

> **sortAddresses**(`addresses`): [`AddressType`](../../../primitives/Address.mdx#addresstype)[]

Defined in: [src/primitives/Address/sortAddresses.js:14](https://github.com/evmts/voltaire/blob/bd6ec34405c15ad8cd51d11579d495dc53813482/src/primitives/Address/sortAddresses.js#L14)

Sort addresses lexicographically

#### Parameters

##### addresses

[`AddressType`](../../../primitives/Address.mdx#addresstype)[]

Addresses to sort

#### Returns

[`AddressType`](../../../primitives/Address.mdx#addresstype)[]

Sorted addresses (new array)

#### Example

```typescript
const sorted = Address.sortAddresses([addr3, addr1, addr2]);
```

***

### toAbiEncoded()

> **toAbiEncoded**(`address`): `Uint8Array`\<`ArrayBufferLike`\>

Defined in: [src/primitives/Address/toAbiEncoded.js:16](https://github.com/evmts/voltaire/blob/bd6ec34405c15ad8cd51d11579d495dc53813482/src/primitives/Address/toAbiEncoded.js#L16)

Convert Address to ABI-encoded bytes (32 bytes, left-padded)

Ethereum ABI encoding pads addresses to 32 bytes by prepending 12 zero bytes.

#### Parameters

##### address

[`AddressType`](../../../primitives/Address.mdx#addresstype)

Address to encode

#### Returns

`Uint8Array`\<`ArrayBufferLike`\>

32-byte ABI-encoded Uint8Array

#### Example

```typescript
const addr = Address.fromHex("0x742d35Cc6634C0532925a3b844Bc9e7595f251e3");
const encoded = Address.toAbiEncoded(addr);
// encoded.length === 32
```

***

### toBytes()

> **toBytes**(`address`): `Uint8Array`\<`ArrayBufferLike`\>

Defined in: [src/primitives/Address/toBytes.js:14](https://github.com/evmts/voltaire/blob/bd6ec34405c15ad8cd51d11579d495dc53813482/src/primitives/Address/toBytes.js#L14)

Convert Address to Uint8Array

#### Parameters

##### address

[`AddressType`](../../../primitives/Address.mdx#addresstype)

Address to convert

#### Returns

`Uint8Array`\<`ArrayBufferLike`\>

Underlying Uint8Array

#### Example

```typescript
const addr = Address.from("0x742d35Cc6634C0532925a3b844Bc9e7595f251e3");
const bytes = Address.toBytes(addr);
console.log(bytes); // Uint8Array(20) [...]
```

***

### ToChecksummed()

> **ToChecksummed**(`deps`): (`address`) => [`Checksummed`](namespaces/Checksummed.mdx#checksummed)

Defined in: [src/primitives/Address/toChecksummed.js:20](https://github.com/evmts/voltaire/blob/bd6ec34405c15ad8cd51d11579d495dc53813482/src/primitives/Address/toChecksummed.js#L20)

Factory: Convert Address to EIP-55 checksummed hex string

#### Parameters

##### deps

Crypto dependencies

###### keccak256

(`data`) => `Uint8Array`

Keccak256 hash function

#### Returns

Function that converts Address to checksummed hex string

> (`address`): [`Checksummed`](namespaces/Checksummed.mdx#checksummed)

##### Parameters

###### address

[`AddressType`](../../../primitives/Address.mdx#addresstype)

##### Returns

[`Checksummed`](namespaces/Checksummed.mdx#checksummed)

#### Example

```typescript
import { ToChecksummed } from '@tevm/voltaire/Address/BrandedAddress'
import { hash as keccak256 } from '@tevm/voltaire/crypto/Keccak256'

const toChecksummed = ToChecksummed({ keccak256 })
const checksummed = toChecksummed(addr)
// "0x742d35Cc6634C0532925a3b844Bc9e7595f251e3"
```

***

### toHex()

> **toHex**(`address`): [`HexType`](../../../primitives/Hex.mdx#hextype)

Defined in: [src/primitives/Address/toHex.js:13](https://github.com/evmts/voltaire/blob/bd6ec34405c15ad8cd51d11579d495dc53813482/src/primitives/Address/toHex.js#L13)

Convert Address to hex string

#### Parameters

##### address

[`AddressType`](../../../primitives/Address.mdx#addresstype)

Address to convert

#### Returns

[`HexType`](../../../primitives/Hex.mdx#hextype)

Lowercase hex string with 0x prefix

#### Example

```typescript
const hex = Address.toHex(addr);
// "0x742d35cc6634c0532925a3b844bc9e7595f251e3"
```

***

### toLowercase()

> **toLowercase**(`address`): [`Lowercase`](namespaces/Lowercase.mdx#lowercase)

Defined in: [src/primitives/Address/toLowercase.js:15](https://github.com/evmts/voltaire/blob/bd6ec34405c15ad8cd51d11579d495dc53813482/src/primitives/Address/toLowercase.js#L15)

Convert Address to lowercase hex string

#### Parameters

##### address

[`AddressType`](../../../primitives/Address.mdx#addresstype)

Address to convert

#### Returns

[`Lowercase`](namespaces/Lowercase.mdx#lowercase)

Lowercase hex string

#### Example

```typescript
const lower = Address.toLowercase(addr);
// "0x742d35cc6634c0532925a3b844bc9e7595f251e3"
```

***

### toShortHex()

> **toShortHex**(`address`, `prefixLength?`, `suffixLength?`): `string`

Defined in: [src/primitives/Address/toShortHex.js:19](https://github.com/evmts/voltaire/blob/bd6ec34405c15ad8cd51d11579d495dc53813482/src/primitives/Address/toShortHex.js#L19)

Format address with shortened display

#### Parameters

##### address

[`AddressType`](../../../primitives/Address.mdx#addresstype)

Address to format

##### prefixLength?

`number`

Number of chars to show at start

##### suffixLength?

`number`

Number of chars to show at end

#### Returns

`string`

Shortened address like "0x742d...51e3"

#### Example

```typescript
const short = Address.toShortHex(addr);
// "0x742d...51e3"
const custom = Address.toShortHex(addr, 8, 6);
// "0x742d35...251e3"
```

***

### toU256()

> **toU256**(`address`): `bigint`

Defined in: [src/primitives/Address/toU256.js:14](https://github.com/evmts/voltaire/blob/bd6ec34405c15ad8cd51d11579d495dc53813482/src/primitives/Address/toU256.js#L14)

Convert Address to uint256

#### Parameters

##### address

[`AddressType`](../../../primitives/Address.mdx#addresstype)

Address to convert

#### Returns

`bigint`

Bigint representation

#### Example

```typescript
const value = Address.toU256(addr);
```

***

### toUppercase()

> **toUppercase**(`address`): [`Uppercase`](namespaces/Uppercase.mdx#uppercase)

Defined in: [src/primitives/Address/toUppercase.js:15](https://github.com/evmts/voltaire/blob/bd6ec34405c15ad8cd51d11579d495dc53813482/src/primitives/Address/toUppercase.js#L15)

Convert Address to uppercase hex string

#### Parameters

##### address

[`AddressType`](../../../primitives/Address.mdx#addresstype)

Address to convert

#### Returns

[`Uppercase`](namespaces/Uppercase.mdx#uppercase)

Uppercase hex string

#### Example

```typescript
const upper = Address.toUppercase(addr);
// "0x742D35CC6634C0532925A3B844BC9E7595F251E3"
```

***

### zero()

> **zero**(): [`AddressType`](../../../primitives/Address.mdx#addresstype)

Defined in: [src/primitives/Address/zero.js:13](https://github.com/evmts/voltaire/blob/bd6ec34405c15ad8cd51d11579d495dc53813482/src/primitives/Address/zero.js#L13)

Create zero address (standard form)

#### Returns

[`AddressType`](../../../primitives/Address.mdx#addresstype)

Zero address (0x0000...0000)

#### Example

```typescript
const zero = Address.zero();
```

## References

### AddressType

Re-exports [AddressType](../../../primitives/Address.mdx#addresstype)

***

### BrandedAddressType

Renames and re-exports [AddressType](../../../primitives/Address.mdx#addresstype)

***

### HEX\_SIZE

Re-exports [HEX_SIZE](../../../primitives/Address.mdx#hex_size)

***

### InvalidAddressError

Re-exports [InvalidAddressError](../../../primitives/Address.mdx#invalidaddresserror)

***

### InvalidAddressLengthError

Re-exports [InvalidAddressLengthError](../../../primitives/Address.mdx#invalidaddresslengtherror)

***

### InvalidChecksumError

Re-exports [InvalidChecksumError](../../../primitives/Address.mdx#invalidchecksumerror)

***

### InvalidHexFormatError

Re-exports [InvalidHexFormatError](../../../primitives/Address.mdx#invalidhexformaterror)

***

### InvalidHexStringError

Re-exports [InvalidHexStringError](../../../primitives/Address.mdx#invalidhexstringerror)

***

### InvalidValueError

Re-exports [InvalidValueError](../../../primitives/Address.mdx#invalidvalueerror)

***

### NATIVE\_ASSET\_ADDRESS

Re-exports [NATIVE_ASSET_ADDRESS](../../../primitives/Address.mdx#native_asset_address)

***

### NotImplementedError

Re-exports [NotImplementedError](../../../primitives/Address.mdx#notimplementederror)

***

### SIZE

Re-exports [SIZE](../../../primitives/Address.mdx#size)
