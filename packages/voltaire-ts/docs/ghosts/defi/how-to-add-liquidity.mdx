---
title: How to Add Liquidity to Pool
description: Add liquidity to a Uniswap V2 pool and receive LP tokens.
---

## Goal

Add liquidity to a Uniswap V2-style pool by depositing a pair of tokens.

Return as:

ANSWER: Added X TOKEN_A + Y TOKEN_B, received Z LP tokens (tx: 0x...)

## Concepts

Liquidity providers deposit equal value of two tokens into a pool and receive LP tokens representing their share.

**Key points**:
- Must deposit tokens in the current pool ratio (or accept slippage)
- LP tokens represent your share of the pool
- You earn 0.3% of all swaps proportional to your share
- Impermanent loss occurs when token prices diverge

## Example (TypeScript)

```ts
import { Contract } from '@tevm/voltaire/contract'

const routerAbi = [
  {
    type: 'function',
    name: 'addLiquidity',
    stateMutability: 'nonpayable',
    inputs: [
      { name: 'tokenA', type: 'address' },
      { name: 'tokenB', type: 'address' },
      { name: 'amountADesired', type: 'uint256' },
      { name: 'amountBDesired', type: 'uint256' },
      { name: 'amountAMin', type: 'uint256' },
      { name: 'amountBMin', type: 'uint256' },
      { name: 'to', type: 'address' },
      { name: 'deadline', type: 'uint256' }
    ],
    outputs: [
      { name: 'amountA', type: 'uint256' },
      { name: 'amountB', type: 'uint256' },
      { name: 'liquidity', type: 'uint256' }
    ]
  },
  {
    type: 'function',
    name: 'addLiquidityETH',
    stateMutability: 'payable',
    inputs: [
      { name: 'token', type: 'address' },
      { name: 'amountTokenDesired', type: 'uint256' },
      { name: 'amountTokenMin', type: 'uint256' },
      { name: 'amountETHMin', type: 'uint256' },
      { name: 'to', type: 'address' },
      { name: 'deadline', type: 'uint256' }
    ],
    outputs: [
      { name: 'amountToken', type: 'uint256' },
      { name: 'amountETH', type: 'uint256' },
      { name: 'liquidity', type: 'uint256' }
    ]
  }
] as const

const pairAbi = [
  {
    type: 'function',
    name: 'getReserves',
    stateMutability: 'view',
    inputs: [],
    outputs: [
      { name: 'reserve0', type: 'uint112' },
      { name: 'reserve1', type: 'uint112' },
      { name: 'blockTimestampLast', type: 'uint32' }
    ]
  }
] as const

const WETH = '0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2'
const USDC = '0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48'
const ROUTER = '0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D'
const PAIR = '0xB4e16d0168e52d35CaCD2c6185b44281Ec28C9Dc'

const router = Contract({
  address: ROUTER,
  abi: routerAbi,
  provider
})

const pair = Contract({
  address: PAIR,
  abi: pairAbi,
  provider
})

// Get current pool ratio
const [reserve0, reserve1] = await pair.read.getReserves()

// Calculate amounts to deposit (1 WETH worth)
const amountWETH = 1n * 10n ** 18n
const amountUSDC = (amountWETH * reserve1) / reserve0 // Match pool ratio

// Set 1% slippage tolerance
const slippage = 100n // 1% = 100 basis points
const amountWETHMin = amountWETH - (amountWETH * slippage) / 10000n
const amountUSDCMin = amountUSDC - (amountUSDC * slippage) / 10000n

const deadline = BigInt(Math.floor(Date.now() / 1000) + 20 * 60)

// Approve both tokens first!
// await weth.write.approve(ROUTER, amountWETH)
// await usdc.write.approve(ROUTER, amountUSDC)

const txHash = await router.write.addLiquidity(
  WETH,
  USDC,
  amountWETH,
  amountUSDC,
  amountWETHMin,
  amountUSDCMin,
  myAddress,
  deadline
)

console.log(`ANSWER: Added 1 WETH + ${Number(amountUSDC) / 1e6} USDC to pool (tx: ${txHash})`)
```

## Remove Liquidity

```ts
const removeLiquidityAbi = [
  {
    type: 'function',
    name: 'removeLiquidity',
    stateMutability: 'nonpayable',
    inputs: [
      { name: 'tokenA', type: 'address' },
      { name: 'tokenB', type: 'address' },
      { name: 'liquidity', type: 'uint256' },
      { name: 'amountAMin', type: 'uint256' },
      { name: 'amountBMin', type: 'uint256' },
      { name: 'to', type: 'address' },
      { name: 'deadline', type: 'uint256' }
    ],
    outputs: [
      { name: 'amountA', type: 'uint256' },
      { name: 'amountB', type: 'uint256' }
    ]
  }
] as const

// Approve LP tokens to router first
// await lpToken.write.approve(ROUTER, lpAmount)

const txHash = await router.write.removeLiquidity(
  WETH,
  USDC,
  lpAmount,
  0n, // amountAMin (set appropriate slippage)
  0n, // amountBMin
  myAddress,
  deadline
)
```

## Notes

- Must approve both tokens to the router before adding liquidity
- The router will only use amounts that maintain the pool ratio
- Excess tokens are returned to your wallet
- LP tokens must be approved to the router for removal
- Consider impermanent loss when providing liquidity to volatile pairs
