---
title: '[Zig] docs/public/lib/primitives/Hex/Hex.zig'
source: 'docs/public/lib/primitives/Hex/Hex.zig'
---

> Auto-generated from Zig tests in: docs/public/lib/primitives/Hex/Hex.zig

### hex validation

```zig
test "hex validation" {
    try testing.expect(isHex("0x1234"));
    try testing.expect(isHex("0xabcdef"));
    try testing.expect(isHex("0xABCDEF"));
    try testing.expect(!isHex("1234"));
    try testing.expect(!isHex("0xGHI"));
    try testing.expect(!isHex("0x"));
}
```

### hex to bytes conversion

```zig
test "hex to bytes conversion" {
    const allocator = testing.allocator;

    const bytes = try hexToBytes(allocator, "0x1234");
    defer allocator.free(bytes);

    try testing.expectEqual(@as(usize, 2), bytes.len);
    try testing.expectEqual(@as(u8, 0x12), bytes[0]);
    try testing.expectEqual(@as(u8, 0x34), bytes[1]);
}
```

### bytes to hex conversion

```zig
test "bytes to hex conversion" {
    const allocator = testing.allocator;

    const bytes = [_]u8{ 0x12, 0x34, 0xab, 0xcd };
    const hex = try bytesToHex(allocator, &bytes);
    defer allocator.free(hex);

    try testing.expectEqualStrings("0x1234abcd", hex);
}
```

### fixed size conversions

```zig
test "fixed size conversions" {
    const hex = "0x1234abcd";
    const bytes = try hexToBytesFixed(4, hex);

    try testing.expectEqual(@as(u8, 0x12), bytes[0]);
    try testing.expectEqual(@as(u8, 0x34), bytes[1]);
    try testing.expectEqual(@as(u8, 0xab), bytes[2]);
    try testing.expectEqual(@as(u8, 0xcd), bytes[3]);

    const hex_result = bytesToHexFixed(4, bytes);
    try testing.expectEqualStrings("0x1234abcd", &hex_result);
}
```

### bytes utilities

```zig
test "bytes utilities" {
    const allocator = testing.allocator;

    const bytes1 = [_]u8{ 0x12, 0x34 };
    const bytes2 = [_]u8{ 0xab, 0xcd };

    const arrays = [_][]const u8{ &bytes1, &bytes2 };
    const concatenated = try concat(allocator, &arrays);
    defer allocator.free(concatenated);

    try testing.expectEqual(@as(usize, 4), concatenated.len);
    try testing.expectEqual(@as(u8, 0x12), concatenated[0]);
    try testing.expectEqual(@as(u8, 0x34), concatenated[1]);
    try testing.expectEqual(@as(u8, 0xab), concatenated[2]);
    try testing.expectEqual(@as(u8, 0xcd), concatenated[3]);
}
```

### padding utilities

```zig
test "padding utilities" {
    const allocator = testing.allocator;

    const bytes = [_]u8{ 0x12, 0x34 };
    const padded = try padLeft(allocator, &bytes, 4);
    defer allocator.free(padded);

    try testing.expectEqual(@as(usize, 4), padded.len);
    try testing.expectEqual(@as(u8, 0x00), padded[0]);
    try testing.expectEqual(@as(u8, 0x00), padded[1]);
    try testing.expectEqual(@as(u8, 0x12), padded[2]);
    try testing.expectEqual(@as(u8, 0x34), padded[3]);
}
```

### trimming utilities

```zig
test "trimming utilities" {
    const bytes = [_]u8{ 0x00, 0x00, 0x12, 0x34, 0x00 };
    const trimmed_left = trimLeftZeros(&bytes);
    const trimmed_right = trimRightZeros(&bytes);

    try testing.expectEqual(@as(usize, 3), trimmed_left.len);
    try testing.expectEqual(@as(u8, 0x12), trimmed_left[0]);

    try testing.expectEqual(@as(usize, 4), trimmed_right.len);
    try testing.expectEqual(@as(u8, 0x34), trimmed_right[3]);
}
```

### numeric conversions

```zig
test "numeric conversions" {
    const allocator = testing.allocator;

    const value = try hexToU256("0x1234");
    try testing.expectEqual(@as(u256, 0x1234), value);

    const hex = try u256ToHex(allocator, 0x1234);
    defer allocator.free(hex);
    try testing.expectEqualStrings("0x1234", hex);
}
```

### is valid hex

```zig
test "is valid hex" {
    // Valid hex strings
    try testing.expect(!isHex("0x")); // Too short, requires at least one hex digit
    try testing.expect(isHex("0x0"));
    try testing.expect(isHex("0x00"));
    try testing.expect(isHex("0x0123456789abcdef"));
    try testing.expect(isHex("0x0123456789ABCDEF"));
    try testing.expect(isHex("0xdeadbeef"));

    // Invalid hex strings
    try testing.expect(!isHex(""));
    try testing.expect(!isHex("0"));
    try testing.expect(!isHex("00"));
    try testing.expect(!isHex("0xg"));
    try testing.expect(!isHex("0x0123456789abcdefg"));
    try testing.expect(!isHex("0x "));
    try testing.expect(!isHex(" 0x00"));
    try testing.expect(!isHex("0x00 "));
}
```

### from bytes basic

```zig
test "from bytes basic" {
    const allocator = testing.allocator;

    // Empty bytes
    const empty = try bytesToHex(allocator, &[_]u8{});
    defer allocator.free(empty);
    try testing.expectEqualStrings("0x", empty);

    // Single byte
    const single = try bytesToHex(allocator, &[_]u8{0x61});
    defer allocator.free(single);
    try testing.expectEqualStrings("0x61", single);

    // Multiple bytes
    const multiple = try bytesToHex(allocator, &[_]u8{ 0x61, 0x62, 0x63 });
    defer allocator.free(multiple);
    try testing.expectEqualStrings("0x616263", multiple);

    // "Hello World!"
    const hello = try bytesToHex(allocator, "Hello World!");
    defer allocator.free(hello);
    try testing.expectEqualStrings("0x48656c6c6f20576f726c6421", hello);
}
```

### from bytes with specific case

```zig
test "from bytes with specific case" {
    const allocator = testing.allocator;

    const bytes = [_]u8{ 0xde, 0xad, 0xbe, 0xef };

    // Lowercase (default)
    const lower = try bytesToHex(allocator, &bytes);
    defer allocator.free(lower);
    try testing.expectEqualStrings("0xdeadbeef", lower);

    // Uppercase - Note: bytesToHexUpper function doesn't exist, skip this test
}
```

### to bytes basic

```zig
test "to bytes basic" {
    const allocator = testing.allocator;

    // Empty hex
    const empty = try hexToBytes(allocator, "0x");
    defer allocator.free(empty);
    try testing.expectEqual(@as(usize, 0), empty.len);

    // Single byte
    const single = try hexToBytes(allocator, "0x61");
    defer allocator.free(single);
    try testing.expectEqualSlices(u8, &[_]u8{0x61}, single);

    // Multiple bytes
    const multiple = try hexToBytes(allocator, "0x616263");
    defer allocator.free(multiple);
    try testing.expectEqualSlices(u8, &[_]u8{ 0x61, 0x62, 0x63 }, multiple);

    // Mixed case
    const mixed = try hexToBytes(allocator, "0xDeAdBeEf");
    defer allocator.free(mixed);
    try testing.expectEqualSlices(u8, &[_]u8{ 0xde, 0xad, 0xbe, 0xef }, mixed);
}
```

### to bytes odd length

```zig
test "to bytes odd length" {
    const allocator = testing.allocator;

    // Note: hexToBytes expects even length after 0x prefix, so odd length will error
    const odd = hexToBytes(allocator, "0x1");
    try testing.expectError(HexError.OddLengthHex, odd);

    const odd2 = hexToBytes(allocator, "0x123");
    try testing.expectError(HexError.OddLengthHex, odd2);
}
```

### to bytes invalid hex

```zig
test "to bytes invalid hex" {
    const allocator = testing.allocator;

    // Missing 0x prefix
    const result1 = hexToBytes(allocator, "deadbeef");
    try testing.expectError(HexError.InvalidHexFormat, result1);

    // Invalid character
    const result2 = hexToBytes(allocator, "0xdeadbeeg");
    try testing.expectError(HexError.InvalidHexCharacter, result2);
}
```

### from u256

```zig
test "from u256" {
    const allocator = testing.allocator;

    // Zero
    const zero_val = try u256ToHex(allocator, 0);
    defer allocator.free(zero_val);
    try testing.expectEqualStrings("0x0", zero_val);

    // Small number
    const small = try u256ToHex(allocator, 69420);
    defer allocator.free(small);
    try testing.expectEqualStrings("0x10f2c", small);

    // Large number
    const large = try u256ToHex(allocator, 0xdeadbeef);
    defer allocator.free(large);
    try testing.expectEqualStrings("0xdeadbeef", large);

    // Max u256
    const max = try u256ToHex(allocator, std.math.maxInt(u256));
    defer allocator.free(max);
    try testing.expectEqualStrings("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff", max);
}
```

### to u256

```zig
test "to u256" {
    // Zero
    const zero_val = try hexToU256("0x0");
    try testing.expectEqual(@as(u256, 0), zero_val);

    // Small number
    const small = try hexToU256("0x10f2c");
    try testing.expectEqual(@as(u256, 69420), small);

    // Large number
    const large = try hexToU256("0xdeadbeef");
    try testing.expectEqual(@as(u256, 0xdeadbeef), large);

    // Max u256
    const max = try hexToU256("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
    try testing.expectEqual(std.math.maxInt(u256), max);
}
```

### empty string handling

```zig
test "empty string handling" {
    const allocator = testing.allocator;

    const result = hexToBytes(allocator, "");
    try testing.expectError(HexError.InvalidHexFormat, result);
}
```

### only prefix

```zig
test "only prefix" {
    const allocator = testing.allocator;

    const bytes = try hexToBytes(allocator, "0x");
    defer allocator.free(bytes);
    try testing.expectEqual(@as(usize, 0), bytes.len);
}
```

### hexToString and stringToHex

```zig
test "hexToString and stringToHex" {
    const allocator = testing.allocator;

    const hex_input = "0x48656c6c6f";
    const string_result = try hexToString(allocator, hex_input);
    defer allocator.free(string_result);
    try testing.expectEqualStrings("Hello", string_result);

    const string_input = "World";
    const hex_result = try stringToHex(allocator, string_input);
    defer allocator.free(hex_result);
    try testing.expectEqualStrings("0x576f726c64", hex_result);

    const empty_hex = "0x";
    const empty_string = try hexToString(allocator, empty_hex);
    defer allocator.free(empty_string);
    try testing.expectEqual(@as(usize, 0), empty_string.len);

    const empty_str_input = "";
    const empty_hex_result = try stringToHex(allocator, empty_str_input);
    defer allocator.free(empty_hex_result);
    try testing.expectEqualStrings("0x", empty_hex_result);
}
```

### slice function edge cases

```zig
test "slice function edge cases" {
    const bytes = [_]u8{ 0x01, 0x02, 0x03, 0x04, 0x05 };

    const full_slice = slice(&bytes, 0, 5);
    try testing.expectEqualSlices(u8, &bytes, full_slice);

    const partial_slice = slice(&bytes, 1, 3);
    try testing.expectEqualSlices(u8, &[_]u8{ 0x02, 0x03 }, partial_slice);

    const start_beyond_len = slice(&bytes, 10, 15);
    try testing.expectEqual(@as(usize, 0), start_beyond_len.len);

    const start_equals_end = slice(&bytes, 2, 2);
    try testing.expectEqual(@as(usize, 0), start_equals_end.len);

    const start_greater_than_end = slice(&bytes, 3, 2);
    try testing.expectEqual(@as(usize, 0), start_greater_than_end.len);

    const end_beyond_len = slice(&bytes, 2, 100);
    try testing.expectEqualSlices(u8, &[_]u8{ 0x03, 0x04, 0x05 }, end_beyond_len);

    const empty_bytes = [_]u8{};
    const empty_slice = slice(&empty_bytes, 0, 0);
    try testing.expectEqual(@as(usize, 0), empty_slice.len);
}
```

### size function

```zig
test "size function" {
    const bytes1 = [_]u8{ 0x01, 0x02, 0x03 };
    try testing.expectEqual(@as(usize, 3), size(&bytes1));

    const bytes2 = [_]u8{};
    try testing.expectEqual(@as(usize, 0), size(&bytes2));

    const bytes3 = [_]u8{0x01} ** 1000;
    try testing.expectEqual(@as(usize, 1000), size(&bytes3));
}
```

### padRight function

```zig
test "padRight function" {
    const allocator = testing.allocator;

    const bytes = [_]u8{ 0x12, 0x34 };
    const padded = try padRight(allocator, &bytes, 5);
    defer allocator.free(padded);

    try testing.expectEqual(@as(usize, 5), padded.len);
    try testing.expectEqual(@as(u8, 0x12), padded[0]);
    try testing.expectEqual(@as(u8, 0x34), padded[1]);
    try testing.expectEqual(@as(u8, 0x00), padded[2]);
    try testing.expectEqual(@as(u8, 0x00), padded[3]);
    try testing.expectEqual(@as(u8, 0x00), padded[4]);

    const exact = try padRight(allocator, &bytes, 2);
    defer allocator.free(exact);
    try testing.expectEqualSlices(u8, &bytes, exact);

    const shorter = try padRight(allocator, &bytes, 1);
    defer allocator.free(shorter);
    try testing.expectEqualSlices(u8, &bytes, shorter);
}
```

### trimRightZeros function

```zig
test "trimRightZeros function" {
    const bytes1 = [_]u8{ 0x12, 0x34, 0x00, 0x00 };
    const trimmed1 = trimRightZeros(&bytes1);
    try testing.expectEqualSlices(u8, &[_]u8{ 0x12, 0x34 }, trimmed1);

    const bytes2 = [_]u8{ 0x00, 0x00, 0x12, 0x34 };
    const trimmed2 = trimRightZeros(&bytes2);
    try testing.expectEqualSlices(u8, &bytes2, trimmed2);

    const bytes3 = [_]u8{ 0x00, 0x00, 0x00 };
    const trimmed3 = trimRightZeros(&bytes3);
    try testing.expectEqual(@as(usize, 0), trimmed3.len);

    const bytes4 = [_]u8{ 0x12, 0x34, 0x56 };
    const trimmed4 = trimRightZeros(&bytes4);
    try testing.expectEqualSlices(u8, &bytes4, trimmed4);

    const empty = [_]u8{};
    const trimmed5 = trimRightZeros(&empty);
    try testing.expectEqual(@as(usize, 0), trimmed5.len);
}
```

### hexToBytesFixed with wrong length

```zig
test "hexToBytesFixed with wrong length" {
    const hex_short = "0x1234";
    const result1 = hexToBytesFixed(4, hex_short);
    try testing.expectError(HexError.InvalidHexLength, result1);

    const hex_long = "0x12345678";
    const result2 = hexToBytesFixed(2, hex_long);
    try testing.expectError(HexError.InvalidHexLength, result2);

    const hex_valid = "0x1234";
    const result3 = try hexToBytesFixed(2, hex_valid);
    try testing.expectEqual(@as(u8, 0x12), result3[0]);
    try testing.expectEqual(@as(u8, 0x34), result3[1]);
}
```

### case sensitivity in hex conversion

```zig
test "case sensitivity in hex conversion" {
    const allocator = testing.allocator;

    const lower = "0xabcdef";
    const upper = "0xABCDEF";
    const mixed = "0xAbCdEf";

    const bytes_lower = try hexToBytes(allocator, lower);
    defer allocator.free(bytes_lower);

    const bytes_upper = try hexToBytes(allocator, upper);
    defer allocator.free(bytes_upper);

    const bytes_mixed = try hexToBytes(allocator, mixed);
    defer allocator.free(bytes_mixed);

    try testing.expectEqualSlices(u8, bytes_lower, bytes_upper);
    try testing.expectEqualSlices(u8, bytes_lower, bytes_mixed);

    const hex_result = try bytesToHex(allocator, bytes_lower);
    defer allocator.free(hex_result);
    try testing.expectEqualStrings("0xabcdef", hex_result);
}
```

### hexToU64 edge cases

```zig
test "hexToU64 edge cases" {
    const zero_val = try hexToU64("0x0");
    try testing.expectEqual(@as(u64, 0), zero_val);

    const max_u64_hex = "0xffffffffffffffff";
    const max_result = try hexToU64(max_u64_hex);
    try testing.expectEqual(std.math.maxInt(u64), max_result);

    const overflow_hex = "0x10000000000000000";
    const overflow_result = hexToU64(overflow_hex);
    try testing.expectError(HexError.ValueTooLarge, overflow_result);

    const large_hex = "0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff";
    const large_result = hexToU64(large_hex);
    try testing.expectError(HexError.ValueTooLarge, large_result);
}
```

### u64ToHex function

```zig
test "u64ToHex function" {
    const allocator = testing.allocator;

    const zero_val = try u64ToHex(allocator, 0);
    defer allocator.free(zero_val);
    try testing.expectEqualStrings("0x0", zero_val);

    const small = try u64ToHex(allocator, 255);
    defer allocator.free(small);
    try testing.expectEqualStrings("0xff", small);

    const max_u64 = try u64ToHex(allocator, std.math.maxInt(u64));
    defer allocator.free(max_u64);
    try testing.expectEqualStrings("0xffffffffffffffff", max_u64);
}
```

### concat with empty arrays

```zig
test "concat with empty arrays" {
    const allocator = testing.allocator;

    const empty1 = [_]u8{};
    const empty2 = [_]u8{};
    const arrays1 = [_][]const u8{ &empty1, &empty2 };
    const result1 = try concat(allocator, &arrays1);
    defer allocator.free(result1);
    try testing.expectEqual(@as(usize, 0), result1.len);

    const bytes = [_]u8{ 0x12, 0x34 };
    const arrays2 = [_][]const u8{ &empty1, &bytes, &empty2 };
    const result2 = try concat(allocator, &arrays2);
    defer allocator.free(result2);
    try testing.expectEqualSlices(u8, &bytes, result2);

    const no_arrays = [_][]const u8{};
    const result3 = try concat(allocator, &no_arrays);
    defer allocator.free(result3);
    try testing.expectEqual(@as(usize, 0), result3.len);
}
```

### trim function (alias for trimLeftZeros)

```zig
test "trim function (alias for trimLeftZeros)" {
    const bytes = [_]u8{ 0x00, 0x00, 0x12, 0x34, 0x00 };
    const trimmed = trim(&bytes);
    try testing.expectEqualSlices(u8, &[_]u8{ 0x12, 0x34, 0x00 }, trimmed);

    const no_leading_zeros = [_]u8{ 0x12, 0x34 };
    const trimmed2 = trim(&no_leading_zeros);
    try testing.expectEqualSlices(u8, &no_leading_zeros, trimmed2);
}
```

### pad function (alias for padLeft)

```zig
test "pad function (alias for padLeft)" {
    const allocator = testing.allocator;

    const bytes = [_]u8{ 0x12, 0x34 };
    const padded = try pad(allocator, &bytes, 5);
    defer allocator.free(padded);

    try testing.expectEqual(@as(usize, 5), padded.len);
    try testing.expectEqual(@as(u8, 0x00), padded[0]);
    try testing.expectEqual(@as(u8, 0x00), padded[1]);
    try testing.expectEqual(@as(u8, 0x00), padded[2]);
    try testing.expectEqual(@as(u8, 0x12), padded[3]);
    try testing.expectEqual(@as(u8, 0x34), padded[4]);
}
```

### hex validation edge cases

```zig
test "hex validation edge cases" {
    try testing.expect(isHex("0x0"));
    try testing.expect(!isHex("0x"));
    try testing.expect(isHex("0xFfFfFf"));
    try testing.expect(!isHex("0x12 34"));
    try testing.expect(!isHex("x1234"));
}
```

### hexToBytes with maximum values

```zig
test "hexToBytes with maximum values" {
    const allocator = testing.allocator;

    const max_byte = try hexToBytes(allocator, "0xff");
    defer allocator.free(max_byte);
    try testing.expectEqual(@as(u8, 0xff), max_byte[0]);

    const max_u16 = try hexToBytes(allocator, "0xffff");
    defer allocator.free(max_u16);
    try testing.expectEqual(@as(u8, 0xff), max_u16[0]);
    try testing.expectEqual(@as(u8, 0xff), max_u16[1]);
}
```

### bytesToHex with zero bytes

```zig
test "bytesToHex with zero bytes" {
    const allocator = testing.allocator;

    const all_zeros = [_]u8{ 0x00, 0x00, 0x00 };
    const hex = try bytesToHex(allocator, &all_zeros);
    defer allocator.free(hex);
    try testing.expectEqualStrings("0x000000", hex);
}
```

### hexToBytesFixed with exact size

```zig
test "hexToBytesFixed with exact size" {
    const hex_4 = "0x12345678";
    const bytes_4 = try hexToBytesFixed(4, hex_4);
    try testing.expectEqual(@as(u8, 0x12), bytes_4[0]);
    try testing.expectEqual(@as(u8, 0x34), bytes_4[1]);
    try testing.expectEqual(@as(u8, 0x56), bytes_4[2]);
    try testing.expectEqual(@as(u8, 0x78), bytes_4[3]);
}
```

### hexToU256 with various values

```zig
test "hexToU256 with various values" {
    try testing.expectEqual(@as(u256, 0), try hexToU256("0x0"));
    try testing.expectEqual(@as(u256, 1), try hexToU256("0x1"));
    try testing.expectEqual(@as(u256, 255), try hexToU256("0xff"));
    try testing.expectEqual(@as(u256, 256), try hexToU256("0x100"));
}
```

### u256ToHex round-trip with powers of 2

```zig
test "u256ToHex round-trip with powers of 2" {
    const allocator = testing.allocator;

    const values = [_]u256{ 1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024 };
    for (values) |val| {
        const hex = try u256ToHex(allocator, val);
        defer allocator.free(hex);
        const result = try hexToU256(hex);
        try testing.expectEqual(val, result);
    }
}
```

### slice edge cases with empty inputs

```zig
test "slice edge cases with empty inputs" {
    const empty = [_]u8{};
    const empty_slice = slice(&empty, 0, 0);
    try testing.expectEqual(@as(usize, 0), empty_slice.len);

    const empty_slice2 = slice(&empty, 5, 10);
    try testing.expectEqual(@as(usize, 0), empty_slice2.len);
}
```

### concat with single array

```zig
test "concat with single array" {
    const allocator = testing.allocator;

    const bytes = [_]u8{ 0x12, 0x34 };
    const arrays = [_][]const u8{&bytes};
    const result = try concat(allocator, &arrays);
    defer allocator.free(result);

    try testing.expectEqualSlices(u8, &bytes, result);
}
```

### padLeft with zero target length

```zig
test "padLeft with zero target length" {
    const allocator = testing.allocator;

    const bytes = [_]u8{ 0x12, 0x34 };
    const result = try padLeft(allocator, &bytes, 0);
    defer allocator.free(result);

    try testing.expectEqualSlices(u8, &bytes, result);
}
```

### padRight with zero target length

```zig
test "padRight with zero target length" {
    const allocator = testing.allocator;

    const bytes = [_]u8{ 0x12, 0x34 };
    const result = try padRight(allocator, &bytes, 0);
    defer allocator.free(result);

    try testing.expectEqualSlices(u8, &bytes, result);
}
```

### trimLeftZeros with all zeros

```zig
test "trimLeftZeros with all zeros" {
    const all_zeros = [_]u8{ 0x00, 0x00, 0x00 };
    const trimmed = trimLeftZeros(&all_zeros);
    try testing.expectEqual(@as(usize, 0), trimmed.len);
}
```

### trimRightZeros with all zeros

```zig
test "trimRightZeros with all zeros" {
    const all_zeros = [_]u8{ 0x00, 0x00, 0x00 };
    const trimmed = trimRightZeros(&all_zeros);
    try testing.expectEqual(@as(usize, 0), trimmed.len);
}
```

### equals function

```zig
test "equals function" {
    // Equal hex strings
    try testing.expect(equals("0x1234", "0x1234"));
    try testing.expect(equals("0xabcd", "0xabcd"));

    // Case-insensitive comparison
    try testing.expect(equals("0xabcd", "0xABCD"));
    try testing.expect(equals("0xABCD", "0xabcd"));
    try testing.expect(equals("0xAbCd", "0xaBcD"));

    // Different values
    try testing.expect(!equals("0x1234", "0x5678"));
    try testing.expect(!equals("0xabcd", "0xef12"));

    // Different lengths
    try testing.expect(!equals("0x12", "0x1234"));
    try testing.expect(!equals("0x1234", "0x12"));

    // Empty hex
    try testing.expect(equals("0x", "0x"));
    try testing.expect(!equals("0x", "0x00"));
    try testing.expect(!equals("0x00", "0x"));
}
```

### clone function

```zig
test "clone function" {
    const allocator = testing.allocator;

    const hex1 = "0x1234";
    const hex2 = try clone(allocator, hex1);
    defer allocator.free(hex2);

    try testing.expect(equals(hex1, hex2));
    try testing.expectEqualStrings(hex1, hex2);

    // Clone empty hex
    const empty = "0x";
    const empty_clone = try clone(allocator, empty);
    defer allocator.free(empty_clone);
    try testing.expectEqualStrings(empty, empty_clone);
}
```

### xor function

```zig
test "xor function" {
    const allocator = testing.allocator;

    // Same-length XOR
    const result1 = try xor(allocator, "0x12", "0x34");
    defer allocator.free(result1);
    try testing.expectEqualStrings("0x26", result1);

    const result2 = try xor(allocator, "0xab", "0xcd");
    defer allocator.free(result2);
    try testing.expectEqualStrings("0x66", result2);

    // XOR with zeros
    const result3 = try xor(allocator, "0xff", "0x00");
    defer allocator.free(result3);
    try testing.expectEqualStrings("0xff", result3);

    // XOR with itself returns zeros
    const result4 = try xor(allocator, "0xdeadbeef", "0xdeadbeef");
    defer allocator.free(result4);
    try testing.expectEqualStrings("0x00000000", result4);

    // Empty hex XOR
    const result5 = try xor(allocator, "0x", "0x");
    defer allocator.free(result5);
    try testing.expectEqualStrings("0x", result5);

    // Mismatched lengths should error
    const result_err = xor(allocator, "0x12", "0x1234");
    try testing.expectError(HexError.InvalidLength, result_err);
}
```

### random function

```zig
test "random function" {
    const allocator = testing.allocator;

    // Generate random hex of various sizes
    const hex1 = try random(allocator, 4);
    defer allocator.free(hex1);
    try testing.expect(isHex(hex1));
    try testing.expectEqual(@as(usize, 10), hex1.len); // "0x" + 8 hex chars

    const hex2 = try random(allocator, 32);
    defer allocator.free(hex2);
    try testing.expect(isHex(hex2));
    try testing.expectEqual(@as(usize, 66), hex2.len); // "0x" + 64 hex chars

    // Zero size
    const hex_zero = try random(allocator, 0);
    defer allocator.free(hex_zero);
    try testing.expectEqualStrings("0x", hex_zero);

    // Different values each time (probabilistic test - try multiple times)
    var all_equal = true;
    var i: usize = 0;
    while (i < 5) : (i += 1) {
        const rand1 = try random(allocator, 32);
        defer allocator.free(rand1);
        const rand2 = try random(allocator, 32);
        defer allocator.free(rand2);
        if (!equals(rand1, rand2)) {
            all_equal = false;
            break;
        }
    }
    try testing.expect(!all_equal);
}
```

### zero function

```zig
test "zero function" {
    const allocator = testing.allocator;

    // Create zero-filled hex
    const hex1 = try zero(allocator, 1);
    defer allocator.free(hex1);
    try testing.expectEqualStrings("0x00", hex1);

    const hex2 = try zero(allocator, 2);
    defer allocator.free(hex2);
    try testing.expectEqualStrings("0x0000", hex2);

    const hex4 = try zero(allocator, 4);
    defer allocator.free(hex4);
    try testing.expectEqualStrings("0x00000000", hex4);

    // Empty hex
    const hex_empty = try zero(allocator, 0);
    defer allocator.free(hex_empty);
    try testing.expectEqualStrings("0x", hex_empty);

    // Large zero hex
    const hex32 = try zero(allocator, 32);
    defer allocator.free(hex32);
    try testing.expectEqualStrings("0x0000000000000000000000000000000000000000000000000000000000000000", hex32);
}
```

### validate function

```zig
test "validate function" {
    // Valid hex strings
    _ = try validate("0x0");
    _ = try validate("0x00");
    _ = try validate("0x1234");
    _ = try validate("0xabcdef");
    _ = try validate("0xABCDEF");
    _ = try validate("0x");

    // Invalid hex strings
    try testing.expectError(HexError.InvalidHexFormat, validate("1234"));
    try testing.expectError(HexError.InvalidHexFormat, validate(""));
    try testing.expectError(HexError.InvalidHexCharacter, validate("0xg"));
    try testing.expectError(HexError.InvalidHexCharacter, validate("0x123g"));
    try testing.expectError(HexError.InvalidHexCharacter, validate("0x "));
}
```

### isSized function

```zig
test "isSized function" {
    // Correct sizes
    try testing.expect(isSized("0x", 0));
    try testing.expect(isSized("0x00", 1));
    try testing.expect(isSized("0x1234", 2));
    try testing.expect(isSized("0x123456", 3));

    // Incorrect sizes
    try testing.expect(!isSized("0x1234", 1));
    try testing.expect(!isSized("0x1234", 3));
    try testing.expect(!isSized("0x", 1));
    try testing.expect(!isSized("0x00", 0));

    // Address size (20 bytes)
    const address = "0x" ++ "00" ** 20;
    try testing.expect(isSized(address, 20));
    try testing.expect(!isSized(address, 19));

    // Hash size (32 bytes)
    const hash = "0x" ++ "00" ** 32;
    try testing.expect(isSized(hash, 32));
    try testing.expect(!isSized(hash, 31));
}
```

### assertSize function

```zig
test "assertSize function" {
    // Valid sizes
    _ = try assertSize("0x", 0);
    _ = try assertSize("0x00", 1);
    _ = try assertSize("0x1234", 2);

    // Invalid sizes
    try testing.expectError(HexError.InvalidLength, assertSize("0x1234", 1));
    try testing.expectError(HexError.InvalidLength, assertSize("0x1234", 3));
    try testing.expectError(HexError.InvalidLength, assertSize("0x", 1));
}
```

### fromBoolean function

```zig
test "fromBoolean function" {
    const allocator = testing.allocator;

    // true -> 0x01
    const hex_true = try fromBoolean(allocator, true);
    defer allocator.free(hex_true);
    try testing.expectEqualStrings("0x01", hex_true);

    // false -> 0x00
    const hex_false = try fromBoolean(allocator, false);
    defer allocator.free(hex_false);
    try testing.expectEqualStrings("0x00", hex_false);
}
```

### toBoolean function

```zig
test "toBoolean function" {
    // 0x01 -> true
    try testing.expect(try toBoolean("0x01"));

    // 0x00 -> false
    try testing.expect(!try toBoolean("0x00"));

    // Non-zero -> true
    try testing.expect(try toBoolean("0xff"));
    try testing.expect(try toBoolean("0x1234"));
    try testing.expect(try toBoolean("0x000001"));

    // All zeros -> false
    try testing.expect(!try toBoolean("0x0000"));
    try testing.expect(!try toBoolean("0x00000000"));

    // Empty hex -> false
    try testing.expect(!try toBoolean("0x"));

    // Uppercase
    try testing.expect(try toBoolean("0xFF"));
    try testing.expect(!try toBoolean("0x00"));
}
```

### fromBoolean and toBoolean round-trip

```zig
test "fromBoolean and toBoolean round-trip" {
    const allocator = testing.allocator;

    const hex_true = try fromBoolean(allocator, true);
    defer allocator.free(hex_true);
    try testing.expect(try toBoolean(hex_true));

    const hex_false = try fromBoolean(allocator, false);
    defer allocator.free(hex_false);
    try testing.expect(!try toBoolean(hex_false));
}
```
