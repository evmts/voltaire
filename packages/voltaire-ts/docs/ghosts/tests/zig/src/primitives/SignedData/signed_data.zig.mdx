---
title: '[Zig] src/primitives/SignedData/signed_data.zig'
source: 'src/primitives/SignedData/signed_data.zig'
---

> Auto-generated from Zig tests in: src/primitives/SignedData/signed_data.zig

### from - personal message version

```zig
test "from - personal message version" {
    const allocator = std.testing.allocator;
    const message = "Hello!";
    var signed = try from(allocator, VERSION_PERSONAL_MESSAGE, &[_]u8{}, message);
    defer signed.deinit();

    try std.testing.expectEqual(EIP191_PREFIX, signed.getPrefix().?);
    try std.testing.expectEqual(VERSION_PERSONAL_MESSAGE, signed.getVersion().?);
}
```

### from - data with validator version

```zig
test "from - data with validator version" {
    const allocator = std.testing.allocator;
    const validator = [_]u8{0xaa} ** 20;
    const data = "test data";
    var signed = try from(allocator, VERSION_DATA_WITH_VALIDATOR, &validator, data);
    defer signed.deinit();

    try std.testing.expectEqual(VERSION_DATA_WITH_VALIDATOR, signed.getVersion().?);
    try std.testing.expectEqual(@as(usize, 2 + 20 + 9), signed.len());
}
```

### from - structured data version

```zig
test "from - structured data version" {
    const allocator = std.testing.allocator;
    const domain_separator = [_]u8{0xbb} ** 32;
    const data = [_]u8{0xcc} ** 32;
    var signed = try from(allocator, VERSION_STRUCTURED_DATA, &domain_separator, &data);
    defer signed.deinit();

    try std.testing.expectEqual(VERSION_STRUCTURED_DATA, signed.getVersion().?);
}
```

### from - invalid version

```zig
test "from - invalid version" {
    const allocator = std.testing.allocator;
    try std.testing.expectError(Error.InvalidVersion, from(allocator, 0xff, &[_]u8{}, "data"));
}
```

### fromPersonalMessage - basic

```zig
test "fromPersonalMessage - basic" {
    const allocator = std.testing.allocator;
    var signed = try fromPersonalMessage(allocator, "Hello!");
    defer signed.deinit();

    // Check prefix
    try std.testing.expect(std.mem.startsWith(u8, signed.bytes(), PERSONAL_MESSAGE_PREFIX));

    // Length should be: prefix (26) + "6" (1) + "Hello!" (6) = 33
    try std.testing.expectEqual(@as(usize, 33), signed.len());
}
```

### fromPersonalMessage - empty message

```zig
test "fromPersonalMessage - empty message" {
    const allocator = std.testing.allocator;
    var signed = try fromPersonalMessage(allocator, "");
    defer signed.deinit();

    // Length should be: prefix (26) + "0" (1) = 27
    try std.testing.expectEqual(@as(usize, 27), signed.len());
}
```

### fromPersonalMessage - long message

```zig
test "fromPersonalMessage - long message" {
    const allocator = std.testing.allocator;
    const message = "a" ** 100;
    var signed = try fromPersonalMessage(allocator, message);
    defer signed.deinit();

    // Length should be: prefix (26) + "100" (3) + message (100) = 129
    try std.testing.expectEqual(@as(usize, 129), signed.len());
}
```

### hash - personal message

```zig
test "hash - personal message" {
    const allocator = std.testing.allocator;
    var signed = try fromPersonalMessage(allocator, "Hello!");
    defer signed.deinit();

    const h = hash(&signed);
    try std.testing.expectEqual(@as(usize, 32), h.len);

    // Hash should be deterministic
    const h2 = hash(&signed);
    try std.testing.expectEqualSlices(u8, &h, &h2);
}
```

### hash - different messages produce different hashes

```zig
test "hash - different messages produce different hashes" {
    const allocator = std.testing.allocator;
    var signed1 = try fromPersonalMessage(allocator, "Hello!");
    defer signed1.deinit();
    var signed2 = try fromPersonalMessage(allocator, "World!");
    defer signed2.deinit();

    const h1 = hash(&signed1);
    const h2 = hash(&signed2);

    try std.testing.expect(!std.mem.eql(u8, &h1, &h2));
}
```

### hashPersonalMessage - basic

```zig
test "hashPersonalMessage - basic" {
    const allocator = std.testing.allocator;
    const h = try hashPersonalMessage(allocator, "Hello!");

    // Verify same as manual approach
    var signed = try fromPersonalMessage(allocator, "Hello!");
    defer signed.deinit();
    const h2 = hash(&signed);

    try std.testing.expectEqualSlices(u8, &h, &h2);
}
```

### equals - identical

```zig
test "equals - identical" {
    const allocator = std.testing.allocator;
    var signed1 = try fromPersonalMessage(allocator, "Hello!");
    defer signed1.deinit();
    var signed2 = try fromPersonalMessage(allocator, "Hello!");
    defer signed2.deinit();

    try std.testing.expect(equals(&signed1, &signed2));
}
```

### equals - different

```zig
test "equals - different" {
    const allocator = std.testing.allocator;
    var signed1 = try fromPersonalMessage(allocator, "Hello!");
    defer signed1.deinit();
    var signed2 = try fromPersonalMessage(allocator, "World!");
    defer signed2.deinit();

    try std.testing.expect(!equals(&signed1, &signed2));
}
```

### isValid - valid personal message

```zig
test "isValid - valid personal message" {
    const allocator = std.testing.allocator;
    var signed = try from(allocator, VERSION_PERSONAL_MESSAGE, &[_]u8{}, "test");
    defer signed.deinit();

    try std.testing.expect(isValid(&signed));
}
```

### isValid - valid data with validator

```zig
test "isValid - valid data with validator" {
    const allocator = std.testing.allocator;
    const validator = [_]u8{0xaa} ** 20;
    var signed = try from(allocator, VERSION_DATA_WITH_VALIDATOR, &validator, "test");
    defer signed.deinit();

    try std.testing.expect(isValid(&signed));
}
```

### isPersonalMessage - true

```zig
test "isPersonalMessage - true" {
    const allocator = std.testing.allocator;
    var signed = try from(allocator, VERSION_PERSONAL_MESSAGE, &[_]u8{}, "test");
    defer signed.deinit();

    try std.testing.expect(isPersonalMessage(&signed));
}
```

### isPersonalMessage - false

```zig
test "isPersonalMessage - false" {
    const allocator = std.testing.allocator;
    const validator = [_]u8{0xaa} ** 20;
    var signed = try from(allocator, VERSION_DATA_WITH_VALIDATOR, &validator, "test");
    defer signed.deinit();

    try std.testing.expect(!isPersonalMessage(&signed));
}
```

### isStructuredData - true

```zig
test "isStructuredData - true" {
    const allocator = std.testing.allocator;
    const domain_separator = [_]u8{0xbb} ** 32;
    var signed = try from(allocator, VERSION_STRUCTURED_DATA, &domain_separator, &[_]u8{0xcc} ** 32);
    defer signed.deinit();

    try std.testing.expect(isStructuredData(&signed));
}
```

### isDataWithValidator - true

```zig
test "isDataWithValidator - true" {
    const allocator = std.testing.allocator;
    const validator = [_]u8{0xaa} ** 20;
    var signed = try from(allocator, VERSION_DATA_WITH_VALIDATOR, &validator, "test");
    defer signed.deinit();

    try std.testing.expect(isDataWithValidator(&signed));
}
```

### clone - creates independent copy

```zig
test "clone - creates independent copy" {
    const allocator = std.testing.allocator;
    var original = try fromPersonalMessage(allocator, "Hello!");
    defer original.deinit();

    var copy = try clone(allocator, &original);
    defer copy.deinit();

    try std.testing.expect(equals(&original, &copy));
    try std.testing.expect(original.data.ptr != copy.data.ptr);
}
```

### SignedMessage - fromSignature creates valid structure

```zig
test "SignedMessage - fromSignature creates valid structure" {
    const allocator = std.testing.allocator;

    // Test data
    const data = "Hello, Ethereum!";

    // Create test signature components (these are mock values)
    // In real usage, these would come from actual signing
    const r = [_]u8{0x01} ** 32;
    const s = [_]u8{0x02} ** 32;
    const v: u8 = 27;

    // Note: This will fail signature recovery with mock values
    // but tests the structure creation
    const result = fromSignature(allocator, data, r, s, v);

    if (result) |*msg| {
        defer msg.deinit();
        try std.testing.expectEqualSlices(u8, data, msg.getData());
        try std.testing.expectEqual(@as(?u8, 27), msg.getSignature().v);
    } else |_| {
        // Expected to fail with mock signature values - that's ok
    }
}
```

### SignedMessage.verify - compares signer addresses

```zig
test "SignedMessage.verify - compares signer addresses" {
    // Create a mock SignedMessage for testing verify logic
    const allocator = std.testing.allocator;
    const data = allocator.alloc(u8, 5) catch unreachable;
    @memcpy(data, "Hello");

    const sig = Signature.fromSecp256k1([_]u8{1} ** 32, [_]u8{2} ** 32, 27);
    var signer: Address = undefined;
    @memset(&signer.bytes, 0xaa);

    var msg = SignedMessage{
        .data = data,
        .signature = sig,
        .signer = signer,
        .allocator = allocator,
    };
    defer msg.deinit();

    // Verify against same address
    var same_addr: Address = undefined;
    @memset(&same_addr.bytes, 0xaa);
    try std.testing.expect(msg.verify(same_addr));

    // Verify against different address
    var diff_addr: Address = undefined;
    @memset(&diff_addr.bytes, 0xbb);
    try std.testing.expect(!msg.verify(diff_addr));
}
```

### SignedMessage.equals - compares all fields

```zig
test "SignedMessage.equals - compares all fields" {
    const allocator = std.testing.allocator;

    // Create two identical messages
    const data1 = allocator.alloc(u8, 5) catch unreachable;
    @memcpy(data1, "Hello");
    const data2 = allocator.alloc(u8, 5) catch unreachable;
    @memcpy(data2, "Hello");

    const sig = Signature.fromSecp256k1([_]u8{1} ** 32, [_]u8{2} ** 32, 27);
    var signer: Address = undefined;
    @memset(&signer.bytes, 0xaa);

    var msg1 = SignedMessage{
        .data = data1,
        .signature = sig,
        .signer = signer,
        .allocator = allocator,
    };
    defer msg1.deinit();

    var msg2 = SignedMessage{
        .data = data2,
        .signature = sig,
        .signer = signer,
        .allocator = allocator,
    };
    defer msg2.deinit();

    try std.testing.expect(msg1.equals(&msg2));
}
```

### SignedMessage.equals - different data returns false

```zig
test "SignedMessage.equals - different data returns false" {
    const allocator = std.testing.allocator;

    const data1 = allocator.alloc(u8, 5) catch unreachable;
    @memcpy(data1, "Hello");
    const data2 = allocator.alloc(u8, 5) catch unreachable;
    @memcpy(data2, "World");

    const sig = Signature.fromSecp256k1([_]u8{1} ** 32, [_]u8{2} ** 32, 27);
    var signer: Address = undefined;
    @memset(&signer.bytes, 0xaa);

    var msg1 = SignedMessage{
        .data = data1,
        .signature = sig,
        .signer = signer,
        .allocator = allocator,
    };
    defer msg1.deinit();

    var msg2 = SignedMessage{
        .data = data2,
        .signature = sig,
        .signer = signer,
        .allocator = allocator,
    };
    defer msg2.deinit();

    try std.testing.expect(!msg1.equals(&msg2));
}
```

### recoverSigner - returns error for invalid signature

```zig
test "recoverSigner - returns error for invalid signature" {
    const msg_hash = [_]u8{0xab} ** 32;
    const r = [_]u8{0x00} ** 32; // Invalid: r cannot be 0
    const s = [_]u8{0x01} ** 32;
    const v: u8 = 27;

    const result = recoverSigner(msg_hash, r, s, v);
    try std.testing.expectError(SignedMessageError.InvalidSignature, result);
}
```

### verifySigner - returns false for invalid signature

```zig
test "verifySigner - returns false for invalid signature" {
    const msg_hash = [_]u8{0xab} ** 32;
    const r = [_]u8{0x00} ** 32; // Invalid
    const s = [_]u8{0x01} ** 32;
    const v: u8 = 27;

    var expected: Address = undefined;
    @memset(&expected.bytes, 0xcc);

    try std.testing.expect(!verifySigner(msg_hash, r, s, v, expected));
}
```

### verifyPersonalMessage - returns false for invalid signature

```zig
test "verifyPersonalMessage - returns false for invalid signature" {
    const allocator = std.testing.allocator;
    const message = "Test message";
    const r = [_]u8{0x00} ** 32; // Invalid
    const s = [_]u8{0x01} ** 32;
    const v: u8 = 27;

    var expected: Address = undefined;
    @memset(&expected.bytes, 0xcc);

    try std.testing.expect(!verifyPersonalMessage(allocator, message, r, s, v, expected));
}
```
