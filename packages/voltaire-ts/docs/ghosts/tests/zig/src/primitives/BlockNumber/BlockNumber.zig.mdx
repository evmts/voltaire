---
title: '[Zig] src/primitives/BlockNumber/BlockNumber.zig'
source: 'src/primitives/BlockNumber/BlockNumber.zig'
---

> Auto-generated from Zig tests in: src/primitives/BlockNumber/BlockNumber.zig

### BlockNumber.from creates block number from u64

```zig
test "BlockNumber.from creates block number from u64" {
    const block = from(123456);
    try std.testing.expectEqual(@as(u64, 123456), block);
}
```

### BlockNumber.from handles zero

```zig
test "BlockNumber.from handles zero" {
    const block = from(0);
    try std.testing.expectEqual(@as(u64, 0), block);
}
```

### BlockNumber.from handles max u64

```zig
test "BlockNumber.from handles max u64" {
    const block = from(std.math.maxInt(u64));
    try std.testing.expectEqual(std.math.maxInt(u64), block);
}
```

### BlockNumber.fromBigInt converts u256 to block number

```zig
test "BlockNumber.fromBigInt converts u256 to block number" {
    const block = fromBigInt(123456);
    try std.testing.expectEqual(@as(u64, 123456), block);
}
```

### BlockNumber.fromBigInt truncates large values

```zig
test "BlockNumber.fromBigInt truncates large values" {
    const large_value: u256 = std.math.maxInt(u64) + 1;
    const block = fromBigInt(large_value);
    // Will truncate to 0 due to overflow
    try std.testing.expectEqual(@as(u64, 0), block);
}
```

### BlockNumber.toBigInt converts block number to u256

```zig
test "BlockNumber.toBigInt converts block number to u256" {
    const block = from(123456);
    const result = toBigInt(block);
    try std.testing.expectEqual(@as(u256, 123456), result);
}
```

### BlockNumber.toBigInt handles max u64

```zig
test "BlockNumber.toBigInt handles max u64" {
    const block = from(std.math.maxInt(u64));
    const result = toBigInt(block);
    try std.testing.expectEqual(@as(u256, std.math.maxInt(u64)), result);
}
```

### BlockNumber.toNumber converts block number to u64

```zig
test "BlockNumber.toNumber converts block number to u64" {
    const block = from(999);
    const result = toNumber(block);
    try std.testing.expectEqual(@as(u64, 999), result);
}
```

### BlockNumber.toNumber is identity function

```zig
test "BlockNumber.toNumber is identity function" {
    const block = from(12345);
    const result = toNumber(block);
    try std.testing.expectEqual(block, result);
}
```

### BlockNumber.equals returns true for equal blocks

```zig
test "BlockNumber.equals returns true for equal blocks" {
    const a = from(100);
    const b = from(100);
    try std.testing.expect(equals(a, b));
}
```

### BlockNumber.equals returns false for different blocks

```zig
test "BlockNumber.equals returns false for different blocks" {
    const a = from(100);
    const b = from(101);
    try std.testing.expect(!equals(a, b));
}
```

### BlockNumber.equals handles zero

```zig
test "BlockNumber.equals handles zero" {
    const a = from(0);
    const b = from(0);
    try std.testing.expect(equals(a, b));
}
```

### BlockNumber.equals handles max u64

```zig
test "BlockNumber.equals handles max u64" {
    const a = from(std.math.maxInt(u64));
    const b = from(std.math.maxInt(u64));
    try std.testing.expect(equals(a, b));
}
```

### BlockNumber constants

```zig
test "BlockNumber constants" {
    try std.testing.expectEqual(@as(u64, 0), MIN);
    try std.testing.expectEqual(@as(u64, 0), ZERO);
    try std.testing.expectEqual(@as(u64, 1), ONE);
    try std.testing.expectEqual(std.math.maxInt(u256), MAX);
}
```

### BlockNumber.from accepts ZERO constant

```zig
test "BlockNumber.from accepts ZERO constant" {
    const block = from(ZERO);
    try std.testing.expectEqual(@as(u64, 0), block);
}
```

### BlockNumber.from accepts ONE constant

```zig
test "BlockNumber.from accepts ONE constant" {
    const block = from(ONE);
    try std.testing.expectEqual(@as(u64, 1), block);
}
```
