---
title: '[Zig] src/primitives/Ssz/variableTypes.zig'
source: 'src/primitives/Ssz/variableTypes.zig'
---

> Auto-generated from Zig tests in: src/primitives/Ssz/variableTypes.zig

### encodeVector u8

```zig
test "encodeVector u8" {
    const allocator = std.testing.allocator;
    const items = [_]u8{ 1, 2, 3, 4 };
    const result = try encodeVector(allocator, u8, &items);
    defer allocator.free(result);

    try std.testing.expectEqual(@as(usize, 4), result.len);
    try std.testing.expectEqual(@as(u8, 1), result[0]);
    try std.testing.expectEqual(@as(u8, 2), result[1]);
    try std.testing.expectEqual(@as(u8, 3), result[2]);
    try std.testing.expectEqual(@as(u8, 4), result[3]);
}
```

### encodeVector u32

```zig
test "encodeVector u32" {
    const allocator = std.testing.allocator;
    const items = [_]u32{ 0x01020304, 0x05060708 };
    const result = try encodeVector(allocator, u32, &items);
    defer allocator.free(result);

    try std.testing.expectEqual(@as(usize, 8), result.len);
}
```

### encodeList

```zig
test "encodeList" {
    const allocator = std.testing.allocator;
    const items = [_]u8{ 1, 2, 3 };
    const result = try encodeList(allocator, u8, &items, 10);
    defer allocator.free(result);

    try std.testing.expectEqual(@as(usize, 7), result.len); // 4 byte prefix + 3 items
    // Check length prefix (little-endian)
    try std.testing.expectEqual(@as(u8, 3), result[0]);
    try std.testing.expectEqual(@as(u8, 0), result[1]);
    try std.testing.expectEqual(@as(u8, 0), result[2]);
    try std.testing.expectEqual(@as(u8, 0), result[3]);
    // Check items
    try std.testing.expectEqual(@as(u8, 1), result[4]);
    try std.testing.expectEqual(@as(u8, 2), result[5]);
    try std.testing.expectEqual(@as(u8, 3), result[6]);
}
```

### encodeList exceeds max

```zig
test "encodeList exceeds max" {
    const allocator = std.testing.allocator;
    const items = [_]u8{ 1, 2, 3, 4, 5 };
    const result = encodeList(allocator, u8, &items, 3);
    try std.testing.expectError(error.ExceedsMaxLength, result);
}
```

### encodeBitvector

```zig
test "encodeBitvector" {
    const allocator = std.testing.allocator;
    const bits = [_]bool{ true, false, true, true, false, false, true, false };
    const result = try encodeBitvector(allocator, &bits);
    defer allocator.free(result);

    try std.testing.expectEqual(@as(usize, 1), result.len);
    // Binary: 01011101 (reversed due to LSB first)
    try std.testing.expectEqual(@as(u8, 0b01011101), result[0]);
}
```

### encodeBitvector multi-byte

```zig
test "encodeBitvector multi-byte" {
    const allocator = std.testing.allocator;
    const bits = [_]bool{ true, false, false, false, false, false, false, false, true };
    const result = try encodeBitvector(allocator, &bits);
    defer allocator.free(result);

    try std.testing.expectEqual(@as(usize, 2), result.len);
    try std.testing.expectEqual(@as(u8, 0b00000001), result[0]);
    try std.testing.expectEqual(@as(u8, 0b00000001), result[1]);
}
```

### encodeBitlist

```zig
test "encodeBitlist" {
    const allocator = std.testing.allocator;
    const bits = [_]bool{ true, false, true };
    const result = try encodeBitlist(allocator, &bits, 10);
    defer allocator.free(result);

    try std.testing.expectEqual(@as(usize, 1), result.len);
    // Binary: 00001101 (data bits + sentinel)
    try std.testing.expectEqual(@as(u8, 0b00001101), result[0]);
}
```

### encodeBytes

```zig
test "encodeBytes" {
    const allocator = std.testing.allocator;
    const bytes = [_]u8{ 0xDE, 0xAD, 0xBE, 0xEF };
    const result = try encodeBytes(allocator, &bytes);
    defer allocator.free(result);

    try std.testing.expectEqual(@as(usize, 4), result.len);
    try std.testing.expectEqualSlices(u8, &bytes, result);
}
```
