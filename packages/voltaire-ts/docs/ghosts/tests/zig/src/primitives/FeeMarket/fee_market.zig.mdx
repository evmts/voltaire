---
title: '[Zig] src/primitives/FeeMarket/fee_market.zig'
source: 'src/primitives/FeeMarket/fee_market.zig'
---

> Auto-generated from Zig tests in: src/primitives/FeeMarket/fee_market.zig

### calculateFeeDelta basic functionality

```zig
test "calculateFeeDelta basic functionality" {
    // Test basic calculation
    const fee = 1000;
    const gas_delta = 100;
    const gas_target = 1000;
    const denominator = 8;

    const result = calculateFeeDelta(fee, gas_delta, gas_target, denominator);
    // Expected: (1000 * 100) / (1000 * 8) = 100000 / 8000 = 12.5, rounded to 12
    try std.testing.expectEqual(@as(u64, 12), result);
}
```

### calculateFeeDelta returns at least 1

```zig
test "calculateFeeDelta returns at least 1" {
    // Test that result is always at least 1
    const fee = 1;
    const gas_delta = 1;
    const gas_target = 1000000;
    const denominator = 1000000;

    const result = calculateFeeDelta(fee, gas_delta, gas_target, denominator);
    try std.testing.expectEqual(@as(u64, 1), result);
}
```

### calculateFeeDelta handles large values without overflow

```zig
test "calculateFeeDelta handles large values without overflow" {
    // Test with large values that would overflow u64 in intermediate calculations
    const fee = std.math.maxInt(u64) / 2;
    const gas_delta = 1000;
    const gas_target = 1000;
    const denominator = 1;

    const result = calculateFeeDelta(fee, gas_delta, gas_target, denominator);
    // Should not panic and return a valid result
    try std.testing.expect(result > 0);
}
```

### calculateFeeDelta handles division by zero protection

```zig
test "calculateFeeDelta handles division by zero protection" {
    // Test with zero gas_target and denominator
    const fee = 1000;
    const gas_delta = 100;
    const gas_target = 0;
    const denominator = 0;

    const result = calculateFeeDelta(fee, gas_delta, gas_target, denominator);
    // Should use divisor of 1 and return fee * gas_delta
    try std.testing.expectEqual(@as(u64, 100000), result);
}
```

### MIN_BASE_FEE constant value

```zig
test "MIN_BASE_FEE constant value" {
    try std.testing.expectEqual(@as(u64, 7), MIN_BASE_FEE);
}
```

### BASE_FEE_CHANGE_DENOMINATOR constant value

```zig
test "BASE_FEE_CHANGE_DENOMINATOR constant value" {
    try std.testing.expectEqual(@as(u64, 8), BASE_FEE_CHANGE_DENOMINATOR);
}
```

### initial_base_fee with exactly target gas usage

```zig
test "initial_base_fee with exactly target gas usage" {
    const parent_gas_limit = 30_000_000;
    const parent_gas_used = 15_000_000; // Exactly half (target)

    const base_fee = initialBaseFee(parent_gas_used, parent_gas_limit);
    // When exactly at target, there's still a minimal adjustment due to calculateFeeDelta returning at least 1
    // gas_used_delta = 0, but calculate_fee_delta returns 1, so base_fee = 1_000_000_000 - 1
    try std.testing.expectEqual(@as(u64, 999_999_999), base_fee);
}
```

### initial_base_fee with above target gas usage

```zig
test "initial_base_fee with above target gas usage" {
    const parent_gas_limit = 30_000_000;
    const parent_gas_used = 20_000_000; // Above target (15M)

    const base_fee = initialBaseFee(parent_gas_used, parent_gas_limit);
    // Should be higher than 1 gwei
    try std.testing.expect(base_fee > 1_000_000_000);

    // Calculate expected: 1 gwei + (1 gwei * 5M / 15M / 8)
    // = 1_000_000_000 + (1_000_000_000 * 5_000_000 / 15_000_000 / 8)
    // = 1_000_000_000 + 41_666_666
    try std.testing.expectEqual(@as(u64, 1_041_666_666), base_fee);
}
```

### initial_base_fee with below target gas usage

```zig
test "initial_base_fee with below target gas usage" {
    const parent_gas_limit = 30_000_000;
    const parent_gas_used = 10_000_000; // Below target (15M)

    const base_fee = initialBaseFee(parent_gas_used, parent_gas_limit);
    // Should be lower than 1 gwei
    try std.testing.expect(base_fee < 1_000_000_000);

    // Calculate expected: 1 gwei - (1 gwei * 5M / 15M / 8)
    // = 1_000_000_000 - 41_666_666
    try std.testing.expectEqual(@as(u64, 958_333_334), base_fee);
}
```

### initial_base_fee with zero gas usage

```zig
test "initial_base_fee with zero gas usage" {
    const parent_gas_limit = 30_000_000;
    const parent_gas_used = 0;

    const base_fee = initialBaseFee(parent_gas_used, parent_gas_limit);
    // Should return 1 gwei (no adjustment)
    try std.testing.expectEqual(@as(u64, 1_000_000_000), base_fee);
}
```

### initial_base_fee respects minimum base fee

```zig
test "initial_base_fee respects minimum base fee" {
    const parent_gas_limit = 100;
    const parent_gas_used = 0;

    const base_fee = initialBaseFee(parent_gas_used, parent_gas_limit);
    // Even with extreme values, should respect MIN_BASE_FEE
    try std.testing.expect(base_fee >= MIN_BASE_FEE);
}
```

### next_base_fee with exactly target gas usage

```zig
test "next_base_fee with exactly target gas usage" {
    const parent_base_fee = 1_000_000_000;
    const parent_gas_target = 15_000_000;
    const parent_gas_used = 15_000_000; // Exactly target

    const next_fee = nextBaseFee(parent_base_fee, parent_gas_used, parent_gas_target);
    // Should remain the same
    try std.testing.expectEqual(parent_base_fee, next_fee);
}
```

### next_base_fee with above target gas usage

```zig
test "next_base_fee with above target gas usage" {
    const parent_base_fee = 1_000_000_000;
    const parent_gas_target = 15_000_000;
    const parent_gas_used = 20_000_000; // 5M above target

    const next_fee = nextBaseFee(parent_base_fee, parent_gas_used, parent_gas_target);
    // Should increase by up to 12.5%
    try std.testing.expect(next_fee > parent_base_fee);

    // Expected increase: base_fee * (5M / 15M) / 8 = base_fee * 1/24
    const expected = parent_base_fee + (parent_base_fee / 24);
    try std.testing.expectEqual(expected, next_fee);
}
```

### next_base_fee with below target gas usage

```zig
test "next_base_fee with below target gas usage" {
    const parent_base_fee = 1_000_000_000;
    const parent_gas_target = 15_000_000;
    const parent_gas_used = 10_000_000; // 5M below target

    const next_fee = nextBaseFee(parent_base_fee, parent_gas_used, parent_gas_target);
    // Should decrease by up to 12.5%
    try std.testing.expect(next_fee < parent_base_fee);

    // Expected decrease: base_fee * (5M / 15M) / 8 = base_fee * 1/24
    const expected = parent_base_fee - (parent_base_fee / 24);
    try std.testing.expectEqual(expected, next_fee);
}
```

### next_base_fee with maximum increase (full block)

```zig
test "next_base_fee with maximum increase (full block)" {
    const parent_base_fee = 1_000_000_000;
    const parent_gas_target = 15_000_000;
    const parent_gas_used = 30_000_000; // Double the target (full block)

    const next_fee = nextBaseFee(parent_base_fee, parent_gas_used, parent_gas_target);
    // Should increase by exactly 12.5%
    const expected = parent_base_fee + (parent_base_fee / 8);
    try std.testing.expectEqual(expected, next_fee);
}
```

### next_base_fee with empty parent block

```zig
test "next_base_fee with empty parent block" {
    const parent_base_fee = 1_000_000_000;
    const parent_gas_target = 15_000_000;
    const parent_gas_used = 0; // Empty block

    const next_fee = nextBaseFee(parent_base_fee, parent_gas_used, parent_gas_target);
    // Should remain the same for empty blocks
    try std.testing.expectEqual(parent_base_fee, next_fee);
}
```

### next_base_fee respects minimum base fee on decrease

```zig
test "next_base_fee respects minimum base fee on decrease" {
    const parent_base_fee = 10; // Very low base fee
    const parent_gas_target = 15_000_000;
    const parent_gas_used = 0; // Would normally decrease

    const next_fee = nextBaseFee(parent_base_fee, parent_gas_used, parent_gas_target);
    // Should not go below MIN_BASE_FEE
    try std.testing.expectEqual(@as(u64, 10), next_fee); // Stays at parent fee since it's above MIN_BASE_FEE
}
```

### next_base_fee respects minimum when decrease would go below

```zig
test "next_base_fee respects minimum when decrease would go below" {
    const parent_base_fee = 8; // Just above MIN_BASE_FEE
    const parent_gas_target = 15_000_000;
    const parent_gas_used = 1; // Very low usage

    const next_fee = nextBaseFee(parent_base_fee, parent_gas_used, parent_gas_target);
    // Should not go below MIN_BASE_FEE
    try std.testing.expect(next_fee >= MIN_BASE_FEE);
}
```

### next_base_fee handles overflow protection

```zig
test "next_base_fee handles overflow protection" {
    const parent_base_fee = std.math.maxInt(u64) - 1000;
    const parent_gas_target = 15_000_000;
    const parent_gas_used = 30_000_000; // Would increase

    const next_fee = nextBaseFee(parent_base_fee, parent_gas_used, parent_gas_target);
    // Should handle overflow gracefully
    try std.testing.expectEqual(parent_base_fee, next_fee);
}
```

### get_effective_gas_price with sufficient max fee

```zig
test "get_effective_gas_price with sufficient max fee" {
    const base_fee = 1_000_000_000; // 1 gwei
    const max_fee = 2_000_000_000; // 2 gwei
    const max_priority_fee = 500_000_000; // 0.5 gwei

    const result = getEffectiveGasPrice(base_fee, max_fee, max_priority_fee);
    // Effective price should be base + priority
    try std.testing.expectEqual(@as(u64, 1_500_000_000), result.effective_gas_price);
    try std.testing.expectEqual(@as(u64, 500_000_000), result.miner_fee);
}
```

### get_effective_gas_price with limited max fee

```zig
test "get_effective_gas_price with limited max fee" {
    const base_fee = 1_000_000_000; // 1 gwei
    const max_fee = 1_200_000_000; // 1.2 gwei
    const max_priority_fee = 500_000_000; // 0.5 gwei (more than available)

    const result = getEffectiveGasPrice(base_fee, max_fee, max_priority_fee);
    // Priority fee limited by max_fee - base_fee
    try std.testing.expectEqual(@as(u64, 1_200_000_000), result.effective_gas_price);
    try std.testing.expectEqual(@as(u64, 200_000_000), result.miner_fee);
}
```

### get_effective_gas_price with max fee below base fee

```zig
test "get_effective_gas_price with max fee below base fee" {
    const base_fee = 1_000_000_000; // 1 gwei
    const max_fee = 800_000_000; // 0.8 gwei (below base)
    const max_priority_fee = 100_000_000; // 0.1 gwei

    const result = getEffectiveGasPrice(base_fee, max_fee, max_priority_fee);
    // Transaction would be rejected, but returns max_fee and 0 miner fee
    try std.testing.expectEqual(@as(u64, 800_000_000), result.effective_gas_price);
    try std.testing.expectEqual(@as(u64, 0), result.miner_fee);
}
```

### get_effective_gas_price with zero priority fee

```zig
test "get_effective_gas_price with zero priority fee" {
    const base_fee = 1_000_000_000; // 1 gwei
    const max_fee = 2_000_000_000; // 2 gwei
    const max_priority_fee = 0; // No tip

    const result = getEffectiveGasPrice(base_fee, max_fee, max_priority_fee);
    // Should just pay base fee
    try std.testing.expectEqual(base_fee, result.effective_gas_price);
    try std.testing.expectEqual(@as(u64, 0), result.miner_fee);
}
```

### get_effective_gas_price with exact base fee

```zig
test "get_effective_gas_price with exact base fee" {
    const base_fee = 1_000_000_000; // 1 gwei
    const max_fee = 1_000_000_000; // Exactly base fee
    const max_priority_fee = 100_000_000; // 0.1 gwei (can't be paid)

    const result = getEffectiveGasPrice(base_fee, max_fee, max_priority_fee);
    // No room for priority fee
    try std.testing.expectEqual(base_fee, result.effective_gas_price);
    try std.testing.expectEqual(@as(u64, 0), result.miner_fee);
}
```

### get_gas_target basic calculation

```zig
test "get_gas_target basic calculation" {
    const gas_limit = 30_000_000;
    const target = getGasTarget(gas_limit);
    try std.testing.expectEqual(@as(u64, 15_000_000), target);
}
```

### get_gas_target with odd gas limit

```zig
test "get_gas_target with odd gas limit" {
    const gas_limit = 30_000_001;
    const target = getGasTarget(gas_limit);
    // Integer division rounds down
    try std.testing.expectEqual(@as(u64, 15_000_000), target);
}
```

### get_gas_target with zero gas limit

```zig
test "get_gas_target with zero gas limit" {
    const gas_limit = 0;
    const target = getGasTarget(gas_limit);
    try std.testing.expectEqual(@as(u64, 0), target);
}
```

### get_gas_target with small gas limit

```zig
test "get_gas_target with small gas limit" {
    const gas_limit = 1;
    const target = getGasTarget(gas_limit);
    try std.testing.expectEqual(@as(u64, 0), target);
}
```

### initialBaseFee with maximum gas limit

```zig
test "initialBaseFee with maximum gas limit" {
    const parent_gas_limit = std.math.maxInt(u64);
    const parent_gas_used = std.math.maxInt(u64) / 2; // At target

    const base_fee = initialBaseFee(parent_gas_used, parent_gas_limit);
    // Should handle large values without overflow
    try std.testing.expect(base_fee >= MIN_BASE_FEE);
}
```

### initialBaseFee with full parent block

```zig
test "initialBaseFee with full parent block" {
    const parent_gas_limit = 30_000_000;
    const parent_gas_used = 30_000_000; // Completely full

    const base_fee = initialBaseFee(parent_gas_used, parent_gas_limit);
    // Should be at maximum increase (12.5%)
    // 1 gwei + (1 gwei * 15M / 15M / 8) = 1 gwei + 125M wei
    try std.testing.expectEqual(@as(u64, 1_125_000_000), base_fee);
}
```

### initialBaseFee with very small gas limit

```zig
test "initialBaseFee with very small gas limit" {
    const parent_gas_limit = 100;
    const parent_gas_used = 50; // At target

    const base_fee = initialBaseFee(parent_gas_used, parent_gas_limit);
    // Should still work with small values and respect minimum
    try std.testing.expect(base_fee >= MIN_BASE_FEE);
}
```

### initialBaseFee with near-zero parent gas used

```zig
test "initialBaseFee with near-zero parent gas used" {
    const parent_gas_limit = 30_000_000;
    const parent_gas_used = 1; // Nearly empty

    const base_fee = initialBaseFee(parent_gas_used, parent_gas_limit);
    // Should decrease from 1 gwei but respect minimum
    try std.testing.expect(base_fee < 1_000_000_000);
    try std.testing.expect(base_fee >= MIN_BASE_FEE);
}
```

### initialBaseFee with extreme below-target usage

```zig
test "initialBaseFee with extreme below-target usage" {
    const parent_gas_limit = 30_000_000;
    const parent_gas_used = 100; // Way below target

    const base_fee = initialBaseFee(parent_gas_used, parent_gas_limit);
    // Should decrease significantly but respect minimum
    try std.testing.expect(base_fee >= MIN_BASE_FEE);
}
```

### initialBaseFee minimum enforcement at boundary

```zig
test "initialBaseFee minimum enforcement at boundary" {
    const parent_gas_limit = 1000;
    const parent_gas_used = 1; // Very low usage to force decrease

    const base_fee = initialBaseFee(parent_gas_used, parent_gas_limit);
    // Even with extreme decrease, should not go below MIN_BASE_FEE
    try std.testing.expectEqual(MIN_BASE_FEE, base_fee);
}
```

### nextBaseFee with minimal above-target usage

```zig
test "nextBaseFee with minimal above-target usage" {
    const parent_base_fee = 1_000_000_000;
    const parent_gas_target = 15_000_000;
    const parent_gas_used = 15_000_001; // Just 1 over target

    const next_fee = nextBaseFee(parent_base_fee, parent_gas_used, parent_gas_target);
    // Should increase minimally (at least by 1)
    try std.testing.expect(next_fee > parent_base_fee);
    try std.testing.expect(next_fee - parent_base_fee >= 1);
}
```

### nextBaseFee with minimal below-target usage

```zig
test "nextBaseFee with minimal below-target usage" {
    const parent_base_fee = 1_000_000_000;
    const parent_gas_target = 15_000_000;
    const parent_gas_used = 14_999_999; // Just 1 under target

    const next_fee = nextBaseFee(parent_base_fee, parent_gas_used, parent_gas_target);
    // Should decrease minimally (at least by 1)
    try std.testing.expect(next_fee < parent_base_fee);
    try std.testing.expect(parent_base_fee - next_fee >= 1);
}
```

### nextBaseFee precision with small base fee

```zig
test "nextBaseFee precision with small base fee" {
    const parent_base_fee = 10; // Very small base fee
    const parent_gas_target = 15_000_000;
    const parent_gas_used = 20_000_000; // Above target

    const next_fee = nextBaseFee(parent_base_fee, parent_gas_used, parent_gas_target);
    // Should still increase by at least 1 due to minimum delta
    try std.testing.expect(next_fee > parent_base_fee);
    try std.testing.expect(next_fee - parent_base_fee >= 1);
}
```

### nextBaseFee precision with large base fee

```zig
test "nextBaseFee precision with large base fee" {
    const parent_base_fee = 1_000_000_000_000; // 1000 gwei
    const parent_gas_target = 15_000_000;
    const parent_gas_used = 16_000_000; // Slightly above target

    const next_fee = nextBaseFee(parent_base_fee, parent_gas_used, parent_gas_target);
    // Should calculate precise increase
    try std.testing.expect(next_fee > parent_base_fee);

    // Expected: base_fee * (1M / 15M) / 8 = base_fee * 1/120
    const expected_delta = parent_base_fee / 120;
    const expected = parent_base_fee + expected_delta;
    try std.testing.expectEqual(expected, next_fee);
}
```

### nextBaseFee with very high gas usage

```zig
test "nextBaseFee with very high gas usage" {
    const parent_base_fee = 1_000_000_000;
    const parent_gas_target = 15_000_000;
    const parent_gas_used = 100_000_000; // Way above target

    const next_fee = nextBaseFee(parent_base_fee, parent_gas_used, parent_gas_target);
    // Should cap at 12.5% increase
    const max_increase = parent_base_fee + (parent_base_fee / 8);
    try std.testing.expectEqual(max_increase, next_fee);
}
```

### nextBaseFee decrease to minimum boundary

```zig
test "nextBaseFee decrease to minimum boundary" {
    const parent_base_fee = 8; // Just above MIN_BASE_FEE
    const parent_gas_target = 1_000;
    const parent_gas_used = 1; // Very low to force decrease

    const next_fee = nextBaseFee(parent_base_fee, parent_gas_used, parent_gas_target);
    // Should not go below MIN_BASE_FEE
    try std.testing.expect(next_fee >= MIN_BASE_FEE);
    try std.testing.expectEqual(MIN_BASE_FEE, next_fee);
}
```

### nextBaseFee at minimum with empty block

```zig
test "nextBaseFee at minimum with empty block" {
    const parent_base_fee = MIN_BASE_FEE;
    const parent_gas_target = 15_000_000;
    const parent_gas_used = 0; // Empty block

    const next_fee = nextBaseFee(parent_base_fee, parent_gas_used, parent_gas_target);
    // Should stay at minimum for empty blocks
    try std.testing.expectEqual(MIN_BASE_FEE, next_fee);
}
```

### nextBaseFee at minimum with below-target usage

```zig
test "nextBaseFee at minimum with below-target usage" {
    const parent_base_fee = MIN_BASE_FEE;
    const parent_gas_target = 15_000_000;
    const parent_gas_used = 1_000_000; // Below target

    const next_fee = nextBaseFee(parent_base_fee, parent_gas_used, parent_gas_target);
    // Should stay at minimum (cannot decrease further)
    try std.testing.expectEqual(MIN_BASE_FEE, next_fee);
}
```

### nextBaseFee with gas used exceeding realistic limits

```zig
test "nextBaseFee with gas used exceeding realistic limits" {
    const parent_base_fee = 1_000_000_000;
    const parent_gas_target = 15_000_000;
    const parent_gas_used = 1_000_000_000; // Unrealistically high

    const next_fee = nextBaseFee(parent_base_fee, parent_gas_used, parent_gas_target);
    // Should still cap at 12.5% increase
    const max_increase = parent_base_fee + (parent_base_fee / 8);
    try std.testing.expectEqual(max_increase, next_fee);
}
```

### nextBaseFee precision loss with integer division

```zig
test "nextBaseFee precision loss with integer division" {
    const parent_base_fee = 15; // Base fee that doesn't divide evenly
    const parent_gas_target = 15_000_000;
    const parent_gas_used = 20_000_000; // Above target

    const next_fee = nextBaseFee(parent_base_fee, parent_gas_used, parent_gas_target);
    // Should handle integer division correctly
    try std.testing.expect(next_fee > parent_base_fee);
    // Minimum increase should be 1
    try std.testing.expect(next_fee - parent_base_fee >= 1);
}
```

### nextBaseFee with maximum safe base fee

```zig
test "nextBaseFee with maximum safe base fee" {
    const parent_base_fee = std.math.maxInt(u64) / 2;
    const parent_gas_target = 15_000_000;
    const parent_gas_used = 20_000_000; // Above target would increase

    const next_fee = nextBaseFee(parent_base_fee, parent_gas_used, parent_gas_target);
    // Should not overflow - calculateFeeDelta handles this
    try std.testing.expect(next_fee >= parent_base_fee);
}
```

### nextBaseFee boundary at exact target after increase

```zig
test "nextBaseFee boundary at exact target after increase" {
    const parent_base_fee = 1_000_000_000;
    const parent_gas_target = 15_000_000;
    // First increase
    const parent_gas_used_high = 20_000_000;
    const increased_fee = nextBaseFee(parent_base_fee, parent_gas_used_high, parent_gas_target);

    // Then at target
    const next_fee = nextBaseFee(increased_fee, parent_gas_target, parent_gas_target);
    // Should stay at increased fee
    try std.testing.expectEqual(increased_fee, next_fee);
}
```

### nextBaseFee boundary at exact target after decrease

```zig
test "nextBaseFee boundary at exact target after decrease" {
    const parent_base_fee = 1_000_000_000;
    const parent_gas_target = 15_000_000;
    // First decrease
    const parent_gas_used_low = 10_000_000;
    const decreased_fee = nextBaseFee(parent_base_fee, parent_gas_used_low, parent_gas_target);

    // Then at target
    const next_fee = nextBaseFee(decreased_fee, parent_gas_target, parent_gas_target);
    // Should stay at decreased fee
    try std.testing.expectEqual(decreased_fee, next_fee);
}
```

### nextBaseFee with zero gas target

```zig
test "nextBaseFee with zero gas target" {
    const parent_base_fee = 1_000_000_000;
    const parent_gas_target = 0; // Edge case
    const parent_gas_used = 0;

    const next_fee = nextBaseFee(parent_base_fee, parent_gas_used, parent_gas_target);
    // Empty block behavior
    try std.testing.expectEqual(parent_base_fee, next_fee);
}
```

### calculateFeeDelta with maximum fee and small delta

```zig
test "calculateFeeDelta with maximum fee and small delta" {
    const fee = std.math.maxInt(u64) / 10;
    const gas_delta = 1;
    const gas_target = 15_000_000;
    const denominator = 8;

    const result = calculateFeeDelta(fee, gas_delta, gas_target, denominator);
    // Should not overflow and return valid result
    try std.testing.expect(result >= 1);
}
```

### calculateFeeDelta with zero fee

```zig
test "calculateFeeDelta with zero fee" {
    const fee = 0;
    const gas_delta = 1_000_000;
    const gas_target = 15_000_000;
    const denominator = 8;

    const result = calculateFeeDelta(fee, gas_delta, gas_target, denominator);
    // 0 * anything = 0, but minimum is 1
    try std.testing.expectEqual(@as(u64, 1), result);
}
```

### calculateFeeDelta with zero gas delta

```zig
test "calculateFeeDelta with zero gas delta" {
    const fee = 1_000_000_000;
    const gas_delta = 0;
    const gas_target = 15_000_000;
    const denominator = 8;

    const result = calculateFeeDelta(fee, gas_delta, gas_target, denominator);
    // 0 delta should result in minimum return of 1
    try std.testing.expectEqual(@as(u64, 1), result);
}
```

### calculateFeeDelta with all maximum values

```zig
test "calculateFeeDelta with all maximum values" {
    const fee = std.math.maxInt(u64);
    const gas_delta = std.math.maxInt(u64);
    const gas_target = std.math.maxInt(u64);
    const denominator = std.math.maxInt(u64);

    const result = calculateFeeDelta(fee, gas_delta, gas_target, denominator);
    // Should handle overflow and return capped result
    try std.testing.expect(result > 0);
    try std.testing.expect(result <= std.math.maxInt(u64));
}
```

### calculateFeeDelta rounding behavior

```zig
test "calculateFeeDelta rounding behavior" {
    // Test that integer division rounds down correctly
    const fee = 1000;
    const gas_delta = 3;
    const gas_target = 100;
    const denominator = 8;

    const result = calculateFeeDelta(fee, gas_delta, gas_target, denominator);
    // (1000 * 3) / (100 * 8) = 3000 / 800 = 3.75 -> rounds to 3
    try std.testing.expectEqual(@as(u64, 3), result);
}
```

### nextBaseFee sequence of full blocks

```zig
test "nextBaseFee sequence of full blocks" {
    var current_fee: u64 = 1_000_000_000;
    const gas_target: u64 = 15_000_000;
    const gas_used: u64 = 30_000_000; // Full block

    // After 10 full blocks, fee should compound
    var i: usize = 0;
    while (i < 10) : (i += 1) {
        const next = nextBaseFee(current_fee, gas_used, gas_target);
        // Each step should increase by 12.5%
        try std.testing.expect(next > current_fee);
        current_fee = next;
    }

    // After 10 blocks at 12.5% increase each, fee should be significantly higher
    try std.testing.expect(current_fee > 3_000_000_000); // More than 3x original
}
```

### nextBaseFee sequence of empty blocks

```zig
test "nextBaseFee sequence of empty blocks" {
    var current_fee: u64 = 1_000_000_000;
    const gas_target: u64 = 15_000_000;
    const gas_used: u64 = 0; // Empty block

    // After 10 empty blocks, fee should stay the same
    var i: usize = 0;
    while (i < 10) : (i += 1) {
        const next = nextBaseFee(current_fee, gas_used, gas_target);
        try std.testing.expectEqual(current_fee, next);
        current_fee = next;
    }

    try std.testing.expectEqual(@as(u64, 1_000_000_000), current_fee);
}
```

### nextBaseFee sequence alternating full and empty

```zig
test "nextBaseFee sequence alternating full and empty" {
    var current_fee: u64 = 1_000_000_000;
    const gas_target: u64 = 15_000_000;

    // Alternate between full and empty blocks
    var i: usize = 0;
    while (i < 10) : (i += 1) {
        if (i % 2 == 0) {
            // Full block
            current_fee = nextBaseFee(current_fee, 30_000_000, gas_target);
        } else {
            // Empty block
            current_fee = nextBaseFee(current_fee, 0, gas_target);
        }
    }

    // Fee should be higher than start (more full than empty)
    try std.testing.expect(current_fee > 1_000_000_000);
}
```

### nextBaseFee sequence descending to minimum

```zig
test "nextBaseFee sequence descending to minimum" {
    var current_fee: u64 = 1_000_000_000;
    const gas_target: u64 = 15_000_000;
    const gas_used: u64 = 100; // Very low usage

    // Keep decreasing until we hit minimum
    var i: usize = 0;
    while (i < 100) : (i += 1) {
        const next = nextBaseFee(current_fee, gas_used, gas_target);
        if (next == MIN_BASE_FEE and current_fee == MIN_BASE_FEE) {
            break; // Reached minimum
        }
        current_fee = next;
    }

    // Should eventually reach minimum
    try std.testing.expectEqual(MIN_BASE_FEE, current_fee);
}
```

### ELASTICITY_MULTIPLIER constant value

```zig
test "ELASTICITY_MULTIPLIER constant value" {
    try std.testing.expectEqual(@as(u64, 2), ELASTICITY_MULTIPLIER);
}
```

### gweiToWei converts 1 gwei

```zig
test "gweiToWei converts 1 gwei" {
    const wei = gweiToWei(1.0);
    try std.testing.expectEqual(@as(u64, 1_000_000_000), wei);
}
```

### gweiToWei converts fractional gwei

```zig
test "gweiToWei converts fractional gwei" {
    const wei = gweiToWei(1.5);
    try std.testing.expectEqual(@as(u64, 1_500_000_000), wei);
}
```

### gweiToWei converts zero

```zig
test "gweiToWei converts zero" {
    const wei = gweiToWei(0.0);
    try std.testing.expectEqual(@as(u64, 0), wei);
}
```

### gweiToWei converts large values

```zig
test "gweiToWei converts large values" {
    const wei = gweiToWei(100.0);
    try std.testing.expectEqual(@as(u64, 100_000_000_000), wei);
}
```

### gweiToWei truncates sub-wei precision

```zig
test "gweiToWei truncates sub-wei precision" {
    const wei = gweiToWei(1.0000000001);
    try std.testing.expectEqual(@as(u64, 1_000_000_000), wei);
}
```

### weiToGwei converts 1 gwei

```zig
test "weiToGwei converts 1 gwei" {
    const allocator = std.testing.allocator;
    const gwei = try weiToGwei(allocator, 1_000_000_000);
    defer allocator.free(gwei);
    try std.testing.expectEqualStrings("1.000000000", gwei);
}
```

### weiToGwei converts fractional gwei

```zig
test "weiToGwei converts fractional gwei" {
    const allocator = std.testing.allocator;
    const gwei = try weiToGwei(allocator, 1_234_567_890);
    defer allocator.free(gwei);
    try std.testing.expectEqualStrings("1.234567890", gwei);
}
```

### weiToGwei converts zero

```zig
test "weiToGwei converts zero" {
    const allocator = std.testing.allocator;
    const gwei = try weiToGwei(allocator, 0);
    defer allocator.free(gwei);
    try std.testing.expectEqualStrings("0.000000000", gwei);
}
```

### weiToGwei converts large values

```zig
test "weiToGwei converts large values" {
    const allocator = std.testing.allocator;
    const gwei = try weiToGwei(allocator, 100_000_000_000);
    defer allocator.free(gwei);
    try std.testing.expectEqualStrings("100.000000000", gwei);
}
```

### weiToGwei converts small values

```zig
test "weiToGwei converts small values" {
    const allocator = std.testing.allocator;
    const gwei = try weiToGwei(allocator, 7);
    defer allocator.free(gwei);
    try std.testing.expectEqualStrings("0.000000007", gwei);
}
```

### canIncludeTx returns true when maxFee covers baseFee

```zig
test "canIncludeTx returns true when maxFee covers baseFee" {
    const can_include = canIncludeTx(1_000_000_000, 900_000_000, null, null);
    try std.testing.expect(can_include);
}
```

### canIncludeTx returns false when maxFee below baseFee

```zig
test "canIncludeTx returns false when maxFee below baseFee" {
    const can_include = canIncludeTx(800_000_000, 900_000_000, null, null);
    try std.testing.expect(!can_include);
}
```

### canIncludeTx returns true when maxFee equals baseFee

```zig
test "canIncludeTx returns true when maxFee equals baseFee" {
    const can_include = canIncludeTx(1_000_000_000, 1_000_000_000, null, null);
    try std.testing.expect(can_include);
}
```

### canIncludeTx returns true for blob tx with sufficient fees

```zig
test "canIncludeTx returns true for blob tx with sufficient fees" {
    const can_include = canIncludeTx(2_000_000_000, 1_500_000_000, 10_000_000, 5_000_000);
    try std.testing.expect(can_include);
}
```

### canIncludeTx returns false for blob tx with insufficient blob fee

```zig
test "canIncludeTx returns false for blob tx with insufficient blob fee" {
    const can_include = canIncludeTx(2_000_000_000, 1_500_000_000, 3_000_000, 5_000_000);
    try std.testing.expect(!can_include);
}
```

### canIncludeTx returns false for blob tx with insufficient gas fee

```zig
test "canIncludeTx returns false for blob tx with insufficient gas fee" {
    const can_include = canIncludeTx(1_000_000_000, 1_500_000_000, 10_000_000, 5_000_000);
    try std.testing.expect(!can_include);
}
```

### getGasTarget uses ELASTICITY_MULTIPLIER

```zig
test "getGasTarget uses ELASTICITY_MULTIPLIER" {
    const gas_limit = 30_000_000;
    const target = getGasTarget(gas_limit);
    try std.testing.expectEqual(@as(u64, 15_000_000), target);
    try std.testing.expectEqual(gas_limit / ELASTICITY_MULTIPLIER, target);
}
```
