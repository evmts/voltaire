---
title: '[Zig] src/primitives/SourceMap/source_map.zig'
source: 'src/primitives/SourceMap/source_map.zig'
---

> Auto-generated from Zig tests in: src/primitives/SourceMap/source_map.zig

### SourceMapEntry: init

```zig
test "SourceMapEntry: init" {
    const entry = SourceMapEntry.init();

    try testing.expectEqual(@as(i32, 0), entry.start);
    try testing.expectEqual(@as(i32, 0), entry.length);
    try testing.expectEqual(@as(i32, 0), entry.file_index);
    try testing.expectEqual(JumpType.regular, entry.jump);
    try testing.expectEqual(@as(i32, -1), entry.modifier_depth);
}
```

### SourceMapEntry: from

```zig
test "SourceMapEntry: from" {
    const entry = SourceMapEntry.from(100, 50, 1, .into, 2);

    try testing.expectEqual(@as(i32, 100), entry.start);
    try testing.expectEqual(@as(i32, 50), entry.length);
    try testing.expectEqual(@as(i32, 1), entry.file_index);
    try testing.expectEqual(JumpType.into, entry.jump);
    try testing.expectEqual(@as(i32, 2), entry.modifier_depth);
}
```

### SourceMapEntry: equality

```zig
test "SourceMapEntry: equality" {
    const entry1 = SourceMapEntry.from(100, 50, 1, .into, 2);
    const entry2 = SourceMapEntry.from(100, 50, 1, .into, 2);
    const entry3 = SourceMapEntry.from(100, 50, 1, .out, 2);

    try testing.expect(entry1.equals(entry2));
    try testing.expect(!entry1.equals(entry3));
}
```

### SourceMapEntry: jump checks

```zig
test "SourceMapEntry: jump checks" {
    const into = SourceMapEntry.from(0, 0, 0, .into, -1);
    try testing.expect(into.isJumpIn());
    try testing.expect(!into.isJumpOut());

    const out = SourceMapEntry.from(0, 0, 0, .out, -1);
    try testing.expect(!out.isJumpIn());
    try testing.expect(out.isJumpOut());
}
```

### JumpType: char conversion

```zig
test "JumpType: char conversion" {
    try testing.expectEqual(JumpType.into, JumpType.fromChar('i'));
    try testing.expectEqual(JumpType.out, JumpType.fromChar('o'));
    try testing.expectEqual(JumpType.regular, JumpType.fromChar('-'));
    try testing.expectEqual(JumpType.regular, JumpType.fromChar('x'));

    try testing.expectEqual(@as(u8, 'i'), JumpType.into.toChar());
    try testing.expectEqual(@as(u8, 'o'), JumpType.out.toChar());
    try testing.expectEqual(@as(u8, '-'), JumpType.regular.toChar());
}
```

### SourceMap: parse empty

```zig
test "SourceMap: parse empty" {
    const allocator = testing.allocator;
    var map = try SourceMap.from(allocator, "");
    defer map.deinit();

    try testing.expect(map.isEmpty());
    try testing.expectEqual(@as(usize, 0), map.len());
}
```

### SourceMap: parse simple

```zig
test "SourceMap: parse simple" {
    const allocator = testing.allocator;
    var map = try SourceMap.from(allocator, "0:50:0:-");
    defer map.deinit();

    try testing.expectEqual(@as(usize, 1), map.len());

    const entry = map.getEntryAt(0).?;
    try testing.expectEqual(@as(i32, 0), entry.start);
    try testing.expectEqual(@as(i32, 50), entry.length);
    try testing.expectEqual(@as(i32, 0), entry.file_index);
    try testing.expectEqual(JumpType.regular, entry.jump);
}
```

### SourceMap: parse multiple

```zig
test "SourceMap: parse multiple" {
    const allocator = testing.allocator;
    var map = try SourceMap.from(allocator, "0:50:0:-;51:100:0:-;151:25:0:o");
    defer map.deinit();

    try testing.expectEqual(@as(usize, 3), map.len());

    try testing.expectEqual(@as(i32, 0), map.getEntryAt(0).?.start);
    try testing.expectEqual(@as(i32, 51), map.getEntryAt(1).?.start);
    try testing.expectEqual(@as(i32, 151), map.getEntryAt(2).?.start);
    try testing.expectEqual(JumpType.out, map.getEntryAt(2).?.jump);
}
```

### SourceMap: parse with compression

```zig
test "SourceMap: parse with compression" {
    const allocator = testing.allocator;
    // Second entry inherits length and file_index
    var map = try SourceMap.from(allocator, "0:50:0:-;100:::-");
    defer map.deinit();

    try testing.expectEqual(@as(usize, 2), map.len());

    const e0 = map.getEntryAt(0).?;
    try testing.expectEqual(@as(i32, 0), e0.start);
    try testing.expectEqual(@as(i32, 50), e0.length);

    const e1 = map.getEntryAt(1).?;
    try testing.expectEqual(@as(i32, 100), e1.start);
    try testing.expectEqual(@as(i32, 50), e1.length); // Inherited
    try testing.expectEqual(@as(i32, 0), e1.file_index); // Inherited
}
```

### SourceMap: parse with modifier depth

```zig
test "SourceMap: parse with modifier depth" {
    const allocator = testing.allocator;
    var map = try SourceMap.from(allocator, "0:50:0:-:2");
    defer map.deinit();

    const entry = map.getEntryAt(0).?;
    try testing.expectEqual(@as(i32, 2), entry.modifier_depth);
}
```

### SourceMap: parse with jump types

```zig
test "SourceMap: parse with jump types" {
    const allocator = testing.allocator;
    var map = try SourceMap.from(allocator, "0:10:0:i;10:20:0:o;30:40:0:-");
    defer map.deinit();

    try testing.expectEqual(JumpType.into, map.getEntryAt(0).?.jump);
    try testing.expectEqual(JumpType.out, map.getEntryAt(1).?.jump);
    try testing.expectEqual(JumpType.regular, map.getEntryAt(2).?.jump);
}
```

### SourceMap: getEntryAt out of bounds

```zig
test "SourceMap: getEntryAt out of bounds" {
    const allocator = testing.allocator;
    var map = try SourceMap.from(allocator, "0:50:0:-");
    defer map.deinit();

    try testing.expect(map.getEntryAt(0) != null);
    try testing.expect(map.getEntryAt(1) == null);
    try testing.expect(map.getEntryAt(100) == null);
}
```

### SourceMap: getEntriesForFile

```zig
test "SourceMap: getEntriesForFile" {
    const allocator = testing.allocator;
    var map = try SourceMap.from(allocator, "0:10:0:-;10:20:1:-;20:30:0:-;30:40:2:-");
    defer map.deinit();

    const file0_entries = try map.getEntriesForFile(allocator, 0);
    defer allocator.free(file0_entries);

    try testing.expectEqual(@as(usize, 2), file0_entries.len);
    try testing.expectEqual(@as(i32, 0), file0_entries[0].start);
    try testing.expectEqual(@as(i32, 20), file0_entries[1].start);
}
```

### SourceMap: toString basic

```zig
test "SourceMap: toString basic" {
    const allocator = testing.allocator;
    var map = try SourceMap.from(allocator, "0:50:0:-");
    defer map.deinit();

    const str = try map.toString(allocator);
    defer allocator.free(str);

    try testing.expectEqualStrings("0:50:0:-", str);
}
```

### SourceMap: multiple files

```zig
test "SourceMap: multiple files" {
    const allocator = testing.allocator;
    var map = try SourceMap.from(allocator, "0:10:0:-;0:20:1:-;0:30:2:-");
    defer map.deinit();

    try testing.expectEqual(@as(i32, 0), map.getEntryAt(0).?.file_index);
    try testing.expectEqual(@as(i32, 1), map.getEntryAt(1).?.file_index);
    try testing.expectEqual(@as(i32, 2), map.getEntryAt(2).?.file_index);
}
```

### SourceMap: real solc output - simple contract

```zig
test "SourceMap: real solc output - simple contract" {
    // Real source map from a simple "contract A { function foo() public {} }"
    const allocator = testing.allocator;
    var map = try SourceMap.from(allocator, "26:74:0:-:0;;;;;;;;;;;;;;;;;;;");
    defer map.deinit();

    try testing.expect(map.len() > 0);
    const first = map.getEntryAt(0).?;
    try testing.expectEqual(@as(i32, 26), first.start);
    try testing.expectEqual(@as(i32, 74), first.length);
    try testing.expectEqual(@as(i32, 0), first.file_index);
    try testing.expectEqual(JumpType.regular, first.jump);
    try testing.expectEqual(@as(i32, 0), first.modifier_depth);
}
```

### SourceMap: negative file index (-1 for generated code)

```zig
test "SourceMap: negative file index (-1 for generated code)" {
    const allocator = testing.allocator;
    var map = try SourceMap.from(allocator, "0:0:-1:-");
    defer map.deinit();

    try testing.expectEqual(@as(usize, 1), map.len());
    const entry = map.getEntryAt(0).?;
    try testing.expectEqual(@as(i32, -1), entry.file_index);
}
```

### SourceMap: toString with compression

```zig
test "SourceMap: toString with compression" {
    const allocator = testing.allocator;
    var map = try SourceMap.from(allocator, "0:50:0:-;100:::;200:::");
    defer map.deinit();

    try testing.expectEqual(@as(usize, 3), map.len());

    // Second entry inherits length, file_index, jump
    const e1 = map.getEntryAt(1).?;
    try testing.expectEqual(@as(i32, 100), e1.start);
    try testing.expectEqual(@as(i32, 50), e1.length); // inherited
    try testing.expectEqual(@as(i32, 0), e1.file_index); // inherited

    // Third entry also inherits
    const e2 = map.getEntryAt(2).?;
    try testing.expectEqual(@as(i32, 200), e2.start);
    try testing.expectEqual(@as(i32, 50), e2.length); // inherited

    // Round-trip test
    const str = try map.toString(allocator);
    defer allocator.free(str);

    // Should compress back (may not be exact same string due to compression rules)
    var map2 = try SourceMap.from(allocator, str);
    defer map2.deinit();

    try testing.expectEqual(map.len(), map2.len());
    for (map.entries, map2.entries) |a, b| {
        try testing.expect(a.equals(b));
    }
}
```

### SourceMap: toString with multiple entries

```zig
test "SourceMap: toString with multiple entries" {
    const allocator = testing.allocator;
    var map = try SourceMap.from(allocator, "0:10:0:i;10:20:0:o;20:30:0:-");
    defer map.deinit();

    const str = try map.toString(allocator);
    defer allocator.free(str);

    // Re-parse and verify
    var map2 = try SourceMap.from(allocator, str);
    defer map2.deinit();

    try testing.expectEqual(@as(usize, 3), map2.len());

    try testing.expectEqual(JumpType.into, map2.getEntryAt(0).?.jump);
    try testing.expectEqual(JumpType.out, map2.getEntryAt(1).?.jump);
    try testing.expectEqual(JumpType.regular, map2.getEntryAt(2).?.jump);
}
```

### SourceMap: complex real-world example

```zig
test "SourceMap: complex real-world example" {
    // More complex source map with multiple files and jump types
    const allocator = testing.allocator;
    const raw = "26:74:0:-:0;;;;;98:39:1;117:11;;129:8;146:23;167:7:2:i;176:15;193:12:0:o";
    var map = try SourceMap.from(allocator, raw);
    defer map.deinit();

    // Verify we got all entries (9 non-empty + some empty)
    try testing.expect(map.len() >= 9);

    // Check specific entries
    const entry0 = map.getEntryAt(0).?;
    try testing.expectEqual(@as(i32, 26), entry0.start);
    try testing.expectEqual(@as(i32, 0), entry0.file_index);

    // Find jump into (file 2)
    var found_jump_in = false;
    for (map.entries) |e| {
        if (e.jump == .into and e.file_index == 2) {
            found_jump_in = true;
            try testing.expectEqual(@as(i32, 167), e.start);
            break;
        }
    }
    try testing.expect(found_jump_in);

    // Find jump out (back to file 0)
    var found_jump_out = false;
    for (map.entries) |e| {
        if (e.jump == .out and e.file_index == 0) {
            found_jump_out = true;
            try testing.expectEqual(@as(i32, 193), e.start);
            break;
        }
    }
    try testing.expect(found_jump_out);
}
```

### SourceMap: find instruction by source location

```zig
test "SourceMap: find instruction by source location" {
    const allocator = testing.allocator;
    var map = try SourceMap.from(allocator, "0:10:0:-;10:20:0:-;30:15:0:-");
    defer map.deinit();

    // Find all instructions that map to source offset 10 (second entry)
    var found_at_10 = false;
    for (map.entries, 0..) |entry, idx| {
        if (entry.start == 10) {
            try testing.expectEqual(@as(usize, 1), idx);
            found_at_10 = true;
        }
    }
    try testing.expect(found_at_10);
}
```

### SourceMap: getSourceLocation (by PC)

```zig
test "SourceMap: getSourceLocation (by PC)" {
    const allocator = testing.allocator;
    // Each entry corresponds to one instruction (PC = index)
    var map = try SourceMap.from(allocator, "100:50:0:-;150:30:0:-;180:20:1:i");
    defer map.deinit();

    // PC 0 -> first instruction, source offset 100
    const loc0 = map.getEntryAt(0).?;
    try testing.expectEqual(@as(i32, 100), loc0.start);
    try testing.expectEqual(@as(i32, 50), loc0.length);

    // PC 1 -> second instruction, source offset 150
    const loc1 = map.getEntryAt(1).?;
    try testing.expectEqual(@as(i32, 150), loc1.start);

    // PC 2 -> third instruction, different file
    const loc2 = map.getEntryAt(2).?;
    try testing.expectEqual(@as(i32, 180), loc2.start);
    try testing.expectEqual(@as(i32, 1), loc2.file_index);
    try testing.expect(loc2.isJumpIn());

    // PC out of bounds
    try testing.expect(map.getEntryAt(3) == null);
}
```
