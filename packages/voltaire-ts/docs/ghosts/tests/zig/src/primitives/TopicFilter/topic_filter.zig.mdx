---
title: '[Zig] src/primitives/TopicFilter/topic_filter.zig'
source: 'src/primitives/TopicFilter/topic_filter.zig'
---

> Auto-generated from Zig tests in: src/primitives/TopicFilter/topic_filter.zig

### single - creates entry with one hash

```zig
test "single - creates entry with one hash" {
    const h = [_]u8{0xab} ** Hash.SIZE;
    const entry = single(h);
    try std.testing.expectEqual(@as(usize, 1), entry.count);
    try std.testing.expect(Hash.equals(&entry.hashes[0], &h));
}
```

### multi - creates entry with multiple hashes

```zig
test "multi - creates entry with multiple hashes" {
    const h1 = [_]u8{0xaa} ** Hash.SIZE;
    const h2 = [_]u8{0xbb} ** Hash.SIZE;
    const entry = try multi(&[_]Hash.Hash{ h1, h2 });
    try std.testing.expectEqual(@as(usize, 2), entry.count);
    try std.testing.expect(Hash.equals(&entry.hashes[0], &h1));
    try std.testing.expect(Hash.equals(&entry.hashes[1], &h2));
}
```

### multi - empty returns error

```zig
test "multi - empty returns error" {
    try std.testing.expectError(TopicFilterError.EmptyHashArray, multi(&[_]Hash.Hash{}));
}
```

### multi - too many hashes returns error

```zig
test "multi - too many hashes returns error" {
    const hashes = [_]Hash.Hash{Hash.ZERO} ** (MAX_HASHES_PER_ENTRY + 1);
    try std.testing.expectError(TopicFilterError.TooManyHashes, multi(&hashes));
}
```

### wildcard - creates entry with count 0

```zig
test "wildcard - creates entry with count 0" {
    const entry = wildcard();
    try std.testing.expectEqual(@as(usize, 0), entry.count);
}
```

### from - empty filter

```zig
test "from - empty filter" {
    const filter = try from(&[_]?TopicEntry{});
    try std.testing.expectEqual(@as(usize, 0), filter.len);
}
```

### from - single topic

```zig
test "from - single topic" {
    const h = [_]u8{0x11} ** Hash.SIZE;
    const filter = try from(&[_]?TopicEntry{single(h)});
    try std.testing.expectEqual(@as(usize, 1), filter.len);
    try std.testing.expectEqual(@as(usize, 1), filter.entries[0].count);
}
```

### from - with wildcards

```zig
test "from - with wildcards" {
    const h1 = [_]u8{0x11} ** Hash.SIZE;
    const h2 = [_]u8{0x22} ** Hash.SIZE;
    const filter = try from(&[_]?TopicEntry{ single(h1), null, single(h2) });
    try std.testing.expectEqual(@as(usize, 3), filter.len);
    try std.testing.expectEqual(@as(usize, 1), filter.entries[0].count);
    try std.testing.expectEqual(@as(usize, 0), filter.entries[1].count); // wildcard
    try std.testing.expectEqual(@as(usize, 1), filter.entries[2].count);
}
```

### from - with OR entry

```zig
test "from - with OR entry" {
    const h1 = [_]u8{0x11} ** Hash.SIZE;
    const h2 = [_]u8{0x22} ** Hash.SIZE;
    const entry = try multi(&[_]Hash.Hash{ h1, h2 });
    const filter = try from(&[_]?TopicEntry{entry});
    try std.testing.expectEqual(@as(usize, 1), filter.len);
    try std.testing.expectEqual(@as(usize, 2), filter.entries[0].count);
}
```

### from - all 4 positions

```zig
test "from - all 4 positions" {
    const h = [_]u8{0x11} ** Hash.SIZE;
    const filter = try from(&[_]?TopicEntry{ single(h), single(h), single(h), null });
    try std.testing.expectEqual(@as(usize, 4), filter.len);
}
```

### from - too many topics returns error

```zig
test "from - too many topics returns error" {
    const h = [_]u8{0x11} ** Hash.SIZE;
    const entries = [_]?TopicEntry{ single(h), single(h), single(h), single(h), single(h) };
    try std.testing.expectError(TopicFilterError.TooManyTopics, from(&entries));
}
```

### empty - creates filter with length 0

```zig
test "empty - creates filter with length 0" {
    const filter = empty();
    try std.testing.expectEqual(@as(usize, 0), filter.len);
}
```

### matches - empty filter matches anything

```zig
test "matches - empty filter matches anything" {
    const filter = empty();
    const h1 = [_]u8{0x11} ** Hash.SIZE;
    const h2 = [_]u8{0x22} ** Hash.SIZE;
    try std.testing.expect(matches(&filter, &[_]Hash.Hash{ h1, h2 }));
}
```

### matches - all wildcards match anything

```zig
test "matches - all wildcards match anything" {
    const filter = try from(&[_]?TopicEntry{ null, null, null });
    const h1 = [_]u8{0x11} ** Hash.SIZE;
    const h2 = [_]u8{0x22} ** Hash.SIZE;
    const h3 = [_]u8{0x33} ** Hash.SIZE;
    try std.testing.expect(matches(&filter, &[_]Hash.Hash{ h1, h2, h3 }));
}
```

### matches - specific topic at position 0

```zig
test "matches - specific topic at position 0" {
    const h1 = [_]u8{0x11} ** Hash.SIZE;
    const h2 = [_]u8{0x22} ** Hash.SIZE;
    const filter = try from(&[_]?TopicEntry{single(h1)});
    try std.testing.expect(matches(&filter, &[_]Hash.Hash{ h1, h2 }));
    try std.testing.expect(!matches(&filter, &[_]Hash.Hash{ h2, h1 }));
}
```

### matches - with wildcard in middle

```zig
test "matches - with wildcard in middle" {
    const h1 = [_]u8{0x11} ** Hash.SIZE;
    const h2 = [_]u8{0x22} ** Hash.SIZE;
    const h3 = [_]u8{0x33} ** Hash.SIZE;
    const filter = try from(&[_]?TopicEntry{ single(h1), null, single(h3) });
    try std.testing.expect(matches(&filter, &[_]Hash.Hash{ h1, h2, h3 }));
    try std.testing.expect(matches(&filter, &[_]Hash.Hash{ h1, h1, h3 }));
    try std.testing.expect(!matches(&filter, &[_]Hash.Hash{ h2, h2, h3 }));
    try std.testing.expect(!matches(&filter, &[_]Hash.Hash{ h1, h2, h2 }));
}
```

### matches - array entry (OR logic)

```zig
test "matches - array entry (OR logic)" {
    const h1 = [_]u8{0x11} ** Hash.SIZE;
    const h2 = [_]u8{0x22} ** Hash.SIZE;
    const h3 = [_]u8{0x33} ** Hash.SIZE;
    const entry = try multi(&[_]Hash.Hash{ h1, h2 });
    const filter = try from(&[_]?TopicEntry{entry});
    try std.testing.expect(matches(&filter, &[_]Hash.Hash{h1}));
    try std.testing.expect(matches(&filter, &[_]Hash.Hash{h2}));
    try std.testing.expect(!matches(&filter, &[_]Hash.Hash{h3}));
}
```

### matches - log has fewer topics

```zig
test "matches - log has fewer topics" {
    const h1 = [_]u8{0x11} ** Hash.SIZE;
    const h2 = [_]u8{0x22} ** Hash.SIZE;
    const filter = try from(&[_]?TopicEntry{ single(h1), single(h2) });
    try std.testing.expect(!matches(&filter, &[_]Hash.Hash{h1}));
}
```

### matches - complex filter

```zig
test "matches - complex filter" {
    const h1 = [_]u8{0x11} ** Hash.SIZE;
    const h2 = [_]u8{0x22} ** Hash.SIZE;
    const h3 = [_]u8{0x33} ** Hash.SIZE;
    const entry = try multi(&[_]Hash.Hash{ h2, h3 });
    const filter = try from(&[_]?TopicEntry{ single(h1), entry, null });
    try std.testing.expect(matches(&filter, &[_]Hash.Hash{ h1, h2, h1 }));
    try std.testing.expect(matches(&filter, &[_]Hash.Hash{ h1, h3, h1 }));
    try std.testing.expect(!matches(&filter, &[_]Hash.Hash{ h1, h1, h1 }));
}
```

### isEmpty - empty array

```zig
test "isEmpty - empty array" {
    const filter = empty();
    try std.testing.expect(isEmpty(&filter));
}
```

### isEmpty - all nulls

```zig
test "isEmpty - all nulls" {
    const filter = try from(&[_]?TopicEntry{ null, null, null });
    try std.testing.expect(isEmpty(&filter));
}
```

### isEmpty - has topic

```zig
test "isEmpty - has topic" {
    const h = [_]u8{0x11} ** Hash.SIZE;
    const filter = try from(&[_]?TopicEntry{single(h)});
    try std.testing.expect(!isEmpty(&filter));
}
```

### isEmpty - topic at any position

```zig
test "isEmpty - topic at any position" {
    const h = [_]u8{0x22} ** Hash.SIZE;
    const filter = try from(&[_]?TopicEntry{ null, single(h), null });
    try std.testing.expect(!isEmpty(&filter));
}
```

### toJson - empty filter

```zig
test "toJson - empty filter" {
    const filter = empty();
    const json = try toJson(&filter, std.testing.allocator);
    defer std.testing.allocator.free(json);
    try std.testing.expect(std.mem.eql(u8, json, "[]"));
}
```

### toJson - single topic

```zig
test "toJson - single topic" {
    const h = [_]u8{0x11} ** Hash.SIZE;
    const filter = try from(&[_]?TopicEntry{single(h)});
    const json = try toJson(&filter, std.testing.allocator);
    defer std.testing.allocator.free(json);
    try std.testing.expect(std.mem.startsWith(u8, json, "[\"0x"));
    try std.testing.expect(std.mem.endsWith(u8, json, "\"]"));
}
```

### toJson - with null

```zig
test "toJson - with null" {
    const h = [_]u8{0x11} ** Hash.SIZE;
    const filter = try from(&[_]?TopicEntry{ single(h), null });
    const json = try toJson(&filter, std.testing.allocator);
    defer std.testing.allocator.free(json);
    try std.testing.expect(std.mem.indexOf(u8, json, "null") != null);
}
```

### toJson - with OR entry

```zig
test "toJson - with OR entry" {
    const h1 = [_]u8{0x11} ** Hash.SIZE;
    const h2 = [_]u8{0x22} ** Hash.SIZE;
    const entry = try multi(&[_]Hash.Hash{ h1, h2 });
    const filter = try from(&[_]?TopicEntry{entry});
    const json = try toJson(&filter, std.testing.allocator);
    defer std.testing.allocator.free(json);
    // Should have nested array
    try std.testing.expect(std.mem.indexOf(u8, json, "[[") != null);
}
```

### clone - creates copy

```zig
test "clone - creates copy" {
    const h = [_]u8{0x11} ** Hash.SIZE;
    const filter1 = try from(&[_]?TopicEntry{single(h)});
    const filter2 = clone(&filter1);
    try std.testing.expectEqual(filter1.len, filter2.len);
    try std.testing.expectEqual(filter1.entries[0].count, filter2.entries[0].count);
}
```

### length - returns filter length

```zig
test "length - returns filter length" {
    const h = [_]u8{0x11} ** Hash.SIZE;
    const filter = try from(&[_]?TopicEntry{ single(h), null, single(h) });
    try std.testing.expectEqual(@as(usize, 3), length(&filter));
}
```
