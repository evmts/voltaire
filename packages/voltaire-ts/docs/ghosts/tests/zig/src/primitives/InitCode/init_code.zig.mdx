---
title: '[Zig] src/primitives/InitCode/init_code.zig'
source: 'src/primitives/InitCode/init_code.zig'
---

> Auto-generated from Zig tests in: src/primitives/InitCode/init_code.zig

### InitCode.from - creates from bytes

```zig
test "InitCode.from - creates from bytes" {
    const bytecode = [_]u8{ 0x60, 0x80, 0x60, 0x40, 0x52 };
    const code = InitCode.from(&bytecode);

    try std.testing.expectEqual(@as(usize, 5), code.len());
    try std.testing.expect(!code.isEmpty());
}
```

### InitCode.from - empty bytecode

```zig
test "InitCode.from - empty bytecode" {
    const bytecode = [_]u8{};
    const code = InitCode.from(&bytecode);

    try std.testing.expectEqual(@as(usize, 0), code.len());
    try std.testing.expect(code.isEmpty());
}
```

### InitCode.fromHex - valid hex

```zig
test "InitCode.fromHex - valid hex" {
    const result = try InitCode.fromHex(std.testing.allocator, "0x6080604052");
    defer std.testing.allocator.free(result.bytes);

    try std.testing.expectEqual(@as(usize, 5), result.code.len());
    try std.testing.expectEqual(@as(u8, 0x60), result.code.bytes[0]);
}
```

### InitCode.toHex - converts to hex string

```zig
test "InitCode.toHex - converts to hex string" {
    const bytecode = [_]u8{ 0x60, 0x80 };
    const code = InitCode.from(&bytecode);

    const hex = try code.toHex(std.testing.allocator);
    defer std.testing.allocator.free(hex);

    try std.testing.expectEqualStrings("0x6080", hex);
}
```

### InitCode.hash - computes keccak256

```zig
test "InitCode.hash - computes keccak256" {
    const bytecode = [_]u8{ 0x60, 0x80, 0x60, 0x40 };
    const code = InitCode.from(&bytecode);

    const code_hash = code.hash();

    try std.testing.expectEqual(@as(usize, 32), code_hash.len);

    var all_zero = true;
    for (code_hash) |b| {
        if (b != 0) {
            all_zero = false;
            break;
        }
    }
    try std.testing.expect(!all_zero);
}
```

### InitCode.equals - same bytecode

```zig
test "InitCode.equals - same bytecode" {
    const bytecode1 = [_]u8{ 0x60, 0x80 };
    const bytecode2 = [_]u8{ 0x60, 0x80 };

    const code1 = InitCode.from(&bytecode1);
    const code2 = InitCode.from(&bytecode2);

    try std.testing.expect(code1.equals(code2));
}
```

### InitCode.equals - different bytecode

```zig
test "InitCode.equals - different bytecode" {
    const bytecode1 = [_]u8{ 0x60, 0x80 };
    const bytecode2 = [_]u8{ 0x60, 0x40 };

    const code1 = InitCode.from(&bytecode1);
    const code2 = InitCode.from(&bytecode2);

    try std.testing.expect(!code1.equals(code2));
}
```

### InitCode.extractRuntime - valid offset

```zig
test "InitCode.extractRuntime - valid offset" {
    const bytecode = [_]u8{ 0x60, 0x80, 0x60, 0x40, 0x52 };
    const code = InitCode.from(&bytecode);

    const runtime = code.extractRuntime(2);
    try std.testing.expect(runtime != null);
    try std.testing.expectEqual(@as(usize, 3), runtime.?.len);
    try std.testing.expectEqual(@as(u8, 0x60), runtime.?[0]);
}
```

### InitCode.extractRuntime - offset at end

```zig
test "InitCode.extractRuntime - offset at end" {
    const bytecode = [_]u8{ 0x60, 0x80 };
    const code = InitCode.from(&bytecode);

    const runtime = code.extractRuntime(2);
    try std.testing.expect(runtime == null);
}
```

### InitCode.extractRuntime - offset beyond end

```zig
test "InitCode.extractRuntime - offset beyond end" {
    const bytecode = [_]u8{ 0x60, 0x80 };
    const code = InitCode.from(&bytecode);

    const runtime = code.extractRuntime(10);
    try std.testing.expect(runtime == null);
}
```

### InitCode.estimateGas - all non-zero bytes

```zig
test "InitCode.estimateGas - all non-zero bytes" {
    const bytecode = [_]u8{ 0x60, 0x80, 0x60, 0x40 };
    const code = InitCode.from(&bytecode);

    const gas = code.estimateGas();
    try std.testing.expectEqual(@as(u64, 4 * GAS_PER_NONZERO_BYTE), gas);
}
```

### InitCode.estimateGas - mixed bytes

```zig
test "InitCode.estimateGas - mixed bytes" {
    const bytecode = [_]u8{ 0x60, 0x00, 0x60, 0x00 };
    const code = InitCode.from(&bytecode);

    const gas = code.estimateGas();
    try std.testing.expectEqual(@as(u64, 2 * GAS_PER_NONZERO_BYTE + 2 * GAS_PER_ZERO_BYTE), gas);
}
```

### InitCode.estimateGas - all zero bytes

```zig
test "InitCode.estimateGas - all zero bytes" {
    const bytecode = [_]u8{ 0x00, 0x00, 0x00, 0x00 };
    const code = InitCode.from(&bytecode);

    const gas = code.estimateGas();
    try std.testing.expectEqual(@as(u64, 4 * GAS_PER_ZERO_BYTE), gas);
}
```

### InitCode.estimateGas - empty

```zig
test "InitCode.estimateGas - empty" {
    const bytecode = [_]u8{};
    const code = InitCode.from(&bytecode);

    const gas = code.estimateGas();
    try std.testing.expectEqual(@as(u64, 0), gas);
}
```

### InitCode.countZeroBytes - counts correctly

```zig
test "InitCode.countZeroBytes - counts correctly" {
    const bytecode = [_]u8{ 0x60, 0x00, 0x00, 0x40 };
    const code = InitCode.from(&bytecode);

    try std.testing.expectEqual(@as(usize, 2), code.countZeroBytes());
    try std.testing.expectEqual(@as(usize, 2), code.countNonZeroBytes());
}
```

### InitCode.getOpcode - valid position

```zig
test "InitCode.getOpcode - valid position" {
    const bytecode = [_]u8{ 0x60, 0x80, 0x60, 0x40 };
    const code = InitCode.from(&bytecode);

    try std.testing.expectEqual(@as(u8, 0x60), code.getOpcode(0).?);
    try std.testing.expectEqual(@as(u8, 0x80), code.getOpcode(1).?);
}
```

### InitCode.getOpcode - out of bounds

```zig
test "InitCode.getOpcode - out of bounds" {
    const bytecode = [_]u8{ 0x60, 0x80 };
    const code = InitCode.from(&bytecode);

    try std.testing.expect(code.getOpcode(2) == null);
}
```
