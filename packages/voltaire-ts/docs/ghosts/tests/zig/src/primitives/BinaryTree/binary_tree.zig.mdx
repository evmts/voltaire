---
title: '[Zig] src/primitives/BinaryTree/binary_tree.zig'
source: 'src/primitives/BinaryTree/binary_tree.zig'
---

> Auto-generated from Zig tests in: src/primitives/BinaryTree/binary_tree.zig

### BinaryTree - addressToKey

```zig
test "BinaryTree - addressToKey" {
    const addr = [_]u8{ 0xf3, 0x9f } ++ [_]u8{0} ** 18;
    const k = addressToKey(addr);

    try std.testing.expectEqual(@as(usize, 32), k.len);
    try std.testing.expectEqual(@as(u8, 0), k[0]);
    try std.testing.expectEqual(@as(u8, 0xf3), k[12]);
    try std.testing.expectEqual(@as(u8, 0x9f), k[13]);
}
```

### BinaryTree - splitKey

```zig
test "BinaryTree - splitKey" {
    var k: [32]u8 = undefined;
    @memset(&k, 0xaa);
    k[31] = 0x42;

    const split = splitKey(k);
    try std.testing.expectEqual(@as(u8, 0x42), split.idx);
    try std.testing.expectEqual(@as(u8, 0xaa), split.stem[0]);
    try std.testing.expectEqual(@as(u8, 0xaa), split.stem[30]);
}
```

### BinaryTree - hashInternal zero children

```zig
test "BinaryTree - hashInternal zero children" {
    const zero = [_]u8{0} ** 32;
    const h = hashInternal(zero, zero);
    try std.testing.expectEqualSlices(u8, &zero, &h);
}
```

### BinaryTree - hashInternal non-zero children

```zig
test "BinaryTree - hashInternal non-zero children" {
    const l = [_]u8{0x01} ++ [_]u8{0} ** 31;
    const r = [_]u8{0x02} ++ [_]u8{0} ** 31;
    const h = hashInternal(l, r);

    // Should not be all zeros
    var all_zero = true;
    for (h) |b| {
        if (b != 0) {
            all_zero = false;
            break;
        }
    }
    try std.testing.expect(!all_zero);
}
```

### BinaryTree - init and deinit

```zig
test "BinaryTree - init and deinit" {
    var tree = init(std.testing.allocator);
    defer tree.deinit();

    const h = tree.rootHash();
    const zero = [_]u8{0} ** 32;
    try std.testing.expectEqualSlices(u8, &zero, &h);
}
```

### BinaryTree - insert single value

```zig
test "BinaryTree - insert single value" {
    var tree = init(std.testing.allocator);
    defer tree.deinit();

    var k: [32]u8 = undefined;
    @memset(&k, 0);
    k[31] = 5;

    var v: [32]u8 = undefined;
    @memset(&v, 0);
    v[31] = 0x42;

    try tree.insert(k, v);

    const h = tree.rootHash();
    const zero = [_]u8{0} ** 32;
    const is_zero = std.mem.eql(u8, &h, &zero);
    try std.testing.expect(!is_zero);
}
```

### BinaryTree - insert and get

```zig
test "BinaryTree - insert and get" {
    var tree = init(std.testing.allocator);
    defer tree.deinit();

    var k: [32]u8 = undefined;
    @memset(&k, 0);
    k[31] = 10;

    var v: [32]u8 = undefined;
    @memset(&v, 0);
    v[31] = 0x99;

    try tree.insert(k, v);

    const retrieved = tree.get(k);
    try std.testing.expect(retrieved != null);
    if (retrieved) |r| {
        try std.testing.expectEqual(@as(u8, 0x99), r[31]);
    }
}
```

### BinaryTree - getStemBit

```zig
test "BinaryTree - getStemBit" {
    var stem: Stem = undefined;
    @memset(&stem, 0);
    stem[0] = 0b10101010;

    try std.testing.expectEqual(@as(u1, 1), getStemBit(stem, 0));
    try std.testing.expectEqual(@as(u1, 0), getStemBit(stem, 1));
    try std.testing.expectEqual(@as(u1, 1), getStemBit(stem, 2));
    try std.testing.expectEqual(@as(u1, 0), getStemBit(stem, 3));
}
```

### BinaryTree - AccountData layout

```zig
test "BinaryTree - AccountData layout" {
    const acc = AccountData{
        .version = 1,
        .code_size = 1024,
        .nonce = 42,
        .balance = 1000000000000000000,
    };

    try std.testing.expectEqual(@as(u8, 1), acc.version);
    try std.testing.expectEqual(@as(u24, 1024), acc.code_size);
    try std.testing.expectEqual(@as(u64, 42), acc.nonce);
    try std.testing.expectEqual(@as(u128, 1000000000000000000), acc.balance);
}
```

### BinaryTree - rootHashHex empty tree

```zig
test "BinaryTree - rootHashHex empty tree" {
    var tree = init(std.testing.allocator);
    defer tree.deinit();

    var buf: [66]u8 = undefined;
    const hex = try tree.rootHashHex(&buf);

    try std.testing.expectEqual(@as(usize, 66), hex.len);
    try std.testing.expect(std.mem.startsWith(u8, hex, "0x"));

    // Empty tree should have all zeros
    const expected = "0x" ++ "00" ** 32;
    try std.testing.expectEqualStrings(expected, hex);
}
```

### BinaryTree - rootHashHex after insert

```zig
test "BinaryTree - rootHashHex after insert" {
    var tree = init(std.testing.allocator);
    defer tree.deinit();

    var buf1: [66]u8 = undefined;
    const h1 = try tree.rootHashHex(&buf1);

    var k: [32]u8 = undefined;
    @memset(&k, 0);
    var v: [32]u8 = undefined;
    @memset(&v, 0);
    v[0] = 1;

    try tree.insert(k, v);

    var buf2: [66]u8 = undefined;
    const h2 = try tree.rootHashHex(&buf2);

    // Hash should change after insert
    try std.testing.expect(!std.mem.eql(u8, h1, h2));
    try std.testing.expect(std.mem.startsWith(u8, h2, "0x"));
}
```

### BinaryTree - rootHashHex format validation

```zig
test "BinaryTree - rootHashHex format validation" {
    var tree = init(std.testing.allocator);
    defer tree.deinit();

    var k: [32]u8 = undefined;
    @memset(&k, 0);
    k[31] = 5;
    var v: [32]u8 = undefined;
    @memset(&v, 0);
    v[31] = 0x42;

    try tree.insert(k, v);

    var buf: [66]u8 = undefined;
    const hex = try tree.rootHashHex(&buf);

    // Check length
    try std.testing.expectEqual(@as(usize, 66), hex.len);

    // Check prefix
    try std.testing.expectEqual(@as(u8, '0'), hex[0]);
    try std.testing.expectEqual(@as(u8, 'x'), hex[1]);

    // Check all characters are valid hex (lowercase)
    for (hex[2..]) |c| {
        const valid = (c >= '0' and c <= '9') or (c >= 'a' and c <= 'f');
        try std.testing.expect(valid);
    }
}
```

### BinaryTree - rootHashHex buffer too small

```zig
test "BinaryTree - rootHashHex buffer too small" {
    var tree = init(std.testing.allocator);
    defer tree.deinit();

    var buf: [65]u8 = undefined; // Too small
    const result = tree.rootHashHex(&buf);

    try std.testing.expectError(error.BufferTooSmall, result);
}
```

### BinaryTree - rootHashHex determinism

```zig
test "BinaryTree - rootHashHex determinism" {
    var tree = init(std.testing.allocator);
    defer tree.deinit();

    var k: [32]u8 = undefined;
    @memset(&k, 0);
    k[31] = 10;
    var v: [32]u8 = undefined;
    @memset(&v, 0);
    v[31] = 0xab;

    try tree.insert(k, v);

    var buf1: [66]u8 = undefined;
    const h1 = try tree.rootHashHex(&buf1);

    var buf2: [66]u8 = undefined;
    const h2 = try tree.rootHashHex(&buf2);

    // Same tree should produce same hex
    try std.testing.expectEqualStrings(h1, h2);
}
```
