---
title: '[Zig] src/primitives/StorageProof/storage_proof.zig'
source: 'src/primitives/StorageProof/storage_proof.zig'
---

> Auto-generated from Zig tests in: src/primitives/StorageProof/storage_proof.zig

### StorageProof.init - creates non-owning proof

```zig
test "StorageProof.init - creates non-owning proof" {
    const addr = [_]u8{0x42} ** 20;
    const key = State.StorageKey{ .address = addr, .slot = 42 };
    const value = StorageValue.fromUint256(123);
    const node1 = [_]u8{0xaa} ** 32;
    const proof_nodes = [_][]const u8{&node1};

    const proof = StorageProof.init(key, value, &proof_nodes);

    try std.testing.expectEqual(@as(u256, 42), proof.key.slot);
    try std.testing.expectEqual(@as(usize, 1), proof.proof.len);
    try std.testing.expectEqual(false, proof._owned);
}
```

### StorageProof.from - creates owning copy

```zig
test "StorageProof.from - creates owning copy" {
    const allocator = std.testing.allocator;

    const addr = [_]u8{0x42} ** 20;
    const key = State.StorageKey{ .address = addr, .slot = 42 };
    const value = StorageValue.fromUint256(123);
    const node1 = [_]u8{0xaa} ** 32;
    const proof_nodes = [_][]const u8{&node1};

    const proof = try StorageProof.from(allocator, key, value, &proof_nodes);
    defer proof.deinit(allocator);

    try std.testing.expectEqual(@as(u256, 42), proof.key.slot);
    try std.testing.expectEqual(@as(usize, 1), proof.proof.len);
    try std.testing.expectEqual(true, proof._owned);
}
```

### StorageProof.fromSlot - convenience constructor

```zig
test "StorageProof.fromSlot - convenience constructor" {
    const allocator = std.testing.allocator;

    const addr = [_]u8{0x11} ** 20;
    const node1 = [_]u8{0xbb} ** 32;
    const proof_nodes = [_][]const u8{&node1};

    const proof = try StorageProof.fromSlot(allocator, addr, 100, 999, &proof_nodes);
    defer proof.deinit(allocator);

    try std.testing.expectEqual(@as(u256, 100), proof.getSlot());
    try std.testing.expectEqual(@as(u256, 999), proof.getValueU256());
    try std.testing.expect(std.mem.eql(u8, &addr, &proof.getAddress()));
}
```

### StorageProof.equals - identical proofs

```zig
test "StorageProof.equals - identical proofs" {
    const addr = [_]u8{0x42} ** 20;
    const key = State.StorageKey{ .address = addr, .slot = 42 };
    const value = StorageValue.fromUint256(123);
    const node1 = [_]u8{0xaa} ** 32;
    const proof_nodes = [_][]const u8{&node1};

    const proof1 = StorageProof.init(key, value, &proof_nodes);
    const proof2 = StorageProof.init(key, value, &proof_nodes);

    try std.testing.expect(StorageProof.equals(&proof1, &proof2));
}
```

### StorageProof.equals - different keys

```zig
test "StorageProof.equals - different keys" {
    const addr = [_]u8{0x42} ** 20;
    const key1 = State.StorageKey{ .address = addr, .slot = 42 };
    const key2 = State.StorageKey{ .address = addr, .slot = 43 };
    const value = StorageValue.fromUint256(123);
    const node1 = [_]u8{0xaa} ** 32;
    const proof_nodes = [_][]const u8{&node1};

    const proof1 = StorageProof.init(key1, value, &proof_nodes);
    const proof2 = StorageProof.init(key2, value, &proof_nodes);

    try std.testing.expect(!StorageProof.equals(&proof1, &proof2));
}
```

### StorageProof.equals - different values

```zig
test "StorageProof.equals - different values" {
    const addr = [_]u8{0x42} ** 20;
    const key = State.StorageKey{ .address = addr, .slot = 42 };
    const value1 = StorageValue.fromUint256(123);
    const value2 = StorageValue.fromUint256(456);
    const node1 = [_]u8{0xaa} ** 32;
    const proof_nodes = [_][]const u8{&node1};

    const proof1 = StorageProof.init(key, value1, &proof_nodes);
    const proof2 = StorageProof.init(key, value2, &proof_nodes);

    try std.testing.expect(!StorageProof.equals(&proof1, &proof2));
}
```

### StorageProof.equals - different proof lengths

```zig
test "StorageProof.equals - different proof lengths" {
    const addr = [_]u8{0x42} ** 20;
    const key = State.StorageKey{ .address = addr, .slot = 42 };
    const value = StorageValue.fromUint256(123);
    const node1 = [_]u8{0xaa} ** 32;
    const node2 = [_]u8{0xbb} ** 32;
    const proof_nodes1 = [_][]const u8{&node1};
    const proof_nodes2 = [_][]const u8{ &node1, &node2 };

    const proof1 = StorageProof.init(key, value, &proof_nodes1);
    const proof2 = StorageProof.init(key, value, &proof_nodes2);

    try std.testing.expect(!StorageProof.equals(&proof1, &proof2));
}
```

### StorageProof.equals - different proof elements

```zig
test "StorageProof.equals - different proof elements" {
    const addr = [_]u8{0x42} ** 20;
    const key = State.StorageKey{ .address = addr, .slot = 42 };
    const value = StorageValue.fromUint256(123);
    const node1 = [_]u8{0xaa} ** 32;
    const node2 = [_]u8{0xbb} ** 32;
    const proof_nodes1 = [_][]const u8{&node1};
    const proof_nodes2 = [_][]const u8{&node2};

    const proof1 = StorageProof.init(key, value, &proof_nodes1);
    const proof2 = StorageProof.init(key, value, &proof_nodes2);

    try std.testing.expect(!StorageProof.equals(&proof1, &proof2));
}
```

### StorageProof.isEmpty - empty proof

```zig
test "StorageProof.isEmpty - empty proof" {
    const addr = [_]u8{0x42} ** 20;
    const key = State.StorageKey{ .address = addr, .slot = 0 };
    const value = StorageValue.ZERO;
    const empty_nodes: []const []const u8 = &.{};

    const proof = StorageProof.init(key, value, empty_nodes);
    try std.testing.expect(proof.isEmpty());
}
```

### StorageProof.isEmpty - non-empty proof

```zig
test "StorageProof.isEmpty - non-empty proof" {
    const addr = [_]u8{0x42} ** 20;
    const key = State.StorageKey{ .address = addr, .slot = 0 };
    const value = StorageValue.ZERO;
    const node = [_]u8{0xaa} ** 32;
    const proof_nodes = [_][]const u8{&node};

    const proof = StorageProof.init(key, value, &proof_nodes);
    try std.testing.expect(!proof.isEmpty());
}
```

### StorageProof.isZeroValue - zero value

```zig
test "StorageProof.isZeroValue - zero value" {
    const addr = [_]u8{0x42} ** 20;
    const key = State.StorageKey{ .address = addr, .slot = 0 };
    const value = StorageValue.ZERO;
    const empty_nodes: []const []const u8 = &.{};

    const proof = StorageProof.init(key, value, empty_nodes);
    try std.testing.expect(proof.isZeroValue());
}
```

### StorageProof.isZeroValue - non-zero value

```zig
test "StorageProof.isZeroValue - non-zero value" {
    const addr = [_]u8{0x42} ** 20;
    const key = State.StorageKey{ .address = addr, .slot = 0 };
    const value = StorageValue.fromUint256(1);
    const empty_nodes: []const []const u8 = &.{};

    const proof = StorageProof.init(key, value, empty_nodes);
    try std.testing.expect(!proof.isZeroValue());
}
```

### StorageProof.depth - returns correct depth

```zig
test "StorageProof.depth - returns correct depth" {
    const addr = [_]u8{0x42} ** 20;
    const key = State.StorageKey{ .address = addr, .slot = 0 };
    const value = StorageValue.ZERO;
    const node1 = [_]u8{0xaa} ** 32;
    const node2 = [_]u8{0xbb} ** 32;
    const node3 = [_]u8{0xcc} ** 32;
    const proof_nodes = [_][]const u8{ &node1, &node2, &node3 };

    const proof = StorageProof.init(key, value, &proof_nodes);
    try std.testing.expectEqual(@as(usize, 3), proof.depth());
}
```

### StorageProof.getSlot - returns slot number

```zig
test "StorageProof.getSlot - returns slot number" {
    const addr = [_]u8{0x42} ** 20;
    const key = State.StorageKey{ .address = addr, .slot = 12345 };
    const value = StorageValue.ZERO;
    const empty_nodes: []const []const u8 = &.{};

    const proof = StorageProof.init(key, value, empty_nodes);
    try std.testing.expectEqual(@as(u256, 12345), proof.getSlot());
}
```

### StorageProof.getValueU256 - returns value as u256

```zig
test "StorageProof.getValueU256 - returns value as u256" {
    const addr = [_]u8{0x42} ** 20;
    const key = State.StorageKey{ .address = addr, .slot = 0 };
    const value = StorageValue.fromUint256(0xdeadbeef);
    const empty_nodes: []const []const u8 = &.{};

    const proof = StorageProof.init(key, value, empty_nodes);
    try std.testing.expectEqual(@as(u256, 0xdeadbeef), proof.getValueU256());
}
```

### StorageProof.computeKeyHash - computes keccak256 of slot

```zig
test "StorageProof.computeKeyHash - computes keccak256 of slot" {
    const addr = [_]u8{0x42} ** 20;
    const key = State.StorageKey{ .address = addr, .slot = 0 };
    const value = StorageValue.ZERO;
    const empty_nodes: []const []const u8 = &.{};

    const proof = StorageProof.init(key, value, empty_nodes);
    const key_hash = proof.computeKeyHash();

    // Verify by computing manually
    var slot_bytes: [32]u8 = undefined;
    std.mem.writeInt(u256, &slot_bytes, 0, .big);
    const expected = Hash.keccak256(&slot_bytes);

    try std.testing.expect(std.mem.eql(u8, &key_hash, &expected));
}
```

### StorageProof.clone - creates independent copy

```zig
test "StorageProof.clone - creates independent copy" {
    const allocator = std.testing.allocator;

    const addr = [_]u8{0x42} ** 20;
    const key = State.StorageKey{ .address = addr, .slot = 42 };
    const value = StorageValue.fromUint256(123);
    const node1 = [_]u8{0xaa} ** 32;
    const proof_nodes = [_][]const u8{&node1};

    const original = StorageProof.init(key, value, &proof_nodes);
    const cloned = try original.clone(allocator);
    defer cloned.deinit(allocator);

    try std.testing.expect(StorageProof.equals(&original, &cloned));
    try std.testing.expectEqual(true, cloned._owned);
}
```

### StorageProof.from - rejects too deep proof

```zig
test "StorageProof.from - rejects too deep proof" {
    const allocator = std.testing.allocator;

    const addr = [_]u8{0x42} ** 20;
    const key = State.StorageKey{ .address = addr, .slot = 0 };
    const value = StorageValue.ZERO;

    // Create array of 257 nodes (exceeds MAX_PROOF_DEPTH)
    var nodes: [MAX_PROOF_DEPTH + 1][32]u8 = undefined;
    var node_slices: [MAX_PROOF_DEPTH + 1][]const u8 = undefined;
    for (&nodes, 0..) |*node, i| {
        @memset(node, @as(u8, @intCast(i % 256)));
        node_slices[i] = node;
    }

    const result = StorageProof.from(allocator, key, value, &node_slices);
    try std.testing.expectError(error.ProofTooDeep, result);
}
```

### StorageProof - different addresses same slot are not equal

```zig
test "StorageProof - different addresses same slot are not equal" {
    const addr1 = [_]u8{0x11} ** 20;
    const addr2 = [_]u8{0x22} ** 20;
    const key1 = State.StorageKey{ .address = addr1, .slot = 42 };
    const key2 = State.StorageKey{ .address = addr2, .slot = 42 };
    const value = StorageValue.fromUint256(123);
    const empty_nodes: []const []const u8 = &.{};

    const proof1 = StorageProof.init(key1, value, empty_nodes);
    const proof2 = StorageProof.init(key2, value, empty_nodes);

    try std.testing.expect(!StorageProof.equals(&proof1, &proof2));
}
```
