---
title: '[Zig] src/primitives/StructLog/struct_log.zig'
source: 'src/primitives/StructLog/struct_log.zig'
---

> Auto-generated from Zig tests in: src/primitives/StructLog/struct_log.zig

### StructLog: basic creation

```zig
test "StructLog: basic creation" {
    const log = StructLog.from(0, .PUSH1, 1000000, 3, 0);

    try testing.expectEqual(@as(u64, 0), log.pc);
    try testing.expectEqual(Opcode.PUSH1, log.op);
    try testing.expectEqual(@as(u64, 1000000), log.gas);
    try testing.expectEqual(@as(u64, 3), log.gas_cost);
    try testing.expectEqual(@as(u32, 0), log.depth);
    try testing.expect(log.stack == null);
    try testing.expect(log.memory == null);
    try testing.expect(log.err == null);
}
```

### StructLog: equality

```zig
test "StructLog: equality" {
    const log1 = StructLog.from(0, .ADD, 1000, 3, 1);
    const log2 = StructLog.from(0, .ADD, 1000, 3, 1);
    const log3 = StructLog.from(1, .ADD, 1000, 3, 1);

    try testing.expect(log1.equals(log2));
    try testing.expect(!log1.equals(log3));
}
```

### StructLog: with error

```zig
test "StructLog: with error" {
    var log = StructLog.from(10, .SSTORE, 500, 5000, 0);
    log.err = "out of gas";

    try testing.expect(log.hasError());
    try testing.expectEqualStrings("out of gas", log.err.?);
}
```

### StructLog: opcode name

```zig
test "StructLog: opcode name" {
    const log = StructLog.from(0, .KECCAK256, 1000, 30, 0);
    try testing.expectEqualStrings("KECCAK256", log.opName());
}
```

### StructLog: with stack

```zig
test "StructLog: with stack" {
    var stack: [2][32]u8 = undefined;
    @memset(&stack[0], 0);
    stack[0][31] = 0x01;
    @memset(&stack[1], 0);
    stack[1][31] = 0x02;

    const log = StructLog.fromFull(0, .ADD, 1000, 3, 0, &stack, null, null, null, null);

    try testing.expect(log.stack != null);
    try testing.expectEqual(@as(usize, 2), log.stack.?.len);
    try testing.expectEqual(@as(u8, 0x01), log.stack.?[0][31]);
    try testing.expectEqual(@as(u8, 0x02), log.stack.?[1][31]);
}
```

### StructLog: JSON encode

```zig
test "StructLog: JSON encode" {
    const allocator = testing.allocator;
    const log = StructLog.from(0, .PUSH1, 1000000, 3, 0);

    const json_str = try log.toJson(allocator);
    defer allocator.free(json_str);

    try testing.expect(std.mem.indexOf(u8, json_str, "\"pc\":0") != null);
    try testing.expect(std.mem.indexOf(u8, json_str, "\"op\":\"PUSH1\"") != null);
    try testing.expect(std.mem.indexOf(u8, json_str, "\"gas\":1000000") != null);
    try testing.expect(std.mem.indexOf(u8, json_str, "\"gasCost\":3") != null);
    try testing.expect(std.mem.indexOf(u8, json_str, "\"depth\":0") != null);
}
```

### StructLog: JSON encode with error

```zig
test "StructLog: JSON encode with error" {
    const allocator = testing.allocator;
    var log = StructLog.from(10, .SSTORE, 500, 5000, 0);
    log.err = "out of gas";

    const json_str = try log.toJson(allocator);
    defer allocator.free(json_str);

    try testing.expect(std.mem.indexOf(u8, json_str, "\"error\":\"out of gas\"") != null);
}
```

### StructLog: JSON roundtrip

```zig
test "StructLog: JSON roundtrip" {
    const allocator = testing.allocator;
    const log = StructLog.from(42, .ADD, 999, 3, 1);

    const json_str = try log.toJson(allocator);
    defer allocator.free(json_str);

    const decoded = try StructLog.fromJson(allocator, json_str);

    try testing.expectEqual(log.pc, decoded.pc);
    try testing.expectEqual(log.op, decoded.op);
    try testing.expectEqual(log.gas, decoded.gas);
    try testing.expectEqual(log.gas_cost, decoded.gas_cost);
    try testing.expectEqual(log.depth, decoded.depth);
}
```

### StructLog: toOpStep conversion

```zig
test "StructLog: toOpStep conversion" {
    const log = StructLog.from(42, .MUL, 1000, 5, 2);
    const step = log.toOpStep();

    try testing.expectEqual(log.pc, step.pc);
    try testing.expectEqual(log.op, step.op);
    try testing.expectEqual(log.gas, step.gas);
    try testing.expectEqual(log.gas_cost, step.gas_cost);
    try testing.expectEqual(log.depth, step.depth);
}
```

### StructLog: toOpStep with stack and memory

```zig
test "StructLog: toOpStep with stack and memory" {
    var stack: [2][32]u8 = undefined;
    @memset(&stack[0], 0);
    stack[0][31] = 0x01;
    @memset(&stack[1], 0);
    stack[1][31] = 0x02;

    var memory = [_]u8{ 0x00, 0x01, 0x02, 0x03 };

    const log = StructLog.fromFull(10, .ADD, 500, 3, 1, &stack, &memory, null, null, null);
    const step = log.toOpStep();

    try testing.expectEqual(log.pc, step.pc);
    try testing.expect(step.stack != null);
    try testing.expectEqual(@as(usize, 2), step.stack.?.len);
    try testing.expect(step.memory != null);
    try testing.expectEqual(@as(usize, 4), step.memory.?.len);
}
```
