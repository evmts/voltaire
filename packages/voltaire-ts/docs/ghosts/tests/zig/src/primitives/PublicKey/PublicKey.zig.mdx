---
title: '[Zig] src/primitives/PublicKey/PublicKey.zig'
source: 'src/primitives/PublicKey/PublicKey.zig'
---

> Auto-generated from Zig tests in: src/primitives/PublicKey/PublicKey.zig

### PublicKey.fromHex - valid 64 byte key

```zig
test "PublicKey.fromHex - valid 64 byte key" {
    const hex = "0x" ++ "04" ** 64;
    const pk = try fromHex(hex);

    try std.testing.expectEqual(64, pk.bytes.len);
    for (pk.bytes) |byte| {
        try std.testing.expectEqual(@as(u8, 0x04), byte);
    }
}
```

### PublicKey.fromHex - without 0x prefix

```zig
test "PublicKey.fromHex - without 0x prefix" {
    const hex = "04" ** 64;
    const pk = try fromHex(hex);

    try std.testing.expectEqual(64, pk.bytes.len);
    for (pk.bytes) |byte| {
        try std.testing.expectEqual(@as(u8, 0x04), byte);
    }
}
```

### PublicKey.fromHex - invalid length

```zig
test "PublicKey.fromHex - invalid length" {
    const hex = "0x1234";
    const result = fromHex(hex);

    try std.testing.expectError(error.InvalidHexFormat, result);
}
```

### PublicKey.fromHex - 65 byte key with prefix rejected

```zig
test "PublicKey.fromHex - 65 byte key with prefix rejected" {
    const hex = "0x04" ++ "04" ** 64;
    const result = fromHex(hex);

    try std.testing.expectError(error.InvalidHexFormat, result);
}
```

### PublicKey.toHex - converts to hex string

```zig
test "PublicKey.toHex - converts to hex string" {
    var pk: PublicKey = undefined;
    @memset(&pk.bytes, 0x42);

    const hex = toHex(pk);

    try std.testing.expect(hex[0] == '0');
    try std.testing.expect(hex[1] == 'x');
    try std.testing.expect(hex[2] == '4');
    try std.testing.expect(hex[3] == '2');
}
```

### PublicKey.toHex - round trip

```zig
test "PublicKey.toHex - round trip" {
    const original_hex = "0x" ++ "ab" ** 64;
    const pk = try fromHex(original_hex);
    const result_hex = toHex(pk);

    try std.testing.expectEqualStrings(original_hex, &result_hex);
}
```

### PublicKey.toAddress - derives address from public key

```zig
test "PublicKey.toAddress - derives address from public key" {
    // Known test vector: public key -> address
    // Using generator point for deterministic test
    const gen = crypto.secp256k1.AffinePoint.generator();

    var pk: PublicKey = undefined;
    std.mem.writeInt(u256, pk.bytes[0..32], gen.x, .big);
    std.mem.writeInt(u256, pk.bytes[32..64], gen.y, .big);

    const addr = toAddress(pk);

    // Address should be 20 bytes
    try std.testing.expectEqual(20, addr.bytes.len);

    // Should be derived from keccak256 of public key
    var hash: [32]u8 = undefined;
    Keccak256.hash(&pk.bytes, &hash, .{});

    for (addr.bytes, 0..) |byte, i| {
        try std.testing.expectEqual(hash[12 + i], byte);
    }
}
```

### PublicKey.fromPrivateKey - derives public key

```zig
test "PublicKey.fromPrivateKey - derives public key" {
    // Private key = 1 should give generator point
    var private_key: [32]u8 = [_]u8{0} ** 32;
    private_key[31] = 1;

    const pk = try fromPrivateKey(private_key);

    const gen = crypto.secp256k1.AffinePoint.generator();
    const expected_x = std.mem.readInt(u256, pk.bytes[0..32], .big);
    const expected_y = std.mem.readInt(u256, pk.bytes[32..64], .big);

    try std.testing.expectEqual(gen.x, expected_x);
    try std.testing.expectEqual(gen.y, expected_y);
}
```

### PublicKey.fromPrivateKey - rejects zero key

```zig
test "PublicKey.fromPrivateKey - rejects zero key" {
    const private_key: [32]u8 = [_]u8{0} ** 32;

    const result = fromPrivateKey(private_key);

    try std.testing.expectError(error.InvalidPrivateKey, result);
}
```

### PublicKey.fromPrivateKey - rejects key >= n

```zig
test "PublicKey.fromPrivateKey - rejects key >= n" {
    // Set to secp256k1 order (invalid)
    var private_key: [32]u8 = undefined;
    std.mem.writeInt(u256, &private_key, crypto.secp256k1.SECP256K1_N, .big);

    const result = fromPrivateKey(private_key);

    try std.testing.expectError(error.InvalidPrivateKey, result);
}
```

### PublicKey.verify - valid signature

```zig
test "PublicKey.verify - valid signature" {
    // Create keypair
    var private_key: [32]u8 = [_]u8{0} ** 32;
    private_key[31] = 42;

    const pk = try fromPrivateKey(private_key);

    // Create message hash
    const msg = "test message";
    var hash: [32]u8 = undefined;
    Keccak256.hash(msg, &hash, .{});

    // For this test, we'll validate the signature verification logic
    // A real signature would require signing implementation
    // This tests the verification algorithm works correctly

    // Test with invalid signature (all zeros) - should reject
    const invalid_sig = [_]u8{0} ** 65;
    const result = try verify(pk, hash, invalid_sig);

    try std.testing.expect(!result); // Should be false for invalid sig
}
```

### PublicKey.verify - rejects invalid r or s

```zig
test "PublicKey.verify - rejects invalid r or s" {
    var pk: PublicKey = undefined;
    @memset(&pk.bytes, 0x42);

    var hash: [32]u8 = undefined;
    @memset(&hash, 0x11);

    // Signature with r = 0 (invalid)
    var sig: [65]u8 = [_]u8{0} ** 65;
    sig[32] = 1; // s = 1

    const result = try verify(pk, hash, sig);

    try std.testing.expect(!result);
}
```

### PublicKey.verify - rejects point not on curve

```zig
test "PublicKey.verify - rejects point not on curve" {
    // Create invalid public key (not on curve)
    var pk: PublicKey = undefined;
    @memset(&pk.bytes, 0x42);

    var hash: [32]u8 = undefined;
    @memset(&hash, 0x11);

    var sig: [65]u8 = undefined;
    @memset(&sig, 0x22);
    sig[0] = 1; // r = small value
    sig[32] = 1; // s = small value

    const result = try verify(pk, hash, sig);

    try std.testing.expect(!result);
}
```

### PublicKey.compress - compresses generator point

```zig
test "PublicKey.compress - compresses generator point" {
    // Use generator point
    const gen = crypto.secp256k1.AffinePoint.generator();
    var pk: PublicKey = undefined;
    std.mem.writeInt(u256, pk.bytes[0..32], gen.x, .big);
    std.mem.writeInt(u256, pk.bytes[32..64], gen.y, .big);

    const compressed = compress(pk);

    // Should be 33 bytes
    try std.testing.expectEqual(@as(usize, 33), compressed.len);

    // y is even, so prefix should be 0x02
    try std.testing.expectEqual(@as(u8, 0x02), compressed[0]);

    // x coordinate should match
    const x_from_compressed = std.mem.readInt(u256, compressed[1..33], .big);
    try std.testing.expectEqual(gen.x, x_from_compressed);
}
```

### PublicKey.compress - handles odd y coordinate

```zig
test "PublicKey.compress - handles odd y coordinate" {
    // Create a point with odd y
    var private_key: [32]u8 = [_]u8{0} ** 32;
    private_key[31] = 2; // private key = 2

    const pk = try fromPrivateKey(private_key);
    const compressed = compress(pk);

    // Check prefix matches y parity
    const y = std.mem.readInt(u256, pk.bytes[32..64], .big);
    const expected_prefix: u8 = if ((y & 1) == 0) 0x02 else 0x03;

    try std.testing.expectEqual(expected_prefix, compressed[0]);
}
```

### PublicKey.decompress - decompresses generator point

```zig
test "PublicKey.decompress - decompresses generator point" {
    // Known compressed generator point
    const gen = crypto.secp256k1.AffinePoint.generator();
    var pk: PublicKey = undefined;
    std.mem.writeInt(u256, pk.bytes[0..32], gen.x, .big);
    std.mem.writeInt(u256, pk.bytes[32..64], gen.y, .big);

    const compressed = compress(pk);
    const decompressed = try decompress(compressed);

    // Should match original
    try std.testing.expectEqualSlices(u8, &pk.bytes, &decompressed.bytes);
}
```

### PublicKey.decompress - round trip

```zig
test "PublicKey.decompress - round trip" {
    // Create multiple test keys
    const test_privkeys = [_]u8{ 1, 2, 3, 7, 42, 123 };

    for (test_privkeys) |priv_val| {
        var private_key: [32]u8 = [_]u8{0} ** 32;
        private_key[31] = priv_val;

        const original_pk = try fromPrivateKey(private_key);
        const compressed = compress(original_pk);
        const decompressed_pk = try decompress(compressed);

        try std.testing.expectEqualSlices(u8, &original_pk.bytes, &decompressed_pk.bytes);
    }
}
```

### PublicKey.decompress - rejects invalid prefix

```zig
test "PublicKey.decompress - rejects invalid prefix" {
    var compressed: [33]u8 = undefined;
    compressed[0] = 0x04; // Invalid prefix (should be 0x02 or 0x03)
    @memset(compressed[1..], 0x01);

    const result = decompress(compressed);

    try std.testing.expectError(error.InvalidCompressedPrefix, result);
}
```

### PublicKey.decompress - rejects x >= p

```zig
test "PublicKey.decompress - rejects x >= p" {
    var compressed: [33]u8 = undefined;
    compressed[0] = 0x02;

    // Set x to p (invalid)
    std.mem.writeInt(u256, compressed[1..33], crypto.secp256k1.SECP256K1_P, .big);

    const result = decompress(compressed);

    try std.testing.expectError(error.InvalidXCoordinate, result);
}
```

### PublicKey.isCompressed - detects compressed format

```zig
test "PublicKey.isCompressed - detects compressed format" {
    var compressed: [33]u8 = undefined;
    compressed[0] = 0x02;
    @memset(compressed[1..], 0x01);

    try std.testing.expect(isCompressed(&compressed));
}
```

### PublicKey.isCompressed - rejects uncompressed format

```zig
test "PublicKey.isCompressed - rejects uncompressed format" {
    var uncompressed: [64]u8 = undefined;
    @memset(&uncompressed, 0x01);

    try std.testing.expect(!isCompressed(&uncompressed));
}
```

### PublicKey.isCompressed - rejects invalid prefix

```zig
test "PublicKey.isCompressed - rejects invalid prefix" {
    var invalid: [33]u8 = undefined;
    invalid[0] = 0x04; // Invalid prefix
    @memset(invalid[1..], 0x01);

    try std.testing.expect(!isCompressed(&invalid));
}
```

### PublicKey.compress/decompress - known test vector

```zig
test "PublicKey.compress/decompress - known test vector" {
    // Known test vector from SEC 2 v2 spec
    // Generator point (secp256k1)
    const gen = crypto.secp256k1.AffinePoint.generator();

    // Create public key from generator
    var pk: PublicKey = undefined;
    std.mem.writeInt(u256, pk.bytes[0..32], gen.x, .big);
    std.mem.writeInt(u256, pk.bytes[32..64], gen.y, .big);

    // Compress
    const compressed = compress(pk);

    // Expected: 02 + 32 bytes of x
    try std.testing.expectEqual(@as(u8, 0x02), compressed[0]);

    // Decompress and verify
    const decompressed = try decompress(compressed);

    // Verify coordinates match
    const x_orig = std.mem.readInt(u256, pk.bytes[0..32], .big);
    const y_orig = std.mem.readInt(u256, pk.bytes[32..64], .big);
    const x_decomp = std.mem.readInt(u256, decompressed.bytes[0..32], .big);
    const y_decomp = std.mem.readInt(u256, decompressed.bytes[32..64], .big);

    try std.testing.expectEqual(x_orig, x_decomp);
    try std.testing.expectEqual(y_orig, y_decomp);
}
```
