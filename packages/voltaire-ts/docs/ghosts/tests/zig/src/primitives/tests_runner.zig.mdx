---
title: '[Zig] src/primitives/tests_runner.zig'
source: 'src/primitives/tests_runner.zig'
---

> Auto-generated from Zig tests in: src/primitives/tests_runner.zig

### Hex.xor requires equal lengths

```zig
test "Hex.xor requires equal lengths" {
    const allocator = std.testing.allocator;
    const a = "0x00";
    const b = "0x0000"; // different length
    try std.testing.expectError(p.Hex.HexError.InvalidLength, p.Hex.xor(allocator, a, b));
}
```

### Hex.equals is case-insensitive

```zig
test "Hex.equals is case-insensitive" {
    try std.testing.expect(p.Hex.equals("0xdeadbeef", "0xDEADBEEF"));
    try std.testing.expect(!p.Hex.equals("0xdeadbeef", "0xdeadbeee"));
}
```

### Address checksum validation and roundtrips

```zig
test "Address checksum validation and roundtrips" {
    const checksummed = "0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045";
    const lower = "0xd8da6bf26964af9d7eed9e03e53415d37aa96045";
    try std.testing.expect(p.Address.isValidChecksumAddress(checksummed));
    try std.testing.expect(!p.Address.isValidChecksumAddress(lower));

    const addr = try p.Address.fromHex(checksummed);
    const abi = p.Address.toAbiEncoded(addr);
    const back = try p.Address.fromAbiEncoded(&abi);
    try std.testing.expect(p.Address.equals(addr, back));
}
```

### Address.fromBytes enforces 20 bytes

```zig
test "Address.fromBytes enforces 20 bytes" {
    // Too short
    try std.testing.expectError(error.InvalidAddressLength, p.Address.fromBytes(&[_]u8{0x00} ** 19));
    // Too long
    try std.testing.expectError(error.InvalidAddressLength, p.Address.fromBytes(&[_]u8{0x00} ** 21));
}
```

### Address sort and deduplicate

```zig
test "Address sort and deduplicate" {
    const allocator = std.testing.allocator;
    const a = try p.Address.fromHex("0x0000000000000000000000000000000000000001");
    const b = try p.Address.fromHex("0x0000000000000000000000000000000000000002");
    const c = try p.Address.fromHex("0x0000000000000000000000000000000000000003");

    var input = [_]p.Address{ c, a, b, a, c };
    const sorted = try p.Address.sortAddresses(allocator, &input);
    defer allocator.free(sorted);

    // Expect non-decreasing order and same length as input
    try std.testing.expectEqual(@as(usize, input.len), sorted.len);
    // Verify monotonic ordering
    for (1..sorted.len) |i| {
        if (p.Address.equals(sorted[i - 1], sorted[i])) continue;
        try std.testing.expect(p.Address.lessThan(sorted[i - 1], sorted[i]));
    }

    const dedup = try p.Address.deduplicateAddresses(allocator, sorted);
    defer allocator.free(dedup);
    try std.testing.expectEqual(@as(usize, 3), dedup.len);
}
```
