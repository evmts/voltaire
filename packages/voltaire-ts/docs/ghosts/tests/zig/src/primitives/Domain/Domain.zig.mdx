---
title: '[Zig] src/primitives/Domain/Domain.zig'
source: 'src/primitives/Domain/Domain.zig'
---

> Auto-generated from Zig tests in: src/primitives/Domain/Domain.zig

### Domain: validate succeeds with name

```zig
test "Domain: validate succeeds with name" {
    const domain = Domain{ .name = "Test" };
    try domain.validate();
}
```

### Domain: validate succeeds with version

```zig
test "Domain: validate succeeds with version" {
    const domain = Domain{ .version = "1" };
    try domain.validate();
}
```

### Domain: validate succeeds with chain_id

```zig
test "Domain: validate succeeds with chain_id" {
    const domain = Domain{ .chain_id = 1 };
    try domain.validate();
}
```

### Domain: validate succeeds with verifying_contract

```zig
test "Domain: validate succeeds with verifying_contract" {
    const addr = try Address.fromHex("0x742d35Cc6634C0532925a3b844Bc9e7595f251e3");
    const domain = Domain{ .verifying_contract = addr };
    try domain.validate();
}
```

### Domain: validate succeeds with salt

```zig
test "Domain: validate succeeds with salt" {
    const domain = Domain{ .salt = [_]u8{0xab} ** 32 };
    try domain.validate();
}
```

### Domain: validate fails with no fields

```zig
test "Domain: validate fails with no fields" {
    const domain = Domain{};
    try std.testing.expectError(error.InvalidDomain, domain.validate());
}
```

### Domain: getTypeString with all fields

```zig
test "Domain: getTypeString with all fields" {
    const allocator = std.testing.allocator;
    const addr = try Address.fromHex("0x742d35Cc6634C0532925a3b844Bc9e7595f251e3");
    const domain = Domain{
        .name = "Test",
        .version = "1",
        .chain_id = 1,
        .verifying_contract = addr,
        .salt = [_]u8{0} ** 32,
    };

    const type_string = try domain.getTypeString(allocator);
    defer allocator.free(type_string);

    try std.testing.expectEqualStrings(
        "EIP712Domain(string name,string version,uint256 chainId,address verifyingContract,bytes32 salt)",
        type_string,
    );
}
```

### Domain: getTypeString with name only

```zig
test "Domain: getTypeString with name only" {
    const allocator = std.testing.allocator;
    const domain = Domain{ .name = "Test" };

    const type_string = try domain.getTypeString(allocator);
    defer allocator.free(type_string);

    try std.testing.expectEqualStrings("EIP712Domain(string name)", type_string);
}
```

### Domain: getTypeString with name and version

```zig
test "Domain: getTypeString with name and version" {
    const allocator = std.testing.allocator;
    const domain = Domain{
        .name = "Test",
        .version = "1",
    };

    const type_string = try domain.getTypeString(allocator);
    defer allocator.free(type_string);

    try std.testing.expectEqualStrings("EIP712Domain(string name,string version)", type_string);
}
```

### Domain: toHash produces consistent result

```zig
test "Domain: toHash produces consistent result" {
    const allocator = std.testing.allocator;
    const domain = Domain{
        .name = "Test",
        .version = "1",
        .chain_id = 1,
    };

    const hash1 = try domain.toHash(allocator);
    const hash2 = try domain.toHash(allocator);

    try std.testing.expect(hash1.equals(hash2));
}
```

### Domain: toHash different domains produce different hashes

```zig
test "Domain: toHash different domains produce different hashes" {
    const allocator = std.testing.allocator;
    const domain1 = Domain{ .name = "Test1" };
    const domain2 = Domain{ .name = "Test2" };

    const hash1 = try domain1.toHash(allocator);
    const hash2 = try domain2.toHash(allocator);

    try std.testing.expect(!hash1.equals(hash2));
}
```

### Domain: equals same domain

```zig
test "Domain: equals same domain" {
    const domain = Domain{
        .name = "Test",
        .version = "1",
    };
    try std.testing.expect(domain.equals(domain));
}
```

### Domain: equals identical domains

```zig
test "Domain: equals identical domains" {
    const a = Domain{
        .name = "Test",
        .version = "1",
        .chain_id = 1,
    };
    const b = Domain{
        .name = "Test",
        .version = "1",
        .chain_id = 1,
    };
    try std.testing.expect(a.equals(b));
}
```

### Domain: equals different names

```zig
test "Domain: equals different names" {
    const a = Domain{ .name = "Test1" };
    const b = Domain{ .name = "Test2" };
    try std.testing.expect(!a.equals(b));
}
```

### Domain: equals different versions

```zig
test "Domain: equals different versions" {
    const a = Domain{ .name = "Test", .version = "1" };
    const b = Domain{ .name = "Test", .version = "2" };
    try std.testing.expect(!a.equals(b));
}
```

### Domain: equals different chain_id

```zig
test "Domain: equals different chain_id" {
    const a = Domain{ .name = "Test", .chain_id = 1 };
    const b = Domain{ .name = "Test", .chain_id = 5 };
    try std.testing.expect(!a.equals(b));
}
```

### Domain: equals null vs non-null

```zig
test "Domain: equals null vs non-null" {
    const a = Domain{ .name = "Test" };
    const b = Domain{ .name = "Test", .version = "1" };
    try std.testing.expect(!a.equals(b));
}
```

### Domain: getFieldsBitmap

```zig
test "Domain: getFieldsBitmap" {
    const domain_name = Domain{ .name = "Test" };
    try std.testing.expectEqual(@as(u8, 0x01), domain_name.getFieldsBitmap());

    const domain_version = Domain{ .version = "1" };
    try std.testing.expectEqual(@as(u8, 0x02), domain_version.getFieldsBitmap());

    const domain_chain = Domain{ .chain_id = 1 };
    try std.testing.expectEqual(@as(u8, 0x04), domain_chain.getFieldsBitmap());

    const addr = try Address.fromHex("0x742d35Cc6634C0532925a3b844Bc9e7595f251e3");
    const domain_contract = Domain{ .verifying_contract = addr };
    try std.testing.expectEqual(@as(u8, 0x08), domain_contract.getFieldsBitmap());

    const domain_salt = Domain{ .salt = [_]u8{0} ** 32 };
    try std.testing.expectEqual(@as(u8, 0x10), domain_salt.getFieldsBitmap());

    const domain_all = Domain{
        .name = "Test",
        .version = "1",
        .chain_id = 1,
        .verifying_contract = addr,
        .salt = [_]u8{0} ** 32,
    };
    try std.testing.expectEqual(@as(u8, 0x1f), domain_all.getFieldsBitmap());
}
```

### Domain: known test vector from EIP-712 spec

```zig
test "Domain: known test vector from EIP-712 spec" {
    // Test against known EIP-712 domain separator from the official spec
    // https://eips.ethereum.org/EIPS/eip-712
    // Domain: name="Ether Mail", version="1", chainId=1,
    //         verifyingContract=0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC
    // Expected hash: 0xf2cee375fa42b42143804025fc449deafd50cc031ca257e0b194a650a912090f
    const allocator = std.testing.allocator;
    const domain = Domain{
        .name = "Ether Mail",
        .version = "1",
        .chain_id = 1,
        .verifying_contract = try Address.fromHex("0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC"),
    };

    const hash = try domain.toHash(allocator);

    // Verify against expected EIP-712 domain separator
    const expected = try DomainSeparator.fromHex("0xf2cee375fa42b42143804025fc449deafd50cc031ca257e0b194a650a912090f");
    try std.testing.expect(hash.equals(expected));
}
```

### Domain: getEIP712DomainType with all fields

```zig
test "Domain: getEIP712DomainType with all fields" {
    const addr = try Address.fromHex("0x742d35Cc6634C0532925a3b844Bc9e7595f251e3");
    const domain = Domain{
        .name = "Test",
        .version = "1",
        .chain_id = 1,
        .verifying_contract = addr,
        .salt = [_]u8{0} ** 32,
    };

    var buffer: [5]EIP712Field = undefined;
    const fields = domain.getEIP712DomainType(&buffer);

    try std.testing.expectEqual(@as(usize, 5), fields.len);
    try std.testing.expectEqualStrings("name", fields[0].name);
    try std.testing.expectEqualStrings("string", fields[0].type);
    try std.testing.expectEqualStrings("version", fields[1].name);
    try std.testing.expectEqualStrings("string", fields[1].type);
    try std.testing.expectEqualStrings("chainId", fields[2].name);
    try std.testing.expectEqualStrings("uint256", fields[2].type);
    try std.testing.expectEqualStrings("verifyingContract", fields[3].name);
    try std.testing.expectEqualStrings("address", fields[3].type);
    try std.testing.expectEqualStrings("salt", fields[4].name);
    try std.testing.expectEqualStrings("bytes32", fields[4].type);
}
```

### Domain: getEIP712DomainType with partial fields

```zig
test "Domain: getEIP712DomainType with partial fields" {
    const domain = Domain{
        .name = "Test",
        .chain_id = 1,
    };

    var buffer: [5]EIP712Field = undefined;
    const fields = domain.getEIP712DomainType(&buffer);

    try std.testing.expectEqual(@as(usize, 2), fields.len);
    try std.testing.expectEqualStrings("name", fields[0].name);
    try std.testing.expectEqualStrings("chainId", fields[1].name);
}
```

### Domain: typeHash for EIP712Domain

```zig
test "Domain: typeHash for EIP712Domain" {
    // Verify the type hash matches expected keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)")
    const allocator = std.testing.allocator;
    const domain = Domain{
        .name = "Ether Mail",
        .version = "1",
        .chain_id = 1,
        .verifying_contract = try Address.fromHex("0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC"),
    };

    const type_string = try domain.getTypeString(allocator);
    defer allocator.free(type_string);

    // Verify type string is correct
    try std.testing.expectEqualStrings(
        "EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)",
        type_string,
    );
}
```

### Domain: typeHash with salt field

```zig
test "Domain: typeHash with salt field" {
    const allocator = std.testing.allocator;
    const domain = Domain{
        .name = "Test",
        .version = "1",
        .chain_id = 1,
        .salt = [_]u8{0xab} ** 32,
    };

    const type_string = try domain.getTypeString(allocator);
    defer allocator.free(type_string);

    // Verify type string includes salt
    try std.testing.expectEqualStrings(
        "EIP712Domain(string name,string version,uint256 chainId,bytes32 salt)",
        type_string,
    );
}
```

### Domain: domain separator with only name

```zig
test "Domain: domain separator with only name" {
    const allocator = std.testing.allocator;
    const domain = Domain{
        .name = "SimpleDapp",
    };

    const type_string = try domain.getTypeString(allocator);
    defer allocator.free(type_string);

    try std.testing.expectEqualStrings(
        "EIP712Domain(string name)",
        type_string,
    );

    // Verify toHash works for minimal domain
    const hash = try domain.toHash(allocator);
    try std.testing.expect(!hash.isZero());
}
```

### Domain: toErc5267Response with all fields

```zig
test "Domain: toErc5267Response with all fields" {
    const addr = try Address.fromHex("0x742d35Cc6634C0532925a3b844Bc9e7595f251e3");
    const domain = Domain{
        .name = "Test",
        .version = "1",
        .chain_id = 1,
        .verifying_contract = addr,
        .salt = [_]u8{0xab} ** 32,
    };

    const response = domain.toErc5267Response();

    try std.testing.expectEqual(@as(u8, 0x1f), response.fields);
    try std.testing.expectEqualStrings("Test", response.name);
    try std.testing.expectEqualStrings("1", response.version);
    try std.testing.expectEqual(@as(u64, 1), response.chain_id);
    try std.testing.expect(response.verifying_contract.equals(addr));
    try std.testing.expectEqual([_]u8{0xab} ** 32, response.salt);
}
```

### Domain: toErc5267Response with partial fields uses defaults

```zig
test "Domain: toErc5267Response with partial fields uses defaults" {
    const domain = Domain{
        .name = "Test",
        .chain_id = 1,
    };

    const response = domain.toErc5267Response();

    try std.testing.expectEqual(@as(u8, 0x05), response.fields); // name + chain_id
    try std.testing.expectEqualStrings("Test", response.name);
    try std.testing.expectEqualStrings("", response.version); // default empty
    try std.testing.expectEqual(@as(u64, 1), response.chain_id);
    try std.testing.expect(response.verifying_contract.equals(Address.ZERO_ADDRESS)); // default zero
    try std.testing.expectEqual([_]u8{0} ** 32, response.salt); // default zeros
}
```
