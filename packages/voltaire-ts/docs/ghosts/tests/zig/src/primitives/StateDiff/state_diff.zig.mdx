---
title: '[Zig] src/primitives/StateDiff/state_diff.zig'
source: 'src/primitives/StateDiff/state_diff.zig'
---

> Auto-generated from Zig tests in: src/primitives/StateDiff/state_diff.zig

### StateDiff.init creates empty diff

```zig
test "StateDiff.init creates empty diff" {
    var diff = init(std.testing.allocator);
    defer diff.deinit();

    try std.testing.expect(isEmpty(&diff));
    try std.testing.expectEqual(@as(usize, 0), accountCount(&diff));
}
```

### StateDiff.setBalanceChange adds balance change

```zig
test "StateDiff.setBalanceChange adds balance change" {
    var diff = init(std.testing.allocator);
    defer diff.deinit();

    const address = Address.Address{ .bytes = [_]u8{0xaa} ** 20 };
    try setBalanceChange(&diff, address, 1000, 2000);

    try std.testing.expect(!isEmpty(&diff));
    try std.testing.expect(hasAccount(&diff, address));
    try std.testing.expect(hasBalanceChange(&diff, address));

    const account = getAccount(&diff, address);
    try std.testing.expect(account != null);
    try std.testing.expectEqual(@as(u256, 1000), account.?.balance.?.from.?);
    try std.testing.expectEqual(@as(u256, 2000), account.?.balance.?.to.?);
}
```

### StateDiff.setNonceChange adds nonce change

```zig
test "StateDiff.setNonceChange adds nonce change" {
    var diff = init(std.testing.allocator);
    defer diff.deinit();

    const address = Address.Address{ .bytes = [_]u8{0xbb} ** 20 };
    try setNonceChange(&diff, address, 0, 1);

    try std.testing.expect(hasNonceChange(&diff, address));

    const account = getAccount(&diff, address);
    try std.testing.expect(account != null);
    try std.testing.expectEqual(@as(u64, 0), account.?.nonce.?.from.?);
    try std.testing.expectEqual(@as(u64, 1), account.?.nonce.?.to.?);
}
```

### StateDiff.setCodeChange adds code change

```zig
test "StateDiff.setCodeChange adds code change" {
    var diff = init(std.testing.allocator);
    defer diff.deinit();

    const address = Address.Address{ .bytes = [_]u8{0xcc} ** 20 };
    const new_code = [_]u8{ 0x60, 0x80, 0x60, 0x40 };
    try setCodeChange(&diff, address, null, &new_code);

    try std.testing.expect(hasCodeChange(&diff, address));

    const account = getAccount(&diff, address);
    try std.testing.expect(account != null);
    try std.testing.expect(account.?.code.?.from == null);
    try std.testing.expectEqualSlices(u8, &new_code, account.?.code.?.to.?);
}
```

### StateDiff.setStorageChange adds storage change

```zig
test "StateDiff.setStorageChange adds storage change" {
    var diff = init(std.testing.allocator);
    defer diff.deinit();

    const address = Address.Address{ .bytes = [_]u8{0xdd} ** 20 };
    const slot: [32]u8 = [_]u8{0x00} ** 32;
    const value: [32]u8 = [_]u8{0xff} ** 32;
    try setStorageChange(&diff, address, slot, null, value);

    try std.testing.expect(hasStorageChanges(&diff, address));

    const account = getAccount(&diff, address);
    try std.testing.expect(account != null);
    const storage_change = account.?.storage.get(slot);
    try std.testing.expect(storage_change != null);
    try std.testing.expect(storage_change.?.from == null);
    try std.testing.expectEqualSlices(u8, &value, &storage_change.?.to.?);
}
```

### StateDiff.getAddresses returns all addresses

```zig
test "StateDiff.getAddresses returns all addresses" {
    var diff = init(std.testing.allocator);
    defer diff.deinit();

    const address1 = Address.Address{ .bytes = [_]u8{0x11} ** 20 };
    const address2 = Address.Address{ .bytes = [_]u8{0x22} ** 20 };

    try setBalanceChange(&diff, address1, 100, 200);
    try setNonceChange(&diff, address2, 0, 1);

    const addresses = try getAddresses(&diff, std.testing.allocator);
    defer std.testing.allocator.free(addresses);

    try std.testing.expectEqual(@as(usize, 2), addresses.len);
}
```

### StateDiff multiple changes for same account

```zig
test "StateDiff multiple changes for same account" {
    var diff = init(std.testing.allocator);
    defer diff.deinit();

    const address = Address.Address{ .bytes = [_]u8{0xee} ** 20 };

    try setBalanceChange(&diff, address, 1000, 2000);
    try setNonceChange(&diff, address, 0, 1);

    try std.testing.expectEqual(@as(usize, 1), accountCount(&diff));
    try std.testing.expect(hasBalanceChange(&diff, address));
    try std.testing.expect(hasNonceChange(&diff, address));
}
```

### StateDiff.isEmpty

```zig
test "StateDiff.isEmpty" {
    var diff = init(std.testing.allocator);
    defer diff.deinit();

    try std.testing.expect(isEmpty(&diff));

    const address = Address.Address{ .bytes = [_]u8{0xff} ** 20 };
    try setBalanceChange(&diff, address, 100, 200);

    try std.testing.expect(!isEmpty(&diff));
}
```

### AccountDiff.hasChanges

```zig
test "AccountDiff.hasChanges" {
    var account = AccountDiff.init(std.testing.allocator);
    defer account.deinit();

    try std.testing.expect(!account.hasChanges());

    account.balance = .{ .from = 100, .to = 200 };
    try std.testing.expect(account.hasChanges());
}
```

### StateDiff.fromPrestateJson parses nonce increment

```zig
test "StateDiff.fromPrestateJson parses nonce increment" {
    // Real prestateTracer diffMode output format
    const json_input =
        \\{"pre":{"0x35a9f94af726f07b5162df7e828cc9dc8439e7d0":{"balance":"0x7a48429e177130a","nonce":1134}},"post":{"0x35a9f94af726f07b5162df7e828cc9dc8439e7d0":{"nonce":1135}}}
    ;

    var diff = try fromPrestateJson(std.testing.allocator, json_input);
    defer diff.deinit();

    try std.testing.expect(!isEmpty(&diff));
    try std.testing.expectEqual(@as(usize, 1), accountCount(&diff));

    // Check the address was parsed correctly
    var expected_addr: [20]u8 = undefined;
    _ = try Hex.hexToBytes(&expected_addr, "0x35a9f94af726f07b5162df7e828cc9dc8439e7d0");
    const address = Address.Address{ .bytes = expected_addr };

    try std.testing.expect(hasAccount(&diff, address));
    try std.testing.expect(hasBalanceChange(&diff, address));
    try std.testing.expect(hasNonceChange(&diff, address));

    const account = getAccount(&diff, address);
    try std.testing.expect(account != null);

    // Nonce: 1134 -> 1135
    try std.testing.expectEqual(@as(u64, 1134), account.?.nonce.?.from.?);
    try std.testing.expectEqual(@as(u64, 1135), account.?.nonce.?.to.?);
}
```

### StateDiff.fromPrestateJson parses storage changes

```zig
test "StateDiff.fromPrestateJson parses storage changes" {
    const json_input =
        \\{"pre":{"0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa":{"storage":{"0x0000000000000000000000000000000000000000000000000000000000000001":"0x0000000000000000000000000000000000000000000000000000000000000064"}}},"post":{"0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa":{"storage":{"0x0000000000000000000000000000000000000000000000000000000000000001":"0x00000000000000000000000000000000000000000000000000000000000000c8"}}}}
    ;

    var diff = try fromPrestateJson(std.testing.allocator, json_input);
    defer diff.deinit();

    var addr_bytes: [20]u8 = undefined;
    _ = try Hex.hexToBytes(&addr_bytes, "0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa");
    const address = Address.Address{ .bytes = addr_bytes };

    try std.testing.expect(hasStorageChanges(&diff, address));

    const account = getAccount(&diff, address);
    try std.testing.expect(account != null);

    var slot: [32]u8 = undefined;
    _ = try Hex.hexToBytes(&slot, "0x0000000000000000000000000000000000000000000000000000000000000001");

    const change = account.?.storage.get(slot);
    try std.testing.expect(change != null);

    // 0x64 = 100, 0xc8 = 200
    var expected_from: [32]u8 = [_]u8{0} ** 32;
    expected_from[31] = 0x64;
    try std.testing.expectEqualSlices(u8, &expected_from, &change.?.from.?);

    var expected_to: [32]u8 = [_]u8{0} ** 32;
    expected_to[31] = 0xc8;
    try std.testing.expectEqualSlices(u8, &expected_to, &change.?.to.?);
}
```

### StateDiff.fromPrestateJson parses new account

```zig
test "StateDiff.fromPrestateJson parses new account" {
    const json_input =
        \\{"pre":{},"post":{"0xbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb":{"balance":"0x1000","nonce":1}}}
    ;

    var diff = try fromPrestateJson(std.testing.allocator, json_input);
    defer diff.deinit();

    var addr_bytes: [20]u8 = undefined;
    _ = try Hex.hexToBytes(&addr_bytes, "0xbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb");
    const address = Address.Address{ .bytes = addr_bytes };

    try std.testing.expect(hasAccount(&diff, address));

    const account = getAccount(&diff, address);
    try std.testing.expect(account != null);

    // New account: from = null
    try std.testing.expect(account.?.balance.?.from == null);
    try std.testing.expectEqual(@as(u256, 0x1000), account.?.balance.?.to.?);

    try std.testing.expect(account.?.nonce.?.from == null);
    try std.testing.expectEqual(@as(u64, 1), account.?.nonce.?.to.?);
}
```

### StateDiff.toJson roundtrip

```zig
test "StateDiff.toJson roundtrip" {
    var diff = init(std.testing.allocator);
    defer diff.deinit();

    const address = Address.Address{ .bytes = [_]u8{0xaa} ** 20 };
    try setBalanceChange(&diff, address, 1000, 2000);
    try setNonceChange(&diff, address, 5, 6);

    const json_output = try toJson(&diff, std.testing.allocator);
    defer std.testing.allocator.free(json_output);

    // Verify it contains expected structure
    try std.testing.expect(std.mem.indexOf(u8, json_output, "\"pre\":{") != null);
    try std.testing.expect(std.mem.indexOf(u8, json_output, "\"post\":{") != null);
}

test "StateDiff.equals compares diffs" {
    var diff1 = init(std.testing.allocator);
    defer diff1.deinit();

    var diff2 = init(std.testing.allocator);
    defer diff2.deinit();

    const address = Address.Address{ .bytes = [_]u8{0xcc} ** 20 };

    try setBalanceChange(&diff1, address, 100, 200);
    try setBalanceChange(&diff2, address, 100, 200);

    try std.testing.expect(equals(&diff1, &diff2));

    // Different value
    var diff3 = init(std.testing.allocator);
    defer diff3.deinit();
    try setBalanceChange(&diff3, address, 100, 300);

    try std.testing.expect(!equals(&diff1, &diff3));
}

test "parseHexU256 parses various formats" {
    try std.testing.expectEqual(@as(u256, 0), try parseHexU256("0x0"));
    try std.testing.expectEqual(@as(u256, 255), try parseHexU256("0xff"));
    try std.testing.expectEqual(@as(u256, 255), try parseHexU256("0xFF"));
    try std.testing.expectEqual(@as(u256, 4096), try parseHexU256("0x1000"));
    try std.testing.expectEqual(@as(u256, 0x7a48429e177130a), try parseHexU256("0x7a48429e177130a"));
}
```
