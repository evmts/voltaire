---
title: '[Zig] src/primitives/Abi/abi_encoding.zig'
source: 'src/primitives/Abi/abi_encoding.zig'
---

> Auto-generated from Zig tests in: src/primitives/Abi/abi_encoding.zig

### encodePacked - uint8

```zig
test "encodePacked - uint8" {
    const allocator = std.testing.allocator;
    const values = [_]AbiValue{AbiValue{ .uint8 = 42 }};
    const encoded = try encodePacked(allocator, &values);
    defer allocator.free(encoded);

    try std.testing.expectEqual(@as(usize, 1), encoded.len);
    try std.testing.expectEqual(@as(u8, 42), encoded[0]);
}
```

### encodePacked - uint16

```zig
test "encodePacked - uint16" {
    const allocator = std.testing.allocator;
    const values = [_]AbiValue{AbiValue{ .uint16 = 0x1234 }};
    const encoded = try encodePacked(allocator, &values);
    defer allocator.free(encoded);

    try std.testing.expectEqual(@as(usize, 2), encoded.len);
    try std.testing.expectEqual(@as(u8, 0x12), encoded[0]);
    try std.testing.expectEqual(@as(u8, 0x34), encoded[1]);
}
```

### encodePacked - uint32

```zig
test "encodePacked - uint32" {
    const allocator = std.testing.allocator;
    const values = [_]AbiValue{AbiValue{ .uint32 = 0xDEADBEEF }};
    const encoded = try encodePacked(allocator, &values);
    defer allocator.free(encoded);

    try std.testing.expectEqual(@as(usize, 4), encoded.len);
    try std.testing.expectEqual(@as(u8, 0xDE), encoded[0]);
    try std.testing.expectEqual(@as(u8, 0xAD), encoded[1]);
    try std.testing.expectEqual(@as(u8, 0xBE), encoded[2]);
    try std.testing.expectEqual(@as(u8, 0xEF), encoded[3]);
}
```

### encodePacked - uint64

```zig
test "encodePacked - uint64" {
    const allocator = std.testing.allocator;
    const values = [_]AbiValue{AbiValue{ .uint64 = 42 }};
    const encoded = try encodePacked(allocator, &values);
    defer allocator.free(encoded);

    try std.testing.expectEqual(@as(usize, 8), encoded.len);
    try std.testing.expectEqual(@as(u8, 0x00), encoded[0]);
    try std.testing.expectEqual(@as(u8, 0x00), encoded[1]);
    try std.testing.expectEqual(@as(u8, 0x00), encoded[2]);
    try std.testing.expectEqual(@as(u8, 0x00), encoded[3]);
    try std.testing.expectEqual(@as(u8, 0x00), encoded[4]);
    try std.testing.expectEqual(@as(u8, 0x00), encoded[5]);
    try std.testing.expectEqual(@as(u8, 0x00), encoded[6]);
    try std.testing.expectEqual(@as(u8, 0x2A), encoded[7]);
}
```

### encodePacked - uint128

```zig
test "encodePacked - uint128" {
    const allocator = std.testing.allocator;
    const values = [_]AbiValue{AbiValue{ .uint128 = 0x123456789ABCDEF }};
    const encoded = try encodePacked(allocator, &values);
    defer allocator.free(encoded);

    try std.testing.expectEqual(@as(usize, 16), encoded.len);
    // Check last 8 bytes contain the value
    try std.testing.expectEqual(@as(u8, 0xEF), encoded[15]);
    try std.testing.expectEqual(@as(u8, 0xCD), encoded[14]);
    try std.testing.expectEqual(@as(u8, 0xAB), encoded[13]);
}
```

### encodePacked - uint256

```zig
test "encodePacked - uint256" {
    const allocator = std.testing.allocator;
    const values = [_]AbiValue{AbiValue{ .uint256 = 0xDEADBEEF }};
    const encoded = try encodePacked(allocator, &values);
    defer allocator.free(encoded);

    try std.testing.expectEqual(@as(usize, 32), encoded.len);
    // Check last 4 bytes contain the value
    try std.testing.expectEqual(@as(u8, 0xDE), encoded[28]);
    try std.testing.expectEqual(@as(u8, 0xAD), encoded[29]);
    try std.testing.expectEqual(@as(u8, 0xBE), encoded[30]);
    try std.testing.expectEqual(@as(u8, 0xEF), encoded[31]);
}
```

### encodePacked - address

```zig
test "encodePacked - address" {
    const allocator = std.testing.allocator;
    const addr_bytes = [_]u8{0xAA} ** 20;
    const addr = address.Address{ .bytes = addr_bytes };
    const values = [_]AbiValue{AbiValue{ .address = addr }};
    const encoded = try encodePacked(allocator, &values);
    defer allocator.free(encoded);

    try std.testing.expectEqual(@as(usize, 20), encoded.len);
    for (encoded) |b| {
        try std.testing.expectEqual(@as(u8, 0xAA), b);
    }
}
```

### encodePacked - bool true

```zig
test "encodePacked - bool true" {
    const allocator = std.testing.allocator;
    const values = [_]AbiValue{AbiValue{ .bool = true }};
    const encoded = try encodePacked(allocator, &values);
    defer allocator.free(encoded);

    try std.testing.expectEqual(@as(usize, 1), encoded.len);
    try std.testing.expectEqual(@as(u8, 1), encoded[0]);
}
```

### encodePacked - bool false

```zig
test "encodePacked - bool false" {
    const allocator = std.testing.allocator;
    const values = [_]AbiValue{AbiValue{ .bool = false }};
    const encoded = try encodePacked(allocator, &values);
    defer allocator.free(encoded);

    try std.testing.expectEqual(@as(usize, 1), encoded.len);
    try std.testing.expectEqual(@as(u8, 0), encoded[0]);
}
```

### encodePacked - bytes32

```zig
test "encodePacked - bytes32" {
    const allocator = std.testing.allocator;
    const hash_bytes = [_]u8{0xFF} ** 32;
    const values = [_]AbiValue{AbiValue{ .bytes32 = hash_bytes }};
    const encoded = try encodePacked(allocator, &values);
    defer allocator.free(encoded);

    try std.testing.expectEqual(@as(usize, 32), encoded.len);
    for (encoded) |b| {
        try std.testing.expectEqual(@as(u8, 0xFF), b);
    }
}
```

### encodePacked - issue #28 exact scenario

```zig
test "encodePacked - issue #28 exact scenario" {
    const allocator = std.testing.allocator;

    const alice = [_]u8{0xAA} ** 20;
    const bob = [_]u8{0xBB} ** 20;
    const zero_addr = [_]u8{0x00} ** 20;

    const values = [_]AbiValue{
        addressValue(address.Address{ .bytes = alice }),
        addressValue(address.Address{ .bytes = bob }),
        AbiValue{ .uint64 = 42 },
        addressValue(address.Address{ .bytes = zero_addr }),
        AbiValue{ .uint32 = 86400 },
    };

    const encoded = try encodePacked(allocator, &values);
    defer allocator.free(encoded);

    // Expected: 20 + 20 + 8 + 20 + 4 = 72 bytes
    try std.testing.expectEqual(@as(usize, 72), encoded.len);

    // Verify alice (first 20 bytes)
    for (encoded[0..20]) |b| {
        try std.testing.expectEqual(@as(u8, 0xAA), b);
    }

    // Verify bob (next 20 bytes)
    for (encoded[20..40]) |b| {
        try std.testing.expectEqual(@as(u8, 0xBB), b);
    }

    // Verify uint64 = 42 (next 8 bytes)
    try std.testing.expectEqual(@as(u8, 0x00), encoded[40]);
    try std.testing.expectEqual(@as(u8, 0x2A), encoded[47]); // Last byte = 42

    // Verify zero address (next 20 bytes)
    for (encoded[48..68]) |b| {
        try std.testing.expectEqual(@as(u8, 0x00), b);
    }

    // Verify uint32 = 86400 (0x15180) (last 4 bytes)
    try std.testing.expectEqual(@as(u8, 0x00), encoded[68]);
    try std.testing.expectEqual(@as(u8, 0x01), encoded[69]);
    try std.testing.expectEqual(@as(u8, 0x51), encoded[70]);
    try std.testing.expectEqual(@as(u8, 0x80), encoded[71]);
}
```

### encodePacked - multiple addresses

```zig
test "encodePacked - multiple addresses" {
    const allocator = std.testing.allocator;

    const addr1 = [_]u8{0x11} ** 20;
    const addr2 = [_]u8{0x22} ** 20;

    const values = [_]AbiValue{
        addressValue(address.Address{ .bytes = addr1 }),
        addressValue(address.Address{ .bytes = addr2 }),
    };

    const encoded = try encodePacked(allocator, &values);
    defer allocator.free(encoded);

    try std.testing.expectEqual(@as(usize, 40), encoded.len);

    for (encoded[0..20]) |b| {
        try std.testing.expectEqual(@as(u8, 0x11), b);
    }
    for (encoded[20..40]) |b| {
        try std.testing.expectEqual(@as(u8, 0x22), b);
    }
}
```

### encodePacked - mixed types

```zig
test "encodePacked - mixed types" {
    const allocator = std.testing.allocator;

    const values = [_]AbiValue{
        AbiValue{ .uint8 = 0xFF },
        AbiValue{ .uint16 = 0x1234 },
        AbiValue{ .uint32 = 0xDEADBEEF },
    };

    const encoded = try encodePacked(allocator, &values);
    defer allocator.free(encoded);

    // 1 + 2 + 4 = 7 bytes
    try std.testing.expectEqual(@as(usize, 7), encoded.len);
    try std.testing.expectEqual(@as(u8, 0xFF), encoded[0]);
    try std.testing.expectEqual(@as(u8, 0x12), encoded[1]);
    try std.testing.expectEqual(@as(u8, 0x34), encoded[2]);
    try std.testing.expectEqual(@as(u8, 0xDE), encoded[3]);
}
```

### encodePacked - int8 positive

```zig
test "encodePacked - int8 positive" {
    const allocator = std.testing.allocator;
    const values = [_]AbiValue{AbiValue{ .int8 = 42 }};
    const encoded = try encodePacked(allocator, &values);
    defer allocator.free(encoded);

    try std.testing.expectEqual(@as(usize, 1), encoded.len);
    try std.testing.expectEqual(@as(u8, 42), encoded[0]);
}
```

### encodePacked - int8 negative

```zig
test "encodePacked - int8 negative" {
    const allocator = std.testing.allocator;
    const values = [_]AbiValue{AbiValue{ .int8 = -1 }};
    const encoded = try encodePacked(allocator, &values);
    defer allocator.free(encoded);

    try std.testing.expectEqual(@as(usize, 1), encoded.len);
    try std.testing.expectEqual(@as(u8, 0xFF), encoded[0]); // Two's complement
}
```

### encodePacked - int16 positive

```zig
test "encodePacked - int16 positive" {
    const allocator = std.testing.allocator;
    const values = [_]AbiValue{AbiValue{ .int16 = 1000 }};
    const encoded = try encodePacked(allocator, &values);
    defer allocator.free(encoded);

    try std.testing.expectEqual(@as(usize, 2), encoded.len);
    try std.testing.expectEqual(@as(u8, 0x03), encoded[0]);
    try std.testing.expectEqual(@as(u8, 0xE8), encoded[1]);
}
```

### encodePacked - int16 negative

```zig
test "encodePacked - int16 negative" {
    const allocator = std.testing.allocator;
    const values = [_]AbiValue{AbiValue{ .int16 = -1 }};
    const encoded = try encodePacked(allocator, &values);
    defer allocator.free(encoded);

    try std.testing.expectEqual(@as(usize, 2), encoded.len);
    try std.testing.expectEqual(@as(u8, 0xFF), encoded[0]);
    try std.testing.expectEqual(@as(u8, 0xFF), encoded[1]);
}
```

### encodePacked - int32 positive

```zig
test "encodePacked - int32 positive" {
    const allocator = std.testing.allocator;
    const values = [_]AbiValue{AbiValue{ .int32 = 123456789 }};
    const encoded = try encodePacked(allocator, &values);
    defer allocator.free(encoded);

    try std.testing.expectEqual(@as(usize, 4), encoded.len);
    try std.testing.expectEqual(@as(u8, 0x07), encoded[0]);
    try std.testing.expectEqual(@as(u8, 0x5B), encoded[1]);
    try std.testing.expectEqual(@as(u8, 0xCD), encoded[2]);
    try std.testing.expectEqual(@as(u8, 0x15), encoded[3]);
}
```

### encodePacked - int32 negative

```zig
test "encodePacked - int32 negative" {
    const allocator = std.testing.allocator;
    const values = [_]AbiValue{AbiValue{ .int32 = -1 }};
    const encoded = try encodePacked(allocator, &values);
    defer allocator.free(encoded);

    try std.testing.expectEqual(@as(usize, 4), encoded.len);
    for (encoded) |b| {
        try std.testing.expectEqual(@as(u8, 0xFF), b);
    }
}
```

### encodePacked - int64 positive

```zig
test "encodePacked - int64 positive" {
    const allocator = std.testing.allocator;
    const values = [_]AbiValue{AbiValue{ .int64 = 123456789 }};
    const encoded = try encodePacked(allocator, &values);
    defer allocator.free(encoded);

    try std.testing.expectEqual(@as(usize, 8), encoded.len);
    try std.testing.expectEqual(@as(u8, 0x15), encoded[7]); // Last byte
}
```

### encodePacked - int128 positive

```zig
test "encodePacked - int128 positive" {
    const allocator = std.testing.allocator;
    const values = [_]AbiValue{AbiValue{ .int128 = 12345 }};
    const encoded = try encodePacked(allocator, &values);
    defer allocator.free(encoded);

    try std.testing.expectEqual(@as(usize, 16), encoded.len);
}
```

### encodePacked - int256 positive

```zig
test "encodePacked - int256 positive" {
    const allocator = std.testing.allocator;
    const values = [_]AbiValue{AbiValue{ .int256 = 12345 }};
    const encoded = try encodePacked(allocator, &values);
    defer allocator.free(encoded);

    try std.testing.expectEqual(@as(usize, 32), encoded.len);
    // Check last 2 bytes contain 0x3039 (12345 in hex)
    try std.testing.expectEqual(@as(u8, 0x30), encoded[30]);
    try std.testing.expectEqual(@as(u8, 0x39), encoded[31]);
}
```

### encodePacked - int256 negative all 0xFF

```zig
test "encodePacked - int256 negative all 0xFF" {
    const allocator = std.testing.allocator;
    const values = [_]AbiValue{AbiValue{ .int256 = -1 }};
    const encoded = try encodePacked(allocator, &values);
    defer allocator.free(encoded);

    try std.testing.expectEqual(@as(usize, 32), encoded.len);
    for (encoded) |b| {
        try std.testing.expectEqual(@as(u8, 0xFF), b);
    }
}
```

### encodePacked - bytes1

```zig
test "encodePacked - bytes1" {
    const allocator = std.testing.allocator;
    const values = [_]AbiValue{AbiValue{ .bytes1 = [_]u8{0x42} }};
    const encoded = try encodePacked(allocator, &values);
    defer allocator.free(encoded);

    try std.testing.expectEqual(@as(usize, 1), encoded.len);
    try std.testing.expectEqual(@as(u8, 0x42), encoded[0]);
}
```

### encodePacked - bytes2

```zig
test "encodePacked - bytes2" {
    const allocator = std.testing.allocator;
    const values = [_]AbiValue{AbiValue{ .bytes2 = [_]u8{ 0x12, 0x34 } }};
    const encoded = try encodePacked(allocator, &values);
    defer allocator.free(encoded);

    try std.testing.expectEqual(@as(usize, 2), encoded.len);
    try std.testing.expectEqual(@as(u8, 0x12), encoded[0]);
    try std.testing.expectEqual(@as(u8, 0x34), encoded[1]);
}
```

### encodePacked - bytes3

```zig
test "encodePacked - bytes3" {
    const allocator = std.testing.allocator;
    const values = [_]AbiValue{AbiValue{ .bytes3 = [_]u8{ 0x12, 0x34, 0x56 } }};
    const encoded = try encodePacked(allocator, &values);
    defer allocator.free(encoded);

    try std.testing.expectEqual(@as(usize, 3), encoded.len);
    try std.testing.expectEqual(@as(u8, 0x12), encoded[0]);
    try std.testing.expectEqual(@as(u8, 0x34), encoded[1]);
    try std.testing.expectEqual(@as(u8, 0x56), encoded[2]);
}
```

### encodePacked - bytes4

```zig
test "encodePacked - bytes4" {
    const allocator = std.testing.allocator;
    const values = [_]AbiValue{AbiValue{ .bytes4 = [_]u8{ 0x12, 0x34, 0x56, 0x78 } }};
    const encoded = try encodePacked(allocator, &values);
    defer allocator.free(encoded);

    try std.testing.expectEqual(@as(usize, 4), encoded.len);
    try std.testing.expectEqual(@as(u8, 0x12), encoded[0]);
    try std.testing.expectEqual(@as(u8, 0x78), encoded[3]);
}
```

### encodePacked - bytes8

```zig
test "encodePacked - bytes8" {
    const allocator = std.testing.allocator;
    const values = [_]AbiValue{AbiValue{ .bytes8 = [_]u8{ 0x12, 0x34, 0x56, 0x78, 0x9A, 0xBC, 0xDE, 0xF0 } }};
    const encoded = try encodePacked(allocator, &values);
    defer allocator.free(encoded);

    try std.testing.expectEqual(@as(usize, 8), encoded.len);
    try std.testing.expectEqual(@as(u8, 0x12), encoded[0]);
    try std.testing.expectEqual(@as(u8, 0xF0), encoded[7]);
}
```

### encodePacked - bytes16

```zig
test "encodePacked - bytes16" {
    const allocator = std.testing.allocator;
    const bytes16_val = [_]u8{0xAA} ** 16;
    const values = [_]AbiValue{AbiValue{ .bytes16 = bytes16_val }};
    const encoded = try encodePacked(allocator, &values);
    defer allocator.free(encoded);

    try std.testing.expectEqual(@as(usize, 16), encoded.len);
    for (encoded) |b| {
        try std.testing.expectEqual(@as(u8, 0xAA), b);
    }
}
```

### encodePacked - dynamic bytes

```zig
test "encodePacked - dynamic bytes" {
    const allocator = std.testing.allocator;
    const bytes_val = [_]u8{ 0x12, 0x34, 0x56 };
    const values = [_]AbiValue{AbiValue{ .bytes = &bytes_val }};
    const encoded = try encodePacked(allocator, &values);
    defer allocator.free(encoded);

    try std.testing.expectEqual(@as(usize, 3), encoded.len);
    try std.testing.expectEqual(@as(u8, 0x12), encoded[0]);
    try std.testing.expectEqual(@as(u8, 0x34), encoded[1]);
    try std.testing.expectEqual(@as(u8, 0x56), encoded[2]);
}
```

### encodePacked - string UTF-8

```zig
test "encodePacked - string UTF-8" {
    const allocator = std.testing.allocator;
    const str = "hello";
    const values = [_]AbiValue{AbiValue{ .string = str }};
    const encoded = try encodePacked(allocator, &values);
    defer allocator.free(encoded);

    try std.testing.expectEqual(@as(usize, 5), encoded.len);
    // "hello" = 0x68656c6c6f
    try std.testing.expectEqual(@as(u8, 0x68), encoded[0]); // 'h'
    try std.testing.expectEqual(@as(u8, 0x65), encoded[1]); // 'e'
    try std.testing.expectEqual(@as(u8, 0x6c), encoded[2]); // 'l'
    try std.testing.expectEqual(@as(u8, 0x6c), encoded[3]); // 'l'
    try std.testing.expectEqual(@as(u8, 0x6f), encoded[4]); // 'o'
}
```

### encodePacked - empty string

```zig
test "encodePacked - empty string" {
    const allocator = std.testing.allocator;
    const values = [_]AbiValue{AbiValue{ .string = "" }};
    const encoded = try encodePacked(allocator, &values);
    defer allocator.free(encoded);

    try std.testing.expectEqual(@as(usize, 0), encoded.len);
}
```

### encodePacked - uint256 array

```zig
test "encodePacked - uint256 array" {
    const allocator = std.testing.allocator;
    const arr = [_]u256{ 1, 2, 3 };
    const values = [_]AbiValue{AbiValue{ .@"uint256[]" = &arr }};
    const encoded = try encodePacked(allocator, &values);
    defer allocator.free(encoded);

    // 3 * 32 bytes = 96 bytes
    try std.testing.expectEqual(@as(usize, 96), encoded.len);
    // Check last byte of first value is 1
    try std.testing.expectEqual(@as(u8, 1), encoded[31]);
    // Check last byte of second value is 2
    try std.testing.expectEqual(@as(u8, 2), encoded[63]);
    // Check last byte of third value is 3
    try std.testing.expectEqual(@as(u8, 3), encoded[95]);
}
```

### encodePacked - bytes32 array

```zig
test "encodePacked - bytes32 array" {
    const allocator = std.testing.allocator;
    const b1 = [_]u8{0xAA} ** 32;
    const b2 = [_]u8{0xBB} ** 32;
    const arr = [_][32]u8{ b1, b2 };
    const values = [_]AbiValue{AbiValue{ .@"bytes32[]" = &arr }};
    const encoded = try encodePacked(allocator, &values);
    defer allocator.free(encoded);

    try std.testing.expectEqual(@as(usize, 64), encoded.len);
    for (encoded[0..32]) |b| {
        try std.testing.expectEqual(@as(u8, 0xAA), b);
    }
    for (encoded[32..64]) |b| {
        try std.testing.expectEqual(@as(u8, 0xBB), b);
    }
}
```

### encodePacked - string array

```zig
test "encodePacked - string array" {
    const allocator = std.testing.allocator;
    const strings = [_][]const u8{ "hello", "world" };
    const values = [_]AbiValue{AbiValue{ .@"string[]" = &strings }};
    const encoded = try encodePacked(allocator, &values);
    defer allocator.free(encoded);

    // "hello" = 5 bytes, "world" = 5 bytes = 10 bytes total
    try std.testing.expectEqual(@as(usize, 10), encoded.len);
    // Check "hello"
    try std.testing.expectEqual(@as(u8, 0x68), encoded[0]); // 'h'
    // Check "world" starts at byte 5
    try std.testing.expectEqual(@as(u8, 0x77), encoded[5]); // 'w'
}
```

### encodePacked - fixed array uint256[2]

```zig
test "encodePacked - fixed array uint256[2]" {
    const allocator = std.testing.allocator;
    const arr = [_]u256{ 1, 2 };
    const values = [_]AbiValue{AbiValue{ .@"uint256[2]" = arr }};
    const encoded = try encodePacked(allocator, &values);
    defer allocator.free(encoded);

    try std.testing.expectEqual(@as(usize, 64), encoded.len);
    try std.testing.expectEqual(@as(u8, 1), encoded[31]);
    try std.testing.expectEqual(@as(u8, 2), encoded[63]);
}
```

### encodePacked - fixed array uint256[3]

```zig
test "encodePacked - fixed array uint256[3]" {
    const allocator = std.testing.allocator;
    const arr = [_]u256{ 1, 2, 3 };
    const values = [_]AbiValue{AbiValue{ .@"uint256[3]" = arr }};
    const encoded = try encodePacked(allocator, &values);
    defer allocator.free(encoded);

    try std.testing.expectEqual(@as(usize, 96), encoded.len);
    try std.testing.expectEqual(@as(u8, 1), encoded[31]);
    try std.testing.expectEqual(@as(u8, 2), encoded[63]);
    try std.testing.expectEqual(@as(u8, 3), encoded[95]);
}
```

### encodePacked - fixed array address[2]

```zig
test "encodePacked - fixed array address[2]" {
    const allocator = std.testing.allocator;
    const addr1 = address.Address{ .bytes = [_]u8{0x11} ** 20 };
    const addr2 = address.Address{ .bytes = [_]u8{0x22} ** 20 };
    const arr = [_]address.Address{ addr1, addr2 };
    const values = [_]AbiValue{AbiValue{ .@"address[2]" = arr }};
    const encoded = try encodePacked(allocator, &values);
    defer allocator.free(encoded);

    try std.testing.expectEqual(@as(usize, 40), encoded.len);
    for (encoded[0..20]) |b| {
        try std.testing.expectEqual(@as(u8, 0x11), b);
    }
    for (encoded[20..40]) |b| {
        try std.testing.expectEqual(@as(u8, 0x22), b);
    }
}
```

### encodePacked - fixed array bool[4]

```zig
test "encodePacked - fixed array bool[4]" {
    const allocator = std.testing.allocator;
    const arr = [_]bool{ true, false, true, false };
    const values = [_]AbiValue{AbiValue{ .@"bool[4]" = arr }};
    const encoded = try encodePacked(allocator, &values);
    defer allocator.free(encoded);

    try std.testing.expectEqual(@as(usize, 4), encoded.len);
    try std.testing.expectEqual(@as(u8, 1), encoded[0]);
    try std.testing.expectEqual(@as(u8, 0), encoded[1]);
    try std.testing.expectEqual(@as(u8, 1), encoded[2]);
    try std.testing.expectEqual(@as(u8, 0), encoded[3]);
}
```

### encodePacked - fixed array bytes4[2]

```zig
test "encodePacked - fixed array bytes4[2]" {
    const allocator = std.testing.allocator;
    const b1 = [_]u8{ 0x12, 0x34, 0x56, 0x78 };
    const b2 = [_]u8{ 0x9A, 0xBC, 0xDE, 0xF0 };
    const arr = [_][4]u8{ b1, b2 };
    const values = [_]AbiValue{AbiValue{ .@"bytes4[2]" = arr }};
    const encoded = try encodePacked(allocator, &values);
    defer allocator.free(encoded);

    try std.testing.expectEqual(@as(usize, 8), encoded.len);
    try std.testing.expectEqual(@as(u8, 0x12), encoded[0]);
    try std.testing.expectEqual(@as(u8, 0x78), encoded[3]);
    try std.testing.expectEqual(@as(u8, 0x9A), encoded[4]);
    try std.testing.expectEqual(@as(u8, 0xF0), encoded[7]);
}
```

### encodePacked - uint8 + address + bool (22 bytes)

```zig
test "encodePacked - uint8 + address + bool (22 bytes)" {
    const allocator = std.testing.allocator;
    const addr = address.Address{ .bytes = [_]u8{0x01} ** 20 };
    const values = [_]AbiValue{
        AbiValue{ .uint8 = 42 },
        AbiValue{ .address = addr },
        AbiValue{ .bool = true },
    };
    const encoded = try encodePacked(allocator, &values);
    defer allocator.free(encoded);

    try std.testing.expectEqual(@as(usize, 22), encoded.len);
    try std.testing.expectEqual(@as(u8, 42), encoded[0]);
    for (encoded[1..21]) |b| {
        try std.testing.expectEqual(@as(u8, 0x01), b);
    }
    try std.testing.expectEqual(@as(u8, 1), encoded[21]);
}
```

### basic ABI encoding

```zig
test "basic ABI encoding" {
    const allocator = std.testing.allocator;

    const values = [_]AbiValue{
        uint256_value(42),
        boolValue(true),
    };

    const encoded = try encodeAbiParameters(allocator, &values);
    defer allocator.free(encoded);

    try std.testing.expectEqual(@as(usize, 64), encoded.len); // 2 * 32 bytes
}
```

### basic ABI decoding

```zig
test "basic ABI decoding" {
    const allocator = std.testing.allocator;

    // Test decoding uint256
    const uint256_data = [_]u8{0} ** 28 ++ [_]u8{ 0x00, 0x00, 0x00, 0x2A }; // 42 in big-endian
    const types = [_]AbiType{.uint256};

    const decoded = try decodeAbiParameters(allocator, &uint256_data, &types);
    defer {
        for (decoded) |value| {
            switch (value) {
                .string, .bytes => |slice| allocator.free(slice),
                else => {},
            }
        }
        allocator.free(decoded);
    }

    try std.testing.expectEqual(@as(usize, 1), decoded.len);
    try std.testing.expectEqual(@as(u256, 42), decoded[0].uint256);
}
```

### function selector computation

```zig
test "function selector computation" {
    const selector = computeSelector("transfer(address,uint256)");

    // This should match the known ERC20 transfer selector
    const expected = [_]u8{ 0xa9, 0x05, 0x9c, 0xbb };
    try std.testing.expectEqualSlices(u8, &expected, &selector);
}
```

### function data encoding

```zig
test "function data encoding" {
    const allocator = std.testing.allocator;

    const selector = computeSelector("transfer(address,uint256)");
    const params = [_]AbiValue{
        addressValue([_]u8{0x12} ** 20),
        uint256_value(1000),
    };

    const encoded = try encodeFunctionData(allocator, selector, &params);
    defer allocator.free(encoded);

    try std.testing.expectEqual(@as(usize, 68), encoded.len); // 4 + 64 bytes
    try std.testing.expectEqualSlices(u8, &selector, encoded[0..4]);
}
```

### packed encoding

```zig
test "packed encoding" {
    const allocator = std.testing.allocator;

    const values = [_]AbiValue{
        AbiValue{ .uint8 = 0x12 },
        AbiValue{ .uint16 = 0x3456 },
        stringValue("test"),
    };

    const packed_data = try encodePacked(allocator, &values);
    defer allocator.free(packed_data);

    try std.testing.expectEqual(@as(usize, 7), packed_data.len); // 1 + 2 + 4 bytes
    try std.testing.expectEqual(@as(u8, 0x12), packed_data[0]);
    try std.testing.expectEqual(@as(u8, 0x34), packed_data[1]);
    try std.testing.expectEqual(@as(u8, 0x56), packed_data[2]);
    try std.testing.expectEqualSlices(u8, "test", packed_data[3..7]);
}
```

### gas estimation

```zig
test "gas estimation" {
    const data = &[_]u8{ 0x00, 0x01, 0x02, 0x00, 0x03 };
    const gas = estimateGasForData(data);

    // 21000 + 4 + 16 + 16 + 4 + 16 = 21056
    try std.testing.expectEqual(@as(u64, 21056), gas);
}
```

### common selectors

```zig
test "common selectors" {
    const transfer_selector = CommonSelectors.ERC20_TRANSFER;
    const expected_transfer = [_]u8{ 0xa9, 0x05, 0x9c, 0xbb };
    try std.testing.expectEqualSlices(u8, &expected_transfer, &transfer_selector);

    const balance_selector = CommonSelectors.ERC20_BALANCE_OF;
    const expected_balance = [_]u8{ 0x70, 0xa0, 0x82, 0x31 };
    try std.testing.expectEqualSlices(u8, &expected_balance, &balance_selector);
}
```

### encode uint256

```zig
test "encode uint256" {
    // Test encoding 69420n (0x10f2c)
    const values = [_]AbiValue{
        uint256_value(69420),
    };

    const encoded = try encodeAbiParameters(std.testing.allocator, &values);
    defer std.testing.allocator.free(encoded);

    try std.testing.expectEqual(@as(usize, 32), encoded.len);

    const expected = [_]u8{0} ** 28 ++ [_]u8{ 0x00, 0x00, 0x10, 0xf2, 0xc };
    try std.testing.expectEqualSlices(u8, &expected, encoded);
}
```

### encode uint8

```zig
test "encode uint8" {
    // Test encoding 32
    const values = [_]AbiValue{
        .{ .uint8 = 32 },
    };

    const encoded = try encodeAbiParameters(std.testing.allocator, &values);
    defer std.testing.allocator.free(encoded);

    try std.testing.expectEqual(@as(usize, 32), encoded.len);

    const expected = [_]u8{0} ** 31 ++ [_]u8{0x20};
    try std.testing.expectEqualSlices(u8, &expected, encoded);
}
```

### encode multiple uint types

```zig
test "encode multiple uint types" {
    const values = [_]AbiValue{
        .{ .uint8 = 255 },
        .{ .uint32 = 69420 },
        uint256_value(0xdeadbeef),
    };

    const encoded = try encodeAbiParameters(std.testing.allocator, &values);
    defer std.testing.allocator.free(encoded);

    try std.testing.expectEqual(@as(usize, 96), encoded.len); // 3 * 32 bytes
}
```

### encode int32 positive

```zig
test "encode int32 positive" {
    const values = [_]AbiValue{
        .{ .int32 = 2147483647 }, // Max int32
    };

    const encoded = try encodeAbiParameters(std.testing.allocator, &values);
    defer std.testing.allocator.free(encoded);

    const expected = [_]u8{0} ** 28 ++ [_]u8{ 0x7f, 0xff, 0xff, 0xff };
    try std.testing.expectEqualSlices(u8, &expected, encoded);
}
```

### encode int32 negative two's complement

```zig
test "encode int32 negative two's complement" {
    const values = [_]AbiValue{
        .{ .int32 = -2147483648 }, // Min int32
    };

    const encoded = try encodeAbiParameters(std.testing.allocator, &values);
    defer std.testing.allocator.free(encoded);

    // Two's complement representation
    const expected = [_]u8{0xff} ** 28 ++ [_]u8{ 0x80, 0x00, 0x00, 0x00 };
    try std.testing.expectEqualSlices(u8, &expected, encoded);
}
```

### encode address

```zig
test "encode address" {
    const addr: address.Address = [_]u8{
        0x14, 0xdC, 0x79, 0x96, 0x4d, 0xa2, 0xC0, 0x8b,
        0x23, 0x69, 0x8B, 0x3D, 0x3c, 0xc7, 0xCa, 0x32,
        0x19, 0x3d, 0x99, 0x55,
    };

    const values = [_]AbiValue{
        addressValue(addr),
    };

    const encoded = try encodeAbiParameters(std.testing.allocator, &values);
    defer std.testing.allocator.free(encoded);

    // Address should be right-padded with zeros
    const expected = [_]u8{0} ** 12 ++ addr;
    try std.testing.expectEqualSlices(u8, &expected, encoded);
}
```

### encode bool

```zig
test "encode bool" {
    // Test true
    {
        const values = [_]AbiValue{
            boolValue(true),
        };

        const encoded = try encodeAbiParameters(std.testing.allocator, &values);
        defer std.testing.allocator.free(encoded);

        const expected = [_]u8{0} ** 31 ++ [_]u8{0x01};
        try std.testing.expectEqualSlices(u8, &expected, encoded);
    }

    // Test false
    {
        const values = [_]AbiValue{
            boolValue(false),
        };

        const encoded = try encodeAbiParameters(std.testing.allocator, &values);
        defer std.testing.allocator.free(encoded);

        const expected = [_]u8{0} ** 32;
        try std.testing.expectEqualSlices(u8, &expected, encoded);
    }
}
```

### decode uint256

```zig
test "decode uint256" {
    const data = [_]u8{0} ** 28 ++ [_]u8{ 0x00, 0x00, 0x10, 0xf2, 0xc };
    const types = [_]AbiType{.uint256};

    const decoded = try decodeAbiParameters(std.testing.allocator, &data, &types);
    defer {
        for (decoded) |value| {
            switch (value) {
                .string, .bytes => |slice| std.testing.allocator.free(slice),
                .@"uint256[]" => |arr| std.testing.allocator.free(arr),
                .@"bytes32[]" => |arr| std.testing.allocator.free(arr),
                .@"address[]" => |arr| std.testing.allocator.free(arr),
                .@"string[]" => |arr| {
                    for (arr) |str| std.testing.allocator.free(str);
                    std.testing.allocator.free(arr);
                },
                else => {},
            }
        }
        std.testing.allocator.free(decoded);
    }

    try std.testing.expectEqual(@as(usize, 1), decoded.len);
    try std.testing.expectEqual(@as(u256, 69420), decoded[0].uint256);
}
```

### decode int32 negative

```zig
test "decode int32 negative" {
    // Two's complement representation of -2147483648
    const data = [_]u8{0xff} ** 28 ++ [_]u8{ 0x80, 0x00, 0x00, 0x00 };
    const types = [_]AbiType{.int32};

    const decoded = try decodeAbiParameters(std.testing.allocator, &data, &types);
    defer std.testing.allocator.free(decoded);

    try std.testing.expectEqual(@as(usize, 1), decoded.len);
    try std.testing.expectEqual(@as(i32, -2147483648), decoded[0].int32);
}
```

### decode address

```zig
test "decode address" {
    const expectedAddr: address.Address = [_]u8{
        0x14, 0xdC, 0x79, 0x96, 0x4d, 0xa2, 0xC0, 0x8b,
        0x23, 0x69, 0x8B, 0x3D, 0x3c, 0xc7, 0xCa, 0x32,
        0x19, 0x3d, 0x99, 0x55,
    };

    const data = [_]u8{0} ** 12 ++ expectedAddr;
    const types = [_]AbiType{.address};

    const decoded = try decodeAbiParameters(std.testing.allocator, &data, &types);
    defer std.testing.allocator.free(decoded);

    try std.testing.expectEqual(@as(usize, 1), decoded.len);
    try std.testing.expectEqualSlices(u8, &expectedAddr, &decoded[0].address);
}
```

### decode bool

```zig
test "decode bool" {
    // Test true
    {
        const data = [_]u8{0} ** 31 ++ [_]u8{0x01};
        const types = [_]AbiType{.bool};

        const decoded = try decodeAbiParameters(std.testing.allocator, &data, &types);
        defer std.testing.allocator.free(decoded);

        try std.testing.expectEqual(@as(usize, 1), decoded.len);
        try std.testing.expectEqual(true, decoded[0].bool);
    }

    // Test false
    {
        const data = [_]u8{0} ** 32;
        const types = [_]AbiType{.bool};

        const decoded = try decodeAbiParameters(std.testing.allocator, &data, &types);
        defer std.testing.allocator.free(decoded);

        try std.testing.expectEqual(@as(usize, 1), decoded.len);
        try std.testing.expectEqual(false, decoded[0].bool);
    }
}
```

### compute selector

```zig
test "compute selector" {
    // Test "transfer(address,uint256)" selector
    const transfer_sig = "transfer(address,uint256)";
    const selector = computeSelector(transfer_sig);

    // This should match the known ERC20 transfer selector
    const expected_selector = [_]u8{ 0xa9, 0x05, 0x9c, 0xbb };
    try std.testing.expectEqualSlices(u8, &expected_selector, &selector);
}
```

### encode function data

```zig
test "encode function data" {
    const selector = computeSelector("transfer(address,uint256)");

    const recipient: address.Address = [_]u8{0x12} ** 20;
    const params = [_]AbiValue{
        addressValue(recipient),
        uint256_value(1000),
    };

    const encoded = try encodeFunctionData(std.testing.allocator, selector, &params);
    defer std.testing.allocator.free(encoded);

    try std.testing.expectEqual(@as(usize, 68), encoded.len); // 4 + 64 bytes
    try std.testing.expectEqualSlices(u8, &selector, encoded[0..4]);
}
```

### decode string

```zig
test "decode string" {
    // Encoded "hello" string
    // offset (32 bytes) + length (32 bytes) + data (32 bytes padded)
    const data = [_]u8{
        // Offset to string data (32)
        0,   0,   0,   0,   0,   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0,   0,   0,   0,   0,   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x20,
        // Length of string (5)
        0,   0,   0,   0,   0,   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0,   0,   0,   0,   0,   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x05,
        // String data "hello" padded to 32 bytes
        'h', 'e', 'l', 'l', 'o', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0,   0,   0,   0,   0,   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    };

    const types = [_]AbiType{.string};

    const decoded = try decodeAbiParameters(std.testing.allocator, &data, &types);
    defer {
        std.testing.allocator.free(decoded[0].string);
        std.testing.allocator.free(decoded);
    }

    try std.testing.expectEqual(@as(usize, 1), decoded.len);
    try std.testing.expectEqualStrings("hello", decoded[0].string);
}
```

### encode packed

```zig
test "encode packed" {
    const values = [_]AbiValue{
        .{ .uint8 = 0x12 },
        .{ .uint16 = 0x3456 },
        stringValue("test"),
    };

    const packed_data = try encodePacked(std.testing.allocator, &values);
    defer std.testing.allocator.free(packed_data);

    try std.testing.expectEqual(@as(usize, 7), packed_data.len); // 1 + 2 + 4 bytes
    try std.testing.expectEqual(@as(u8, 0x12), packed_data[0]);
    try std.testing.expectEqual(@as(u8, 0x34), packed_data[1]);
    try std.testing.expectEqual(@as(u8, 0x56), packed_data[2]);
    try std.testing.expectEqualStrings("test", packed_data[3..7]);
}
```

### gas estimation for data

```zig
test "gas estimation for data" {
    // Test with mix of zero and non-zero bytes
    const data = &[_]u8{ 0x00, 0x01, 0x02, 0x00, 0x03 };
    const gas = estimateGasForData(data);

    // Base cost: 21000
    // Zero bytes (2): 2 * 4 = 8
    // Non-zero bytes (3): 3 * 16 = 48
    // Total: 21000 + 8 + 48 = 21056
    try std.testing.expectEqual(@as(u64, 21056), gas);
}
```

### decode empty parameters

```zig
test "decode empty parameters" {
    const decoded = try decodeAbiParameters(std.testing.allocator, "", &[_]AbiType{});
    defer std.testing.allocator.free(decoded);

    try std.testing.expectEqual(@as(usize, 0), decoded.len);
}
```

### decode with insufficient data

```zig
test "decode with insufficient data" {
    const data = [_]u8{ 0x01, 0x02, 0x03 }; // Only 3 bytes
    const types = [_]AbiType{.uint256}; // Expects 32 bytes

    const result = decodeAbiParameters(std.testing.allocator, &data, &types);
    try std.testing.expectError(AbiError.DataTooSmall, result);
}
```

### encode and decode multiple types

```zig
test "encode and decode multiple types" {
    const addr: address.Address = [_]u8{0xaa} ** 20;
    const originalValues = [_]AbiValue{
        uint256_value(42),
        boolValue(true),
        addressValue(addr),
    };

    const encoded = try encodeAbiParameters(std.testing.allocator, &originalValues);
    defer std.testing.allocator.free(encoded);

    const types = [_]AbiType{ .uint256, .bool, .address };
    const decoded = try decodeAbiParameters(std.testing.allocator, encoded, &types);
    defer std.testing.allocator.free(decoded);

    try std.testing.expectEqual(@as(u256, 42), decoded[0].uint256);
    try std.testing.expectEqual(true, decoded[1].bool);
    try std.testing.expectEqualSlices(u8, &addr, &decoded[2].address);
}
```

### encode_abi_parameters - comprehensive test cases from ox and viem

```zig
test "encode_abi_parameters - comprehensive test cases from ox and viem" {
    const allocator = std.testing.allocator;

    // Test uint256 (value 69420n)
    {
        const values = [_]AbiValue{uint256_value(69420)};
        const encoded = try encodeAbiParameters(allocator, &values);
        defer allocator.free(encoded);

        const expected = "0000000000000000000000000000000000000000000000000000000000010f2c";
        const actual_hex = try std.fmt.allocPrint(allocator, "{}", .{std.fmt.fmtSliceHexLower(encoded)});
        defer allocator.free(actual_hex);

        try std.testing.expectEqualStrings(expected, actual_hex);
    }

    // Test uint8 (value 32)
    {
        const values = [_]AbiValue{AbiValue{ .uint8 = 32 }};
        const encoded = try encodeAbiParameters(allocator, &values);
        defer allocator.free(encoded);

        const expected = "0000000000000000000000000000000000000000000000000000000000000020";
        const actual_hex = try std.fmt.allocPrint(allocator, "{}", .{std.fmt.fmtSliceHexLower(encoded)});
        defer allocator.free(actual_hex);

        try std.testing.expectEqualStrings(expected, actual_hex);
    }

    // Test address
    {
        const addr: address.Address = [_]u8{
            0x14, 0xdC, 0x79, 0x96, 0x4d, 0xa2, 0xC0, 0x8b,
            0x23, 0x69, 0x8B, 0x3D, 0x3c, 0xc7, 0xCa, 0x32,
            0x19, 0x3d, 0x99, 0x55,
        };
        const values = [_]AbiValue{addressValue(addr)};
        const encoded = try encodeAbiParameters(allocator, &values);
        defer allocator.free(encoded);

        const expected = "00000000000000000000000014dc79964da2c08b23698b3d3cc7ca32193d9955";
        const actual_hex = try std.fmt.allocPrint(allocator, "{}", .{std.fmt.fmtSliceHexLower(encoded)});
        defer allocator.free(actual_hex);

        try std.testing.expectEqualStrings(expected, actual_hex);
    }

    // Test bool true
    {
        const values = [_]AbiValue{boolValue(true)};
        const encoded = try encodeAbiParameters(allocator, &values);
        defer allocator.free(encoded);

        const expected = "0000000000000000000000000000000000000000000000000000000000000001";
        const actual_hex = try std.fmt.allocPrint(allocator, "{}", .{std.fmt.fmtSliceHexLower(encoded)});
        defer allocator.free(actual_hex);

        try std.testing.expectEqualStrings(expected, actual_hex);
    }

    // Test bool false
    {
        const values = [_]AbiValue{boolValue(false)};
        const encoded = try encodeAbiParameters(allocator, &values);
        defer allocator.free(encoded);

        const expected = "0000000000000000000000000000000000000000000000000000000000000000";
        const actual_hex = try std.fmt.allocPrint(allocator, "{}", .{std.fmt.fmtSliceHexLower(encoded)});
        defer allocator.free(actual_hex);

        try std.testing.expectEqualStrings(expected, actual_hex);
    }

    // Test int32 positive
    {
        const values = [_]AbiValue{AbiValue{ .int32 = 2147483647 }};
        const encoded = try encodeAbiParameters(allocator, &values);
        defer allocator.free(encoded);

        const expected = "000000000000000000000000000000000000000000000000000000007fffffff";
        const actual_hex = try std.fmt.allocPrint(allocator, "{}", .{std.fmt.fmtSliceHexLower(encoded)});
        defer allocator.free(actual_hex);

        try std.testing.expectEqualStrings(expected, actual_hex);
    }

    // Test int32 negative (two's complement)
    {
        const values = [_]AbiValue{AbiValue{ .int32 = -2147483648 }};
        const encoded = try encodeAbiParameters(allocator, &values);
        defer allocator.free(encoded);

        const expected = "ffffffffffffffffffffffffffffffffffffffffffffffffffffffff80000000";
        const actual_hex = try std.fmt.allocPrint(allocator, "{}", .{std.fmt.fmtSliceHexLower(encoded)});
        defer allocator.free(actual_hex);

        try std.testing.expectEqualStrings(expected, actual_hex);
    }

    // Test multiple static types (uint256, bool, address)
    {
        const addr: address.Address = [_]u8{
            0xc9, 0x61, 0x14, 0x5a, 0x54, 0xC9, 0x6E, 0x3a,
            0xE9, 0xbA, 0xA0, 0x48, 0xc4, 0xF4, 0xD6, 0xb0,
            0x4C, 0x13, 0x91, 0x6b,
        };
        const values = [_]AbiValue{
            uint256_value(420),
            boolValue(true),
            addressValue(addr),
        };
        const encoded = try encodeAbiParameters(allocator, &values);
        defer allocator.free(encoded);

        const expected = "00000000000000000000000000000000000000000000000000000000000001a40000000000000000000000000000000000000000000000000000000000000001000000000000000000000000c961145a54c96e3ae9baa048c4f4d6b04c13916b";
        const actual_hex = try std.fmt.allocPrint(allocator, "{}", .{std.fmt.fmtSliceHexLower(encoded)});
        defer allocator.free(actual_hex);

        try std.testing.expectEqualStrings(expected, actual_hex);
    }

    // Test string encoding
    {
        const values = [_]AbiValue{stringValue("wagmi")};
        const encoded = try encodeAbiParameters(allocator, &values);
        defer allocator.free(encoded);

        const expected = "000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000057761676d69000000000000000000000000000000000000000000000000000000";
        const actual_hex = try std.fmt.allocPrint(allocator, "{}", .{std.fmt.fmtSliceHexLower(encoded)});
        defer allocator.free(actual_hex);

        try std.testing.expectEqualStrings(expected, actual_hex);
    }

    // Test mixed static and dynamic types (string, uint256, bool)
    {
        const values = [_]AbiValue{
            stringValue("wagmi"),
            uint256_value(420),
            boolValue(true),
        };
        const encoded = try encodeAbiParameters(allocator, &values);
        defer allocator.free(encoded);

        const expected = "000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000001a4000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000057761676d69000000000000000000000000000000000000000000000000000000";
        const actual_hex = try std.fmt.allocPrint(allocator, "{}", .{std.fmt.fmtSliceHexLower(encoded)});
        defer allocator.free(actual_hex);

        try std.testing.expectEqualStrings(expected, actual_hex);
    }
}
```

### ABI encode decode round-trip - all uint types

```zig
test "ABI encode decode round-trip - all uint types" {
    const allocator = std.testing.allocator;

    const values = [_]AbiValue{
        .{ .uint8 = 255 },
        .{ .uint16 = 65535 },
        .{ .uint32 = 4294967295 },
        .{ .uint64 = 18446744073709551615 },
    };

    const encoded = try encodeAbiParameters(allocator, &values);
    defer allocator.free(encoded);

    const types = [_]AbiType{ .uint8, .uint16, .uint32, .uint64 };
    const decoded = try decodeAbiParameters(allocator, encoded, &types);
    defer allocator.free(decoded);

    try std.testing.expectEqual(@as(u8, 255), decoded[0].uint8);
    try std.testing.expectEqual(@as(u16, 65535), decoded[1].uint16);
    try std.testing.expectEqual(@as(u32, 4294967295), decoded[2].uint32);
    try std.testing.expectEqual(@as(u64, 18446744073709551615), decoded[3].uint64);
}
```

### ABI encode decode round-trip - all int types

```zig
test "ABI encode decode round-trip - all int types" {
    const allocator = std.testing.allocator;

    const values = [_]AbiValue{
        .{ .int8 = -128 },
        .{ .int16 = -32768 },
        .{ .int32 = -2147483648 },
        .{ .int64 = -9223372036854775808 },
    };

    const encoded = try encodeAbiParameters(allocator, &values);
    defer allocator.free(encoded);

    const types = [_]AbiType{ .int8, .int16, .int32, .int64 };
    const decoded = try decodeAbiParameters(allocator, encoded, &types);
    defer allocator.free(decoded);

    try std.testing.expectEqual(@as(i8, -128), decoded[0].int8);
    try std.testing.expectEqual(@as(i16, -32768), decoded[1].int16);
    try std.testing.expectEqual(@as(i32, -2147483648), decoded[2].int32);
    try std.testing.expectEqual(@as(i64, -9223372036854775808), decoded[3].int64);
}
```

### ABI fixed bytes types encoding

```zig
test "ABI fixed bytes types encoding" {
    const allocator = std.testing.allocator;

    const values = [_]AbiValue{
        .{ .bytes1 = [_]u8{0xaa} },
        .{ .bytes4 = [_]u8{ 0x11, 0x22, 0x33, 0x44 } },
        .{ .bytes32 = [_]u8{0xff} ** 32 },
    };

    const encoded = try encodeAbiParameters(allocator, &values);
    defer allocator.free(encoded);

    try std.testing.expectEqual(@as(usize, 96), encoded.len);
    try std.testing.expectEqual(@as(u8, 0xaa), encoded[0]);
    try std.testing.expectEqual(@as(u8, 0x11), encoded[32]);
    try std.testing.expectEqual(@as(u8, 0xff), encoded[64]);
}
```

### ABI fixed bytes decode round-trip

```zig
test "ABI fixed bytes decode round-trip" {
    const allocator = std.testing.allocator;

    const values = [_]AbiValue{
        .{ .bytes8 = [_]u8{ 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08 } },
        .{ .bytes16 = [_]u8{0xab} ** 16 },
    };

    const encoded = try encodeAbiParameters(allocator, &values);
    defer allocator.free(encoded);

    const types = [_]AbiType{ .bytes8, .bytes16 };
    const decoded = try decodeAbiParameters(allocator, encoded, &types);
    defer allocator.free(decoded);

    try std.testing.expectEqualSlices(u8, &values[0].bytes8, &decoded[0].bytes8);
    try std.testing.expectEqualSlices(u8, &values[1].bytes16, &decoded[1].bytes16);
}
```

### ABI dynamic bytes encoding

```zig
test "ABI dynamic bytes encoding" {
    const allocator = std.testing.allocator;

    const data = [_]u8{ 0xde, 0xad, 0xbe, 0xef };
    const values = [_]AbiValue{
        bytesValue(&data),
    };

    const encoded = try encodeAbiParameters(allocator, &values);
    defer allocator.free(encoded);

    const types = [_]AbiType{.bytes};
    const decoded = try decodeAbiParameters(allocator, encoded, &types);
    defer {
        allocator.free(decoded[0].bytes);
        allocator.free(decoded);
    }

    try std.testing.expectEqualSlices(u8, &data, decoded[0].bytes);
}
```

### ABI large dynamic bytes

```zig
test "ABI large dynamic bytes" {
    const allocator = std.testing.allocator;

    const large_data = [_]u8{0xaa} ** 1000;
    const values = [_]AbiValue{
        bytesValue(&large_data),
    };

    const encoded = try encodeAbiParameters(allocator, &values);
    defer allocator.free(encoded);

    const types = [_]AbiType{.bytes};
    const decoded = try decodeAbiParameters(allocator, encoded, &types);
    defer {
        allocator.free(decoded[0].bytes);
        allocator.free(decoded);
    }

    try std.testing.expectEqual(@as(usize, 1000), decoded[0].bytes.len);
    try std.testing.expectEqualSlices(u8, &large_data, decoded[0].bytes);
}
```

### ABI uint256 array encoding

```zig
test "ABI uint256 array encoding" {
    const allocator = std.testing.allocator;

    const arr = [_]u256{ 1, 2, 3, 4, 5 };
    const values = [_]AbiValue{
        .{ .@"uint256[]" = &arr },
    };

    const encoded = try encodeAbiParameters(allocator, &values);
    defer allocator.free(encoded);

    const types = [_]AbiType{.@"uint256[]"};
    const decoded = try decodeAbiParameters(allocator, encoded, &types);
    defer {
        allocator.free(decoded[0].@"uint256[]");
        allocator.free(decoded);
    }

    try std.testing.expectEqual(@as(usize, 5), decoded[0].@"uint256[]".len);
    for (arr, 0..) |val, i| {
        try std.testing.expectEqual(val, decoded[0].@"uint256[]"[i]);
    }
}
```

### ABI bytes32 array encoding

```zig
test "ABI bytes32 array encoding" {
    const allocator = std.testing.allocator;

    const arr = [_][32]u8{
        [_]u8{0xaa} ** 32,
        [_]u8{0xbb} ** 32,
        [_]u8{0xcc} ** 32,
    };
    const values = [_]AbiValue{
        .{ .@"bytes32[]" = &arr },
    };

    const encoded = try encodeAbiParameters(allocator, &values);
    defer allocator.free(encoded);

    const types = [_]AbiType{.@"bytes32[]"};
    const decoded = try decodeAbiParameters(allocator, encoded, &types);
    defer {
        allocator.free(decoded[0].@"bytes32[]");
        allocator.free(decoded);
    }

    try std.testing.expectEqual(@as(usize, 3), decoded[0].@"bytes32[]".len);
    for (arr, 0..) |val, i| {
        try std.testing.expectEqualSlices(u8, &val, &decoded[0].@"bytes32[]"[i]);
    }
}
```

### ABI address array encoding

```zig
test "ABI address array encoding" {
    const allocator = std.testing.allocator;

    const addr1: address.Address = [_]u8{0x11} ** 20;
    const addr2: address.Address = [_]u8{0x22} ** 20;
    const arr = [_]address.Address{ addr1, addr2 };
    const values = [_]AbiValue{
        .{ .@"address[]" = &arr },
    };

    const encoded = try encodeAbiParameters(allocator, &values);
    defer allocator.free(encoded);

    const types = [_]AbiType{.@"address[]"};
    const decoded = try decodeAbiParameters(allocator, encoded, &types);
    defer {
        allocator.free(decoded[0].@"address[]");
        allocator.free(decoded);
    }

    try std.testing.expectEqual(@as(usize, 2), decoded[0].@"address[]".len);
    try std.testing.expectEqualSlices(u8, &addr1, &decoded[0].@"address[]"[0]);
    try std.testing.expectEqualSlices(u8, &addr2, &decoded[0].@"address[]"[1]);
}
```

### ABI string array encoding

```zig
test "ABI string array encoding" {
    const allocator = std.testing.allocator;

    const strings = [_][]const u8{ "hello", "world", "test" };
    const values = [_]AbiValue{
        .{ .@"string[]" = &strings },
    };

    const encoded = try encodeAbiParameters(allocator, &values);
    defer allocator.free(encoded);

    const types = [_]AbiType{.@"string[]"};
    const decoded = try decodeAbiParameters(allocator, encoded, &types);
    defer {
        for (decoded[0].@"string[]") |str| {
            allocator.free(str);
        }
        allocator.free(decoded[0].@"string[]");
        allocator.free(decoded);
    }

    try std.testing.expectEqual(@as(usize, 3), decoded[0].@"string[]".len);
    try std.testing.expectEqualStrings("hello", decoded[0].@"string[]"[0]);
    try std.testing.expectEqualStrings("world", decoded[0].@"string[]"[1]);
    try std.testing.expectEqualStrings("test", decoded[0].@"string[]"[2]);
}
```

### ABI empty arrays

```zig
test "ABI empty arrays" {
    const allocator = std.testing.allocator;

    const empty_arr = [_]u256{};
    const values = [_]AbiValue{
        .{ .@"uint256[]" = &empty_arr },
    };

    const encoded = try encodeAbiParameters(allocator, &values);
    defer allocator.free(encoded);

    const types = [_]AbiType{.@"uint256[]"};
    const decoded = try decodeAbiParameters(allocator, encoded, &types);
    defer {
        allocator.free(decoded[0].@"uint256[]");
        allocator.free(decoded);
    }

    try std.testing.expectEqual(@as(usize, 0), decoded[0].@"uint256[]".len);
}
```

### ABI malformed input - truncated data

```zig
test "ABI malformed input - truncated data" {
    const allocator = std.testing.allocator;

    const truncated = [_]u8{ 0x00, 0x00, 0x00, 0x00, 0x00 };
    const types = [_]AbiType{.uint256};

    const result = decodeAbiParameters(allocator, &truncated, &types);
    try std.testing.expectError(AbiError.DataTooSmall, result);
}
```

### ABI malformed input - invalid offset beyond bounds

```zig
test "ABI malformed input - invalid offset beyond bounds" {
    const allocator = std.testing.allocator;

    var data: [64]u8 = undefined;
    @memset(&data, 0);
    std.mem.writeInt(u64, data[24..32], 1000, .big);

    const types = [_]AbiType{.string};
    const result = decodeAbiParameters(allocator, &data, &types);
    try std.testing.expectError(AbiError.OutOfBounds, result);
}
```

### ABI invalid UTF-8 in string

```zig
test "ABI invalid UTF-8 in string" {
    const allocator = std.testing.allocator;

    var data: [96]u8 = undefined;
    @memset(&data, 0);
    std.mem.writeInt(u64, data[24..32], 32, .big);
    std.mem.writeInt(u64, data[56..64], 5, .big);
    data[64] = 0xff;
    data[65] = 0xff;
    data[66] = 0xff;
    data[67] = 0xff;
    data[68] = 0xff;

    const types = [_]AbiType{.string};
    const result = decodeAbiParameters(allocator, &data, &types);
    try std.testing.expectError(AbiError.InvalidUtf8, result);
}
```

### ABI complex mixed encoding - multiple dynamic types

```zig
test "ABI complex mixed encoding - multiple dynamic types" {
    const allocator = std.testing.allocator;

    const arr = [_]u256{ 100, 200, 300 };
    const values = [_]AbiValue{
        uint256_value(42),
        stringValue("test"),
        .{ .@"uint256[]" = &arr },
        boolValue(true),
    };

    const encoded = try encodeAbiParameters(allocator, &values);
    defer allocator.free(encoded);

    const types = [_]AbiType{ .uint256, .string, .@"uint256[]", .bool };
    const decoded = try decodeAbiParameters(allocator, encoded, &types);
    defer {
        allocator.free(decoded[1].string);
        allocator.free(decoded[2].@"uint256[]");
        allocator.free(decoded);
    }

    try std.testing.expectEqual(@as(u256, 42), decoded[0].uint256);
    try std.testing.expectEqualStrings("test", decoded[1].string);
    try std.testing.expectEqual(@as(usize, 3), decoded[2].@"uint256[]".len);
    try std.testing.expectEqual(true, decoded[3].bool);
}
```

### ABI decode function data with no parameters

```zig
test "ABI decode function data with no parameters" {
    const allocator = std.testing.allocator;

    const selector = [_]u8{ 0x12, 0x34, 0x56, 0x78 };
    const result = try decodeFunctionData(allocator, &selector, &[_]AbiType{});
    defer allocator.free(result.parameters);

    try std.testing.expectEqualSlices(u8, &selector, &result.selector);
    try std.testing.expectEqual(@as(usize, 0), result.parameters.len);
}
```

### ABI encode event topics with indexed values

```zig
test "ABI encode event topics with indexed values" {
    const allocator = std.testing.allocator;

    const addr: address.Address = [_]u8{0xaa} ** 20;
    const indexed = [_]AbiValue{
        addressValue(addr),
        uint256_value(1000),
    };

    const topics = try encodeEventTopics(allocator, "Transfer(address,address,uint256)", &indexed);
    defer {
        for (topics) |topic| {
            allocator.free(topic);
        }
        allocator.free(topics);
    }

    try std.testing.expectEqual(@as(usize, 3), topics.len);
    try std.testing.expectEqual(@as(usize, 32), topics[0].len);
    try std.testing.expectEqual(@as(usize, 32), topics[1].len);
}
```

### ABI zero values encoding

```zig
test "ABI zero values encoding" {
    const allocator = std.testing.allocator;

    const values = [_]AbiValue{
        .{ .uint8 = 0 },
        .{ .uint256 = 0 },
        boolValue(false),
    };

    const encoded = try encodeAbiParameters(allocator, &values);
    defer allocator.free(encoded);

    const expected_zeros = [_]u8{0} ** 96;
    try std.testing.expectEqualSlices(u8, &expected_zeros, encoded);
}
```

### ABI maximum values encoding

```zig
test "ABI maximum values encoding" {
    const allocator = std.testing.allocator;

    const values = [_]AbiValue{
        .{ .uint8 = 255 },
        .{ .uint16 = 65535 },
        .{ .uint32 = 4294967295 },
        .{ .uint64 = 18446744073709551615 },
        .{ .uint128 = 340282366920938463463374607431768211455 },
    };

    const encoded = try encodeAbiParameters(allocator, &values);
    defer allocator.free(encoded);

    try std.testing.expectEqual(@as(usize, 160), encoded.len);
}
```

### ABI large array encoding - 1000 elements

```zig
test "ABI large array encoding - 1000 elements" {
    const allocator = std.testing.allocator;

    const arr = try allocator.alloc(u256, 1000);
    defer allocator.free(arr);

    for (arr, 0..) |*val, i| {
        val.* = i;
    }

    const values = [_]AbiValue{
        .{ .@"uint256[]" = arr },
    };

    const encoded = try encodeAbiParameters(allocator, &values);
    defer allocator.free(encoded);

    const types = [_]AbiType{.@"uint256[]"};
    const decoded = try decodeAbiParameters(allocator, encoded, &types);
    defer {
        allocator.free(decoded[0].@"uint256[]");
        allocator.free(decoded);
    }

    try std.testing.expectEqual(@as(usize, 1000), decoded[0].@"uint256[]".len);
    for (arr, 0..) |val, i| {
        try std.testing.expectEqual(val, decoded[0].@"uint256[]"[i]);
    }
}
```

### ABI cursor bounds checking

```zig
test "ABI cursor bounds checking" {
    var cursor = Cursor.init(&[_]u8{ 1, 2, 3 });
    const result = cursor.readBytes(10);
    try std.testing.expectError(AbiError.OutOfBounds, result);
}
```

### ABI cursor position manipulation

```zig
test "ABI cursor position manipulation" {
    const data = [_]u8{ 1, 2, 3, 4, 5 };
    var cursor = Cursor.init(&data);

    cursor.setPosition(2);
    const bytes = try cursor.readBytes(2);
    try std.testing.expectEqual(@as(u8, 3), bytes[0]);
    try std.testing.expectEqual(@as(u8, 4), bytes[1]);
}
```

### ABI createFunctionSignature

```zig
test "ABI createFunctionSignature" {
    const allocator = std.testing.allocator;

    const types = [_]AbiType{ .address, .uint256 };
    const signature = try createFunctionSignature(allocator, "transfer", &types);
    defer allocator.free(signature);

    try std.testing.expectEqualStrings("transfer(address,uint256)", signature);
}
```

### ABI dynamic array - empty uint256 array

```zig
test "ABI dynamic array - empty uint256 array" {
    const allocator = std.testing.allocator;

    const empty_arr = [_]u256{};
    const values = [_]AbiValue{
        .{ .@"uint256[]" = &empty_arr },
    };

    const encoded = try encodeAbiParameters(allocator, &values);
    defer allocator.free(encoded);

    const types = [_]AbiType{.@"uint256[]"};
    const decoded = try decodeAbiParameters(allocator, encoded, &types);
    defer {
        allocator.free(decoded[0].@"uint256[]");
        allocator.free(decoded);
    }

    try std.testing.expectEqual(@as(usize, 0), decoded[0].@"uint256[]".len);
}
```

### ABI dynamic array - single element uint256 array

```zig
test "ABI dynamic array - single element uint256 array" {
    const allocator = std.testing.allocator;

    const arr = [_]u256{42};
    const values = [_]AbiValue{
        .{ .@"uint256[]" = &arr },
    };

    const encoded = try encodeAbiParameters(allocator, &values);
    defer allocator.free(encoded);

    const types = [_]AbiType{.@"uint256[]"};
    const decoded = try decodeAbiParameters(allocator, encoded, &types);
    defer {
        allocator.free(decoded[0].@"uint256[]");
        allocator.free(decoded);
    }

    try std.testing.expectEqual(@as(usize, 1), decoded[0].@"uint256[]".len);
    try std.testing.expectEqual(@as(u256, 42), decoded[0].@"uint256[]"[0]);
}
```

### ABI dynamic array - multiple elements address array

```zig
test "ABI dynamic array - multiple elements address array" {
    const allocator = std.testing.allocator;

    const addr1: address.Address = [_]u8{0x11} ** 20;
    const addr2: address.Address = [_]u8{0x22} ** 20;
    const addr3: address.Address = [_]u8{0x33} ** 20;
    const arr = [_]address.Address{ addr1, addr2, addr3 };
    const values = [_]AbiValue{
        .{ .@"address[]" = &arr },
    };

    const encoded = try encodeAbiParameters(allocator, &values);
    defer allocator.free(encoded);

    const types = [_]AbiType{.@"address[]"};
    const decoded = try decodeAbiParameters(allocator, encoded, &types);
    defer {
        allocator.free(decoded[0].@"address[]");
        allocator.free(decoded);
    }

    try std.testing.expectEqual(@as(usize, 3), decoded[0].@"address[]".len);
    try std.testing.expectEqualSlices(u8, &addr1, &decoded[0].@"address[]"[0]);
    try std.testing.expectEqualSlices(u8, &addr2, &decoded[0].@"address[]"[1]);
    try std.testing.expectEqualSlices(u8, &addr3, &decoded[0].@"address[]"[2]);
}
```

### ABI dynamic array - empty string array

```zig
test "ABI dynamic array - empty string array" {
    const allocator = std.testing.allocator;

    const empty_arr = [_][]const u8{};
    const values = [_]AbiValue{
        .{ .@"string[]" = &empty_arr },
    };

    const encoded = try encodeAbiParameters(allocator, &values);
    defer allocator.free(encoded);

    const types = [_]AbiType{.@"string[]"};
    const decoded = try decodeAbiParameters(allocator, encoded, &types);
    defer {
        for (decoded[0].@"string[]") |str| {
            allocator.free(str);
        }
        allocator.free(decoded[0].@"string[]");
        allocator.free(decoded);
    }

    try std.testing.expectEqual(@as(usize, 0), decoded[0].@"string[]".len);
}
```

### ABI dynamic array - string array with empty strings

```zig
test "ABI dynamic array - string array with empty strings" {
    const allocator = std.testing.allocator;

    const strings = [_][]const u8{ "", "test", "" };
    const values = [_]AbiValue{
        .{ .@"string[]" = &strings },
    };

    const encoded = try encodeAbiParameters(allocator, &values);
    defer allocator.free(encoded);

    const types = [_]AbiType{.@"string[]"};
    const decoded = try decodeAbiParameters(allocator, encoded, &types);
    defer {
        for (decoded[0].@"string[]") |str| {
            allocator.free(str);
        }
        allocator.free(decoded[0].@"string[]");
        allocator.free(decoded);
    }

    try std.testing.expectEqual(@as(usize, 3), decoded[0].@"string[]".len);
    try std.testing.expectEqualStrings("", decoded[0].@"string[]"[0]);
    try std.testing.expectEqualStrings("test", decoded[0].@"string[]"[1]);
    try std.testing.expectEqualStrings("", decoded[0].@"string[]"[2]);
}
```

### ABI dynamic array - very large uint256 array (10000 elements)

```zig
test "ABI dynamic array - very large uint256 array (10000 elements)" {
    const allocator = std.testing.allocator;

    const arr = try allocator.alloc(u256, 10000);
    defer allocator.free(arr);

    for (arr, 0..) |*val, i| {
        val.* = i * 123456789;
    }

    const values = [_]AbiValue{
        .{ .@"uint256[]" = arr },
    };

    const encoded = try encodeAbiParameters(allocator, &values);
    defer allocator.free(encoded);

    const types = [_]AbiType{.@"uint256[]"};
    const decoded = try decodeAbiParameters(allocator, encoded, &types);
    defer {
        allocator.free(decoded[0].@"uint256[]");
        allocator.free(decoded);
    }

    try std.testing.expectEqual(@as(usize, 10000), decoded[0].@"uint256[]".len);
    for (arr, 0..) |val, i| {
        try std.testing.expectEqual(val, decoded[0].@"uint256[]"[i]);
    }
}
```

### ABI dynamic array - bytes32 array with all zeros

```zig
test "ABI dynamic array - bytes32 array with all zeros" {
    const allocator = std.testing.allocator;

    const arr = [_][32]u8{
        [_]u8{0} ** 32,
        [_]u8{0} ** 32,
        [_]u8{0} ** 32,
    };
    const values = [_]AbiValue{
        .{ .@"bytes32[]" = &arr },
    };

    const encoded = try encodeAbiParameters(allocator, &values);
    defer allocator.free(encoded);

    const types = [_]AbiType{.@"bytes32[]"};
    const decoded = try decodeAbiParameters(allocator, encoded, &types);
    defer {
        allocator.free(decoded[0].@"bytes32[]");
        allocator.free(decoded);
    }

    try std.testing.expectEqual(@as(usize, 3), decoded[0].@"bytes32[]".len);
    for (decoded[0].@"bytes32[]") |val| {
        try std.testing.expectEqualSlices(u8, &([_]u8{0} ** 32), &val);
    }
}
```

### ABI dynamic array - mixed static and dynamic array encoding

```zig
test "ABI dynamic array - mixed static and dynamic array encoding" {
    const allocator = std.testing.allocator;

    const uint_arr = [_]u256{ 1, 2, 3 };
    const string_arr = [_][]const u8{ "hello", "world" };
    const values = [_]AbiValue{
        uint256_value(99),
        .{ .@"uint256[]" = &uint_arr },
        stringValue("middle"),
        .{ .@"string[]" = &string_arr },
        boolValue(true),
    };

    const encoded = try encodeAbiParameters(allocator, &values);
    defer allocator.free(encoded);

    const types = [_]AbiType{ .uint256, .@"uint256[]", .string, .@"string[]", .bool };
    const decoded = try decodeAbiParameters(allocator, encoded, &types);
    defer {
        allocator.free(decoded[1].@"uint256[]");
        allocator.free(decoded[2].string);
        for (decoded[3].@"string[]") |str| {
            allocator.free(str);
        }
        allocator.free(decoded[3].@"string[]");
        allocator.free(decoded);
    }

    try std.testing.expectEqual(@as(u256, 99), decoded[0].uint256);
    try std.testing.expectEqual(@as(usize, 3), decoded[1].@"uint256[]".len);
    try std.testing.expectEqualStrings("middle", decoded[2].string);
    try std.testing.expectEqual(@as(usize, 2), decoded[3].@"string[]".len);
    try std.testing.expectEqual(true, decoded[4].bool);
}
```

### ABI dynamic array - address array with zero addresses

```zig
test "ABI dynamic array - address array with zero addresses" {
    const allocator = std.testing.allocator;

    const zero_addr: address.Address = [_]u8{0} ** 20;
    const arr = [_]address.Address{zero_addr} ** 5;
    const values = [_]AbiValue{
        .{ .@"address[]" = &arr },
    };

    const encoded = try encodeAbiParameters(allocator, &values);
    defer allocator.free(encoded);

    const types = [_]AbiType{.@"address[]"};
    const decoded = try decodeAbiParameters(allocator, encoded, &types);
    defer {
        allocator.free(decoded[0].@"address[]");
        allocator.free(decoded);
    }

    try std.testing.expectEqual(@as(usize, 5), decoded[0].@"address[]".len);
    for (decoded[0].@"address[]") |addr| {
        try std.testing.expectEqualSlices(u8, &zero_addr, &addr);
    }
}
```

### ABI dynamic array - string array with long strings (>32 bytes each)

```zig
test "ABI dynamic array - string array with long strings (>32 bytes each)" {
    const allocator = std.testing.allocator;

    const long_str1 = "This is a very long string that exceeds thirty-two bytes in length";
    const long_str2 = "Another extraordinarily lengthy string for comprehensive testing purposes";
    const strings = [_][]const u8{ long_str1, long_str2 };
    const values = [_]AbiValue{
        .{ .@"string[]" = &strings },
    };

    const encoded = try encodeAbiParameters(allocator, &values);
    defer allocator.free(encoded);

    const types = [_]AbiType{.@"string[]"};
    const decoded = try decodeAbiParameters(allocator, encoded, &types);
    defer {
        for (decoded[0].@"string[]") |str| {
            allocator.free(str);
        }
        allocator.free(decoded[0].@"string[]");
        allocator.free(decoded);
    }

    try std.testing.expectEqual(@as(usize, 2), decoded[0].@"string[]".len);
    try std.testing.expectEqualStrings(long_str1, decoded[0].@"string[]"[0]);
    try std.testing.expectEqualStrings(long_str2, decoded[0].@"string[]"[1]);
}
```

### ABI boundary - uint8 minimum value (0)

```zig
test "ABI boundary - uint8 minimum value (0)" {
    const allocator = std.testing.allocator;

    const values = [_]AbiValue{
        .{ .uint8 = 0 },
    };

    const encoded = try encodeAbiParameters(allocator, &values);
    defer allocator.free(encoded);

    const types = [_]AbiType{.uint8};
    const decoded = try decodeAbiParameters(allocator, encoded, &types);
    defer allocator.free(decoded);

    try std.testing.expectEqual(@as(u8, 0), decoded[0].uint8);
}
```

### ABI boundary - uint8 maximum value (255)

```zig
test "ABI boundary - uint8 maximum value (255)" {
    const allocator = std.testing.allocator;

    const values = [_]AbiValue{
        .{ .uint8 = 255 },
    };

    const encoded = try encodeAbiParameters(allocator, &values);
    defer allocator.free(encoded);

    const types = [_]AbiType{.uint8};
    const decoded = try decodeAbiParameters(allocator, encoded, &types);
    defer allocator.free(decoded);

    try std.testing.expectEqual(@as(u8, 255), decoded[0].uint8);
}
```

### ABI boundary - uint256 minimum value (0)

```zig
test "ABI boundary - uint256 minimum value (0)" {
    const allocator = std.testing.allocator;

    const values = [_]AbiValue{
        uint256_value(0),
    };

    const encoded = try encodeAbiParameters(allocator, &values);
    defer allocator.free(encoded);

    const types = [_]AbiType{.uint256};
    const decoded = try decodeAbiParameters(allocator, encoded, &types);
    defer allocator.free(decoded);

    try std.testing.expectEqual(@as(u256, 0), decoded[0].uint256);
}
```

### ABI boundary - uint256 maximum value (2^256-1)

```zig
test "ABI boundary - uint256 maximum value (2^256-1)" {
    const allocator = std.testing.allocator;

    const max_u256: u256 = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;
    const values = [_]AbiValue{
        uint256_value(max_u256),
    };

    const encoded = try encodeAbiParameters(allocator, &values);
    defer allocator.free(encoded);

    const types = [_]AbiType{.uint256};
    const decoded = try decodeAbiParameters(allocator, encoded, &types);
    defer allocator.free(decoded);

    try std.testing.expectEqual(max_u256, decoded[0].uint256);
}
```

### ABI boundary - int8 minimum value (-128)

```zig
test "ABI boundary - int8 minimum value (-128)" {
    const allocator = std.testing.allocator;

    const values = [_]AbiValue{
        .{ .int8 = -128 },
    };

    const encoded = try encodeAbiParameters(allocator, &values);
    defer allocator.free(encoded);

    const types = [_]AbiType{.int8};
    const decoded = try decodeAbiParameters(allocator, encoded, &types);
    defer allocator.free(decoded);

    try std.testing.expectEqual(@as(i8, -128), decoded[0].int8);
}
```

### ABI boundary - int8 maximum value (127)

```zig
test "ABI boundary - int8 maximum value (127)" {
    const allocator = std.testing.allocator;

    const values = [_]AbiValue{
        .{ .int8 = 127 },
    };

    const encoded = try encodeAbiParameters(allocator, &values);
    defer allocator.free(encoded);

    const types = [_]AbiType{.int8};
    const decoded = try decodeAbiParameters(allocator, encoded, &types);
    defer allocator.free(decoded);

    try std.testing.expectEqual(@as(i8, 127), decoded[0].int8);
}
```

### ABI boundary - int128 minimum value

```zig
test "ABI boundary - int128 minimum value" {
    const allocator = std.testing.allocator;

    const min_i128: i128 = -170141183460469231731687303715884105728;
    const values = [_]AbiValue{
        .{ .int128 = min_i128 },
    };

    const encoded = try encodeAbiParameters(allocator, &values);
    defer allocator.free(encoded);

    const types = [_]AbiType{.int128};
    const decoded = try decodeAbiParameters(allocator, encoded, &types);
    defer allocator.free(decoded);

    try std.testing.expectEqual(min_i128, decoded[0].int128);
}
```

### ABI boundary - int128 maximum value

```zig
test "ABI boundary - int128 maximum value" {
    const allocator = std.testing.allocator;

    const max_i128: i128 = 170141183460469231731687303715884105727;
    const values = [_]AbiValue{
        .{ .int128 = max_i128 },
    };

    const encoded = try encodeAbiParameters(allocator, &values);
    defer allocator.free(encoded);

    const types = [_]AbiType{.int128};
    const decoded = try decodeAbiParameters(allocator, encoded, &types);
    defer allocator.free(decoded);

    try std.testing.expectEqual(max_i128, decoded[0].int128);
}
```

### ABI boundary - address zero (0x0000...0000)

```zig
test "ABI boundary - address zero (0x0000...0000)" {
    const allocator = std.testing.allocator;

    const zero_addr: address.Address = [_]u8{0} ** 20;
    const values = [_]AbiValue{
        addressValue(zero_addr),
    };

    const encoded = try encodeAbiParameters(allocator, &values);
    defer allocator.free(encoded);

    const types = [_]AbiType{.address};
    const decoded = try decodeAbiParameters(allocator, encoded, &types);
    defer allocator.free(decoded);

    try std.testing.expectEqualSlices(u8, &zero_addr, &decoded[0].address);
}
```

### ABI boundary - address maximum (0xFFFF...FFFF)

```zig
test "ABI boundary - address maximum (0xFFFF...FFFF)" {
    const allocator = std.testing.allocator;

    const max_addr: address.Address = [_]u8{0xFF} ** 20;
    const values = [_]AbiValue{
        addressValue(max_addr),
    };

    const encoded = try encodeAbiParameters(allocator, &values);
    defer allocator.free(encoded);

    const types = [_]AbiType{.address};
    const decoded = try decodeAbiParameters(allocator, encoded, &types);
    defer allocator.free(decoded);

    try std.testing.expectEqualSlices(u8, &max_addr, &decoded[0].address);
}
```

### ABI boundary - bytes1 vs bytes32 comparison

```zig
test "ABI boundary - bytes1 vs bytes32 comparison" {
    const allocator = std.testing.allocator;

    const values = [_]AbiValue{
        .{ .bytes1 = [_]u8{0xAA} },
        .{ .bytes32 = [_]u8{0xBB} ** 32 },
    };

    const encoded = try encodeAbiParameters(allocator, &values);
    defer allocator.free(encoded);

    const types = [_]AbiType{ .bytes1, .bytes32 };
    const decoded = try decodeAbiParameters(allocator, encoded, &types);
    defer allocator.free(decoded);

    try std.testing.expectEqual(@as(u8, 0xAA), decoded[0].bytes1[0]);
    for (decoded[1].bytes32) |byte| {
        try std.testing.expectEqual(@as(u8, 0xBB), byte);
    }
}
```

### ABI boundary - empty string vs long string (>1000 bytes)

```zig
test "ABI boundary - empty string vs long string (>1000 bytes)" {
    const allocator = std.testing.allocator;

    const long_str = "a" ** 1500;
    const values = [_]AbiValue{
        stringValue(""),
        stringValue(long_str),
    };

    const encoded = try encodeAbiParameters(allocator, &values);
    defer allocator.free(encoded);

    const types = [_]AbiType{ .string, .string };
    const decoded = try decodeAbiParameters(allocator, encoded, &types);
    defer {
        allocator.free(decoded[0].string);
        allocator.free(decoded[1].string);
        allocator.free(decoded);
    }

    try std.testing.expectEqualStrings("", decoded[0].string);
    try std.testing.expectEqualStrings(long_str, decoded[1].string);
    try std.testing.expectEqual(@as(usize, 1500), decoded[1].string.len);
}
```

### ABI boundary - empty bytes vs maximum bytes

```zig
test "ABI boundary - empty bytes vs maximum bytes" {
    const allocator = std.testing.allocator;

    const empty_bytes = [_]u8{};
    const large_bytes = [_]u8{0xCD} ** 5000;
    const values = [_]AbiValue{
        bytesValue(&empty_bytes),
        bytesValue(&large_bytes),
    };

    const encoded = try encodeAbiParameters(allocator, &values);
    defer allocator.free(encoded);

    const types = [_]AbiType{ .bytes, .bytes };
    const decoded = try decodeAbiParameters(allocator, encoded, &types);
    defer {
        allocator.free(decoded[0].bytes);
        allocator.free(decoded[1].bytes);
        allocator.free(decoded);
    }

    try std.testing.expectEqual(@as(usize, 0), decoded[0].bytes.len);
    try std.testing.expectEqual(@as(usize, 5000), decoded[1].bytes.len);
    try std.testing.expectEqualSlices(u8, &large_bytes, decoded[1].bytes);
}
```

### ABI selector - ERC20 transfer selector accuracy

```zig
test "ABI selector - ERC20 transfer selector accuracy" {
    const selector = computeSelector("transfer(address,uint256)");
    const expected = [_]u8{ 0xa9, 0x05, 0x9c, 0xbb };
    try std.testing.expectEqualSlices(u8, &expected, &selector);
}
```

### ABI selector - ERC20 approve selector accuracy

```zig
test "ABI selector - ERC20 approve selector accuracy" {
    const selector = computeSelector("approve(address,uint256)");
    const expected = [_]u8{ 0x09, 0x5e, 0xa7, 0xb3 };
    try std.testing.expectEqualSlices(u8, &expected, &selector);
}
```

### ABI selector - ERC20 balanceOf selector accuracy

```zig
test "ABI selector - ERC20 balanceOf selector accuracy" {
    const selector = computeSelector("balanceOf(address)");
    const expected = [_]u8{ 0x70, 0xa0, 0x82, 0x31 };
    try std.testing.expectEqualSlices(u8, &expected, &selector);
}
```

### ABI selector - complex function signature parsing

```zig
test "ABI selector - complex function signature parsing" {
    const allocator = std.testing.allocator;

    const types = [_]AbiType{ .uint256, .address, .bool, .bytes32 };
    const signature = try createFunctionSignature(allocator, "complexFunction", &types);
    defer allocator.free(signature);

    try std.testing.expectEqualStrings("complexFunction(uint256,address,bool,bytes32)", signature);

    const selector = computeSelector(signature);
    try std.testing.expectEqual(@as(usize, 4), selector.len);
}
```

### ABI selector - function data encoding with selector

```zig
test "ABI selector - function data encoding with selector" {
    const allocator = std.testing.allocator;

    const selector = computeSelector("setValue(uint256)");
    const params = [_]AbiValue{
        uint256_value(12345),
    };

    const encoded = try encodeFunctionData(allocator, selector, &params);
    defer allocator.free(encoded);

    try std.testing.expectEqual(@as(usize, 36), encoded.len);
    try std.testing.expectEqualSlices(u8, &selector, encoded[0..4]);
}
```

### ABI selector - decoding function data with selector

```zig
test "ABI selector - decoding function data with selector" {
    const allocator = std.testing.allocator;

    const selector = computeSelector("getValue()");
    const params = [_]AbiValue{};

    const encoded = try encodeFunctionData(allocator, selector, &params);
    defer allocator.free(encoded);

    const result = try decodeFunctionData(allocator, encoded, &[_]AbiType{});
    defer allocator.free(result.parameters);

    try std.testing.expectEqualSlices(u8, &selector, &result.selector);
    try std.testing.expectEqual(@as(usize, 0), result.parameters.len);
}
```

### ABI selector - function definition get_selector

```zig
test "ABI selector - function definition get_selector" {
    const allocator = std.testing.allocator;

    const func_def = CommonPatterns.erc20_transfer();
    const selector = try func_def.get_selector(allocator);

    const expected = CommonSelectors.ERC20_TRANSFER;
    try std.testing.expectEqualSlices(u8, &expected, &selector);
}
```

### ABI selector - multiple selectors uniqueness

```zig
test "ABI selector - multiple selectors uniqueness" {
    const sel1 = computeSelector("func1(uint256)");
    const sel2 = computeSelector("func2(uint256)");
    const sel3 = computeSelector("func1(address)");

    const same_as_sel1 = computeSelector("func1(uint256)");
    try std.testing.expectEqualSlices(u8, &sel1, &same_as_sel1);

    const equal_sel1_sel2 = std.mem.eql(u8, &sel1, &sel2);
    try std.testing.expect(!equal_sel1_sel2);

    const equal_sel1_sel3 = std.mem.eql(u8, &sel1, &sel3);
    try std.testing.expect(!equal_sel1_sel3);
}
```

### ABI error - truncated data insufficient for type

```zig
test "ABI error - truncated data insufficient for type" {
    const allocator = std.testing.allocator;

    const truncated = [_]u8{ 0x01, 0x02, 0x03 };
    const types = [_]AbiType{.uint256};

    const result = decodeAbiParameters(allocator, &truncated, &types);
    try std.testing.expectError(AbiError.DataTooSmall, result);
}
```

### ABI error - invalid dynamic offset beyond data bounds

```zig
test "ABI error - invalid dynamic offset beyond data bounds" {
    const allocator = std.testing.allocator;

    var data: [64]u8 = undefined;
    @memset(&data, 0);
    std.mem.writeInt(u64, data[24..32], 999999, .big);

    const types = [_]AbiType{.string};
    const result = decodeAbiParameters(allocator, &data, &types);
    try std.testing.expectError(AbiError.OutOfBounds, result);
}
```

### ABI error - invalid UTF-8 string decoding

```zig
test "ABI error - invalid UTF-8 string decoding" {
    const allocator = std.testing.allocator;

    var data: [96]u8 = undefined;
    @memset(&data, 0);
    std.mem.writeInt(u64, data[24..32], 32, .big);
    std.mem.writeInt(u64, data[56..64], 4, .big);
    data[64] = 0xFF;
    data[65] = 0xFF;
    data[66] = 0xFE;
    data[67] = 0xFD;

    const types = [_]AbiType{.string};
    const result = decodeAbiParameters(allocator, &data, &types);
    try std.testing.expectError(AbiError.InvalidUtf8, result);
}
```

### ABI error - function data too small (less than 4 bytes)

```zig
test "ABI error - function data too small (less than 4 bytes)" {
    const allocator = std.testing.allocator;

    const short_data = [_]u8{ 0x01, 0x02 };
    const result = decodeFunctionData(allocator, &short_data, &[_]AbiType{});
    try std.testing.expectError(AbiError.DataTooSmall, result);
}
```

### ABI error - cursor reading beyond bounds

```zig
test "ABI error - cursor reading beyond bounds" {
    var cursor = Cursor.init(&[_]u8{ 1, 2, 3, 4, 5 });
    const result = cursor.readBytes(10);
    try std.testing.expectError(AbiError.OutOfBounds, result);
}
```

### ABI error - cursor reading word from insufficient data

```zig
test "ABI error - cursor reading word from insufficient data" {
    var cursor = Cursor.init(&[_]u8{ 1, 2, 3, 4, 5 });
    const result = cursor.readWord();
    try std.testing.expectError(AbiError.OutOfBounds, result);
}
```

### ABI error - array length causes offset overflow

```zig
test "ABI error - array length causes offset overflow" {
    const allocator = std.testing.allocator;

    var data: [64]u8 = undefined;
    @memset(&data, 0);
    std.mem.writeInt(u64, data[24..32], 32, .big);
    std.mem.writeInt(u64, data[56..64], std.math.maxInt(u64), .big);

    const types = [_]AbiType{.@"uint256[]"};
    const result = decodeAbiParameters(allocator, &data, &types);
    try std.testing.expectError(AbiError.OutOfBounds, result);
}
```

### ABI error - negative offset in dynamic data

```zig
test "ABI error - negative offset in dynamic data" {
    const allocator = std.testing.allocator;

    var data: [64]u8 = undefined;
    @memset(&data, 0xFF);

    const types = [_]AbiType{.string};
    const result = decodeAbiParameters(allocator, &data, &types);
    try std.testing.expectError(AbiError.OutOfBounds, result);
}
```

### ABI error - malformed array with invalid element count

```zig
test "ABI error - malformed array with invalid element count" {
    const allocator = std.testing.allocator;

    var data: [128]u8 = undefined;
    @memset(&data, 0);
    std.mem.writeInt(u64, data[24..32], 32, .big);
    std.mem.writeInt(u64, data[56..64], 10, .big);

    const types = [_]AbiType{.@"uint256[]"};
    const result = decodeAbiParameters(allocator, &data, &types);
    try std.testing.expectError(AbiError.OutOfBounds, result);
}
```

### ABI error - empty data with non-empty type requirements

```zig
test "ABI error - empty data with non-empty type requirements" {
    const allocator = std.testing.allocator;

    const empty_data = [_]u8{};
    const types = [_]AbiType{ .uint256, .address };

    const result = decodeAbiParameters(allocator, &empty_data, &types);
    try std.testing.expectError(AbiError.DataTooSmall, result);
}
```

### ABI error - bytes dynamic length exceeds available data

```zig
test "ABI error - bytes dynamic length exceeds available data" {
    const allocator = std.testing.allocator;

    var data: [96]u8 = undefined;
    @memset(&data, 0);
    std.mem.writeInt(u64, data[24..32], 32, .big);
    std.mem.writeInt(u64, data[56..64], 1000, .big);

    const types = [_]AbiType{.bytes};
    const result = decodeAbiParameters(allocator, &data, &types);
    try std.testing.expectError(AbiError.OutOfBounds, result);
}
```

### ABI error - string array with invalid nested offset

```zig
test "ABI error - string array with invalid nested offset" {
    const allocator = std.testing.allocator;

    var data: [128]u8 = undefined;
    @memset(&data, 0);
    std.mem.writeInt(u64, data[24..32], 32, .big);
    std.mem.writeInt(u64, data[56..64], 1, .big);
    std.mem.writeInt(u64, data[88..96], 999999, .big);

    const types = [_]AbiType{.@"string[]"};
    const result = decodeAbiParameters(allocator, &data, &types);
    try std.testing.expectError(AbiError.OutOfBounds, result);
}
```

### ABI cross-validation - ethers.js ERC20 transfer encoding

```zig
test "ABI cross-validation - ethers.js ERC20 transfer encoding" {
    const allocator = std.testing.allocator;

    const recipient: address.Address = [_]u8{
        0xd8, 0xda, 0x6b, 0xf2, 0x69, 0x64, 0xaf, 0x9d,
        0x7e, 0xed, 0x9e, 0x03, 0xe5, 0x34, 0x15, 0xd3,
        0x7a, 0xa9, 0x60, 0x45,
    };
    const amount: u256 = 1000000000000000000;

    const values = [_]AbiValue{
        addressValue(recipient),
        uint256_value(amount),
    };

    const encoded = try encodeAbiParameters(allocator, &values);
    defer allocator.free(encoded);

    const expected_hex = "000000000000000000000000d8da6bf26964af9d7eed9e03e53415d37aa960450000000000000000000000000000000000000000000000000de0b6b3a7640000";
    const actual_hex = try std.fmt.allocPrint(allocator, "{}", .{std.fmt.fmtSliceHexLower(encoded)});
    defer allocator.free(actual_hex);

    try std.testing.expectEqualStrings(expected_hex, actual_hex);
}
```

### ABI cross-validation - web3.js approve encoding

```zig
test "ABI cross-validation - web3.js approve encoding" {
    const allocator = std.testing.allocator;

    const spender: address.Address = [_]u8{
        0x7a, 0x25, 0x0d, 0x56, 0x30, 0xb4, 0xcf, 0x53,
        0x99, 0x39, 0xc1, 0xf0, 0x7d, 0x1e, 0x3e, 0xa4,
        0x0f, 0x60, 0x63, 0xaf,
    };
    const max_uint256: u256 = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;

    const values = [_]AbiValue{
        addressValue(spender),
        uint256_value(max_uint256),
    };

    const encoded = try encodeAbiParameters(allocator, &values);
    defer allocator.free(encoded);

    const expected_hex = "0000000000000000000000007a250d5630b4cf539939c1f07d1e3ea40f6063afffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff";
    const actual_hex = try std.fmt.allocPrint(allocator, "{}", .{std.fmt.fmtSliceHexLower(encoded)});
    defer allocator.free(actual_hex);

    try std.testing.expectEqualStrings(expected_hex, actual_hex);
}
```

### ABI cross-validation - viem string encoding 'Hello World'

```zig
test "ABI cross-validation - viem string encoding 'Hello World'" {
    const allocator = std.testing.allocator;

    const values = [_]AbiValue{
        stringValue("Hello World"),
    };

    const encoded = try encodeAbiParameters(allocator, &values);
    defer allocator.free(encoded);

    const expected_hex = "0000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000b48656c6c6f20576f726c64000000000000000000000000000000000000000000";
    const actual_hex = try std.fmt.allocPrint(allocator, "{}", .{std.fmt.fmtSliceHexLower(encoded)});
    defer allocator.free(actual_hex);

    try std.testing.expectEqualStrings(expected_hex, actual_hex);
}
```

### ABI cross-validation - ethers.js multiple parameters encoding

```zig
test "ABI cross-validation - ethers.js multiple parameters encoding" {
    const allocator = std.testing.allocator;

    const addr: address.Address = [_]u8{
        0xc9, 0x61, 0x14, 0x5a, 0x54, 0xc9, 0x6e, 0x3a,
        0xe9, 0xba, 0xa0, 0x48, 0xc4, 0xf4, 0xd6, 0xb0,
        0x4c, 0x13, 0x91, 0x6b,
    };
    const values = [_]AbiValue{
        uint256_value(420),
        boolValue(true),
        addressValue(addr),
    };

    const encoded = try encodeAbiParameters(allocator, &values);
    defer allocator.free(encoded);

    const expected_hex = "00000000000000000000000000000000000000000000000000000000000001a40000000000000000000000000000000000000000000000000000000000000001000000000000000000000000c961145a54c96e3ae9baa048c4f4d6b04c13916b";
    const actual_hex = try std.fmt.allocPrint(allocator, "{}", .{std.fmt.fmtSliceHexLower(encoded)});
    defer allocator.free(actual_hex);

    try std.testing.expectEqualStrings(expected_hex, actual_hex);
}
```

### ABI cross-validation - real contract function encoding

```zig
test "ABI cross-validation - real contract function encoding" {
    const allocator = std.testing.allocator;

    const addr1: address.Address = [_]u8{0x11} ** 20;
    const addr2: address.Address = [_]u8{0x22} ** 20;
    const path = [_]address.Address{ addr1, addr2 };

    const to_addr: address.Address = [_]u8{0x33} ** 20;

    const values = [_]AbiValue{
        uint256_value(1000000000000000000),
        uint256_value(900000000000000000),
        .{ .@"address[]" = &path },
        addressValue(to_addr),
        uint256_value(1700000000),
    };

    const encoded = try encodeAbiParameters(allocator, &values);
    defer allocator.free(encoded);

    const types = [_]AbiType{ .uint256, .uint256, .@"address[]", .address, .uint256 };
    const decoded = try decodeAbiParameters(allocator, encoded, &types);
    defer {
        allocator.free(decoded[2].@"address[]");
        allocator.free(decoded);
    }

    try std.testing.expectEqual(@as(u256, 1000000000000000000), decoded[0].uint256);
    try std.testing.expectEqual(@as(u256, 900000000000000000), decoded[1].uint256);
    try std.testing.expectEqual(@as(usize, 2), decoded[2].@"address[]".len);
    try std.testing.expectEqualSlices(u8, &to_addr, &decoded[3].address);
    try std.testing.expectEqual(@as(u256, 1700000000), decoded[4].uint256);
}
```

### ABI cross-validation - bytes encoding with known hash

```zig
test "ABI cross-validation - bytes encoding with known hash" {
    const allocator = std.testing.allocator;

    const data = [_]u8{ 0xde, 0xad, 0xbe, 0xef, 0xca, 0xfe, 0xba, 0xbe };
    const values = [_]AbiValue{
        bytesValue(&data),
    };

    const encoded = try encodeAbiParameters(allocator, &values);
    defer allocator.free(encoded);

    const expected_hex = "00000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000008deadbeefcafebabe0000000000000000000000000000000000000000000000";
    const actual_hex = try std.fmt.allocPrint(allocator, "{}", .{std.fmt.fmtSliceHexLower(encoded)});
    defer allocator.free(actual_hex);

    try std.testing.expectEqualStrings(expected_hex, actual_hex);
}
```

### Security - MAX_ABI_LENGTH prevents memory exhaustion on decode

```zig
test "Security - MAX_ABI_LENGTH prevents memory exhaustion on decode" {
    const allocator = std.testing.allocator;

    // Create encoded data claiming to have an absurdly large length (20 MB)
    var large_data: [64]u8 = undefined;
    @memset(&large_data, 0);

    // First word: offset to dynamic data = 32
    std.mem.writeInt(u256, large_data[0..32], 32, .big);

    // Second word: claimed length = 20MB (exceeds MAX_ABI_LENGTH)
    const excessive_length: u256 = 20 * 1024 * 1024;
    std.mem.writeInt(u256, large_data[32..64], excessive_length, .big);

    const types = [_]AbiType{.bytes};

    // Should fail with MaxLengthExceeded
    const result = decodeAbiParameters(allocator, &large_data, &types);
    try std.testing.expectError(AbiError.MaxLengthExceeded, result);
}
```

### Security - MAX_ABI_LENGTH prevents memory exhaustion on encode

```zig
test "Security - MAX_ABI_LENGTH prevents memory exhaustion on encode" {
    const allocator = std.testing.allocator;

    // Try to allocate a string that would exceed MAX_ABI_LENGTH
    const huge_str_len = MAX_ABI_LENGTH + 1000;
    const huge_str = try allocator.alloc(u8, huge_str_len);
    defer allocator.free(huge_str);
    @memset(huge_str, 'A');

    const values = [_]AbiValue{
        stringValue(huge_str),
    };

    // Should fail with MaxLengthExceeded
    const result = encodeAbiParameters(allocator, &values);
    try std.testing.expectError(AbiError.MaxLengthExceeded, result);
}
```

### Security - MAX_RECURSION_DEPTH prevents stack exhaustion

```zig
test "Security - MAX_RECURSION_DEPTH prevents stack exhaustion" {
    const allocator = std.testing.allocator;

    // Create nested array structure that would exceed recursion depth
    // We can't actually create deeply nested arrays in the current type system,
    // but we can test with the maximum supported depth

    // Create a uint256[] array at depth 0
    const arr = [_]u256{ 1, 2, 3 };
    const values = [_]AbiValue{
        .{ .@"uint256[]" = &arr },
    };

    // Encode it (should work at depth 0)
    const encoded = try encodeAbiParameters(allocator, &values);
    defer allocator.free(encoded);

    // Decode it (should work at depth 0)
    const types = [_]AbiType{.@"uint256[]"};
    const decoded = try decodeAbiParameters(allocator, encoded, &types);
    defer {
        allocator.free(decoded[0].@"uint256[]");
        allocator.free(decoded);
    }

    try std.testing.expectEqual(@as(usize, 3), decoded[0].@"uint256[]".len);
}
```

### Security - safeIntCast prevents integer overflow

```zig
test "Security - safeIntCast prevents integer overflow" {
    // Test that safeIntCast properly validates ranges

    // Valid cast
    const valid = try safeIntCast(u64, 100);
    try std.testing.expectEqual(@as(u64, 100), valid);

    // Invalid cast - value too large for u64
    const too_large: u256 = std.math.maxInt(u256);
    const result = safeIntCast(u64, too_large);
    try std.testing.expectError(AbiError.IntegerCastOverflow, result);
}
```

### Security - validateAllocationSize prevents large allocations

```zig
test "Security - validateAllocationSize prevents large allocations" {
    // Within limit
    try validateAllocationSize(1024);
    try validateAllocationSize(MAX_ABI_LENGTH);

    // Exceeds limit
    const result = validateAllocationSize(MAX_ABI_LENGTH + 1);
    try std.testing.expectError(AbiError.MaxLengthExceeded, result);
}
```

### Security - validateRecursionDepth prevents deep recursion

```zig
test "Security - validateRecursionDepth prevents deep recursion" {
    // Within limit
    try validateRecursionDepth(0);
    try validateRecursionDepth(MAX_RECURSION_DEPTH - 1);

    // Exceeds limit
    const result = validateRecursionDepth(MAX_RECURSION_DEPTH);
    try std.testing.expectError(AbiError.MaxRecursionDepthExceeded, result);
}
```

### Security - array length validation on decode

```zig
test "Security - array length validation on decode" {
    const allocator = std.testing.allocator;

    // Create encoded data with excessive array length
    var data: [64]u8 = undefined;
    @memset(&data, 0);

    // First word: offset = 32
    std.mem.writeInt(u256, data[0..32], 32, .big);

    // Second word: array length that would cause excessive memory allocation
    const excessive_count: u256 = MAX_ABI_LENGTH / 32 + 1000;
    std.mem.writeInt(u256, data[32..64], excessive_count, .big);

    const types = [_]AbiType{.@"uint256[]"};

    // Should fail with MaxLengthExceeded when trying to allocate array
    const result = decodeAbiParameters(allocator, &data, &types);
    try std.testing.expectError(AbiError.MaxLengthExceeded, result);
}
```

### Security - string array total size validation

```zig
test "Security - string array total size validation" {
    const allocator = std.testing.allocator;

    // Create many large strings that would exceed MAX_ABI_LENGTH in total
    const str_count = 1000;
    const str_size = MAX_ABI_LENGTH / 100; // Each string is 100KB

    const strings = try allocator.alloc([]const u8, str_count);
    defer allocator.free(strings);

    for (strings) |*s| {
        const str = try allocator.alloc(u8, str_size);
        @memset(str, 'X');
        s.* = str;
    }
    defer for (strings) |s| {
        allocator.free(s);
    };

    var values = try allocator.alloc(AbiValue, str_count);
    defer allocator.free(values);

    for (strings, 0..) |s, i| {
        values[i] = stringValue(s);
    }

    // Should fail with MaxLengthExceeded due to total size
    const result = encodeAbiParameters(allocator, values);
    try std.testing.expectError(AbiError.MaxLengthExceeded, result);
}
```

### Fixed array - uint256[2] encoding

```zig
test "Fixed array - uint256[2] encoding" {
    const allocator = std.testing.allocator;

    const arr = [2]u256{ 1, 2 };
    const values = [_]AbiValue{
        .{ .@"uint256[2]" = arr },
    };

    const encoded = try encodeAbiParameters(allocator, &values);
    defer allocator.free(encoded);

    // Fixed array is encoded inline: 2 * 32 = 64 bytes (NO offset pointer)
    try std.testing.expectEqual(@as(usize, 64), encoded.len);
    try std.testing.expectEqual(@as(u8, 1), encoded[31]);
    try std.testing.expectEqual(@as(u8, 2), encoded[63]);
}
```

### Fixed array - uint256[3] encoding and decoding

```zig
test "Fixed array - uint256[3] encoding and decoding" {
    const allocator = std.testing.allocator;

    const arr = [3]u256{ 10, 20, 30 };
    const values = [_]AbiValue{
        .{ .@"uint256[3]" = arr },
    };

    const encoded = try encodeAbiParameters(allocator, &values);
    defer allocator.free(encoded);

    // 3 * 32 = 96 bytes
    try std.testing.expectEqual(@as(usize, 96), encoded.len);
    try std.testing.expectEqual(@as(u8, 10), encoded[31]);
    try std.testing.expectEqual(@as(u8, 20), encoded[63]);
    try std.testing.expectEqual(@as(u8, 30), encoded[95]);

    // Decode round-trip
    const types = [_]AbiType{.@"uint256[3]"};
    const decoded = try decodeAbiParameters(allocator, encoded, &types);
    defer allocator.free(decoded);

    try std.testing.expectEqual(@as(u256, 10), decoded[0].@"uint256[3]"[0]);
    try std.testing.expectEqual(@as(u256, 20), decoded[0].@"uint256[3]"[1]);
    try std.testing.expectEqual(@as(u256, 30), decoded[0].@"uint256[3]"[2]);
}
```

### Fixed array - address[2] encoding

```zig
test "Fixed array - address[2] encoding" {
    const allocator = std.testing.allocator;

    const addr1 = address.Address{ .bytes = [_]u8{0} ** 19 ++ [_]u8{1} };
    const addr2 = address.Address{ .bytes = [_]u8{0} ** 19 ++ [_]u8{2} };
    const arr = [2]address.Address{ addr1, addr2 };
    const values = [_]AbiValue{
        .{ .@"address[2]" = arr },
    };

    const encoded = try encodeAbiParameters(allocator, &values);
    defer allocator.free(encoded);

    // 2 * 32 = 64 bytes
    try std.testing.expectEqual(@as(usize, 64), encoded.len);
    try std.testing.expectEqual(@as(u8, 1), encoded[31]);
    try std.testing.expectEqual(@as(u8, 2), encoded[63]);
}
```

### Fixed array - bool[4] encoding

```zig
test "Fixed array - bool[4] encoding" {
    const allocator = std.testing.allocator;

    const arr = [4]bool{ true, false, true, true };
    const values = [_]AbiValue{
        .{ .@"bool[4]" = arr },
    };

    const encoded = try encodeAbiParameters(allocator, &values);
    defer allocator.free(encoded);

    // 4 * 32 = 128 bytes
    try std.testing.expectEqual(@as(usize, 128), encoded.len);
    try std.testing.expectEqual(@as(u8, 1), encoded[31]);
    try std.testing.expectEqual(@as(u8, 0), encoded[63]);
    try std.testing.expectEqual(@as(u8, 1), encoded[95]);
    try std.testing.expectEqual(@as(u8, 1), encoded[127]);
}
```

### Fixed array - bytes4[2] encoding

```zig
test "Fixed array - bytes4[2] encoding" {
    const allocator = std.testing.allocator;

    const b1 = [4]u8{ 0x12, 0x34, 0x56, 0x78 };
    const b2 = [4]u8{ 0x9a, 0xbc, 0xde, 0xf0 };
    const arr = [2][4]u8{ b1, b2 };
    const values = [_]AbiValue{
        .{ .@"bytes4[2]" = arr },
    };

    const encoded = try encodeAbiParameters(allocator, &values);
    defer allocator.free(encoded);

    // 2 * 32 = 64 bytes (each bytes4 left-aligned in 32-byte slot)
    try std.testing.expectEqual(@as(usize, 64), encoded.len);
    try std.testing.expectEqual(@as(u8, 0x12), encoded[0]);
    try std.testing.expectEqual(@as(u8, 0x78), encoded[3]);
    try std.testing.expectEqual(@as(u8, 0x9a), encoded[32]);
    try std.testing.expectEqual(@as(u8, 0xf0), encoded[35]);
}
```

### Fixed array - mixed with other params (uint256, address[2], bool)

```zig
test "Fixed array - mixed with other params (uint256, address[2], bool)" {
    const allocator = std.testing.allocator;

    const addr1 = address.Address{ .bytes = [_]u8{0} ** 19 ++ [_]u8{1} };
    const addr2 = address.Address{ .bytes = [_]u8{0} ** 19 ++ [_]u8{2} };
    const arr = [2]address.Address{ addr1, addr2 };

    const values = [_]AbiValue{
        .{ .uint256 = 42 },
        .{ .@"address[2]" = arr },
        .{ .bool = true },
    };

    const encoded = try encodeAbiParameters(allocator, &values);
    defer allocator.free(encoded);

    // uint256 (32) + address[2] (64) + bool (32) = 128 bytes
    try std.testing.expectEqual(@as(usize, 128), encoded.len);
    try std.testing.expectEqual(@as(u8, 42), encoded[31]); // uint256
    try std.testing.expectEqual(@as(u8, 1), encoded[63]); // address[2][0]
    try std.testing.expectEqual(@as(u8, 2), encoded[95]); // address[2][1]
    try std.testing.expectEqual(@as(u8, 1), encoded[127]); // bool
}
```

### Fixed array - empty vs populated

```zig
test "Fixed array - empty vs populated" {
    const allocator = std.testing.allocator;

    // Zero values
    const arr_zeros = [2]u256{ 0, 0 };
    const values_zeros = [_]AbiValue{
        .{ .@"uint256[2]" = arr_zeros },
    };

    const encoded_zeros = try encodeAbiParameters(allocator, &values_zeros);
    defer allocator.free(encoded_zeros);

    try std.testing.expectEqual(@as(usize, 64), encoded_zeros.len);
    for (encoded_zeros) |b| {
        try std.testing.expectEqual(@as(u8, 0), b);
    }

    // Non-zero values
    const arr_vals = [2]u256{ 100, 200 };
    const values_vals = [_]AbiValue{
        .{ .@"uint256[2]" = arr_vals },
    };

    const encoded_vals = try encodeAbiParameters(allocator, &values_vals);
    defer allocator.free(encoded_vals);

    try std.testing.expectEqual(@as(usize, 64), encoded_vals.len);
    try std.testing.expectEqual(@as(u8, 100), encoded_vals[31]);
    try std.testing.expectEqual(@as(u8, 200), encoded_vals[63]);
}
```

### Tuple - simple all-static (uint256, address)

```zig
test "Tuple - simple all-static (uint256, address)" {
    const allocator = std.testing.allocator;

    const values = [_]AbiValue{
        uint256_value(100),
        addressValue(address.Address{ .bytes = [_]u8{0x00} ** 19 ++ [_]u8{0x01} }),
    };

    const encoded = try encodeAbiParameters(allocator, &values);
    defer allocator.free(encoded);

    try std.testing.expectEqual(@as(usize, 64), encoded.len);
    try std.testing.expectEqual(@as(u8, 100), encoded[31]);
    try std.testing.expectEqual(@as(u8, 0x01), encoded[63]);

    const types = [_]AbiType{ .uint256, .address };
    const decoded = try decodeAbiParameters(allocator, encoded, &types);
    defer allocator.free(decoded);

    try std.testing.expectEqual(@as(u256, 100), decoded[0].uint256);
    try std.testing.expectEqual(@as(u8, 0x01), decoded[1].address.bytes[19]);
}
```

### Tuple - with dynamic member (uint256, string)

```zig
test "Tuple - with dynamic member (uint256, string)" {
    const allocator = std.testing.allocator;

    const values = [_]AbiValue{
        uint256_value(42),
        stringValue("hello"),
    };

    const encoded = try encodeAbiParameters(allocator, &values);
    defer allocator.free(encoded);

    try std.testing.expectEqual(@as(usize, 128), encoded.len);
    try std.testing.expectEqual(@as(u8, 42), encoded[31]);
    try std.testing.expectEqual(@as(u8, 0x40), encoded[63]);
    try std.testing.expectEqual(@as(u8, 5), encoded[95]);

    const types = [_]AbiType{ .uint256, .string };
    const decoded = try decodeAbiParameters(allocator, encoded, &types);
    defer {
        allocator.free(decoded[1].string);
        allocator.free(decoded);
    }

    try std.testing.expectEqual(@as(u256, 42), decoded[0].uint256);
    try std.testing.expectEqualSlices(u8, "hello", decoded[1].string);
}
```

### Tuple - multiple types (uint8, address, bool, bytes4)

```zig
test "Tuple - multiple types (uint8, address, bool, bytes4)" {
    const allocator = std.testing.allocator;

    const values = [_]AbiValue{
        AbiValue{ .uint8 = 255 },
        addressValue(address.Address{ .bytes = [_]u8{0x00} ** 19 ++ [_]u8{0x01} }),
        boolValue(true),
        AbiValue{ .bytes4 = [_]u8{ 0x12, 0x34, 0x56, 0x78 } },
    };

    const encoded = try encodeAbiParameters(allocator, &values);
    defer allocator.free(encoded);

    try std.testing.expectEqual(@as(usize, 128), encoded.len);
    try std.testing.expectEqual(@as(u8, 255), encoded[31]);
    try std.testing.expectEqual(@as(u8, 0x01), encoded[63]);
    try std.testing.expectEqual(@as(u8, 1), encoded[95]);
    try std.testing.expectEqual(@as(u8, 0x12), encoded[96]);
    try std.testing.expectEqual(@as(u8, 0x78), encoded[99]);

    const types = [_]AbiType{ .uint8, .address, .bool, .bytes4 };
    const decoded = try decodeAbiParameters(allocator, encoded, &types);
    defer allocator.free(decoded);

    try std.testing.expectEqual(@as(u8, 255), decoded[0].uint8);
    try std.testing.expectEqual(@as(u8, 0x01), decoded[1].address.bytes[19]);
    try std.testing.expectEqual(true, decoded[2].bool);
    try std.testing.expectEqual(@as(u8, 0x12), decoded[3].bytes4[0]);
}
```

### Tuple - mixed (address, string, uint256)

```zig
test "Tuple - mixed (address, string, uint256)" {
    const allocator = std.testing.allocator;

    const values = [_]AbiValue{
        addressValue(address.Address{ .bytes = [_]u8{0x00} ** 19 ++ [_]u8{0x01} }),
        stringValue("test"),
        uint256_value(999),
    };

    const encoded = try encodeAbiParameters(allocator, &values);
    defer allocator.free(encoded);

    try std.testing.expectEqual(@as(usize, 160), encoded.len);

    const types = [_]AbiType{ .address, .string, .uint256 };
    const decoded = try decodeAbiParameters(allocator, encoded, &types);
    defer {
        allocator.free(decoded[1].string);
        allocator.free(decoded);
    }

    try std.testing.expectEqual(@as(u8, 0x01), decoded[0].address.bytes[19]);
    try std.testing.expectEqualSlices(u8, "test", decoded[1].string);
    try std.testing.expectEqual(@as(u256, 999), decoded[2].uint256);
}
```

### uint types boundary - zero values

```zig
test "uint types boundary - zero values" {
    const allocator = std.testing.allocator;

    const values = [_]AbiValue{
        .{ .uint8 = 0 },
        .{ .uint16 = 0 },
        .{ .uint32 = 0 },
        .{ .uint64 = 0 },
        .{ .uint128 = 0 },
        uint256_value(0),
    };

    const encoded = try encodeAbiParameters(allocator, &values);
    defer allocator.free(encoded);

    try std.testing.expectEqual(@as(usize, 192), encoded.len); // 6 * 32
    // All should be zero bytes
    for (encoded) |byte| {
        try std.testing.expectEqual(@as(u8, 0), byte);
    }

    const types = [_]AbiType{ .uint8, .uint16, .uint32, .uint64, .uint128, .uint256 };
    const decoded = try decodeAbiParameters(allocator, encoded, &types);
    defer allocator.free(decoded);

    try std.testing.expectEqual(@as(u8, 0), decoded[0].uint8);
    try std.testing.expectEqual(@as(u16, 0), decoded[1].uint16);
    try std.testing.expectEqual(@as(u32, 0), decoded[2].uint32);
    try std.testing.expectEqual(@as(u64, 0), decoded[3].uint64);
    try std.testing.expectEqual(@as(u128, 0), decoded[4].uint128);
    try std.testing.expectEqual(@as(u256, 0), decoded[5].uint256);
}
```

### uint types boundary - one values

```zig
test "uint types boundary - one values" {
    const allocator = std.testing.allocator;

    const values = [_]AbiValue{
        .{ .uint8 = 1 },
        .{ .uint16 = 1 },
        .{ .uint32 = 1 },
        .{ .uint64 = 1 },
        .{ .uint128 = 1 },
        uint256_value(1),
    };

    const encoded = try encodeAbiParameters(allocator, &values);
    defer allocator.free(encoded);

    const types = [_]AbiType{ .uint8, .uint16, .uint32, .uint64, .uint128, .uint256 };
    const decoded = try decodeAbiParameters(allocator, encoded, &types);
    defer allocator.free(decoded);

    try std.testing.expectEqual(@as(u8, 1), decoded[0].uint8);
    try std.testing.expectEqual(@as(u16, 1), decoded[1].uint16);
    try std.testing.expectEqual(@as(u32, 1), decoded[2].uint32);
    try std.testing.expectEqual(@as(u64, 1), decoded[3].uint64);
    try std.testing.expectEqual(@as(u128, 1), decoded[4].uint128);
    try std.testing.expectEqual(@as(u256, 1), decoded[5].uint256);
}
```

### uint types boundary - max values

```zig
test "uint types boundary - max values" {
    const allocator = std.testing.allocator;

    const values = [_]AbiValue{
        .{ .uint8 = std.math.maxInt(u8) },
        .{ .uint16 = std.math.maxInt(u16) },
        .{ .uint32 = std.math.maxInt(u32) },
        .{ .uint64 = std.math.maxInt(u64) },
        .{ .uint128 = std.math.maxInt(u128) },
        uint256_value(std.math.maxInt(u256)),
    };

    const encoded = try encodeAbiParameters(allocator, &values);
    defer allocator.free(encoded);

    const types = [_]AbiType{ .uint8, .uint16, .uint32, .uint64, .uint128, .uint256 };
    const decoded = try decodeAbiParameters(allocator, encoded, &types);
    defer allocator.free(decoded);

    try std.testing.expectEqual(std.math.maxInt(u8), decoded[0].uint8);
    try std.testing.expectEqual(std.math.maxInt(u16), decoded[1].uint16);
    try std.testing.expectEqual(std.math.maxInt(u32), decoded[2].uint32);
    try std.testing.expectEqual(std.math.maxInt(u64), decoded[3].uint64);
    try std.testing.expectEqual(std.math.maxInt(u128), decoded[4].uint128);
    try std.testing.expectEqual(std.math.maxInt(u256), decoded[5].uint256);
}
```

### int types boundary - zero values

```zig
test "int types boundary - zero values" {
    const allocator = std.testing.allocator;

    const values = [_]AbiValue{
        .{ .int8 = 0 },
        .{ .int16 = 0 },
        .{ .int32 = 0 },
        .{ .int64 = 0 },
        .{ .int128 = 0 },
    };

    const encoded = try encodeAbiParameters(allocator, &values);
    defer allocator.free(encoded);

    const types = [_]AbiType{ .int8, .int16, .int32, .int64, .int128 };
    const decoded = try decodeAbiParameters(allocator, encoded, &types);
    defer allocator.free(decoded);

    try std.testing.expectEqual(@as(i8, 0), decoded[0].int8);
    try std.testing.expectEqual(@as(i16, 0), decoded[1].int16);
    try std.testing.expectEqual(@as(i32, 0), decoded[2].int32);
    try std.testing.expectEqual(@as(i64, 0), decoded[3].int64);
    try std.testing.expectEqual(@as(i128, 0), decoded[4].int128);
}
```

### int types boundary - positive max values

```zig
test "int types boundary - positive max values" {
    const allocator = std.testing.allocator;

    const values = [_]AbiValue{
        .{ .int8 = std.math.maxInt(i8) },
        .{ .int16 = std.math.maxInt(i16) },
        .{ .int32 = std.math.maxInt(i32) },
        .{ .int64 = std.math.maxInt(i64) },
        .{ .int128 = std.math.maxInt(i128) },
    };

    const encoded = try encodeAbiParameters(allocator, &values);
    defer allocator.free(encoded);

    const types = [_]AbiType{ .int8, .int16, .int32, .int64, .int128 };
    const decoded = try decodeAbiParameters(allocator, encoded, &types);
    defer allocator.free(decoded);

    try std.testing.expectEqual(std.math.maxInt(i8), decoded[0].int8);
    try std.testing.expectEqual(std.math.maxInt(i16), decoded[1].int16);
    try std.testing.expectEqual(std.math.maxInt(i32), decoded[2].int32);
    try std.testing.expectEqual(std.math.maxInt(i64), decoded[3].int64);
    try std.testing.expectEqual(std.math.maxInt(i128), decoded[4].int128);
}
```

### int types boundary - negative min values two's complement

```zig
test "int types boundary - negative min values two's complement" {
    const allocator = std.testing.allocator;

    const values = [_]AbiValue{
        .{ .int8 = std.math.minInt(i8) },
        .{ .int16 = std.math.minInt(i16) },
        .{ .int32 = std.math.minInt(i32) },
        .{ .int64 = std.math.minInt(i64) },
        .{ .int128 = std.math.minInt(i128) },
    };

    const encoded = try encodeAbiParameters(allocator, &values);
    defer allocator.free(encoded);

    // Verify two's complement encoding for int8 = -128
    const expected_int8 = [_]u8{0xff} ** 31 ++ [_]u8{0x80};
    try std.testing.expectEqualSlices(u8, &expected_int8, encoded[0..32]);

    const types = [_]AbiType{ .int8, .int16, .int32, .int64, .int128 };
    const decoded = try decodeAbiParameters(allocator, encoded, &types);
    defer allocator.free(decoded);

    try std.testing.expectEqual(std.math.minInt(i8), decoded[0].int8);
    try std.testing.expectEqual(std.math.minInt(i16), decoded[1].int16);
    try std.testing.expectEqual(std.math.minInt(i32), decoded[2].int32);
    try std.testing.expectEqual(std.math.minInt(i64), decoded[3].int64);
    try std.testing.expectEqual(std.math.minInt(i128), decoded[4].int128);
}
```

### int types - negative one two's complement

```zig
test "int types - negative one two's complement" {
    const allocator = std.testing.allocator;

    const values = [_]AbiValue{
        .{ .int8 = -1 },
        .{ .int16 = -1 },
        .{ .int32 = -1 },
        .{ .int64 = -1 },
        .{ .int128 = -1 },
    };

    const encoded = try encodeAbiParameters(allocator, &values);
    defer allocator.free(encoded);

    // -1 should be all 0xff bytes in two's complement
    for (0..5) |i| {
        for (encoded[i * 32 .. (i + 1) * 32]) |byte| {
            try std.testing.expectEqual(@as(u8, 0xff), byte);
        }
    }

    const types = [_]AbiType{ .int8, .int16, .int32, .int64, .int128 };
    const decoded = try decodeAbiParameters(allocator, encoded, &types);
    defer allocator.free(decoded);

    try std.testing.expectEqual(@as(i8, -1), decoded[0].int8);
    try std.testing.expectEqual(@as(i16, -1), decoded[1].int16);
    try std.testing.expectEqual(@as(i32, -1), decoded[2].int32);
    try std.testing.expectEqual(@as(i64, -1), decoded[3].int64);
    try std.testing.expectEqual(@as(i128, -1), decoded[4].int128);
}
```

### bytesN types - all sizes

```zig
test "bytesN types - all sizes" {
    const allocator = std.testing.allocator;

    const values = [_]AbiValue{
        .{ .bytes1 = [_]u8{0x01} },
        .{ .bytes2 = [_]u8{ 0x01, 0x02 } },
        .{ .bytes3 = [_]u8{ 0x01, 0x02, 0x03 } },
        .{ .bytes4 = [_]u8{ 0x01, 0x02, 0x03, 0x04 } },
        .{ .bytes8 = [_]u8{ 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08 } },
        .{ .bytes16 = [_]u8{0xff} ** 16 },
        .{ .bytes32 = [_]u8{0xaa} ** 32 },
    };

    const encoded = try encodeAbiParameters(allocator, &values);
    defer allocator.free(encoded);

    try std.testing.expectEqual(@as(usize, 224), encoded.len); // 7 * 32

    const types = [_]AbiType{ .bytes1, .bytes2, .bytes3, .bytes4, .bytes8, .bytes16, .bytes32 };
    const decoded = try decodeAbiParameters(allocator, encoded, &types);
    defer allocator.free(decoded);

    try std.testing.expectEqual(@as(u8, 0x01), decoded[0].bytes1[0]);
    try std.testing.expectEqualSlices(u8, &values[1].bytes2, &decoded[1].bytes2);
    try std.testing.expectEqualSlices(u8, &values[2].bytes3, &decoded[2].bytes3);
    try std.testing.expectEqualSlices(u8, &values[3].bytes4, &decoded[3].bytes4);
    try std.testing.expectEqualSlices(u8, &values[4].bytes8, &decoded[4].bytes8);
    try std.testing.expectEqualSlices(u8, &values[5].bytes16, &decoded[5].bytes16);
    try std.testing.expectEqualSlices(u8, &values[6].bytes32, &decoded[6].bytes32);
}
```

### dynamic bytes - empty

```zig
test "dynamic bytes - empty" {
    const allocator = std.testing.allocator;

    const empty = [_]u8{};
    const values = [_]AbiValue{
        bytesValue(&empty),
    };

    const encoded = try encodeAbiParameters(allocator, &values);
    defer allocator.free(encoded);

    const types = [_]AbiType{.bytes};
    const decoded = try decodeAbiParameters(allocator, encoded, &types);
    defer {
        allocator.free(decoded[0].bytes);
        allocator.free(decoded);
    }

    try std.testing.expectEqual(@as(usize, 0), decoded[0].bytes.len);
}
```

### dynamic bytes - single byte

```zig
test "dynamic bytes - single byte" {
    const allocator = std.testing.allocator;

    const single = [_]u8{0x42};
    const values = [_]AbiValue{
        bytesValue(&single),
    };

    const encoded = try encodeAbiParameters(allocator, &values);
    defer allocator.free(encoded);

    const types = [_]AbiType{.bytes};
    const decoded = try decodeAbiParameters(allocator, encoded, &types);
    defer {
        allocator.free(decoded[0].bytes);
        allocator.free(decoded);
    }

    try std.testing.expectEqual(@as(usize, 1), decoded[0].bytes.len);
    try std.testing.expectEqual(@as(u8, 0x42), decoded[0].bytes[0]);
}
```

### dynamic bytes - 32 bytes no extra padding

```zig
test "dynamic bytes - 32 bytes no extra padding" {
    const allocator = std.testing.allocator;

    const exact = [_]u8{0x42} ** 32;
    const values = [_]AbiValue{
        bytesValue(&exact),
    };

    const encoded = try encodeAbiParameters(allocator, &values);
    defer allocator.free(encoded);

    const types = [_]AbiType{.bytes};
    const decoded = try decodeAbiParameters(allocator, encoded, &types);
    defer {
        allocator.free(decoded[0].bytes);
        allocator.free(decoded);
    }

    try std.testing.expectEqual(@as(usize, 32), decoded[0].bytes.len);
    try std.testing.expectEqualSlices(u8, &exact, decoded[0].bytes);
}
```

### dynamic bytes - 33 bytes requires padding

```zig
test "dynamic bytes - 33 bytes requires padding" {
    const allocator = std.testing.allocator;

    const over = [_]u8{0x42} ** 33;
    const values = [_]AbiValue{
        bytesValue(&over),
    };

    const encoded = try encodeAbiParameters(allocator, &values);
    defer allocator.free(encoded);

    const types = [_]AbiType{.bytes};
    const decoded = try decodeAbiParameters(allocator, encoded, &types);
    defer {
        allocator.free(decoded[0].bytes);
        allocator.free(decoded);
    }

    try std.testing.expectEqual(@as(usize, 33), decoded[0].bytes.len);
    try std.testing.expectEqualSlices(u8, &over, decoded[0].bytes);
}
```

### string - empty

```zig
test "string - empty" {
    const allocator = std.testing.allocator;

    const values = [_]AbiValue{
        stringValue(""),
    };

    const encoded = try encodeAbiParameters(allocator, &values);
    defer allocator.free(encoded);

    const types = [_]AbiType{.string};
    const decoded = try decodeAbiParameters(allocator, encoded, &types);
    defer {
        allocator.free(decoded[0].string);
        allocator.free(decoded);
    }

    try std.testing.expectEqual(@as(usize, 0), decoded[0].string.len);
}
```

### string - ASCII

```zig
test "string - ASCII" {
    const allocator = std.testing.allocator;

    const values = [_]AbiValue{
        stringValue("Hello, World!"),
    };

    const encoded = try encodeAbiParameters(allocator, &values);
    defer allocator.free(encoded);

    const types = [_]AbiType{.string};
    const decoded = try decodeAbiParameters(allocator, encoded, &types);
    defer {
        allocator.free(decoded[0].string);
        allocator.free(decoded);
    }

    try std.testing.expectEqualStrings("Hello, World!", decoded[0].string);
}
```

### string - UTF-8 multibyte

```zig
test "string - UTF-8 multibyte" {
    const allocator = std.testing.allocator;

    const values = [_]AbiValue{
        stringValue("Hello  "),
    };

    const encoded = try encodeAbiParameters(allocator, &values);
    defer allocator.free(encoded);

    const types = [_]AbiType{.string};
    const decoded = try decodeAbiParameters(allocator, encoded, &types);
    defer {
        allocator.free(decoded[0].string);
        allocator.free(decoded);
    }

    try std.testing.expectEqualStrings("Hello  ", decoded[0].string);
}
```

### string - emoji only

```zig
test "string - emoji only" {
    const allocator = std.testing.allocator;

    const values = [_]AbiValue{
        stringValue(""),
    };

    const encoded = try encodeAbiParameters(allocator, &values);
    defer allocator.free(encoded);

    const types = [_]AbiType{.string};
    const decoded = try decodeAbiParameters(allocator, encoded, &types);
    defer {
        allocator.free(decoded[0].string);
        allocator.free(decoded);
    }

    try std.testing.expectEqualStrings("", decoded[0].string);
}
```

### arrays - uint256[] empty

```zig
test "arrays - uint256[] empty" {
    const allocator = std.testing.allocator;

    const arr = [_]u256{};
    const values = [_]AbiValue{
        .{ .@"uint256[]" = &arr },
    };

    const encoded = try encodeAbiParameters(allocator, &values);
    defer allocator.free(encoded);

    const types = [_]AbiType{.@"uint256[]"};
    const decoded = try decodeAbiParameters(allocator, encoded, &types);
    defer {
        allocator.free(decoded[0].@"uint256[]");
        allocator.free(decoded);
    }

    try std.testing.expectEqual(@as(usize, 0), decoded[0].@"uint256[]".len);
}
```

### arrays - uint256[] single element

```zig
test "arrays - uint256[] single element" {
    const allocator = std.testing.allocator;

    const arr = [_]u256{42};
    const values = [_]AbiValue{
        .{ .@"uint256[]" = &arr },
    };

    const encoded = try encodeAbiParameters(allocator, &values);
    defer allocator.free(encoded);

    const types = [_]AbiType{.@"uint256[]"};
    const decoded = try decodeAbiParameters(allocator, encoded, &types);
    defer {
        allocator.free(decoded[0].@"uint256[]");
        allocator.free(decoded);
    }

    try std.testing.expectEqual(@as(usize, 1), decoded[0].@"uint256[]".len);
    try std.testing.expectEqual(@as(u256, 42), decoded[0].@"uint256[]"[0]);
}
```

### arrays - bytes32[] empty

```zig
test "arrays - bytes32[] empty" {
    const allocator = std.testing.allocator;

    const arr = [_][32]u8{};
    const values = [_]AbiValue{
        .{ .@"bytes32[]" = &arr },
    };

    const encoded = try encodeAbiParameters(allocator, &values);
    defer allocator.free(encoded);

    const types = [_]AbiType{.@"bytes32[]"};
    const decoded = try decodeAbiParameters(allocator, encoded, &types);
    defer {
        allocator.free(decoded[0].@"bytes32[]");
        allocator.free(decoded);
    }

    try std.testing.expectEqual(@as(usize, 0), decoded[0].@"bytes32[]".len);
}
```

### arrays - bytes32[] single element

```zig
test "arrays - bytes32[] single element" {
    const allocator = std.testing.allocator;

    const arr = [_][32]u8{[_]u8{0x42} ** 32};
    const values = [_]AbiValue{
        .{ .@"bytes32[]" = &arr },
    };

    const encoded = try encodeAbiParameters(allocator, &values);
    defer allocator.free(encoded);

    const types = [_]AbiType{.@"bytes32[]"};
    const decoded = try decodeAbiParameters(allocator, encoded, &types);
    defer {
        allocator.free(decoded[0].@"bytes32[]");
        allocator.free(decoded);
    }

    try std.testing.expectEqual(@as(usize, 1), decoded[0].@"bytes32[]".len);
    try std.testing.expectEqualSlices(u8, &arr[0], &decoded[0].@"bytes32[]"[0]);
}
```

### arrays - address[] empty

```zig
test "arrays - address[] empty" {
    const allocator = std.testing.allocator;

    const arr = [_]address.Address{};
    const values = [_]AbiValue{
        .{ .@"address[]" = &arr },
    };

    const encoded = try encodeAbiParameters(allocator, &values);
    defer allocator.free(encoded);

    const types = [_]AbiType{.@"address[]"};
    const decoded = try decodeAbiParameters(allocator, encoded, &types);
    defer {
        allocator.free(decoded[0].@"address[]");
        allocator.free(decoded);
    }

    try std.testing.expectEqual(@as(usize, 0), decoded[0].@"address[]".len);
}
```

### arrays - address[] single element

```zig
test "arrays - address[] single element" {
    const allocator = std.testing.allocator;

    const addr: address.Address = [_]u8{0x11} ** 20;
    const arr = [_]address.Address{addr};
    const values = [_]AbiValue{
        .{ .@"address[]" = &arr },
    };

    const encoded = try encodeAbiParameters(allocator, &values);
    defer allocator.free(encoded);

    const types = [_]AbiType{.@"address[]"};
    const decoded = try decodeAbiParameters(allocator, encoded, &types);
    defer {
        allocator.free(decoded[0].@"address[]");
        allocator.free(decoded);
    }

    try std.testing.expectEqual(@as(usize, 1), decoded[0].@"address[]".len);
    try std.testing.expectEqualSlices(u8, &addr, &decoded[0].@"address[]"[0]);
}
```

### arrays - string[] empty

```zig
test "arrays - string[] empty" {
    const allocator = std.testing.allocator;

    const arr = [_][]const u8{};
    const values = [_]AbiValue{
        .{ .@"string[]" = &arr },
    };

    const encoded = try encodeAbiParameters(allocator, &values);
    defer allocator.free(encoded);

    const types = [_]AbiType{.@"string[]"};
    const decoded = try decodeAbiParameters(allocator, encoded, &types);
    defer {
        for (decoded[0].@"string[]") |str| {
            allocator.free(str);
        }
        allocator.free(decoded[0].@"string[]");
        allocator.free(decoded);
    }

    try std.testing.expectEqual(@as(usize, 0), decoded[0].@"string[]".len);
}
```

### arrays - string[] single element

```zig
test "arrays - string[] single element" {
    const allocator = std.testing.allocator;

    const arr = [_][]const u8{"hello"};
    const values = [_]AbiValue{
        .{ .@"string[]" = &arr },
    };

    const encoded = try encodeAbiParameters(allocator, &values);
    defer allocator.free(encoded);

    const types = [_]AbiType{.@"string[]"};
    const decoded = try decodeAbiParameters(allocator, encoded, &types);
    defer {
        for (decoded[0].@"string[]") |str| {
            allocator.free(str);
        }
        allocator.free(decoded[0].@"string[]");
        allocator.free(decoded);
    }

    try std.testing.expectEqual(@as(usize, 1), decoded[0].@"string[]".len);
    try std.testing.expectEqualStrings("hello", decoded[0].@"string[]"[0]);
}
```

### nested - tuple in tuple (all static) ((uint256, address), bool)

```zig
test "nested - tuple in tuple (all static) ((uint256, address), bool)" {
    // In ABI encoding, nested tuples flatten: ((uint256, address), bool)  uint256, address, bool
    const allocator = std.testing.allocator;

    const addr: address.Address = [_]u8{0x00} ** 19 ++ [_]u8{0x01};
    const values = [_]AbiValue{
        uint256_value(100),
        addressValue(addr),
        boolValue(true),
    };

    const encoded = try encodeAbiParameters(allocator, &values);
    defer allocator.free(encoded);

    // All static: 32 + 32 + 32 = 96 bytes
    try std.testing.expectEqual(@as(usize, 96), encoded.len);
    try std.testing.expectEqual(@as(u8, 100), encoded[31]); // uint256
    try std.testing.expectEqual(@as(u8, 0x01), encoded[63]); // address
    try std.testing.expectEqual(@as(u8, 1), encoded[95]); // bool

    const types = [_]AbiType{ .uint256, .address, .bool };
    const decoded = try decodeAbiParameters(allocator, encoded, &types);
    defer allocator.free(decoded);

    try std.testing.expectEqual(@as(u256, 100), decoded[0].uint256);
    try std.testing.expectEqual(@as(u8, 0x01), decoded[1].address.bytes[19]);
    try std.testing.expectEqual(true, decoded[2].bool);
}
```

### nested - tuple in tuple with dynamic ((uint256, string), address)

```zig
test "nested - tuple in tuple with dynamic ((uint256, string), address)" {
    // Flattens to: uint256, string, address
    // With dynamic string in middle
    const allocator = std.testing.allocator;

    const addr: address.Address = [_]u8{0x00} ** 19 ++ [_]u8{0x01};
    const values = [_]AbiValue{
        uint256_value(42),
        stringValue("hello"),
        addressValue(addr),
    };

    const encoded = try encodeAbiParameters(allocator, &values);
    defer allocator.free(encoded);

    // Head: 32 (uint256) + 32 (offset) + 32 (address) = 96
    // Tail: 32 (length) + 32 (data padded) = 64
    // Total: 160 bytes
    try std.testing.expectEqual(@as(usize, 160), encoded.len);

    const types = [_]AbiType{ .uint256, .string, .address };
    const decoded = try decodeAbiParameters(allocator, encoded, &types);
    defer {
        allocator.free(decoded[1].string);
        allocator.free(decoded);
    }

    try std.testing.expectEqual(@as(u256, 42), decoded[0].uint256);
    try std.testing.expectEqualStrings("hello", decoded[1].string);
    try std.testing.expectEqual(@as(u8, 0x01), decoded[2].address.bytes[19]);
}
```

### nested - triple nesting (((uint256, bool), address), bytes4)

```zig
test "nested - triple nesting (((uint256, bool), address), bytes4)" {
    // All tuples flatten to: uint256, bool, address, bytes4
    const allocator = std.testing.allocator;

    const addr: address.Address = [_]u8{0x00} ** 19 ++ [_]u8{0x01};
    const values = [_]AbiValue{
        uint256_value(123),
        boolValue(false),
        addressValue(addr),
        AbiValue{ .bytes4 = [_]u8{ 0xde, 0xad, 0xbe, 0xef } },
    };

    const encoded = try encodeAbiParameters(allocator, &values);
    defer allocator.free(encoded);

    // All static: 4 * 32 = 128 bytes
    try std.testing.expectEqual(@as(usize, 128), encoded.len);

    const types = [_]AbiType{ .uint256, .bool, .address, .bytes4 };
    const decoded = try decodeAbiParameters(allocator, encoded, &types);
    defer allocator.free(decoded);

    try std.testing.expectEqual(@as(u256, 123), decoded[0].uint256);
    try std.testing.expectEqual(false, decoded[1].bool);
    try std.testing.expectEqual(@as(u8, 0x01), decoded[2].address.bytes[19]);
    try std.testing.expectEqual(@as(u8, 0xde), decoded[3].bytes4[0]);
}
```

### nested - tuple with array (uint256[], address) - tuple flattens

```zig
test "nested - tuple with array (uint256[], address) - tuple flattens" {
    // Flattens to: uint256[], address
    const allocator = std.testing.allocator;

    const addr: address.Address = [_]u8{0x00} ** 19 ++ [_]u8{0x01};
    const arr = [_]u256{ 1, 2, 3 };
    const values = [_]AbiValue{
        .{ .@"uint256[]" = &arr },
        addressValue(addr),
    };

    const encoded = try encodeAbiParameters(allocator, &values);
    defer allocator.free(encoded);

    // Head: 32 (offset) + 32 (address) = 64
    // Tail: 32 (length) + 3*32 (data) = 128
    // Total: 192 bytes
    try std.testing.expectEqual(@as(usize, 192), encoded.len);

    const types = [_]AbiType{ .@"uint256[]", .address };
    const decoded = try decodeAbiParameters(allocator, encoded, &types);
    defer {
        allocator.free(decoded[0].@"uint256[]");
        allocator.free(decoded);
    }

    try std.testing.expectEqual(@as(usize, 3), decoded[0].@"uint256[]".len);
    try std.testing.expectEqual(@as(u256, 1), decoded[0].@"uint256[]"[0]);
    try std.testing.expectEqual(@as(u256, 2), decoded[0].@"uint256[]"[1]);
    try std.testing.expectEqual(@as(u256, 3), decoded[0].@"uint256[]"[2]);
    try std.testing.expectEqual(@as(u8, 0x01), decoded[1].address.bytes[19]);
}
```

### nested - tuple with multiple arrays (address, uint256[], bool[])

```zig
test "nested - tuple with multiple arrays (address, uint256[], bool[])" {
    // Multiple dynamic types require correct offset calculation
    const allocator = std.testing.allocator;

    const addr: address.Address = [_]u8{0x00} ** 19 ++ [_]u8{0x01};
    const nums = [_]u256{ 10, 20 };
    const bools = [_]bool{ true, false, true };

    const values = [_]AbiValue{
        addressValue(addr),
        .{ .@"uint256[]" = &nums },
        .{ .@"bool[]" = &bools },
    };

    const encoded = try encodeAbiParameters(allocator, &values);
    defer allocator.free(encoded);

    // Head: 32 (address) + 32 (offset1) + 32 (offset2) = 96
    // Tail1: 32 (length) + 2*32 (nums) = 96
    // Tail2: 32 (length) + 3*32 (bools) = 128
    // Total: 320 bytes
    try std.testing.expectEqual(@as(usize, 320), encoded.len);

    const types = [_]AbiType{ .address, .@"uint256[]", .@"bool[]" };
    const decoded = try decodeAbiParameters(allocator, encoded, &types);
    defer {
        allocator.free(decoded[1].@"uint256[]");
        allocator.free(decoded[2].@"bool[]");
        allocator.free(decoded);
    }

    try std.testing.expectEqual(@as(u8, 0x01), decoded[0].address.bytes[19]);
    try std.testing.expectEqual(@as(usize, 2), decoded[1].@"uint256[]".len);
    try std.testing.expectEqual(@as(u256, 10), decoded[1].@"uint256[]"[0]);
    try std.testing.expectEqual(@as(u256, 20), decoded[1].@"uint256[]"[1]);
    try std.testing.expectEqual(@as(usize, 3), decoded[2].@"bool[]".len);
    try std.testing.expectEqual(true, decoded[2].@"bool[]"[0]);
    try std.testing.expectEqual(false, decoded[2].@"bool[]"[1]);
    try std.testing.expectEqual(true, decoded[2].@"bool[]"[2]);
}
```

### nested - complex mixed (address, uint256[], (bool, string))

```zig
test "nested - complex mixed (address, uint256[], (bool, string))" {
    // Flattens to: address, uint256[], bool, string
    // Two dynamic types: uint256[] and string
    const allocator = std.testing.allocator;

    const addr: address.Address = [_]u8{0x00} ** 19 ++ [_]u8{0x01};
    const nums = [_]u256{100};

    const values = [_]AbiValue{
        addressValue(addr),
        .{ .@"uint256[]" = &nums },
        boolValue(true),
        stringValue("test"),
    };

    const encoded = try encodeAbiParameters(allocator, &values);
    defer allocator.free(encoded);

    // Head: 32 (address) + 32 (offset1) + 32 (bool) + 32 (offset2) = 128
    // Tail1: 32 (length) + 32 (nums[0]) = 64
    // Tail2: 32 (length) + 32 (string padded) = 64
    // Total: 256 bytes
    try std.testing.expectEqual(@as(usize, 256), encoded.len);

    const types = [_]AbiType{ .address, .@"uint256[]", .bool, .string };
    const decoded = try decodeAbiParameters(allocator, encoded, &types);
    defer {
        allocator.free(decoded[1].@"uint256[]");
        allocator.free(decoded[3].string);
        allocator.free(decoded);
    }

    try std.testing.expectEqual(@as(u8, 0x01), decoded[0].address.bytes[19]);
    try std.testing.expectEqual(@as(usize, 1), decoded[1].@"uint256[]".len);
    try std.testing.expectEqual(@as(u256, 100), decoded[1].@"uint256[]"[0]);
    try std.testing.expectEqual(true, decoded[2].bool);
    try std.testing.expectEqualStrings("test", decoded[3].string);
}
```

### nested - empty arrays in tuple (uint256[], address[])

```zig
test "nested - empty arrays in tuple (uint256[], address[])" {
    // Both empty dynamic arrays
    const allocator = std.testing.allocator;

    const empty_nums = [_]u256{};
    const empty_addrs = [_]address.Address{};

    const values = [_]AbiValue{
        .{ .@"uint256[]" = &empty_nums },
        .{ .@"address[]" = &empty_addrs },
    };

    const encoded = try encodeAbiParameters(allocator, &values);
    defer allocator.free(encoded);

    // Head: 32 (offset1) + 32 (offset2) = 64
    // Tail1: 32 (length=0) = 32
    // Tail2: 32 (length=0) = 32
    // Total: 128 bytes
    try std.testing.expectEqual(@as(usize, 128), encoded.len);

    const types = [_]AbiType{ .@"uint256[]", .@"address[]" };
    const decoded = try decodeAbiParameters(allocator, encoded, &types);
    defer {
        allocator.free(decoded[0].@"uint256[]");
        allocator.free(decoded[1].@"address[]");
        allocator.free(decoded);
    }

    try std.testing.expectEqual(@as(usize, 0), decoded[0].@"uint256[]".len);
    try std.testing.expectEqual(@as(usize, 0), decoded[1].@"address[]".len);
}
```

### nested - dynamic array of arrays uint256[][]

```zig
test "nested - dynamic array of arrays uint256[][]" {
    // Nested array: outer array is dynamic, inner arrays are dynamic
    const allocator = std.testing.allocator;

    const arr1 = [_]u256{ 1, 2 };
    const arr2 = [_]u256{ 3, 4, 5 };
    const nested = [_][]const u256{ &arr1, &arr2 };

    const values = [_]AbiValue{
        .{ .@"uint256[][]" = &nested },
    };

    const encoded = try encodeAbiParameters(allocator, &values);
    defer allocator.free(encoded);

    // Head: 32 (offset to outer array) = 32
    // Outer array: 32 (length=2) + 32 (offset to arr1) + 32 (offset to arr2) = 96
    // arr1: 32 (length=2) + 2*32 (elements) = 96
    // arr2: 32 (length=3) + 3*32 (elements) = 128
    // Total: 32 + 96 + 96 + 128 = 352 bytes
    try std.testing.expectEqual(@as(usize, 352), encoded.len);

    const types = [_]AbiType{.@"uint256[][]"};
    const decoded = try decodeAbiParameters(allocator, encoded, &types);
    defer {
        for (decoded[0].@"uint256[][]") |arr| {
            allocator.free(arr);
        }
        allocator.free(decoded[0].@"uint256[][]");
        allocator.free(decoded);
    }

    try std.testing.expectEqual(@as(usize, 2), decoded[0].@"uint256[][]".len);
    try std.testing.expectEqual(@as(usize, 2), decoded[0].@"uint256[][]"[0].len);
    try std.testing.expectEqual(@as(u256, 1), decoded[0].@"uint256[][]"[0][0]);
    try std.testing.expectEqual(@as(u256, 2), decoded[0].@"uint256[][]"[0][1]);
    try std.testing.expectEqual(@as(usize, 3), decoded[0].@"uint256[][]"[1].len);
    try std.testing.expectEqual(@as(u256, 3), decoded[0].@"uint256[][]"[1][0]);
    try std.testing.expectEqual(@as(u256, 4), decoded[0].@"uint256[][]"[1][1]);
    try std.testing.expectEqual(@as(u256, 5), decoded[0].@"uint256[][]"[1][2]);
}
```

### nested - empty nested array uint256[][]

```zig
test "nested - empty nested array uint256[][]" {
    // Empty outer array
    const allocator = std.testing.allocator;

    const empty_nested = [_][]const u256{};

    const values = [_]AbiValue{
        .{ .@"uint256[][]" = &empty_nested },
    };

    const encoded = try encodeAbiParameters(allocator, &values);
    defer allocator.free(encoded);

    // Head: 32 (offset) = 32
    // Outer array: 32 (length=0) = 32
    // Total: 64 bytes
    try std.testing.expectEqual(@as(usize, 64), encoded.len);

    const types = [_]AbiType{.@"uint256[][]"};
    const decoded = try decodeAbiParameters(allocator, encoded, &types);
    defer {
        for (decoded[0].@"uint256[][]") |arr| {
            allocator.free(arr);
        }
        allocator.free(decoded[0].@"uint256[][]");
        allocator.free(decoded);
    }

    try std.testing.expectEqual(@as(usize, 0), decoded[0].@"uint256[][]".len);
}
```

### nested - nested array with empty inner arrays

```zig
test "nested - nested array with empty inner arrays" {
    // Outer array with empty inner arrays
    const allocator = std.testing.allocator;

    const arr1 = [_]u256{};
    const arr2 = [_]u256{};
    const nested = [_][]const u256{ &arr1, &arr2 };

    const values = [_]AbiValue{
        .{ .@"uint256[][]" = &nested },
    };

    const encoded = try encodeAbiParameters(allocator, &values);
    defer allocator.free(encoded);

    // Head: 32 (offset) = 32
    // Outer array: 32 (length=2) + 32 (offset to arr1) + 32 (offset to arr2) = 96
    // arr1: 32 (length=0) = 32
    // arr2: 32 (length=0) = 32
    // Total: 32 + 96 + 32 + 32 = 192 bytes
    try std.testing.expectEqual(@as(usize, 192), encoded.len);

    const types = [_]AbiType{.@"uint256[][]"};
    const decoded = try decodeAbiParameters(allocator, encoded, &types);
    defer {
        for (decoded[0].@"uint256[][]") |arr| {
            allocator.free(arr);
        }
        allocator.free(decoded[0].@"uint256[][]");
        allocator.free(decoded);
    }

    try std.testing.expectEqual(@as(usize, 2), decoded[0].@"uint256[][]".len);
    try std.testing.expectEqual(@as(usize, 0), decoded[0].@"uint256[][]"[0].len);
    try std.testing.expectEqual(@as(usize, 0), decoded[0].@"uint256[][]"[1].len);
}
```

### FunctionDefinition - get_signature for transfer

```zig
test "FunctionDefinition - get_signature for transfer" {
    const allocator = std.testing.allocator;
    const func = CommonPatterns.erc20_transfer();

    const signature = try func.get_signature(allocator);
    defer allocator.free(signature);

    try std.testing.expectEqualStrings("transfer(address,uint256)", signature);
}
```

### FunctionDefinition - get_signature for balanceOf

```zig
test "FunctionDefinition - get_signature for balanceOf" {
    const allocator = std.testing.allocator;
    const func = CommonPatterns.erc20_balance_of();

    const signature = try func.get_signature(allocator);
    defer allocator.free(signature);

    try std.testing.expectEqualStrings("balanceOf(address)", signature);
}
```

### FunctionDefinition - get_signature for approve

```zig
test "FunctionDefinition - get_signature for approve" {
    const allocator = std.testing.allocator;
    const func = CommonPatterns.erc20_approve();

    const signature = try func.get_signature(allocator);
    defer allocator.free(signature);

    try std.testing.expectEqualStrings("approve(address,uint256)", signature);
}
```

### FunctionDefinition - get_selector transfer

```zig
test "FunctionDefinition - get_selector transfer" {
    const allocator = std.testing.allocator;
    const func = CommonPatterns.erc20_transfer();

    const selector = try func.get_selector(allocator);
    const expected = [_]u8{ 0xa9, 0x05, 0x9c, 0xbb };

    try std.testing.expectEqualSlices(u8, &expected, &selector);
}
```

### FunctionDefinition - get_selector balanceOf

```zig
test "FunctionDefinition - get_selector balanceOf" {
    const allocator = std.testing.allocator;
    const func = CommonPatterns.erc20_balance_of();

    const selector = try func.get_selector(allocator);
    const expected = [_]u8{ 0x70, 0xa0, 0x82, 0x31 };

    try std.testing.expectEqualSlices(u8, &expected, &selector);
}
```

### FunctionDefinition - get_selector approve

```zig
test "FunctionDefinition - get_selector approve" {
    const allocator = std.testing.allocator;
    const func = CommonPatterns.erc20_approve();

    const selector = try func.get_selector(allocator);
    const expected = [_]u8{ 0x09, 0x5e, 0xa7, 0xb3 };

    try std.testing.expectEqualSlices(u8, &expected, &selector);
}
```

### FunctionDefinition - encode_params transfer

```zig
test "FunctionDefinition - encode_params transfer" {
    const allocator = std.testing.allocator;
    const func = CommonPatterns.erc20_transfer();

    const args = [_]AbiValue{
        addressValue([_]u8{0x74} ++ [_]u8{0x2d} ++ [_]u8{0x35} ++ [_]u8{0xcc} ++ [_]u8{0x66} ++ [_]u8{0x34} ++ [_]u8{0xc0} ++ [_]u8{0x53} ++ [_]u8{0x29} ++ [_]u8{0x25} ++ [_]u8{0xa3} ++ [_]u8{0xb8} ++ [_]u8{0x44} ++ [_]u8{0xbc} ++ [_]u8{0x9e} ++ [_]u8{0x75} ++ [_]u8{0x95} ++ [_]u8{0xf2} ++ [_]u8{0x51} ++ [_]u8{0xe3}),
        uint256_value(100),
    };

    const encoded = try func.encode_params(allocator, &args);
    defer allocator.free(encoded);

    // Should have selector (4 bytes) + params (64 bytes)
    try std.testing.expectEqual(@as(usize, 68), encoded.len);

    // Check selector
    const expected_selector = [_]u8{ 0xa9, 0x05, 0x9c, 0xbb };
    try std.testing.expectEqualSlices(u8, &expected_selector, encoded[0..4]);
}
```

### FunctionDefinition - decode_params transfer

```zig
test "FunctionDefinition - decode_params transfer" {
    const allocator = std.testing.allocator;
    const func = CommonPatterns.erc20_transfer();

    // First encode
    const args = [_]AbiValue{
        addressValue([_]u8{0x12} ** 20),
        uint256_value(1000),
    };

    const encoded = try func.encode_params(allocator, &args);
    defer allocator.free(encoded);

    // Then decode
    const decoded = try func.decode_params(allocator, encoded);
    defer allocator.free(decoded);

    try std.testing.expectEqual(@as(usize, 2), decoded.len);
    try std.testing.expectEqualSlices(u8, &args[0].address, &decoded[0].address);
    try std.testing.expectEqual(@as(u256, 1000), decoded[1].uint256);
}
```

### FunctionDefinition - encode_result balanceOf

```zig
test "FunctionDefinition - encode_result balanceOf" {
    const allocator = std.testing.allocator;
    const func = CommonPatterns.erc20_balance_of();

    const return_values = [_]AbiValue{
        uint256_value(5000),
    };

    const encoded = try func.encode_result(allocator, &return_values);
    defer allocator.free(encoded);

    try std.testing.expectEqual(@as(usize, 32), encoded.len);
}
```

### FunctionDefinition - decode_result balanceOf

```zig
test "FunctionDefinition - decode_result balanceOf" {
    const allocator = std.testing.allocator;
    const func = CommonPatterns.erc20_balance_of();

    // Encode a return value
    const return_values = [_]AbiValue{
        uint256_value(5000),
    };

    const encoded = try func.encode_result(allocator, &return_values);
    defer allocator.free(encoded);

    // Decode it back
    const decoded = try func.decode_result(allocator, encoded);
    defer allocator.free(decoded);

    try std.testing.expectEqual(@as(usize, 1), decoded.len);
    try std.testing.expectEqual(@as(u256, 5000), decoded[0].uint256);
}
```

### FunctionDefinition - function with no params

```zig
test "FunctionDefinition - function with no params" {
    const allocator = std.testing.allocator;

    const func = FunctionDefinition{
        .name = "totalSupply",
        .inputs = &[_]AbiType{},
        .outputs = &[_]AbiType{.uint256},
        .state_mutability = .view,
    };

    const signature = try func.get_signature(allocator);
    defer allocator.free(signature);

    try std.testing.expectEqualStrings("totalSupply()", signature);

    const selector = try func.get_selector(allocator);
    const expected = [_]u8{ 0x18, 0x16, 0x0d, 0xdd };
    try std.testing.expectEqualSlices(u8, &expected, &selector);
}
```

### FunctionDefinition - function with no outputs

```zig
test "FunctionDefinition - function with no outputs" {
    const allocator = std.testing.allocator;

    const func = FunctionDefinition{
        .name = "burn",
        .inputs = &[_]AbiType{.uint256},
        .outputs = &[_]AbiType{},
        .state_mutability = .nonpayable,
    };

    const signature = try func.get_signature(allocator);
    defer allocator.free(signature);

    try std.testing.expectEqualStrings("burn(uint256)", signature);

    const args = [_]AbiValue{
        uint256_value(100),
    };

    const encoded = try func.encode_params(allocator, &args);
    defer allocator.free(encoded);

    try std.testing.expectEqual(@as(usize, 36), encoded.len); // 4 selector + 32 param
}
```

### FunctionDefinition - complex function with arrays

```zig
test "FunctionDefinition - complex function with arrays" {
    const allocator = std.testing.allocator;

    const func = FunctionDefinition{
        .name = "multiTransfer",
        .inputs = &[_]AbiType{ .@"address[]", .@"uint256[]" },
        .outputs = &[_]AbiType{.bool},
        .state_mutability = .nonpayable,
    };

    const signature = try func.get_signature(allocator);
    defer allocator.free(signature);

    try std.testing.expectEqualStrings("multiTransfer(address[],uint256[])", signature);
}
```

### FunctionDefinition - round trip encode/decode

```zig
test "FunctionDefinition - round trip encode/decode" {
    const allocator = std.testing.allocator;
    const func = CommonPatterns.erc20_approve();

    // Original arguments
    const args = [_]AbiValue{
        addressValue([_]u8{0xAB} ** 20),
        uint256_value(999999),
    };

    // Encode
    const encoded = try func.encode_params(allocator, &args);
    defer allocator.free(encoded);

    // Decode
    const decoded = try func.decode_params(allocator, encoded);
    defer allocator.free(decoded);

    // Verify round trip
    try std.testing.expectEqual(@as(usize, 2), decoded.len);
    try std.testing.expectEqualSlices(u8, &args[0].address, &decoded[0].address);
    try std.testing.expectEqual(@as(u256, 999999), decoded[1].uint256);
}
```

### FunctionDefinition - all known ERC20 selectors

```zig
test "FunctionDefinition - all known ERC20 selectors" {
    const allocator = std.testing.allocator;

    // transfer
    {
        const func = CommonPatterns.erc20_transfer();
        const selector = try func.get_selector(allocator);
        try std.testing.expectEqualSlices(u8, &[_]u8{ 0xa9, 0x05, 0x9c, 0xbb }, &selector);
    }

    // balanceOf
    {
        const func = CommonPatterns.erc20_balance_of();
        const selector = try func.get_selector(allocator);
        try std.testing.expectEqualSlices(u8, &[_]u8{ 0x70, 0xa0, 0x82, 0x31 }, &selector);
    }

    // approve
    {
        const func = CommonPatterns.erc20_approve();
        const selector = try func.get_selector(allocator);
        try std.testing.expectEqualSlices(u8, &[_]u8{ 0x09, 0x5e, 0xa7, 0xb3 }, &selector);
    }
}
```

### error - signature generation

```zig
test "error - signature generation" {
    const allocator = std.testing.allocator;

    const err = ErrorDefinition{
        .name = "InsufficientBalance",
        .inputs = &[_]AbiType{ .uint256, .uint256 },
    };

    const signature = try err.get_signature(allocator);
    defer allocator.free(signature);

    try std.testing.expectEqualStrings("InsufficientBalance(uint256,uint256)", signature);
}
```

### error - selector computation

```zig
test "error - selector computation" {
    const allocator = std.testing.allocator;

    const err = ErrorDefinition{
        .name = "Unauthorized",
        .inputs = &[_]AbiType{},
    };

    const selector = try err.get_selector(allocator);

    // Known selector for "Unauthorized()"
    const signature = "Unauthorized()";
    const expected = computeSelector(signature);
    try std.testing.expectEqualSlices(u8, &expected, &selector);
}
```

### error - encode data with params

```zig
test "error - encode data with params" {
    const allocator = std.testing.allocator;

    const err = ErrorDefinition{
        .name = "InsufficientBalance",
        .inputs = &[_]AbiType{ .uint256, .uint256 },
    };

    const values = [_]AbiValue{
        uint256_value(100),
        uint256_value(200),
    };

    const encoded = try err.encode_data(allocator, &values);
    defer allocator.free(encoded);

    // Should be 4-byte selector + 64 bytes (2 uint256s)
    try std.testing.expectEqual(@as(usize, 68), encoded.len);

    // Verify selector matches
    const expected_selector = try err.get_selector(allocator);
    try std.testing.expectEqualSlices(u8, &expected_selector, encoded[0..4]);
}
```

### error - encode data with no params

```zig
test "error - encode data with no params" {
    const allocator = std.testing.allocator;

    const err = ErrorDefinition{
        .name = "Unauthorized",
        .inputs = &[_]AbiType{},
    };

    const values = [_]AbiValue{};
    const encoded = try err.encode_data(allocator, &values);
    defer allocator.free(encoded);

    // Should be just 4-byte selector
    try std.testing.expectEqual(@as(usize, 4), encoded.len);
}
```

### error - decode data

```zig
test "error - decode data" {
    const allocator = std.testing.allocator;

    const err = ErrorDefinition{
        .name = "InsufficientBalance",
        .inputs = &[_]AbiType{ .uint256, .uint256 },
    };

    // Encode first
    const values = [_]AbiValue{
        uint256_value(100),
        uint256_value(200),
    };
    const encoded = try err.encode_data(allocator, &values);
    defer allocator.free(encoded);

    // Decode
    const decoded = try err.decode_data(allocator, encoded);
    defer {
        for (decoded) |value| {
            switch (value) {
                .string, .bytes => |slice| allocator.free(slice),
                else => {},
            }
        }
        allocator.free(decoded);
    }

    try std.testing.expectEqual(@as(usize, 2), decoded.len);
    try std.testing.expectEqual(@as(u256, 100), decoded[0].uint256);
    try std.testing.expectEqual(@as(u256, 200), decoded[1].uint256);
}
```

### error - decode data with invalid selector

```zig
test "error - decode data with invalid selector" {
    const allocator = std.testing.allocator;

    const err = ErrorDefinition{
        .name = "InsufficientBalance",
        .inputs = &[_]AbiType{ .uint256, .uint256 },
    };

    // Create data with wrong selector
    const wrong_selector = [_]u8{ 0xFF, 0xFF, 0xFF, 0xFF };
    var data = std.ArrayList(u8).init(allocator);
    defer data.deinit();
    try data.appendSlice(&wrong_selector);
    try data.appendSlice(&[_]u8{0} ** 64); // dummy params

    const result = err.decode_data(allocator, data.items);
    try std.testing.expectError(AbiError.InvalidSelector, result);
}
```

### error - decode data too short

```zig
test "error - decode data too short" {
    const allocator = std.testing.allocator;

    const err = ErrorDefinition{
        .name = "Unauthorized",
        .inputs = &[_]AbiType{},
    };

    const data = [_]u8{ 0x01, 0x02 }; // Only 2 bytes
    const result = err.decode_data(allocator, &data);
    try std.testing.expectError(AbiError.DataTooSmall, result);
}
```

### error - complex types

```zig
test "error - complex types" {
    const allocator = std.testing.allocator;

    const err = ErrorDefinition{
        .name = "TransferFailed",
        .inputs = &[_]AbiType{ .address, .uint256, .string },
    };

    const signature = try err.get_signature(allocator);
    defer allocator.free(signature);

    try std.testing.expectEqualStrings("TransferFailed(address,uint256,string)", signature);
}
```

### constructor - encode params with no params

```zig
test "constructor - encode params with no params" {
    const allocator = std.testing.allocator;

    const constructor = ConstructorDefinition{
        .inputs = &[_]AbiType{},
        .state_mutability = .nonpayable,
    };

    const values = [_]AbiValue{};
    const encoded = try constructor.encode_data(allocator, &values);
    defer allocator.free(encoded);

    // Empty encoding
    try std.testing.expectEqual(@as(usize, 0), encoded.len);
}
```

### constructor - encode params with single param

```zig
test "constructor - encode params with single param" {
    const allocator = std.testing.allocator;

    const constructor = ConstructorDefinition{
        .inputs = &[_]AbiType{.uint256},
        .state_mutability = .nonpayable,
    };

    const values = [_]AbiValue{
        uint256_value(123),
    };

    const encoded = try constructor.encode_data(allocator, &values);
    defer allocator.free(encoded);

    // Should be 32 bytes (1 uint256)
    try std.testing.expectEqual(@as(usize, 32), encoded.len);

    // Verify value
    const decoded = try constructor.decode_data(allocator, encoded);
    defer {
        for (decoded) |value| {
            switch (value) {
                .string, .bytes => |slice| allocator.free(slice),
                else => {},
            }
        }
        allocator.free(decoded);
    }

    try std.testing.expectEqual(@as(usize, 1), decoded.len);
    try std.testing.expectEqual(@as(u256, 123), decoded[0].uint256);
}
```

### constructor - encode params with multiple params

```zig
test "constructor - encode params with multiple params" {
    const allocator = std.testing.allocator;

    const constructor = ConstructorDefinition{
        .inputs = &[_]AbiType{ .address, .uint256, .bool },
        .state_mutability = .nonpayable,
    };

    const addr = [_]u8{0x12} ** 20;
    const values = [_]AbiValue{
        addressValue(addr),
        uint256_value(1000),
        boolValue(true),
    };

    const encoded = try constructor.encode_data(allocator, &values);
    defer allocator.free(encoded);

    // Should be 96 bytes (3 * 32)
    try std.testing.expectEqual(@as(usize, 96), encoded.len);
}
```

### constructor - encode params with dynamic types

```zig
test "constructor - encode params with dynamic types" {
    const allocator = std.testing.allocator;

    const constructor = ConstructorDefinition{
        .inputs = &[_]AbiType{ .string, .uint256 },
        .state_mutability = .nonpayable,
    };

    const values = [_]AbiValue{
        stringValue("Hello"),
        uint256_value(42),
    };

    const encoded = try constructor.encode_data(allocator, &values);
    defer allocator.free(encoded);

    // Decode to verify
    const decoded = try constructor.decode_data(allocator, encoded);
    defer {
        for (decoded) |value| {
            switch (value) {
                .string, .bytes => |slice| allocator.free(slice),
                else => {},
            }
        }
        allocator.free(decoded);
    }

    try std.testing.expectEqual(@as(usize, 2), decoded.len);
    try std.testing.expectEqualStrings("Hello", decoded[0].string);
    try std.testing.expectEqual(@as(u256, 42), decoded[1].uint256);
}
```

### constructor - decode params

```zig
test "constructor - decode params" {
    const allocator = std.testing.allocator;

    const constructor = ConstructorDefinition{
        .inputs = &[_]AbiType{ .uint256, .address },
        .state_mutability = .nonpayable,
    };

    // Encode
    const addr = [_]u8{0xAB} ** 20;
    const values = [_]AbiValue{
        uint256_value(999),
        addressValue(addr),
    };
    const encoded = try constructor.encode_data(allocator, &values);
    defer allocator.free(encoded);

    // Decode
    const decoded = try constructor.decode_data(allocator, encoded);
    defer {
        for (decoded) |value| {
            switch (value) {
                .string, .bytes => |slice| allocator.free(slice),
                else => {},
            }
        }
        allocator.free(decoded);
    }

    try std.testing.expectEqual(@as(usize, 2), decoded.len);
    try std.testing.expectEqual(@as(u256, 999), decoded[0].uint256);
    try std.testing.expectEqualSlices(u8, &addr, &decoded[1].address);
}
```

### Event - signature generation

```zig
test "Event - signature generation" {
    const allocator = std.testing.allocator;

    // Test ERC20 Transfer event
    const params = [_]EventParameter{
        .{ .type_name = "address", .indexed = true, .name = "from" },
        .{ .type_name = "address", .indexed = true, .name = "to" },
        .{ .type_name = "uint256", .indexed = false, .name = "value" },
    };

    const event = EventDefinition{
        .name = "Transfer",
        .inputs = &params,
        .anonymous = false,
    };

    const signature = try createEventSignature(allocator, event);
    defer allocator.free(signature);

    try std.testing.expectEqualStrings("Transfer(address,address,uint256)", signature);
}
```

### Event - selector for Transfer event

```zig
test "Event - selector for Transfer event" {
    const allocator = std.testing.allocator;

    const params = [_]EventParameter{
        .{ .type_name = "address", .indexed = true },
        .{ .type_name = "address", .indexed = true },
        .{ .type_name = "uint256", .indexed = false },
    };

    const event = EventDefinition{
        .name = "Transfer",
        .inputs = &params,
    };

    const selector = try getEventSelector(allocator, event);

    // Known Transfer event selector
    // keccak256("Transfer(address,address,uint256)") =
    // 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef
    const expected = [_]u8{
        0xdd, 0xf2, 0x52, 0xad, 0x1b, 0xe2, 0xc8, 0x9b,
        0x69, 0xc2, 0xb0, 0x68, 0xfc, 0x37, 0x8d, 0xaa,
        0x95, 0x2b, 0xa7, 0x7f, 0x16, 0x3c, 0x4a, 0x11,
        0x62, 0x8f, 0x55, 0xa4, 0xdf, 0x52, 0x3b, 0x3e,
    };

    try std.testing.expectEqualSlices(u8, &expected, &selector);
}
```

### Event - selector for Approval event

```zig
test "Event - selector for Approval event" {
    const allocator = std.testing.allocator;

    const params = [_]EventParameter{
        .{ .type_name = "address", .indexed = true },
        .{ .type_name = "address", .indexed = true },
        .{ .type_name = "uint256", .indexed = false },
    };

    const event = EventDefinition{
        .name = "Approval",
        .inputs = &params,
    };

    const selector = try getEventSelector(allocator, event);

    // Known Approval event selector
    // keccak256("Approval(address,address,uint256)") =
    // 0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925
    const expected = [_]u8{
        0x8c, 0x5b, 0xe1, 0xe5, 0xeb, 0xec, 0x7d, 0x5b,
        0xd1, 0x4f, 0x71, 0x42, 0x7d, 0x1e, 0x84, 0xf3,
        0xdd, 0x03, 0x14, 0xc0, 0xf7, 0xb2, 0x29, 0x1e,
        0x5b, 0x20, 0x0a, 0xc8, 0xc7, 0xc3, 0xb9, 0x25,
    };

    try std.testing.expectEqualSlices(u8, &expected, &selector);
}
```

### Event - encode topics with 2 indexed addresses

```zig
test "Event - encode topics with 2 indexed addresses" {
    const allocator = std.testing.allocator;

    const params = [_]EventParameter{
        .{ .type_name = "address", .indexed = true },
        .{ .type_name = "address", .indexed = true },
        .{ .type_name = "uint256", .indexed = false },
    };

    const event = EventDefinition{
        .name = "Transfer",
        .inputs = &params,
    };

    const from_addr: [20]u8 = [_]u8{0x11} ** 20;
    const to_addr: [20]u8 = [_]u8{0x22} ** 20;

    const indexed = [_]AbiValue{
        addressValue(from_addr),
        addressValue(to_addr),
    };

    const topics = try encodeEventTopicsFromDef(allocator, event, &indexed);
    defer {
        for (topics) |topic| {
            allocator.free(topic);
        }
        allocator.free(topics);
    }

    // Should have topic0 + 2 indexed params = 3 topics
    try std.testing.expectEqual(@as(usize, 3), topics.len);
    try std.testing.expectEqual(@as(usize, 32), topics[0].len);
    try std.testing.expectEqual(@as(usize, 32), topics[1].len);
    try std.testing.expectEqual(@as(usize, 32), topics[2].len);

    // Verify topic0 is event selector
    const selector = try getEventSelector(allocator, event);
    try std.testing.expectEqualSlices(u8, &selector, topics[0]);

    // Verify topic1 is from address (padded)
    for (topics[1][0..12]) |byte| {
        try std.testing.expectEqual(@as(u8, 0), byte);
    }
    try std.testing.expectEqualSlices(u8, &from_addr, topics[1][12..32]);

    // Verify topic2 is to address (padded)
    for (topics[2][0..12]) |byte| {
        try std.testing.expectEqual(@as(u8, 0), byte);
    }
    try std.testing.expectEqualSlices(u8, &to_addr, topics[2][12..32]);
}
```

### Event - anonymous event (no topic0)

```zig
test "Event - anonymous event (no topic0)" {
    const allocator = std.testing.allocator;

    const params = [_]EventParameter{
        .{ .type_name = "address", .indexed = true },
        .{ .type_name = "uint256", .indexed = true },
    };

    const event = EventDefinition{
        .name = "AnonymousEvent",
        .inputs = &params,
        .anonymous = true,
    };

    const addr: [20]u8 = [_]u8{0xaa} ** 20;
    const indexed = [_]AbiValue{
        addressValue(addr),
        .{ .uint256 = 42 },
    };

    const topics = try encodeEventTopicsFromDef(allocator, event, &indexed);
    defer {
        for (topics) |topic| {
            allocator.free(topic);
        }
        allocator.free(topics);
    }

    // Anonymous event has NO topic0, just indexed params
    try std.testing.expectEqual(@as(usize, 2), topics.len);
}
```

### Event - dynamic indexed param (string) is hashed

```zig
test "Event - dynamic indexed param (string) is hashed" {
    const allocator = std.testing.allocator;

    const params = [_]EventParameter{
        .{ .type_name = "string", .indexed = true },
        .{ .type_name = "uint256", .indexed = false },
    };

    const event = EventDefinition{
        .name = "StringEvent",
        .inputs = &params,
        .anonymous = false,
    };

    const test_string = "hello";
    const str_value = stringValue(test_string);
    const indexed = [_]AbiValue{str_value};

    const topics = try encodeEventTopicsFromDef(allocator, event, &indexed);
    defer {
        for (topics) |topic| {
            allocator.free(topic);
        }
        allocator.free(topics);
    }

    // topic0 + 1 indexed string param
    try std.testing.expectEqual(@as(usize, 2), topics.len);

    // topic1 should be hash of the encoded string (not the string itself)
    // Verify it's not just zeros
    var all_zeros = true;
    for (topics[1]) |byte| {
        if (byte != 0) {
            all_zeros = false;
            break;
        }
    }
    try std.testing.expect(!all_zeros); // Should be a hash, not zeros
}
```

### Event - decode log with indexed and non-indexed params

```zig
test "Event - decode log with indexed and non-indexed params" {
    const allocator = std.testing.allocator;

    const params = [_]EventParameter{
        .{ .type_name = "address", .indexed = true },
        .{ .type_name = "address", .indexed = true },
        .{ .type_name = "uint256", .indexed = false },
    };

    const event = EventDefinition{
        .name = "Transfer",
        .inputs = &params,
    };

    // Create topics
    const from_addr: [20]u8 = [_]u8{0x11} ** 20;
    const to_addr: [20]u8 = [_]u8{0x22} ** 20;
    const indexed = [_]AbiValue{
        addressValue(from_addr),
        addressValue(to_addr),
    };

    const topics = try encodeEventTopicsFromDef(allocator, event, &indexed);
    defer {
        for (topics) |topic| {
            allocator.free(topic);
        }
        allocator.free(topics);
    }

    // Create data with non-indexed uint256 value
    const value: u256 = 1000;
    const data_values = [_]AbiValue{.{ .uint256 = value }};
    const data = try encodeAbiParameters(allocator, &data_values);
    defer allocator.free(data);

    // Decode the log
    const decoded = try decodeEventLog(allocator, event, data, topics);
    defer allocator.free(decoded);

    try std.testing.expectEqual(@as(usize, 3), decoded.len);

    // Check decoded values
    try std.testing.expectEqualSlices(u8, &from_addr, &decoded[0].address);
    try std.testing.expectEqualSlices(u8, &to_addr, &decoded[1].address);
    try std.testing.expectEqual(value, decoded[2].uint256);
}
```

### Event - decode log invalid selector

```zig
test "Event - decode log invalid selector" {
    const allocator = std.testing.allocator;

    const params = [_]EventParameter{
        .{ .type_name = "address", .indexed = true },
    };

    const event = EventDefinition{
        .name = "Transfer",
        .inputs = &params,
    };

    // Create wrong topic0
    const wrong_topic0 = [_]u8{0xff} ** 32;
    const topic0_copy = try allocator.alloc(u8, 32);
    defer allocator.free(topic0_copy);
    @memcpy(topic0_copy, &wrong_topic0);

    const topics = [_][]u8{topic0_copy};
    const data = [_]u8{};

    // Should error on invalid selector
    const result = decodeEventLog(allocator, event, &data, &topics);
    try std.testing.expectError(AbiError.InvalidSelector, result);
}
```

### Event - full selector is 32 bytes (not 4 bytes)

```zig
test "Event - full selector is 32 bytes (not 4 bytes)" {
    const allocator = std.testing.allocator;

    const params = [_]EventParameter{
        .{ .type_name = "address", .indexed = true },
    };

    const event = EventDefinition{
        .name = "Test",
        .inputs = &params,
    };

    const selector = try getEventSelector(allocator, event);

    // Event selector is FULL 32 bytes (unlike function selector which is 4 bytes)
    try std.testing.expectEqual(@as(usize, 32), selector.len);
}
```
