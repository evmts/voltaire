---
title: '[Zig] src/primitives/TokenId/TokenId.zig'
source: 'src/primitives/TokenId/TokenId.zig'
---

> Auto-generated from Zig tests in: src/primitives/TokenId/TokenId.zig

### TokenId.from creates token ID from u256

```zig
test "TokenId.from creates token ID from u256" {
    const token_id = from(42);
    try std.testing.expectEqual(@as(u256, 42), token_id);
}
```

### TokenId.from handles zero

```zig
test "TokenId.from handles zero" {
    const token_id = from(0);
    try std.testing.expectEqual(@as(u256, 0), token_id);
}
```

### TokenId.from handles max u256

```zig
test "TokenId.from handles max u256" {
    const token_id = from(MAX);
    try std.testing.expectEqual(MAX, token_id);
}
```

### TokenId.fromNumber creates token ID from u64

```zig
test "TokenId.fromNumber creates token ID from u64" {
    const token_id = fromNumber(12345);
    try std.testing.expectEqual(@as(u256, 12345), token_id);
}
```

### TokenId.fromHex parses hex with 0x prefix

```zig
test "TokenId.fromHex parses hex with 0x prefix" {
    const token_id = try fromHex("0x2a");
    try std.testing.expectEqual(@as(u256, 42), token_id);
}
```

### TokenId.fromHex parses hex without prefix

```zig
test "TokenId.fromHex parses hex without prefix" {
    const token_id = try fromHex("ff");
    try std.testing.expectEqual(@as(u256, 255), token_id);
}
```

### TokenId.fromHex parses large hex

```zig
test "TokenId.fromHex parses large hex" {
    const token_id = try fromHex("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
    try std.testing.expectEqual(MAX, token_id);
}
```

### TokenId.fromHex returns error for invalid hex

```zig
test "TokenId.fromHex returns error for invalid hex" {
    const result = fromHex("0xgg");
    try std.testing.expectError(error.InvalidHexCharacter, result);
}
```

### TokenId.fromHex handles empty after prefix

```zig
test "TokenId.fromHex handles empty after prefix" {
    const token_id = try fromHex("0x");
    try std.testing.expectEqual(@as(u256, 0), token_id);
}
```

### TokenId.equals returns true for same value

```zig
test "TokenId.equals returns true for same value" {
    const a = from(42);
    const b = from(42);
    try std.testing.expect(equals(a, b));
}
```

### TokenId.equals returns false for different values

```zig
test "TokenId.equals returns false for different values" {
    const a = from(42);
    const b = from(43);
    try std.testing.expect(!equals(a, b));
}
```

### TokenId.compare returns correct ordering

```zig
test "TokenId.compare returns correct ordering" {
    try std.testing.expectEqual(@as(i8, -1), compare(from(1), from(2)));
    try std.testing.expectEqual(@as(i8, 0), compare(from(42), from(42)));
    try std.testing.expectEqual(@as(i8, 1), compare(from(100), from(50)));
}
```

### TokenId.toNumber converts to u64

```zig
test "TokenId.toNumber converts to u64" {
    const token_id = from(42);
    try std.testing.expectEqual(@as(u64, 42), toNumber(token_id));
}
```

### TokenId.toNumber truncates large values

```zig
test "TokenId.toNumber truncates large values" {
    const large_value: u256 = std.math.maxInt(u64) + 1;
    const token_id = from(large_value);
    try std.testing.expectEqual(@as(u64, 0), toNumber(token_id));
}
```

### TokenId.toBigInt returns u256

```zig
test "TokenId.toBigInt returns u256" {
    const token_id = from(42);
    try std.testing.expectEqual(@as(u256, 42), toBigInt(token_id));
}
```

### TokenId.toHex converts to hex string

```zig
test "TokenId.toHex converts to hex string" {
    const token_id = from(42);
    const hex = toHex(token_id);
    // 42 = 0x2a, padded to 64 chars
    try std.testing.expectEqualStrings("0x000000000000000000000000000000000000000000000000000000000000002a", &hex);
}
```

### TokenId.toHex converts zero

```zig
test "TokenId.toHex converts zero" {
    const token_id = from(0);
    const hex = toHex(token_id);
    try std.testing.expectEqualStrings("0x0000000000000000000000000000000000000000000000000000000000000000", &hex);
}
```

### TokenId.toHex converts max

```zig
test "TokenId.toHex converts max" {
    const token_id = from(MAX);
    const hex = toHex(token_id);
    try std.testing.expectEqualStrings("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff", &hex);
}
```

### TokenId.toHexMinimal returns minimal hex

```zig
test "TokenId.toHexMinimal returns minimal hex" {
    const allocator = std.testing.allocator;

    const result = try toHexMinimal(allocator, from(42));
    defer allocator.free(result);
    try std.testing.expectEqualStrings("0x2a", result);
}
```

### TokenId.toHexMinimal handles zero

```zig
test "TokenId.toHexMinimal handles zero" {
    const allocator = std.testing.allocator;

    const result = try toHexMinimal(allocator, from(0));
    defer allocator.free(result);
    try std.testing.expectEqualStrings("0x0", result);
}
```

### TokenId.toHexMinimal handles large value

```zig
test "TokenId.toHexMinimal handles large value" {
    const allocator = std.testing.allocator;

    const result = try toHexMinimal(allocator, from(0xdeadbeef));
    defer allocator.free(result);
    try std.testing.expectEqualStrings("0xdeadbeef", result);
}
```

### TokenId.isValid always returns true

```zig
test "TokenId.isValid always returns true" {
    try std.testing.expect(isValid(0));
    try std.testing.expect(isValid(42));
    try std.testing.expect(isValid(MAX));
}
```

### TokenId constants are correct

```zig
test "TokenId constants are correct" {
    try std.testing.expectEqual(@as(u256, 0), MIN);
    try std.testing.expectEqual(std.math.maxInt(u256), MAX);
}
```

### TokenId.ERC721_SELECTORS are correct

```zig
test "TokenId.ERC721_SELECTORS are correct" {
    // balanceOf(address) = 0x70a08231
    try std.testing.expectEqual([4]u8{ 0x70, 0xa0, 0x82, 0x31 }, ERC721_SELECTORS.balanceOf);
    // ownerOf(uint256) = 0x6352211e
    try std.testing.expectEqual([4]u8{ 0x63, 0x52, 0x21, 0x1e }, ERC721_SELECTORS.ownerOf);
}
```

### TokenId complete workflow

```zig
test "TokenId complete workflow" {
    // Create from value
    const token_id = fromNumber(12345);

    // Convert to hex
    const hex = toHex(token_id);
    try std.testing.expect(hex[hex.len - 1] == '9'); // last digit of 12345 = 0x3039

    // Compare with another
    const other = from(12345);
    try std.testing.expect(equals(token_id, other));
    try std.testing.expectEqual(@as(i8, 0), compare(token_id, other));

    // Convert back to number
    const num = toNumber(token_id);
    try std.testing.expectEqual(@as(u64, 12345), num);
}
```
