---
title: '[Zig] src/primitives/BeaconBlockRoot/BeaconBlockRoot.zig'
source: 'src/primitives/BeaconBlockRoot/BeaconBlockRoot.zig'
---

> Auto-generated from Zig tests in: src/primitives/BeaconBlockRoot/BeaconBlockRoot.zig

### fromBytes - valid 32 bytes

```zig
test "fromBytes - valid 32 bytes" {
    const bytes = [_]u8{0xab} ** SIZE;
    const root = fromBytes(&bytes);
    try std.testing.expectEqual(SIZE, root.len);
    try std.testing.expectEqual(@as(u8, 0xab), root[0]);
    try std.testing.expectEqual(@as(u8, 0xab), root[31]);
}
```

### fromBytes - creates independent copy

```zig
test "fromBytes - creates independent copy" {
    var bytes = [_]u8{42} ** SIZE;
    const root = fromBytes(&bytes);
    bytes[0] = 99;
    try std.testing.expectEqual(@as(u8, 42), root[0]);
}
```

### fromHex - with 0x prefix

```zig
test "fromHex - with 0x prefix" {
    const hex = "0x" ++ ("ab" ** SIZE);
    const root = try fromHex(hex);
    try std.testing.expectEqual(@as(u8, 0xab), root[0]);
    try std.testing.expectEqual(@as(u8, 0xab), root[31]);
}
```

### fromHex - without 0x prefix

```zig
test "fromHex - without 0x prefix" {
    const hex = "cd" ** SIZE;
    const root = try fromHex(hex);
    try std.testing.expectEqual(@as(u8, 0xcd), root[0]);
}
```

### fromHex - invalid length

```zig
test "fromHex - invalid length" {
    const hex = "0xaabb";
    try std.testing.expectError(error.InvalidHashLength, fromHex(hex));
}
```

### fromHex - invalid hex chars

```zig
test "fromHex - invalid hex chars" {
    const hex = "0x" ++ ("zz" ** SIZE);
    try std.testing.expectError(error.InvalidHexCharacter, fromHex(hex));
}
```

### from - raw bytes

```zig
test "from - raw bytes" {
    const bytes = [_]u8{42} ** SIZE;
    const root = try from(bytes[0..]);
    try std.testing.expectEqual(@as(u8, 42), root[0]);
}
```

### from - hex with 0x

```zig
test "from - hex with 0x" {
    const hex = "0x" ++ ("ef" ** SIZE);
    const root = try from(hex);
    try std.testing.expectEqual(@as(u8, 0xef), root[0]);
}
```

### toBytes - returns correct slice

```zig
test "toBytes - returns correct slice" {
    var root: BeaconBlockRoot = undefined;
    @memset(&root, 0xaa);
    const bytes = toBytes(&root);
    try std.testing.expectEqual(SIZE, bytes.len);
    try std.testing.expectEqual(@as(u8, 0xaa), bytes[0]);
}
```

### toHex - with 0x prefix

```zig
test "toHex - with 0x prefix" {
    var root: BeaconBlockRoot = undefined;
    @memset(&root, 0xff);
    const hex = try toHex(&root, std.testing.allocator);
    defer std.testing.allocator.free(hex);

    try std.testing.expectEqual(2 + SIZE * 2, hex.len);
    try std.testing.expect(std.mem.startsWith(u8, hex, "0x"));
    try std.testing.expect(std.mem.eql(u8, hex, "0x" ++ ("ff" ** SIZE)));
}
```

### equals - same root

```zig
test "equals - same root" {
    const root: BeaconBlockRoot = [_]u8{42} ** SIZE;
    try std.testing.expect(equals(&root, &root));
}
```

### equals - identical roots

```zig
test "equals - identical roots" {
    const root1: BeaconBlockRoot = [_]u8{99} ** SIZE;
    const root2: BeaconBlockRoot = [_]u8{99} ** SIZE;
    try std.testing.expect(equals(&root1, &root2));
}
```

### equals - different roots

```zig
test "equals - different roots" {
    const root1: BeaconBlockRoot = [_]u8{1} ** SIZE;
    const root2: BeaconBlockRoot = [_]u8{2} ** SIZE;
    try std.testing.expect(!equals(&root1, &root2));
}
```

### isZero - zero root

```zig
test "isZero - zero root" {
    const root: BeaconBlockRoot = ZERO;
    try std.testing.expect(isZero(&root));
}
```

### isZero - non-zero root

```zig
test "isZero - non-zero root" {
    var root: BeaconBlockRoot = ZERO;
    root[0] = 1;
    try std.testing.expect(!isZero(&root));
}
```

### isValidHex - valid with 0x

```zig
test "isValidHex - valid with 0x" {
    const hex = "0x" ++ ("ab" ** SIZE);
    try std.testing.expect(isValidHex(hex));
}
```

### isValidHex - valid without 0x

```zig
test "isValidHex - valid without 0x" {
    const hex = "cd" ** SIZE;
    try std.testing.expect(isValidHex(hex));
}
```

### isValidHex - invalid length

```zig
test "isValidHex - invalid length" {
    try std.testing.expect(!isValidHex("0xaabb"));
}
```

### clone - creates independent copy

```zig
test "clone - creates independent copy" {
    var original: BeaconBlockRoot = [_]u8{42} ** SIZE;
    var copy = clone(&original);
    try std.testing.expect(equals(&original, &copy));

    // Modify original
    original[0] = 99;
    try std.testing.expect(!equals(&original, &copy));
    try std.testing.expectEqual(@as(u8, 42), copy[0]);
}
```

### random - generates different roots

```zig
test "random - generates different roots" {
    const root1 = random();
    const root2 = random();
    // Astronomically unlikely to be equal
    try std.testing.expect(!equals(&root1, &root2));
}
```

### random - correct size

```zig
test "random - correct size" {
    const root = random();
    try std.testing.expectEqual(SIZE, root.len);
}
```

### format - returns hex string

```zig
test "format - returns hex string" {
    const root: BeaconBlockRoot = ZERO;
    const formatted = try format(&root, std.testing.allocator);
    defer std.testing.allocator.free(formatted);
    try std.testing.expect(std.mem.startsWith(u8, formatted, "0x"));
    try std.testing.expectEqual(2 + SIZE * 2, formatted.len);
}
```

### isBeaconBlockRoot - BeaconBlockRoot type

```zig
test "isBeaconBlockRoot - BeaconBlockRoot type" {
    const root: BeaconBlockRoot = ZERO;
    try std.testing.expect(isBeaconBlockRoot(root));
}
```

### isBeaconBlockRoot - pointer types

```zig
test "isBeaconBlockRoot - pointer types" {
    const root: BeaconBlockRoot = ZERO;
    try std.testing.expect(isBeaconBlockRoot(&root));
}
```

### toHash - converts to Hash

```zig
test "toHash - converts to Hash" {
    const root: BeaconBlockRoot = [_]u8{0xab} ** SIZE;
    const hash = toHash(&root);
    try std.testing.expectEqualSlices(u8, &root, &hash);
}
```

### fromHash - creates from Hash

```zig
test "fromHash - creates from Hash" {
    const hash: Hash.Hash = [_]u8{0xcd} ** SIZE;
    const root = fromHash(&hash);
    try std.testing.expectEqualSlices(u8, &hash, &root);
}
```
