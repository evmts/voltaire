---
title: '[Zig] src/primitives/PeerId/PeerId.zig'
source: 'src/primitives/PeerId/PeerId.zig'
---

> Auto-generated from Zig tests in: src/primitives/PeerId/PeerId.zig

### PeerId: from creates from bytes

```zig
test "PeerId: from creates from bytes" {
    var bytes: [64]u8 = undefined;
    @memset(&bytes, 0xAB);

    const peer = from(bytes);
    try std.testing.expectEqualSlices(u8, &bytes, &peer);
}
```

### PeerId: fromSlice creates from slice

```zig
test "PeerId: fromSlice creates from slice" {
    var bytes: [64]u8 = undefined;
    @memset(&bytes, 0xCD);

    const peer = try fromSlice(&bytes);
    try std.testing.expectEqualSlices(u8, &bytes, &peer);
}
```

### PeerId: fromSlice rejects invalid length

```zig
test "PeerId: fromSlice rejects invalid length" {
    const short: [32]u8 = undefined;
    try std.testing.expectError(error.InvalidLength, fromSlice(&short));
}
```

### PeerId: fromHex creates from hex string

```zig
test "PeerId: fromHex creates from hex string" {
    const hex = "6f8a80d14311c39f35f516fa664deaaaa13e85b2f7493f37f6144d86991ec012937307647bd3b9a82abe2974e1407241d54947bbb39763a4cac9f77166ad92a0";
    const peer = try fromHex(hex);

    try std.testing.expectEqual(@as(u8, 0x6f), peer[0]);
    try std.testing.expectEqual(@as(u8, 0x8a), peer[1]);
}
```

### PeerId: fromHex with 0x prefix

```zig
test "PeerId: fromHex with 0x prefix" {
    const hex = "0x6f8a80d14311c39f35f516fa664deaaaa13e85b2f7493f37f6144d86991ec012937307647bd3b9a82abe2974e1407241d54947bbb39763a4cac9f77166ad92a0";
    const peer = try fromHex(hex);

    try std.testing.expectEqual(@as(u8, 0x6f), peer[0]);
}
```

### PeerId: fromHex rejects invalid length

```zig
test "PeerId: fromHex rejects invalid length" {
    try std.testing.expectError(error.InvalidHexLength, fromHex("abc123"));
    try std.testing.expectError(error.InvalidHexLength, fromHex("0xabc123"));
}
```

### PeerId: fromPublicKey creates from PublicKey

```zig
test "PeerId: fromPublicKey creates from PublicKey" {
    var pk: PublicKey = undefined;
    @memset(&pk.bytes, 0xEF);

    const peer = fromPublicKey(pk);
    try std.testing.expectEqualSlices(u8, &pk.bytes, &peer);
}
```

### PeerId: toHex converts to hex string

```zig
test "PeerId: toHex converts to hex string" {
    var peer: PeerId = undefined;
    @memset(&peer, 0x42);

    const hex = toHex(peer);

    try std.testing.expectEqual(@as(usize, 128), hex.len);
    try std.testing.expectEqual(@as(u8, '4'), hex[0]);
    try std.testing.expectEqual(@as(u8, '2'), hex[1]);
}
```

### PeerId: toHexPrefixed includes 0x prefix

```zig
test "PeerId: toHexPrefixed includes 0x prefix" {
    var peer: PeerId = undefined;
    @memset(&peer, 0x42);

    const hex = toHexPrefixed(peer);

    try std.testing.expectEqual(@as(usize, 130), hex.len);
    try std.testing.expectEqual(@as(u8, '0'), hex[0]);
    try std.testing.expectEqual(@as(u8, 'x'), hex[1]);
    try std.testing.expectEqual(@as(u8, '4'), hex[2]);
}
```

### PeerId: toPublicKey converts to PublicKey

```zig
test "PeerId: toPublicKey converts to PublicKey" {
    var peer: PeerId = undefined;
    @memset(&peer, 0xAA);

    const pk = toPublicKey(peer);
    try std.testing.expectEqualSlices(u8, &peer, &pk.bytes);
}
```

### PeerId: toEnode formats as enode URL

```zig
test "PeerId: toEnode formats as enode URL" {
    var peer: PeerId = undefined;
    @memset(&peer, 0xAB);

    const enode = try toEnode(peer, std.testing.allocator, "192.168.1.1", 30303, null);
    defer std.testing.allocator.free(enode);

    try std.testing.expect(std.mem.startsWith(u8, enode, "enode://"));
    try std.testing.expect(std.mem.indexOf(u8, enode, "@192.168.1.1:30303") != null);
}
```

### PeerId: toEnode with discovery port

```zig
test "PeerId: toEnode with discovery port" {
    var peer: PeerId = undefined;
    @memset(&peer, 0xCD);

    const enode = try toEnode(peer, std.testing.allocator, "10.0.0.1", 30303, 30301);
    defer std.testing.allocator.free(enode);

    try std.testing.expect(std.mem.indexOf(u8, enode, "?discport=30301") != null);
}
```

### PeerId: equals returns true for same peer

```zig
test "PeerId: equals returns true for same peer" {
    var peer1: PeerId = undefined;
    @memset(&peer1, 0x11);

    var peer2: PeerId = undefined;
    @memset(&peer2, 0x11);

    try std.testing.expect(equals(peer1, peer2));
}
```

### PeerId: equals returns false for different peers

```zig
test "PeerId: equals returns false for different peers" {
    var peer1: PeerId = undefined;
    @memset(&peer1, 0x11);

    var peer2: PeerId = undefined;
    @memset(&peer2, 0x22);

    try std.testing.expect(!equals(peer1, peer2));
}
```

### PeerId: parseEnode parses valid enode

```zig
test "PeerId: parseEnode parses valid enode" {
    const enode = "enode://6f8a80d14311c39f35f516fa664deaaaa13e85b2f7493f37f6144d86991ec012937307647bd3b9a82abe2974e1407241d54947bbb39763a4cac9f77166ad92a0@10.3.58.6:30303";

    const parsed = try parseEnode(enode);

    try std.testing.expectEqualStrings("10.3.58.6", parsed.ip);
    try std.testing.expectEqual(@as(u16, 30303), parsed.port);
    try std.testing.expectEqual(@as(?u16, null), parsed.discovery_port);
    try std.testing.expectEqual(@as(u8, 0x6f), parsed.public_key[0]);
}
```

### PeerId: parseEnode with discovery port

```zig
test "PeerId: parseEnode with discovery port" {
    const enode = "enode://6f8a80d14311c39f35f516fa664deaaaa13e85b2f7493f37f6144d86991ec012937307647bd3b9a82abe2974e1407241d54947bbb39763a4cac9f77166ad92a0@10.3.58.6:30303?discport=30301";

    const parsed = try parseEnode(enode);

    try std.testing.expectEqual(@as(?u16, 30301), parsed.discovery_port);
}
```

### PeerId: parseEnode rejects invalid prefix

```zig
test "PeerId: parseEnode rejects invalid prefix" {
    try std.testing.expectError(error.InvalidEnodePrefix, parseEnode("http://abc@127.0.0.1:30303"));
}
```

### PeerId: parseEnode rejects missing @

```zig
test "PeerId: parseEnode rejects missing @" {
    try std.testing.expectError(error.MissingAtSeparator, parseEnode("enode://abc123"));
}
```

### PeerId: parseEnode rejects invalid pubkey length

```zig
test "PeerId: parseEnode rejects invalid pubkey length" {
    try std.testing.expectError(error.InvalidPublicKeyLength, parseEnode("enode://abc@127.0.0.1:30303"));
}
```

### PeerId: fromEnode extracts PeerId from enode URL

```zig
test "PeerId: fromEnode extracts PeerId from enode URL" {
    const enode = "enode://6f8a80d14311c39f35f516fa664deaaaa13e85b2f7493f37f6144d86991ec012937307647bd3b9a82abe2974e1407241d54947bbb39763a4cac9f77166ad92a0@192.168.1.1:30303";

    const peer = try fromEnode(enode);

    try std.testing.expectEqual(@as(u8, 0x6f), peer[0]);
    try std.testing.expectEqual(@as(u8, 0xa0), peer[63]);
}
```

### PeerId: round trip hex

```zig
test "PeerId: round trip hex" {
    const original_hex = "6f8a80d14311c39f35f516fa664deaaaa13e85b2f7493f37f6144d86991ec012937307647bd3b9a82abe2974e1407241d54947bbb39763a4cac9f77166ad92a0";
    const peer = try fromHex(original_hex);
    const result_hex = toHex(peer);

    try std.testing.expectEqualStrings(original_hex, &result_hex);
}
```

### PeerId: round trip enode

```zig
test "PeerId: round trip enode" {
    const original_enode = "enode://6f8a80d14311c39f35f516fa664deaaaa13e85b2f7493f37f6144d86991ec012937307647bd3b9a82abe2974e1407241d54947bbb39763a4cac9f77166ad92a0@192.168.1.100:30303?discport=30301";

    // Parse original enode
    const parsed = try parseEnode(original_enode);

    // Recreate enode URL
    const recreated = try toEnode(parsed.public_key, std.testing.allocator, parsed.ip, parsed.port, parsed.discovery_port);
    defer std.testing.allocator.free(recreated);

    // Compare (should match)
    try std.testing.expectEqualStrings(original_enode, recreated);
}
```

### PeerId: complete workflow

```zig
test "PeerId: complete workflow" {
    // Create PeerId from hex
    const hex = "6f8a80d14311c39f35f516fa664deaaaa13e85b2f7493f37f6144d86991ec012937307647bd3b9a82abe2974e1407241d54947bbb39763a4cac9f77166ad92a0";
    const peer = try fromHex(hex);

    // Convert to PublicKey
    const pk = toPublicKey(peer);
    try std.testing.expectEqualSlices(u8, &peer, &pk.bytes);

    // Generate enode URL
    const enode = try toEnode(peer, std.testing.allocator, "10.3.58.6", 30303, 30301);
    defer std.testing.allocator.free(enode);

    // Parse enode and verify
    const parsed = try parseEnode(enode);
    try std.testing.expect(equals(peer, parsed.public_key));
    try std.testing.expectEqualStrings("10.3.58.6", parsed.ip);
    try std.testing.expectEqual(@as(u16, 30303), parsed.port);
    try std.testing.expectEqual(@as(?u16, 30301), parsed.discovery_port);
}
```
