---
title: '[Zig] src/primitives/GasConstants/gas_constants.zig'
source: 'src/primitives/GasConstants/gas_constants.zig'
---

> Auto-generated from Zig tests in: src/primitives/GasConstants/gas_constants.zig

### callGasCost function

```zig
test "callGasCost function" {
    // Test basic call (warm, no value transfer, existing account)
    const basic_call = callGasCost(false, false, false);
    try testing.expectEqual(CALL_BASE_COST, basic_call);

    // Test cold call with no value transfer
    const cold_call = callGasCost(false, false, true);
    try testing.expectEqual(CALL_BASE_COST + CALL_COLD_ACCOUNT_COST, cold_call);

    // Test warm call with value transfer
    const value_call = callGasCost(true, false, false);
    try testing.expectEqual(CALL_BASE_COST + CALL_VALUE_TRANSFER_COST, value_call);

    // Test new account creation
    const new_account_call = callGasCost(false, true, false);
    try testing.expectEqual(CALL_BASE_COST + CALL_NEW_ACCOUNT_COST, new_account_call);

    // Test maximum cost (cold call with value transfer to new account)
    const max_cost_call = callGasCost(true, true, true);
    const expected_max = CALL_BASE_COST + CALL_COLD_ACCOUNT_COST + CALL_VALUE_TRANSFER_COST + CALL_NEW_ACCOUNT_COST;
    try testing.expectEqual(expected_max, max_cost_call);
}
```

### sstoreGasCost function

```zig
test "sstoreGasCost function" {
    // Test no change (current == original == new)
    const no_change = sstoreGasCost(42, 42, 42, false);
    try testing.expectEqual(SloadGas, no_change);

    // Test setting zero to non-zero (most expensive case)
    const zero_to_nonzero = sstoreGasCost(0, 0, 42, false);
    try testing.expectEqual(SstoreSetGas, zero_to_nonzero);

    // Test cold access with zero to non-zero
    const cold_zero_to_nonzero = sstoreGasCost(0, 0, 42, true);
    try testing.expectEqual(ColdSloadCost + SstoreSetGas, cold_zero_to_nonzero);

    // Test modifying existing non-zero value
    const modify_nonzero = sstoreGasCost(10, 10, 20, false);
    try testing.expectEqual(SstoreResetGas, modify_nonzero);

    // Test subsequent modification (current != original)
    const subsequent_mod = sstoreGasCost(20, 10, 30, false);
    try testing.expectEqual(SloadGas, subsequent_mod);
}
```

### createGasCost function

```zig
test "createGasCost function" {
    // Test empty init code
    const empty_create = createGasCost(0, InitcodeWordGas);
    try testing.expectEqual(CreateGas, empty_create);

    // Test 32 bytes (1 word) of init code
    const one_word_create = createGasCost(32, InitcodeWordGas);
    try testing.expectEqual(CreateGas + InitcodeWordGas, one_word_create);

    // Test 64 bytes (2 words) of init code
    const two_word_create = createGasCost(64, InitcodeWordGas);
    try testing.expectEqual(CreateGas + 2 * InitcodeWordGas, two_word_create);

    // Test 33 bytes (2 words due to rounding up) of init code
    const partial_word_create = createGasCost(33, InitcodeWordGas);
    try testing.expectEqual(CreateGas + 2 * InitcodeWordGas, partial_word_create);
}
```

### logGasCost function

```zig
test "logGasCost function" {
    // Test LOG0 (no topics)
    const log0_cost = logGasCost(0, 0);
    try testing.expectEqual(LogGas, log0_cost);

    // Test LOG1 with no data
    const log1_no_data = logGasCost(1, 0);
    try testing.expectEqual(LogGas + LogTopicGas, log1_no_data);

    // Test LOG0 with data
    const log0_with_data = logGasCost(0, 100);
    try testing.expectEqual(LogGas + 100 * LogDataGas, log0_with_data);

    // Test LOG4 with data (maximum topics)
    const log4_with_data = logGasCost(4, 256);
    const expected = LogGas + 4 * LogTopicGas + 256 * LogDataGas;
    try testing.expectEqual(expected, log4_with_data);
}
```

### copyGasCost function

```zig
test "copyGasCost function" {
    // Test zero size copy
    const zero_copy = copyGasCost(0);
    try testing.expectEqual(0, zero_copy);

    // Test 32 bytes (1 word)
    const one_word_copy = copyGasCost(32);
    try testing.expectEqual(CopyGas, one_word_copy);

    // Test 64 bytes (2 words)
    const two_word_copy = copyGasCost(64);
    try testing.expectEqual(2 * CopyGas, two_word_copy);

    // Test 33 bytes (2 words due to rounding up)
    const partial_word_copy = copyGasCost(33);
    try testing.expectEqual(2 * CopyGas, partial_word_copy);
}
```

### keccak256GasCost function

```zig
test "keccak256GasCost function" {
    // Test zero size hash
    const zero_hash = keccak256GasCost(0);
    try testing.expectEqual(Keccak256Gas, zero_hash);

    // Test 32 bytes (1 word)
    const one_word_hash = keccak256GasCost(32);
    try testing.expectEqual(Keccak256Gas + Keccak256WordGas, one_word_hash);

    // Test 64 bytes (2 words)
    const two_word_hash = keccak256GasCost(64);
    try testing.expectEqual(Keccak256Gas + 2 * Keccak256WordGas, two_word_hash);

    // Test 33 bytes (2 words due to rounding up)
    const partial_word_hash = keccak256GasCost(33);
    try testing.expectEqual(Keccak256Gas + 2 * Keccak256WordGas, partial_word_hash);
}
```

### memoryGasCost edge cases

```zig
test "memoryGasCost edge cases" {
    // Test same sizes (no expansion)
    try testing.expectEqual(@as(u64, 0), memoryGasCost(1000, 1000));
    try testing.expectEqual(@as(u64, 0), memoryGasCost(2048, 1000)); // new_size < current_size

    // Test zero expansion
    try testing.expectEqual(@as(u64, 0), memoryGasCost(0, 0));

    // Test small expansions (verifiable manually)
    const expand_to_32 = memoryGasCost(0, 32);
    const expected_32 = 3 * 1 + (1 * 1) / 512; // 1 word: 3 + 0 = 3
    try testing.expectEqual(expected_32, expand_to_32);

    const expand_to_64 = memoryGasCost(0, 64);
    const expected_64 = 3 * 2 + (2 * 2) / 512; // 2 words: 6 + 0 = 6
    try testing.expectEqual(expected_64, expand_to_64);
}
```

### wordCount edge cases

```zig
test "wordCount edge cases" {
    // Test zero size
    try testing.expectEqual(@as(usize, 0), wordCount(0));

    // Test exact word boundaries
    try testing.expectEqual(@as(usize, 1), wordCount(32));
    try testing.expectEqual(@as(usize, 2), wordCount(64));

    // Test partial words (should round up)
    try testing.expectEqual(@as(usize, 1), wordCount(1));
    try testing.expectEqual(@as(usize, 1), wordCount(31));
    try testing.expectEqual(@as(usize, 2), wordCount(33));

    // Test overflow protection
    const max_safe_bytes = std.math.maxInt(usize) - 31;
    const max_words = wordCount(max_safe_bytes);
    try testing.expect(max_words > 0); // Should not overflow

    const overflow_bytes = std.math.maxInt(usize);
    const overflow_words = wordCount(overflow_bytes);
    try testing.expectEqual(std.math.maxInt(usize) / 32, overflow_words);
}
```

### memoryGasCost - quadratic growth behavior

```zig
test "memoryGasCost - quadratic growth behavior" {
    // Test quadratic growth for larger expansions
    // Formula: gas = 3n + n²/512

    // 512 bytes = 16 words
    // Cost = 3*16 + 16²/512 = 48 + 0.5 = 48
    const cost_512 = memoryGasCost(0, 512);
    try testing.expectEqual(@as(u64, 48), cost_512);

    // 1024 bytes = 32 words
    // Cost = 3*32 + 32²/512 = 96 + 2 = 98
    const cost_1024 = memoryGasCost(0, 1024);
    try testing.expectEqual(@as(u64, 98), cost_1024);

    // 2048 bytes = 64 words
    // Cost = 3*64 + 64²/512 = 192 + 8 = 200
    const cost_2048 = memoryGasCost(0, 2048);
    try testing.expectEqual(@as(u64, 200), cost_2048);
}
```

### memoryGasCost - incremental expansions

```zig
test "memoryGasCost - incremental expansions" {
    // Test expanding from existing memory
    const expand_1024_to_2048 = memoryGasCost(1024, 2048);
    const total_2048 = memoryGasCost(0, 2048);
    const total_1024 = memoryGasCost(0, 1024);

    // Cost should be the difference
    try testing.expectEqual(total_2048 - total_1024, expand_1024_to_2048);

    // Partial word expansions
    const expand_0_to_1 = memoryGasCost(0, 1);
    const expand_0_to_31 = memoryGasCost(0, 31);
    const expand_0_to_32 = memoryGasCost(0, 32);

    // All should cost the same (1 word)
    try testing.expectEqual(expand_0_to_1, expand_0_to_31);
    try testing.expectEqual(expand_0_to_31, expand_0_to_32);
    try testing.expectEqual(@as(u64, 3), expand_0_to_1);
}
```

### callGasCost - all flag combinations

```zig
test "callGasCost - all flag combinations" {
    // Test all 8 combinations of the 3 boolean parameters
    const scenarios = [_]struct {
        value_transfer: bool,
        new_account: bool,
        cold_access: bool,
        expected: u64,
    }{
        // Basic warm call
        .{ .value_transfer = false, .new_account = false, .cold_access = false, .expected = 100 },
        // Cold call only
        .{ .value_transfer = false, .new_account = false, .cold_access = true, .expected = 100 + 2600 },
        // Value transfer only
        .{ .value_transfer = true, .new_account = false, .cold_access = false, .expected = 100 + 9000 },
        // New account only
        .{ .value_transfer = false, .new_account = true, .cold_access = false, .expected = 100 + 25000 },
        // Cold + value
        .{ .value_transfer = true, .new_account = false, .cold_access = true, .expected = 100 + 2600 + 9000 },
        // Cold + new account
        .{ .value_transfer = false, .new_account = true, .cold_access = true, .expected = 100 + 2600 + 25000 },
        // Value + new account
        .{ .value_transfer = true, .new_account = true, .cold_access = false, .expected = 100 + 9000 + 25000 },
        // All flags (maximum cost)
        .{ .value_transfer = true, .new_account = true, .cold_access = true, .expected = 100 + 2600 + 9000 + 25000 },
    };

    for (scenarios) |scenario| {
        const cost = callGasCost(scenario.value_transfer, scenario.new_account, scenario.cold_access);
        try testing.expectEqual(scenario.expected, cost);
    }
}
```

### sstoreGasCost - all state transitions

```zig
test "sstoreGasCost - all state transitions" {
    // Test zero to non-zero (most expensive)
    try testing.expectEqual(@as(u64, 20000), sstoreGasCost(0, 0, 1, false));
    try testing.expectEqual(@as(u64, 22100), sstoreGasCost(0, 0, 1, true)); // cold

    // Test non-zero to different non-zero
    try testing.expectEqual(@as(u64, 5000), sstoreGasCost(1, 1, 2, false));
    try testing.expectEqual(@as(u64, 7100), sstoreGasCost(1, 1, 2, true)); // cold

    // Test non-zero to zero (clearing)
    try testing.expectEqual(@as(u64, 5000), sstoreGasCost(42, 42, 0, false));
    try testing.expectEqual(@as(u64, 7100), sstoreGasCost(42, 42, 0, true)); // cold

    // Test subsequent modifications
    try testing.expectEqual(@as(u64, 100), sstoreGasCost(2, 1, 3, false));
    try testing.expectEqual(@as(u64, 2200), sstoreGasCost(2, 1, 3, true)); // cold
}
```

### createGasCost - init code size variations

```zig
test "createGasCost - init code size variations" {
    // Test various init code sizes
    try testing.expectEqual(@as(u64, 32000), createGasCost(0, InitcodeWordGas));
    try testing.expectEqual(@as(u64, 32002), createGasCost(1, InitcodeWordGas));
    try testing.expectEqual(@as(u64, 32002), createGasCost(32, InitcodeWordGas));
    try testing.expectEqual(@as(u64, 32004), createGasCost(33, InitcodeWordGas));
    try testing.expectEqual(@as(u64, 32064), createGasCost(1024, InitcodeWordGas));

    // Test maximum init code size (EIP-3860)
    const max_size = MaxInitcodeSize; // 49152 bytes
    const max_cost = createGasCost(max_size, InitcodeWordGas);
    const expected = 32000 + (49152 / 32) * 2; // 32000 + 1536 * 2 = 35072
    try testing.expectEqual(expected, max_cost);
}
```

### logGasCost - all LOG opcodes

```zig
test "logGasCost - all LOG opcodes" {
    // Test LOG0 through LOG4
    try testing.expectEqual(@as(u64, 375), logGasCost(0, 0)); // LOG0
    try testing.expectEqual(@as(u64, 750), logGasCost(1, 0)); // LOG1
    try testing.expectEqual(@as(u64, 1125), logGasCost(2, 0)); // LOG2
    try testing.expectEqual(@as(u64, 1500), logGasCost(3, 0)); // LOG3
    try testing.expectEqual(@as(u64, 1875), logGasCost(4, 0)); // LOG4

    // Test with data
    const data_size = 256;
    try testing.expectEqual(@as(u64, 375 + 256 * 8), logGasCost(0, data_size));
    try testing.expectEqual(@as(u64, 1875 + 256 * 8), logGasCost(4, data_size));
}
```

### copyGasCost - alignment with CODECOPY operations

```zig
test "copyGasCost - alignment with CODECOPY operations" {
    // Test common copy sizes
    const sizes = [_]usize{ 0, 1, 32, 33, 64, 100, 256, 512, 1024, 4096 };

    for (sizes) |size| {
        const cost = copyGasCost(size);
        const expected_words = wordCount(size);
        try testing.expectEqual(expected_words * CopyGas, cost);
    }
}
```

### keccak256GasCost - common hash scenarios

```zig
test "keccak256GasCost - common hash scenarios" {
    // Empty input
    try testing.expectEqual(@as(u64, 30), keccak256GasCost(0));

    // Common sizes
    try testing.expectEqual(@as(u64, 36), keccak256GasCost(32)); // 1 word
    try testing.expectEqual(@as(u64, 42), keccak256GasCost(64)); // 2 words
    try testing.expectEqual(@as(u64, 78), keccak256GasCost(256)); // 8 words

    // Large hashes
    try testing.expectEqual(@as(u64, 222), keccak256GasCost(1024)); // 32 words
    try testing.expectEqual(@as(u64, 798), keccak256GasCost(4096)); // 128 words
}
```

### gas calculation overflow protection

```zig
test "gas calculation overflow protection" {
    // Test that calculations handle large inputs without overflow

    // Large memory expansion
    const large_memory = memoryGasCost(0, 1_000_000);
    try testing.expect(large_memory > 0);
    try testing.expect(large_memory < std.math.maxInt(u64));

    // Large copy operation
    const large_copy = copyGasCost(1_000_000);
    try testing.expect(large_copy > 0);
    try testing.expect(large_copy < std.math.maxInt(u64));

    // Large hash operation
    const large_hash = keccak256GasCost(1_000_000);
    try testing.expect(large_hash > 0);
    try testing.expect(large_hash < std.math.maxInt(u64));
}
```

### gas constants match Ethereum specifications

```zig
test "gas constants match Ethereum specifications" {
    // Verify key constants match Yellow Paper and EIPs

    // Basic operations
    try testing.expectEqual(@as(u64, 3), GasFastestStep);
    try testing.expectEqual(@as(u64, 5), GasFastStep);
    try testing.expectEqual(@as(u64, 8), GasMidStep);

    // Storage operations (EIP-2929)
    try testing.expectEqual(@as(u64, 100), SloadGas);
    try testing.expectEqual(@as(u64, 2100), ColdSloadCost);
    try testing.expectEqual(@as(u64, 2600), ColdAccountAccessCost);

    // Contract creation
    try testing.expectEqual(@as(u64, 32000), CreateGas);
    try testing.expectEqual(@as(u64, 53000), TxGasContractCreation);

    // Memory and hashing
    try testing.expectEqual(@as(u64, 3), MemoryGas);
    try testing.expectEqual(@as(u64, 512), QuadCoeffDiv);
    try testing.expectEqual(@as(u64, 30), Keccak256Gas);
    try testing.expectEqual(@as(u64, 6), Keccak256WordGas);
}
```

### memoryGasCost - maximum memory size

```zig
test "memoryGasCost - maximum memory size" {
    // Test near maximum memory sizes
    const max_memory = 0x1FFFFFFFE0; // Maximum EVM memory size
    const near_max = max_memory - 32;

    // Expanding to maximum should work
    const expand_to_max = memoryGasCost(0, max_memory);
    try testing.expect(expand_to_max > 0);

    // Expanding from near-max to max
    const expand_near_to_max = memoryGasCost(near_max, max_memory);
    try testing.expect(expand_near_to_max > 0);
}
```

### wordCount - special boundary cases

```zig
test "wordCount - special boundary cases" {
    // Test powers of 2 boundaries
    try testing.expectEqual(@as(usize, 16), wordCount(512)); // 2^9
    try testing.expectEqual(@as(usize, 32), wordCount(1024)); // 2^10
    try testing.expectEqual(@as(usize, 256), wordCount(8192)); // 2^13

    // Test maximum contract size
    const max_contract_size = 24576; // 24KB max contract size
    try testing.expectEqual(@as(usize, 768), wordCount(max_contract_size));
}
```

### sstoreGasCost - complex state transitions

```zig
test "sstoreGasCost - complex state transitions" {
    // Test transition from non-zero to different non-zero back to original
    // This tests the "dirty" state tracking

    // Original = 10, Current = 20, New = 10 (reverting to original)
    try testing.expectEqual(@as(u64, 100), sstoreGasCost(20, 10, 10, false));

    // Original = 0, Current = 10, New = 0 (reverting to original zero)
    try testing.expectEqual(@as(u64, 100), sstoreGasCost(10, 0, 0, false));

    // Original = 10, Current = 0, New = 20 (was cleared, now setting different)
    try testing.expectEqual(@as(u64, 100), sstoreGasCost(0, 10, 20, false));
}
```

### createGasCost - exact word boundaries

```zig
test "createGasCost - exact word boundaries" {
    // Test exact multiples of 32 bytes
    const word_sizes = [_]usize{ 32, 64, 128, 256, 512, 1024, 2048, 4096 };

    for (word_sizes) |size| {
        const cost = createGasCost(size, InitcodeWordGas);
        const expected = CreateGas + (size / 32) * InitcodeWordGas;
        try testing.expectEqual(expected, cost);
    }
}
```

### logGasCost - maximum data sizes

```zig
test "logGasCost - maximum data sizes" {
    // Test with large data sizes that might be used in practice
    const large_sizes = [_]usize{ 1024, 2048, 4096, 8192, 16384 };

    for (large_sizes) |size| {
        for (0..5) |topic_count| {
            const cost = logGasCost(@intCast(topic_count), size);
            const expected = LogGas + topic_count * LogTopicGas + size * LogDataGas;
            try testing.expectEqual(expected, cost);
        }
    }
}
```

### integration - CREATE2 full gas calculation

```zig
test "integration - CREATE2 full gas calculation" {
    // CREATE2 requires: base create cost + init code cost + hash cost
    const init_code_size = 1000;
    const salt_size = 32;
    const address_size = 20;
    const prefix_size = 1; // 0xff prefix

    // Calculate individual components
    const create_cost = createGasCost(init_code_size, InitcodeWordGas);
    const hash_input_size = prefix_size + address_size + salt_size + init_code_size;
    const hash_cost = keccak256GasCost(hash_input_size);

    // Total cost should be sum of components
    const total_cost = create_cost + hash_cost;
    try testing.expect(total_cost > CreateGas);
    try testing.expect(total_cost == 32000 + wordCount(init_code_size) * 2 + 30 + wordCount(hash_input_size) * 6);
}
```

### integration - memory expansion with copy

```zig
test "integration - memory expansion with copy" {
    // Common pattern: expand memory then copy data
    const current_mem = 1000;
    const copy_offset = 2000;
    const copy_size = 500;
    const final_mem = copy_offset + copy_size; // 2500

    // Calculate costs
    const expansion_cost = memoryGasCost(current_mem, final_mem);
    const copy_cost = copyGasCost(copy_size);

    // Verify costs are reasonable
    try testing.expect(expansion_cost > 0);
    try testing.expect(copy_cost == wordCount(copy_size) * CopyGas);
}
```

### integration - storage operation sequence

```zig
test "integration - storage operation sequence" {
    // Simulate a sequence of storage operations in a transaction

    // First access (cold)
    const first_read = ColdSloadCost; // 2100

    // First write (cold, zero to non-zero)
    const first_write = sstoreGasCost(0, 0, 42, true); // 22100

    // Second read (warm)
    const second_read = SloadGas; // 100

    // Second write (warm, modify)
    const second_write = sstoreGasCost(42, 42, 100, false); // 5000

    // Third write (warm, already modified)
    const third_write = sstoreGasCost(100, 42, 200, false); // 100

    // Total sequence cost
    const total = first_read + first_write + second_read + second_write + third_write;
    try testing.expectEqual(@as(u64, 29400), total);
}
```

### storage refunds - clearing storage

```zig
test "storage refunds - clearing storage" {
    // Test gas refund calculations for storage clearing

    // Clear storage (non-zero to zero)
    const clear_cost = sstoreGasCost(42, 42, 0, false);
    try testing.expectEqual(SstoreResetGas, clear_cost);

    // Refund should be SstoreRefundGas
    try testing.expectEqual(@as(u64, 4800), SstoreRefundGas);

    // Maximum refund is gas_used / MaxRefundQuotient
    const gas_used = 100000;
    const max_refund = gas_used / MaxRefundQuotient;
    try testing.expectEqual(@as(u64, 20000), max_refund);
}
```

### precompile gas costs - identity

```zig
test "precompile gas costs - identity" {
    // Identity precompile (0x04)
    const sizes = [_]usize{ 0, 32, 64, 128, 256 };

    for (sizes) |size| {
        const cost = IDENTITY_BASE_COST + wordCount(size) * IDENTITY_WORD_COST;
        try testing.expectEqual(15 + wordCount(size) * 3, cost);
    }
}
```

### precompile gas costs - sha256

```zig
test "precompile gas costs - sha256" {
    // SHA256 precompile (0x02)
    const sizes = [_]usize{ 0, 32, 64, 128, 256 };

    for (sizes) |size| {
        const cost = SHA256_BASE_COST + wordCount(size) * SHA256_WORD_COST;
        try testing.expectEqual(60 + wordCount(size) * 12, cost);
    }
}
```

### precompile gas costs - ecrecover

```zig
test "precompile gas costs - ecrecover" {
    // ECRECOVER has fixed cost regardless of input
    try testing.expectEqual(@as(u64, 3000), ECRECOVER_COST);
}
```

### transaction gas costs - data costs

```zig
test "transaction gas costs - data costs" {
    // Test transaction data gas costs
    const zero_bytes = 100;
    const non_zero_bytes = 50;

    const data_cost = zero_bytes * TxDataZeroGas + non_zero_bytes * TxDataNonZeroGas;
    try testing.expectEqual(@as(u64, 100 * 4 + 50 * 16), data_cost);

    // Total transaction cost
    const total_tx_cost = TxGas + data_cost;
    try testing.expectEqual(@as(u64, 21000 + 400 + 800), total_tx_cost);
}
```

### blob transaction gas costs

```zig
test "blob transaction gas costs" {
    // Test blob-related opcodes
    try testing.expectEqual(@as(u64, 3), BlobHashGas);
    try testing.expectEqual(@as(u64, 2), BlobBaseFeeGas);
}
```

### transient storage gas costs

```zig
test "transient storage gas costs" {
    // TLOAD and TSTORE have same cost
    try testing.expectEqual(@as(u64, 100), TLoadGas);
    try testing.expectEqual(@as(u64, 100), TStoreGas);

    // Much cheaper than persistent storage
    try testing.expect(TStoreGas < SstoreResetGas);
    try testing.expect(TLoadGas == SloadGas); // Same as warm SLOAD
}
```

### hardfork - EIP-150 Tangerine Whistle gas repricing

```zig
test "hardfork - EIP-150 Tangerine Whistle gas repricing" {
    // EIP-150 increased costs for IO-heavy operations

    // CALL operations base cost
    try testing.expectEqual(@as(u64, 700), CallCodeCost);
    try testing.expectEqual(@as(u64, 40), CallGas); // Base CALL gas

    // SELFDESTRUCT was free before EIP-150, then 5000 gas
    try testing.expectEqual(@as(u64, 5000), SelfdestructGas);

    // EXT* operations cost 20 gas (previously cheaper)
    try testing.expectEqual(@as(u64, 20), GasExtStep);
}
```

### hardfork - EIP-1108 Istanbul bn256 precompile repricing

```zig
test "hardfork - EIP-1108 Istanbul bn256 precompile repricing" {
    // Istanbul dramatically reduced bn256 precompile costs

    // ECADD: 500 → 150 gas
    try testing.expectEqual(@as(u64, 150), ECADD_GAS_COST);
    try testing.expectEqual(@as(u64, 500), ECADD_GAS_COST_BYZANTIUM);

    // ECMUL: 40,000 → 6,000 gas
    try testing.expectEqual(@as(u64, 6000), ECMUL_GAS_COST);
    try testing.expectEqual(@as(u64, 40000), ECMUL_GAS_COST_BYZANTIUM);

    // ECPAIRING base: 100,000 → 45,000 gas
    try testing.expectEqual(@as(u64, 45000), ECPAIRING_BASE_GAS_COST);
    try testing.expectEqual(@as(u64, 100000), ECPAIRING_BASE_GAS_COST_BYZANTIUM);

    // ECPAIRING per pair: 80,000 → 34,000 gas
    try testing.expectEqual(@as(u64, 34000), ECPAIRING_PER_PAIR_GAS_COST);
    try testing.expectEqual(@as(u64, 80000), ECPAIRING_PER_PAIR_GAS_COST_BYZANTIUM);
}
```

### hardfork - EIP-2929 Berlin cold/warm access

```zig
test "hardfork - EIP-2929 Berlin cold/warm access" {
    // Berlin introduced cold/warm access patterns

    // Cold access costs (first time in transaction)
    try testing.expectEqual(@as(u64, 2600), ColdAccountAccessCost);
    try testing.expectEqual(@as(u64, 2100), ColdSloadCost);

    // Warm access costs (subsequent accesses)
    try testing.expectEqual(@as(u64, 100), WarmStorageReadCost);
    try testing.expectEqual(@as(u64, 100), SloadGas);

    // CALL cold account cost
    try testing.expectEqual(@as(u64, 2600), CALL_COLD_ACCOUNT_COST);

    // Verify cold costs are higher than warm
    try testing.expect(ColdAccountAccessCost > WarmStorageReadCost);
    try testing.expect(ColdSloadCost > SloadGas);
}
```

### hardfork - EIP-3529 London gas refund changes

```zig
test "hardfork - EIP-3529 London gas refund changes" {
    // London reduced refunds to prevent refund abuse

    // SSTORE refund reduced from 15,000 to 4,800
    try testing.expectEqual(@as(u64, 4800), SstoreRefundGas);

    // SELFDESTRUCT refund removed (was 24,000)
    try testing.expectEqual(@as(u64, 24000), SelfdestructRefundGas);

    // Max refund quotient changed from 2 to 5 (max 1/5 of gas used)
    try testing.expectEqual(@as(u64, 5), MaxRefundQuotient);
}
```

### hardfork - EIP-3860 Shanghai initcode limit

```zig
test "hardfork - EIP-3860 Shanghai initcode limit" {
    // Shanghai introduced init code size limit and per-word cost

    // Maximum init code size (2 * max contract size)
    try testing.expectEqual(@as(u64, 49152), MaxInitcodeSize);

    // Cost per 32-byte word of init code
    try testing.expectEqual(@as(u64, 2), InitcodeWordGas);

    // Verify max size is 2x contract size limit
    const max_contract_size = 24576;
    try testing.expectEqual(max_contract_size * 2, MaxInitcodeSize);
}
```

### hardfork - EIP-1153 Cancun transient storage

```zig
test "hardfork - EIP-1153 Cancun transient storage" {
    // Cancun introduced transient storage opcodes

    // TLOAD and TSTORE both cost 100 gas
    try testing.expectEqual(@as(u64, 100), TLoadGas);
    try testing.expectEqual(@as(u64, 100), TStoreGas);

    // Same as warm storage access
    try testing.expectEqual(TLoadGas, WarmStorageReadCost);
    try testing.expectEqual(TStoreGas, WarmStorageReadCost);

    // Much cheaper than persistent storage
    try testing.expect(TStoreGas < SstoreSetGas);
    try testing.expect(TStoreGas < SstoreResetGas);
}
```

### hardfork - EIP-4844 Cancun blob transactions

```zig
test "hardfork - EIP-4844 Cancun blob transactions" {
    // Cancun introduced blob-carrying transactions

    // BLOBHASH opcode cost
    try testing.expectEqual(@as(u64, 3), BlobHashGas);

    // BLOBBASEFEE opcode cost
    try testing.expectEqual(@as(u64, 2), BlobBaseFeeGas);

    // Blob opcodes are cheap (similar to basic operations)
    try testing.expect(BlobHashGas == GasFastestStep);
    try testing.expect(BlobBaseFeeGas == GasQuickStep);
}
```

### hardfork gas calculation functions

```zig
test "hardfork gas calculation functions" {
    // Test CALL gas with hardfork differences

    // Pre-Berlin: no cold access penalty
    const pre_berlin_call = callGasCostWithHardfork(true, false, true, false);
    try testing.expectEqual(@as(u64, 9100), pre_berlin_call); // 100 + 9000

    // Post-Berlin: cold access penalty
    const post_berlin_call = callGasCostWithHardfork(true, false, true, true);
    try testing.expectEqual(@as(u64, 11700), post_berlin_call); // 100 + 2600 + 9000

    // Test storage gas with hardfork differences

    // Pre-Istanbul simple rules
    const pre_istanbul_sstore = sstoreGasCostWithHardfork(0, 0, 42, false, false, false);
    try testing.expectEqual(@as(u64, 20000), pre_istanbul_sstore);

    // Post-Istanbul with warm access
    const post_istanbul_warm = sstoreGasCostWithHardfork(42, 42, 42, false, false, true);
    try testing.expectEqual(@as(u64, 200), post_istanbul_warm);

    // Post-Berlin with warm access
    const post_berlin_warm = sstoreGasCostWithHardfork(42, 42, 42, false, true, true);
    try testing.expectEqual(@as(u64, 100), post_berlin_warm);

    // Test precompile gas with hardfork differences

    // Pre-Istanbul ECADD
    try testing.expectEqual(@as(u64, 500), ecaddGasCostWithHardfork(false));

    // Post-Istanbul ECADD
    try testing.expectEqual(@as(u64, 150), ecaddGasCostWithHardfork(true));

    // ECPAIRING with 2 pairs
    const pre_istanbul_pairing = ecpairingGasCostWithHardfork(2, false);
    try testing.expectEqual(@as(u64, 260000), pre_istanbul_pairing); // 100000 + 2*80000

    const post_istanbul_pairing = ecpairingGasCostWithHardfork(2, true);
    try testing.expectEqual(@as(u64, 113000), post_istanbul_pairing); // 45000 + 2*34000
}
```

### hardfork - CREATE2 gas calculation across hardforks

```zig
test "hardfork - CREATE2 gas calculation across hardforks" {
    // CREATE2 introduced in Constantinople

    // Pre-Shanghai: no init code word cost
    const init_code_size = 1000;
    const pre_shanghai_cost = createGasCost(init_code_size, 0);
    try testing.expectEqual(@as(u64, 32000), pre_shanghai_cost);

    // Post-Shanghai: init code word cost
    const post_shanghai_cost = createGasCost(init_code_size, InitcodeWordGas);
    const expected_words = wordCount(init_code_size);
    try testing.expectEqual(32000 + expected_words * 2, post_shanghai_cost);

    // Hash cost for CREATE2 (unchanged across hardforks)
    const salt_and_address_size = 85; // 1 + 20 + 32 + 32
    const hash_input_size = salt_and_address_size + init_code_size;
    const hash_cost = keccak256GasCost(hash_input_size);
    try testing.expectEqual(30 + wordCount(hash_input_size) * 6, hash_cost);
}
```

### hardfork - transaction type gas costs

```zig
test "hardfork - transaction type gas costs" {
    // Legacy transaction (all hardforks)
    try testing.expectEqual(@as(u64, 21000), TxGas);

    // Contract creation transaction
    try testing.expectEqual(@as(u64, 53000), TxGasContractCreation);

    // Transaction data costs (unchanged across hardforks)
    try testing.expectEqual(@as(u64, 4), TxDataZeroGas);
    try testing.expectEqual(@as(u64, 16), TxDataNonZeroGas);

    // EIP-2930 (Berlin) introduced access list transactions
    // Access list costs are handled via warm/cold mechanics

    // EIP-1559 (London) introduced base fee transactions
    // Gas costs remain the same, just fee calculation changes
}
```

### hardfork - memory expansion costs unchanged

```zig
test "hardfork - memory expansion costs unchanged" {
    // Memory expansion formula unchanged across hardforks
    // gas = 3n + n²/512

    const sizes = [_]u64{ 0, 32, 64, 128, 256, 512, 1024, 2048, 4096 };

    for (sizes) |size| {
        const cost = memoryGasCost(0, size);
        const words = wordCount(size);
        const expected = MemoryGas * words + (words * words) / QuadCoeffDiv;
        try testing.expectEqual(expected, cost);
    }

    // Verify constants unchanged
    try testing.expectEqual(@as(u64, 3), MemoryGas);
    try testing.expectEqual(@as(u64, 512), QuadCoeffDiv);
}
```

### hardfork - EIP-2200 Istanbul SSTORE gas metering

```zig
test "hardfork - EIP-2200 Istanbul SSTORE gas metering" {
    // Test Istanbul's complex SSTORE gas rules

    // Scenario 1: No-op (current == original == new)
    const no_op_gas = sstoreGasCost(42, 42, 42, false);
    try testing.expectEqual(@as(u64, 100), no_op_gas); // SloadGas

    // Scenario 2: Fresh slot (original == current == 0, new != 0)
    const fresh_slot_gas = sstoreGasCost(0, 0, 42, false);
    try testing.expectEqual(@as(u64, 20000), fresh_slot_gas); // SstoreSetGas

    // Scenario 3: Clean slot (original == current != 0, new == 0)
    const clean_slot_gas = sstoreGasCost(42, 42, 0, false);
    try testing.expectEqual(@as(u64, 5000), clean_slot_gas); // SstoreClearGas

    // Scenario 4: Reset to original (original != current, new == original)
    const reset_original_gas = sstoreGasCost(100, 42, 42, false);
    try testing.expectEqual(@as(u64, 100), reset_original_gas); // SloadGas

    // Scenario 5: Dirty write (original != current, new != original)
    const dirty_write_gas = sstoreGasCost(100, 42, 200, false);
    try testing.expectEqual(@as(u64, 100), dirty_write_gas); // SloadGas
}
```

### hardfork - MODEXP precompile gas thresholds

```zig
test "hardfork - MODEXP precompile gas thresholds" {
    // EIP-2565 introduced new gas calculation for MODEXP

    // Minimum gas cost
    try testing.expectEqual(@as(u64, 200), MODEXP_MIN_GAS);

    // Quadratic threshold (64 bytes)
    try testing.expectEqual(@as(usize, 64), MODEXP_QUADRATIC_THRESHOLD);

    // Linear threshold (1024 bytes)
    try testing.expectEqual(@as(usize, 1024), MODEXP_LINEAR_THRESHOLD);

    // For inputs smaller than 64 bytes, use simple quadratic formula
    // For inputs between 64-1024 bytes, use optimized formula
    // For inputs larger than 1024 bytes, use linear approximation
}
```

### hardfork - gas stipends and retention

```zig
test "hardfork - gas stipends and retention" {
    // Test gas stipend for value transfers
    try testing.expectEqual(@as(u64, 2300), CallStipend);
    try testing.expectEqual(@as(u64, 2300), GAS_STIPEND_VALUE_TRANSFER);

    // Test 63/64 gas retention rule
    try testing.expectEqual(@as(u64, 64), CALL_GAS_RETENTION_DIVISOR);

    // Calculate retained gas for various amounts
    const test_gas_amounts = [_]u64{ 64000, 100000, 1000000 };
    for (test_gas_amounts) |gas| {
        const retained = gas / CALL_GAS_RETENTION_DIVISOR;
        const forwarded = gas - retained;
        // Note: Integer division may cause slight differences
        // 100000 / 64 = 1562 (retained), 100000 - 1562 = 98438
        // 100000 * 63 / 64 = 98437 (due to integer division)
        const expected_forwarded = gas - (gas / 64);
        try testing.expectEqual(expected_forwarded, forwarded);
    }
}
```

### hardfork - gas cost evolution timeline

```zig
test "hardfork - gas cost evolution timeline" {
    // Test how specific operations changed across hardforks

    // SLOAD evolution
    // Pre-Berlin: 200 gas (after EIP-1884)
    // Post-Berlin: 100 gas warm, 2100 gas cold
    try testing.expectEqual(@as(u64, 100), SloadGas); // Warm
    try testing.expectEqual(@as(u64, 2100), ColdSloadCost); // Cold

    // SELFDESTRUCT evolution
    // Pre-EIP-150: 0 gas
    // Post-EIP-150: 5000 gas
    // Post-London: No refund (was 24000)
    try testing.expectEqual(@as(u64, 5000), SelfdestructGas);
    try testing.expectEqual(@as(u64, 24000), SelfdestructRefundGas);

    // BALANCE evolution
    // Pre-EIP-1884: 20 gas
    // Post-EIP-1884: 400 gas
    // Post-Berlin: 100 gas warm, 2600 gas cold
    try testing.expectEqual(@as(u64, 100), CALL_BASE_COST); // Warm access
    try testing.expectEqual(@as(u64, 2600), ColdAccountAccessCost); // Cold
}
```

### hardfork - edge cases across hardforks

```zig
test "hardfork - edge cases across hardforks" {
    // Test edge cases that behave differently across hardforks

    // SSTORE with same value (no-op)
    _ = 5000; // no_op_pre_istanbul: Always charged before Istanbul
    _ = 200; // no_op_istanbul: Reduced in Istanbul
    _ = 100; // no_op_berlin: Further reduced in Berlin

    // Verify current (Berlin+) behavior
    const current_no_op = sstoreGasCost(42, 42, 42, false);
    try testing.expectEqual(@as(u64, 100), current_no_op);

    // CREATE2 with empty init code
    const empty_create2_pre_shanghai = createGasCost(0, 0);
    const empty_create2_post_shanghai = createGasCost(0, InitcodeWordGas);
    try testing.expectEqual(@as(u64, 32000), empty_create2_pre_shanghai);
    try testing.expectEqual(@as(u64, 32000), empty_create2_post_shanghai); // 0 words

    // Transient storage (only exists post-Cancun)
    try testing.expectEqual(@as(u64, 100), TLoadGas);
    try testing.expectEqual(@as(u64, 100), TStoreGas);
}
```

### parity - basic opcode costs match TS

```zig
test "parity - basic opcode costs match TS" {
    // GasQuickStep matches TS QuickStep
    try testing.expectEqual(@as(u64, 2), GasQuickStep);

    // GasFastestStep matches TS FastestStep
    try testing.expectEqual(@as(u64, 3), GasFastestStep);

    // GasFastStep matches TS FastStep
    try testing.expectEqual(@as(u64, 5), GasFastStep);

    // GasMidStep matches TS MidStep
    try testing.expectEqual(@as(u64, 8), GasMidStep);

    // GasSlowStep matches TS SlowStep
    try testing.expectEqual(@as(u64, 10), GasSlowStep);

    // GasExtStep matches TS ExtStep
    try testing.expectEqual(@as(u64, 20), GasExtStep);

    // JumpdestGas matches TS Jumpdest
    try testing.expectEqual(@as(u64, 1), JumpdestGas);
}
```

### parity - hashing costs match TS

```zig
test "parity - hashing costs match TS" {
    // Keccak256Gas matches TS Keccak256Base
    try testing.expectEqual(@as(u64, 30), Keccak256Gas);

    // Keccak256WordGas matches TS Keccak256Word
    try testing.expectEqual(@as(u64, 6), Keccak256WordGas);
}
```

### parity - storage costs match TS

```zig
test "parity - storage costs match TS" {
    // SloadGas matches TS Sload
    try testing.expectEqual(@as(u64, 100), SloadGas);

    // ColdSloadCost matches TS ColdSload
    try testing.expectEqual(@as(u64, 2100), ColdSloadCost);

    // ColdAccountAccessCost matches TS ColdAccountAccess
    try testing.expectEqual(@as(u64, 2600), ColdAccountAccessCost);

    // WarmStorageReadCost matches TS WarmStorageRead
    try testing.expectEqual(@as(u64, 100), WarmStorageReadCost);

    // SstoreSentryGas matches TS SstoreSentry
    try testing.expectEqual(@as(u64, 2300), SstoreSentryGas);

    // SstoreSetGas matches TS SstoreSet
    try testing.expectEqual(@as(u64, 20000), SstoreSetGas);

    // SstoreResetGas matches TS SstoreReset
    try testing.expectEqual(@as(u64, 5000), SstoreResetGas);

    // SstoreClearGas matches TS SstoreClear
    try testing.expectEqual(@as(u64, 5000), SstoreClearGas);

    // SstoreRefundGas matches TS SstoreRefund
    try testing.expectEqual(@as(u64, 4800), SstoreRefundGas);
}
```

### parity - logging costs match TS

```zig
test "parity - logging costs match TS" {
    // LogGas matches TS LogBase
    try testing.expectEqual(@as(u64, 375), LogGas);

    // LogDataGas matches TS LogData
    try testing.expectEqual(@as(u64, 8), LogDataGas);

    // LogTopicGas matches TS LogTopic
    try testing.expectEqual(@as(u64, 375), LogTopicGas);
}
```

### parity - call and create costs match TS

```zig
test "parity - call and create costs match TS" {
    // CreateGas matches TS Create
    try testing.expectEqual(@as(u64, 32000), CreateGas);

    // CallGas matches TS Call (base CALL opcode cost)
    try testing.expectEqual(@as(u64, 40), CallGas);

    // CallBaseCost matches TS Call (newly added)
    try testing.expectEqual(@as(u64, 40), CallBaseCost);

    // CallStipend matches TS CallStipend
    try testing.expectEqual(@as(u64, 2300), CallStipend);

    // CallValueTransferGas matches TS CallValueTransfer
    try testing.expectEqual(@as(u64, 9000), CallValueTransferGas);

    // CallNewAccountGas matches TS CallNewAccount
    try testing.expectEqual(@as(u64, 25000), CallNewAccountGas);

    // CallCodeCost matches TS CallCode
    try testing.expectEqual(@as(u64, 700), CallCodeCost);

    // DelegateCallCost matches TS DelegateCall
    try testing.expectEqual(@as(u64, 700), DelegateCallCost);

    // StaticCallCost matches TS StaticCall
    try testing.expectEqual(@as(u64, 700), StaticCallCost);

    // SelfdestructGas matches TS Selfdestruct
    try testing.expectEqual(@as(u64, 5000), SelfdestructGas);

    // SelfdestructRefundGas matches TS SelfdestructRefund
    try testing.expectEqual(@as(u64, 24000), SelfdestructRefundGas);

    // CALL_GAS_RETENTION_DIVISOR matches TS CallGasRetentionDivisor
    try testing.expectEqual(@as(u64, 64), CALL_GAS_RETENTION_DIVISOR);
}
```

### parity - memory costs match TS

```zig
test "parity - memory costs match TS" {
    // MemoryGas matches TS Memory
    try testing.expectEqual(@as(u64, 3), MemoryGas);

    // QuadCoeffDiv matches TS QuadCoeffDiv
    try testing.expectEqual(@as(u64, 512), QuadCoeffDiv);
}
```

### parity - contract deployment costs match TS

```zig
test "parity - contract deployment costs match TS" {
    // CreateDataGas matches TS CreateData
    try testing.expectEqual(@as(u64, 200), CreateDataGas);

    // InitcodeWordGas matches TS InitcodeWord
    try testing.expectEqual(@as(u64, 2), InitcodeWordGas);

    // MaxInitcodeSize matches TS MaxInitcodeSize
    try testing.expectEqual(@as(u64, 49152), MaxInitcodeSize);
}
```

### parity - transaction costs match TS

```zig
test "parity - transaction costs match TS" {
    // TxGas matches TS Tx
    try testing.expectEqual(@as(u64, 21000), TxGas);

    // TxGasContractCreation matches TS TxContractCreation
    try testing.expectEqual(@as(u64, 53000), TxGasContractCreation);

    // TxDataZeroGas matches TS TxDataZero
    try testing.expectEqual(@as(u64, 4), TxDataZeroGas);

    // TxDataNonZeroGas matches TS TxDataNonZero
    try testing.expectEqual(@as(u64, 16), TxDataNonZeroGas);

    // CopyGas matches TS Copy
    try testing.expectEqual(@as(u64, 3), CopyGas);

    // MaxRefundQuotient matches TS MaxRefundQuotient
    try testing.expectEqual(@as(u64, 5), MaxRefundQuotient);
}
```

### parity - EIP-4844 costs match TS

```zig
test "parity - EIP-4844 costs match TS" {
    // BlobHashGas matches TS BlobHash
    try testing.expectEqual(@as(u64, 3), BlobHashGas);

    // BlobBaseFeeGas matches TS BlobBaseFee
    try testing.expectEqual(@as(u64, 2), BlobBaseFeeGas);
}
```

### parity - EIP-1153 costs match TS

```zig
test "parity - EIP-1153 costs match TS" {
    // TLoadGas matches TS TLoad
    try testing.expectEqual(@as(u64, 100), TLoadGas);

    // TStoreGas matches TS TStore
    try testing.expectEqual(@as(u64, 100), TStoreGas);
}
```

### parity - precompile costs match TS

```zig
test "parity - precompile costs match TS" {
    // ECRECOVER_COST matches TS Precompile.EcRecover
    try testing.expectEqual(@as(u64, 3000), ECRECOVER_COST);

    // SHA256_BASE_COST matches TS Precompile.Sha256Base
    try testing.expectEqual(@as(u64, 60), SHA256_BASE_COST);

    // SHA256_WORD_COST matches TS Precompile.Sha256Word
    try testing.expectEqual(@as(u64, 12), SHA256_WORD_COST);

    // RIPEMD160_BASE_COST matches TS Precompile.Ripemd160Base
    try testing.expectEqual(@as(u64, 600), RIPEMD160_BASE_COST);

    // RIPEMD160_WORD_COST matches TS Precompile.Ripemd160Word
    try testing.expectEqual(@as(u64, 120), RIPEMD160_WORD_COST);

    // IDENTITY_BASE_COST matches TS Precompile.IdentityBase
    try testing.expectEqual(@as(u64, 15), IDENTITY_BASE_COST);

    // IDENTITY_WORD_COST matches TS Precompile.IdentityWord
    try testing.expectEqual(@as(u64, 3), IDENTITY_WORD_COST);

    // MODEXP_MIN_GAS matches TS Precompile.ModExpMin
    try testing.expectEqual(@as(u64, 200), MODEXP_MIN_GAS);

    // MODEXP_QUADRATIC_THRESHOLD matches TS Precompile.ModExpQuadraticThreshold
    try testing.expectEqual(@as(usize, 64), MODEXP_QUADRATIC_THRESHOLD);

    // MODEXP_LINEAR_THRESHOLD matches TS Precompile.ModExpLinearThreshold
    try testing.expectEqual(@as(usize, 1024), MODEXP_LINEAR_THRESHOLD);

    // BN254 Istanbul costs
    try testing.expectEqual(@as(u64, 150), ECADD_GAS_COST);
    try testing.expectEqual(@as(u64, 6000), ECMUL_GAS_COST);
    try testing.expectEqual(@as(u64, 45000), ECPAIRING_BASE_GAS_COST);
    try testing.expectEqual(@as(u64, 34000), ECPAIRING_PER_PAIR_GAS_COST);

    // BN254 Byzantium costs
    try testing.expectEqual(@as(u64, 500), ECADD_GAS_COST_BYZANTIUM);
    try testing.expectEqual(@as(u64, 40000), ECMUL_GAS_COST_BYZANTIUM);
    try testing.expectEqual(@as(u64, 100000), ECPAIRING_BASE_GAS_COST_BYZANTIUM);
    try testing.expectEqual(@as(u64, 80000), ECPAIRING_PER_PAIR_GAS_COST_BYZANTIUM);
}
```
