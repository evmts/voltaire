---
title: '[Zig] src/primitives/ProtocolVersion/ProtocolVersion.zig'
source: 'src/primitives/ProtocolVersion/ProtocolVersion.zig'
---

> Auto-generated from Zig tests in: src/primitives/ProtocolVersion/ProtocolVersion.zig

### ProtocolVersion: init creates protocol version

```zig
test "ProtocolVersion: init creates protocol version" {
    const proto = ProtocolVersion.init("eth", 67);
    try std.testing.expectEqualStrings("eth", proto.protocol);
    try std.testing.expectEqual(@as(u32, 67), proto.version);
}
```

### ProtocolVersion: constants are correct values

```zig
test "ProtocolVersion: constants are correct values" {
    try std.testing.expectEqualStrings("eth", ETH_66.protocol);
    try std.testing.expectEqual(@as(u32, 66), ETH_66.version);

    try std.testing.expectEqualStrings("eth", ETH_67.protocol);
    try std.testing.expectEqual(@as(u32, 67), ETH_67.version);

    try std.testing.expectEqualStrings("eth", ETH_68.protocol);
    try std.testing.expectEqual(@as(u32, 68), ETH_68.version);

    try std.testing.expectEqualStrings("snap", SNAP_1.protocol);
    try std.testing.expectEqual(@as(u32, 1), SNAP_1.version);
}
```

### ProtocolVersion: equals returns true for same protocol

```zig
test "ProtocolVersion: equals returns true for same protocol" {
    const proto1 = ProtocolVersion.init("eth", 67);
    const proto2 = ProtocolVersion.init("eth", 67);
    try std.testing.expect(proto1.equals(proto2));
}
```

### ProtocolVersion: equals returns false for different version

```zig
test "ProtocolVersion: equals returns false for different version" {
    const proto1 = ProtocolVersion.init("eth", 66);
    const proto2 = ProtocolVersion.init("eth", 67);
    try std.testing.expect(!proto1.equals(proto2));
}
```

### ProtocolVersion: equals returns false for different protocol

```zig
test "ProtocolVersion: equals returns false for different protocol" {
    const proto1 = ProtocolVersion.init("eth", 1);
    const proto2 = ProtocolVersion.init("snap", 1);
    try std.testing.expect(!proto1.equals(proto2));
}
```

### ProtocolVersion: equals with constants

```zig
test "ProtocolVersion: equals with constants" {
    try std.testing.expect(ETH_67.equals(ProtocolVersion.init("eth", 67)));
    try std.testing.expect(!ETH_66.equals(ETH_67));
}
```

### ProtocolVersion: compare same protocol different versions

```zig
test "ProtocolVersion: compare same protocol different versions" {
    try std.testing.expectEqual(@as(i32, -1), ETH_66.compare(ETH_67));
    try std.testing.expectEqual(@as(i32, 1), ETH_67.compare(ETH_66));
    try std.testing.expectEqual(@as(i32, 0), ETH_67.compare(ETH_67));
}
```

### ProtocolVersion: compare different protocols

```zig
test "ProtocolVersion: compare different protocols" {
    // Different protocols are not comparable - returns 0
    try std.testing.expectEqual(@as(i32, 0), ETH_67.compare(SNAP_1));
}
```

### ProtocolVersion: toString formats correctly

```zig
test "ProtocolVersion: toString formats correctly" {
    const proto = ProtocolVersion.init("eth", 67);
    const str = try proto.toString(std.testing.allocator);
    defer std.testing.allocator.free(str);
    try std.testing.expectEqualStrings("eth/67", str);
}
```

### ProtocolVersion: toString with snap

```zig
test "ProtocolVersion: toString with snap" {
    const str = try SNAP_1.toString(std.testing.allocator);
    defer std.testing.allocator.free(str);
    try std.testing.expectEqualStrings("snap/1", str);
}
```

### ProtocolVersion: fromString parses valid format

```zig
test "ProtocolVersion: fromString parses valid format" {
    const proto = fromString("eth/67") orelse unreachable;
    try std.testing.expectEqualStrings("eth", proto.protocol);
    try std.testing.expectEqual(@as(u32, 67), proto.version);
}
```

### ProtocolVersion: fromString parses snap/1

```zig
test "ProtocolVersion: fromString parses snap/1" {
    const proto = fromString("snap/1") orelse unreachable;
    try std.testing.expectEqualStrings("snap", proto.protocol);
    try std.testing.expectEqual(@as(u32, 1), proto.version);
}
```

### ProtocolVersion: fromString returns null for invalid format

```zig
test "ProtocolVersion: fromString returns null for invalid format" {
    try std.testing.expectEqual(@as(?ProtocolVersion, null), fromString("eth67"));
    try std.testing.expectEqual(@as(?ProtocolVersion, null), fromString("/67"));
    try std.testing.expectEqual(@as(?ProtocolVersion, null), fromString("eth/"));
    try std.testing.expectEqual(@as(?ProtocolVersion, null), fromString("eth/abc"));
    try std.testing.expectEqual(@as(?ProtocolVersion, null), fromString(""));
}
```

### ProtocolVersion: from creates protocol version

```zig
test "ProtocolVersion: from creates protocol version" {
    const proto = from("eth", 68);
    try std.testing.expectEqualStrings("eth", proto.protocol);
    try std.testing.expectEqual(@as(u32, 68), proto.version);
}
```

### ProtocolVersion: getProtocol returns protocol name

```zig
test "ProtocolVersion: getProtocol returns protocol name" {
    try std.testing.expectEqualStrings("eth", ETH_67.getProtocol());
    try std.testing.expectEqualStrings("snap", SNAP_1.getProtocol());
}
```

### ProtocolVersion: getVersion returns version number

```zig
test "ProtocolVersion: getVersion returns version number" {
    try std.testing.expectEqual(@as(u32, 67), ETH_67.getVersion());
    try std.testing.expectEqual(@as(u32, 1), SNAP_1.getVersion());
}
```

### ProtocolVersion: toNumber returns version

```zig
test "ProtocolVersion: toNumber returns version" {
    try std.testing.expectEqual(@as(u32, 66), ETH_66.toNumber());
    try std.testing.expectEqual(@as(u32, 67), ETH_67.toNumber());
    try std.testing.expectEqual(@as(u32, 68), ETH_68.toNumber());
    try std.testing.expectEqual(@as(u32, 1), SNAP_1.toNumber());
}
```

### ProtocolVersion: toHex returns hex string

```zig
test "ProtocolVersion: toHex returns hex string" {
    var buf: [8]u8 = undefined;
    try std.testing.expectEqualStrings("42", ETH_66.toHex(&buf)); // 66 = 0x42
    try std.testing.expectEqualStrings("43", ETH_67.toHex(&buf)); // 67 = 0x43
    try std.testing.expectEqualStrings("44", ETH_68.toHex(&buf)); // 68 = 0x44
    try std.testing.expectEqualStrings("1", SNAP_1.toHex(&buf));
}
```

### ProtocolVersion: fromHex parses valid hex

```zig
test "ProtocolVersion: fromHex parses valid hex" {
    const proto = fromHex("43") orelse unreachable;
    try std.testing.expectEqualStrings("eth", proto.protocol);
    try std.testing.expectEqual(@as(u32, 67), proto.version);
}
```

### ProtocolVersion: fromHex with 0x prefix

```zig
test "ProtocolVersion: fromHex with 0x prefix" {
    const proto = fromHex("0x43") orelse unreachable;
    try std.testing.expect(proto.equals(ETH_67));
}
```

### ProtocolVersion: fromHex returns null for invalid input

```zig
test "ProtocolVersion: fromHex returns null for invalid input" {
    try std.testing.expect(fromHex("") == null);
    try std.testing.expect(fromHex("0x") == null);
    try std.testing.expect(fromHex("xyz") == null);
}
```

### ProtocolVersion: free function equals

```zig
test "ProtocolVersion: free function equals" {
    try std.testing.expect(equals(ETH_67, from("eth", 67)));
    try std.testing.expect(!equals(ETH_66, ETH_67));
}
```

### ProtocolVersion: complete workflow

```zig
test "ProtocolVersion: complete workflow" {
    // Parse from string
    const proto = fromString("eth/67") orelse unreachable;

    // Check equality
    try std.testing.expect(proto.equals(ETH_67));

    // Compare versions
    try std.testing.expectEqual(@as(i32, 1), proto.compare(ETH_66));
    try std.testing.expectEqual(@as(i32, -1), proto.compare(ETH_68));

    // Convert to string
    const str = try proto.toString(std.testing.allocator);
    defer std.testing.allocator.free(str);
    try std.testing.expectEqualStrings("eth/67", str);

    // toNumber and toHex
    try std.testing.expectEqual(@as(u32, 67), proto.toNumber());
    var buf: [8]u8 = undefined;
    try std.testing.expectEqualStrings("43", proto.toHex(&buf));
}
```
