---
title: '[Zig] src/primitives/PeerInfo/PeerInfo.zig'
source: 'src/primitives/PeerInfo/PeerInfo.zig'
---

> Auto-generated from Zig tests in: src/primitives/PeerInfo/PeerInfo.zig

### PeerInfo: isInbound returns true for inbound peer

```zig
test "PeerInfo: isInbound returns true for inbound peer" {
    const peer = createTestPeer(true);
    try std.testing.expect(peer.isInbound());
}
```

### PeerInfo: isInbound returns false for outbound peer

```zig
test "PeerInfo: isInbound returns false for outbound peer" {
    const peer = createTestPeer(false);
    try std.testing.expect(!peer.isInbound());
}
```

### PeerInfo: isOutbound returns true for outbound peer

```zig
test "PeerInfo: isOutbound returns true for outbound peer" {
    const peer = createTestPeer(false);
    try std.testing.expect(peer.isOutbound());
}
```

### PeerInfo: isOutbound returns false for inbound peer

```zig
test "PeerInfo: isOutbound returns false for inbound peer" {
    const peer = createTestPeer(true);
    try std.testing.expect(!peer.isOutbound());
}
```

### PeerInfo: isTrusted returns correct value

```zig
test "PeerInfo: isTrusted returns correct value" {
    const peer_id = PeerId.from("enode://abc@127.0.0.1:30303") catch unreachable;
    const peer = init(
        peer_id,
        "Geth/v1.10.26",
        &test_caps,
        .{
            .local_address = "192.168.1.1:30303",
            .remote_address = "10.0.0.1:30303",
            .inbound = false,
            .trusted = true,
            .static = false,
        },
        .{ .eth = null },
    );
    try std.testing.expect(peer.isTrusted());
}
```

### PeerInfo: isStatic returns correct value

```zig
test "PeerInfo: isStatic returns correct value" {
    const peer_id = PeerId.from("enode://abc@127.0.0.1:30303") catch unreachable;
    const peer = init(
        peer_id,
        "Geth/v1.10.26",
        &test_caps,
        .{
            .local_address = "192.168.1.1:30303",
            .remote_address = "10.0.0.1:30303",
            .inbound = false,
            .trusted = false,
            .static = true,
        },
        .{ .eth = null },
    );
    try std.testing.expect(peer.isStatic());
}
```

### PeerInfo: hasCapability returns true for supported capability

```zig
test "PeerInfo: hasCapability returns true for supported capability" {
    const peer = createTestPeer(false);
    try std.testing.expect(peer.hasCapability("eth/67"));
    try std.testing.expect(peer.hasCapability("snap/1"));
}
```

### PeerInfo: hasCapability returns false for unsupported capability

```zig
test "PeerInfo: hasCapability returns false for unsupported capability" {
    const peer = createTestPeer(false);
    try std.testing.expect(!peer.hasCapability("eth/66"));
    try std.testing.expect(!peer.hasCapability("les/2"));
}
```

### PeerInfo: getEthProtocol returns null when not supported

```zig
test "PeerInfo: getEthProtocol returns null when not supported" {
    const peer = createTestPeer(false);
    try std.testing.expectEqual(@as(?EthProtocolInfo, null), peer.getEthProtocol());
}
```

### PeerInfo: getEthProtocol returns info when supported

```zig
test "PeerInfo: getEthProtocol returns info when supported" {
    const peer_id = PeerId.from("enode://abc@127.0.0.1:30303") catch unreachable;
    var head: [32]u8 = undefined;
    @memset(&head, 0xAB);

    const peer = init(
        peer_id,
        "Geth/v1.10.26",
        &test_caps,
        .{
            .local_address = "192.168.1.1:30303",
            .remote_address = "10.0.0.1:30303",
            .inbound = false,
            .trusted = false,
            .static = false,
        },
        .{ .eth = .{
            .version = ProtocolVersion.ETH_67,
            .difficulty = 12345678,
            .head = head,
        } },
    );

    const eth = peer.getEthProtocol() orelse unreachable;
    try std.testing.expect(eth.version.equals(ProtocolVersion.ETH_67));
    try std.testing.expectEqual(@as(u256, 12345678), eth.difficulty);
}
```

### PeerInfo: supportsEth returns correct value

```zig
test "PeerInfo: supportsEth returns correct value" {
    const peer_without_eth = createTestPeer(false);
    try std.testing.expect(!peer_without_eth.supportsEth());

    const peer_id = PeerId.from("enode://abc@127.0.0.1:30303") catch unreachable;
    var head: [32]u8 = undefined;
    @memset(&head, 0);

    const peer_with_eth = init(
        peer_id,
        "Geth/v1.10.26",
        &test_caps,
        .{
            .local_address = "192.168.1.1:30303",
            .remote_address = "10.0.0.1:30303",
            .inbound = false,
            .trusted = false,
            .static = false,
        },
        .{ .eth = .{
            .version = ProtocolVersion.ETH_67,
            .difficulty = 0,
            .head = head,
        } },
    );
    try std.testing.expect(peer_with_eth.supportsEth());
}
```

### PeerInfo: equals compares by ID

```zig
test "PeerInfo: equals compares by ID" {
    const peer1 = createTestPeer(true);
    const peer2 = createTestPeer(false); // Different inbound status, same ID
    try std.testing.expect(peer1.equals(peer2));

    const peer_id_diff = PeerId.from("enode://def@127.0.0.1:30303") catch unreachable;
    const peer3 = init(
        peer_id_diff,
        "Geth/v1.10.26",
        &test_caps,
        .{
            .local_address = "192.168.1.1:30303",
            .remote_address = "10.0.0.1:30303",
            .inbound = true,
            .trusted = false,
            .static = false,
        },
        .{ .eth = null },
    );
    try std.testing.expect(!peer1.equals(peer3));
}
```

### PeerInfo: access name field

```zig
test "PeerInfo: access name field" {
    const peer = createTestPeer(false);
    try std.testing.expectEqualStrings("Geth/v1.10.26-stable", peer.name);
}
```

### PeerInfo: access network addresses

```zig
test "PeerInfo: access network addresses" {
    const peer = createTestPeer(false);
    try std.testing.expectEqualStrings("192.168.1.1:30303", peer.network.local_address);
    try std.testing.expectEqualStrings("10.0.0.1:30303", peer.network.remote_address);
}
```

### PeerInfo: complete workflow

```zig
test "PeerInfo: complete workflow" {
    const peer_id = PeerId.from("enode://abc@10.0.0.1:30303") catch unreachable;
    var head: [32]u8 = undefined;
    @memset(&head, 0xCD);

    const peer = init(
        peer_id,
        "Geth/v1.10.26-stable-abc123",
        &test_caps,
        .{
            .local_address = "192.168.1.100:30303",
            .remote_address = "10.0.0.1:30303",
            .inbound = true,
            .trusted = true,
            .static = false,
        },
        .{ .eth = .{
            .version = ProtocolVersion.ETH_68,
            .difficulty = 999999999999,
            .head = head,
        } },
    );

    // Check connection properties
    try std.testing.expect(peer.isInbound());
    try std.testing.expect(peer.isTrusted());
    try std.testing.expect(!peer.isStatic());

    // Check capabilities
    try std.testing.expect(peer.hasCapability("eth/67"));
    try std.testing.expect(peer.hasCapability("snap/1"));
    try std.testing.expect(!peer.hasCapability("eth/66"));

    // Check protocol info
    try std.testing.expect(peer.supportsEth());
    const eth = peer.getEthProtocol() orelse unreachable;
    try std.testing.expect(eth.version.equals(ProtocolVersion.ETH_68));
}
```
