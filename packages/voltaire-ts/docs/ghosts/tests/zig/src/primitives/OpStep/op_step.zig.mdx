---
title: '[Zig] src/primitives/OpStep/op_step.zig'
source: 'src/primitives/OpStep/op_step.zig'
---

> Auto-generated from Zig tests in: src/primitives/OpStep/op_step.zig

### OpStep: basic creation

```zig
test "OpStep: basic creation" {
    const step = OpStep.from(0, .PUSH1, 1000000, 3, 0);

    try testing.expectEqual(@as(u64, 0), step.pc);
    try testing.expectEqual(Opcode.PUSH1, step.op);
    try testing.expectEqual(@as(u64, 1000000), step.gas);
    try testing.expectEqual(@as(u64, 3), step.gas_cost);
    try testing.expectEqual(@as(u32, 0), step.depth);
    try testing.expect(step.stack == null);
    try testing.expect(step.memory == null);
    try testing.expect(step.err == null);
}
```

### OpStep: equality

```zig
test "OpStep: equality" {
    const step1 = OpStep.from(0, .ADD, 1000, 3, 1);
    const step2 = OpStep.from(0, .ADD, 1000, 3, 1);
    const step3 = OpStep.from(1, .ADD, 1000, 3, 1);

    try testing.expect(step1.equals(step2));
    try testing.expect(!step1.equals(step3));
}
```

### OpStep: hasError

```zig
test "OpStep: hasError" {
    var step = OpStep.from(10, .SSTORE, 500, 5000, 0);
    try testing.expect(!step.hasError());

    step.err = "stack underflow";
    try testing.expect(step.hasError());
}
```

### OpStep: opcode utilities

```zig
test "OpStep: opcode utilities" {
    const push_step = OpStep.from(0, .PUSH1, 1000, 3, 0);
    try testing.expect(push_step.isPush());
    try testing.expect(!push_step.isTerminating());
    try testing.expect(!push_step.isStateModifying());
    try testing.expectEqual(@as(u8, 0x60), push_step.opByte());
    try testing.expectEqualStrings("PUSH1", push_step.opName());

    const stop_step = OpStep.from(100, .STOP, 0, 0, 0);
    try testing.expect(stop_step.isTerminating());
    try testing.expect(!stop_step.isPush());

    const sstore_step = OpStep.from(50, .SSTORE, 1000, 5000, 0);
    try testing.expect(sstore_step.isStateModifying());
}
```

### OpStep: stack and memory depth

```zig
test "OpStep: stack and memory depth" {
    const step1 = OpStep.from(0, .ADD, 1000, 3, 0);
    try testing.expectEqual(@as(usize, 0), step1.stackDepth());
    try testing.expectEqual(@as(usize, 0), step1.memorySize());

    var stack: [3][32]u8 = undefined;
    @memset(&stack[0], 0);
    @memset(&stack[1], 0);
    @memset(&stack[2], 0);

    var memory = [_]u8{ 0x00, 0x01, 0x02, 0x03 };

    const step2 = OpStep.fromFull(0, .ADD, 1000, 3, 0, &stack, &memory, null, null);
    try testing.expectEqual(@as(usize, 3), step2.stackDepth());
    try testing.expectEqual(@as(usize, 4), step2.memorySize());
}
```

### OpStep: JSON encode

```zig
test "OpStep: JSON encode" {
    const allocator = testing.allocator;
    const step = OpStep.from(42, .ADD, 999, 3, 1);

    const json_str = try step.toJson(allocator);
    defer allocator.free(json_str);

    try testing.expect(std.mem.indexOf(u8, json_str, "\"pc\":42") != null);
    try testing.expect(std.mem.indexOf(u8, json_str, "\"op\":1") != null); // ADD = 0x01
    try testing.expect(std.mem.indexOf(u8, json_str, "\"gas\":999") != null);
    try testing.expect(std.mem.indexOf(u8, json_str, "\"gasCost\":3") != null);
    try testing.expect(std.mem.indexOf(u8, json_str, "\"depth\":1") != null);
}
```

### OpStep: JSON roundtrip

```zig
test "OpStep: JSON roundtrip" {
    const allocator = testing.allocator;
    const step = OpStep.from(42, .MUL, 999, 5, 2);

    const json_str = try step.toJson(allocator);
    defer allocator.free(json_str);

    const decoded = try OpStep.fromJson(allocator, json_str);

    try testing.expectEqual(step.pc, decoded.pc);
    try testing.expectEqual(step.op, decoded.op);
    try testing.expectEqual(step.gas, decoded.gas);
    try testing.expectEqual(step.gas_cost, decoded.gas_cost);
    try testing.expectEqual(step.depth, decoded.depth);
}
```
