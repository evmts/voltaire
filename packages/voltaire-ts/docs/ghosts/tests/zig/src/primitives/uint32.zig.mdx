---
title: '[Zig] src/primitives/uint32.zig'
source: 'src/primitives/uint32.zig'
---

> Auto-generated from Zig tests in: src/primitives/uint32.zig

### Uint32 constants

```zig
test "Uint32 constants" {
    try testing.expectEqual(@as(u32, 0), Uint32.MIN.value);
    try testing.expectEqual(@as(u32, 4294967295), Uint32.MAX.value);
    try testing.expectEqual(@as(u32, 0), Uint32.ZERO.value);
    try testing.expectEqual(@as(u32, 1), Uint32.ONE.value);
    try testing.expectEqual(@as(usize, 4), Uint32.SIZE);
    try testing.expectEqual(@as(usize, 32), Uint32.BITS);
}
```

### Uint32 from

```zig
test "Uint32 from" {
    const a = Uint32.from(42);
    try testing.expectEqual(@as(u32, 42), a.value);

    const b = Uint32.from(0);
    try testing.expectEqual(@as(u32, 0), b.value);

    const c = Uint32.from(4294967295);
    try testing.expectEqual(@as(u32, 4294967295), c.value);
}
```

### Uint32 fromNumber

```zig
test "Uint32 fromNumber" {
    const a = Uint32.fromNumber(42);
    try testing.expect(a != null);
    try testing.expectEqual(@as(u32, 42), a.?.value);

    const b = Uint32.fromNumber(4294967296);
    try testing.expect(b == null);

    const c = Uint32.fromNumber(-1);
    try testing.expect(c == null);
}
```

### Uint32 fromHex

```zig
test "Uint32 fromHex" {
    const a = try Uint32.fromHex("0x0000002a");
    try testing.expectEqual(@as(u32, 42), a.value);

    const b = try Uint32.fromHex("ffffffff");
    try testing.expectEqual(@as(u32, 4294967295), b.value);

    const c = try Uint32.fromHex("0X00000000");
    try testing.expectEqual(@as(u32, 0), c.value);

    try testing.expectError(error.InvalidHex, Uint32.fromHex("0x100000000"));
    try testing.expectError(error.InvalidHex, Uint32.fromHex(""));
    try testing.expectError(error.InvalidHex, Uint32.fromHex("0x"));
}
```

### Uint32 fromBytes

```zig
test "Uint32 fromBytes" {
    const bytes_be = [_]u8{ 0x00, 0x00, 0x00, 0x2a };
    const a = Uint32.fromBytes(&bytes_be);
    try testing.expect(a != null);
    try testing.expectEqual(@as(u32, 42), a.?.value);

    const bytes_le = [_]u8{ 0x2a, 0x00, 0x00, 0x00 };
    const b = Uint32.fromBytesLittle(&bytes_le);
    try testing.expect(b != null);
    try testing.expectEqual(@as(u32, 42), b.?.value);

    const empty: []const u8 = &.{};
    try testing.expect(Uint32.fromBytes(empty) == null);

    const too_long = [_]u8{ 1, 2, 3, 4, 5 };
    try testing.expect(Uint32.fromBytes(&too_long) == null);
}
```

### Uint32 toNumber

```zig
test "Uint32 toNumber" {
    const a = Uint32.from(42);
    try testing.expectEqual(@as(u32, 42), a.toNumber());
}
```

### Uint32 toHex

```zig
test "Uint32 toHex" {
    var buf: [10]u8 = undefined;

    const a = Uint32.from(42);
    try testing.expectEqualStrings("0x0000002a", a.toHex(&buf));

    const b = Uint32.from(4294967295);
    try testing.expectEqualStrings("0xffffffff", b.toHex(&buf));

    const c = Uint32.from(0);
    try testing.expectEqualStrings("0x00000000", c.toHex(&buf));
}
```

### Uint32 toBytes

```zig
test "Uint32 toBytes" {
    var buf: [4]u8 = undefined;
    const a = Uint32.from(0x12345678);
    const bytes = a.toBytes(&buf);
    try testing.expectEqual(@as(usize, 4), bytes.len);
    try testing.expectEqual(@as(u8, 0x12), bytes[0]);
    try testing.expectEqual(@as(u8, 0x34), bytes[1]);
    try testing.expectEqual(@as(u8, 0x56), bytes[2]);
    try testing.expectEqual(@as(u8, 0x78), bytes[3]);

    const bytes_le = a.toBytesLittle(&buf);
    try testing.expectEqual(@as(u8, 0x78), bytes_le[0]);
    try testing.expectEqual(@as(u8, 0x56), bytes_le[1]);
    try testing.expectEqual(@as(u8, 0x34), bytes_le[2]);
    try testing.expectEqual(@as(u8, 0x12), bytes_le[3]);
}
```

### Uint32 checked add

```zig
test "Uint32 checked add" {
    const a = Uint32.from(2000000000);
    const b = Uint32.from(1000000000);
    const result = a.add(b);
    try testing.expect(result != null);
    try testing.expectEqual(@as(u32, 3000000000), result.?.value);

    const c = Uint32.from(3000000000);
    const d = Uint32.from(2000000000);
    try testing.expect(c.add(d) == null);
}
```

### Uint32 checked sub

```zig
test "Uint32 checked sub" {
    const a = Uint32.from(3000000000);
    const b = Uint32.from(1000000000);
    const result = a.sub(b);
    try testing.expect(result != null);
    try testing.expectEqual(@as(u32, 2000000000), result.?.value);

    const c = Uint32.from(1000000000);
    const d = Uint32.from(2000000000);
    try testing.expect(c.sub(d) == null);
}
```

### Uint32 checked mul

```zig
test "Uint32 checked mul" {
    const a = Uint32.from(50000);
    const b = Uint32.from(80000);
    const result = a.mul(b);
    try testing.expect(result != null);
    try testing.expectEqual(@as(u32, 4000000000), result.?.value);

    const c = Uint32.from(100000);
    const d = Uint32.from(100000);
    try testing.expect(c.mul(d) == null);
}
```

### Uint32 checked div

```zig
test "Uint32 checked div" {
    const a = Uint32.from(1000000000);
    const b = Uint32.from(10000);
    const result = a.div(b);
    try testing.expect(result != null);
    try testing.expectEqual(@as(u32, 100000), result.?.value);

    const c = Uint32.from(100);
    const d = Uint32.from(0);
    try testing.expect(c.div(d) == null);
}
```

### Uint32 checked mod

```zig
test "Uint32 checked mod" {
    const a = Uint32.from(1000000000);
    const b = Uint32.from(300000000);
    const result = a.mod(b);
    try testing.expect(result != null);
    try testing.expectEqual(@as(u32, 100000000), result.?.value);

    const c = Uint32.from(100);
    const d = Uint32.from(0);
    try testing.expect(c.mod(d) == null);
}
```

### Uint32 checked pow

```zig
test "Uint32 checked pow" {
    const a = Uint32.from(2);
    const result = a.pow(10);
    try testing.expect(result != null);
    try testing.expectEqual(@as(u32, 1024), result.?.value);

    const b = Uint32.from(10);
    const result2 = b.pow(9);
    try testing.expect(result2 != null);
    try testing.expectEqual(@as(u32, 1000000000), result2.?.value);

    const c = Uint32.from(100);
    try testing.expect(c.pow(5) == null);

    try testing.expectEqual(@as(u32, 1), Uint32.from(5).pow(0).?.value);
    try testing.expectEqual(@as(u32, 0), Uint32.from(0).pow(5).?.value);
    try testing.expectEqual(@as(u32, 1), Uint32.from(1).pow(31).?.value);
}
```

### Uint32 wrapping arithmetic

```zig
test "Uint32 wrapping arithmetic" {
    const a = Uint32.from(3000000000);
    const b = Uint32.from(2000000000);
    try testing.expectEqual(@as(u32, 705032704), a.wrappingAdd(b).value);

    const c = Uint32.from(1000000000);
    const d = Uint32.from(2000000000);
    try testing.expectEqual(@as(u32, 3294967296), c.wrappingSub(d).value);
}
```

### Uint32 saturating arithmetic

```zig
test "Uint32 saturating arithmetic" {
    const a = Uint32.from(3000000000);
    const b = Uint32.from(2000000000);
    try testing.expectEqual(@as(u32, 4294967295), a.saturatingAdd(b).value);

    const c = Uint32.from(1000000000);
    const d = Uint32.from(2000000000);
    try testing.expectEqual(@as(u32, 0), c.saturatingSub(d).value);
}
```

### Uint32 comparison

```zig
test "Uint32 comparison" {
    const a = Uint32.from(1000000000);
    const b = Uint32.from(1000000000);
    const c = Uint32.from(500000000);

    try testing.expect(a.equals(b));
    try testing.expect(!a.equals(c));

    try testing.expectEqual(std.math.Order.eq, a.compare(b));
    try testing.expectEqual(std.math.Order.gt, a.compare(c));
    try testing.expectEqual(std.math.Order.lt, c.compare(a));

    try testing.expect(!a.lessThan(b));
    try testing.expect(c.lessThan(a));
    try testing.expect(a.greaterThan(c));
    try testing.expect(a.lessThanOrEqual(b));
    try testing.expect(a.greaterThanOrEqual(b));
}
```

### Uint32 bitwise operations

```zig
test "Uint32 bitwise operations" {
    const a = Uint32.from(0xFFFF0000);
    const b = Uint32.from(0x0F0F0F0F);

    try testing.expectEqual(@as(u32, 0x0F0F0000), a.bitwiseAnd(b).value);
    try testing.expectEqual(@as(u32, 0xFFFF0F0F), a.bitwiseOr(b).value);
    try testing.expectEqual(@as(u32, 0xF0F00F0F), a.bitwiseXor(b).value);
    try testing.expectEqual(@as(u32, 0x0000FFFF), a.bitwiseNot().value);
}
```

### Uint32 shift operations

```zig
test "Uint32 shift operations" {
    const a = Uint32.from(0x000000FF);
    try testing.expectEqual(@as(u32, 0x0000FF00), a.shiftLeft(8).value);
    try testing.expectEqual(@as(u32, 0x0000000F), a.shiftRight(4).value);
}
```

### Uint32 rotate operations

```zig
test "Uint32 rotate operations" {
    const a = Uint32.from(0x12345678);
    try testing.expectEqual(@as(u32, 0x23456781), a.rotateLeft(4).value);
    try testing.expectEqual(@as(u32, 0x81234567), a.rotateRight(4).value);
}
```

### Uint32 utility functions

```zig
test "Uint32 utility functions" {
    const zero = Uint32.from(0);
    const nonzero = Uint32.from(42);

    try testing.expect(zero.isZero());
    try testing.expect(!nonzero.isZero());

    const a = Uint32.from(100000);
    const b = Uint32.from(200000);
    try testing.expectEqual(@as(u32, 100000), a.min(b).value);
    try testing.expectEqual(@as(u32, 200000), a.max(b).value);
}
```

### Uint32 bit counting

```zig
test "Uint32 bit counting" {
    const a = Uint32.from(0b00101100000000000000000000000000);
    try testing.expectEqual(@as(u6, 30), a.bitLength());
    try testing.expectEqual(@as(u6, 2), a.leadingZeros());
    try testing.expectEqual(@as(u6, 26), a.trailingZeros());
    try testing.expectEqual(@as(u6, 3), a.popCount());

    const zero = Uint32.from(0);
    try testing.expectEqual(@as(u6, 0), zero.bitLength());
    try testing.expectEqual(@as(u6, 32), zero.leadingZeros());
}
```

### Uint32 byteSwap

```zig
test "Uint32 byteSwap" {
    const a = Uint32.from(0x12345678);
    try testing.expectEqual(@as(u32, 0x78563412), a.byteSwap().value);
}
```

### Uint32 reverseBits

```zig
test "Uint32 reverseBits" {
    const a = Uint32.from(0x80000000);
    try testing.expectEqual(@as(u32, 0x00000001), a.reverseBits().value);

    const b = Uint32.from(0x12345678);
    const rev = b.reverseBits();
    try testing.expectEqual(@as(u32, 0x1E6A2C48), rev.value);
}
```
