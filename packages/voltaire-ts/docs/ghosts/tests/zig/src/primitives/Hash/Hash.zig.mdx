---
title: '[Zig] src/primitives/Hash/Hash.zig'
source: 'src/primitives/Hash/Hash.zig'
---

> Auto-generated from Zig tests in: src/primitives/Hash/Hash.zig

### fromBytes - valid 32 bytes

```zig
test "fromBytes - valid 32 bytes" {
    const bytes = [_]u8{1} ** SIZE;
    const hash = fromBytes(&bytes);
    try std.testing.expectEqual(SIZE, hash.len);
    try std.testing.expectEqual(@as(u8, 1), hash[0]);
    try std.testing.expectEqual(@as(u8, 1), hash[31]);
}
```

### fromBytes - creates independent copy

```zig
test "fromBytes - creates independent copy" {
    var bytes = [_]u8{42} ** SIZE;
    const hash = fromBytes(&bytes);
    bytes[0] = 99;
    try std.testing.expectEqual(@as(u8, 42), hash[0]);
}
```

### fromHex - with 0x prefix

```zig
test "fromHex - with 0x prefix" {
    const hex = "0x" ++ ("ab" ** SIZE);
    const hash = try fromHex(hex);
    try std.testing.expectEqual(@as(u8, 0xab), hash[0]);
    try std.testing.expectEqual(@as(u8, 0xab), hash[31]);
}
```

### fromHex - without 0x prefix

```zig
test "fromHex - without 0x prefix" {
    const hex = "cd" ** SIZE;
    const hash = try fromHex(hex);
    try std.testing.expectEqual(@as(u8, 0xcd), hash[0]);
}
```

### fromHex - invalid length

```zig
test "fromHex - invalid length" {
    const hex = "0xaabb";
    try std.testing.expectError(error.InvalidHashLength, fromHex(hex));
}
```

### fromHex - invalid hex chars

```zig
test "fromHex - invalid hex chars" {
    const hex = "0x" ++ ("zz" ** SIZE);
    try std.testing.expectError(error.InvalidHexCharacter, fromHex(hex));
}
```

### from - Hash passthrough

```zig
test "from - Hash passthrough" {
    const hash1: Hash = ZERO;
    const hash2 = try from(hash1);
    try std.testing.expectEqualSlices(u8, &hash1, &hash2);
}
```

### from - raw bytes

```zig
test "from - raw bytes" {
    const bytes = [_]u8{42} ** SIZE;
    const hash = try from(bytes[0..]);
    try std.testing.expectEqual(@as(u8, 42), hash[0]);
}
```

### from - hex with 0x

```zig
test "from - hex with 0x" {
    const hex = "0x" ++ ("ef" ** SIZE);
    const hash = try from(hex);
    try std.testing.expectEqual(@as(u8, 0xef), hash[0]);
}
```

### from - hex without 0x

```zig
test "from - hex without 0x" {
    const hex = "12" ** SIZE;
    const hash = try from(hex);
    try std.testing.expectEqual(@as(u8, 0x12), hash[0]);
}
```

### toBytes - returns correct slice

```zig
test "toBytes - returns correct slice" {
    var hash: Hash = undefined;
    @memset(&hash, 0xaa);
    const bytes = toBytes(&hash);
    try std.testing.expectEqual(SIZE, bytes.len);
    try std.testing.expectEqual(@as(u8, 0xaa), bytes[0]);
    try std.testing.expectEqual(@as(u8, 0xaa), bytes[31]);
}
```

### toHex - with 0x prefix

```zig
test "toHex - with 0x prefix" {
    var hash: Hash = undefined;
    @memset(&hash, 0xff);
    const hex = try toHex(&hash, std.testing.allocator);
    defer std.testing.allocator.free(hex);

    try std.testing.expectEqual(2 + SIZE * 2, hex.len);
    try std.testing.expect(std.mem.startsWith(u8, hex, "0x"));
    try std.testing.expect(std.mem.eql(u8, hex, "0x" ++ ("ff" ** SIZE)));
}
```

### toString - same as toHex

```zig
test "toString - same as toHex" {
    const hash: Hash = ZERO;
    const str = try toString(&hash, std.testing.allocator);
    defer std.testing.allocator.free(str);
    const hex_str = try toHex(&hash, std.testing.allocator);
    defer std.testing.allocator.free(hex_str);
    try std.testing.expect(std.mem.eql(u8, str, hex_str));
}
```

### equals - same hash

```zig
test "equals - same hash" {
    const hash: Hash = [_]u8{42} ** SIZE;
    try std.testing.expect(equals(&hash, &hash));
}
```

### equals - identical hashes

```zig
test "equals - identical hashes" {
    const hash1: Hash = [_]u8{99} ** SIZE;
    const hash2: Hash = [_]u8{99} ** SIZE;
    try std.testing.expect(equals(&hash1, &hash2));
}
```

### equals - different hashes

```zig
test "equals - different hashes" {
    const hash1: Hash = [_]u8{1} ** SIZE;
    const hash2: Hash = [_]u8{2} ** SIZE;
    try std.testing.expect(!equals(&hash1, &hash2));
}
```

### isZero - zero hash

```zig
test "isZero - zero hash" {
    const hash: Hash = ZERO;
    try std.testing.expect(isZero(&hash));
}
```

### isZero - non-zero hash

```zig
test "isZero - non-zero hash" {
    var hash: Hash = ZERO;
    hash[0] = 1;
    try std.testing.expect(!isZero(&hash));
}
```

### assert - always succeeds for Hash type

```zig
test "assert - always succeeds for Hash type" {
    const hash: Hash = ZERO;
    assert(&hash);
}
```

### isValidHex - valid with 0x

```zig
test "isValidHex - valid with 0x" {
    const hex = "0x" ++ ("ab" ** SIZE);
    try std.testing.expect(isValidHex(hex));
}
```

### isValidHex - valid without 0x

```zig
test "isValidHex - valid without 0x" {
    const hex = "cd" ** SIZE;
    try std.testing.expect(isValidHex(hex));
}
```

### isValidHex - invalid length

```zig
test "isValidHex - invalid length" {
    try std.testing.expect(!isValidHex("0xaabb"));
}
```

### isValidHex - invalid chars

```zig
test "isValidHex - invalid chars" {
    const hex = "0x" ++ ("zz" ** SIZE);
    try std.testing.expect(!isValidHex(hex));
}
```

### isValidHex - no 0x prefix but wrong length

```zig
test "isValidHex - no 0x prefix but wrong length" {
    try std.testing.expect(!isValidHex("abcd"));
}
```

### isHash - Hash type

```zig
test "isHash - Hash type" {
    const hash: Hash = ZERO;
    try std.testing.expect(isHash(hash));
}
```

### isHash - pointer types

```zig
test "isHash - pointer types" {
    const hash: Hash = ZERO;
    try std.testing.expect(isHash(&hash));
}
```

### isHash - non-Hash type

```zig
test "isHash - non-Hash type" {
    const bytes = [_]u8{0} ** 16;
    try std.testing.expect(!isHash(bytes));
}
```

### clone - creates independent copy

```zig
test "clone - creates independent copy" {
    var original: Hash = [_]u8{42} ** SIZE;
    var copy = clone(&original);
    try std.testing.expect(equals(&original, &copy));

    // Modify original
    original[0] = 99;
    try std.testing.expect(!equals(&original, &copy));
    try std.testing.expectEqual(@as(u8, 42), copy[0]);
}
```

### slice - partial slice

```zig
test "slice - partial slice" {
    var hash: Hash = undefined;
    for (0..SIZE) |i| {
        hash[i] = @intCast(i);
    }
    const s = slice(&hash, 0, 10);
    try std.testing.expectEqual(@as(usize, 10), s.len);
    try std.testing.expectEqual(@as(u8, 0), s[0]);
    try std.testing.expectEqual(@as(u8, 9), s[9]);
}
```

### slice - full slice

```zig
test "slice - full slice" {
    const hash: Hash = [_]u8{77} ** SIZE;
    const s = slice(&hash, 0, SIZE);
    try std.testing.expectEqual(SIZE, s.len);
    try std.testing.expectEqualSlices(u8, &hash, s);
}
```

### format - returns hex string

```zig
test "format - returns hex string" {
    const hash: Hash = ZERO;
    const formatted = try format(&hash, std.testing.allocator);
    defer std.testing.allocator.free(formatted);
    try std.testing.expect(std.mem.startsWith(u8, formatted, "0x"));
    try std.testing.expectEqual(2 + SIZE * 2, formatted.len);
}
```

### random - generates different hashes

```zig
test "random - generates different hashes" {
    const hash1 = random();
    const hash2 = random();
    // Astronomically unlikely to be equal
    try std.testing.expect(!equals(&hash1, &hash2));
}
```

### random - correct size

```zig
test "random - correct size" {
    const hash = random();
    try std.testing.expectEqual(SIZE, hash.len);
}
```

### keccak256 - empty data

```zig
test "keccak256 - empty data" {
    const hash = keccak256("");
    // Known Keccak256 of empty string
    const expected_hex = "0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470";
    const expected = try fromHex(expected_hex);
    try std.testing.expect(equals(&hash, &expected));
}
```

### keccak256 - known vector

```zig
test "keccak256 - known vector" {
    const hash = keccak256("abc");
    // Known Keccak256("abc")
    const expected_hex = "0x4e03657aea45a94fc7d47ba826c8d667c0d1e6e33a64a036ec44f58fa12d6c45";
    const expected = try fromHex(expected_hex);
    try std.testing.expect(equals(&hash, &expected));
}
```

### keccak256String - same as keccak256

```zig
test "keccak256String - same as keccak256" {
    const str = "test string";
    const hash1 = keccak256String(str);
    const hash2 = keccak256(str);
    try std.testing.expect(equals(&hash1, &hash2));
}
```

### keccak256Hex - valid hex

```zig
test "keccak256Hex - valid hex" {
    const hex = "0xaabbccdd";
    const hash = try keccak256Hex(hex);

    // Verify by converting hex to bytes and hashing
    const bytes = try Hex.toBytes(hex, std.testing.allocator);
    defer std.testing.allocator.free(bytes);
    const expected = keccak256(bytes);

    try std.testing.expect(equals(&hash, &expected));
}
```

### concat - two hashes

```zig
test "concat - two hashes" {
    const hash1: Hash = [_]u8{0xaa} ** SIZE;
    const hash2: Hash = [_]u8{0xbb} ** SIZE;
    const hashes = [_]Hash{ hash1, hash2 };

    const result = try concat(std.testing.allocator, &hashes);

    // Verify by manually concatenating
    var buffer: [SIZE * 2]u8 = undefined;
    @memcpy(buffer[0..SIZE], &hash1);
    @memcpy(buffer[SIZE .. SIZE * 2], &hash2);
    const expected = keccak256(&buffer);

    try std.testing.expect(equals(&result, &expected));
}
```

### concat - single hash

```zig
test "concat - single hash" {
    const hash1: Hash = [_]u8{0xcc} ** SIZE;
    const hashes = [_]Hash{hash1};
    const result = try concat(std.testing.allocator, &hashes);
    const expected = keccak256(&hash1);
    try std.testing.expect(equals(&result, &expected));
}
```

### concat - empty array returns hash of empty data

```zig
test "concat - empty array returns hash of empty data" {
    const hashes: []const Hash = &[_]Hash{};
    const result = try concat(std.testing.allocator, hashes);
    const expected = keccak256("");
    try std.testing.expect(equals(&result, &expected));
}
```

### merkleRoot - empty array

```zig
test "merkleRoot - empty array" {
    const hashes: []const Hash = &[_]Hash{};
    const root = try merkleRoot(std.testing.allocator, hashes);
    try std.testing.expect(equals(&root, &ZERO));
}
```

### merkleRoot - single hash

```zig
test "merkleRoot - single hash" {
    const hash: Hash = [_]u8{0xaa} ** SIZE;
    const hashes = [_]Hash{hash};
    const root = try merkleRoot(std.testing.allocator, &hashes);
    try std.testing.expect(equals(&root, &hash));
}
```

### merkleRoot - two hashes

```zig
test "merkleRoot - two hashes" {
    const hash1: Hash = [_]u8{0xaa} ** SIZE;
    const hash2: Hash = [_]u8{0xbb} ** SIZE;
    const hashes = [_]Hash{ hash1, hash2 };

    const root = try merkleRoot(std.testing.allocator, &hashes);

    // Root should be concat(hash1, hash2)
    const expected = try concat(std.testing.allocator, &hashes);
    try std.testing.expect(equals(&root, &expected));
}
```

### merkleRoot - three hashes (odd)

```zig
test "merkleRoot - three hashes (odd)" {
    const hash1: Hash = [_]u8{0x11} ** SIZE;
    const hash2: Hash = [_]u8{0x22} ** SIZE;
    const hash3: Hash = [_]u8{0x33} ** SIZE;
    const hashes = [_]Hash{ hash1, hash2, hash3 };

    const root = try merkleRoot(std.testing.allocator, &hashes);

    // Manually compute expected
    // Level 1: h12 = concat(h1, h2), h33 = concat(h3, h3)
    const pair12 = [_]Hash{ hash1, hash2 };
    const h12 = try concat(std.testing.allocator, &pair12);
    const pair33 = [_]Hash{ hash3, hash3 };
    const h33 = try concat(std.testing.allocator, &pair33);

    // Level 2: root = concat(h12, h33)
    const final_pair = [_]Hash{ h12, h33 };
    const expected = try concat(std.testing.allocator, &final_pair);

    try std.testing.expect(equals(&root, &expected));
}
```

### merkleRoot - four hashes (even)

```zig
test "merkleRoot - four hashes (even)" {
    const hash1: Hash = [_]u8{0x11} ** SIZE;
    const hash2: Hash = [_]u8{0x22} ** SIZE;
    const hash3: Hash = [_]u8{0x33} ** SIZE;
    const hash4: Hash = [_]u8{0x44} ** SIZE;
    const hashes = [_]Hash{ hash1, hash2, hash3, hash4 };

    const root = try merkleRoot(std.testing.allocator, &hashes);

    // Manually compute
    const pair12 = [_]Hash{ hash1, hash2 };
    const h12 = try concat(std.testing.allocator, &pair12);
    const pair34 = [_]Hash{ hash3, hash4 };
    const h34 = try concat(std.testing.allocator, &pair34);
    const final_pair = [_]Hash{ h12, h34 };
    const expected = try concat(std.testing.allocator, &final_pair);

    try std.testing.expect(equals(&root, &expected));
}
```
