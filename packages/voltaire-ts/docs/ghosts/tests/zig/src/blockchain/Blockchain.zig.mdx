---
title: '[Zig] src/blockchain/Blockchain.zig'
source: 'src/blockchain/Blockchain.zig'
---

> Auto-generated from Zig tests in: src/blockchain/Blockchain.zig

### Blockchain - init without fork cache

```zig
test "Blockchain - init without fork cache" {
    const allocator = std.testing.allocator;
    var blockchain = try Blockchain.init(allocator, null);
    defer blockchain.deinit();

    try std.testing.expectEqual(@as(usize, 0), blockchain.localBlockCount());
}
```

### Blockchain - put and get block (local only)

```zig
test "Blockchain - put and get block (local only)" {
    const allocator = std.testing.allocator;
    var blockchain = try Blockchain.init(allocator, null);
    defer blockchain.deinit();

    const genesis = try Block.genesis(1, allocator);
    const genesis_hash = genesis.hash;

    try blockchain.putBlock(genesis);

    const retrieved = try blockchain.getBlockByHash(genesis_hash);
    try std.testing.expect(retrieved != null);
    try std.testing.expectEqual(@as(u64, 0), retrieved.?.header.number);
}
```

### Blockchain - get by number (local canonical)

```zig
test "Blockchain - get by number (local canonical)" {
    const allocator = std.testing.allocator;
    var blockchain = try Blockchain.init(allocator, null);
    defer blockchain.deinit();

    const genesis = try Block.genesis(1, allocator);
    try blockchain.putBlock(genesis);
    try blockchain.setCanonicalHead(genesis.hash);

    const retrieved = try blockchain.getBlockByNumber(0);
    try std.testing.expect(retrieved != null);
    try std.testing.expectEqual(@as(u64, 0), retrieved.?.header.number);
}
```

### Blockchain - set canonical head

```zig
test "Blockchain - set canonical head" {
    const allocator = std.testing.allocator;
    var blockchain = try Blockchain.init(allocator, null);
    defer blockchain.deinit();

    const genesis = try Block.genesis(1, allocator);
    try blockchain.putBlock(genesis);
    try blockchain.setCanonicalHead(genesis.hash);

    const head_number = blockchain.getHeadBlockNumber();
    try std.testing.expect(head_number != null);
    try std.testing.expectEqual(@as(u64, 0), head_number.?);
}
```

### Blockchain - read flow with fork cache

```zig
test "Blockchain - read flow with fork cache" {
    const allocator = std.testing.allocator;

    var fork_cache = try ForkBlockCache.init(allocator, 1000);
    defer fork_cache.deinit();

    var blockchain = try Blockchain.init(allocator, &fork_cache);
    defer blockchain.deinit();

    try std.testing.expectError(error.RpcPending, blockchain.getBlockByNumber(0));

    const request = fork_cache.nextRequest() orelse {
        try std.testing.expect(false);
        return;
    };
    const hash_hex = "0x" ++ ("11" ** 32);
    const response = try std.fmt.allocPrint(allocator, "{{\"hash\":\"{s}\",\"number\":\"0x0\"}}", .{hash_hex});
    defer allocator.free(response);
    try fork_cache.continueRequest(request.id, response);

    const block = try blockchain.getBlockByNumber(0);
    try std.testing.expect(block != null);
    try std.testing.expectEqual(@as(u64, 0), block.?.header.number);
}
```

### Blockchain - local takes precedence over fork cache

```zig
test "Blockchain - local takes precedence over fork cache" {
    const allocator = std.testing.allocator;

    var fork_cache = try ForkBlockCache.init(allocator, 1000);
    defer fork_cache.deinit();

    var blockchain = try Blockchain.init(allocator, &fork_cache);
    defer blockchain.deinit();

    // Put local genesis
    const local_genesis = try Block.genesis(1, allocator);
    try blockchain.putBlock(local_genesis);
    try blockchain.setCanonicalHead(local_genesis.hash);

    // Fetch should return local (not fork cache)
    const block = try blockchain.getBlockByNumber(0);
    try std.testing.expect(block != null);
    try std.testing.expectEqual(@as(u64, 0), block.?.header.number);

    // Hash should match local
    try std.testing.expectEqualSlices(u8, &local_genesis.hash, &block.?.hash);
}
```

### Blockchain - sequential blocks build local chain

```zig
test "Blockchain - sequential blocks build local chain" {
    const allocator = std.testing.allocator;
    var blockchain = try Blockchain.init(allocator, null);
    defer blockchain.deinit();

    // Genesis
    const genesis = try Block.genesis(1, allocator);
    try blockchain.putBlock(genesis);
    try blockchain.setCanonicalHead(genesis.hash);

    // Block 1
    var header1 = primitives.BlockHeader.init();
    header1.number = 1;
    header1.parent_hash = genesis.hash;
    const body1 = primitives.BlockBody.init();
    const block1 = try Block.from(&header1, &body1, allocator);

    try blockchain.putBlock(block1);
    try blockchain.setCanonicalHead(block1.hash);

    try std.testing.expectEqual(@as(usize, 2), blockchain.localBlockCount());
    try std.testing.expectEqual(@as(usize, 2), blockchain.canonicalChainLength());
    try std.testing.expectEqual(@as(usize, 0), blockchain.orphanCount());

    const head = blockchain.getHeadBlockNumber();
    try std.testing.expect(head != null);
    try std.testing.expectEqual(@as(u64, 1), head.?);
}
```

### Blockchain - statistics methods

```zig
test "Blockchain - statistics methods" {
    const allocator = std.testing.allocator;
    var blockchain = try Blockchain.init(allocator, null);
    defer blockchain.deinit();

    const genesis = try Block.genesis(1, allocator);
    try blockchain.putBlock(genesis);
    try blockchain.setCanonicalHead(genesis.hash);

    try std.testing.expectEqual(@as(usize, 1), blockchain.localBlockCount());
    try std.testing.expectEqual(@as(usize, 1), blockchain.canonicalChainLength());
    try std.testing.expectEqual(@as(usize, 0), blockchain.orphanCount());
}
```
