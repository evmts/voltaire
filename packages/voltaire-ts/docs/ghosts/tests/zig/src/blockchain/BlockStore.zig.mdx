---
title: '[Zig] src/blockchain/BlockStore.zig'
source: 'src/blockchain/BlockStore.zig'
---

> Auto-generated from Zig tests in: src/blockchain/BlockStore.zig

### BlockStore - init and deinit

```zig
test "BlockStore - init and deinit" {
    const allocator = std.testing.allocator;
    var store = try BlockStore.init(allocator);
    defer store.deinit();

    try std.testing.expectEqual(@as(usize, 0), store.blockCount());
}
```

### BlockStore - put and get genesis block

```zig
test "BlockStore - put and get genesis block" {
    const allocator = std.testing.allocator;
    var store = try BlockStore.init(allocator);
    defer store.deinit();

    const genesis = try Block.genesis(1, allocator);
    const genesis_hash = genesis.hash;

    try store.putBlock(genesis);

    try std.testing.expectEqual(@as(usize, 1), store.blockCount());
    try std.testing.expect(store.hasBlock(genesis_hash));
    try std.testing.expect(!store.isOrphan(genesis_hash));

    const retrieved = store.getBlock(genesis_hash);
    try std.testing.expect(retrieved != null);
    try std.testing.expectEqual(@as(u64, 0), retrieved.?.header.number);
}
```

### BlockStore - put block with missing parent marks as orphan

```zig
test "BlockStore - put block with missing parent marks as orphan" {
    const allocator = std.testing.allocator;
    var store = try BlockStore.init(allocator);
    defer store.deinit();

    // Create block with non-existent parent
    var header = primitives.BlockHeader.init();
    header.number = 5;
    header.parent_hash = Hash.Hash{ 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99 };

    const body = primitives.BlockBody.init();
    const block = try Block.from(&header, &body, allocator);
    const block_hash = block.hash;

    try store.putBlock(block);

    try std.testing.expectEqual(@as(usize, 1), store.blockCount());
    try std.testing.expectEqual(@as(usize, 1), store.orphanCount());
    try std.testing.expect(store.isOrphan(block_hash));
}
```

### BlockStore - get by number returns canonical block only

```zig
test "BlockStore - get by number returns canonical block only" {
    const allocator = std.testing.allocator;
    var store = try BlockStore.init(allocator);
    defer store.deinit();

    const genesis = try Block.genesis(1, allocator);
    try store.putBlock(genesis);
    try store.setCanonicalHead(genesis.hash);

    const retrieved = store.getBlockByNumber(0);
    try std.testing.expect(retrieved != null);
    try std.testing.expectEqual(@as(u64, 0), retrieved.?.header.number);
}
```

### BlockStore - setCanonicalHead rejects orphans

```zig
test "BlockStore - setCanonicalHead rejects orphans" {
    const allocator = std.testing.allocator;
    var store = try BlockStore.init(allocator);
    defer store.deinit();

    // Create orphan block
    var header = primitives.BlockHeader.init();
    header.number = 5;
    header.parent_hash = Hash.Hash{ 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99 };

    const body = primitives.BlockBody.init();
    const block = try Block.from(&header, &body, allocator);

    try store.putBlock(block);

    const result = store.setCanonicalHead(block.hash);
    try std.testing.expectError(error.CannotSetOrphanAsHead, result);
}
```

### BlockStore - sequential blocks build canonical chain

```zig
test "BlockStore - sequential blocks build canonical chain" {
    const allocator = std.testing.allocator;
    var store = try BlockStore.init(allocator);
    defer store.deinit();

    // Create genesis
    const genesis = try Block.genesis(1, allocator);
    try store.putBlock(genesis);
    try store.setCanonicalHead(genesis.hash);

    // Create block 1 (parent = genesis)
    var header1 = primitives.BlockHeader.init();
    header1.number = 1;
    header1.parent_hash = genesis.hash;

    const body1 = primitives.BlockBody.init();
    const block1 = try Block.from(&header1, &body1, allocator);

    try store.putBlock(block1);
    try store.setCanonicalHead(block1.hash);

    try std.testing.expectEqual(@as(usize, 2), store.blockCount());
    try std.testing.expectEqual(@as(usize, 2), store.canonicalChainLength());
    try std.testing.expectEqual(@as(usize, 0), store.orphanCount());

    const head_number = store.getHeadBlockNumber();
    try std.testing.expect(head_number != null);
    try std.testing.expectEqual(@as(u64, 1), head_number.?);
}
```

### BlockStore - orphan resolution when parent arrives

```zig
test "BlockStore - orphan resolution when parent arrives" {
    const allocator = std.testing.allocator;
    var store = try BlockStore.init(allocator);
    defer store.deinit();

    // Create genesis
    const genesis = try Block.genesis(1, allocator);
    try store.putBlock(genesis);

    // Create block 1 first (will be parent)
    var header1 = primitives.BlockHeader.init();
    header1.number = 1;
    header1.parent_hash = genesis.hash;

    const body1 = primitives.BlockBody.init();
    const block1 = try Block.from(&header1, &body1, allocator);

    // Create block 2 with correct parent (but add before block 1 exists)
    var header2 = primitives.BlockHeader.init();
    header2.number = 2;
    header2.parent_hash = block1.hash;

    const body2 = primitives.BlockBody.init();
    const block2 = try Block.from(&header2, &body2, allocator);
    const block2_hash = block2.hash;

    // Add block2 first (should be orphan since parent doesn't exist)
    try store.putBlock(block2);

    // Should be orphan
    try std.testing.expectEqual(@as(usize, 2), store.blockCount()); // genesis + block2
    try std.testing.expectEqual(@as(usize, 1), store.orphanCount());
    try std.testing.expect(store.isOrphan(block2_hash));

    // Now add block 1 (parent)
    try store.putBlock(block1);

    // Orphan should be resolved
    try std.testing.expectEqual(@as(usize, 3), store.blockCount()); // genesis + block1 + block2
    try std.testing.expect(!store.isOrphan(block2_hash));
}
```
