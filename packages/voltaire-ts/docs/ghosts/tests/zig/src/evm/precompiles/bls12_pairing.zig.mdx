---
title: '[Zig] src/evm/precompiles/bls12_pairing.zig'
source: 'src/evm/precompiles/bls12_pairing.zig'
---

> Auto-generated from Zig tests in: src/evm/precompiles/bls12_pairing.zig

### bls12_pairing - out of gas

```zig
test "bls12_pairing - out of gas" {
    // Empty input (0 pairs) requires BASE_GAS
    const input = [_]u8{};
    const result = execute(std.testing.allocator, &input, BASE_GAS - 1);
    try std.testing.expectError(error.OutOfGas, result);
}
```

### bls12_pairing - exact gas for zero pairs

```zig
test "bls12_pairing - exact gas for zero pairs" {
    // Empty input (0 pairs) - should succeed with pairing result of 1
    const input = [_]u8{};
    const result = try execute(std.testing.allocator, &input, BASE_GAS);
    defer std.testing.allocator.free(result.output);

    try std.testing.expectEqual(BASE_GAS, result.gas_used);
    try std.testing.expectEqual(@as(usize, 32), result.output.len);
    // Empty input should return success (1)
    try std.testing.expectEqual(@as(u8, 1), result.output[31]);
}
```

### bls12_pairing - single pair exact gas

```zig
test "bls12_pairing - single pair exact gas" {
    // Single pair: G1 point (128 bytes) + G2 point (256 bytes) = 384 bytes
    // All zeros represents points at infinity
    const input = [_]u8{0} ** 384;
    const expected_gas = BASE_GAS + PER_PAIR_GAS;
    const result = try execute(std.testing.allocator, &input, expected_gas);
    defer std.testing.allocator.free(result.output);

    try std.testing.expectEqual(expected_gas, result.gas_used);
    try std.testing.expectEqual(@as(usize, 32), result.output.len);
}
```

### bls12_pairing - single pair insufficient gas

```zig
test "bls12_pairing - single pair insufficient gas" {
    const input = [_]u8{0} ** 384;
    const expected_gas = BASE_GAS + PER_PAIR_GAS;
    const result = execute(std.testing.allocator, &input, expected_gas - 1);
    try std.testing.expectError(error.OutOfGas, result);
}
```

### bls12_pairing - two pairs exact gas

```zig
test "bls12_pairing - two pairs exact gas" {
    // Two pairs: 2 * 384 = 768 bytes
    const input = [_]u8{0} ** 768;
    const expected_gas = BASE_GAS + 2 * PER_PAIR_GAS;
    const result = try execute(std.testing.allocator, &input, expected_gas);
    defer std.testing.allocator.free(result.output);

    try std.testing.expectEqual(expected_gas, result.gas_used);
    try std.testing.expectEqual(@as(usize, 32), result.output.len);
}
```

### bls12_pairing - three pairs

```zig
test "bls12_pairing - three pairs" {
    // Three pairs: 3 * 384 = 1152 bytes
    const input = [_]u8{0} ** 1152;
    const expected_gas = BASE_GAS + 3 * PER_PAIR_GAS;
    const result = try execute(std.testing.allocator, &input, expected_gas);
    defer std.testing.allocator.free(result.output);

    try std.testing.expectEqual(expected_gas, result.gas_used);
    try std.testing.expectEqual(@as(usize, 32), result.output.len);
}
```

### bls12_pairing - invalid input length not multiple of 384

```zig
test "bls12_pairing - invalid input length not multiple of 384" {
    // 383 bytes - not a multiple of 384
    const input = [_]u8{0} ** 383;
    const result = execute(std.testing.allocator, &input, 1000000);
    try std.testing.expectError(error.InvalidInput, result);
}
```

### bls12_pairing - invalid input length 1

```zig
test "bls12_pairing - invalid input length 1" {
    const input = [_]u8{0};
    const result = execute(std.testing.allocator, &input, 1000000);
    try std.testing.expectError(error.InvalidInput, result);
}
```

### bls12_pairing - invalid input length 385

```zig
test "bls12_pairing - invalid input length 385" {
    const input = [_]u8{0} ** 385;
    const result = execute(std.testing.allocator, &input, 1000000);
    try std.testing.expectError(error.InvalidInput, result);
}
```

### bls12_pairing - gas cost constants validation

```zig
test "bls12_pairing - gas cost constants validation" {
    // Verify gas cost constants match EIP-2537 specification
    try std.testing.expectEqual(@as(u64, 65000), BASE_GAS);
    try std.testing.expectEqual(@as(u64, 43000), PER_PAIR_GAS);
}
```

### bls12_pairing - gas cost calculation

```zig
test "bls12_pairing - gas cost calculation" {
    // Test gas cost formula: BASE_GAS + k * PER_PAIR_GAS
    // where k is the number of pairs

    // 0 pairs
    try std.testing.expectEqual(@as(u64, 65000), BASE_GAS + 0 * PER_PAIR_GAS);

    // 1 pair
    try std.testing.expectEqual(@as(u64, 108000), BASE_GAS + 1 * PER_PAIR_GAS);

    // 2 pairs
    try std.testing.expectEqual(@as(u64, 151000), BASE_GAS + 2 * PER_PAIR_GAS);

    // 5 pairs
    try std.testing.expectEqual(@as(u64, 280000), BASE_GAS + 5 * PER_PAIR_GAS);
}
```

### bls12_pairing - output format

```zig
test "bls12_pairing - output format" {
    // Output should be 32 bytes with result in last byte
    const input = [_]u8{};
    const result = try execute(std.testing.allocator, &input, BASE_GAS);
    defer std.testing.allocator.free(result.output);

    try std.testing.expectEqual(@as(usize, 32), result.output.len);

    // First 31 bytes should be zero
    for (result.output[0..31]) |byte| {
        try std.testing.expectEqual(@as(u8, 0), byte);
    }

    // Last byte should be 0 or 1
    try std.testing.expect(result.output[31] == 0 or result.output[31] == 1);
}
```

### bls12_pairing - large number of pairs gas calculation

```zig
test "bls12_pairing - large number of pairs gas calculation" {
    // Test with 10 pairs
    const k: u64 = 10;
    const input = [_]u8{0} ** (384 * k);
    const expected_gas = BASE_GAS + k * PER_PAIR_GAS;

    const result = try execute(std.testing.allocator, &input, expected_gas);
    defer std.testing.allocator.free(result.output);

    try std.testing.expectEqual(expected_gas, result.gas_used);
    try std.testing.expectEqual(@as(usize, 32), result.output.len);
}
```

### bls12_pairing - bilinearity property structure

```zig
test "bls12_pairing - bilinearity property structure" {
    // Test that we can create inputs for bilinearity testing
    // e(aP, Q) should equal e(P, aQ)
    // This test verifies input structure, actual bilinearity tested when implemented

    // Single pair for e(P, Q)
    var pair1: [384]u8 = undefined;
    @memset(&pair1, 0);
    // G1 point P at pair1[0..128]
    // G2 point Q at pair1[128..384]

    const result1 = try execute(std.testing.allocator, &pair1, BASE_GAS + PER_PAIR_GAS);
    defer std.testing.allocator.free(result1.output);

    try std.testing.expectEqual(@as(usize, 32), result1.output.len);
}
```

### bls12_pairing - output size consistency

```zig
test "bls12_pairing - output size consistency" {
    // Verify output is always 32 bytes regardless of input size
    const test_sizes = [_]usize{ 0, 384, 768, 1152 };

    for (test_sizes) |size| {
        const input = try std.testing.allocator.alloc(u8, size);
        defer std.testing.allocator.free(input);
        @memset(input, 0);

        const k = size / 384;
        const gas = BASE_GAS + k * PER_PAIR_GAS;

        const result = try execute(std.testing.allocator, input, gas);
        defer std.testing.allocator.free(result.output);

        try std.testing.expectEqual(@as(usize, 32), result.output.len);
    }
}
```
