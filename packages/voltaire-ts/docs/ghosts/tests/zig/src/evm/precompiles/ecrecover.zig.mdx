---
title: '[Zig] src/evm/precompiles/ecrecover.zig'
source: 'src/evm/precompiles/ecrecover.zig'
---

> Auto-generated from Zig tests in: src/evm/precompiles/ecrecover.zig

### ecRecover - valid signature

```zig
test "ecRecover - valid signature" {
    const testing = std.testing;
    const allocator = testing.allocator;

    // Example from Ethereum yellow paper
    const hash = [_]u8{0x47} ** 32;
    const v = [_]u8{0} ** 31 ++ [_]u8{28};
    const r = [_]u8{0x69} ** 32;
    const s = [_]u8{0x7a} ** 32;

    var input: [128]u8 = undefined;
    @memcpy(input[0..32], &hash);
    @memcpy(input[32..64], &v);
    @memcpy(input[64..96], &r);
    @memcpy(input[96..128], &s);

    const result = try execute(allocator, &input, 1000000);
    defer result.deinit(allocator);

    try testing.expectEqual(@as(usize, 32), result.output.len);
    try testing.expectEqual(GAS, result.gas_used);
}
```

### ecRecover - out of gas

```zig
test "ecRecover - out of gas" {
    const testing = std.testing;
    const allocator = testing.allocator;

    var input = [_]u8{0} ** 128;
    const result = execute(allocator, &input, GAS - 1);
    try testing.expectError(error.OutOfGas, result);
}
```

### ecRecover - exact gas

```zig
test "ecRecover - exact gas" {
    const testing = std.testing;
    const allocator = testing.allocator;

    var input = [_]u8{0} ** 128;
    const result = try execute(allocator, &input, GAS);
    defer result.deinit(allocator);

    try testing.expectEqual(GAS, result.gas_used);
}
```

### ecRecover - input too short padded

```zig
test "ecRecover - input too short padded" {
    const testing = std.testing;
    const allocator = testing.allocator;

    var input = [_]u8{0} ** 100;
    const result = try execute(allocator, &input, GAS);
    defer result.deinit(allocator);

    try testing.expectEqual(@as(usize, 32), result.output.len);
}
```

### ecRecover - input too long truncated

```zig
test "ecRecover - input too long truncated" {
    const testing = std.testing;
    const allocator = testing.allocator;

    var input = [_]u8{0} ** 200;
    const result = try execute(allocator, &input, GAS);
    defer result.deinit(allocator);

    try testing.expectEqual(@as(usize, 32), result.output.len);
}
```

### ecRecover - empty input

```zig
test "ecRecover - empty input" {
    const testing = std.testing;
    const allocator = testing.allocator;

    var input = [_]u8{};
    const result = try execute(allocator, &input, GAS);
    defer result.deinit(allocator);

    try testing.expectEqual(@as(usize, 32), result.output.len);
}
```

### ecRecover - v value 27

```zig
test "ecRecover - v value 27" {
    const testing = std.testing;
    const allocator = testing.allocator;

    var input = [_]u8{0} ** 128;
    input[63] = 27;

    const result = try execute(allocator, &input, GAS);
    defer result.deinit(allocator);

    try testing.expectEqual(@as(usize, 32), result.output.len);
}
```

### ecRecover - v value 28

```zig
test "ecRecover - v value 28" {
    const testing = std.testing;
    const allocator = testing.allocator;

    var input = [_]u8{0} ** 128;
    input[63] = 28;

    const result = try execute(allocator, &input, GAS);
    defer result.deinit(allocator);

    try testing.expectEqual(@as(usize, 32), result.output.len);
}
```

### ecRecover - invalid v value returns zero

```zig
test "ecRecover - invalid v value returns zero" {
    const testing = std.testing;
    const allocator = testing.allocator;

    var input = [_]u8{0} ** 128;
    input[63] = 29;

    const result = try execute(allocator, &input, GAS);
    defer result.deinit(allocator);

    try testing.expectEqual(@as(usize, 32), result.output.len);
}
```

### ecRecover - all zero input returns zero

```zig
test "ecRecover - all zero input returns zero" {
    const testing = std.testing;
    const allocator = testing.allocator;

    var input = [_]u8{0} ** 128;
    const result = try execute(allocator, &input, GAS);
    defer result.deinit(allocator);

    try testing.expectEqual(@as(usize, 32), result.output.len);
    for (result.output) |byte| {
        try testing.expectEqual(@as(u8, 0), byte);
    }
}
```

### ecRecover - gas cost constant

```zig
test "ecRecover - gas cost constant" {
    const testing = std.testing;

    try testing.expectEqual(@as(u64, 3000), GAS);
}
```

### ecRecover - output always 32 bytes

```zig
test "ecRecover - output always 32 bytes" {
    const testing = std.testing;
    const allocator = testing.allocator;

    var input = [_]u8{0} ** 128;
    const result = try execute(allocator, &input, GAS);
    defer result.deinit(allocator);

    try testing.expectEqual(@as(usize, 32), result.output.len);
}
```

### ecRecover - invalid signature graceful failure

```zig
test "ecRecover - invalid signature graceful failure" {
    const testing = std.testing;
    const allocator = testing.allocator;

    var input = [_]u8{0xFF} ** 128;
    const result = try execute(allocator, &input, GAS);
    defer result.deinit(allocator);

    try testing.expectEqual(@as(usize, 32), result.output.len);
    try testing.expectEqual(GAS, result.gas_used);
}
```

### ecRecover - EIP-2 malleability: reject high s value

```zig
test "ecRecover - EIP-2 malleability: reject high s value" {
    const testing = std.testing;
    const allocator = testing.allocator;

    // Test that s > secp256k1_n / 2 is rejected (EIP-2 protection)
    // secp256k1_n = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141
    // secp256k1_n / 2 = 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0

    var input: [128]u8 = undefined;
    const hash = [_]u8{0x47} ** 32;
    const v = [_]u8{0} ** 31 ++ [_]u8{28};
    const r = [_]u8{0x69} ** 32;

    // Set s to a high value > n/2 (should be rejected per EIP-2)
    // Using 0x8000...0000 which is definitely > n/2
    const s_high = [_]u8{0x80} ++ [_]u8{0x00} ** 31;

    @memcpy(input[0..32], &hash);
    @memcpy(input[32..64], &v);
    @memcpy(input[64..96], &r);
    @memcpy(input[96..128], &s_high);

    const result = try execute(allocator, &input, GAS);
    defer result.deinit(allocator);

    // Should return zero address (invalid signature)
    try testing.expectEqual(@as(usize, 32), result.output.len);
    for (result.output) |byte| {
        try testing.expectEqual(@as(u8, 0), byte);
    }
}
```

### ecRecover - reject r = 0

```zig
test "ecRecover - reject r = 0" {
    const testing = std.testing;
    const allocator = testing.allocator;

    var input: [128]u8 = undefined;
    const hash = [_]u8{0x47} ** 32;
    const v = [_]u8{0} ** 31 ++ [_]u8{28};
    const r_zero = [_]u8{0} ** 32; // r = 0 should be rejected
    const s = [_]u8{0x7a} ** 32;

    @memcpy(input[0..32], &hash);
    @memcpy(input[32..64], &v);
    @memcpy(input[64..96], &r_zero);
    @memcpy(input[96..128], &s);

    const result = try execute(allocator, &input, GAS);
    defer result.deinit(allocator);

    // Should return zero address (invalid signature)
    try testing.expectEqual(@as(usize, 32), result.output.len);
    for (result.output) |byte| {
        try testing.expectEqual(@as(u8, 0), byte);
    }
}
```

### ecRecover - reject s = 0

```zig
test "ecRecover - reject s = 0" {
    const testing = std.testing;
    const allocator = testing.allocator;

    var input: [128]u8 = undefined;
    const hash = [_]u8{0x47} ** 32;
    const v = [_]u8{0} ** 31 ++ [_]u8{28};
    const r = [_]u8{0x69} ** 32;
    const s_zero = [_]u8{0} ** 32; // s = 0 should be rejected

    @memcpy(input[0..32], &hash);
    @memcpy(input[32..64], &v);
    @memcpy(input[64..96], &r);
    @memcpy(input[96..128], &s_zero);

    const result = try execute(allocator, &input, GAS);
    defer result.deinit(allocator);

    // Should return zero address (invalid signature)
    try testing.expectEqual(@as(usize, 32), result.output.len);
    for (result.output) |byte| {
        try testing.expectEqual(@as(u8, 0), byte);
    }
}
```

### ecRecover - reject r >= curve_order

```zig
test "ecRecover - reject r >= curve_order" {
    const testing = std.testing;
    const allocator = testing.allocator;

    var input: [128]u8 = undefined;
    const hash = [_]u8{0x47} ** 32;
    const v = [_]u8{0} ** 31 ++ [_]u8{28};
    const s = [_]u8{0x7a} ** 32;

    // Set r to all 0xFF (definitely >= curve_order)
    const r_invalid = [_]u8{0xFF} ** 32;

    @memcpy(input[0..32], &hash);
    @memcpy(input[32..64], &v);
    @memcpy(input[64..96], &r_invalid);
    @memcpy(input[96..128], &s);

    const result = try execute(allocator, &input, GAS);
    defer result.deinit(allocator);

    // Should return zero address (invalid signature)
    try testing.expectEqual(@as(usize, 32), result.output.len);
    for (result.output) |byte| {
        try testing.expectEqual(@as(u8, 0), byte);
    }
}
```

### ecRecover - reject s >= curve_order

```zig
test "ecRecover - reject s >= curve_order" {
    const testing = std.testing;
    const allocator = testing.allocator;

    var input: [128]u8 = undefined;
    const hash = [_]u8{0x47} ** 32;
    const v = [_]u8{0} ** 31 ++ [_]u8{28};
    const r = [_]u8{0x69} ** 32;

    // Set s to all 0xFF (definitely >= curve_order)
    const s_invalid = [_]u8{0xFF} ** 32;

    @memcpy(input[0..32], &hash);
    @memcpy(input[32..64], &v);
    @memcpy(input[64..96], &r);
    @memcpy(input[96..128], &s_invalid);

    const result = try execute(allocator, &input, GAS);
    defer result.deinit(allocator);

    // Should return zero address (invalid signature)
    try testing.expectEqual(@as(usize, 32), result.output.len);
    for (result.output) |byte| {
        try testing.expectEqual(@as(u8, 0), byte);
    }
}
```

### ecRecover - reject invalid v value beyond 29

```zig
test "ecRecover - reject invalid v value beyond 29" {
    const testing = std.testing;
    const allocator = testing.allocator;

    var input: [128]u8 = undefined;
    const hash = [_]u8{0x47} ** 32;
    const v_invalid = [_]u8{0} ** 31 ++ [_]u8{100}; // v = 100 (invalid)
    const r = [_]u8{0x69} ** 32;
    const s = [_]u8{0x7a} ** 32;

    @memcpy(input[0..32], &hash);
    @memcpy(input[32..64], &v_invalid);
    @memcpy(input[64..96], &r);
    @memcpy(input[96..128], &s);

    const result = try execute(allocator, &input, GAS);
    defer result.deinit(allocator);

    // Should return zero address (invalid signature)
    try testing.expectEqual(@as(usize, 32), result.output.len);
    for (result.output) |byte| {
        try testing.expectEqual(@as(u8, 0), byte);
    }
}
```
