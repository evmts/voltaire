---
title: '[Zig] src/evm/storage/handlers_storage.zig.md'
source: 'src/evm/storage/handlers_storage.zig.md'
---

> Auto-generated from Zig tests in: src/evm/storage/handlers_storage.zig.md

### SSTORE: refund calculation for clearing storage

```zig
test "SSTORE: refund calculation for clearing storage" {
    // Test case: original=100, current=100, new=0
    // Expected: +4800 refund (GAS_STORAGE_CLEAR_REFUND)
}
```

### SSTORE: refund reversal when restoring cleared slot

```zig
test "SSTORE: refund reversal when restoring cleared slot" {
    // Test case: original=100, current=0, new=50
    // Expected: -4800 refund (reversal of previous clear)
}
```

### SSTORE: static call violation timing

```zig
test "SSTORE: static call violation timing" {
    // Verify error happens BEFORE gas consumption
}
```

### TLOAD/TSTORE: isolation between calls

```zig
test "TLOAD/TSTORE: isolation between calls" {
    // Verify transient storage persists within transaction
    // but not between transactions
}
```

### TLOAD: returns InvalidOpcode before Cancun

```zig
test "TLOAD: returns InvalidOpcode before Cancun" {
    var frame = createTestFrame(.SHANGHAI); // Pre-Cancun
    const result = StorageHandlers.tload(&frame);
    try testing.expectError(error.InvalidOpcode, result);
}
```

### SSTORE: refund invariants

```zig
test "SSTORE: refund invariants" {
    var prng = std.rand.DefaultPrng.init(0);
    const random = prng.random();

    for (0..1000) |_| {
        const original = random.int(u256);
        const current = random.int(u256);
        const value = random.int(u256);

        const refund = calculateRefundLondon(original, current, value);

        // Invariant: Restoring to original never costs more
        if (value == original) {
            try testing.expect(refund >= 0);
        }

        // Invariant: Clearing gives refund
        if (original != 0 and current != 0 and value == 0) {
            try testing.expectEqual(refund, 4800);
        }
    }
}
```

### benchmark: SLOAD warm access

```zig
test "benchmark: SLOAD warm access" {
    // Measure SLOAD performance with warm access
}
```

### benchmark: SSTORE refund calculation

```zig
test "benchmark: SSTORE refund calculation" {
    // Measure refund logic overhead across hardforks
}
```

### benchmark: access list lookup

```zig
test "benchmark: access list lookup" {
    // Measure warm/cold detection performance
}
```

### SSTORE: refund counter can go negative

```zig
   test "SSTORE: refund counter can go negative" {
       // Match Python behavior: refund_counter can be negative
       // (gets clamped at transaction end)
   }
```
