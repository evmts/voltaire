---
title: '[Zig] src/evm/comparison/handlers_comparison.zig.md'
source: 'src/evm/comparison/handlers_comparison.zig.md'
---

> Auto-generated from Zig tests in: src/evm/comparison/handlers_comparison.zig.md

### lt: boundary values

```zig
   test "lt: boundary values" {
       // Test: 0 < 1, MAX < 0, MAX < MAX, 0 < 0
   }
```

### slt: signed overflow boundaries

```zig
   test "slt: signed overflow boundaries" {
       // Test: -1 < 0, MAX_INT < MIN_INT (wrapping), etc.
   }
```

### all comparison ops consume GasFastestStep

```zig
   test "all comparison ops consume GasFastestStep" {
       // Verify each op consumes exactly 3 gas
   }
```

### comparison ops pop 2 push 1 (or pop 1 push 1 for iszero)

```zig
   test "comparison ops pop 2 push 1 (or pop 1 push 1 for iszero)" {
       // Verify stack manipulation correctness
   }
```

### all comparison ops increment PC by 1

```zig
   test "all comparison ops increment PC by 1" {
       // Verify PC behavior
   }
```

### lt: basic comparisons

```zig
test "lt: basic comparisons" {
    // Setup mock frame
    var frame = try createTestFrame();
    defer frame.deinit();

    // Test: 5 < 10 = 1
    try frame.pushStack(10);  // Right (second pop)
    try frame.pushStack(5);   // Left (first pop)
    try frame.handlers.comparison.lt(&frame);
    try testing.expectEqual(@as(u256, 1), try frame.popStack());

    // Test: 10 < 5 = 0
    try frame.pushStack(5);
    try frame.pushStack(10);
    try frame.handlers.comparison.lt(&frame);
    try testing.expectEqual(@as(u256, 0), try frame.popStack());

    // Test: 5 < 5 = 0
    try frame.pushStack(5);
    try frame.pushStack(5);
    try frame.handlers.comparison.lt(&frame);
    try testing.expectEqual(@as(u256, 0), try frame.popStack());
}
```

### slt: signed boundary cases

```zig
test "slt: signed boundary cases" {
    var frame = try createTestFrame();
    defer frame.deinit();

    // Test: -1 < 0 = 1 (0xFFFF...FFFF < 0)
    const minus_one = @as(u256, @bitCast(@as(i256, -1)));
    try frame.pushStack(0);
    try frame.pushStack(minus_one);
    try frame.handlers.comparison.slt(&frame);
    try testing.expectEqual(@as(u256, 1), try frame.popStack());

    // Test: INT_MAX < INT_MIN = 0 (positive < negative in signed)
    const int_max = @as(u256, @bitCast(@as(i256, std.math.maxInt(i256))));
    const int_min = @as(u256, @bitCast(@as(i256, std.math.minInt(i256))));
    try frame.pushStack(int_min);
    try frame.pushStack(int_max);
    try frame.handlers.comparison.slt(&frame);
    try testing.expectEqual(@as(u256, 0), try frame.popStack());
}
```

### iszero: boundary cases

```zig
test "iszero: boundary cases" {
    var frame = try createTestFrame();
    defer frame.deinit();

    // Test: iszero(0) = 1
    try frame.pushStack(0);
    try frame.handlers.comparison.iszero(&frame);
    try testing.expectEqual(@as(u256, 1), try frame.popStack());

    // Test: iszero(1) = 0
    try frame.pushStack(1);
    try frame.handlers.comparison.iszero(&frame);
    try testing.expectEqual(@as(u256, 0), try frame.popStack());

    // Test: iszero(MAX_U256) = 0
    try frame.pushStack(std.math.maxInt(u256));
    try frame.handlers.comparison.iszero(&frame);
    try testing.expectEqual(@as(u256, 0), try frame.popStack());
}
```
