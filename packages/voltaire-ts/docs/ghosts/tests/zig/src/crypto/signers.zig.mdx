---
title: '[Zig] src/crypto/signers.zig'
source: 'src/crypto/signers.zig'
---

> Auto-generated from Zig tests in: src/crypto/signers.zig

### LocalSigner - init from private key

```zig
test "LocalSigner - init from private key" {
    // Known test private key (DO NOT use in production)
    const private_key = PrivateKey{
        0xac, 0x09, 0x74, 0xbe, 0xc3, 0x9a, 0x17, 0xe3,
        0x6b, 0xa4, 0xa6, 0xb4, 0xd2, 0x38, 0xff, 0x24,
        0x4e, 0x21, 0xdb, 0x63, 0x5c, 0x51, 0xcb, 0x29,
        0x36, 0x49, 0x5a, 0xf7, 0x42, 0x2f, 0xba, 0x41,
    };

    var signer_instance = try LocalSigner.init(private_key);
    defer signer_instance.deinit();

    // Address should be 20 bytes
    try testing.expectEqual(@as(usize, 20), signer_instance.address.bytes.len);

    // Public key should be valid
    try testing.expect(signer_instance.public_key.isValid());
}
```

### LocalSigner - fromHex with 0x prefix

```zig
test "LocalSigner - fromHex with 0x prefix" {
    const hex = "0xac0974bec39a17e36ba4a6b4d238ff244e21db635c51cb293649a7422fba41";
    // Note: this is 62 chars after 0x, should fail
    const result = LocalSigner.fromHex(hex);
    try testing.expectError(SignerError.InvalidPrivateKey, result);
}
```

### LocalSigner - fromHex valid

```zig
test "LocalSigner - fromHex valid" {
    const hex = "ac0974bec39a17e36ba4a6b4d238ff244e21db635c51cb2936495af7422fba41";
    var signer_instance = try LocalSigner.fromHex(hex);
    defer signer_instance.deinit();

    try testing.expect(signer_instance.public_key.isValid());
}
```

### LocalSigner - signMessage

```zig
test "LocalSigner - signMessage" {
    const private_key = PrivateKey{
        0x42, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    };

    var signer_instance = try LocalSigner.init(private_key);
    defer signer_instance.deinit();

    const message = "Hello, Ethereum!";
    const signature = try signer_instance.signMessage(message);

    // Signature should be valid
    try testing.expect(signature.isValid());

    // v should be 27 or 28
    try testing.expect(signature.v == 27 or signature.v == 28);
}
```

### LocalSigner - signHash deterministic

```zig
test "LocalSigner - signHash deterministic" {
    const private_key = PrivateKey{
        0xfe, 0xed, 0xbe, 0xef, 0xde, 0xad, 0xc0, 0xde,
        0xca, 0xfe, 0xba, 0xbe, 0x12, 0x34, 0x56, 0x78,
        0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34, 0x56, 0x78,
        0x9a, 0xbc, 0xde, 0xf0, 0x11, 0x22, 0x33, 0x44,
    };

    var signer_instance = try LocalSigner.init(private_key);
    defer signer_instance.deinit();

    const hash = Hash.keccak256("test message");

    // Sign twice
    const sig1 = try signer_instance.signHash(hash);
    const sig2 = try signer_instance.signHash(hash);

    // Signatures should be identical (deterministic RFC 6979)
    try testing.expectEqual(sig1.r, sig2.r);
    try testing.expectEqual(sig1.s, sig2.s);
    try testing.expectEqual(sig1.v, sig2.v);
}
```

### LocalSigner - signature recovery

```zig
test "LocalSigner - signature recovery" {
    const private_key = PrivateKey{
        0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
        0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
        0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
        0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
    };

    var signer_instance = try LocalSigner.init(private_key);
    defer signer_instance.deinit();

    const message = "Recovery test";
    const signature = try signer_instance.signMessage(message);

    // Recover address from signature
    const message_hash = Crypto.hashMessage(message);
    const recovered_address = try Crypto.unaudited_recoverAddress(message_hash, signature);

    // Should match signer address
    try testing.expect(std.mem.eql(u8, &recovered_address.bytes, &signer_instance.address.bytes));
}
```

### LocalSigner - random generation

```zig
test "LocalSigner - random generation" {
    var signer1 = try LocalSigner.random();
    defer signer1.deinit();

    var signer2 = try LocalSigner.random();
    defer signer2.deinit();

    // Addresses should be different
    try testing.expect(!std.mem.eql(u8, &signer1.address.bytes, &signer2.address.bytes));
}
```

### LocalSigner - signer interface

```zig
test "LocalSigner - signer interface" {
    const private_key = PrivateKey{
        0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88,
        0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff, 0x00,
        0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88,
        0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff, 0x00,
    };

    var local = try LocalSigner.init(private_key);
    defer local.deinit();

    const generic_signer = local.signer();

    // Use generic interface
    const address = generic_signer.getAddress();
    try testing.expectEqual(@as(usize, 20), address.bytes.len);

    const pub_key = generic_signer.getPublicKey();
    try testing.expect(pub_key != null);
    try testing.expect(pub_key.?.isValid());
}
```

### LocalSigner - invalid private key zero

```zig
test "LocalSigner - invalid private key zero" {
    const zero_key = PrivateKey{0} ** 32;
    const result = LocalSigner.init(zero_key);
    try testing.expectError(SignerError.InvalidPrivateKey, result);
}
```

### HardwareWalletSigner - not connected error

```zig
test "HardwareWalletSigner - not connected error" {
    // Mock vtable that always returns not connected
    const MockVTable = struct {
        fn connect(_: *anyopaque) SignerError!void {
            return SignerError.DeviceError;
        }
        fn disconnect(_: *anyopaque) void {}
        fn isConnected(_: *anyopaque) bool {
            return false;
        }
        fn getAddr(_: *anyopaque, _: []const u8) SignerError!Address {
            return SignerError.NotConnected;
        }
        fn signH(_: *anyopaque, _: []const u8, _: Hash.Hash) SignerError!Signature {
            return SignerError.NotConnected;
        }
        fn signM(_: *anyopaque, _: []const u8, _: []const u8) SignerError!Signature {
            return SignerError.NotConnected;
        }
        fn signT(_: *anyopaque, _: []const u8, _: Hash.Hash) SignerError!Signature {
            return SignerError.NotConnected;
        }
    };

    const vtable = HardwareWalletSigner.VTable{
        .connect = MockVTable.connect,
        .disconnect = MockVTable.disconnect,
        .isConnected = MockVTable.isConnected,
        .getAddress = MockVTable.getAddr,
        .signHash = MockVTable.signH,
        .signMessage = MockVTable.signM,
        .signTypedDataHash = MockVTable.signT,
    };

    var dummy: u8 = 0;
    var hw_signer = HardwareWalletSigner{
        .ptr = &dummy,
        .vtable = &vtable,
        .derivation_path = "m/44'/60'/0'/0/0",
        .cached_address = null,
    };

    // Should fail with NotConnected
    const hash = Hash.keccak256("test");
    try testing.expectError(SignerError.NotConnected, hw_signer.signHash(hash));
}
```

### JsonRpcSigner - parseSignatureResponse

```zig
test "JsonRpcSigner - parseSignatureResponse" {
    // Valid signature hex (0x + 64 + 64 + 2 = 132 chars)
    const valid_sig = "0x" ++
        "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa" ++ // r
        "bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb" ++ // s
        "1c"; // v = 28

    const sig = try JsonRpcSigner.parseSignatureResponse(valid_sig);
    try testing.expectEqual(@as(u8, 0x1c), sig.v);
}
```

### hexCharToValue

```zig
test "hexCharToValue" {
    try testing.expectEqual(@as(?u8, 0), hexCharToValue('0'));
    try testing.expectEqual(@as(?u8, 9), hexCharToValue('9'));
    try testing.expectEqual(@as(?u8, 10), hexCharToValue('a'));
    try testing.expectEqual(@as(?u8, 15), hexCharToValue('f'));
    try testing.expectEqual(@as(?u8, 10), hexCharToValue('A'));
    try testing.expectEqual(@as(?u8, 15), hexCharToValue('F'));
    try testing.expectEqual(@as(?u8, null), hexCharToValue('g'));
    try testing.expectEqual(@as(?u8, null), hexCharToValue('Z'));
}
```

### createSigner - from private key

```zig
test "createSigner - from private key" {
    const private_key = PrivateKey{
        0xac, 0x09, 0x74, 0xbe, 0xc3, 0x9a, 0x17, 0xe3,
        0x6b, 0xa4, 0xa6, 0xb4, 0xd2, 0x38, 0xff, 0x24,
        0x4e, 0x21, 0xdb, 0x63, 0x5c, 0x51, 0xcb, 0x29,
        0x36, 0x49, 0x5a, 0xf7, 0x42, 0x2f, 0xba, 0x41,
    };

    var signer = try createSigner(.{ .private_key = private_key });
    defer signer.deinit();

    try testing.expect(signer.public_key.isValid());
}
```

### createSigner - from hex string

```zig
test "createSigner - from hex string" {
    const hex = "ac0974bec39a17e36ba4a6b4d238ff244e21db635c51cb2936495af7422fba41";

    var signer = try createSigner(.{ .private_key_hex = hex });
    defer signer.deinit();

    try testing.expect(signer.public_key.isValid());
}
```

### createSigner - random

```zig
test "createSigner - random" {
    var signer = try createSigner(.{ .random = true });
    defer signer.deinit();

    try testing.expect(signer.public_key.isValid());
}
```

### createSigner - no options returns error

```zig
test "createSigner - no options returns error" {
    const result = createSigner(.{});
    try testing.expectError(SignerError.InvalidPrivateKey, result);
}
```

### createSignerFromHex

```zig
test "createSignerFromHex" {
    const hex = "ac0974bec39a17e36ba4a6b4d238ff244e21db635c51cb2936495af7422fba41";

    var signer = try createSignerFromHex(hex);
    defer signer.deinit();

    try testing.expect(signer.public_key.isValid());
}
```

### createRandomSigner

```zig
test "createRandomSigner" {
    var signer1 = try createRandomSigner();
    defer signer1.deinit();

    var signer2 = try createRandomSigner();
    defer signer2.deinit();

    // Should produce different signers
    try testing.expect(!std.mem.eql(u8, &signer1.address.bytes, &signer2.address.bytes));
}
```

### isValidSigner - valid signer

```zig
test "isValidSigner - valid signer" {
    const private_key = PrivateKey{
        0xac, 0x09, 0x74, 0xbe, 0xc3, 0x9a, 0x17, 0xe3,
        0x6b, 0xa4, 0xa6, 0xb4, 0xd2, 0x38, 0xff, 0x24,
        0x4e, 0x21, 0xdb, 0x63, 0x5c, 0x51, 0xcb, 0x29,
        0x36, 0x49, 0x5a, 0xf7, 0x42, 0x2f, 0xba, 0x41,
    };

    var signer = try LocalSigner.init(private_key);
    defer signer.deinit();

    try testing.expect(isValidSigner(&signer));
}
```

### isSignerConfigured - configured signer

```zig
test "isSignerConfigured - configured signer" {
    const private_key = PrivateKey{
        0xac, 0x09, 0x74, 0xbe, 0xc3, 0x9a, 0x17, 0xe3,
        0x6b, 0xa4, 0xa6, 0xb4, 0xd2, 0x38, 0xff, 0x24,
        0x4e, 0x21, 0xdb, 0x63, 0x5c, 0x51, 0xcb, 0x29,
        0x36, 0x49, 0x5a, 0xf7, 0x42, 0x2f, 0xba, 0x41,
    };

    var signer = try LocalSigner.init(private_key);
    defer signer.deinit();

    try testing.expect(isSignerConfigured(&signer));
}
```

### createSigner priority - random takes precedence

```zig
test "createSigner priority - random takes precedence" {
    // When random is true, it should create a random signer regardless of other options
    const private_key = PrivateKey{
        0xac, 0x09, 0x74, 0xbe, 0xc3, 0x9a, 0x17, 0xe3,
        0x6b, 0xa4, 0xa6, 0xb4, 0xd2, 0x38, 0xff, 0x24,
        0x4e, 0x21, 0xdb, 0x63, 0x5c, 0x51, 0xcb, 0x29,
        0x36, 0x49, 0x5a, 0xf7, 0x42, 0x2f, 0xba, 0x41,
    };

    var signer = try createSigner(.{ .random = true, .private_key = private_key });
    defer signer.deinit();

    // Verify it's a valid signer (could be the same or different address)
    try testing.expect(signer.public_key.isValid());
}
```
