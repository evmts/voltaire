---
title: '[Zig] src/crypto/bn254/Fr.zig'
source: 'src/crypto/bn254/Fr.zig'
---

> Auto-generated from Zig tests in: src/crypto/bn254/Fr.zig

### Fr.add basic addition

```zig
test "Fr.add basic addition" {
    const a = Fr{ .value = 10 };
    const b = Fr{ .value = 20 };
    const result = a.add(&b);
    try std.testing.expect(result.value == 30);
}
```

### Fr.add with modular reduction

```zig
test "Fr.add with modular reduction" {
    const a = Fr{ .value = FR_MOD - 1 };
    const b = Fr{ .value = 5 };
    const result = a.add(&b);
    try std.testing.expect(result.value == 4);
}
```

### Fr.add with zero

```zig
test "Fr.add with zero" {
    const a = Fr{ .value = 100 };
    const b = Fr{ .value = 0 };
    const result = a.add(&b);
    try std.testing.expect(result.value == 100);
}
```

### Fr.add resulting in modulus

```zig
test "Fr.add resulting in modulus" {
    const a = Fr{ .value = FR_MOD - 10 };
    const b = Fr{ .value = 10 };
    const result = a.add(&b);
    try std.testing.expect(result.value == 0);
}
```

### Fr.neg basic negation

```zig
test "Fr.neg basic negation" {
    const a = Fr{ .value = 100 };
    const result = a.neg();
    try std.testing.expect(result.value == FR_MOD - 100);
}
```

### Fr.neg of zero

```zig
test "Fr.neg of zero" {
    const a = Fr{ .value = 0 };
    const result = a.neg();
    try std.testing.expect(result.value == 0);
}
```

### Fr.neg of maximum value

```zig
test "Fr.neg of maximum value" {
    const a = Fr{ .value = FR_MOD - 1 };
    const result = a.neg();
    try std.testing.expect(result.value == 1);
}
```

### Fr.sub basic subtraction

```zig
test "Fr.sub basic subtraction" {
    const a = Fr{ .value = 50 };
    const b = Fr{ .value = 20 };
    const result = a.sub(&b);
    try std.testing.expect(result.value == 30);
}
```

### Fr.sub with underflow

```zig
test "Fr.sub with underflow" {
    const a = Fr{ .value = 10 };
    const b = Fr{ .value = 20 };
    const result = a.sub(&b);
    try std.testing.expect(result.value == FR_MOD - 10);
}
```

### Fr.sub with zero

```zig
test "Fr.sub with zero" {
    const a = Fr{ .value = 100 };
    const b = Fr{ .value = 0 };
    const result = a.sub(&b);
    try std.testing.expect(result.value == 100);
}
```

### Fr.sub from zero

```zig
test "Fr.sub from zero" {
    const a = Fr{ .value = 0 };
    const b = Fr{ .value = 25 };
    const result = a.sub(&b);
    try std.testing.expect(result.value == FR_MOD - 25);
}
```

### Fr.mul basic multiplication

```zig
test "Fr.mul basic multiplication" {
    const a = Fr{ .value = 6 };
    const b = Fr{ .value = 5 };
    const result = a.mul(&b);
    try std.testing.expect(result.value == 30);
}
```

### Fr.mul with zero

```zig
test "Fr.mul with zero" {
    const a = Fr{ .value = 100 };
    const b = Fr{ .value = 0 };
    const result = a.mul(&b);
    try std.testing.expect(result.value == 0);
}
```

### Fr.mul with one

```zig
test "Fr.mul with one" {
    const a = Fr{ .value = 123 };
    const b = Fr{ .value = 1 };
    const result = a.mul(&b);
    try std.testing.expect(result.value == 123);
}
```

### Fr.mul with modular reduction

```zig
test "Fr.mul with modular reduction" {
    const a = Fr{ .value = FR_MOD - 1 };
    const b = Fr{ .value = 2 };
    const result = a.mul(&b);
    try std.testing.expect(result.value == FR_MOD - 2);
}
```

### Fr.mul large values

```zig
test "Fr.mul large values" {
    const a = Fr{ .value = FR_MOD - 1 };
    const b = Fr{ .value = FR_MOD - 5 };
    const result = a.mul(&b);
    // This will test the modular reduction behavior with large numbers
    try std.testing.expect(result.value == 5);
}
```

### Fr.pow basic power

```zig
test "Fr.pow basic power" {
    const a = Fr{ .value = 2 };
    const result = a.pow(3);
    try std.testing.expect(result.value == 8);
}
```

### Fr.pow to power of zero

```zig
test "Fr.pow to power of zero" {
    const a = Fr{ .value = 123 };
    const result = a.pow(0);
    try std.testing.expect(result.value == 1);
}
```

### Fr.pow to power of one

```zig
test "Fr.pow to power of one" {
    const a = Fr{ .value = 456 };
    const result = a.pow(1);
    try std.testing.expect(result.value == 456);
}
```

### Fr.pow with base zero

```zig
test "Fr.pow with base zero" {
    const a = Fr{ .value = 0 };
    const result = a.pow(5);
    try std.testing.expect(result.value == 0);
}
```

### Fr.pow with base one

```zig
test "Fr.pow with base one" {
    const a = Fr{ .value = 1 };
    const result = a.pow(100);
    try std.testing.expect(result.value == 1);
}
```

### Fr.pow large exponent

```zig
test "Fr.pow large exponent" {
    const a = Fr{ .value = 3 };
    const result = a.pow(10);
    try std.testing.expect(result.value == 59049);
}
```

### Fr.pow with modular reduction

```zig
test "Fr.pow with modular reduction" {
    const a = Fr{ .value = FR_MOD - 1 };
    const result = a.pow(2);
    try std.testing.expect(result.value == 1);
}
```

### Fr.inv basic inverse

```zig
test "Fr.inv basic inverse" {
    const a = Fr{ .value = 2 };
    const a_inv = try a.inv();
    const product = a.mul(&a_inv);
    try std.testing.expect(product.value == 1);
}
```

### Fr.inv of one

```zig
test "Fr.inv of one" {
    const a = Fr{ .value = 1 };
    const result = try a.inv();
    try std.testing.expect(result.value == 1);
}
```

### Fr.inv double inverse

```zig
test "Fr.inv double inverse" {
    const a = Fr{ .value = 17 };
    const a_inv = try a.inv();
    const a_double_inv = try a_inv.inv();
    try std.testing.expect(a_double_inv.value == a.value);
}
```

### Fr.inv with known value

```zig
test "Fr.inv with known value" {
    const a = Fr{ .value = 3 };
    const a_inv = try a.inv();
    const product = a.mul(&a_inv);
    try std.testing.expect(product.value == 1);
}
```

### Fr.inv large value

```zig
test "Fr.inv large value" {
    const a = Fr{ .value = 12345678 };
    const a_inv = try a.inv();
    const product = a.mul(&a_inv);
    try std.testing.expect(product.value == 1);
}
```

### Fr.equal basic equality

```zig
test "Fr.equal basic equality" {
    const a = Fr{ .value = 123 };
    const b = Fr{ .value = 123 };
    try std.testing.expect(a.equal(&b));
}
```

### Fr.equal different values

```zig
test "Fr.equal different values" {
    const a = Fr{ .value = 123 };
    const b = Fr{ .value = 456 };
    try std.testing.expect(!a.equal(&b));
}
```

### Fr.init basic initialization

```zig
test "Fr.init basic initialization" {
    const a = Fr.init(123);
    try std.testing.expect(a.value == 123);
}
```

### Fr.init with modular reduction

```zig
test "Fr.init with modular reduction" {
    const a = Fr.init(FR_MOD + 5);
    try std.testing.expect(a.value == 5);
}
```

### Fr.mul near modulus boundary

```zig
test "Fr.mul near modulus boundary" {
    const a = Fr{ .value = FR_MOD - 1 };
    const b = Fr{ .value = FR_MOD - 1 };
    const result = a.mul(&b);
    try std.testing.expect(result.value == 1);
}
```

### Fr.mul distributive property

```zig
test "Fr.mul distributive property" {
    const a = Fr{ .value = 123 };
    const b = Fr{ .value = 456 };
    const c = Fr{ .value = 789 };
    const left = a.mul(&b.add(&c));
    const right = a.mul(&b).add(&a.mul(&c));
    try std.testing.expect(left.equal(&right));
}
```

### Fr.mul associative property

```zig
test "Fr.mul associative property" {
    const a = Fr{ .value = 123 };
    const b = Fr{ .value = 456 };
    const c = Fr{ .value = 789 };
    const left = a.mul(&b).mul(&c);
    const right = a.mul(&b).mul(&c);
    try std.testing.expect(left.equal(&right));
}
```

### Fr.add modular wraparound edge case

```zig
test "Fr.add modular wraparound edge case" {
    const a = Fr{ .value = FR_MOD - 1 };
    const b = Fr{ .value = FR_MOD - 1 };
    const result = a.add(&b);
    try std.testing.expect(result.value == FR_MOD - 2);
}
```

### Fr.pow edge case with large exponent

```zig
test "Fr.pow edge case with large exponent" {
    const a = Fr{ .value = 2 };
    const result = a.pow(256);
    // 2^256 mod FR_MOD should be computed correctly
    try std.testing.expect(result.value < FR_MOD);
}
```

### Fr.inv mathematical property a * a^-1 = 1

```zig
test "Fr.inv mathematical property a * a^-1 = 1" {
    const values = [_]u256{ 2, 3, 7, 11, 13, 17, 65537, FR_MOD - 1 };
    for (values) |val| {
        const a = Fr{ .value = val };
        const a_inv = try a.inv();
        const product = a.mul(&a_inv);
        try std.testing.expect(product.value == 1);
    }
}
```

### Fr.inv of zero returns error

```zig
test "Fr.inv of zero returns error" {
    const a = Fr{ .value = 0 };
    try std.testing.expectError(error.DivisionByZero, a.inv());
}
```

### Fr.equal is constant-time by design

```zig
test "Fr.equal is constant-time by design" {
    // Verify equal() uses simple value comparison (constant-time operation)
    // The implementation uses direct == comparison which is constant-time for fixed-size integers
    const a = Fr{ .value = 123 };
    const b = Fr{ .value = 123 };
    const c = Fr{ .value = 456 };

    // Equal values
    try std.testing.expect(a.equal(&b));

    // Unequal values - same code path, no early return
    try std.testing.expect(!a.equal(&c));

    // Test with zero
    const zero = Fr.ZERO;
    try std.testing.expect(zero.equal(&Fr{ .value = 0 }));
    try std.testing.expect(!zero.equal(&a));

    // Test with max value
    const max_val = Fr{ .value = FR_MOD - 1 };
    try std.testing.expect(max_val.equal(&Fr{ .value = FR_MOD - 1 }));
    try std.testing.expect(!max_val.equal(&a));
}
```

### Fr.equal returns same type for all inputs

```zig
test "Fr.equal returns same type for all inputs" {
    // Document that equal() always returns bool without branching on comparison result internally
    // This ensures constant-time behavior
    const test_values = [_]u256{ 0, 1, 2, 100, 999, FR_MOD - 1 };

    for (test_values) |val1| {
        for (test_values) |val2| {
            const a = Fr{ .value = val1 };
            const b = Fr{ .value = val2 };
            const result = a.equal(&b);

            // Result is always bool, no exceptions or early returns based on values
            try std.testing.expect(@TypeOf(result) == bool);

            // Verify symmetric property
            try std.testing.expect(a.equal(&b) == b.equal(&a));
        }
    }
}
```
