---
title: '[Zig] src/crypto/bn254/Fp4Mont.zig'
source: 'src/crypto/bn254/Fp4Mont.zig'
---

> Auto-generated from Zig tests in: src/crypto/bn254/Fp4Mont.zig

### Fp4Mont.init basic initialization

```zig
test "Fp4Mont.init basic initialization" {
    const a = fp4mont(123, 456, 789, 101112);
    const expected = Fp4Mont{
        .y0 = Fp2Mont.initFromInt(123, 456),
        .y1 = Fp2Mont.initFromInt(789, 101112),
    };
    try expectFp4MontEqual(expected, a);
}
```

### Fp4Mont.init with modular reduction

```zig
test "Fp4Mont.init with modular reduction" {
    const a = fp4mont(curve_parameters.FP_MOD + 5, curve_parameters.FP_MOD + 10, curve_parameters.FP_MOD + 15, curve_parameters.FP_MOD + 20);
    const expected = fp4mont(5, 10, 15, 20);
    try expectFp4MontEqual(expected, a);
}
```

### Fp4Mont.add basic addition

```zig
test "Fp4Mont.add basic addition" {
    const a = fp4mont(10, 20, 30, 40);
    const b = fp4mont(50, 60, 70, 80);
    const result = a.add(&b);
    try expectFp4MontEqual(fp4mont(60, 80, 100, 120), result);
}
```

### Fp4Mont.add with zero

```zig
test "Fp4Mont.add with zero" {
    const a = fp4mont(100, 200, 300, 400);
    const zero = fp4mont(0, 0, 0, 0);
    const result = a.add(&zero);
    try expectFp4MontEqual(a, result);
}
```

### Fp4Mont.add with modular reduction

```zig
test "Fp4Mont.add with modular reduction" {
    const a = fp4mont(curve_parameters.FP_MOD - 1, curve_parameters.FP_MOD - 2, curve_parameters.FP_MOD - 3, curve_parameters.FP_MOD - 4);
    const b = fp4mont(5, 10, 15, 20);
    const result = a.add(&b);
    try expectFp4MontEqual(fp4mont(4, 8, 12, 16), result);
}
```

### Fp4Mont.add commutative property

```zig
test "Fp4Mont.add commutative property" {
    const a = fp4mont(15, 25, 35, 45);
    const b = fp4mont(55, 65, 75, 85);
    const result1 = a.add(&b);
    const result2 = b.add(&a);
    try expectFp4MontEqual(result1, result2);
}
```

### Fp4Mont.neg basic negation

```zig
test "Fp4Mont.neg basic negation" {
    const a = fp4mont(100, 200, 300, 400);
    const result = a.neg();
    const expected = fp4mont(curve_parameters.FP_MOD - 100, curve_parameters.FP_MOD - 200, curve_parameters.FP_MOD - 300, curve_parameters.FP_MOD - 400);
    try expectFp4MontEqual(expected, result);
}
```

### Fp4Mont.neg double negation

```zig
test "Fp4Mont.neg double negation" {
    const a = fp4mont(123, 456, 789, 101112);
    const result = a.neg().neg();
    try expectFp4MontEqual(a, result);
}
```

### Fp4Mont.neg of zero

```zig
test "Fp4Mont.neg of zero" {
    const zero = fp4mont(0, 0, 0, 0);
    const result = zero.neg();
    const expected = fp4mont(0, 0, 0, 0);
    try expectFp4MontEqual(expected, result);
}
```

### Fp4Mont.sub basic subtraction

```zig
test "Fp4Mont.sub basic subtraction" {
    const a = fp4mont(100, 150, 200, 250);
    const b = fp4mont(30, 50, 70, 90);
    const result = a.sub(&b);
    try expectFp4MontEqual(fp4mont(70, 100, 130, 160), result);
}
```

### Fp4Mont.sub with zero

```zig
test "Fp4Mont.sub with zero" {
    const a = fp4mont(100, 200, 300, 400);
    const zero = fp4mont(0, 0, 0, 0);
    const result = a.sub(&zero);
    try expectFp4MontEqual(a, result);
}
```

### Fp4Mont.sub from zero

```zig
test "Fp4Mont.sub from zero" {
    const a = fp4mont(25, 35, 45, 55);
    const zero = fp4mont(0, 0, 0, 0);
    const result = zero.sub(&a);
    try expectFp4MontEqual(a.neg(), result);
}
```

### Fp4Mont.square of zero

```zig
test "Fp4Mont.square of zero" {
    const zero = fp4mont(0, 0, 0, 0);
    const result = zero.square();
    try expectFp4MontEqual(zero, result);
}
```

### Fp4Mont.square of one

```zig
test "Fp4Mont.square of one" {
    const one = fp4mont(1, 0, 0, 0);
    const result = one.square();
    try expectFp4MontEqual(one, result);
}
```

### Fp4Mont.conj basic conjugate

```zig
test "Fp4Mont.conj basic conjugate" {
    const a = fp4mont(5, 7, 9, 11);
    const result = a.conj();
    const expected = fp4mont(5, 7, curve_parameters.FP_MOD - 9, curve_parameters.FP_MOD - 11);
    try expectFp4MontEqual(expected, result);
}
```

### Fp4Mont.conj double conjugate

```zig
test "Fp4Mont.conj double conjugate" {
    const a = fp4mont(123, 456, 789, 101112);
    const result = a.conj().conj();
    try expectFp4MontEqual(a, result);
}
```

### Fp4Mont.conj of real number

```zig
test "Fp4Mont.conj of real number" {
    const a = fp4mont(100, 50, 0, 0);
    const result = a.conj();
    const expected = fp4mont(100, 50, 0, 0);
    try expectFp4MontEqual(expected, result);
}
```

### Fp4Mont.equal basic equality

```zig
test "Fp4Mont.equal basic equality" {
    const a = fp4mont(123, 456, 789, 101112);
    const b = fp4mont(123, 456, 789, 101112);
    try std.testing.expect(a.equal(&b));
}
```

### Fp4Mont.equal different values

```zig
test "Fp4Mont.equal different values" {
    const a = fp4mont(123, 456, 789, 101112);
    const b = fp4mont(321, 456, 789, 101112);
    try std.testing.expect(!a.equal(&b));
}
```

### Fp4Mont.equal reflexive property

```zig
test "Fp4Mont.equal reflexive property" {
    const a = fp4mont(111, 222, 333, 444);
    try std.testing.expect(a.equal(&a));
}
```

### Fp4Mont.mulBySmallInt basic multiplication

```zig
test "Fp4Mont.mulBySmallInt basic multiplication" {
    const a = fp4mont(2, 3, 4, 5);
    const result = a.mulBySmallInt(3);
    try expectFp4MontEqual(fp4mont(6, 9, 12, 15), result);
}
```

### Fp4Mont.mulBySmallInt with zero

```zig
test "Fp4Mont.mulBySmallInt with zero" {
    const a = fp4mont(10, 20, 30, 40);
    const result = a.mulBySmallInt(0);
    try expectFp4MontEqual(fp4mont(0, 0, 0, 0), result);
}
```

### Fp4Mont.mulBySmallInt with one

```zig
test "Fp4Mont.mulBySmallInt with one" {
    const a = fp4mont(123, 456, 789, 101112);
    const result = a.mulBySmallInt(1);
    try expectFp4MontEqual(a, result);
}
```

### Fp4Mont.mulByY basic operation

```zig
test "Fp4Mont.mulByY basic operation" {
    const a = fp4mont(1, 2, 3, 4);
    const result = a.mulByY();
    const xi = curve_parameters.XI;
    const expected_y0 = Fp2Mont.initFromInt(3, 4).mul(&xi);
    const expected_y1 = Fp2Mont.initFromInt(1, 2);
    const expected = Fp4Mont{ .y0 = expected_y0, .y1 = expected_y1 };
    try expectFp4MontEqual(expected, result);
}
```
