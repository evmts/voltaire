---
title: '[Zig] src/crypto/bn254/G2.zig'
source: 'src/crypto/bn254/G2.zig'
---

> Auto-generated from Zig tests in: src/crypto/bn254/G2.zig

### G2.isOnCurve generator

```zig
test "G2.isOnCurve generator" {
    try std.testing.expect(G2.GENERATOR.isOnCurve());
}
```

### G2.isOnCurve identity

```zig
test "G2.isOnCurve identity" {
    try std.testing.expect(G2.INFINITY.isOnCurve());
}
```

### G2.isOnCurve multiples

```zig
test "G2.isOnCurve multiples" {
    const scalars = [_]u256{ 2, 3, 7, 13, 27 };
    for (scalars) |k| {
        var scalar = Fr.init(k);
        const point = G2.GENERATOR.mul(&scalar);
        try std.testing.expect(point.isOnCurve());
    }
}
```

### G2.curve order annihilates subgroup points

```zig
test "G2.curve order annihilates subgroup points" {
    const order = curve_parameters.FR_MOD;
    const scalars = [_]u256{ 1, 5, 9, 33, 101 };
    for (scalars) |k| {
        var scalar = Fr.init(k);
        const point = G2.GENERATOR.mul(&scalar);
        const multiple = point.mulByInt(order);
        try std.testing.expect(multiple.isInfinity());
    }
}
```

### G2.isInSubgroup generator multiples

```zig
test "G2.isInSubgroup generator multiples" {
    const scalars = [_]u256{ 1, 7, 19, 123, 98765 };
    for (scalars) |k| {
        var scalar = Fr.init(k);
        const point = G2.GENERATOR.mul(&scalar);
        try std.testing.expect(point.isInSubgroup());
    }
}
```

### G2.isInSubgroup non subgroup point

```zig
test "G2.isInSubgroup non subgroup point" {
    const x = Fp2Mont{ .u0 = FpMont{ .value = 122 }, .u1 = FpMont{ .value = 3333 } };
    const y = Fp2Mont{ .u0 = FpMont{ .value = 4562906498667794019468448659772613644715180855375958127421599247974276735405 }, .u1 = FpMont{ .value = 11306249705311604911826567979787687424320829738512421461876664403170710609448 } };
    const z = Fp2Mont.ONE;
    const point = G2.initUnchecked(&x, &y, &z);
    try std.testing.expect(point.isOnCurve());
    try std.testing.expect(!point.isInSubgroup());
}
```

### G2.equal different representations same point

```zig
test "G2.equal different representations same point" {
    var scalar = Fr.init(11);
    const point = G2.GENERATOR.mul(&scalar);
    const scale = Fp2Mont.initFromInt(5, 0);
    const scale_sq = scale.mul(&scale);
    const scale_cu = scale_sq.mul(&scale);
    const scaled = G2{
        .x = point.x.mul(&scale_sq),
        .y = point.y.mul(&scale_cu),
        .z = point.z.mul(&scale),
    };
    try std.testing.expect(point.equal(&scaled));
}
```

### G2.toAffine normalizes coordinates

```zig
test "G2.toAffine normalizes coordinates" {
    var scalar = Fr.init(19);
    const projective = G2.GENERATOR.mul(&scalar);
    const affine = projective.toAffine();
    try std.testing.expect(affine.z.equal(&Fp2Mont.ONE));
    try std.testing.expect(projective.equal(&affine));
    try std.testing.expect(affine.isOnCurve());
}
```

### G2.add inverse gives infinity

```zig
test "G2.add inverse gives infinity" {
    var scalar = Fr.init(23);
    const point = G2.GENERATOR.mul(&scalar);
    const inverse = point.neg();
    const sum = point.add(&inverse);
    try std.testing.expect(sum.isInfinity());
}
```

### G2.add commutativity

```zig
test "G2.add commutativity" {
    var s1 = Fr.init(9);
    var s2 = Fr.init(17);
    const p1 = G2.GENERATOR.mul(&s1);
    const p2 = G2.GENERATOR.mul(&s2);
    const left = p1.add(&p2);
    const right = p2.add(&p1);
    try std.testing.expect(left.equal(&right));
}
```

### G2.add associativity

```zig
test "G2.add associativity" {
    var s1 = Fr.init(5);
    var s2 = Fr.init(11);
    var s3 = Fr.init(19);
    const p1 = G2.GENERATOR.mul(&s1);
    const p2 = G2.GENERATOR.mul(&s2);
    const p3 = G2.GENERATOR.mul(&s3);

    var left = p1.add(&p2);
    left.addAssign(&p3);
    var right = p2.add(&p3);
    right.addAssign(&p1);
    try std.testing.expect(left.equal(&right));
}
```

### G2.double matches add self

```zig
test "G2.double matches add self" {
    var scalar = Fr.init(29);
    const point = G2.GENERATOR.mul(&scalar);
    const doubled = point.double();
    const sum = point.add(&point);
    try std.testing.expect(doubled.equal(&sum));
}
```

### G2.assignment helpers

```zig
test "G2.assignment helpers" {
    var s1 = Fr.init(7);
    var s2 = Fr.init(13);
    var p = G2.GENERATOR.mul(&s1);
    const q = G2.GENERATOR.mul(&s2);

    const add_expected = p.add(&q);
    p.addAssign(&q);
    try std.testing.expect(p.equal(&add_expected));

    p = G2.GENERATOR.mul(&s1);
    const double_expected = p.double();
    p.doubleAssign();
    try std.testing.expect(p.equal(&double_expected));

    p = G2.GENERATOR.mul(&s1);
    const neg_expected = p.neg();
    p.negAssign();
    try std.testing.expect(p.equal(&neg_expected));

    p = G2.GENERATOR.mul(&s1);
    var scalar = Fr.init(21);
    const mul_expected = p.mul(&scalar);
    p.mulAssign(&scalar);
    try std.testing.expect(p.equal(&mul_expected));
}
```

### G2.mul matches naive ladder

```zig
test "G2.mul matches naive ladder" {
    const scalars = [_]u256{ 0, 1, 2, 3, 5, 9, 15, 37 };
    for (scalars) |k| {
        var expected = INFINITY;
        var addend = G2.GENERATOR;
        var tmp = k;
        while (tmp != 0) : (tmp >>= 1) {
            if ((tmp & 1) == 1) {
                expected = expected.add(&addend);
            }
            addend = addend.double();
        }
        const actual = G2.GENERATOR.mulByInt(k);
        try std.testing.expect(expected.equal(&actual));
    }
}
```

### G2.mul edge cases

```zig
test "G2.mul edge cases" {
    const zero = G2.GENERATOR.mulByInt(0);
    try std.testing.expect(zero.isInfinity());

    const one = G2.GENERATOR.mulByInt(1);
    try std.testing.expect(one.equal(&G2.GENERATOR));

    const near_order = curve_parameters.FR_MOD - 1;
    const neg_point = G2.GENERATOR.neg();
    const result = G2.GENERATOR.mulByInt(near_order);
    try std.testing.expect(result.equal(&neg_point));
}
```

### G2.distributivity over addition

```zig
test "G2.distributivity over addition" {
    var s1 = Fr.init(8);
    var s2 = Fr.init(21);
    const scalar = Fr.init(17);
    const p = G2.GENERATOR.mul(&s1);
    const q = G2.GENERATOR.mul(&s2);

    const lhs = p.mul(&scalar).add(&q.mul(&scalar));
    const rhs = p.add(&q).mul(&scalar);
    try std.testing.expect(lhs.equal(&rhs));
}
```

### G2.lambda endomorphism equals multiplication by lambda

```zig
test "G2.lambda endomorphism equals multiplication by lambda" {
    const lambda = Fr{ .value = curve_parameters.G2_SCALAR.lambda };
    const scalars = [_]u256{ 1, 3, 17, 55, 1234 };
    for (scalars) |k| {
        var scalar = Fr.init(k);
        const point = G2.GENERATOR.mul(&scalar);
        const by_lambda = point.mul(&lambda);
        const endo = point.lambdaEndomorphism();
        try std.testing.expect(by_lambda.equal(&endo));
    }
}
```

### G2.gamma endomorphism equals multiplication by gamma

```zig
test "G2.gamma endomorphism equals multiplication by gamma" {
    const gamma = Fr{ .value = curve_parameters.G2_SCALAR.gamma };
    const scalars = [_]u256{ 2, 9, 27, 91 };
    for (scalars) |k| {
        var scalar = Fr.init(k);
        const point = G2.GENERATOR.mul(&scalar);
        const by_gamma = point.mul(&gamma);
        const endo = point.gammaEndomorphism();
        try std.testing.expect(by_gamma.equal(&endo));
    }
}
```

### G2.gamma lambda endomorphism equals multiplication by gamma lambda

```zig
test "G2.gamma lambda endomorphism equals multiplication by gamma lambda" {
    const gamma_lambda = Fr{ .value = curve_parameters.G2_SCALAR.gamma_lambda };
    const scalars = [_]u256{ 4, 13, 29, 123 };
    for (scalars) |k| {
        var scalar = Fr.init(k);
        const point = G2.GENERATOR.mul(&scalar);
        const composed = point.gammaEndomorphism().lambdaEndomorphism();
        const by_gamma_lambda = point.mul(&gamma_lambda);
        const direct = point.gammaLambdaEndomorphism();
        try std.testing.expect(by_gamma_lambda.equal(&direct));
        try std.testing.expect(composed.equal(&direct));
    }
}
```

### G2.frobenius has order 12

```zig
test "G2.frobenius has order 12" {
    var scalar = Fr.init(15);
    const point = G2.GENERATOR.mul(&scalar);
    var iter = point;
    var i: usize = 0;
    while (i < 12) : (i += 1) {
        iter = iter.frobenius();
        try std.testing.expect(iter.isOnCurve());
    }
    try std.testing.expect(iter.equal(&point));
}
```

### G2.decomposeScalar recomposes original

```zig
test "G2.decomposeScalar recomposes original" {
    const scalars = [_]Fr{
        Fr.init(1),
        Fr.init(56789),
        Fr.init(9876543210),
        Fr.init(curve_parameters.FR_MOD - 5),
        Fr.init(curve_parameters.FR_MOD / 2 + 12345),
    };

    const lambda = @as(i512, @intCast(curve_parameters.G2_SCALAR.lambda));
    const gamma = @as(i512, @intCast(curve_parameters.G2_SCALAR.gamma));
    const gamma_lambda = @as(i512, @intCast(curve_parameters.G2_SCALAR.gamma_lambda));
    const modulus = @as(i512, @intCast(curve_parameters.FR_MOD));

    for (scalars) |scalar_val| {
        const decomposition = G2.decomposeScalar(scalar_val.value);
        const k1 = @as(i512, decomposition.k1);
        const k2 = @as(i512, decomposition.k2);
        const k3 = @as(i512, decomposition.k3);
        const k4 = @as(i512, decomposition.k4);

        var acc = k1;
        acc += lambda * k2;
        acc += gamma * k3;
        acc += gamma_lambda * k4;

        var reconstructed = @mod(acc, modulus);
        if (reconstructed < 0) {
            reconstructed += modulus;
        }
        const expected = @as(i512, @intCast(scalar_val.value));
        try std.testing.expect(reconstructed == expected);
    }
}
```

### G2.init validates subgroup membership for valid points

```zig
test "G2.init validates subgroup membership for valid points" {
    // Generator should be in subgroup
    const gen_affine = G2.GENERATOR.toAffine();
    const valid_point = try G2.init(&gen_affine.x, &gen_affine.y, &gen_affine.z);
    try std.testing.expect(valid_point.isInSubgroup());

    // Multiple of generator should be in subgroup
    var scalar = Fr.init(17);
    const multiple = G2.GENERATOR.mul(&scalar);
    const multiple_affine = multiple.toAffine();
    const valid_multiple = try G2.init(&multiple_affine.x, &multiple_affine.y, &multiple_affine.z);
    try std.testing.expect(valid_multiple.isInSubgroup());

    // Infinity should be in subgroup
    const infinity = try G2.init(&G2.INFINITY.x, &G2.INFINITY.y, &G2.INFINITY.z);
    try std.testing.expect(infinity.isInfinity());
    try std.testing.expect(infinity.isInSubgroup());
}
```

### G2.init rejects points not in subgroup

```zig
test "G2.init rejects points not in subgroup" {
    // Known point on curve but not in subgroup
    const x = Fp2Mont{ .u0 = FpMont{ .value = 122 }, .u1 = FpMont{ .value = 3333 } };
    const y = Fp2Mont{ .u0 = FpMont{ .value = 4562906498667794019468448659772613644715180855375958127421599247974276735405 }, .u1 = FpMont{ .value = 11306249705311604911826567979787687424320829738512421461876664403170710609448 } };
    const z = Fp2Mont.ONE;

    // Verify it's on curve but not in subgroup using unchecked constructor
    const unchecked_point = G2.initUnchecked(&x, &y, &z);
    try std.testing.expect(unchecked_point.isOnCurve());
    try std.testing.expect(!unchecked_point.isInSubgroup());

    // Now verify init() rejects it
    const result = G2.init(&x, &y, &z);
    try std.testing.expectError(error.NotInSubgroup, result);
}
```

### G2.init rejects points not on curve

```zig
test "G2.init rejects points not on curve" {
    // Random point not on curve
    const x = Fp2Mont{ .u0 = FpMont{ .value = 12345 }, .u1 = FpMont{ .value = 67890 } };
    const y = Fp2Mont{ .u0 = FpMont{ .value = 11111 }, .u1 = FpMont{ .value = 22222 } };
    const z = Fp2Mont.ONE;

    // Verify it's not on curve
    const unchecked_point = G2.initUnchecked(&x, &y, &z);
    try std.testing.expect(!unchecked_point.isOnCurve());

    // Now verify init() rejects it
    const result = G2.init(&x, &y, &z);
    try std.testing.expectError(error.InvalidPoint, result);
}
```
