---
title: '[Zig] src/crypto/secp256k1.zig'
source: 'src/crypto/secp256k1.zig'
---

> Auto-generated from Zig tests in: src/crypto/secp256k1.zig

### recover address from signature

```zig
test "recover address from signature" {
    const message = "Hello, Ethereum!";
    var hasher = crypto.hash.sha3.Keccak256.init(.{});
    hasher.update("\x19Ethereum Signed Message:\n");
    const length_str = try std.fmt.allocPrint(std.testing.allocator, "{d}", .{message.len});
    defer std.testing.allocator.free(length_str);
    hasher.update(length_str);
    hasher.update(message);
    var message_hash: [32]u8 = undefined;
    hasher.final(&message_hash);

    const r_val: u256 = 0x9f150809ad6e882b6e8f0c4dc4b0c5d58d6fd84ee8d48aef7e37b8d60f3d4f5a;
    const s_val: u256 = 0x6fc95f48bd0e960fb86fd656887187152553ad9fc4a5f0e9f098e9d4e2ec4895;
    const recoveryId: u8 = 0;

    const recovered_address = unauditedRecoverAddress(&message_hash, recoveryId, r_val, s_val) catch |err| {
        try std.testing.expect(err == error.InvalidSignature);
        return;
    };

    const zero_address = [_]u8{0} ** 20;
    try std.testing.expect(!std.mem.eql(u8, &recovered_address, &zero_address));
}
```

### signature malleability check

```zig
test "signature malleability check" {
    const r_val: u256 = 0x1234567890123456789012345678901234567890123456789012345678901234;
    const s_high: u256 = 0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141;

    try std.testing.expect(!unauditedValidateSignature(r_val, s_high));
}
```

### EIP-2 signature validation

```zig
test "EIP-2 signature validation" {
    const r_val: u256 = 0x1234567890123456789012345678901234567890123456789012345678901234;
    const s_val: u256 = 0x3456789012345678901234567890123456789012345678901234567890123456;

    try std.testing.expect(unauditedValidateSignature(r_val, s_val));
    try std.testing.expect(!unauditedValidateSignature(0, s_val));
    try std.testing.expect(!unauditedValidateSignature(r_val, 0));
}
```

### signature recovery edge cases

```zig
test "signature recovery edge cases" {
    const zero_hash = [_]u8{0} ** 32;
    const r_val: u256 = 0x1234567890123456789012345678901234567890123456789012345678901234;
    const s_val: u256 = 0x3456789012345678901234567890123456789012345678901234567890123456;

    const result = unauditedRecoverAddress(&zero_hash, 0, r_val, s_val);
    _ = result catch |err| {
        try std.testing.expect(err == error.InvalidSignature);
    };
}
```

### affine point operations

```zig
test "affine point operations" {
    const generator = AffinePoint.generator();

    try std.testing.expect(generator.isOnCurve());
    try std.testing.expect(!generator.infinity);

    const doubled = generator.double();
    try std.testing.expect(doubled.isOnCurve());
    try std.testing.expect(!doubled.infinity);

    const added = generator.add(generator);
    try std.testing.expect(added.x == doubled.x);
    try std.testing.expect(added.y == doubled.y);

    const negated = generator.negate();
    try std.testing.expect(negated.isOnCurve());
    try std.testing.expect(negated.x == generator.x);
    try std.testing.expect(negated.y == SECP256K1_P - generator.y);

    const zero = generator.add(negated);
    try std.testing.expect(zero.infinity);
}
```

### scalar multiplication

```zig
test "scalar multiplication" {
    const generator = AffinePoint.generator();

    const zero_mul = generator.scalarMul(0);
    try std.testing.expect(zero_mul.infinity);

    const one_mul = generator.scalarMul(1);
    try std.testing.expect(one_mul.x == generator.x);
    try std.testing.expect(one_mul.y == generator.y);

    const two_mul = generator.scalarMul(2);
    const doubled = generator.double();
    try std.testing.expect(two_mul.x == doubled.x);
    try std.testing.expect(two_mul.y == doubled.y);

    const n_mul = generator.scalarMul(SECP256K1_N);
    try std.testing.expect(n_mul.infinity);
}
```

### field arithmetic

```zig
test "field arithmetic" {
    const a: u256 = 0x123456789abcdef;
    const b: u256 = 0xfedcba987654321;
    const m: u256 = SECP256K1_P;
    const result = mulmod(a, b, m);
    try std.testing.expect(result < m);

    const sum = addmod(a, b, m);
    try std.testing.expect(sum < m);
    try std.testing.expect(sum == (a + b) % m);

    const diff = submod(b, a, m);
    try std.testing.expect(diff < m);
}
```

### modular inverse

```zig
test "modular inverse" {
    const a: u256 = 12345;
    const m: u256 = SECP256K1_N;
    const inv = modInverse(a, m).?;
    const prod = mulmod(a, inv, m);
    try std.testing.expect(prod == 1);
}
```

### recoverPubkey with valid signature

```zig
test "recoverPubkey with valid signature" {
    // Known test vector
    const hash = [_]u8{
        0xd1, 0x67, 0xea, 0x22, 0x8e, 0x51, 0x6b, 0x1d,
        0x8e, 0x51, 0x23, 0x1b, 0x3a, 0x7e, 0x34, 0x4b,
        0x23, 0x6f, 0x89, 0x6b, 0x43, 0x21, 0x8f, 0x6a,
        0x8e, 0x3d, 0x5a, 0x7b, 0x12, 0x34, 0x56, 0x78,
    };

    var r: [32]u8 = undefined;
    std.mem.writeInt(u256, &r, 0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798, .big);
    var s: [32]u8 = undefined;
    std.mem.writeInt(u256, &s, 0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8, .big);

    // This may fail with test data - that's expected
    const result = recoverPubkey(&hash, &r, &s, 27);
    if (result) |pub_key| {
        try std.testing.expect(pub_key.len == 64);
    } else |_| {
        // Expected for contrived test data
    }
}
```
