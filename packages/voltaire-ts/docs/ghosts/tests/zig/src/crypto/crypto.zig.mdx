---
title: '[Zig] src/crypto/crypto.zig'
source: 'src/crypto/crypto.zig'
---

> Auto-generated from Zig tests in: src/crypto/crypto.zig

### private key generation

```zig
test "private key generation" {
    const private_key = try unaudited_randomPrivateKey();

    // Verify it's not all zeros
    var is_zero = true;
    for (private_key) |byte| {
        if (byte != 0) {
            is_zero = false;
            break;
        }
    }
    try testing.expect(!is_zero);

    // Verify it's a valid private key
    const key_as_u256 = std.mem.readInt(u256, &private_key, .big);
    try testing.expect(key_as_u256 > 0);
    try testing.expect(key_as_u256 < SECP256K1_N);
}
```

### public key derivation

```zig
test "public key derivation" {
    const private_key = try unaudited_randomPrivateKey();
    const public_key = try unaudited_getPublicKey(private_key);

    // Verify public key is valid
    try testing.expect(public_key.isValid());

    // Verify public key is not at infinity
    try testing.expect(public_key.x != 0 or public_key.y != 0);
}
```

### address derivation

```zig
test "address derivation" {
    const private_key = try unaudited_randomPrivateKey();
    const public_key = try unaudited_getPublicKey(private_key);
    const address = public_key.toAddress();

    // Verify address is not zero
    const zero_address = [_]u8{0} ** 20;
    try testing.expect(!std.mem.eql(u8, &address, &zero_address));
}
```

### message hashing

```zig
test "message hashing" {
    const message = "Hello, Ethereum!";
    const hash1 = hashMessage(message);
    const hash2 = hashMessage(message);

    // Verify deterministic hashing
    try testing.expect(std.mem.eql(u8, &hash1, &hash2));

    // Verify different messages produce different hashes
    const different_message = "Hello, World!";
    const hash3 = hashMessage(different_message);
    try testing.expect(!std.mem.eql(u8, &hash1, &hash3));
}
```

### signature creation and verification

```zig
test "signature creation and verification" {
    const private_key = try unaudited_randomPrivateKey();
    const message = "Test message for signing";

    // Sign the message
    const signature = try unaudited_signMessage(message, private_key);

    // Verify signature is valid
    try testing.expect(signature.isValid());

    // Recover address from signature
    const recovered_address = try unaudited_recoverMessageAddress(message, signature);

    // Verify recovered address matches expected
    const public_key = try unaudited_getPublicKey(private_key);
    const expected_address = public_key.toAddress();
    try testing.expect(std.mem.eql(u8, &recovered_address, &expected_address));

    // Verify signature verification
    try testing.expect(try unaudited_verifyMessage(message, signature, expected_address));
}
```

### signature roundtrip

```zig
test "signature roundtrip" {
    const private_key = try unaudited_randomPrivateKey();
    const message = "Roundtrip test message";

    // Sign message
    const signature = try unaudited_signMessage(message, private_key);

    // Verify signature components
    try testing.expect(signature.r > 0);
    try testing.expect(signature.s > 0);
    try testing.expect(signature.v == 27 or signature.v == 28);

    // Verify signature serialization
    const signature_bytes = signature.toBytes();
    const signature_restored = Signature.fromBytes(signature_bytes);
    try testing.expect(signature_restored.r == signature.r);
    try testing.expect(signature_restored.s == signature.s);
    try testing.expect(signature_restored.v == signature.v);

    // Verify message verification
    const expected_address = (try unaudited_getPublicKey(private_key)).toAddress();
    try testing.expect(try unaudited_verifyMessage(message, signature, expected_address));
}
```

### invalid signature rejection

```zig
test "invalid signature rejection" {
    const private_key = try unaudited_randomPrivateKey();
    const message = "Test message";
    const signature = try unaudited_signMessage(message, private_key);
    const expected_address = (try unaudited_getPublicKey(private_key)).toAddress();

    // Verify correct signature works
    try testing.expect(try unaudited_verifyMessage(message, signature, expected_address));

    // Test with modified message
    const wrong_message = "Wrong message";
    try testing.expect(!try unaudited_verifyMessage(wrong_message, signature, expected_address));

    // Test with wrong address
    const wrong_address = [_]u8{0xFF} ** 20;
    try testing.expect(!try unaudited_verifyMessage(message, signature, wrong_address));

    // Test with invalid signature
    var invalid_signature = signature;
    invalid_signature.r = 0; // Invalid r
    try testing.expect(!invalid_signature.isValid());
}
```

### create and verify signature

```zig
test "create and verify signature" {
    // Test private key
    const private_key = PrivateKey{
        0xac, 0x09, 0x74, 0xbe, 0xc3, 0x9a, 0x17, 0xe3,
        0x6b, 0xa4, 0xa6, 0xb4, 0xd2, 0x38, 0xff, 0x24,
        0x4e, 0x21, 0xdb, 0x63, 0x5c, 0x51, 0xcb, 0x29,
        0x36, 0x49, 0x5a, 0xf7, 0x42, 0x2f, 0xba, 0x41,
    };

    // Message to sign
    const message = "Hello, Ethereum!";
    const message_hash = Hash.keccak256(message);

    // Sign the message
    const signature = try unaudited_signHash(message_hash, private_key);

    // Verify signature components
    try testing.expectEqual(@as(usize, 32), @sizeOf(@TypeOf(signature.r)));
    try testing.expectEqual(@as(usize, 32), @sizeOf(@TypeOf(signature.s)));
    try testing.expect(signature.v == 27 or signature.v == 28);
}
```

### ecdsa recover public key

```zig
test "ecdsa recover public key" {
    // Known test vector
    const message_hash = Hash.keccak256("test message");

    const signature = Signature{
        .r = 0x1234567890123456789012345678901234567890123456789012345678901234,
        .s = 0x3456789012345678901234567890123456789012345678901234567890123456,
        .v = 27,
    };

    // Recovery should not fail for valid signature
    const result = unaudited_recoverAddress(message_hash, signature);
    _ = result catch |err| {
        // Expected to potentially fail with invalid test data
        try testing.expect(err == CryptoError.InvalidSignature or
            err == CryptoError.RecoveryFailed);
    };
}
```

### signature serialization

```zig
test "signature serialization" {
    const signature = Signature{
        .r = 0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa,
        .s = 0xbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb,
        .v = 28,
    };

    // Convert to bytes
    const bytes = signature.toBytes();
    try testing.expectEqual(@as(usize, 65), bytes.len);

    // First 32 bytes should be r
    var expected_r: [32]u8 = undefined;
    std.mem.writeInt(u256, &expected_r, signature.r, .big);
    try testing.expectEqualSlices(u8, &expected_r, bytes[0..32]);

    // Next 32 bytes should be s
    var expected_s: [32]u8 = undefined;
    std.mem.writeInt(u256, &expected_s, signature.s, .big);
    try testing.expectEqualSlices(u8, &expected_s, bytes[32..64]);

    // Last byte should be v
    try testing.expectEqual(@as(u8, 28), bytes[64]);

    // Convert back from bytes
    const recovered = Signature.fromBytes(bytes);
    try testing.expectEqual(signature.r, recovered.r);
    try testing.expectEqual(signature.s, recovered.s);
    try testing.expectEqual(signature.v, recovered.v);
}
```

### signature hex encoding

```zig
test "signature hex encoding" {
    const signature = Signature{
        .r = 0x123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0,
        .s = 0xfedcba9876543210fedcba9876543210fedcba9876543210fedcba9876543210,
        .v = 27,
    };

    // Convert to hex
    const hex_str = signature.toHex();

    // Should be 0x + 130 chars (65 bytes * 2)
    try testing.expectEqual(@as(usize, 132), hex_str.len);
    try testing.expect(std.mem.startsWith(u8, &hex_str, "0x"));

    // Convert back from hex
    const recovered = try Signature.fromHex(&hex_str);
    try testing.expectEqual(signature.r, recovered.r);
    try testing.expectEqual(signature.s, recovered.s);
    try testing.expectEqual(signature.v, recovered.v);
}
```

### generate private key

```zig
test "generate private key" {
    const key1 = try unaudited_randomPrivateKey();
    const key2 = try unaudited_randomPrivateKey();

    // Keys should be different
    try testing.expect(!std.mem.eql(u8, &key1, &key2));

    // Keys should be 32 bytes
    try testing.expectEqual(@as(usize, 32), key1.len);
    try testing.expectEqual(@as(usize, 32), key2.len);

    // Keys should not be zero
    const zero_key = [_]u8{0} ** 32;
    try testing.expect(!std.mem.eql(u8, &key1, &zero_key));
    try testing.expect(!std.mem.eql(u8, &key2, &zero_key));
}
```

### derive public key from private key

```zig
test "derive public key from private key" {
    // Test vector with known private/public key pair
    const private_key = PrivateKey{ 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };

    const public_key = try unaudited_getPublicKey(private_key);

    // Public key should be valid
    try testing.expect(public_key.isValid());

    // Public key should be deterministic
    const public_key2 = try unaudited_getPublicKey(private_key);
    try testing.expectEqual(public_key.x, public_key2.x);
    try testing.expectEqual(public_key.y, public_key2.y);
}
```

### derive address from private key

```zig
test "derive address from private key" {
    const private_key = PrivateKey{
        0xac, 0x09, 0x74, 0xbe, 0xc3, 0x9a, 0x17, 0xe3,
        0x6b, 0xa4, 0xa6, 0xb4, 0xd2, 0x38, 0xff, 0x24,
        0x4e, 0x21, 0xdb, 0x63, 0x5c, 0x51, 0xcb, 0x29,
        0x36, 0x49, 0x5a, 0xf7, 0x42, 0x2f, 0xba, 0x41,
    };

    const public_key = try unaudited_getPublicKey(private_key);
    const address = publicKeyToAddress(public_key);

    // Address should be 20 bytes
    try testing.expectEqual(@as(usize, 20), address.len);

    // Address should be deterministic
    const address2 = publicKeyToAddress(public_key);
    try testing.expectEqualSlices(u8, &address, &address2);
}
```

### personal sign message

```zig
test "personal sign message" {
    const private_key = PrivateKey{ 0x42, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };

    const message = "Hello, Ethereum!";

    // Sign with personal_sign prefix
    const signature = try unaudited_signMessage(message, private_key);

    // Verify signature format
    try testing.expectEqual(@as(usize, 32), @sizeOf(@TypeOf(signature.r)));
    try testing.expectEqual(@as(usize, 32), @sizeOf(@TypeOf(signature.s)));
    try testing.expect(signature.v == 27 or signature.v == 28);
}
```

### signature normalization

```zig
test "signature normalization" {
    // Signatures should have normalized S values (low S)
    // S should be <= n/2 where n is the curve order
    const signature = Signature{
        .r = 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff,
        .s = 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, // High S value
        .v = 27,
    };

    // This signature would be invalid due to high S
    try testing.expect(!signature.isValid());
}
```

### validate signature components

```zig
test "validate signature components" {
    // Valid signature
    const valid_sig = Signature{
        .r = 0x1234567890123456789012345678901234567890123456789012345678901234,
        .s = 0x3456789012345678901234567890123456789012345678901234567890123456,
        .v = 27,
    };
    try testing.expect(isValidSignature(valid_sig));

    // Invalid v value
    const invalid_v = Signature{
        .r = 0x1234567890123456789012345678901234567890123456789012345678901234,
        .s = 0x3456789012345678901234567890123456789012345678901234567890123456,
        .v = 26, // Should be 27 or 28
    };
    try testing.expect(!isValidSignature(invalid_v));

    // Zero r value (invalid)
    const zero_r = Signature{
        .r = 0,
        .s = 0x3456789012345678901234567890123456789012345678901234567890123456,
        .v = 27,
    };
    try testing.expect(!isValidSignature(zero_r));

    // Zero s value (invalid)
    const zero_s = Signature{
        .r = 0x1234567890123456789012345678901234567890123456789012345678901234,
        .s = 0,
        .v = 27,
    };
    try testing.expect(!isValidSignature(zero_s));
}
```

### RFC 6979 deterministic signature - test vector 1

```zig
test "RFC 6979 deterministic signature - test vector 1" {
    // Test vector from Bitcoin community implementations
    // Private key: 0x0000000000000000000000000000000000000000000000000000000000000001
    // Message: "Satoshi Nakamoto"
    // Expected k: 0x8F8A276C19F4149656B280621E358CCE24F5F52542772691EE69063B74F15D15
    // Expected r: 0x934b1ea10a4b3c1757e2b0c017d0b6143ce3c9a7e6a4a49860d7a6ab210ee3d8

    const private_key = PrivateKey{
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
    };

    const message = "Satoshi Nakamoto";
    const message_hash = Hash.keccak256(message);

    // Sign the message
    const signature = try unaudited_signHash(message_hash, private_key);

    // Verify signature is valid
    try testing.expect(signature.isValid());

    // Verify signature is deterministic - sign again and compare
    const signature2 = try unaudited_signHash(message_hash, private_key);
    try testing.expectEqual(signature.r, signature2.r);
    try testing.expectEqual(signature.s, signature2.s);

    // Verify we can recover the address
    const recovered_address = try unaudited_recoverAddress(message_hash, signature);
    const public_key = try unaudited_getPublicKey(private_key);
    const expected_address = public_key.toAddress();
    try testing.expect(std.mem.eql(u8, &recovered_address.bytes, &expected_address.bytes));
}
```

### RFC 6979 deterministic signature - test vector 2

```zig
test "RFC 6979 deterministic signature - test vector 2" {
    // Test with a different private key
    const private_key = PrivateKey{
        0xfe, 0xed, 0xbe, 0xef, 0xde, 0xad, 0xc0, 0xde,
        0xca, 0xfe, 0xba, 0xbe, 0x12, 0x34, 0x56, 0x78,
        0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34, 0x56, 0x78,
        0x9a, 0xbc, 0xde, 0xf0, 0x11, 0x22, 0x33, 0x44,
    };

    const message = "test message for RFC 6979";
    const message_hash = Hash.keccak256(message);

    // Sign the message twice
    const signature1 = try unaudited_signHash(message_hash, private_key);
    const signature2 = try unaudited_signHash(message_hash, private_key);

    // Signatures should be identical (deterministic)
    try testing.expectEqual(signature1.r, signature2.r);
    try testing.expectEqual(signature1.s, signature2.s);
    try testing.expectEqual(signature1.v, signature2.v);

    // Both signatures should verify correctly
    const public_key = try unaudited_getPublicKey(private_key);
    const expected_address = public_key.toAddress();

    const recovered_address1 = try unaudited_recoverAddress(message_hash, signature1);
    const recovered_address2 = try unaudited_recoverAddress(message_hash, signature2);

    try testing.expect(std.mem.eql(u8, &recovered_address1.bytes, &expected_address.bytes));
    try testing.expect(std.mem.eql(u8, &recovered_address2.bytes, &expected_address.bytes));
}
```

### RFC 6979 deterministic signature - different messages produce different signatures

```zig
test "RFC 6979 deterministic signature - different messages produce different signatures" {
    // Same private key but different messages should produce different signatures
    const private_key = PrivateKey{
        0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42,
        0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42,
        0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42,
        0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42,
    };

    const message1 = "message one";
    const message2 = "message two";

    const hash1 = Hash.keccak256(message1);
    const hash2 = Hash.keccak256(message2);

    const sig1 = try unaudited_signHash(hash1, private_key);
    const sig2 = try unaudited_signHash(hash2, private_key);

    // Signatures should be different
    try testing.expect(sig1.r != sig2.r or sig1.s != sig2.s);

    // But both should be valid and deterministic
    const sig1_repeat = try unaudited_signHash(hash1, private_key);
    const sig2_repeat = try unaudited_signHash(hash2, private_key);

    try testing.expectEqual(sig1.r, sig1_repeat.r);
    try testing.expectEqual(sig1.s, sig1_repeat.s);
    try testing.expectEqual(sig2.r, sig2_repeat.r);
    try testing.expectEqual(sig2.s, sig2_repeat.s);
}
```

### RFC 6979 deterministic signature - empty message

```zig
test "RFC 6979 deterministic signature - empty message" {
    // Test with empty message (edge case)
    const private_key = PrivateKey{
        0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
        0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
        0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
        0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
    };

    const empty_message = "";
    const hash = Hash.keccak256(empty_message);

    // Sign empty message
    const sig1 = try unaudited_signHash(hash, private_key);
    const sig2 = try unaudited_signHash(hash, private_key);

    // Should be deterministic
    try testing.expectEqual(sig1.r, sig2.r);
    try testing.expectEqual(sig1.s, sig2.s);

    // Should be valid
    try testing.expect(sig1.isValid());

    // Should recover correct address
    const public_key = try unaudited_getPublicKey(private_key);
    const expected_address = public_key.toAddress();
    const recovered = try unaudited_recoverAddress(hash, sig1);
    try testing.expect(std.mem.eql(u8, &recovered.bytes, &expected_address.bytes));
}
```

### RFC 6979 deterministic signature - long message

```zig
test "RFC 6979 deterministic signature - long message" {
    // Test with a long message
    const private_key = PrivateKey{
        0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55,
        0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55,
        0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55,
        0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55,
    };

    const long_message = "The Times 03/Jan/2009 Chancellor on brink of second bailout for banks. " ++
        "This is a longer message to test RFC 6979 with various message lengths. " ++
        "Deterministic signatures ensure no nonce reuse vulnerabilities.";

    const hash = Hash.keccak256(long_message);

    // Sign multiple times
    const sig1 = try unaudited_signHash(hash, private_key);
    const sig2 = try unaudited_signHash(hash, private_key);
    const sig3 = try unaudited_signHash(hash, private_key);

    // All signatures should be identical
    try testing.expectEqual(sig1.r, sig2.r);
    try testing.expectEqual(sig1.s, sig2.s);
    try testing.expectEqual(sig1.v, sig2.v);
    try testing.expectEqual(sig2.r, sig3.r);
    try testing.expectEqual(sig2.s, sig3.s);
    try testing.expectEqual(sig2.v, sig3.v);

    // Should verify correctly
    const public_key = try unaudited_getPublicKey(private_key);
    const expected_address = public_key.toAddress();
    const recovered = try unaudited_recoverAddress(hash, sig1);
    try testing.expect(std.mem.eql(u8, &recovered.bytes, &expected_address.bytes));
}
```
