---
title: '[Swift] swift/Tests/VoltaireTests/AddressAdvancedTests.swift'
source: 'swift/Tests/VoltaireTests/AddressAdvancedTests.swift'
---

> Auto-generated from Swift test file: swift/Tests/VoltaireTests/AddressAdvancedTests.swift

```swift
import XCTest
@testable import Voltaire

final class AddressAdvancedTests: XCTestCase {
    func testValidationAndFormatting() throws {
        XCTAssertTrue(Address.isValid("0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045"))
        XCTAssertTrue(Address.isValid("d8dA6BF26964aF9D7eEd9e03E53415D37aA96045"))
        XCTAssertFalse(Address.isValid("0xzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz"))
        XCTAssertFalse(Address.isValid("0x1234"))

        let addr = try Address(hex: "0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045")
        XCTAssertEqual(addr.lowercaseHex, addr.hex)
        XCTAssertEqual(addr.uppercaseHex, addr.hex.uppercased())

        let short = addr.shortHex
        XCTAssertTrue(short.hasPrefix(String(addr.hex.prefix(8))))
        XCTAssertTrue(short.hasSuffix(String(addr.hex.suffix(3))))
        XCTAssertEqual(short.count, 14)
    }

    func testAbiEncodingRoundTrip() throws {
        let addr = try Address(hex: "0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045")
        let abi = addr.abiEncoded
        XCTAssertEqual(abi.count, 32)
        XCTAssertEqual(Array(abi.prefix(12)), [UInt8](repeating: 0, count: 12))
        XCTAssertEqual(Array(abi.suffix(20)), addr.bytes)

        let decoded = try Address.fromAbiEncoded(abi)
        XCTAssertEqual(decoded, addr)
    }

    func testU256Conversions() throws {
        let addr = try Address(hex: "0x0000000000000000000000000000000000000001")
        let v = addr.asU256
        let round = Address.from(u256: v)
        XCTAssertEqual(round, addr)
    }

    func testBase64RoundTripAndErrors() throws {
        let addr = try Address(hex: "0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045")
        let b64 = Data(addr.bytes).base64EncodedString()
        let dec = try Address.fromBase64(b64)
        XCTAssertEqual(dec, addr)

        XCTAssertThrowsError(try Address.fromBase64("?!")) { error in
            XCTAssertTrue(error is VoltaireError)
        }

        // Wrong length (not 20 bytes)
        let wrong = Data([0x01, 0x02, 0x03]).base64EncodedString()
        XCTAssertThrowsError(try Address.fromBase64(wrong)) { error in
            XCTAssertTrue(error is VoltaireError)
        }
    }

    func testComparableAndSorting() throws {
        let a = try Address(hex: "0x0000000000000000000000000000000000000001")
        let b = try Address(hex: "0x0000000000000000000000000000000000000002")
        XCTAssertTrue(a < b)
        let sorted = try [b, a].sorted()
        XCTAssertEqual(sorted, [a, b])
    }

    func testCreateKnownVector() throws {
        // From Zig tests
        let sender = try Address(hex: "0xa0cf798816d4b9b9866b5330eea46a18382f251e")
        // Expected computed via underlying primitives (CREATE address)
        let expected = try Address(hex: "0xfA0D70e1D133B2F6CF2777547e8b12810d31B69a")
        let out = try Address.calculateCreate(sender: sender, nonce: 0)
        XCTAssertEqual(out, expected)

        // Deterministic for same inputs
        let out2 = try Address.calculateCreate(sender: sender, nonce: 0)
        XCTAssertEqual(out2, out)

        // Different for different nonce
        let out3 = try Address.calculateCreate(sender: sender, nonce: 1)
        XCTAssertNotEqual(out3, out)
    }

    func testCreate2AgainstManualComputation() throws {
        let sender = try Address(hex: "0x0000000000000000000000000000000000000000")
        let salt = try Bytes32(hex: "0x" + String(repeating: "00", count: 32))
        let initCode: [UInt8] = []

        // Library result
        let libAddr = try Address.calculateCreate2(sender: sender, salt: salt, initCode: initCode)

        // Manual EIP-1014: keccak256(0xff ++ sender ++ salt ++ keccak256(initCode))[12:]
        let initHash = Keccak256.hash(initCode)
        var data = [UInt8]()
        data.append(0xff)
        data.append(contentsOf: sender.bytes)
        data.append(contentsOf: salt.bytes)
        data.append(contentsOf: initHash.bytes)
        let finalHash = Keccak256.hash(data)
        let expected = try Address(bytes: Array(finalHash.bytes.suffix(20)))

        XCTAssertEqual(libAddr, expected)

        // Different salt produces different address
        var salt2Bytes = salt.bytes
        salt2Bytes[31] = 0x01
        let salt2 = try Bytes32(bytes: salt2Bytes)
        let addr2 = try Address.calculateCreate2(sender: sender, salt: salt2, initCode: initCode)
        XCTAssertNotEqual(addr2, libAddr)
    }
}

```
