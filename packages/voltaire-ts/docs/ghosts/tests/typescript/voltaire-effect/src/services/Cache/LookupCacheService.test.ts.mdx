---
title: '[TS/JS] voltaire-effect/src/services/Cache/LookupCacheService.test.ts'
source: 'voltaire-effect/src/services/Cache/LookupCacheService.test.ts'
---

> Auto-generated from test file: voltaire-effect/src/services/Cache/LookupCacheService.test.ts

```typescript
import { describe, expect, it } from "@effect/vitest";
import * as Duration from "effect/Duration";
import * as Effect from "effect/Effect";
import * as Option from "effect/Option";
import * as Ref from "effect/Ref";
import * as TestClock from "effect/TestClock";
import { LookupCacheService, makeLookupCache } from "./LookupCacheService.js";

const StringCache = LookupCacheService<string, string, never>();

describe("LookupCacheService", () => {
	describe("basic operations", () => {
		it.effect("computes value on cache miss", () =>
			Effect.gen(function* () {
				const callCount = yield* Ref.make(0);

				const layer = makeLookupCache(StringCache, {
					capacity: 100,
					timeToLive: Duration.minutes(5),
					lookup: (key) =>
						Effect.gen(function* () {
							yield* Ref.update(callCount, (n) => n + 1);
							return `value-for-${key}`;
						}),
				});

				const result = yield* Effect.gen(function* () {
					const cache = yield* StringCache;
					return yield* cache.get("key1");
				}).pipe(Effect.provide(layer));

				const count = yield* Ref.get(callCount);

				expect(result).toBe("value-for-key1");
				expect(count).toBe(1);
			}),
		);

		it.effect("returns cached value on subsequent calls", () =>
			Effect.gen(function* () {
				const callCount = yield* Ref.make(0);

				const layer = makeLookupCache(StringCache, {
					capacity: 100,
					timeToLive: Duration.minutes(5),
					lookup: (key) =>
						Effect.gen(function* () {
							yield* Ref.update(callCount, (n) => n + 1);
							return `value-for-${key}`;
						}),
				});

				const program = Effect.gen(function* () {
					const cache = yield* StringCache;
					const r1 = yield* cache.get("key1");
					const r2 = yield* cache.get("key1");
					return [r1, r2] as const;
				}).pipe(Effect.provide(layer));

				const [r1, r2] = yield* program;
				const count = yield* Ref.get(callCount);

				expect(r1).toBe("value-for-key1");
				expect(r2).toBe("value-for-key1");
				expect(count).toBe(1);
			}),
		);

		it.effect("getOption returns none for uncached key", () =>
			Effect.gen(function* () {
				const layer = makeLookupCache(StringCache, {
					capacity: 100,
					timeToLive: Duration.minutes(5),
					lookup: (key) => Effect.succeed(`value-for-${key}`),
				});

				const result = yield* Effect.gen(function* () {
					const cache = yield* StringCache;
					return yield* cache.getOption("key1");
				}).pipe(Effect.provide(layer));

				expect(Option.isNone(result)).toBe(true);
			}),
		);

		it.effect("getOption returns some for cached key", () =>
			Effect.gen(function* () {
				const layer = makeLookupCache(StringCache, {
					capacity: 100,
					timeToLive: Duration.minutes(5),
					lookup: (key) => Effect.succeed(`value-for-${key}`),
				});

				const result = yield* Effect.gen(function* () {
					const cache = yield* StringCache;
					yield* cache.get("key1");
					return yield* cache.getOption("key1");
				}).pipe(Effect.provide(layer));

				expect(Option.isSome(result)).toBe(true);
				expect(Option.getOrThrow(result)).toBe("value-for-key1");
			}),
		);

		it.effect("set manually stores a value", () =>
			Effect.gen(function* () {
				const callCount = yield* Ref.make(0);

				const layer = makeLookupCache(StringCache, {
					capacity: 100,
					timeToLive: Duration.minutes(5),
					lookup: (key) =>
						Effect.gen(function* () {
							yield* Ref.update(callCount, (n) => n + 1);
							return `computed-${key}`;
						}),
				});

				const result = yield* Effect.gen(function* () {
					const cache = yield* StringCache;
					yield* cache.set("key1", "manual-value");
					return yield* cache.get("key1");
				}).pipe(Effect.provide(layer));

				const count = yield* Ref.get(callCount);

				expect(result).toBe("manual-value");
				expect(count).toBe(0);
			}),
		);
	});

	describe("invalidation", () => {
		it.effect("invalidate removes a key", () =>
			Effect.gen(function* () {
				const callCount = yield* Ref.make(0);

				const layer = makeLookupCache(StringCache, {
					capacity: 100,
					timeToLive: Duration.minutes(5),
					lookup: (_key) =>
						Effect.gen(function* () {
							yield* Ref.update(callCount, (n) => n + 1);
							return `value-${yield* Ref.get(callCount)}`;
						}),
				});

				const program = Effect.gen(function* () {
					const cache = yield* StringCache;
					const r1 = yield* cache.get("key1");
					yield* cache.invalidate("key1");
					const r2 = yield* cache.get("key1");
					return [r1, r2] as const;
				}).pipe(Effect.provide(layer));

				const [r1, r2] = yield* program;
				const count = yield* Ref.get(callCount);

				expect(r1).toBe("value-1");
				expect(r2).toBe("value-2");
				expect(count).toBe(2);
			}),
		);

		it.effect("invalidateAll clears all keys", () =>
			Effect.gen(function* () {
				const callCount = yield* Ref.make(0);

				const layer = makeLookupCache(StringCache, {
					capacity: 100,
					timeToLive: Duration.minutes(5),
					lookup: () =>
						Effect.gen(function* () {
							yield* Ref.update(callCount, (n) => n + 1);
							return `value-${yield* Ref.get(callCount)}`;
						}),
				});

				const program = Effect.gen(function* () {
					const cache = yield* StringCache;
					yield* cache.get("key1");
					yield* cache.get("key2");
					yield* cache.invalidateAll;
					const r1 = yield* cache.get("key1");
					const r2 = yield* cache.get("key2");
					return [r1, r2] as const;
				}).pipe(Effect.provide(layer));

				const [r1, r2] = yield* program;
				const count = yield* Ref.get(callCount);

				expect(r1).toBe("value-3");
				expect(r2).toBe("value-4");
				expect(count).toBe(4);
			}),
		);
	});

	describe("refresh", () => {
		it.effect("refresh recomputes value", () =>
			Effect.gen(function* () {
				const callCount = yield* Ref.make(0);

				const layer = makeLookupCache(StringCache, {
					capacity: 100,
					timeToLive: Duration.minutes(5),
					lookup: () =>
						Effect.gen(function* () {
							yield* Ref.update(callCount, (n) => n + 1);
							return `value-${yield* Ref.get(callCount)}`;
						}),
				});

				const program = Effect.gen(function* () {
					const cache = yield* StringCache;
					const r1 = yield* cache.get("key1");
					yield* cache.refresh("key1");
					const r2 = yield* cache.get("key1");
					return [r1, r2] as const;
				}).pipe(Effect.provide(layer));

				const [r1, r2] = yield* program;

				expect(r1).toBe("value-1");
				expect(r2).toBe("value-2");
			}),
		);
	});

	describe("stats", () => {
		it.effect("returns cache statistics", () =>
			Effect.gen(function* () {
				const layer = makeLookupCache(StringCache, {
					capacity: 100,
					timeToLive: Duration.minutes(5),
					lookup: (key) => Effect.succeed(`value-for-${key}`),
				});

				const stats = yield* Effect.gen(function* () {
					const cache = yield* StringCache;
					yield* cache.get("key1");
					yield* cache.get("key1");
					yield* cache.get("key2");
					return yield* cache.stats;
				}).pipe(Effect.provide(layer));

				expect(stats.size).toBe(2);
				expect(stats.hits).toBeGreaterThanOrEqual(1);
			}),
		);

		it.effect("returns cache size", () =>
			Effect.gen(function* () {
				const layer = makeLookupCache(StringCache, {
					capacity: 100,
					timeToLive: Duration.minutes(5),
					lookup: (key) => Effect.succeed(`value-for-${key}`),
				});

				const size = yield* Effect.gen(function* () {
					const cache = yield* StringCache;
					yield* cache.get("key1");
					yield* cache.get("key2");
					yield* cache.get("key3");
					return yield* cache.size;
				}).pipe(Effect.provide(layer));

				expect(size).toBe(3);
			}),
		);
	});

	describe("TTL expiration", () => {
		it.effect("expires entries after TTL", () =>
			Effect.gen(function* () {
				const callCount = yield* Ref.make(0);

				const layer = makeLookupCache(StringCache, {
					capacity: 100,
					timeToLive: Duration.seconds(1),
					lookup: () =>
						Effect.gen(function* () {
							yield* Ref.update(callCount, (n) => n + 1);
							return `value-${yield* Ref.get(callCount)}`;
						}),
				});

				const program = Effect.gen(function* () {
					const cache = yield* StringCache;
					const r1 = yield* cache.get("key1");
					yield* TestClock.adjust(Duration.seconds(2));
					const r2 = yield* cache.get("key1");
					return [r1, r2] as const;
				}).pipe(Effect.provide(layer));

				const [r1, r2] = yield* program;
				const count = yield* Ref.get(callCount);

				expect(r1).toBe("value-1");
				expect(r2).toBe("value-2");
				expect(count).toBe(2);
			}),
		);
	});
});

```
