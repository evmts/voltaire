---
title: '[TS/JS] voltaire-effect/src/primitives/LogFilter/LogFilter.test.ts'
source: 'voltaire-effect/src/primitives/LogFilter/LogFilter.test.ts'
---

> Auto-generated from test file: voltaire-effect/src/primitives/LogFilter/LogFilter.test.ts

```typescript
import { describe, expect, it } from "@effect/vitest";
import * as Schema from "effect/Schema";
import * as LogFilter from "./index.js";

describe("LogFilter.Rpc", () => {
	it("validates filter with block range", () => {
		const input = {
			fromBlock: 1000000n,
			toBlock: 1000100n,
		};
		const result = Schema.decodeSync(LogFilter.Rpc)(input);
		expect(result.fromBlock).toBe(1000000n);
		expect(result.toBlock).toBe(1000100n);
	});

	it("validates filter with block tags", () => {
		const input = {
			fromBlock: "latest" as const,
		};
		const result = Schema.decodeSync(LogFilter.Rpc)(input);
		expect(result.fromBlock).toBe("latest");
	});

	it("validates filter with address", () => {
		const input = {
			address: "0x1234567890123456789012345678901234567890",
		};
		const result = Schema.decodeSync(LogFilter.Rpc)(input);
		expect(result.address).toBeInstanceOf(Uint8Array);
	});

	it("allows blockhash alone", () => {
		const input = {
			blockhash: `0x${"ab".repeat(32)}`,
		};
		const result = Schema.decodeSync(LogFilter.Rpc)(input);
		expect(result.blockhash).toBeInstanceOf(Uint8Array);
	});

	it("allows fromBlock/toBlock without blockhash", () => {
		const input = {
			fromBlock: 100n,
			toBlock: 200n,
		};
		const result = Schema.decodeSync(LogFilter.Rpc)(input);
		expect(result.fromBlock).toBe(100n);
		expect(result.toBlock).toBe(200n);
		expect(result.blockhash).toBeUndefined();
	});

	it("rejects blockhash with fromBlock", () => {
		const input = {
			blockhash: `0x${"ab".repeat(32)}`,
			fromBlock: 1n,
		};
		expect(() => Schema.decodeSync(LogFilter.Rpc)(input)).toThrow(
			"blockhash is mutually exclusive with fromBlock/toBlock",
		);
	});

	it("rejects blockhash with toBlock", () => {
		const input = {
			blockhash: `0x${"ab".repeat(32)}`,
			toBlock: 100n,
		};
		expect(() => Schema.decodeSync(LogFilter.Rpc)(input)).toThrow(
			"blockhash is mutually exclusive with fromBlock/toBlock",
		);
	});

	it("rejects blockhash with both fromBlock and toBlock", () => {
		const input = {
			blockhash: `0x${"ab".repeat(32)}`,
			fromBlock: 1n,
			toBlock: 100n,
		};
		expect(() => Schema.decodeSync(LogFilter.Rpc)(input)).toThrow(
			"blockhash is mutually exclusive with fromBlock/toBlock",
		);
	});
});

```
