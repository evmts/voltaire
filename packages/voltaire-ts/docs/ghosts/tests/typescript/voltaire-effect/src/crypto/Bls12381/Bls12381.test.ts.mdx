---
title: '[TS/JS] voltaire-effect/src/crypto/Bls12381/Bls12381.test.ts'
source: 'voltaire-effect/src/crypto/Bls12381/Bls12381.test.ts'
---

> Auto-generated from test file: voltaire-effect/src/crypto/Bls12381/Bls12381.test.ts

```typescript
import { describe, expect, it } from "@effect/vitest";
import * as VoltaireBls12381 from "@tevm/voltaire/Bls12381";
import * as Effect from "effect/Effect";
import * as Exit from "effect/Exit";
import * as Bls12381Effect from "./index.js";

describe("Bls12381", () => {
	const testPrivateKey = VoltaireBls12381.randomPrivateKey();
	const testPublicKey = VoltaireBls12381.derivePublicKey(testPrivateKey);
	const testMessage = new TextEncoder().encode("Hello, Ethereum!");

	describe("sign", () => {
		it.effect("signs a message with a private key", () =>
			Effect.gen(function* () {
				const result = yield* Bls12381Effect.sign(testMessage, testPrivateKey);
				expect(result).toBeInstanceOf(Uint8Array);
				expect(result.length).toBe(48);
			}),
		);

		it.effect("produces deterministic signatures", () =>
			Effect.gen(function* () {
				const sig1 = yield* Bls12381Effect.sign(testMessage, testPrivateKey);
				const sig2 = yield* Bls12381Effect.sign(testMessage, testPrivateKey);
				expect(sig1).toEqual(sig2);
			}),
		);

		it("fails with zero private key", async () => {
			const zeroKey = new Uint8Array(32);
			const exit = await Effect.runPromiseExit(
				Bls12381Effect.sign(testMessage, zeroKey),
			);
			expect(Exit.isFailure(exit)).toBe(true);
		});

		it("fails with wrong key length (16 bytes)", async () => {
			const shortKey = new Uint8Array(16);
			const exit = await Effect.runPromiseExit(
				Bls12381Effect.sign(testMessage, shortKey),
			);
			expect(Exit.isFailure(exit)).toBe(true);
		});

		it("fails with wrong key length (64 bytes)", async () => {
			const longKey = new Uint8Array(64).fill(0x42);
			const exit = await Effect.runPromiseExit(
				Bls12381Effect.sign(testMessage, longKey),
			);
			expect(Exit.isFailure(exit)).toBe(true);
		});

		it("fails with empty key", async () => {
			const emptyKey = new Uint8Array(0);
			const exit = await Effect.runPromiseExit(
				Bls12381Effect.sign(testMessage, emptyKey),
			);
			expect(Exit.isFailure(exit)).toBe(true);
		});

		it.effect("signs empty message", () =>
			Effect.gen(function* () {
				const emptyMessage = new Uint8Array(0);
				const result = yield* Bls12381Effect.sign(emptyMessage, testPrivateKey);
				expect(result).toBeInstanceOf(Uint8Array);
				expect(result.length).toBe(48);
			}),
		);

		it.effect("signs large message", () =>
			Effect.gen(function* () {
				const largeMessage = new Uint8Array(10000).fill(0xab);
				const result = yield* Bls12381Effect.sign(largeMessage, testPrivateKey);
				expect(result).toBeInstanceOf(Uint8Array);
				expect(result.length).toBe(48);
			}),
		);

		it.effect("produces different signatures for different messages", () =>
			Effect.gen(function* () {
				const msg1 = new TextEncoder().encode("Message 1");
				const msg2 = new TextEncoder().encode("Message 2");
				const sig1 = yield* Bls12381Effect.sign(msg1, testPrivateKey);
				const sig2 = yield* Bls12381Effect.sign(msg2, testPrivateKey);
				expect(sig1).not.toEqual(sig2);
			}),
		);

		it.effect("produces different signatures for different keys", () =>
			Effect.gen(function* () {
				const key1 = VoltaireBls12381.randomPrivateKey();
				const key2 = VoltaireBls12381.randomPrivateKey();
				const sig1 = yield* Bls12381Effect.sign(testMessage, key1);
				const sig2 = yield* Bls12381Effect.sign(testMessage, key2);
				expect(sig1).not.toEqual(sig2);
			}),
		);

		it.effect("handles minimum valid private key", () =>
			Effect.gen(function* () {
				const minKey = new Uint8Array(32);
				minKey[31] = 1;
				const result = yield* Bls12381Effect.sign(testMessage, minKey);
				expect(result).toBeInstanceOf(Uint8Array);
				expect(result.length).toBe(48);
			}),
		);
	});

	describe("verify", () => {
		it.effect("verifies a valid signature", () =>
			Effect.gen(function* () {
				const signature = yield* Bls12381Effect.sign(
					testMessage,
					testPrivateKey,
				);
				const isValid = yield* Bls12381Effect.verify(
					signature,
					testMessage,
					testPublicKey,
				);
				expect(isValid).toBe(true);
			}),
		);

		it.effect("returns false for wrong message", () =>
			Effect.gen(function* () {
				const signature = yield* Bls12381Effect.sign(
					testMessage,
					testPrivateKey,
				);
				const wrongMessage = new TextEncoder().encode("Wrong message");
				const isValid = yield* Bls12381Effect.verify(
					signature,
					wrongMessage,
					testPublicKey,
				);
				expect(isValid).toBe(false);
			}),
		);

		it.effect("returns false for wrong public key", () =>
			Effect.gen(function* () {
				const signature = yield* Bls12381Effect.sign(
					testMessage,
					testPrivateKey,
				);
				const otherPrivateKey = VoltaireBls12381.randomPrivateKey();
				const wrongPublicKey =
					VoltaireBls12381.derivePublicKey(otherPrivateKey);
				const isValid = yield* Bls12381Effect.verify(
					signature,
					testMessage,
					wrongPublicKey,
				);
				expect(isValid).toBe(false);
			}),
		);

		it.effect("returns false for tampered signature", () =>
			Effect.gen(function* () {
				const signature = yield* Bls12381Effect.sign(
					testMessage,
					testPrivateKey,
				);
				const tamperedSig = new Uint8Array(signature);
				tamperedSig[0] ^= 0xff;
				const isValid = yield* Bls12381Effect.verify(
					tamperedSig,
					testMessage,
					testPublicKey,
				);
				expect(isValid).toBe(false);
			}),
		);

		it("returns false for zero signature", async () => {
			const zeroSig = new Uint8Array(48);
			const exit = await Effect.runPromiseExit(
				Bls12381Effect.verify(zeroSig, testMessage, testPublicKey),
			);
			if (Exit.isSuccess(exit)) {
				expect(exit.value).toBe(false);
			}
		});

		it.effect("verifies empty message signature", () =>
			Effect.gen(function* () {
				const emptyMessage = new Uint8Array(0);
				const signature = yield* Bls12381Effect.sign(
					emptyMessage,
					testPrivateKey,
				);
				const isValid = yield* Bls12381Effect.verify(
					signature,
					emptyMessage,
					testPublicKey,
				);
				expect(isValid).toBe(true);
			}),
		);

		it.effect("verifies large message signature", () =>
			Effect.gen(function* () {
				const largeMessage = new Uint8Array(10000).fill(0xab);
				const signature = yield* Bls12381Effect.sign(
					largeMessage,
					testPrivateKey,
				);
				const isValid = yield* Bls12381Effect.verify(
					signature,
					largeMessage,
					testPublicKey,
				);
				expect(isValid).toBe(true);
			}),
		);

		it.effect("verifies signatures from multiple different keys", () =>
			Effect.gen(function* () {
				for (let i = 0; i < 3; i++) {
					const privateKey = VoltaireBls12381.randomPrivateKey();
					const publicKey = VoltaireBls12381.derivePublicKey(privateKey);
					const message = new TextEncoder().encode(`Message ${i}`);
					const sig = yield* Bls12381Effect.sign(message, privateKey);
					const isValid = yield* Bls12381Effect.verify(sig, message, publicKey);
					expect(isValid).toBe(true);
				}
			}),
		);
	});

	describe("aggregate", () => {
		it.effect("aggregates multiple signatures", () =>
			Effect.gen(function* () {
				const pk1 = VoltaireBls12381.randomPrivateKey();
				const pk2 = VoltaireBls12381.randomPrivateKey();
				const sig1 = yield* Bls12381Effect.sign(testMessage, pk1);
				const sig2 = yield* Bls12381Effect.sign(testMessage, pk2);
				const aggSig = yield* Bls12381Effect.aggregate([sig1, sig2]);
				expect(aggSig).toBeInstanceOf(Uint8Array);
				expect(aggSig.length).toBe(48);
			}),
		);

		it.effect(
			"single signature aggregation returns same signature format",
			() =>
				Effect.gen(function* () {
					const signature = yield* Bls12381Effect.sign(
						testMessage,
						testPrivateKey,
					);
					const aggSig = yield* Bls12381Effect.aggregate([signature]);
					expect(aggSig).toBeInstanceOf(Uint8Array);
					expect(aggSig.length).toBe(48);
				}),
		);

		it("fails with empty array", async () => {
			const exit = await Effect.runPromiseExit(Bls12381Effect.aggregate([]));
			expect(Exit.isFailure(exit)).toBe(true);
		});

		it.effect("aggregates three signatures", () =>
			Effect.gen(function* () {
				const pk1 = VoltaireBls12381.randomPrivateKey();
				const pk2 = VoltaireBls12381.randomPrivateKey();
				const pk3 = VoltaireBls12381.randomPrivateKey();
				const sig1 = yield* Bls12381Effect.sign(testMessage, pk1);
				const sig2 = yield* Bls12381Effect.sign(testMessage, pk2);
				const sig3 = yield* Bls12381Effect.sign(testMessage, pk3);
				const aggSig = yield* Bls12381Effect.aggregate([sig1, sig2, sig3]);
				expect(aggSig).toBeInstanceOf(Uint8Array);
				expect(aggSig.length).toBe(48);
			}),
		);
	});

	describe("Full Round Trip", () => {
		it.effect("sign-verify round trip", () =>
			Effect.gen(function* () {
				const privateKey = VoltaireBls12381.randomPrivateKey();
				const publicKey = VoltaireBls12381.derivePublicKey(privateKey);
				const message = new TextEncoder().encode("Round trip test");
				const signature = yield* Bls12381Effect.sign(message, privateKey);
				const isValid = yield* Bls12381Effect.verify(
					signature,
					message,
					publicKey,
				);
				expect(isValid).toBe(true);
			}),
		);

		it.effect("sign-aggregate-verify pattern", () =>
			Effect.gen(function* () {
				const pk1 = VoltaireBls12381.randomPrivateKey();
				const pubKey1 = VoltaireBls12381.derivePublicKey(pk1);
				const sig1 = yield* Bls12381Effect.sign(testMessage, pk1);
				const aggSig = yield* Bls12381Effect.aggregate([sig1]);
				const isValid = yield* Bls12381Effect.verify(
					aggSig,
					testMessage,
					pubKey1,
				);
				expect(isValid).toBe(true);
			}),
		);
	});

	describe("Bls12381Service", () => {
		it.effect("provides sign through service layer", () =>
			Effect.gen(function* () {
				const bls = yield* Bls12381Effect.Bls12381Service;
				const result = yield* bls.sign(testMessage, testPrivateKey);
				expect(result).toBeInstanceOf(Uint8Array);
				expect(result.length).toBe(48);
			}).pipe(Effect.provide(Bls12381Effect.Bls12381Live)),
		);

		it.effect("provides verify through service layer", () =>
			Effect.gen(function* () {
				const signature = yield* Bls12381Effect.sign(
					testMessage,
					testPrivateKey,
				);
				const bls = yield* Bls12381Effect.Bls12381Service;
				const result = yield* bls.verify(signature, testMessage, testPublicKey);
				expect(result).toBe(true);
			}).pipe(Effect.provide(Bls12381Effect.Bls12381Live)),
		);

		it.effect("provides aggregate through service layer", () =>
			Effect.gen(function* () {
				const pk1 = VoltaireBls12381.randomPrivateKey();
				const sig1 = yield* Bls12381Effect.sign(testMessage, pk1);
				const sig2 = yield* Bls12381Effect.sign(testMessage, testPrivateKey);
				const bls = yield* Bls12381Effect.Bls12381Service;
				const result = yield* bls.aggregate([sig1, sig2]);
				expect(result).toBeInstanceOf(Uint8Array);
			}).pipe(Effect.provide(Bls12381Effect.Bls12381Live)),
		);

		it.effect("sign-verify through service layer", () =>
			Effect.gen(function* () {
				const bls = yield* Bls12381Effect.Bls12381Service;
				const sig = yield* bls.sign(testMessage, testPrivateKey);
				const result = yield* bls.verify(sig, testMessage, testPublicKey);
				expect(result).toBe(true);
			}).pipe(Effect.provide(Bls12381Effect.Bls12381Live)),
		);

		it("handles error in service layer", async () => {
			const zeroKey = new Uint8Array(32);
			const program = Effect.gen(function* () {
				const bls = yield* Bls12381Effect.Bls12381Service;
				return yield* bls.sign(testMessage, zeroKey);
			});
			const exit = await Effect.runPromiseExit(
				program.pipe(Effect.provide(Bls12381Effect.Bls12381Live)),
			);
			expect(Exit.isFailure(exit)).toBe(true);
		});

		it("handles aggregate error in service layer", async () => {
			const program = Effect.gen(function* () {
				const bls = yield* Bls12381Effect.Bls12381Service;
				return yield* bls.aggregate([]);
			});
			const exit = await Effect.runPromiseExit(
				program.pipe(Effect.provide(Bls12381Effect.Bls12381Live)),
			);
			expect(Exit.isFailure(exit)).toBe(true);
		});
	});

	describe("Edge Cases", () => {
		it.effect("signature is always 48 bytes", () =>
			Effect.gen(function* () {
				for (let i = 0; i < 5; i++) {
					const privateKey = VoltaireBls12381.randomPrivateKey();
					const message = new TextEncoder().encode(`Message ${i}`);
					const sig = yield* Bls12381Effect.sign(message, privateKey);
					expect(sig.length).toBe(48);
				}
			}),
		);

		it("public key derivation is deterministic", () => {
			const privateKey = VoltaireBls12381.randomPrivateKey();
			const pubKey1 = VoltaireBls12381.derivePublicKey(privateKey);
			const pubKey2 = VoltaireBls12381.derivePublicKey(privateKey);
			expect(pubKey1).toEqual(pubKey2);
		});

		it("different private keys produce different public keys", () => {
			const key1 = VoltaireBls12381.randomPrivateKey();
			const key2 = VoltaireBls12381.randomPrivateKey();
			const pubKey1 = VoltaireBls12381.derivePublicKey(key1);
			const pubKey2 = VoltaireBls12381.derivePublicKey(key2);
			expect(pubKey1).not.toEqual(pubKey2);
		});

		it("public key is 48 bytes (compressed G1 point)", () => {
			const privateKey = VoltaireBls12381.randomPrivateKey();
			const publicKey = VoltaireBls12381.derivePublicKey(privateKey);
			expect(publicKey.length).toBe(48);
		});

		it("random private key is 32 bytes", () => {
			const privateKey = VoltaireBls12381.randomPrivateKey();
			expect(privateKey.length).toBe(32);
		});
	});

	describe("Known Vectors", () => {
		it.effect("produces consistent signatures for same inputs", () =>
			Effect.gen(function* () {
				const privateKey = VoltaireBls12381.randomPrivateKey();
				const message = new TextEncoder().encode("Consistent test");
				const sig1 = yield* Bls12381Effect.sign(message, privateKey);
				const sig2 = yield* Bls12381Effect.sign(message, privateKey);
				const sig3 = yield* Bls12381Effect.sign(message, privateKey);
				expect(sig1).toEqual(sig2);
				expect(sig2).toEqual(sig3);
			}),
		);

		it.effect("aggregation order does not matter (commutative)", () =>
			Effect.gen(function* () {
				const pk1 = VoltaireBls12381.randomPrivateKey();
				const pk2 = VoltaireBls12381.randomPrivateKey();
				const sig1 = yield* Bls12381Effect.sign(testMessage, pk1);
				const sig2 = yield* Bls12381Effect.sign(testMessage, pk2);
				const aggSig1 = yield* Bls12381Effect.aggregate([sig1, sig2]);
				const aggSig2 = yield* Bls12381Effect.aggregate([sig2, sig1]);
				expect(aggSig1).toEqual(aggSig2);
			}),
		);
	});

	describe("Security Edge Cases", () => {
		it.effect("signature changes when message changes by 1 bit", () =>
			Effect.gen(function* () {
				const msg1 = new Uint8Array([0x00, 0x01, 0x02, 0x03]);
				const msg2 = new Uint8Array([0x00, 0x01, 0x02, 0x02]);
				const sig1 = yield* Bls12381Effect.sign(msg1, testPrivateKey);
				const sig2 = yield* Bls12381Effect.sign(msg2, testPrivateKey);
				expect(sig1).not.toEqual(sig2);
			}),
		);

		it.effect("cannot verify with wrong domain separation", () =>
			Effect.gen(function* () {
				const msg1 = new TextEncoder().encode("domain1:message");
				const msg2 = new TextEncoder().encode("domain2:message");
				const sig = yield* Bls12381Effect.sign(msg1, testPrivateKey);
				const isValid = yield* Bls12381Effect.verify(sig, msg2, testPublicKey);
				expect(isValid).toBe(false);
			}),
		);
	});
});

```
