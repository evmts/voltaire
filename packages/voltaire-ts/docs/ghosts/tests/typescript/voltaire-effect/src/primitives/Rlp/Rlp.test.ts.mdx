---
title: '[TS/JS] voltaire-effect/src/primitives/Rlp/Rlp.test.ts'
source: 'voltaire-effect/src/primitives/Rlp/Rlp.test.ts'
---

> Auto-generated from test file: voltaire-effect/src/primitives/Rlp/Rlp.test.ts

```typescript
import { describe, expect, it } from "@effect/vitest";
import * as Effect from "effect/Effect";
import * as S from "effect/Schema";
import * as Rlp from "./index.js";

type Encodable = Uint8Array | Encodable[];

/** Convert hex string to Uint8Array */
const fromHex = (hex: string): Uint8Array => {
	const h = hex.startsWith("0x") ? hex.slice(2) : hex;
	const bytes = new Uint8Array(h.length / 2);
	for (let i = 0; i < bytes.length; i++) {
		bytes[i] = Number.parseInt(h.slice(i * 2, i * 2 + 2), 16);
	}
	return bytes;
};

/** Convert string to Uint8Array */
const fromString = (s: string): Uint8Array => new TextEncoder().encode(s);

/** Convert integer to minimal big-endian Uint8Array (0 = empty array) */
const fromInt = (n: number): Uint8Array => {
	if (n === 0) return new Uint8Array(0);
	const hex = n.toString(16);
	const padded = hex.length % 2 === 0 ? hex : `0${hex}`;
	return fromHex(padded);
};

describe("Rlp encode", () => {
	describe("single byte encoding", () => {
		it("encodes single byte 0x00 as itself", () => {
			const encoded = Effect.runSync(Rlp.encode(new Uint8Array([0x00])));
			expect(encoded).toEqual(new Uint8Array([0x00]));
		});

		it("encodes single byte < 0x80 as itself", () => {
			const encoded = Effect.runSync(Rlp.encode(new Uint8Array([0x7f])));
			expect(encoded).toEqual(new Uint8Array([0x7f]));
		});

		it("encodes single byte 0x80 with prefix", () => {
			const encoded = Effect.runSync(Rlp.encode(new Uint8Array([0x80])));
			expect(encoded).toEqual(new Uint8Array([0x81, 0x80]));
		});
	});

	describe("short bytes (0-55 bytes)", () => {
		it("encodes empty bytes as 0x80", () => {
			const encoded = Effect.runSync(Rlp.encode(new Uint8Array(0)));
			expect(encoded).toEqual(new Uint8Array([0x80]));
		});

		it("encodes 2 bytes with prefix 0x82", () => {
			const encoded = Effect.runSync(Rlp.encode(new Uint8Array([0x01, 0x02])));
			expect(encoded).toEqual(new Uint8Array([0x82, 0x01, 0x02]));
		});

		it("encodes 55 bytes with prefix 0xb7", () => {
			const data = new Uint8Array(55).fill(0xab);
			const encoded = Effect.runSync(Rlp.encode(data));
			expect(encoded[0]).toBe(0xb7);
			expect(encoded.length).toBe(56);
		});
	});

	describe("long bytes (> 55 bytes)", () => {
		it("encodes 56 bytes with length prefix", () => {
			const data = new Uint8Array(56).fill(0xab);
			const encoded = Effect.runSync(Rlp.encode(data));
			expect(encoded[0]).toBe(0xb8);
			expect(encoded[1]).toBe(56);
			expect(encoded.length).toBe(58);
		});

		it("encodes 256 bytes with 2-byte length prefix", () => {
			const data = new Uint8Array(256).fill(0xab);
			const encoded = Effect.runSync(Rlp.encode(data));
			expect(encoded[0]).toBe(0xb9);
			expect(encoded[1]).toBe(0x01);
			expect(encoded[2]).toBe(0x00);
			expect(encoded.length).toBe(259);
		});

		it("encodes 1024 bytes correctly", () => {
			const data = new Uint8Array(1024).fill(0xcd);
			const encoded = Effect.runSync(Rlp.encode(data));
			expect(encoded[0]).toBe(0xb9);
			expect(encoded.length).toBe(1027);
		});
	});

	describe("short lists (0-55 bytes total)", () => {
		it("encodes empty list as 0xc0", () => {
			const encoded = Effect.runSync(Rlp.encode([]));
			expect(encoded).toEqual(new Uint8Array([0xc0]));
		});

		it("encodes list with single byte item", () => {
			const encoded = Effect.runSync(Rlp.encode([new Uint8Array([0x01])]));
			expect(encoded).toEqual(new Uint8Array([0xc1, 0x01]));
		});

		it("encodes list with multiple items", () => {
			const encoded = Effect.runSync(
				Rlp.encode([new Uint8Array([0x01]), new Uint8Array([0x02])]),
			);
			expect(encoded).toEqual(new Uint8Array([0xc2, 0x01, 0x02]));
		});
	});

	describe("long lists (> 55 bytes)", () => {
		it("encodes list with total > 55 bytes", () => {
			const items = Array.from({ length: 60 }, () => new Uint8Array([0xab]));
			const encoded = Effect.runSync(Rlp.encode(items));
			expect(encoded[0]).toBe(0xf8);
		});
	});

	describe("nested lists", () => {
		it("encodes nested list", () => {
			const nested: Encodable = [[new Uint8Array([0x01])]];
			const encoded = Effect.runSync(Rlp.encode(nested));
			expect(encoded).toEqual(new Uint8Array([0xc2, 0xc1, 0x01]));
		});

		it("encodes deeply nested empty lists", () => {
			const nested: Encodable = [[[[]]]];
			const encoded = Effect.runSync(Rlp.encode(nested));
			expect(encoded).toEqual(new Uint8Array([0xc3, 0xc2, 0xc1, 0xc0]));
		});

		it("encodes mixed nested structure", () => {
			const mixed: Encodable = [
				new Uint8Array([0x01]),
				[new Uint8Array([0x02]), new Uint8Array([0x03])],
			];
			const encoded = Effect.runSync(Rlp.encode(mixed));
			expect(encoded).toEqual(new Uint8Array([0xc4, 0x01, 0xc2, 0x02, 0x03]));
		});
	});
});

describe("Rlp decode", () => {
	describe("single byte decoding", () => {
		it("decodes single byte < 0x80", () => {
			const decoded = Effect.runSync(Rlp.decode(new Uint8Array([0x7f])));
			expect(decoded.data).toEqual({
				type: "bytes",
				value: new Uint8Array([0x7f]),
			});
			expect(decoded.remainder.length).toBe(0);
		});

		it("decodes single byte 0x00", () => {
			const decoded = Effect.runSync(Rlp.decode(new Uint8Array([0x00])));
			expect(decoded.data).toEqual({
				type: "bytes",
				value: new Uint8Array([0x00]),
			});
		});
	});

	describe("bytes decoding", () => {
		it("decodes empty bytes", () => {
			const decoded = Effect.runSync(Rlp.decode(new Uint8Array([0x80])));
			expect(decoded.data).toEqual({ type: "bytes", value: new Uint8Array(0) });
		});

		it("decodes short bytes", () => {
			const decoded = Effect.runSync(
				Rlp.decode(new Uint8Array([0x82, 0x01, 0x02])),
			);
			expect(decoded.data).toEqual({
				type: "bytes",
				value: new Uint8Array([0x01, 0x02]),
			});
		});

		it("decodes long bytes with 1-byte length", () => {
			const data = new Uint8Array(56).fill(0xab);
			const encoded = Effect.runSync(Rlp.encode(data));
			const decoded = Effect.runSync(Rlp.decode(encoded));
			expect(decoded.data).toEqual({ type: "bytes", value: data });
		});
	});

	describe("list decoding", () => {
		it("decodes empty list", () => {
			const decoded = Effect.runSync(Rlp.decode(new Uint8Array([0xc0])));
			expect(decoded.data).toEqual({ type: "list", value: [] });
		});

		it("decodes list with items", () => {
			const decoded = Effect.runSync(
				Rlp.decode(new Uint8Array([0xc2, 0x01, 0x02])),
			);
			expect(decoded.data).toEqual({
				type: "list",
				value: [
					{ type: "bytes", value: new Uint8Array([0x01]) },
					{ type: "bytes", value: new Uint8Array([0x02]) },
				],
			});
		});
	});

	describe("error handling", () => {
		it("rejects oversized length prefixes", async () => {
			const oversizedLength = new Uint8Array([
				0xbf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			]);
			await expect(
				Effect.runPromise(Rlp.decode(oversizedLength)),
			).rejects.toThrow();
		});

		it("rejects truncated input", async () => {
			const truncated = new Uint8Array([0x82, 0x01]);
			await expect(Effect.runPromise(Rlp.decode(truncated))).rejects.toThrow();
		});

		it("rejects invalid length for long bytes", async () => {
			const invalid = new Uint8Array([0xb8, 0x10]);
			await expect(Effect.runPromise(Rlp.decode(invalid))).rejects.toThrow();
		});
	});
});

describe("Rlp round-trip", () => {
	it("round-trips empty bytes", () => {
		const original = new Uint8Array(0);
		const encoded = Effect.runSync(Rlp.encode(original));
		const { data } = Effect.runSync(Rlp.decode(encoded));
		const reEncoded = Effect.runSync(Rlp.encode(data));
		expect(reEncoded).toEqual(encoded);
	});

	it("round-trips short bytes", () => {
		const original = new Uint8Array([0x01, 0x02, 0x03, 0x04, 0x05]);
		const encoded = Effect.runSync(Rlp.encode(original));
		const { data } = Effect.runSync(Rlp.decode(encoded));
		const reEncoded = Effect.runSync(Rlp.encode(data));
		expect(reEncoded).toEqual(encoded);
	});

	it("round-trips long bytes", () => {
		const original = new Uint8Array(200).fill(0xab);
		const encoded = Effect.runSync(Rlp.encode(original));
		const { data } = Effect.runSync(Rlp.decode(encoded));
		const reEncoded = Effect.runSync(Rlp.encode(data));
		expect(reEncoded).toEqual(encoded);
	});

	it("round-trips empty list", () => {
		const original: Encodable = [];
		const encoded = Effect.runSync(Rlp.encode(original));
		const { data } = Effect.runSync(Rlp.decode(encoded));
		const reEncoded = Effect.runSync(Rlp.encode(data));
		expect(reEncoded).toEqual(encoded);
	});

	it("round-trips nested lists", () => {
		const original: Encodable = [
			new Uint8Array([0x01]),
			[new Uint8Array([0x02]), [new Uint8Array([0x03])]],
			[],
		];
		const encoded = Effect.runSync(Rlp.encode(original));
		const { data } = Effect.runSync(Rlp.decode(encoded));
		const reEncoded = Effect.runSync(Rlp.encode(data));
		expect(reEncoded).toEqual(encoded);
	});

	it("round-trips deeply nested empty lists", () => {
		const original: Encodable = [[[[]]]];
		const encoded = Effect.runSync(Rlp.encode(original));
		const { data } = Effect.runSync(Rlp.decode(encoded));
		const reEncoded = Effect.runSync(Rlp.encode(data));
		expect(reEncoded).toEqual(encoded);
	});

	it("handles concurrent encode/decode without shared state", async () => {
		const inputs: Encodable[] = [
			new Uint8Array([0x01, 0x02, 0x03]),
			[new Uint8Array([0x04]), [new Uint8Array([0x05])]],
			[],
			[new Uint8Array(0), new Uint8Array([0x00])],
			[[[new Uint8Array([0xaa])]]],
		];

		const encoded = await Promise.all(
			inputs.map((input) => Effect.runPromise(Rlp.encode(input))),
		);
		const decoded = await Promise.all(
			encoded.map((bytes) => Effect.runPromise(Rlp.decode(bytes))),
		);
		const reEncoded = await Promise.all(
			decoded.map(({ data }) => Effect.runPromise(Rlp.encode(data))),
		);

		encoded.forEach((bytes, index) => {
			expect(decoded[index]?.remainder.length).toBe(0);
			expect(reEncoded[index]).toEqual(bytes);
		});
	});
});

describe("Rlp edge cases", () => {
	it("distinguishes empty list from empty bytes", () => {
		const emptyBytesEncoded = Effect.runSync(Rlp.encode(new Uint8Array(0)));
		const emptyListEncoded = Effect.runSync(Rlp.encode([]));

		expect(emptyBytesEncoded).toEqual(new Uint8Array([0x80]));
		expect(emptyListEncoded).toEqual(new Uint8Array([0xc0]));

		const emptyBytesDecoded = Effect.runSync(Rlp.decode(emptyBytesEncoded));
		const emptyListDecoded = Effect.runSync(Rlp.decode(emptyListEncoded));

		expect(emptyBytesDecoded.data).toEqual({
			type: "bytes",
			value: new Uint8Array(0),
		});
		expect(emptyListDecoded.data).toEqual({ type: "list", value: [] });
	});

	it("encodes all single-byte values correctly", () => {
		for (let i = 0; i < 128; i++) {
			const encoded = Effect.runSync(Rlp.encode(new Uint8Array([i])));
			expect(encoded).toEqual(new Uint8Array([i]));
		}
		for (let i = 128; i < 256; i++) {
			const encoded = Effect.runSync(Rlp.encode(new Uint8Array([i])));
			expect(encoded).toEqual(new Uint8Array([0x81, i]));
		}
	});

	it("handles large nested structure", () => {
		const buildNested = (depth: number): Encodable => {
			if (depth === 0) return new Uint8Array([0x42]);
			return [buildNested(depth - 1)];
		};
		const nested = buildNested(10);
		const encoded = Effect.runSync(Rlp.encode(nested));
		const { data } = Effect.runSync(Rlp.decode(encoded));
		const reEncoded = Effect.runSync(Rlp.encode(data));
		expect(reEncoded).toEqual(encoded);
	});

	it("handles list with many items", () => {
		const items = Array.from({ length: 100 }, (_, i) => new Uint8Array([i]));
		const encoded = Effect.runSync(Rlp.encode(items));
		const { data } = Effect.runSync(Rlp.decode(encoded));
		const reEncoded = Effect.runSync(Rlp.encode(data));
		expect(reEncoded).toEqual(encoded);
	});
});

describe("Ethereum official RLP test vectors", () => {
	// From https://github.com/ethereum/tests/blob/develop/RLPTests/rlptest.json

	it("emptystring: '' → 0x80", () => {
		const encoded = Effect.runSync(Rlp.encode(new Uint8Array(0)));
		expect(encoded).toEqual(fromHex("80"));
	});

	it("bytestring00: '\\x00' → 0x00", () => {
		const encoded = Effect.runSync(Rlp.encode(new Uint8Array([0x00])));
		expect(encoded).toEqual(fromHex("00"));
	});

	it("bytestring01: '\\x01' → 0x01", () => {
		const encoded = Effect.runSync(Rlp.encode(new Uint8Array([0x01])));
		expect(encoded).toEqual(fromHex("01"));
	});

	it("bytestring7F: '\\x7f' → 0x7f", () => {
		const encoded = Effect.runSync(Rlp.encode(new Uint8Array([0x7f])));
		expect(encoded).toEqual(fromHex("7f"));
	});

	it("shortstring: 'dog' → 0x83646f67", () => {
		const encoded = Effect.runSync(Rlp.encode(fromString("dog")));
		expect(encoded).toEqual(fromHex("83646f67"));
	});

	it("shortstring2: 55-char string → prefix 0xb7", () => {
		const input = fromString(
			"Lorem ipsum dolor sit amet, consectetur adipisicing eli",
		);
		expect(input.length).toBe(55);
		const encoded = Effect.runSync(Rlp.encode(input));
		expect(encoded).toEqual(
			fromHex(
				"b74c6f72656d20697073756d20646f6c6f722073697420616d65742c20636f6e7365637465747572206164697069736963696e6720656c69",
			),
		);
	});

	it("longstring: 56-char string → prefix 0xb838", () => {
		const input = fromString(
			"Lorem ipsum dolor sit amet, consectetur adipisicing elit",
		);
		expect(input.length).toBe(56);
		const encoded = Effect.runSync(Rlp.encode(input));
		expect(encoded).toEqual(
			fromHex(
				"b8384c6f72656d20697073756d20646f6c6f722073697420616d65742c20636f6e7365637465747572206164697069736963696e6720656c6974",
			),
		);
	});

	it("zero: integer 0 → 0x80 (empty bytes)", () => {
		const encoded = Effect.runSync(Rlp.encode(fromInt(0)));
		expect(encoded).toEqual(fromHex("80"));
	});

	it("smallint: 1 → 0x01", () => {
		const encoded = Effect.runSync(Rlp.encode(fromInt(1)));
		expect(encoded).toEqual(fromHex("01"));
	});

	it("smallint2: 16 → 0x10", () => {
		const encoded = Effect.runSync(Rlp.encode(fromInt(16)));
		expect(encoded).toEqual(fromHex("10"));
	});

	it("smallint3: 79 → 0x4f", () => {
		const encoded = Effect.runSync(Rlp.encode(fromInt(79)));
		expect(encoded).toEqual(fromHex("4f"));
	});

	it("smallint4: 127 → 0x7f", () => {
		const encoded = Effect.runSync(Rlp.encode(fromInt(127)));
		expect(encoded).toEqual(fromHex("7f"));
	});

	it("mediumint1: 128 → 0x8180", () => {
		const encoded = Effect.runSync(Rlp.encode(fromInt(128)));
		expect(encoded).toEqual(fromHex("8180"));
	});

	it("mediumint2: 1000 → 0x8203e8", () => {
		const encoded = Effect.runSync(Rlp.encode(fromInt(1000)));
		expect(encoded).toEqual(fromHex("8203e8"));
	});

	it("mediumint3: 100000 → 0x830186a0", () => {
		const encoded = Effect.runSync(Rlp.encode(fromInt(100000)));
		expect(encoded).toEqual(fromHex("830186a0"));
	});

	it("emptylist: [] → 0xc0", () => {
		const encoded = Effect.runSync(Rlp.encode([]));
		expect(encoded).toEqual(fromHex("c0"));
	});

	it("stringlist: ['dog','god','cat'] → 0xcc83646f6783676f6483636174", () => {
		const encoded = Effect.runSync(
			Rlp.encode([fromString("dog"), fromString("god"), fromString("cat")]),
		);
		expect(encoded).toEqual(fromHex("cc83646f6783676f6483636174"));
	});

	it("multilist: ['zw', [4], 1] → 0xc6827a77c10401", () => {
		const encoded = Effect.runSync(
			Rlp.encode([fromString("zw"), [fromInt(4)], fromInt(1)]),
		);
		expect(encoded).toEqual(fromHex("c6827a77c10401"));
	});

	it("listsoflists: [[[], []], []] → 0xc4c2c0c0c0", () => {
		const encoded = Effect.runSync(Rlp.encode([[[], []], []]));
		expect(encoded).toEqual(fromHex("c4c2c0c0c0"));
	});

	it("listsoflists2: [[], [[]], [[], [[]]]] → 0xc7c0c1c0c3c0c1c0", () => {
		const encoded = Effect.runSync(Rlp.encode([[], [[]], [[], [[]]]]));
		expect(encoded).toEqual(fromHex("c7c0c1c0c3c0c1c0"));
	});
});

describe("Rlp.encodeBytes", () => {
	it("encodes empty bytes", () => {
		const encoded = Effect.runSync(Rlp.encodeBytes(new Uint8Array(0)));
		expect(encoded).toEqual(new Uint8Array([0x80]));
	});

	it("encodes single byte < 0x80 as itself", () => {
		const encoded = Effect.runSync(Rlp.encodeBytes(new Uint8Array([0x42])));
		expect(encoded).toEqual(new Uint8Array([0x42]));
	});

	it("encodes single byte >= 0x80 with prefix", () => {
		const encoded = Effect.runSync(Rlp.encodeBytes(new Uint8Array([0xff])));
		expect(encoded).toEqual(new Uint8Array([0x81, 0xff]));
	});

	it("encodes short bytes with prefix", () => {
		const encoded = Effect.runSync(Rlp.encodeBytes(new Uint8Array([1, 2, 3])));
		expect(encoded).toEqual(new Uint8Array([0x83, 1, 2, 3]));
	});
});

describe("Rlp.encodeList", () => {
	it("encodes empty list", () => {
		const encoded = Effect.runSync(Rlp.encodeList([]));
		expect(encoded).toEqual(new Uint8Array([0xc0]));
	});

	it("encodes list with items", () => {
		const encoded = Effect.runSync(
			Rlp.encodeList([new Uint8Array([1]), new Uint8Array([2])]),
		);
		expect(encoded).toEqual(new Uint8Array([0xc2, 0x01, 0x02]));
	});

	it("encodes nested list", () => {
		const encoded = Effect.runSync(Rlp.encodeList([[new Uint8Array([0x42])]]));
		expect(encoded).toEqual(new Uint8Array([0xc2, 0xc1, 0x42]));
	});
});

describe("Rlp.encodeArray", () => {
	it("encodes array of bytes", () => {
		const encoded = Effect.runSync(
			Rlp.encodeArray([new Uint8Array([1, 2]), new Uint8Array([3, 4])]),
		);
		expect(encoded[0]).toBe(0xc6); // list prefix for 6 bytes
	});

	it("round-trips with decodeArray", () => {
		const original = [new Uint8Array([1, 2, 3]), new Uint8Array([4, 5, 6])];
		const encoded = Effect.runSync(Rlp.encodeArray(original));
		const decoded = Effect.runSync(Rlp.decodeArray(encoded));
		expect(decoded).toHaveLength(2);
		expect(decoded[0]).toEqual(original[0]);
		expect(decoded[1]).toEqual(original[1]);
	});
});

describe("Rlp.decodeArray", () => {
	it("decodes list to array", () => {
		const encoded = new Uint8Array([0xc2, 0x01, 0x02]);
		const decoded = Effect.runSync(Rlp.decodeArray(encoded));
		expect(decoded).toEqual([new Uint8Array([0x01]), new Uint8Array([0x02])]);
	});

	it("decodes nested lists", () => {
		const encoded = new Uint8Array([0xc3, 0xc2, 0x01, 0x02]);
		const decoded = Effect.runSync(Rlp.decodeArray(encoded));
		expect(decoded).toHaveLength(1);
		expect(Array.isArray(decoded[0])).toBe(true);
	});

	it("fails on invalid RLP", async () => {
		const invalid = new Uint8Array([0x83, 0x01]); // claims 3 bytes, only 1
		await expect(Effect.runPromise(Rlp.decodeArray(invalid))).rejects.toThrow();
	});
});

describe("Rlp.flatten", () => {
	it("flattens bytes to single-element array", () => {
		const { data } = Effect.runSync(
			Rlp.decode(new Uint8Array([0x83, 1, 2, 3])),
		);
		const flat = Effect.runSync(Rlp.flatten(data));
		expect(flat).toHaveLength(1);
		expect(flat[0]?.value).toEqual(new Uint8Array([1, 2, 3]));
	});

	it("flattens nested list depth-first", () => {
		const encoded = Effect.runSync(
			Rlp.encode([
				new Uint8Array([1]),
				[new Uint8Array([2]), new Uint8Array([3])],
			]),
		);
		const { data } = Effect.runSync(Rlp.decode(encoded));
		const flat = Effect.runSync(Rlp.flatten(data));
		expect(flat).toHaveLength(3);
		expect(flat[0]?.value).toEqual(new Uint8Array([1]));
		expect(flat[1]?.value).toEqual(new Uint8Array([2]));
		expect(flat[2]?.value).toEqual(new Uint8Array([3]));
	});

	it("returns empty array for empty list", () => {
		const { data } = Effect.runSync(Rlp.decode(new Uint8Array([0xc0])));
		const flat = Effect.runSync(Rlp.flatten(data));
		expect(flat).toEqual([]);
	});
});

describe("Rlp.validate", () => {
	it("returns true for valid single byte", () => {
		const valid = Effect.runSync(Rlp.validate(new Uint8Array([0x42])));
		expect(valid).toBe(true);
	});

	it("returns true for valid short bytes", () => {
		const valid = Effect.runSync(Rlp.validate(new Uint8Array([0x83, 1, 2, 3])));
		expect(valid).toBe(true);
	});

	it("returns true for valid empty list", () => {
		const valid = Effect.runSync(Rlp.validate(new Uint8Array([0xc0])));
		expect(valid).toBe(true);
	});

	it("returns false for truncated short bytes", () => {
		const valid = Effect.runSync(Rlp.validate(new Uint8Array([0x83, 1]))); // claims 3 bytes
		expect(valid).toBe(false);
	});

	it("returns false for truncated list", () => {
		const valid = Effect.runSync(Rlp.validate(new Uint8Array([0xc2, 0x01]))); // claims 2 bytes
		expect(valid).toBe(false);
	});

	it("returns false for empty input", () => {
		const valid = Effect.runSync(Rlp.validate(new Uint8Array(0)));
		expect(valid).toBe(false);
	});
});

describe("Rlp.Schema", () => {
	// NOTE: The Schema uses Rlp.from() which wraps input as BrandedRlp data structures,
	// it does NOT decode RLP-encoded bytes. For decoding, use Rlp.decode().

	it("wraps Uint8Array as bytes data", () => {
		// Schema wraps Uint8Array as {type: 'bytes', value: input}
		const input = new Uint8Array([1, 2, 3]);
		const result = S.decodeUnknownSync(Rlp.Schema)(input);
		expect(result.type).toBe("bytes");
		if (result.type === "bytes") {
			expect(result.value).toEqual(new Uint8Array([1, 2, 3]));
		}
	});

	it("handles already-branded RLP data", () => {
		// First decode some RLP to get branded data
		const { data } = Effect.runSync(
			Rlp.decode(new Uint8Array([0x83, 1, 2, 3])),
		);
		// Schema should accept already-branded data
		const result = S.decodeUnknownSync(Rlp.Schema)(data);
		expect(result.type).toBe("bytes");
		if (result.type === "bytes") {
			expect(result.value).toEqual(new Uint8Array([1, 2, 3]));
		}
	});

	it("encodes back to branded representation", () => {
		const input = new Uint8Array([1, 2, 3]);
		const decoded = S.decodeUnknownSync(Rlp.Schema)(input);
		const encoded = S.encodeSync(Rlp.Schema)(decoded);
		// Schema encode returns the branded type as-is
		expect(encoded).toBe(decoded);
	});
});

describe("Rlp decode error cases", () => {
	it("rejects leading zeros in length (non-canonical)", async () => {
		// 0xb900XX would be non-canonical for length < 256
		const nonCanonical = new Uint8Array([
			0xb9,
			0x00,
			0x38,
			...new Array(56).fill(0xab),
		]);
		await expect(Effect.runPromise(Rlp.decode(nonCanonical))).rejects.toThrow();
	});

	it("rejects incomplete long length prefix", async () => {
		// 0xb9 claims 2 length bytes, only 1 provided
		const incomplete = new Uint8Array([0xb9, 0x01]);
		await expect(Effect.runPromise(Rlp.decode(incomplete))).rejects.toThrow();
	});

	it("rejects list length exceeding input", async () => {
		// 0xf8 0x10 claims 16 bytes of list content but none provided
		const oversized = new Uint8Array([0xf8, 0x10]);
		await expect(Effect.runPromise(Rlp.decode(oversized))).rejects.toThrow();
	});

	it("rejects bytes with trailing data when not in stream mode", async () => {
		const withTrailing = new Uint8Array([0x01, 0x99]);
		// Default mode (non-stream) throws on trailing data
		await expect(Effect.runPromise(Rlp.decode(withTrailing))).rejects.toThrow();
	});

	it("handles stream mode for multiple items", () => {
		const twoItems = new Uint8Array([0x01, 0x02]);
		const first = Effect.runSync(Rlp.decode(twoItems, true));
		expect(first.data).toEqual({
			type: "bytes",
			value: new Uint8Array([0x01]),
		});
		expect(first.remainder).toEqual(new Uint8Array([0x02]));
		const second = Effect.runSync(Rlp.decode(first.remainder, true));
		expect(second.data).toEqual({
			type: "bytes",
			value: new Uint8Array([0x02]),
		});
		expect(second.remainder.length).toBe(0);
	});
});

describe("Rlp large data", () => {
	it("encodes very long bytes (> 65535 bytes)", () => {
		const data = new Uint8Array(70000).fill(0xab);
		const encoded = Effect.runSync(Rlp.encode(data));
		// 0xba + 3-byte length (70000 = 0x011170)
		expect(encoded[0]).toBe(0xba);
		expect(encoded.length).toBe(70000 + 4);
		const { data: decoded } = Effect.runSync(Rlp.decode(encoded));
		if (decoded.type === "bytes") {
			expect(decoded.value.length).toBe(70000);
		}
	});

	it("encodes very long list (> 55 bytes payload)", () => {
		const items = Array.from(
			{ length: 256 },
			(_, i) => new Uint8Array([i % 256]),
		);
		const encoded = Effect.runSync(Rlp.encode(items));
		expect(encoded[0]).toBe(0xf9); // 0xf8 + 1 (2-byte length)
		const { data } = Effect.runSync(Rlp.decode(encoded));
		expect(data.type).toBe("list");
		if (data.type === "list") {
			expect(data.value.length).toBe(256);
		}
	});
});

describe("Rlp list boundary cases", () => {
	it("encodes list with exactly 55 bytes total payload (boundary)", () => {
		// Each item: 0x83 + 3 bytes = 4 bytes encoded. Need 55 bytes, so 13 items + 3 bytes leftover
		// Actually simpler: 55 single-byte items (each encoded as itself) = 55 bytes payload
		const items = Array.from(
			{ length: 55 },
			(_, i) => new Uint8Array([i % 128]),
		);
		const encoded = Effect.runSync(Rlp.encode(items));
		// List prefix for 55 bytes: 0xc0 + 55 = 0xf7
		expect(encoded[0]).toBe(0xf7);
		expect(encoded.length).toBe(56); // 1 prefix + 55 payload
	});

	it("encodes list with exactly 56 bytes total payload (crosses boundary)", () => {
		// 56 single-byte items = 56 bytes payload
		const items = Array.from(
			{ length: 56 },
			(_, i) => new Uint8Array([i % 128]),
		);
		const encoded = Effect.runSync(Rlp.encode(items));
		// Long list prefix: 0xf8 (1 length byte) + 0x38 (56)
		expect(encoded[0]).toBe(0xf8);
		expect(encoded[1]).toBe(56);
		expect(encoded.length).toBe(58); // 2 prefix bytes + 56 payload
	});

	it("encodes list containing a list at the 55-byte boundary", () => {
		// Nested list at boundary: [[53 bytes]] = 0xc1 + inner = 0xc1 + 0xb7 + 53 bytes
		const innerData = new Uint8Array(53).fill(0x42);
		const nested: Encodable = [[innerData]];
		const encoded = Effect.runSync(Rlp.encode(nested));
		const { data } = Effect.runSync(Rlp.decode(encoded));
		expect(data.type).toBe("list");
		const reEncoded = Effect.runSync(Rlp.encode(data));
		expect(reEncoded).toEqual(encoded);
	});
});

describe("Rlp canonical encoding additional tests", () => {
	it("rejects single byte >= 0x80 encoded without prefix (non-canonical would be impossible to represent)", () => {
		// This is a conceptual test - RLP spec requires single bytes >= 0x80 to have 0x81 prefix
		// Encoding 0x80 directly would be interpreted as empty string
		const decoded = Effect.runSync(Rlp.decode(new Uint8Array([0x80])));
		expect(decoded.data).toEqual({ type: "bytes", value: new Uint8Array(0) });
	});

	it("handles maximum single-byte length prefix (55 bytes)", () => {
		// 0xb7 is the max prefix for short strings (0x80 + 55 = 0xb7)
		const data = new Uint8Array(55).fill(0xff);
		const encoded = Effect.runSync(Rlp.encode(data));
		expect(encoded[0]).toBe(0xb7);
		const { data: decoded } = Effect.runSync(Rlp.decode(encoded));
		if (decoded.type === "bytes") {
			expect(decoded.value.length).toBe(55);
		}
	});

	it("rejects 0xb8 0x00 (empty data claiming long format)", async () => {
		// Non-canonical: using long string format for data that could fit in short format
		const nonCanonical = new Uint8Array([0xb8, 0x00]);
		await expect(Effect.runPromise(Rlp.decode(nonCanonical))).rejects.toThrow();
	});

	it("rejects 0xb8 0x37 (55 bytes claiming long format)", async () => {
		// Non-canonical: 55 bytes should use 0xb7 prefix, not 0xb8 0x37
		const nonCanonical = new Uint8Array([
			0xb8,
			0x37,
			...new Array(55).fill(0xab),
		]);
		await expect(Effect.runPromise(Rlp.decode(nonCanonical))).rejects.toThrow();
	});

	it("rejects 0xf8 0x00 (empty list claiming long format)", async () => {
		// Non-canonical: empty list should be 0xc0, not 0xf8 0x00
		const nonCanonical = new Uint8Array([0xf8, 0x00]);
		await expect(Effect.runPromise(Rlp.decode(nonCanonical))).rejects.toThrow();
	});
});

describe("Rlp transaction-like structures", () => {
	it("encodes/decodes legacy transaction structure", () => {
		// Legacy tx: [nonce, gasPrice, gasLimit, to, value, data, v, r, s]
		const tx: Encodable = [
			fromInt(0), // nonce
			fromInt(20000000000), // gasPrice (20 gwei)
			fromInt(21000), // gasLimit
			fromHex("0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045"), // to (vitalik.eth)
			fromInt(1000000000000000000), // value (1 ETH)
			new Uint8Array(0), // data
			fromInt(27), // v
			fromHex(`0x${"ab".repeat(32)}`), // r
			fromHex(`0x${"cd".repeat(32)}`), // s
		];

		const encoded = Effect.runSync(Rlp.encode(tx));
		const { data } = Effect.runSync(Rlp.decode(encoded));
		expect(data.type).toBe("list");
		if (data.type === "list") {
			expect(data.value.length).toBe(9);
		}
		const reEncoded = Effect.runSync(Rlp.encode(data));
		expect(reEncoded).toEqual(encoded);
	});

	it("encodes/decodes EIP-2930 access list structure", () => {
		// Access list: [[address, [storageKeys...]]]
		const accessList: Encodable = [
			[
				fromHex("0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045"),
				[fromHex(`0x${"00".repeat(32)}`), fromHex(`0x${"01".repeat(32)}`)],
			],
		];

		const encoded = Effect.runSync(Rlp.encode(accessList));
		const { data } = Effect.runSync(Rlp.decode(encoded));
		const reEncoded = Effect.runSync(Rlp.encode(data));
		expect(reEncoded).toEqual(encoded);
	});

	it("encodes/decodes block header structure", () => {
		// Simplified block header fields
		const header: Encodable = [
			fromHex(`0x${"ab".repeat(32)}`), // parentHash
			fromHex(`0x${"00".repeat(32)}`), // ommersHash
			fromHex("0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045"), // beneficiary
			fromHex(`0x${"cd".repeat(32)}`), // stateRoot
			fromHex(`0x${"ef".repeat(32)}`), // transactionsRoot
			fromHex(`0x${"12".repeat(32)}`), // receiptsRoot
			new Uint8Array(256).fill(0), // logsBloom
			fromInt(1), // difficulty
			fromInt(12345678), // number
			fromInt(30000000), // gasLimit
			fromInt(21000), // gasUsed
			fromInt(1640000000), // timestamp
			new Uint8Array(0), // extraData
			fromHex(`0x${"ff".repeat(32)}`), // mixHash
			fromHex(`0x${"00".repeat(8)}`), // nonce
		];

		const encoded = Effect.runSync(Rlp.encode(header));
		const { data } = Effect.runSync(Rlp.decode(encoded));
		expect(data.type).toBe("list");
		if (data.type === "list") {
			expect(data.value.length).toBe(15);
		}
		const reEncoded = Effect.runSync(Rlp.encode(data));
		expect(reEncoded).toEqual(encoded);
	});
});

describe("Rlp integer encoding edge cases", () => {
	it("encodes integer 0 as empty bytes (0x80)", () => {
		const encoded = Effect.runSync(Rlp.encode(fromInt(0)));
		expect(encoded).toEqual(new Uint8Array([0x80]));
	});

	it("encodes integers without leading zeros", () => {
		// 256 = 0x0100 should be [0x01, 0x00], not [0x00, 0x01, 0x00]
		const encoded = Effect.runSync(Rlp.encode(fromInt(256)));
		expect(encoded).toEqual(new Uint8Array([0x82, 0x01, 0x00]));
	});

	it("encodes max uint64 correctly", () => {
		// 2^64 - 1 = 0xffffffffffffffff
		const maxUint64 = fromHex("0xffffffffffffffff");
		const encoded = Effect.runSync(Rlp.encode(maxUint64));
		expect(encoded[0]).toBe(0x88); // 8 bytes + 0x80
		expect(encoded.length).toBe(9);
	});

	it("encodes max uint256 correctly", () => {
		// 2^256 - 1 = 32 bytes of 0xff
		const maxUint256 = new Uint8Array(32).fill(0xff);
		const encoded = Effect.runSync(Rlp.encode(maxUint256));
		expect(encoded[0]).toBe(0xa0); // 32 bytes + 0x80
		expect(encoded.length).toBe(33);
	});

	it("round-trips large integer values", () => {
		const values = [
			fromInt(127), // max single byte
			fromInt(128), // first 2-byte
			fromInt(255), // max 1-byte value
			fromInt(256), // first 2-byte big-endian
			fromInt(65535), // max 2-byte
			fromInt(65536), // first 3-byte
			fromInt(16777215), // max 3-byte
			fromInt(16777216), // first 4-byte
		];

		for (const value of values) {
			const encoded = Effect.runSync(Rlp.encode(value));
			const { data } = Effect.runSync(Rlp.decode(encoded));
			const reEncoded = Effect.runSync(Rlp.encode(data));
			expect(reEncoded).toEqual(encoded);
		}
	});
});

describe("Rlp mixed content lists", () => {
	it("encodes list with empty and non-empty items", () => {
		const mixed: Encodable = [
			new Uint8Array(0), // empty
			new Uint8Array([1]), // single byte
			new Uint8Array([128]), // single byte >= 0x80
			[], // empty list
			[new Uint8Array(0)], // list with empty bytes
		];

		const encoded = Effect.runSync(Rlp.encode(mixed));
		const { data } = Effect.runSync(Rlp.decode(encoded));
		expect(data.type).toBe("list");
		const reEncoded = Effect.runSync(Rlp.encode(data));
		expect(reEncoded).toEqual(encoded);
	});

	it("encodes alternating bytes and lists", () => {
		const alternating: Encodable = [
			new Uint8Array([1]),
			[new Uint8Array([2])],
			new Uint8Array([3]),
			[new Uint8Array([4])],
		];

		const encoded = Effect.runSync(Rlp.encode(alternating));
		// Total content: 1 (single byte) + 2 ([2]) + 1 (single byte) + 2 ([4]) = 6 bytes
		expect(encoded).toEqual(
			new Uint8Array([
				0xc6, // list of 6 bytes
				0x01, // 1
				0xc1,
				0x02, // [2]
				0x03, // 3
				0xc1,
				0x04, // [4]
			]),
		);
	});

	it("handles deeply nested mixed structure", () => {
		const deep: Encodable = [
			new Uint8Array([1]),
			[
				new Uint8Array([2]),
				[new Uint8Array([3]), [new Uint8Array([4]), [new Uint8Array([5])]]],
			],
		];

		const encoded = Effect.runSync(Rlp.encode(deep));
		const { data } = Effect.runSync(Rlp.decode(encoded));
		const reEncoded = Effect.runSync(Rlp.encode(data));
		expect(reEncoded).toEqual(encoded);
	});
});

```
