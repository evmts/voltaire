---
title: '[TS/JS] voltaire-effect/src/primitives/Block/Block.test.ts'
source: 'voltaire-effect/src/primitives/Block/Block.test.ts'
---

> Auto-generated from test file: voltaire-effect/src/primitives/Block/Block.test.ts

```typescript
/**
 * @fileoverview Tests for Block Effect Schemas.
 * @module Block/Block.test
 */

import { Block, BlockBody, BlockHeader, Hex, Withdrawal } from "@tevm/voltaire";
import * as S from "effect/Schema";
import { describe, expect, it } from "vitest";
import { BlockSchema } from "./BlockSchema.js";
import { Rpc } from "./Rpc.js";

type BlockType = Block.BlockType;

/**
 * Creates a valid block header for testing.
 */
function createValidHeader(): ReturnType<typeof BlockHeader.from> {
	return BlockHeader.from({
		parentHash: `0x${"ab".repeat(32)}`,
		ommersHash: `0x${"cd".repeat(32)}`,
		beneficiary: `0x${"ef".repeat(20)}`,
		stateRoot: `0x${"11".repeat(32)}`,
		transactionsRoot: `0x${"22".repeat(32)}`,
		receiptsRoot: `0x${"33".repeat(32)}`,
		logsBloom: new Uint8Array(256).fill(0),
		difficulty: 0n,
		number: 12345n,
		gasLimit: 30000000n,
		gasUsed: 21000n,
		timestamp: 1700000000n,
		extraData: new Uint8Array(0),
		mixHash: `0x${"44".repeat(32)}`,
		nonce: new Uint8Array(8).fill(0),
		baseFeePerGas: 1000000000n,
	});
}

/**
 * Creates a valid block body for testing.
 */
function createValidBody(): ReturnType<typeof BlockBody.from> {
	return BlockBody.from({
		transactions: [],
		ommers: [],
	});
}

/**
 * Creates a valid block for testing.
 */
function createValidBlock(): ReturnType<typeof Block.from> {
	return Block.from({
		header: createValidHeader(),
		body: createValidBody(),
		hash: `0x${"55".repeat(32)}`,
		size: 1000n,
	});
}

describe("BlockSchema", () => {
	it("validates complete block", () => {
		const block = createValidBlock();
		const result = S.decodeSync(BlockSchema)(block);
		expect(result.hash.length).toBe(32);
		expect(result.header.number).toBe(12345n);
	});

	it("rejects block with invalid header (string)", () => {
		const block = createValidBlock();
		const invalid = { ...block, header: "garbage" } as unknown as BlockType;
		expect(() => S.decodeSync(BlockSchema)(invalid)).toThrow();
	});

	it("rejects block with invalid header (null)", () => {
		const block = createValidBlock();
		const invalid = { ...block, header: null } as unknown as BlockType;
		expect(() => S.decodeSync(BlockSchema)(invalid)).toThrow();
	});

	it("rejects block with invalid body (null)", () => {
		const block = createValidBlock();
		const invalid = { ...block, body: null } as unknown as BlockType;
		expect(() => S.decodeSync(BlockSchema)(invalid)).toThrow();
	});

	it("rejects block with wrong hash length", () => {
		const block = createValidBlock();
		const invalid = {
			...block,
			hash: new Uint8Array(16),
		} as unknown as BlockType;
		expect(() => S.decodeSync(BlockSchema)(invalid)).toThrow();
	});

	it("rejects block missing required header field (parentHash)", () => {
		const block = createValidBlock();
		const { parentHash: _, ...headerWithoutParentHash } = block.header as {
			parentHash: Uint8Array;
			[key: string]: unknown;
		};
		const invalid = {
			...block,
			header: headerWithoutParentHash,
		} as unknown as BlockType;
		expect(() => S.decodeSync(BlockSchema)(invalid)).toThrow();
	});

	it("rejects block with wrong parentHash length", () => {
		const block = createValidBlock();
		const invalidHeader = { ...block.header, parentHash: new Uint8Array(16) };
		const invalid = { ...block, header: invalidHeader } as unknown as BlockType;
		expect(() => S.decodeSync(BlockSchema)(invalid)).toThrow();
	});

	it("rejects block with wrong beneficiary length", () => {
		const block = createValidBlock();
		const invalidHeader = { ...block.header, beneficiary: new Uint8Array(32) };
		const invalid = { ...block, header: invalidHeader } as unknown as BlockType;
		expect(() => S.decodeSync(BlockSchema)(invalid)).toThrow();
	});

	it("rejects block with wrong logsBloom length", () => {
		const block = createValidBlock();
		const invalidHeader = { ...block.header, logsBloom: new Uint8Array(128) };
		const invalid = { ...block, header: invalidHeader } as unknown as BlockType;
		expect(() => S.decodeSync(BlockSchema)(invalid)).toThrow();
	});

	it("rejects block with wrong nonce length", () => {
		const block = createValidBlock();
		const invalidHeader = { ...block.header, nonce: new Uint8Array(4) };
		const invalid = { ...block, header: invalidHeader } as unknown as BlockType;
		expect(() => S.decodeSync(BlockSchema)(invalid)).toThrow();
	});

	it("rejects block with non-bigint number", () => {
		const block = createValidBlock();
		const invalidHeader = { ...block.header, number: 12345 };
		const invalid = { ...block, header: invalidHeader } as unknown as BlockType;
		expect(() => S.decodeSync(BlockSchema)(invalid)).toThrow();
	});

	it("rejects block with non-array transactions", () => {
		const block = createValidBlock();
		const invalidBody = { ...block.body, transactions: "not-an-array" };
		const invalid = { ...block, body: invalidBody } as unknown as BlockType;
		expect(() => S.decodeSync(BlockSchema)(invalid)).toThrow();
	});

	it("rejects block with non-array ommers", () => {
		const block = createValidBlock();
		const invalidBody = { ...block.body, ommers: {} };
		const invalid = { ...block, body: invalidBody } as unknown as BlockType;
		expect(() => S.decodeSync(BlockSchema)(invalid)).toThrow();
	});

	it("rejects non-object input", () => {
		expect(() =>
			S.decodeSync(BlockSchema)("not-an-object" as unknown as BlockType),
		).toThrow();
		expect(() =>
			S.decodeSync(BlockSchema)(null as unknown as BlockType),
		).toThrow();
		expect(() =>
			S.decodeSync(BlockSchema)(undefined as unknown as BlockType),
		).toThrow();
	});
});

describe("Block.Rpc", () => {
	const createRpcBlock = () => ({
		hash: `0x${"ab".repeat(32)}`,
		size: "0x3e8",
		parentHash: `0x${"cd".repeat(32)}`,
		sha3Uncles: `0x${"de".repeat(32)}`,
		miner: `0x${"ef".repeat(20)}`,
		stateRoot: `0x${"11".repeat(32)}`,
		transactionsRoot: `0x${"22".repeat(32)}`,
		receiptsRoot: `0x${"33".repeat(32)}`,
		logsBloom: `0x${"00".repeat(256)}`,
		difficulty: "0x0",
		number: "0x3039",
		gasLimit: "0x1c9c380",
		gasUsed: "0x5208",
		timestamp: "0x65510d80",
		extraData: "0x",
		mixHash: `0x${"44".repeat(32)}`,
		nonce: "0x0000000000000000",
		baseFeePerGas: "0x3b9aca00",
		transactions: [],
	});

	it("decodes RPC block", () => {
		const rpcBlock = createRpcBlock();
		const block = S.decodeSync(Rpc)(rpcBlock);
		expect(block.header.number).toBe(12345n);
		expect(block.hash.length).toBe(32);
	});

	it("decodes post-Shanghai block with withdrawals", () => {
		const rpcBlock = {
			...createRpcBlock(),
			withdrawalsRoot: `0x${"55".repeat(32)}`,
			withdrawals: [
				{
					index: "0x0",
					validatorIndex: "0x1",
					address: `0x${"aa".repeat(20)}`,
					amount: "0x1000",
				},
			],
		};
		const block = S.decodeSync(Rpc)(rpcBlock);
		expect(block.body.withdrawals?.length).toBe(1);
	});

	it("decodes post-Cancun block with blob fields", () => {
		const rpcBlock = {
			...createRpcBlock(),
			withdrawalsRoot: `0x${"55".repeat(32)}`,
			withdrawals: [],
			blobGasUsed: "0x20000",
			excessBlobGas: "0x0",
			parentBeaconBlockRoot: `0x${"66".repeat(32)}`,
		};
		const block = S.decodeSync(Rpc)(rpcBlock);
		expect(block.header.blobGasUsed).toBe(131072n);
		expect(block.header.excessBlobGas).toBe(0n);
	});

	it("encodes block to RPC format", () => {
		const block = createValidBlock();
		const rpc = S.encodeSync(Rpc)(block);

		expect(rpc.hash).toBe(Hex.fromBytes(block.hash));
		expect(rpc.number).toBe(Hex.fromBigInt(block.header.number));
		expect(rpc.parentHash).toBe(Hex.fromBytes(block.header.parentHash));
		expect(rpc.miner).toBe(Hex.fromBytes(block.header.beneficiary));
	});

	it("round-trips block through RPC format", () => {
		const rpcBlock = createRpcBlock();
		const block = S.decodeSync(Rpc)(rpcBlock);
		const encoded = S.encodeSync(Rpc)(block);

		// Decode again and compare
		const decoded = S.decodeSync(Rpc)(encoded);
		expect(decoded.header.number).toBe(block.header.number);
		expect(decoded.header.gasLimit).toBe(block.header.gasLimit);
	});

	it("encodes block with withdrawals", () => {
		const header = BlockHeader.from({
			parentHash: `0x${"ab".repeat(32)}`,
			ommersHash: `0x${"cd".repeat(32)}`,
			beneficiary: `0x${"ef".repeat(20)}`,
			stateRoot: `0x${"11".repeat(32)}`,
			transactionsRoot: `0x${"22".repeat(32)}`,
			receiptsRoot: `0x${"33".repeat(32)}`,
			logsBloom: new Uint8Array(256).fill(0),
			difficulty: 0n,
			number: 17000000n,
			gasLimit: 30000000n,
			gasUsed: 21000n,
			timestamp: 1700000000n,
			extraData: new Uint8Array(0),
			mixHash: `0x${"44".repeat(32)}`,
			nonce: new Uint8Array(8).fill(0),
			baseFeePerGas: 1000000000n,
			withdrawalsRoot: `0x${"55".repeat(32)}`,
		});

		const body = BlockBody.from({
			transactions: [],
			ommers: [],
			withdrawals: [
				Withdrawal.from({
					index: 0n,
					validatorIndex: 1n,
					address: `0x${"aa".repeat(20)}`,
					amount: 1000000000n,
				}),
			],
		});

		const block = Block.from({
			header,
			body,
			hash: `0x${"66".repeat(32)}`,
			size: 2000n,
		});

		const rpc = S.encodeSync(Rpc)(block);
		expect(rpc.withdrawals).toBeDefined();
		expect(rpc.withdrawals?.length).toBe(1);
		expect(rpc.withdrawals?.[0].index).toBe("0x0");
		expect(rpc.withdrawals?.[0].validatorIndex).toBe("0x1");
	});

	it("rejects invalid RPC block", () => {
		const invalid = {
			hash: "not-valid-hex",
			size: "0x100",
			parentHash: `0x${"cd".repeat(32)}`,
		};
		expect(() => S.decodeSync(Rpc)(invalid as never)).toThrow();
	});

	it("decodes pre-London block (no baseFeePerGas)", () => {
		const preLondonRpc = {
			hash: `0x${"ab".repeat(32)}`,
			size: "0x3e8",
			parentHash: `0x${"cd".repeat(32)}`,
			sha3Uncles: `0x${"de".repeat(32)}`,
			miner: `0x${"ef".repeat(20)}`,
			stateRoot: `0x${"11".repeat(32)}`,
			transactionsRoot: `0x${"22".repeat(32)}`,
			receiptsRoot: `0x${"33".repeat(32)}`,
			logsBloom: `0x${"00".repeat(256)}`,
			difficulty: "0x2d79883d2000",
			number: "0xc5d488",
			gasLimit: "0x1c9c380",
			gasUsed: "0xbebc20",
			timestamp: "0x60c7a2bb",
			extraData: "0x6e616e6f706f6f6c2e6f7267",
			mixHash: `0x${"44".repeat(32)}`,
			nonce: "0x0db95e41b7970000",
			transactions: [],
		};
		const block = S.decodeSync(Rpc)(preLondonRpc);
		expect(block.header.baseFeePerGas).toBeUndefined();
		expect(block.header.difficulty).toBe(50000000000000n);
	});

	it("encodes block with optional EIP-4844 fields", () => {
		const header = BlockHeader.from({
			parentHash: `0x${"ab".repeat(32)}`,
			ommersHash: `0x${"cd".repeat(32)}`,
			beneficiary: `0x${"ef".repeat(20)}`,
			stateRoot: `0x${"11".repeat(32)}`,
			transactionsRoot: `0x${"22".repeat(32)}`,
			receiptsRoot: `0x${"33".repeat(32)}`,
			logsBloom: new Uint8Array(256).fill(0),
			difficulty: 0n,
			number: 19000000n,
			gasLimit: 30000000n,
			gasUsed: 21000n,
			timestamp: 1710000000n,
			extraData: new Uint8Array(0),
			mixHash: `0x${"44".repeat(32)}`,
			nonce: new Uint8Array(8).fill(0),
			baseFeePerGas: 1000000000n,
			withdrawalsRoot: `0x${"55".repeat(32)}`,
			blobGasUsed: 131072n,
			excessBlobGas: 0n,
			parentBeaconBlockRoot: `0x${"77".repeat(32)}`,
		});

		const body = BlockBody.from({
			transactions: [],
			ommers: [],
			withdrawals: [],
		});

		const block = Block.from({
			header,
			body,
			hash: `0x${"88".repeat(32)}`,
			size: 500n,
		});

		const rpc = S.encodeSync(Rpc)(block);
		expect(rpc.blobGasUsed).toBe("0x20000");
		expect(rpc.excessBlobGas).toBe("0x0");
		expect(rpc.parentBeaconBlockRoot).toBe(`0x${"77".repeat(32)}`);
	});
});

```
