---
title: '[TS/JS] voltaire-effect/src/services/Account/Account.test.ts'
source: 'voltaire-effect/src/services/Account/Account.test.ts'
---

> Auto-generated from test file: voltaire-effect/src/services/Account/Account.test.ts

```typescript
import { describe, expect, it } from "@effect/vitest";
import {
	Address,
	type BrandedAddress,
	type BrandedHex,
	Signature,
	TypedData,
} from "@tevm/voltaire";
import * as Effect from "effect/Effect";
import * as Layer from "effect/Layer";
import { CryptoTest } from "../../crypto/CryptoTest.js";
import { KeccakLive } from "../../crypto/Keccak256/index.js";
import { Secp256k1Live } from "../../crypto/Secp256k1/index.js";
import { TransportError, TransportService } from "../Transport/index.js";
import {
	AccountError,
	AccountService,
	JsonRpcAccount,
	LocalAccount,
	type UnsignedTransaction,
} from "./index.js";

type AddressType = BrandedAddress.AddressType;
type HexType = BrandedHex.HexType;
type TypedDataType = TypedData.TypedDataType;

const TEST_PRIVATE_KEY =
	"0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80" as HexType;
const TEST_PUBLIC_KEY =
	"0x048318535b54105d4a7aae60c08fc45f9687181b4fdfc625bd1a753fa7397fed753547f11ca8696646f2f3acb08e31016afac23e630c5d11f59f61fef57b0d2aa5" as HexType;
const TEST_ADDRESS_HEX = "0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266" as const;
const TEST_HASH =
	"0x1c8aff950685c2ed4bc3174f3472287b56d9517b9c948127319a09a7a36deac8" as HexType;
const TEST_HASH_SIGNATURE =
	"0x73eebf81a611136662d65778960c853fdcaf6eca86793ed9cabc30f2195937af78a07e601627da5b4cc80c0ab35f6894da19b4a01759d90c101d9c9dd1c6745d1b" as HexType;
const CryptoLiveLayer = Layer.mergeAll(KeccakLive, Secp256k1Live);

describe("AccountService", () => {
	describe("LocalAccount", () => {
		it.effect("derives address from private key", () =>
			Effect.gen(function* () {
				const account = yield* AccountService;
				const addressHex = Address.toHex(account.address);
				expect(addressHex).toBe(TEST_ADDRESS_HEX);
			}).pipe(
				Effect.provide(LocalAccount(TEST_PRIVATE_KEY)),
				Effect.provide(CryptoLiveLayer),
			),
		);

		it.effect('has type "local"', () =>
			Effect.gen(function* () {
				const account = yield* AccountService;
				expect(account.type).toBe("local");
			}).pipe(
				Effect.provide(LocalAccount(TEST_PRIVATE_KEY)),
				Effect.provide(CryptoTest),
			),
		);

		it.effect("exposes publicKey property (65 bytes uncompressed)", () =>
			Effect.gen(function* () {
				const account = yield* AccountService;
				const publicKey = account.publicKey;
				expect(publicKey).toBeDefined();
				expect(publicKey).toBe(TEST_PUBLIC_KEY);
				expect(publicKey?.length).toBe(TEST_PUBLIC_KEY.length);
				expect(publicKey?.startsWith("0x04")).toBe(true);
			}).pipe(
				Effect.provide(LocalAccount(TEST_PRIVATE_KEY)),
				Effect.provide(CryptoLiveLayer),
			),
		);

		it.effect("signs raw hash with sign({ hash })", () =>
			Effect.gen(function* () {
				const account = yield* AccountService;
				const signature = yield* account.sign({ hash: TEST_HASH });
				expect(signature).toBeDefined();
				expect(Signature.toHex(signature)).toBe(TEST_HASH_SIGNATURE);
			}).pipe(
				Effect.provide(LocalAccount(TEST_PRIVATE_KEY)),
				Effect.provide(CryptoLiveLayer),
			),
		);

		it.effect("sign({ hash }) fails for non-32-byte hash", () =>
			Effect.gen(function* () {
				const shortHash = "0x1234" as HexType;
				const account = yield* AccountService;
				const result = yield* Effect.either(account.sign({ hash: shortHash }));
				expect(result._tag).toBe("Left");
				if (result._tag === "Left") {
					expect(result.left._tag).toBe("AccountError");
					expect(result.left.message).toContain("32 bytes");
				}
			}).pipe(
				Effect.provide(LocalAccount(TEST_PRIVATE_KEY)),
				Effect.provide(CryptoTest),
			),
		);

		it.effect("clearKey() zeros out private key bytes", () =>
			Effect.gen(function* () {
				const account = yield* AccountService;
				// Ensure we can sign before clearing
				const sigBefore = yield* account.sign({ hash: TEST_HASH });
				expect(sigBefore).toBeDefined();

				// Clear the key
				yield* account.clearKey();

				// Note: After clearKey, the key bytes are zeroed.
				// Signing will produce invalid signatures or fail.
				// The test verifies clearKey completes without error.
			}).pipe(
				Effect.provide(LocalAccount(TEST_PRIVATE_KEY)),
				Effect.provide(CryptoTest),
			),
		);

		it.effect("signs message with EIP-191 prefix", () =>
			Effect.gen(function* () {
				const message = "0x48656c6c6f" as HexType;
				const account = yield* AccountService;
				const signature = yield* account.signMessage(message);
				expect(signature).toBeDefined();
			}).pipe(
				Effect.provide(LocalAccount(TEST_PRIVATE_KEY)),
				Effect.provide(CryptoTest),
			),
		);

		it.effect("signs transaction", () =>
			Effect.gen(function* () {
				const tx: UnsignedTransaction = {
					to: Address.fromHex("0x0000000000000000000000000000000000000001"),
					value: 1000000000000000000n,
					nonce: 0n,
					gasPrice: 20000000000n,
					gasLimit: 21000n,
					chainId: 1n,
				};

				const account = yield* AccountService;
				const signature = yield* account.signTransaction(tx);
				expect(signature).toBeDefined();
			}).pipe(
				Effect.provide(LocalAccount(TEST_PRIVATE_KEY)),
				Effect.provide(CryptoTest),
			),
		);

		it.effect("signTransaction fails for EIP-4844 when to is missing", () =>
			Effect.gen(function* () {
				const account = yield* AccountService;
				const result = yield* Effect.either(
					account.signTransaction({
						type: 3,
						nonce: 0n,
						gasLimit: 21000n,
						chainId: 1n,
						blobVersionedHashes: [],
					}),
				);
				expect(result._tag).toBe("Left");
				if (result._tag === "Left") {
					expect(result.left._tag).toBe("AccountError");
					expect(result.left.cause).toBeInstanceOf(Error);
					expect(result.left.cause?.message).toContain(
						"EIP-4844 transactions require a 'to' address",
					);
				}
			}).pipe(
				Effect.provide(LocalAccount(TEST_PRIVATE_KEY)),
				Effect.provide(CryptoTest),
			),
		);

		it.effect("signs typed data (EIP-712)", () =>
			Effect.gen(function* () {
				const typedData = TypedData.from({
					types: {
						EIP712Domain: [
							{ name: "name", type: "string" },
							{ name: "version", type: "string" },
							{ name: "chainId", type: "uint256" },
						],
						Person: [
							{ name: "name", type: "string" },
							{ name: "wallet", type: "address" },
						],
					},
					primaryType: "Person",
					domain: {
						name: "Test",
						version: "1",
						chainId: 1,
					},
					message: {
						name: "Alice",
						wallet: Address.fromHex(
							"0x0000000000000000000000000000000000000001",
						),
					},
				});

				const account = yield* AccountService;
				const signature = yield* account.signTypedData(typedData);
				expect(signature).toBeDefined();
			}).pipe(
				Effect.provide(LocalAccount(TEST_PRIVATE_KEY)),
				Effect.provide(CryptoTest),
			),
		);

		it.effect("signs EIP-7702 authorization", () =>
			Effect.gen(function* () {
				const account = yield* AccountService;
				const authorization = yield* account.signAuthorization({
					contractAddress: "0x000000000000000000000000000000000000dead",
					chainId: 1n,
					nonce: 7n,
				});

				expect(authorization.chainId).toBe(1n);
				expect(authorization.nonce).toBe(7n);
				expect(authorization.address).toBe(
					"0x000000000000000000000000000000000000dead",
				);
				expect(authorization.yParity === 0 || authorization.yParity === 1).toBe(
					true,
				);
				expect(authorization.r).toMatch(/^0x[0-9a-fA-F]{64}$/);
				expect(authorization.s).toMatch(/^0x[0-9a-fA-F]{64}$/);
			}).pipe(
				Effect.provide(LocalAccount(TEST_PRIVATE_KEY)),
				Effect.provide(CryptoTest),
			),
		);

		it.effect("signAuthorization fails when nonce is missing", () =>
			Effect.gen(function* () {
				const account = yield* AccountService;
				const result = yield* Effect.either(
					account.signAuthorization({
						contractAddress: "0x000000000000000000000000000000000000dead",
						chainId: 1n,
					}),
				);
				expect(result._tag).toBe("Left");
				if (result._tag === "Left") {
					expect(result.left._tag).toBe("AccountError");
					expect(result.left.cause).toBeInstanceOf(Error);
					expect(result.left.cause?.message).toContain(
						"Authorization nonce is required",
					);
				}
			}).pipe(
				Effect.provide(LocalAccount(TEST_PRIVATE_KEY)),
				Effect.provide(CryptoTest),
			),
		);

		it.effect(
			"signs typed data with nested struct types (Mail containing Person)",
			() =>
				Effect.gen(function* () {
					const typedData = TypedData.from({
						types: {
							EIP712Domain: [
								{ name: "name", type: "string" },
								{ name: "version", type: "string" },
								{ name: "chainId", type: "uint256" },
							],
							Person: [
								{ name: "name", type: "string" },
								{ name: "wallet", type: "address" },
							],
							Mail: [
								{ name: "from", type: "Person" },
								{ name: "to", type: "Person" },
								{ name: "contents", type: "string" },
							],
						},
						primaryType: "Mail",
						domain: {
							name: "Ether Mail",
							version: "1",
							chainId: 1,
						},
						message: {
							from: {
								name: "Alice",
								wallet: Address.fromHex(
									"0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826",
								),
							},
							to: {
								name: "Bob",
								wallet: Address.fromHex(
									"0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB",
								),
							},
							contents: "Hello, Bob!",
						},
					});

					const account = yield* AccountService;
					const signature = yield* account.signTypedData(typedData);
					expect(signature).toBeDefined();
					expect(Signature.toHex(signature)).toMatch(/^0x[0-9a-f]{130}$/);
				}).pipe(
					Effect.provide(LocalAccount(TEST_PRIVATE_KEY)),
					Effect.provide(CryptoTest),
				),
		);

		it.effect("signs typed data with array of primitives (uint256[])", () =>
			Effect.gen(function* () {
				const typedData = TypedData.from({
					types: {
						EIP712Domain: [
							{ name: "name", type: "string" },
							{ name: "version", type: "string" },
							{ name: "chainId", type: "uint256" },
						],
						Batch: [
							{ name: "amounts", type: "uint256[]" },
							{ name: "nonce", type: "uint256" },
						],
					},
					primaryType: "Batch",
					domain: {
						name: "BatchApp",
						version: "1",
						chainId: 1,
					},
					message: {
						amounts: [
							1000000000000000000n,
							2000000000000000000n,
							3000000000000000000n,
						],
						nonce: 42n,
					},
				});

				const account = yield* AccountService;
				const signature = yield* account.signTypedData(typedData);
				expect(signature).toBeDefined();
				expect(Signature.toHex(signature)).toMatch(/^0x[0-9a-f]{130}$/);
			}).pipe(
				Effect.provide(LocalAccount(TEST_PRIVATE_KEY)),
				Effect.provide(CryptoTest),
			),
		);

		it.effect("signs typed data with fixed-size array (uint256[3])", () =>
			Effect.gen(function* () {
				const typedData = TypedData.from({
					types: {
						EIP712Domain: [
							{ name: "name", type: "string" },
							{ name: "version", type: "string" },
							{ name: "chainId", type: "uint256" },
						],
						Vector: [
							{ name: "components", type: "uint256[3]" },
							{ name: "magnitude", type: "uint256" },
						],
					},
					primaryType: "Vector",
					domain: {
						name: "Math",
						version: "1",
						chainId: 1,
					},
					message: {
						components: [10n, 20n, 30n],
						magnitude: 37n,
					},
				});

				const account = yield* AccountService;
				const signature = yield* account.signTypedData(typedData);
				expect(signature).toBeDefined();
				expect(Signature.toHex(signature)).toMatch(/^0x[0-9a-f]{130}$/);
			}).pipe(
				Effect.provide(LocalAccount(TEST_PRIVATE_KEY)),
				Effect.provide(CryptoTest),
			),
		);

		it.effect("signs typed data with array of structs (Person[])", () =>
			Effect.gen(function* () {
				const typedData = TypedData.from({
					types: {
						EIP712Domain: [
							{ name: "name", type: "string" },
							{ name: "version", type: "string" },
							{ name: "chainId", type: "uint256" },
						],
						Person: [
							{ name: "name", type: "string" },
							{ name: "wallet", type: "address" },
						],
						Group: [
							{ name: "members", type: "Person[]" },
							{ name: "name", type: "string" },
						],
					},
					primaryType: "Group",
					domain: {
						name: "GroupApp",
						version: "1",
						chainId: 1,
					},
					message: {
						members: [
							{
								name: "Alice",
								wallet: Address.fromHex(
									"0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826",
								),
							},
							{
								name: "Bob",
								wallet: Address.fromHex(
									"0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB",
								),
							},
						],
						name: "Team Alpha",
					},
				});

				const account = yield* AccountService;
				const signature = yield* account.signTypedData(typedData);
				expect(signature).toBeDefined();
				expect(Signature.toHex(signature)).toMatch(/^0x[0-9a-f]{130}$/);
			}).pipe(
				Effect.provide(LocalAccount(TEST_PRIVATE_KEY)),
				Effect.provide(CryptoTest),
			),
		);

		it.effect("signs typed data with deeply nested types", () =>
			Effect.gen(function* () {
				const typedData = TypedData.from({
					types: {
						EIP712Domain: [
							{ name: "name", type: "string" },
							{ name: "version", type: "string" },
							{ name: "chainId", type: "uint256" },
						],
						Coordinate: [
							{ name: "x", type: "int256" },
							{ name: "y", type: "int256" },
						],
						Location: [
							{ name: "name", type: "string" },
							{ name: "position", type: "Coordinate" },
						],
						Route: [
							{ name: "start", type: "Location" },
							{ name: "end", type: "Location" },
							{ name: "distance", type: "uint256" },
						],
					},
					primaryType: "Route",
					domain: {
						name: "Navigation",
						version: "1",
						chainId: 1,
					},
					message: {
						start: {
							name: "Home",
							position: { x: 100n, y: 200n },
						},
						end: {
							name: "Work",
							position: { x: 500n, y: 600n },
						},
						distance: 1000n,
					},
				});

				const account = yield* AccountService;
				const signature = yield* account.signTypedData(typedData);
				expect(signature).toBeDefined();
				expect(Signature.toHex(signature)).toMatch(/^0x[0-9a-f]{130}$/);
			}).pipe(
				Effect.provide(LocalAccount(TEST_PRIVATE_KEY)),
				Effect.provide(CryptoTest),
			),
		);

		it.effect("signs EIP-2612 Permit typed data", () =>
			Effect.gen(function* () {
				const typedData = TypedData.from({
					types: {
						EIP712Domain: [
							{ name: "name", type: "string" },
							{ name: "version", type: "string" },
							{ name: "chainId", type: "uint256" },
							{ name: "verifyingContract", type: "address" },
						],
						Permit: [
							{ name: "owner", type: "address" },
							{ name: "spender", type: "address" },
							{ name: "value", type: "uint256" },
							{ name: "nonce", type: "uint256" },
							{ name: "deadline", type: "uint256" },
						],
					},
					primaryType: "Permit",
					domain: {
						name: "USDC",
						version: "2",
						chainId: 1,
						verifyingContract: Address.fromHex(
							"0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48",
						),
					},
					message: {
						owner: Address.fromHex(
							"0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266",
						),
						spender: Address.fromHex(
							"0x0000000000000000000000000000000000000001",
						),
						value: 1000000n,
						nonce: 0n,
						deadline: 1893456000n,
					},
				});

				const account = yield* AccountService;
				const signature = yield* account.signTypedData(typedData);
				expect(signature).toBeDefined();
				expect(Signature.toHex(signature)).toMatch(/^0x[0-9a-f]{130}$/);
			}).pipe(
				Effect.provide(LocalAccount(TEST_PRIVATE_KEY)),
				Effect.provide(CryptoTest),
			),
		);
	});

	describe("JsonRpcAccount", () => {
		const mockAddress = Address.fromHex(
			"0x742d35Cc6634C0532925a3b844Bc9e7595f251e3",
		);
		const mockSignature = ("0x" +
			"00".repeat(32) +
			"00".repeat(32) +
			"1b") as HexType;

		const mockTransport = {
			request: <T>(method: string, _params?: unknown[]) => {
				if (method === "personal_sign") {
					return Effect.succeed(mockSignature as unknown as T);
				}
				if (method === "eth_sign") {
					return Effect.succeed(mockSignature as unknown as T);
				}
				if (method === "eth_signTransaction") {
					return Effect.succeed(mockSignature as unknown as T);
				}
				if (method === "eth_signTypedData_v4") {
					return Effect.succeed(mockSignature as unknown as T);
				}
				if (method === "wallet_signAuthorization") {
					return Effect.succeed({
						chainId: "0x1",
						address: "0x0000000000000000000000000000000000000001",
						nonce: "0x0",
						yParity: "0x0",
						r: `0x${"00".repeat(32)}`,
						s: `0x${"00".repeat(32)}`,
					} as unknown as T);
				}
				return Effect.fail(
					new TransportError({
						code: -32601,
						message: `Unknown method: ${method}`,
					}),
				);
			},
		};

		const transportLayer = Layer.succeed(TransportService, mockTransport);

		it.effect("has correct address", () =>
			Effect.gen(function* () {
				const account = yield* AccountService;
				expect(Address.equals(account.address, mockAddress)).toBe(true);
			}).pipe(
				Effect.provide(JsonRpcAccount(mockAddress)),
				Effect.provide(transportLayer),
			),
		);

		it.effect('has type "json-rpc"', () =>
			Effect.gen(function* () {
				const account = yield* AccountService;
				expect(account.type).toBe("json-rpc");
			}).pipe(
				Effect.provide(JsonRpcAccount(mockAddress)),
				Effect.provide(transportLayer),
			),
		);

		it.effect("publicKey is undefined for JSON-RPC accounts", () =>
			Effect.gen(function* () {
				const account = yield* AccountService;
				expect(account.publicKey).toBeUndefined();
			}).pipe(
				Effect.provide(JsonRpcAccount(mockAddress)),
				Effect.provide(transportLayer),
			),
		);

		it.effect("delegates sign({ hash }) to eth_sign", () =>
			Effect.gen(function* () {
				const account = yield* AccountService;
				const signature = yield* account.sign({ hash: TEST_HASH });
				expect(signature).toBeDefined();
			}).pipe(
				Effect.provide(JsonRpcAccount(mockAddress)),
				Effect.provide(transportLayer),
			),
		);

		it.effect("clearKey() is a no-op for JSON-RPC accounts", () =>
			Effect.gen(function* () {
				const account = yield* AccountService;
				// Should complete without error
				yield* account.clearKey();
			}).pipe(
				Effect.provide(JsonRpcAccount(mockAddress)),
				Effect.provide(transportLayer),
			),
		);

		it.effect("delegates signMessage to transport", () =>
			Effect.gen(function* () {
				const message = "0x48656c6c6f" as HexType;
				const account = yield* AccountService;
				const signature = yield* account.signMessage(message);
				expect(signature).toBeDefined();
			}).pipe(
				Effect.provide(JsonRpcAccount(mockAddress)),
				Effect.provide(transportLayer),
			),
		);

		it.effect("delegates signTransaction to transport", () =>
			Effect.gen(function* () {
				const tx: UnsignedTransaction = {
					to: Address.fromHex("0x0000000000000000000000000000000000000001"),
					value: 1000000000000000000n,
					nonce: 0n,
					gasLimit: 21000n,
					chainId: 1n,
				};

				const account = yield* AccountService;
				const signature = yield* account.signTransaction(tx);
				expect(signature).toBeDefined();
			}).pipe(
				Effect.provide(JsonRpcAccount(mockAddress)),
				Effect.provide(transportLayer),
			),
		);

		it.effect("delegates signTypedData to transport", () =>
			Effect.gen(function* () {
				const typedData = TypedData.from({
					types: {
						EIP712Domain: [
							{ name: "name", type: "string" },
							{ name: "version", type: "string" },
							{ name: "chainId", type: "uint256" },
						],
						Person: [
							{ name: "name", type: "string" },
							{ name: "wallet", type: "address" },
						],
					},
					primaryType: "Person",
					domain: {
						name: "Test",
						version: "1",
						chainId: 1,
					},
					message: {
						name: "Alice",
						wallet: Address.fromHex(
							"0x0000000000000000000000000000000000000001",
						),
					},
				});

				const account = yield* AccountService;
				const signature = yield* account.signTypedData(typedData);
				expect(signature).toBeDefined();
			}).pipe(
				Effect.provide(JsonRpcAccount(mockAddress)),
				Effect.provide(transportLayer),
			),
		);

		it.effect("signAuthorization fails when nonce is missing", () =>
			Effect.gen(function* () {
				const account = yield* AccountService;
				const result = yield* Effect.either(
					account.signAuthorization({
						contractAddress: "0x000000000000000000000000000000000000dead",
						chainId: 1n,
					}),
				);
				expect(result._tag).toBe("Left");
				if (result._tag === "Left") {
					expect(result.left._tag).toBe("AccountError");
					expect(result.left.cause).toBeInstanceOf(Error);
					expect(result.left.cause?.message).toContain(
						"Authorization nonce is required",
					);
				}
			}).pipe(
				Effect.provide(JsonRpcAccount(mockAddress)),
				Effect.provide(transportLayer),
			),
		);
	});

	describe("AccountError", () => {
		it("has correct tag", () => {
			const error = new AccountError({ action: "signMessage" }, "test message");
			expect(error._tag).toBe("AccountError");
			expect(error.name).toBe("AccountError");
			expect(error.message).toBe("test message");
			expect(error.input).toEqual({ action: "signMessage" });
		});

		it("chains cause", () => {
			const cause = new Error("original");
			const error = new AccountError({ action: "signTransaction" }, "wrapped", {
				cause,
			});
			expect(error.cause).toBe(cause);
		});
	});
});

```
