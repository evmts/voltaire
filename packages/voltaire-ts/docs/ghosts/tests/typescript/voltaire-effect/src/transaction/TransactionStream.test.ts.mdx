---
title: '[TS/JS] voltaire-effect/src/transaction/TransactionStream.test.ts'
source: 'voltaire-effect/src/transaction/TransactionStream.test.ts'
---

> Auto-generated from test file: voltaire-effect/src/transaction/TransactionStream.test.ts

```typescript
/**
 * @fileoverview Tests for TransactionStream helpers.
 */

import { describe, expect, it } from "@effect/vitest";
import * as Effect from "effect/Effect";
import * as Layer from "effect/Layer";
import * as Stream from "effect/Stream";
import {
	TransportError,
	TransportService,
	type TransportShape,
} from "../services/Transport/index.js";
import { makeTransactionStream } from "./TransactionStream.js";
import { TransactionStreamError } from "./TransactionStreamError.js";

describe("TransactionStream", () => {
	describe("TransactionStreamError", () => {
		it("creates error with message", () => {
			const error = new TransactionStreamError("test error");
			expect(error.message).toBe("test error");
			expect(error._tag).toBe("TransactionStreamError");
		});

		it("creates error with cause", () => {
			const cause = new Error("underlying");
			const error = new TransactionStreamError("test error", { cause });
			expect(error.message).toContain("test error");
			expect(error.cause).toBe(cause);
		});

		it("creates error with context", () => {
			const error = new TransactionStreamError("test error", {
				context: { txHash: "0x123", confirmations: 3 },
			});
			expect(error.message).toBe("test error");
			expect(error._tag).toBe("TransactionStreamError");
		});

		it("has correct name property", () => {
			const error = new TransactionStreamError("test");
			expect(error.name).toBe("TransactionStreamError");
		});

		it("is instanceof Error", () => {
			const error = new TransactionStreamError("test");
			expect(error instanceof Error).toBe(true);
		});

		it("preserves cause chain", () => {
			const rootCause = new Error("root");
			const intermediateCause = new Error("intermediate", { cause: rootCause });
			const error = new TransactionStreamError("top level", {
				cause: intermediateCause,
			});
			expect(error.cause).toBe(intermediateCause);
			expect((error.cause as Error).cause).toBe(rootCause);
		});

		it("has stack trace", () => {
			const error = new TransactionStreamError("test");
			expect(error.stack).toBeDefined();
			expect(error.stack).toContain("TransactionStreamError");
		});

		it("handles empty message", () => {
			const error = new TransactionStreamError("");
			expect(error.message).toBe("");
			expect(error._tag).toBe("TransactionStreamError");
		});

		it("handles long error messages", () => {
			const longMessage = "x".repeat(10000);
			const error = new TransactionStreamError(longMessage);
			expect(error.message).toBe(longMessage);
		});
	});

	describe("makeTransactionStream", () => {
		it("provides transaction streaming from TransportService", async () => {
			const mockTransport: TransportShape = {
				request: <T>(
					_method: string,
					_params?: unknown[],
				): Effect.Effect<T, never> => Effect.succeed("0x1" as T),
			};

			const TestTransportLayer = Layer.succeed(TransportService, mockTransport);

			const program = Effect.gen(function* () {
				const txStream = yield* makeTransactionStream();
				expect(txStream.watchPending).toBeDefined();
				expect(txStream.watchConfirmed).toBeDefined();
				expect(txStream.track).toBeDefined();
				expect(typeof txStream.watchPending).toBe("function");
				expect(typeof txStream.watchConfirmed).toBe("function");
				expect(typeof txStream.track).toBe("function");
			}).pipe(Effect.provide(TestTransportLayer));

			await Effect.runPromise(program);
		});

		it("watchPending returns a stream", async () => {
			const mockTransport: TransportShape = {
				request: <T>(
					_method: string,
					_params?: unknown[],
				): Effect.Effect<T, never> => Effect.succeed([] as T),
			};

			const TestTransportLayer = Layer.succeed(TransportService, mockTransport);

			const program = Effect.gen(function* () {
				const txStream = yield* makeTransactionStream();
				const stream = txStream.watchPending();
				expect(stream).toBeDefined();
			}).pipe(Effect.provide(TestTransportLayer));

			await Effect.runPromise(program);
		});

		it("watchConfirmed returns a stream", async () => {
			const mockTransport: TransportShape = {
				request: <T>(
					_method: string,
					_params?: unknown[],
				): Effect.Effect<T, never> => Effect.succeed("0x1" as T),
			};

			const TestTransportLayer = Layer.succeed(TransportService, mockTransport);

			const program = Effect.gen(function* () {
				const txStream = yield* makeTransactionStream();
				const stream = txStream.watchConfirmed({ confirmations: 3 });
				expect(stream).toBeDefined();
			}).pipe(Effect.provide(TestTransportLayer));

			await Effect.runPromise(program);
		});

		it("track returns a stream", async () => {
			const mockTransport: TransportShape = {
				request: <T>(
					_method: string,
					_params?: unknown[],
				): Effect.Effect<T, never> => Effect.succeed(null as T),
			};

			const TestTransportLayer = Layer.succeed(TransportService, mockTransport);

			const program = Effect.gen(function* () {
				const txStream = yield* makeTransactionStream();
				const stream = txStream.track(
					"0x1234567890123456789012345678901234567890123456789012345678901234",
				);
				expect(stream).toBeDefined();
			}).pipe(Effect.provide(TestTransportLayer));

			await Effect.runPromise(program);
		});

		it("watchPending with options", async () => {
			const mockTransport: TransportShape = {
				request: <T>(
					_method: string,
					_params?: unknown[],
				): Effect.Effect<T, never> => Effect.succeed([] as T),
			};

			const TestTransportLayer = Layer.succeed(TransportService, mockTransport);

			const program = Effect.gen(function* () {
				const txStream = yield* makeTransactionStream();
				const stream = txStream.watchPending({
					filter: { to: "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48" },
				});
				expect(stream).toBeDefined();
			}).pipe(Effect.provide(TestTransportLayer));

			await Effect.runPromise(program);
		});

		it("watchConfirmed with custom confirmations", async () => {
			const mockTransport: TransportShape = {
				request: <T>(
					_method: string,
					_params?: unknown[],
				): Effect.Effect<T, never> => Effect.succeed("0x1" as T),
			};

			const TestTransportLayer = Layer.succeed(TransportService, mockTransport);

			const program = Effect.gen(function* () {
				const txStream = yield* makeTransactionStream();
				const stream1 = txStream.watchConfirmed({ confirmations: 1 });
				const stream12 = txStream.watchConfirmed({ confirmations: 12 });
				expect(stream1).toBeDefined();
				expect(stream12).toBeDefined();
			}).pipe(Effect.provide(TestTransportLayer));

			await Effect.runPromise(program);
		});

		it("track with options", async () => {
			const mockTransport: TransportShape = {
				request: <T>(
					_method: string,
					_params?: unknown[],
				): Effect.Effect<T, never> => Effect.succeed(null as T),
			};

			const TestTransportLayer = Layer.succeed(TransportService, mockTransport);

			const program = Effect.gen(function* () {
				const txStream = yield* makeTransactionStream();
				const stream = txStream.track(
					"0x1234567890123456789012345678901234567890123456789012345678901234",
					{ confirmations: 6 },
				);
				expect(stream).toBeDefined();
			}).pipe(Effect.provide(TestTransportLayer));

			await Effect.runPromise(program);
		});

		it("track accepts Uint8Array hash", async () => {
			const mockTransport: TransportShape = {
				request: <T>(
					_method: string,
					_params?: unknown[],
				): Effect.Effect<T, never> => Effect.succeed(null as T),
			};

			const TestTransportLayer = Layer.succeed(TransportService, mockTransport);

			const program = Effect.gen(function* () {
				const txStream = yield* makeTransactionStream();
				const hashBytes = new Uint8Array(32).fill(0x12);
				const stream = txStream.track(hashBytes);
				expect(stream).toBeDefined();
			}).pipe(Effect.provide(TestTransportLayer));

			await Effect.runPromise(program);
		});
	});

	describe("error handling", () => {
		it("wraps transport errors as TransactionStreamError", async () => {
			const mockTransport: TransportShape = {
				request: <T>(
					_method: string,
					_params?: unknown[],
				): Effect.Effect<T, TransportError> =>
					Effect.fail(
						new TransportError({
							code: -32000,
							message: "RPC connection failed",
						}),
					),
			};

			const TestTransportLayer = Layer.succeed(TransportService, mockTransport);

			const program = Effect.gen(function* () {
				const txStream = yield* makeTransactionStream();
				const stream = txStream.track(
					"0x1234567890123456789012345678901234567890123456789012345678901234",
				);
				yield* Stream.runCollect(stream);
			}).pipe(Effect.provide(TestTransportLayer));

			const result = await Effect.runPromiseExit(program);
			expect(result._tag).toBe("Failure");
		});
	});

	describe("stream lifecycle", () => {
		it("multiple streams can be created from same service", async () => {
			const mockTransport: TransportShape = {
				request: <T>(
					_method: string,
					_params?: unknown[],
				): Effect.Effect<T, never> => Effect.succeed("0x1" as T),
			};

			const TestTransportLayer = Layer.succeed(TransportService, mockTransport);

			const program = Effect.gen(function* () {
				const txStream = yield* makeTransactionStream();
				const stream1 = txStream.watchPending();
				const stream2 = txStream.watchConfirmed();
				const stream3 = txStream.track(
					"0x1234567890123456789012345678901234567890123456789012345678901234",
				);
				expect(stream1).toBeDefined();
				expect(stream2).toBeDefined();
				expect(stream3).toBeDefined();
			}).pipe(Effect.provide(TestTransportLayer));

			await Effect.runPromise(program);
		});
	});

	describe("exports", () => {
		it("exports from index", async () => {
			const {
				TransactionStream,
				TransactionStreamError,
				makeTransactionStream,
			} = await import("./index.js");
			expect(TransactionStream).toBeDefined();
			expect(TransactionStreamError).toBeDefined();
			expect(makeTransactionStream).toBeDefined();
		});
	});

	describe("confirmation logic", () => {
		it("confirmations: 0 emits immediately when mined", async () => {
			let _requestCount = 0;
			const mockTransport: TransportShape = {
				request: <T>(
					method: string,
					params?: unknown[],
				): Effect.Effect<T, never> => {
					_requestCount++;
					if (method === "eth_blockNumber") {
						return Effect.succeed("0x10" as T); // block 16
					}
					if (method === "eth_getTransactionByHash") {
						return Effect.succeed({
							hash: params?.[0],
							blockNumber: "0x10",
							blockHash: `0x${"ab".repeat(32)}`,
							transactionIndex: "0x0",
							from: `0x${"11".repeat(20)}`,
							to: `0x${"22".repeat(20)}`,
							value: "0x0",
							gas: "0x5208",
							gasPrice: "0x3b9aca00",
							nonce: "0x1",
							input: "0x",
						} as T);
					}
					if (method === "eth_getTransactionReceipt") {
						return Effect.succeed({
							transactionHash: params?.[0],
							transactionIndex: "0x0",
							blockHash: `0x${"ab".repeat(32)}`,
							blockNumber: "0x10",
							from: `0x${"11".repeat(20)}`,
							to: `0x${"22".repeat(20)}`,
							cumulativeGasUsed: "0x5208",
							gasUsed: "0x5208",
							contractAddress: null,
							logs: [],
							logsBloom: `0x${"00".repeat(256)}`,
							status: "0x1",
							effectiveGasPrice: "0x3b9aca00",
							type: "0x2",
						} as T);
					}
					return Effect.succeed(null as T);
				},
			};

			const TestTransportLayer = Layer.succeed(TransportService, mockTransport);

			const program = Effect.gen(function* () {
				const txStream = yield* makeTransactionStream();
				const stream = txStream.track(
					"0x1234567890123456789012345678901234567890123456789012345678901234",
					{ confirmations: 0 },
				);
				const events = yield* Stream.take(stream, 1).pipe(Stream.runCollect);
				expect(events.length).toBeGreaterThan(0);
			}).pipe(Effect.provide(TestTransportLayer));

			await Effect.runPromise(program);
		});

		it("confirmations: 1 emits after 1 block confirmation", async () => {
			const mockTransport: TransportShape = {
				request: <T>(
					method: string,
					params?: unknown[],
				): Effect.Effect<T, never> => {
					if (method === "eth_blockNumber") {
						return Effect.succeed("0x11" as T); // block 17, tx in block 16 = 2 confirms
					}
					if (method === "eth_getTransactionByHash") {
						return Effect.succeed({
							hash: params?.[0],
							blockNumber: "0x10", // block 16
							blockHash: `0x${"ab".repeat(32)}`,
							transactionIndex: "0x0",
							from: `0x${"11".repeat(20)}`,
							to: `0x${"22".repeat(20)}`,
							value: "0x0",
							gas: "0x5208",
							gasPrice: "0x3b9aca00",
							nonce: "0x1",
							input: "0x",
						} as T);
					}
					if (method === "eth_getTransactionReceipt") {
						return Effect.succeed({
							transactionHash: params?.[0],
							transactionIndex: "0x0",
							blockHash: `0x${"ab".repeat(32)}`,
							blockNumber: "0x10",
							from: `0x${"11".repeat(20)}`,
							to: `0x${"22".repeat(20)}`,
							cumulativeGasUsed: "0x5208",
							gasUsed: "0x5208",
							contractAddress: null,
							logs: [],
							logsBloom: `0x${"00".repeat(256)}`,
							status: "0x1",
							effectiveGasPrice: "0x3b9aca00",
							type: "0x2",
						} as T);
					}
					return Effect.succeed(null as T);
				},
			};

			const TestTransportLayer = Layer.succeed(TransportService, mockTransport);

			const program = Effect.gen(function* () {
				const txStream = yield* makeTransactionStream();
				const stream = txStream.track(
					"0x1234567890123456789012345678901234567890123456789012345678901234",
					{ confirmations: 1 },
				);
				const events = yield* Stream.take(stream, 1).pipe(Stream.runCollect);
				expect(events.length).toBeGreaterThan(0);
			}).pipe(Effect.provide(TestTransportLayer));

			await Effect.runPromise(program);
		});

		it("confirmations: 12 waits for 12 blocks before emitting confirmed", async () => {
			let blockNumber = 16;
			const mockTransport: TransportShape = {
				request: <T>(
					method: string,
					params?: unknown[],
				): Effect.Effect<T, never> => {
					if (method === "eth_blockNumber") {
						// Start at block 16, tx in block 10, so 7 confirms initially
						// Need 12 confirms: block 21+ (10 + 12 - 1 = 21)
						blockNumber++;
						return Effect.succeed(`0x${blockNumber.toString(16)}` as T);
					}
					if (method === "eth_getTransactionByHash") {
						return Effect.succeed({
							hash: params?.[0],
							blockNumber: "0xa", // block 10
							blockHash: `0x${"ab".repeat(32)}`,
							transactionIndex: "0x0",
							from: `0x${"11".repeat(20)}`,
							to: `0x${"22".repeat(20)}`,
							value: "0x0",
							gas: "0x5208",
							gasPrice: "0x3b9aca00",
							nonce: "0x1",
							input: "0x",
						} as T);
					}
					if (method === "eth_getTransactionReceipt") {
						return Effect.succeed({
							transactionHash: params?.[0],
							transactionIndex: "0x0",
							blockHash: `0x${"ab".repeat(32)}`,
							blockNumber: "0xa",
							from: `0x${"11".repeat(20)}`,
							to: `0x${"22".repeat(20)}`,
							cumulativeGasUsed: "0x5208",
							gasUsed: "0x5208",
							contractAddress: null,
							logs: [],
							logsBloom: `0x${"00".repeat(256)}`,
							status: "0x1",
							effectiveGasPrice: "0x3b9aca00",
							type: "0x2",
						} as T);
					}
					return Effect.succeed(null as T);
				},
			};

			const TestTransportLayer = Layer.succeed(TransportService, mockTransport);

			const program = Effect.gen(function* () {
				const txStream = yield* makeTransactionStream();
				const stream = txStream.track(
					"0x1234567890123456789012345678901234567890123456789012345678901234",
					{ confirmations: 12, pollingInterval: 1 },
				);
				const events = yield* Stream.take(stream, 1).pipe(Stream.runCollect);
				expect(events.length).toBe(1);
			}).pipe(Effect.provide(TestTransportLayer));

			await Effect.runPromise(program);
		});
	});

	describe("RPC null handling", () => {
		it("eth_getTransactionReceipt returns null then non-null", async () => {
			let receiptCallCount = 0;
			const mockTransport: TransportShape = {
				request: <T>(
					method: string,
					params?: unknown[],
				): Effect.Effect<T, never> => {
					if (method === "eth_blockNumber") {
						return Effect.succeed("0x15" as T);
					}
					if (method === "eth_getTransactionByHash") {
						return Effect.succeed({
							hash: params?.[0],
							blockNumber: "0x10",
							blockHash: `0x${"ab".repeat(32)}`,
							transactionIndex: "0x0",
							from: `0x${"11".repeat(20)}`,
							to: `0x${"22".repeat(20)}`,
							value: "0x0",
							gas: "0x5208",
							gasPrice: "0x3b9aca00",
							nonce: "0x1",
							input: "0x",
						} as T);
					}
					if (method === "eth_getTransactionReceipt") {
						receiptCallCount++;
						// Return null first 2 times, then receipt
						if (receiptCallCount <= 2) {
							return Effect.succeed(null as T);
						}
						return Effect.succeed({
							transactionHash: params?.[0],
							transactionIndex: "0x0",
							blockHash: `0x${"ab".repeat(32)}`,
							blockNumber: "0x10",
							from: `0x${"11".repeat(20)}`,
							to: `0x${"22".repeat(20)}`,
							cumulativeGasUsed: "0x5208",
							gasUsed: "0x5208",
							contractAddress: null,
							logs: [],
							logsBloom: `0x${"00".repeat(256)}`,
							status: "0x1",
							effectiveGasPrice: "0x3b9aca00",
							type: "0x2",
						} as T);
					}
					return Effect.succeed(null as T);
				},
			};

			const TestTransportLayer = Layer.succeed(TransportService, mockTransport);

			const program = Effect.gen(function* () {
				const txStream = yield* makeTransactionStream();
				const stream = txStream.track(
					"0x1234567890123456789012345678901234567890123456789012345678901234",
					{ confirmations: 1, pollingInterval: 1 },
				);
				const events = yield* Stream.take(stream, 1).pipe(Stream.runCollect);
				expect(events.length).toBe(1);
				expect(receiptCallCount).toBeGreaterThan(2);
			}).pipe(Effect.provide(TestTransportLayer));

			await Effect.runPromise(program);
		});
	});

	describe("polling failures", () => {
		it("transient transport errors are handled gracefully", async () => {
			let callCount = 0;
			const mockTransport: TransportShape = {
				request: <T>(
					method: string,
					params?: unknown[],
				): Effect.Effect<T, TransportError> => {
					callCount++;
					// Fail first 2 calls, then succeed
					if (callCount <= 2) {
						return Effect.fail(
							new TransportError({ code: -32000, message: "Network timeout" }),
						);
					}
					if (method === "eth_blockNumber") {
						return Effect.succeed("0x15" as T);
					}
					if (method === "eth_getTransactionByHash") {
						return Effect.succeed({
							hash: params?.[0],
							blockNumber: "0x10",
							blockHash: `0x${"ab".repeat(32)}`,
							transactionIndex: "0x0",
							from: `0x${"11".repeat(20)}`,
							to: `0x${"22".repeat(20)}`,
							value: "0x0",
							gas: "0x5208",
							gasPrice: "0x3b9aca00",
							nonce: "0x1",
							input: "0x",
						} as T);
					}
					if (method === "eth_getTransactionReceipt") {
						return Effect.succeed({
							transactionHash: params?.[0],
							transactionIndex: "0x0",
							blockHash: `0x${"ab".repeat(32)}`,
							blockNumber: "0x10",
							from: `0x${"11".repeat(20)}`,
							to: `0x${"22".repeat(20)}`,
							cumulativeGasUsed: "0x5208",
							gasUsed: "0x5208",
							contractAddress: null,
							logs: [],
							logsBloom: `0x${"00".repeat(256)}`,
							status: "0x1",
							effectiveGasPrice: "0x3b9aca00",
							type: "0x2",
						} as T);
					}
					return Effect.succeed(null as T);
				},
			};

			const TestTransportLayer = Layer.succeed(TransportService, mockTransport);

			const program = Effect.gen(function* () {
				const txStream = yield* makeTransactionStream();
				const stream = txStream.track(
					"0x1234567890123456789012345678901234567890123456789012345678901234",
					{ confirmations: 1, pollingInterval: 1 },
				);
				const events = yield* Stream.take(stream, 1).pipe(Stream.runCollect);
				expect(events.length).toBe(1);
			}).pipe(Effect.provide(TestTransportLayer));

			await Effect.runPromise(program);
		});
	});

	describe("filtering", () => {
		it("watchPending with filter.to option filters transactions", async () => {
			const targetAddress = "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48";
			const mockTransport: TransportShape = {
				request: <T>(
					method: string,
					_params?: unknown[],
				): Effect.Effect<T, never> => {
					if (method === "eth_blockNumber") {
						return Effect.succeed("0x10" as T);
					}
					if (method === "eth_pendingTransactions") {
						return Effect.succeed([
							{
								hash: `0x${"aa".repeat(32)}`,
								from: `0x${"11".repeat(20)}`,
								to: targetAddress,
								value: "0x0",
								gas: "0x5208",
								gasPrice: "0x3b9aca00",
								nonce: "0x1",
								input: "0x",
							},
							{
								hash: `0x${"bb".repeat(32)}`,
								from: `0x${"11".repeat(20)}`,
								to: `0x${"99".repeat(20)}`, // different address
								value: "0x0",
								gas: "0x5208",
								gasPrice: "0x3b9aca00",
								nonce: "0x2",
								input: "0x",
							},
						] as T);
					}
					return Effect.succeed([] as T);
				},
			};

			const TestTransportLayer = Layer.succeed(TransportService, mockTransport);

			const program = Effect.gen(function* () {
				const txStream = yield* makeTransactionStream();
				const stream = txStream.watchPending({
					filter: { to: targetAddress },
				});
				expect(stream).toBeDefined();
			}).pipe(Effect.provide(TestTransportLayer));

			await Effect.runPromise(program);
		});
	});

	describe("transaction not found", () => {
		it("emits dropped event when transaction disappears after being pending", async () => {
			let txCallCount = 0;
			const mockTransport: TransportShape = {
				request: <T>(
					method: string,
					params?: unknown[],
				): Effect.Effect<T, never> => {
					if (method === "eth_blockNumber") {
						return Effect.succeed("0x10" as T);
					}
					if (method === "eth_getTransactionByHash") {
						txCallCount++;
						// First call: return pending tx
						if (txCallCount === 1) {
							return Effect.succeed({
								hash: params?.[0],
								from: `0x${"11".repeat(20)}`,
								to: `0x${"22".repeat(20)}`,
								value: "0x0",
								gas: "0x5208",
								gasPrice: "0x3b9aca00",
								nonce: "0x1",
								input: "0x",
							} as T);
						}
						// Subsequent calls: tx not found (dropped)
						return Effect.succeed(null as T);
					}
					return Effect.succeed(null as T);
				},
			};

			const TestTransportLayer = Layer.succeed(TransportService, mockTransport);

			const program = Effect.gen(function* () {
				const txStream = yield* makeTransactionStream();
				const stream = txStream.track(
					"0x1234567890123456789012345678901234567890123456789012345678901234",
					{ confirmations: 1, pollingInterval: 1 },
				);
				const events = yield* Stream.take(stream, 2).pipe(Stream.runCollect);
				expect(events.length).toBe(2);
				const eventArray = Array.from(events);
				expect(eventArray[0].type).toBe("pending");
				expect(eventArray[1].type).toBe("dropped");
			}).pipe(Effect.provide(TestTransportLayer));

			await Effect.runPromise(program);
		});
	});

	describe("receipt status", () => {
		it("handles successful transaction (status 0x1)", async () => {
			const mockTransport: TransportShape = {
				request: <T>(
					method: string,
					params?: unknown[],
				): Effect.Effect<T, never> => {
					if (method === "eth_blockNumber") {
						return Effect.succeed("0x15" as T);
					}
					if (method === "eth_getTransactionByHash") {
						return Effect.succeed({
							hash: params?.[0],
							blockNumber: "0x10",
							blockHash: `0x${"ab".repeat(32)}`,
							transactionIndex: "0x0",
							from: `0x${"11".repeat(20)}`,
							to: `0x${"22".repeat(20)}`,
							value: "0x0",
							gas: "0x5208",
							gasPrice: "0x3b9aca00",
							nonce: "0x1",
							input: "0x",
						} as T);
					}
					if (method === "eth_getTransactionReceipt") {
						return Effect.succeed({
							transactionHash: params?.[0],
							transactionIndex: "0x0",
							blockHash: `0x${"ab".repeat(32)}`,
							blockNumber: "0x10",
							from: `0x${"11".repeat(20)}`,
							to: `0x${"22".repeat(20)}`,
							cumulativeGasUsed: "0x5208",
							gasUsed: "0x5208",
							contractAddress: null,
							logs: [],
							logsBloom: `0x${"00".repeat(256)}`,
							status: "0x1", // success
							effectiveGasPrice: "0x3b9aca00",
							type: "0x2",
						} as T);
					}
					return Effect.succeed(null as T);
				},
			};

			const TestTransportLayer = Layer.succeed(TransportService, mockTransport);

			const program = Effect.gen(function* () {
				const txStream = yield* makeTransactionStream();
				const stream = txStream.track(
					"0x1234567890123456789012345678901234567890123456789012345678901234",
					{ confirmations: 1 },
				);
				const events = yield* Stream.take(stream, 1).pipe(Stream.runCollect);
				expect(events.length).toBe(1);
				const event = Array.from(events)[0];
				expect(event.type).toBe("confirmed");
				if (event.type === "confirmed") {
					expect(event.transaction.receipt.status).toBe(1);
				}
			}).pipe(Effect.provide(TestTransportLayer));

			await Effect.runPromise(program);
		});

		it("handles reverted transaction (status 0x0)", async () => {
			const mockTransport: TransportShape = {
				request: <T>(
					method: string,
					params?: unknown[],
				): Effect.Effect<T, never> => {
					if (method === "eth_blockNumber") {
						return Effect.succeed("0x15" as T);
					}
					if (method === "eth_getTransactionByHash") {
						return Effect.succeed({
							hash: params?.[0],
							blockNumber: "0x10",
							blockHash: `0x${"ab".repeat(32)}`,
							transactionIndex: "0x0",
							from: `0x${"11".repeat(20)}`,
							to: `0x${"22".repeat(20)}`,
							value: "0x0",
							gas: "0x5208",
							gasPrice: "0x3b9aca00",
							nonce: "0x1",
							input: "0x",
						} as T);
					}
					if (method === "eth_getTransactionReceipt") {
						return Effect.succeed({
							transactionHash: params?.[0],
							transactionIndex: "0x0",
							blockHash: `0x${"ab".repeat(32)}`,
							blockNumber: "0x10",
							from: `0x${"11".repeat(20)}`,
							to: `0x${"22".repeat(20)}`,
							cumulativeGasUsed: "0x5208",
							gasUsed: "0x5208",
							contractAddress: null,
							logs: [],
							logsBloom: `0x${"00".repeat(256)}`,
							status: "0x0", // reverted
							effectiveGasPrice: "0x3b9aca00",
							type: "0x2",
						} as T);
					}
					return Effect.succeed(null as T);
				},
			};

			const TestTransportLayer = Layer.succeed(TransportService, mockTransport);

			const program = Effect.gen(function* () {
				const txStream = yield* makeTransactionStream();
				const stream = txStream.track(
					"0x1234567890123456789012345678901234567890123456789012345678901234",
					{ confirmations: 1 },
				);
				const events = yield* Stream.take(stream, 1).pipe(Stream.runCollect);
				expect(events.length).toBe(1);
				const event = Array.from(events)[0];
				expect(event.type).toBe("confirmed");
				if (event.type === "confirmed") {
					expect(event.transaction.receipt.status).toBe(0);
				}
			}).pipe(Effect.provide(TestTransportLayer));

			await Effect.runPromise(program);
		});
	});
});

```
