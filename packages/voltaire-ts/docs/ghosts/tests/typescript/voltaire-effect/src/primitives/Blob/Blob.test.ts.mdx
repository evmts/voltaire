---
title: '[TS/JS] voltaire-effect/src/primitives/Blob/Blob.test.ts'
source: 'voltaire-effect/src/primitives/Blob/Blob.test.ts'
---

> Auto-generated from test file: voltaire-effect/src/primitives/Blob/Blob.test.ts

```typescript
import { describe, expect, it } from "@effect/vitest";
import { Effect } from "effect";
import {
	SIZE,
	FIELD_ELEMENTS_PER_BLOB,
	BYTES_PER_FIELD_ELEMENT,
	MAX_PER_TRANSACTION,
	MAX_DATA_PER_BLOB,
} from "./index.js";
import { from } from "./from.js";
import { fromData } from "./fromData.js";
import { isValid } from "./isValid.js";
import { isValidVersion } from "./isValidVersion.js";
import { toData } from "./toData.js";
import { calculateGas } from "./calculateGas.js";
import { estimateBlobCount } from "./estimateBlobCount.js";
import { splitData } from "./splitData.js";
import { joinData } from "./joinData.js";
import { toVersionedHash } from "./toVersionedHash.js";
import { toCommitment } from "./toCommitment.js";
import { toProof } from "./toProof.js";
import { verify } from "./verify.js";
import { verifyBatch } from "./verifyBatch.js";
import { BlobSchema } from "./BlobSchema.js";
import { KZGTest } from "../../crypto/KZG/KZGService.js";
import * as S from "effect/Schema";

describe("Blob", () => {
	describe("constants", () => {
		it("SIZE is 131072", () => {
			expect(SIZE).toBe(131072);
		});

		it("FIELD_ELEMENTS_PER_BLOB is 4096", () => {
			expect(FIELD_ELEMENTS_PER_BLOB).toBe(4096);
		});

		it("BYTES_PER_FIELD_ELEMENT is 32", () => {
			expect(BYTES_PER_FIELD_ELEMENT).toBe(32);
		});

		it("MAX_PER_TRANSACTION is 6", () => {
			expect(MAX_PER_TRANSACTION).toBe(6);
		});

		it("MAX_DATA_PER_BLOB is 126972", () => {
			expect(MAX_DATA_PER_BLOB).toBe(126972);
		});
	});

	describe("isValid", () => {
		it("returns true for 128KB blob", () => {
			const blob = new Uint8Array(SIZE);
			expect(isValid(blob)).toBe(true);
		});

		it("returns false for wrong size", () => {
			expect(isValid(new Uint8Array(100))).toBe(false);
			expect(isValid(new Uint8Array(SIZE + 1))).toBe(false);
		});
	});

	describe("from", () => {
		it.effect("returns blob if already valid size", () =>
			Effect.gen(function* () {
				const input = new Uint8Array(SIZE);
				const blob = yield* from(input);
				expect(blob.length).toBe(SIZE);
			}),
		);

		it.effect("encodes smaller data", () =>
			Effect.gen(function* () {
				const data = new TextEncoder().encode("Hello");
				const blob = yield* from(data);
				expect(blob.length).toBe(SIZE);
			}),
		);
	});

	describe("fromData", () => {
		it.effect("encodes data with padding", () =>
			Effect.gen(function* () {
				const data = new TextEncoder().encode("Hello, blob!");
				const blob = yield* fromData(data);
				expect(blob.length).toBe(SIZE);
			}),
		);

		it.effect("fails for data too large", () =>
			Effect.gen(function* () {
				const data = new Uint8Array(MAX_DATA_PER_BLOB + 1);
				const result = yield* Effect.either(fromData(data));
				expect(result._tag).toBe("Left");
			}),
		);
	});

	describe("toData", () => {
		it.effect("round-trips data correctly", () =>
			Effect.gen(function* () {
				const original = new TextEncoder().encode("Hello, blob!");
				const blob = yield* fromData(original);
				const extracted = toData(blob);
				expect(new TextDecoder().decode(extracted)).toBe("Hello, blob!");
			}),
		);
	});

	describe("isValidVersion", () => {
		it("returns true for valid KZG version", () => {
			const hash = new Uint8Array(32);
			hash[0] = 0x01;
			expect(isValidVersion(hash as any)).toBe(true);
		});

		it("returns false for wrong version", () => {
			const hash = new Uint8Array(32);
			hash[0] = 0x00;
			expect(isValidVersion(hash as any)).toBe(false);
		});

		it("returns false for wrong length", () => {
			const hash = new Uint8Array(31);
			hash[0] = 0x01;
			expect(isValidVersion(hash as any)).toBe(false);
		});
	});

	describe("calculateGas", () => {
		it.effect("calculates gas for valid count", () =>
			Effect.gen(function* () {
				const gas = yield* calculateGas(3);
				expect(gas).toBe(3 * 131072);
			}),
		);

		it.effect("returns 0 for 0 blobs", () =>
			Effect.gen(function* () {
				const gas = yield* calculateGas(0);
				expect(gas).toBe(0);
			}),
		);

		it.effect("fails for invalid count", () =>
			Effect.gen(function* () {
				const result = yield* Effect.either(calculateGas(7));
				expect(result._tag).toBe("Left");
			}),
		);
	});

	describe("estimateBlobCount", () => {
		it.effect("estimates correctly", () =>
			Effect.gen(function* () {
				const count = yield* estimateBlobCount(200000);
				expect(count).toBe(2);
			}),
		);

		it.effect("returns 0 for empty data", () =>
			Effect.gen(function* () {
				const count = yield* estimateBlobCount(0);
				expect(count).toBe(0);
			}),
		);

		it.effect("fails for negative size", () =>
			Effect.gen(function* () {
				const result = yield* Effect.either(estimateBlobCount(-1));
				expect(result._tag).toBe("Left");
			}),
		);
	});

	describe("splitData/joinData", () => {
		it.effect("round-trips large data", () =>
			Effect.gen(function* () {
				const original = new Uint8Array(200000);
				for (let i = 0; i < original.length; i++) {
					original[i] = i % 256;
				}
				const blobs = yield* splitData(original);
				expect(blobs.length).toBe(2);
				const rejoined = yield* joinData(blobs);
				expect(rejoined).toEqual(original);
			}),
		);

		it.effect("fails for data requiring too many blobs", () =>
			Effect.gen(function* () {
				const huge = new Uint8Array(MAX_DATA_PER_BLOB * 7);
				const result = yield* Effect.either(splitData(huge));
				expect(result._tag).toBe("Left");
			}),
		);
	});

	describe("toVersionedHash", () => {
		it.effect("creates versioned hash from commitment", () =>
			Effect.gen(function* () {
				const commitment = new Uint8Array(48);
				const hash = yield* toVersionedHash(commitment as any);
				expect(hash.length).toBe(32);
				expect(hash[0]).toBe(0x01);
			}),
		);

		it.effect("fails for invalid commitment size", () =>
			Effect.gen(function* () {
				const commitment = new Uint8Array(32);
				const result = yield* Effect.either(
					toVersionedHash(commitment as any),
				);
				expect(result._tag).toBe("Left");
			}),
		);
	});

	describe("KZG operations with KZGTest", () => {
		it.effect("toCommitment returns 48-byte commitment", () =>
			Effect.gen(function* () {
				const blob = yield* fromData(new Uint8Array(100));
				const commitment = yield* toCommitment(blob);
				expect(commitment.length).toBe(48);
			}).pipe(Effect.provide(KZGTest)),
		);

		it.effect("toProof returns 48-byte proof", () =>
			Effect.gen(function* () {
				const blob = yield* fromData(new Uint8Array(100));
				const commitment = yield* toCommitment(blob);
				const proof = yield* toProof(blob, commitment);
				expect(proof.length).toBe(48);
			}).pipe(Effect.provide(KZGTest)),
		);

		it.effect("verify returns true with test layer", () =>
			Effect.gen(function* () {
				const blob = yield* fromData(new Uint8Array(100));
				const commitment = yield* toCommitment(blob);
				const proof = yield* toProof(blob, commitment);
				const isValid = yield* verify(blob, commitment, proof);
				expect(isValid).toBe(true);
			}).pipe(Effect.provide(KZGTest)),
		);
	});

	describe("verifyBatch", () => {
		it.effect("fails with not implemented error", () =>
			Effect.gen(function* () {
				const blob = yield* fromData(new Uint8Array(100));
				const commitment = new Uint8Array(48) as any;
				const proof = new Uint8Array(48) as any;
				const result = yield* Effect.either(
					verifyBatch([blob], [commitment], [proof]),
				);
				expect(result._tag).toBe("Left");
				if (result._tag === "Left") {
					expect(result.left.name).toBe("BlobNotImplementedError");
				}
			}),
		);

		it.effect("validates array length mismatch", () =>
			Effect.gen(function* () {
				const blob = yield* fromData(new Uint8Array(100));
				const commitment = new Uint8Array(48) as any;
				const result = yield* Effect.either(
					verifyBatch([blob], [commitment], []),
				);
				expect(result._tag).toBe("Left");
				if (result._tag === "Left") {
					expect(result.left.name).toBe("BlobArrayLengthMismatchError");
				}
			}),
		);
	});

	describe("BlobSchema", () => {
		it("decodes valid blob", () => {
			const bytes = new Uint8Array(SIZE);
			const blob = S.decodeSync(BlobSchema)(bytes);
			expect(blob.length).toBe(SIZE);
		});

		it("fails for invalid size", () => {
			const bytes = new Uint8Array(100);
			expect(() => S.decodeSync(BlobSchema)(bytes)).toThrow();
		});
	});
});

```
