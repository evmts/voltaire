---
title: '[TS/JS] voltaire-effect/src/crypto/X25519/X25519.test.ts'
source: 'voltaire-effect/src/crypto/X25519/X25519.test.ts'
---

> Auto-generated from test file: voltaire-effect/src/crypto/X25519/X25519.test.ts

```typescript
import { describe, expect, it } from "@effect/vitest";
import * as VoltaireX25519 from "@tevm/voltaire/X25519";
import * as Effect from "effect/Effect";
import * as Exit from "effect/Exit";
import * as X25519Effect from "./index.js";

describe("X25519", () => {
	const testSeed = new Uint8Array(32).fill(0x42);
	const testKeypair = VoltaireX25519.keypairFromSeed(testSeed);

	describe("generateKeyPair", () => {
		it.effect("generates a valid keypair", () =>
			Effect.gen(function* () {
				const result = yield* X25519Effect.generateKeyPair();
				expect(result.secretKey).toBeInstanceOf(Uint8Array);
				expect(result.publicKey).toBeInstanceOf(Uint8Array);
				expect(result.secretKey.length).toBe(32);
				expect(result.publicKey.length).toBe(32);
			}),
		);

		it.effect("generates different keypairs each time", () =>
			Effect.gen(function* () {
				const kp1 = yield* X25519Effect.generateKeyPair();
				const kp2 = yield* X25519Effect.generateKeyPair();
				expect(kp1.secretKey).not.toEqual(kp2.secretKey);
				expect(kp1.publicKey).not.toEqual(kp2.publicKey);
			}),
		);
	});

	describe("getPublicKey", () => {
		it.effect("derives public key from secret key", () =>
			Effect.gen(function* () {
				const result = yield* X25519Effect.getPublicKey(testKeypair.secretKey);
				expect(result).toBeInstanceOf(Uint8Array);
				expect(result.length).toBe(32);
				expect(result).toEqual(testKeypair.publicKey);
			}),
		);

		it("fails with wrong key length", async () => {
			const wrongKey = new Uint8Array(16);
			const exit = await Effect.runPromiseExit(
				X25519Effect.getPublicKey(wrongKey),
			);
			expect(Exit.isFailure(exit)).toBe(true);
		});
	});

	describe("computeSecret", () => {
		it.effect("computes shared secret between two parties", () =>
			Effect.gen(function* () {
				const seed1 = new Uint8Array(32).fill(0x11);
				const seed2 = new Uint8Array(32).fill(0x22);
				const alice = VoltaireX25519.keypairFromSeed(seed1);
				const bob = VoltaireX25519.keypairFromSeed(seed2);
				const sharedAlice = yield* X25519Effect.computeSecret(
					alice.secretKey,
					bob.publicKey,
				);
				const sharedBob = yield* X25519Effect.computeSecret(
					bob.secretKey,
					alice.publicKey,
				);
				expect(sharedAlice).toBeInstanceOf(Uint8Array);
				expect(sharedAlice.length).toBe(32);
				expect(sharedAlice).toEqual(sharedBob);
			}),
		);

		it("fails with invalid secret key length", async () => {
			const wrongKey = new Uint8Array(16);
			const exit = await Effect.runPromiseExit(
				X25519Effect.computeSecret(wrongKey, testKeypair.publicKey),
			);
			expect(Exit.isFailure(exit)).toBe(true);
		});

		it("fails with invalid public key length", async () => {
			const wrongPub = new Uint8Array(16);
			const exit = await Effect.runPromiseExit(
				X25519Effect.computeSecret(testKeypair.secretKey, wrongPub),
			);
			expect(Exit.isFailure(exit)).toBe(true);
		});
	});

	describe("X25519Service", () => {
		it.effect("provides generateKeyPair through service layer", () =>
			Effect.gen(function* () {
				const x = yield* X25519Effect.X25519Service;
				const result = yield* x.generateKeyPair();
				expect(result.secretKey).toBeInstanceOf(Uint8Array);
				expect(result.publicKey).toBeInstanceOf(Uint8Array);
				expect(result.secretKey.length).toBe(32);
				expect(result.publicKey.length).toBe(32);
			}).pipe(Effect.provide(X25519Effect.X25519Live)),
		);

		it.effect("provides getPublicKey through service layer", () =>
			Effect.gen(function* () {
				const x = yield* X25519Effect.X25519Service;
				const result = yield* x.getPublicKey(testKeypair.secretKey);
				expect(result).toBeInstanceOf(Uint8Array);
				expect(result.length).toBe(32);
				expect(result).toEqual(testKeypair.publicKey);
			}).pipe(Effect.provide(X25519Effect.X25519Live)),
		);

		it.effect("provides computeSecret through service layer", () =>
			Effect.gen(function* () {
				const seed1 = new Uint8Array(32).fill(0x33);
				const seed2 = new Uint8Array(32).fill(0x44);
				const alice = VoltaireX25519.keypairFromSeed(seed1);
				const bob = VoltaireX25519.keypairFromSeed(seed2);
				const x = yield* X25519Effect.X25519Service;
				const sharedAlice = yield* x.computeSecret(
					alice.secretKey,
					bob.publicKey,
				);
				const sharedBob = yield* x.computeSecret(
					bob.secretKey,
					alice.publicKey,
				);
				expect(sharedAlice).toEqual(sharedBob);
			}).pipe(Effect.provide(X25519Effect.X25519Live)),
		);
	});

	describe("X25519Test", () => {
		it.effect("returns mock keypair", () =>
			Effect.gen(function* () {
				const x = yield* X25519Effect.X25519Service;
				const result = yield* x.generateKeyPair();
				expect(result.secretKey).toBeInstanceOf(Uint8Array);
				expect(result.publicKey).toBeInstanceOf(Uint8Array);
				expect(result.secretKey.length).toBe(32);
				expect(result.publicKey.length).toBe(32);
				expect(result.secretKey.every((b) => b === 0)).toBe(true);
				expect(result.publicKey.every((b) => b === 0)).toBe(true);
			}).pipe(Effect.provide(X25519Effect.X25519Test)),
		);

		it.effect("returns mock public key", () =>
			Effect.gen(function* () {
				const x = yield* X25519Effect.X25519Service;
				const result = yield* x.getPublicKey(testKeypair.secretKey);
				expect(result).toBeInstanceOf(Uint8Array);
				expect(result.length).toBe(32);
				expect(result.every((b) => b === 0)).toBe(true);
			}).pipe(Effect.provide(X25519Effect.X25519Test)),
		);

		it.effect("returns mock shared secret", () =>
			Effect.gen(function* () {
				const x = yield* X25519Effect.X25519Service;
				const result = yield* x.computeSecret(
					testKeypair.secretKey,
					testKeypair.publicKey,
				);
				expect(result).toBeInstanceOf(Uint8Array);
				expect(result.length).toBe(32);
				expect(result.every((b) => b === 0)).toBe(true);
			}).pipe(Effect.provide(X25519Effect.X25519Test)),
		);
	});
});

```
