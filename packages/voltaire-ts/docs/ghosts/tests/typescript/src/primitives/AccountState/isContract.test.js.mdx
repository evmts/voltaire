---
title: '[TS/JS] src/primitives/AccountState/isContract.test.js'
source: 'src/primitives/AccountState/isContract.test.js'
---

> Auto-generated from test file: src/primitives/AccountState/isContract.test.js

```javascript
import { describe, expect, it } from "vitest";
import { from as weiFrom } from "../Denomination/Wei.js";
import { Hash } from "../Hash/index.js";
import { from as nonceFrom } from "../Nonce/from.js";
import * as StateRoot from "../StateRoot/index.js";
import { EMPTY_CODE_HASH, EMPTY_TRIE_HASH } from "./AccountStateType.js";
import { from } from "./from.js";
import { isContract } from "./isContract.js";

describe("AccountState.isContract", () => {
	describe("contract detection", () => {
		it("returns true for contract with custom code hash", () => {
			const state = from({
				nonce: nonceFrom(1n),
				balance: weiFrom(0n),
				storageRoot: StateRoot.from(EMPTY_TRIE_HASH),
				codeHash: Hash(
					"0x1234567890123456789012345678901234567890123456789012345678901234",
				),
			});

			expect(isContract(state)).toBe(true);
		});

		it("returns true for contract with custom storage root", () => {
			const state = from({
				nonce: nonceFrom(1n),
				balance: weiFrom(0n),
				storageRoot: StateRoot.from(
					"0xabcdef1234567890123456789012345678901234567890123456789012345678",
				),
				codeHash: Hash(
					"0x1234567890123456789012345678901234567890123456789012345678901234",
				),
			});

			expect(isContract(state)).toBe(true);
		});

		it("returns true for contract with both custom hashes", () => {
			const state = from({
				nonce: nonceFrom(1n),
				balance: weiFrom(0n),
				storageRoot: StateRoot.from(
					"0xabcdef1234567890123456789012345678901234567890123456789012345678",
				),
				codeHash: Hash(
					"0x9876543210987654321098765432109876543210987654321098765432109876",
				),
			});

			expect(isContract(state)).toBe(true);
		});

		it("returns true for contract with balance", () => {
			const state = from({
				nonce: nonceFrom(1n),
				balance: weiFrom(1000000000000000000n),
				storageRoot: StateRoot.from(EMPTY_TRIE_HASH),
				codeHash: Hash(
					"0x1234567890123456789012345678901234567890123456789012345678901234",
				),
			});

			expect(isContract(state)).toBe(true);
		});

		it("returns true for contract with high nonce", () => {
			const state = from({
				nonce: nonceFrom(100n),
				balance: weiFrom(0n),
				storageRoot: StateRoot.from(EMPTY_TRIE_HASH),
				codeHash: Hash(
					"0x1234567890123456789012345678901234567890123456789012345678901234",
				),
			});

			expect(isContract(state)).toBe(true);
		});

		it("returns true for contract with zero nonce", () => {
			const state = from({
				nonce: nonceFrom(0n),
				balance: weiFrom(0n),
				storageRoot: StateRoot.from(EMPTY_TRIE_HASH),
				codeHash: Hash(
					"0x1234567890123456789012345678901234567890123456789012345678901234",
				),
			});

			expect(isContract(state)).toBe(true);
		});

		it("returns true for contract with zero balance", () => {
			const state = from({
				nonce: nonceFrom(1n),
				balance: weiFrom(0n),
				storageRoot: StateRoot.from(EMPTY_TRIE_HASH),
				codeHash: Hash(
					"0x1234567890123456789012345678901234567890123456789012345678901234",
				),
			});

			expect(isContract(state)).toBe(true);
		});

		it("returns true for contract with maximum balance", () => {
			const state = from({
				nonce: nonceFrom(1n),
				balance: weiFrom(2n ** 256n - 1n),
				storageRoot: StateRoot.from(EMPTY_TRIE_HASH),
				codeHash: Hash(
					"0x1234567890123456789012345678901234567890123456789012345678901234",
				),
			});

			expect(isContract(state)).toBe(true);
		});
	});

	describe("EOA detection", () => {
		it("returns false for empty account", () => {
			const state = from({
				nonce: nonceFrom(0n),
				balance: weiFrom(0n),
				storageRoot: StateRoot.from(EMPTY_TRIE_HASH),
				codeHash: Hash(EMPTY_CODE_HASH),
			});

			expect(isContract(state)).toBe(false);
		});

		it("returns false for EOA with zero balance", () => {
			const state = from({
				nonce: nonceFrom(5n),
				balance: weiFrom(0n),
				storageRoot: StateRoot.from(EMPTY_TRIE_HASH),
				codeHash: Hash(EMPTY_CODE_HASH),
			});

			expect(isContract(state)).toBe(false);
		});

		it("returns false for EOA with non-zero balance", () => {
			const state = from({
				nonce: nonceFrom(0n),
				balance: weiFrom(1000000000000000000n),
				storageRoot: StateRoot.from(EMPTY_TRIE_HASH),
				codeHash: Hash(EMPTY_CODE_HASH),
			});

			expect(isContract(state)).toBe(false);
		});

		it("returns false for EOA with high nonce", () => {
			const state = from({
				nonce: nonceFrom(1000000n),
				balance: weiFrom(0n),
				storageRoot: StateRoot.from(EMPTY_TRIE_HASH),
				codeHash: Hash(EMPTY_CODE_HASH),
			});

			expect(isContract(state)).toBe(false);
		});

		it("returns false for EOA with nonce and balance", () => {
			const state = from({
				nonce: nonceFrom(42n),
				balance: weiFrom(5000000000000000000n),
				storageRoot: StateRoot.from(EMPTY_TRIE_HASH),
				codeHash: Hash(EMPTY_CODE_HASH),
			});

			expect(isContract(state)).toBe(false);
		});

		it("returns false for EOA with maximum nonce", () => {
			const state = from({
				nonce: nonceFrom(2n ** 64n - 1n),
				balance: weiFrom(0n),
				storageRoot: StateRoot.from(EMPTY_TRIE_HASH),
				codeHash: Hash(EMPTY_CODE_HASH),
			});

			expect(isContract(state)).toBe(false);
		});

		it("returns false for EOA with maximum balance", () => {
			const state = from({
				nonce: nonceFrom(0n),
				balance: weiFrom(2n ** 256n - 1n),
				storageRoot: StateRoot.from(EMPTY_TRIE_HASH),
				codeHash: Hash(EMPTY_CODE_HASH),
			});

			expect(isContract(state)).toBe(false);
		});
	});

	describe("edge cases", () => {
		it("distinguishes contract from EOA correctly", () => {
			const eoaState = from({
				nonce: nonceFrom(0n),
				balance: weiFrom(0n),
				storageRoot: StateRoot.from(EMPTY_TRIE_HASH),
				codeHash: Hash(EMPTY_CODE_HASH),
			});

			const contractState = from({
				nonce: nonceFrom(0n),
				balance: weiFrom(0n),
				storageRoot: StateRoot.from(EMPTY_TRIE_HASH),
				codeHash: Hash(
					"0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff",
				),
			});

			expect(isContract(eoaState)).toBe(false);
			expect(isContract(contractState)).toBe(true);
		});

		it("handles code hash that differs by one byte from empty", () => {
			const almostEmpty =
				"0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a471";
			const state = from({
				nonce: nonceFrom(0n),
				balance: weiFrom(0n),
				storageRoot: StateRoot.from(EMPTY_TRIE_HASH),
				codeHash: Hash(almostEmpty),
			});

			expect(isContract(state)).toBe(true);
		});

		it("handles empty code hash in different case", () => {
			const upperCaseEmpty =
				"0xC5D2460186F7233C927E7DB2DCC703C0E500B653CA82273B7BFAD8045D85A470";
			const state = from({
				nonce: nonceFrom(0n),
				balance: weiFrom(0n),
				storageRoot: StateRoot.from(EMPTY_TRIE_HASH),
				codeHash: Hash(upperCaseEmpty),
			});

			expect(isContract(state)).toBe(false);
		});

		it("returns true for all-zero code hash", () => {
			const state = from({
				nonce: nonceFrom(0n),
				balance: weiFrom(0n),
				storageRoot: StateRoot.from(EMPTY_TRIE_HASH),
				codeHash: Hash(
					"0x0000000000000000000000000000000000000000000000000000000000000000",
				),
			});

			expect(isContract(state)).toBe(true);
		});

		it("returns true for all-ones code hash", () => {
			const state = from({
				nonce: nonceFrom(0n),
				balance: weiFrom(0n),
				storageRoot: StateRoot.from(EMPTY_TRIE_HASH),
				codeHash: Hash(
					"0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff",
				),
			});

			expect(isContract(state)).toBe(true);
		});
	});

	describe("inverse relationship", () => {
		it("isContract is inverse of isEOA for empty account", async () => {
			const state = from({
				nonce: nonceFrom(0n),
				balance: weiFrom(0n),
				storageRoot: StateRoot.from(EMPTY_TRIE_HASH),
				codeHash: Hash(EMPTY_CODE_HASH),
			});

			const { isEOA } = await import("./isEOA.js");
			expect(isContract(state)).toBe(!isEOA(state));
		});

		it("isContract is inverse of isEOA for contract", async () => {
			const state = from({
				nonce: nonceFrom(1n),
				balance: weiFrom(0n),
				storageRoot: StateRoot.from(EMPTY_TRIE_HASH),
				codeHash: Hash(
					"0x1234567890123456789012345678901234567890123456789012345678901234",
				),
			});

			const { isEOA } = await import("./isEOA.js");
			expect(isContract(state)).toBe(!isEOA(state));
		});
	});
});

```
