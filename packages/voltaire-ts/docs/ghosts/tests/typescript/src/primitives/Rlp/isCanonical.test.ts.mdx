---
title: '[TS/JS] src/primitives/Rlp/isCanonical.test.ts'
source: 'src/primitives/Rlp/isCanonical.test.ts'
---

> Auto-generated from test file: src/primitives/Rlp/isCanonical.test.ts

```typescript
/**
 * Tests for Rlp.isCanonical
 */

import { describe, expect, it } from "vitest";
import { encode } from "./encode.js";
import { isCanonical } from "./isCanonical.js";

describe("Rlp.isCanonical", () => {
	describe("canonical encodings", () => {
		it("validates single byte < 0x80", () => {
			const data = new Uint8Array([0x7f]);
			expect(isCanonical(data)).toBe(true);
		});

		it("validates empty bytes (0x80)", () => {
			const data = new Uint8Array([0x80]);
			expect(isCanonical(data)).toBe(true);
		});

		it("validates short string", () => {
			const data = encode(new Uint8Array([0x80, 0x81, 0x82])); // >= 0x80
			expect(isCanonical(data)).toBe(true);
		});

		it("validates long string (>55 bytes)", () => {
			const data = encode(new Uint8Array(60).fill(0x42));
			expect(isCanonical(data)).toBe(true);
		});

		it("validates empty list", () => {
			const data = encode([]);
			expect(isCanonical(data)).toBe(true);
		});

		it("validates list with items", () => {
			const data = encode([
				new Uint8Array([1]),
				new Uint8Array([2]),
				new Uint8Array([3]),
			]);
			expect(isCanonical(data)).toBe(true);
		});

		it("validates nested list", () => {
			const data = encode([new Uint8Array([1]), [new Uint8Array([2])]]);
			expect(isCanonical(data)).toBe(true);
		});

		it("validates 55 byte string (boundary)", () => {
			const data = encode(new Uint8Array(55).fill(0x42));
			expect(isCanonical(data)).toBe(true);
		});

		it("validates 56 byte string (boundary)", () => {
			const data = encode(new Uint8Array(56).fill(0x42));
			expect(isCanonical(data)).toBe(true);
		});
	});

	describe("non-canonical encodings", () => {
		it("rejects empty input", () => {
			const data = new Uint8Array([]);
			expect(isCanonical(data)).toBe(false);
		});

		it("rejects single byte < 0x80 with string prefix", () => {
			// 0x7f should be encoded as just 0x7f, not 0x81 0x7f
			const data = new Uint8Array([0x81, 0x7f]);
			expect(isCanonical(data)).toBe(false);
		});

		it("rejects string with leading zeros in length", () => {
			// Long form with leading zero in length
			const data = new Uint8Array([
				0xb8, 0x00, 0x05, 0x68, 0x65, 0x6c, 0x6c, 0x6f,
			]);
			expect(isCanonical(data)).toBe(false);
		});

		it("rejects short string using long form", () => {
			// 5 bytes should use short form (0x85), not long form (0xb8 0x05)
			const data = new Uint8Array([0xb8, 0x05, 0x68, 0x65, 0x6c, 0x6c, 0x6f]);
			expect(isCanonical(data)).toBe(false);
		});

		it("rejects list with leading zeros in length", () => {
			// Long list form with leading zero in length
			const data = new Uint8Array([0xf8, 0x00, 0x03, 0x01, 0x02, 0x03]);
			expect(isCanonical(data)).toBe(false);
		});

		it("rejects short list using long form", () => {
			// 3 bytes should use short form (0xc3), not long form (0xf8 0x03)
			const data = new Uint8Array([0xf8, 0x03, 0x01, 0x02, 0x03]);
			expect(isCanonical(data)).toBe(false);
		});

		it("rejects truncated short string", () => {
			// Claims 3 bytes but only has 2
			const data = new Uint8Array([0x83, 1, 2]);
			expect(isCanonical(data)).toBe(false);
		});

		it("rejects truncated long string", () => {
			// Claims 60 bytes but only has 3
			const data = new Uint8Array([0xb8, 60, 1, 2, 3]);
			expect(isCanonical(data)).toBe(false);
		});

		it("rejects truncated list", () => {
			// Claims 4 bytes but only has 1
			const data = new Uint8Array([0xc4, 0x01]);
			expect(isCanonical(data)).toBe(false);
		});

		it("rejects list with non-canonical item", () => {
			// List containing non-canonical single byte encoding
			const data = new Uint8Array([0xc3, 0x81, 0x7f, 0x02]);
			expect(isCanonical(data)).toBe(false);
		});

		it("rejects nested list with non-canonical item", () => {
			// Nested list with non-canonical encoding deep inside
			const data = new Uint8Array([0xc5, 0xc3, 0x81, 0x7f, 0x02, 0x03]);
			expect(isCanonical(data)).toBe(false);
		});

		it("rejects excessively nested structures", () => {
			// Create a deeply nested structure beyond MAX_DEPTH
			let data = new Uint8Array([0x01]); // Start with single byte
			for (let i = 0; i < 33; i++) {
				// Properly encode lists beyond max depth
				const prefix = 0xc0 + data.length;
				data = new Uint8Array([prefix, ...data]);
			}
			expect(isCanonical(data)).toBe(false);
		});
	});

	describe("edge cases", () => {
		it("validates 0x80 single byte that needs prefix", () => {
			// Byte 0x80 must be encoded as 0x81 0x80 (needs prefix)
			const data = new Uint8Array([0x81, 0x80]);
			expect(isCanonical(data)).toBe(true);
		});

		it("validates complex nested structure", () => {
			const data = encode([
				[new Uint8Array([1]), [new Uint8Array([2])]],
				new Uint8Array([3]),
				[],
			]);
			expect(isCanonical(data)).toBe(true);
		});

		it("validates large payload", () => {
			// 1KB payload
			const data = encode(new Uint8Array(1024).fill(0xff));
			expect(isCanonical(data)).toBe(true);
		});

		it("validates maximum allowed nesting depth", () => {
			// Create properly encoded nested structure at max depth
			// MAX_DEPTH is 32, depth goes 0-31
			// We need properly encoded nested lists
			let data = new Uint8Array([0x01]);
			for (let i = 0; i < 31; i++) {
				// Properly encode as list: prefix = 0xc0 + payload_length
				const prefix = 0xc0 + data.length;
				data = new Uint8Array([prefix, ...data]);
			}
			expect(isCanonical(data)).toBe(true);
		});
	});

	describe("integer encoding", () => {
		it("validates zero as empty bytes (0x80)", () => {
			const data = new Uint8Array([0x80]);
			expect(isCanonical(data)).toBe(true);
		});

		it("validates single byte integer < 0x80", () => {
			const data = new Uint8Array([0x42]);
			expect(isCanonical(data)).toBe(true);
		});

		it("validates single byte integer >= 0x80", () => {
			// 0xff encoded as 0x81 0xff
			const data = new Uint8Array([0x81, 0xff]);
			expect(isCanonical(data)).toBe(true);
		});

		it("validates multi-byte integer", () => {
			// 1024 = 0x0400 -> encoded as 0x82 0x04 0x00
			const data = new Uint8Array([0x82, 0x04, 0x00]);
			expect(isCanonical(data)).toBe(true);
		});

		it("rejects integer with leading zero (would be non-minimal)", () => {
			// 0x00 0x42 should be just 0x42
			// This would be encoded as 0x82 0x00 0x42 which is non-canonical
			const data = new Uint8Array([0x82, 0x00, 0x42]);
			expect(isCanonical(data)).toBe(true); // Structure is valid, but semantically non-minimal
			// Note: isCanonical checks RLP structure, not integer semantics
		});
	});

	describe("round-trip validation", () => {
		it("validates encode output is canonical", () => {
			const inputs = [
				new Uint8Array([]),
				new Uint8Array([0x00]),
				new Uint8Array([0x7f]),
				new Uint8Array([0x80]),
				new Uint8Array([0xff]),
				new Uint8Array([1, 2, 3, 4, 5]),
				new Uint8Array(60).fill(0x42),
				new Uint8Array(100).fill(0xff),
			];

			for (const input of inputs) {
				const encoded = encode(input);
				expect(isCanonical(encoded)).toBe(true);
			}
		});

		it("validates encoded lists are canonical", () => {
			const lists = [
				[],
				[new Uint8Array([1])],
				[new Uint8Array([1]), new Uint8Array([2])],
				[new Uint8Array([1]), [new Uint8Array([2])]],
				[[], [], []],
			];

			for (const list of lists) {
				const encoded = encode(list);
				expect(isCanonical(encoded)).toBe(true);
			}
		});
	});
});

```
