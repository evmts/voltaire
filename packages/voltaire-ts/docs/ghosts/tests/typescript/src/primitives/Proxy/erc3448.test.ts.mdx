---
title: '[TS/JS] src/primitives/Proxy/erc3448.test.ts'
source: 'src/primitives/Proxy/erc3448.test.ts'
---

> Auto-generated from test file: src/primitives/Proxy/erc3448.test.ts

```typescript
/**
 * ERC-3448 MetaProxy Tests
 * @see https://eips.ethereum.org/EIPS/eip-3448
 */

import { describe, expect, test } from "vitest";
import { generateErc1167 } from "./generateErc1167.js";
import { generateErc3448 } from "./generateErc3448.js";
import { isErc1167 } from "./isErc1167.js";
import { isErc3448 } from "./isErc3448.js";
import { parseErc3448 } from "./parseErc3448.js";

describe("ERC-3448 MetaProxy", () => {
	const testAddress = new Uint8Array([
		0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xaa, 0xbb, 0xcc,
		0xdd, 0xee, 0xff, 0x00, 0x11, 0x22, 0x33, 0x44,
	]);

	describe("generateErc3448", () => {
		test("generates valid bytecode with empty metadata", () => {
			const metadata = new Uint8Array(0);
			const bytecode = generateErc3448(testAddress, metadata);

			// 55 (ERC-1167) + 0 (metadata) + 32 (length) = 87 bytes
			expect(bytecode).toHaveLength(87);
		});

		test("generates valid bytecode with small metadata", () => {
			const metadata = new Uint8Array([0xde, 0xad, 0xbe, 0xef]);
			const bytecode = generateErc3448(testAddress, metadata);

			// 55 + 4 + 32 = 91 bytes
			expect(bytecode).toHaveLength(91);
		});

		test("generates valid bytecode with large metadata", () => {
			const metadata = new Uint8Array(1024).fill(0xff);
			const bytecode = generateErc3448(testAddress, metadata);

			// 55 + 1024 + 32 = 1111 bytes
			expect(bytecode).toHaveLength(1111);
		});

		test("throws on invalid address length", () => {
			const invalidAddress = new Uint8Array(19);
			const metadata = new Uint8Array(0);
			expect(() => generateErc3448(invalidAddress, metadata)).toThrow(
				"Implementation address must be 20 bytes",
			);
		});

		test("embeds implementation address at correct offset", () => {
			const metadata = new Uint8Array([0xaa, 0xbb]);
			const bytecode = generateErc3448(testAddress, metadata);

			// Address should be at offset 20
			const embeddedAddress = bytecode.slice(20, 40);
			expect(embeddedAddress).toEqual(testAddress);
		});

		test("has correct creation code prefix", () => {
			const metadata = new Uint8Array(0);
			const bytecode = generateErc3448(testAddress, metadata);

			// 3d602d80600a3d3981f3
			expect(bytecode[0]).toBe(0x3d);
			expect(bytecode[1]).toBe(0x60);
			expect(bytecode[2]).toBe(0x2d);
			expect(bytecode[3]).toBe(0x80);
			expect(bytecode[9]).toBe(0xf3);
		});

		test("has correct runtime code prefix", () => {
			const metadata = new Uint8Array(0);
			const bytecode = generateErc3448(testAddress, metadata);

			// 363d3d373d3d3d363d73
			expect(bytecode[10]).toBe(0x36);
			expect(bytecode[19]).toBe(0x73); // PUSH20
		});

		test("has correct runtime code suffix", () => {
			const metadata = new Uint8Array(0);
			const bytecode = generateErc3448(testAddress, metadata);

			// 5af43d82803e903d91602b57fd5bf3
			expect(bytecode[40]).toBe(0x5a);
			expect(bytecode[41]).toBe(0xf4);
			expect(bytecode[54]).toBe(0xf3);
		});

		test("encodes metadata correctly", () => {
			const metadata = new Uint8Array([0xde, 0xad, 0xbe, 0xef]);
			const bytecode = generateErc3448(testAddress, metadata);

			// Metadata at offset 55
			expect(bytecode[55]).toBe(0xde);
			expect(bytecode[56]).toBe(0xad);
			expect(bytecode[57]).toBe(0xbe);
			expect(bytecode[58]).toBe(0xef);
		});

		test("encodes metadata length as big-endian uint256", () => {
			const metadata = new Uint8Array([0xde, 0xad, 0xbe, 0xef]);
			const bytecode = generateErc3448(testAddress, metadata);

			// Length should be last 32 bytes
			// Length = 4, so last byte should be 0x04
			expect(bytecode[bytecode.length - 1]).toBe(0x04);
			// All other length bytes should be 0
			for (let i = bytecode.length - 32; i < bytecode.length - 1; i++) {
				expect(bytecode[i]).toBe(0x00);
			}
		});

		test("encodes large metadata length correctly", () => {
			const metadata = new Uint8Array(256).fill(0xaa);
			const bytecode = generateErc3448(testAddress, metadata);

			// Length = 256 = 0x0100
			expect(bytecode[bytecode.length - 1]).toBe(0x00);
			expect(bytecode[bytecode.length - 2]).toBe(0x01);
		});

		test("deterministic - same inputs produce same bytecode", () => {
			const metadata = new Uint8Array([0x12, 0x34]);
			const bytecode1 = generateErc3448(testAddress, metadata);
			const bytecode2 = generateErc3448(testAddress, metadata);

			expect(bytecode1).toEqual(bytecode2);
		});

		test("different metadata produces different bytecode", () => {
			const metadata1 = new Uint8Array([0x12, 0x34]);
			const metadata2 = new Uint8Array([0x56, 0x78]);
			const bytecode1 = generateErc3448(testAddress, metadata1);
			const bytecode2 = generateErc3448(testAddress, metadata2);

			expect(bytecode1).not.toEqual(bytecode2);
		});
	});

	describe("parseErc3448", () => {
		test("extracts implementation and empty metadata", () => {
			const metadata = new Uint8Array(0);
			const bytecode = generateErc3448(testAddress, metadata);
			const parsed = parseErc3448(bytecode);

			expect(parsed).not.toBeNull();
			expect(parsed?.implementation).toEqual(testAddress);
			expect(parsed?.metadata).toEqual(metadata);
		});

		test("extracts implementation and small metadata", () => {
			const metadata = new Uint8Array([0xde, 0xad, 0xbe, 0xef]);
			const bytecode = generateErc3448(testAddress, metadata);
			const parsed = parseErc3448(bytecode);

			expect(parsed).not.toBeNull();
			expect(parsed?.implementation).toEqual(testAddress);
			expect(parsed?.metadata).toEqual(metadata);
		});

		test("extracts implementation and large metadata", () => {
			const metadata = new Uint8Array(1024).fill(0xff);
			const bytecode = generateErc3448(testAddress, metadata);
			const parsed = parseErc3448(bytecode);

			expect(parsed).not.toBeNull();
			expect(parsed?.implementation).toEqual(testAddress);
			expect(parsed?.metadata).toEqual(metadata);
		});

		test("returns null for invalid bytecode length", () => {
			const invalidBytecode = new Uint8Array(50);
			const parsed = parseErc3448(invalidBytecode);

			expect(parsed).toBeNull();
		});

		test("returns null for invalid prefix pattern", () => {
			const invalidBytecode = new Uint8Array(87).fill(0xff);
			const parsed = parseErc3448(invalidBytecode);

			expect(parsed).toBeNull();
		});

		test("returns null for corrupted creation code", () => {
			const metadata = new Uint8Array([0xaa]);
			const bytecode = generateErc3448(testAddress, metadata);
			bytecode[0] = 0xff; // Corrupt first byte

			const parsed = parseErc3448(bytecode);
			expect(parsed).toBeNull();
		});

		test("returns null for corrupted runtime code", () => {
			const metadata = new Uint8Array([0xaa]);
			const bytecode = generateErc3448(testAddress, metadata);
			bytecode[40] = 0xff; // Corrupt suffix

			const parsed = parseErc3448(bytecode);
			expect(parsed).toBeNull();
		});

		test("returns null for mismatched length encoding", () => {
			const metadata = new Uint8Array([0xaa, 0xbb]);
			const bytecode = generateErc3448(testAddress, metadata);
			// Corrupt length encoding
			bytecode[bytecode.length - 1] = 0xff;

			const parsed = parseErc3448(bytecode);
			expect(parsed).toBeNull();
		});

		test("handles zero address", () => {
			const zeroAddress = new Uint8Array(20);
			const metadata = new Uint8Array([0x01, 0x02]);
			const bytecode = generateErc3448(zeroAddress, metadata);
			const parsed = parseErc3448(bytecode);

			expect(parsed).not.toBeNull();
			expect(parsed?.implementation).toEqual(zeroAddress);
		});

		test("handles max address", () => {
			const maxAddress = new Uint8Array(20).fill(0xff);
			const metadata = new Uint8Array([0x01, 0x02]);
			const bytecode = generateErc3448(maxAddress, metadata);
			const parsed = parseErc3448(bytecode);

			expect(parsed).not.toBeNull();
			expect(parsed?.implementation).toEqual(maxAddress);
		});
	});

	describe("isErc3448", () => {
		test("validates bytecode with empty metadata", () => {
			const metadata = new Uint8Array(0);
			const bytecode = generateErc3448(testAddress, metadata);
			expect(isErc3448(bytecode)).toBe(true);
		});

		test("validates bytecode with small metadata", () => {
			const metadata = new Uint8Array([0xde, 0xad, 0xbe, 0xef]);
			const bytecode = generateErc3448(testAddress, metadata);
			expect(isErc3448(bytecode)).toBe(true);
		});

		test("validates bytecode with large metadata", () => {
			const metadata = new Uint8Array(2048).fill(0xaa);
			const bytecode = generateErc3448(testAddress, metadata);
			expect(isErc3448(bytecode)).toBe(true);
		});

		test("rejects invalid length (too short)", () => {
			const invalidBytecode = new Uint8Array(50);
			expect(isErc3448(invalidBytecode)).toBe(false);
		});

		test("rejects invalid prefix", () => {
			const invalidBytecode = new Uint8Array(87).fill(0xff);
			expect(isErc3448(invalidBytecode)).toBe(false);
		});

		test("rejects corrupted creation code", () => {
			const metadata = new Uint8Array([0xaa]);
			const bytecode = generateErc3448(testAddress, metadata);
			bytecode[0] = 0xff; // Corrupt first byte

			expect(isErc3448(bytecode)).toBe(false);
		});

		test("rejects corrupted runtime prefix", () => {
			const metadata = new Uint8Array([0xaa]);
			const bytecode = generateErc3448(testAddress, metadata);
			bytecode[10] = 0xff; // Corrupt runtime prefix

			expect(isErc3448(bytecode)).toBe(false);
		});

		test("rejects corrupted runtime suffix", () => {
			const metadata = new Uint8Array([0xaa]);
			const bytecode = generateErc3448(testAddress, metadata);
			bytecode[54] = 0xff; // Corrupt last byte of suffix

			expect(isErc3448(bytecode)).toBe(false);
		});

		test("rejects mismatched length encoding", () => {
			const metadata = new Uint8Array([0xaa, 0xbb]);
			const bytecode = generateErc3448(testAddress, metadata);
			// Corrupt length encoding
			bytecode[bytecode.length - 1] = 0xff;

			expect(isErc3448(bytecode)).toBe(false);
		});

		test("validates with different implementation addresses", () => {
			const addresses = [
				new Uint8Array(20),
				new Uint8Array(20).fill(0xff),
				testAddress,
			];

			for (const address of addresses) {
				const metadata = new Uint8Array([0x01]);
				const bytecode = generateErc3448(address, metadata);
				expect(isErc3448(bytecode)).toBe(true);
			}
		});

		test("validates with various metadata sizes", () => {
			const sizes = [0, 1, 4, 32, 64, 256, 512, 1024];

			for (const size of sizes) {
				const metadata = new Uint8Array(size).fill(0xaa);
				const bytecode = generateErc3448(testAddress, metadata);
				expect(isErc3448(bytecode)).toBe(true);
			}
		});
	});

	describe("round-trip", () => {
		test("generate -> parse -> validate with empty metadata", () => {
			const metadata = new Uint8Array(0);
			const bytecode = generateErc3448(testAddress, metadata);
			const parsed = parseErc3448(bytecode);
			const valid = isErc3448(bytecode);

			expect(parsed).not.toBeNull();
			expect(parsed?.implementation).toEqual(testAddress);
			expect(parsed?.metadata).toEqual(metadata);
			expect(valid).toBe(true);
		});

		test("generate -> parse -> validate with metadata", () => {
			const metadata = new Uint8Array([0xde, 0xad, 0xbe, 0xef]);
			const bytecode = generateErc3448(testAddress, metadata);
			const parsed = parseErc3448(bytecode);
			const valid = isErc3448(bytecode);

			expect(parsed).not.toBeNull();
			expect(parsed?.implementation).toEqual(testAddress);
			expect(parsed?.metadata).toEqual(metadata);
			expect(valid).toBe(true);
		});

		test("generate -> parse -> regenerate produces identical bytecode", () => {
			const metadata = new Uint8Array([0x12, 0x34, 0x56, 0x78]);
			const bytecode1 = generateErc3448(testAddress, metadata);
			const parsed = parseErc3448(bytecode1);

			expect(parsed).not.toBeNull();
			if (parsed === null) return;
			const bytecode2 = generateErc3448(parsed.implementation, parsed.metadata);

			expect(bytecode2).toEqual(bytecode1);
		});

		test("multiple addresses and metadata combinations", () => {
			const testAddresses = [
				new Uint8Array(20),
				new Uint8Array(20).fill(0xff),
				testAddress,
			];

			const testMetadata = [
				new Uint8Array(0),
				new Uint8Array([0xaa]),
				new Uint8Array([0xde, 0xad, 0xbe, 0xef]),
				new Uint8Array(64).fill(0xff),
			];

			for (const address of testAddresses) {
				for (const metadata of testMetadata) {
					const bytecode = generateErc3448(address, metadata);
					const parsed = parseErc3448(bytecode);

					expect(parsed).not.toBeNull();
					expect(parsed?.implementation).toEqual(address);
					expect(parsed?.metadata).toEqual(metadata);
					expect(isErc3448(bytecode)).toBe(true);
				}
			}
		});
	});

	describe("ERC-1167 compatibility", () => {
		test("ERC-3448 with empty metadata is not ERC-1167", () => {
			const metadata = new Uint8Array(0);
			const bytecode = generateErc3448(testAddress, metadata);

			// ERC-3448 is 87 bytes, ERC-1167 is 55 bytes
			expect(isErc1167(bytecode)).toBe(false);
		});

		test("ERC-1167 is not ERC-3448", () => {
			const bytecode = generateErc1167(testAddress);

			// ERC-1167 is too short to be ERC-3448
			expect(isErc3448(bytecode)).toBe(false);
		});

		test("ERC-3448 first 55 bytes match ERC-1167", () => {
			const metadata = new Uint8Array([0xaa, 0xbb]);
			const erc3448Bytecode = generateErc3448(testAddress, metadata);
			const erc1167Bytecode = generateErc1167(testAddress);

			// First 55 bytes should be identical
			const erc3448Prefix = erc3448Bytecode.slice(0, 55);
			expect(erc3448Prefix).toEqual(erc1167Bytecode);
		});

		test("implementation address extracted matches between standards", () => {
			const metadata = new Uint8Array([0x12, 0x34]);
			const erc3448Bytecode = generateErc3448(testAddress, metadata);
			const erc3448Prefix = erc3448Bytecode.slice(0, 55);

			const parsed = parseErc3448(erc3448Bytecode);
			const erc1167Impl = erc3448Prefix.slice(20, 40);

			expect(parsed?.implementation).toEqual(erc1167Impl);
		});
	});

	describe("edge cases", () => {
		test("max uint8 metadata length (255 bytes)", () => {
			const metadata = new Uint8Array(255).fill(0xaa);
			const bytecode = generateErc3448(testAddress, metadata);

			expect(isErc3448(bytecode)).toBe(true);

			const parsed = parseErc3448(bytecode);
			expect(parsed?.metadata).toEqual(metadata);
		});

		test("max uint16 metadata length (65535 bytes)", () => {
			const metadata = new Uint8Array(65535).fill(0xbb);
			const bytecode = generateErc3448(testAddress, metadata);

			expect(bytecode).toHaveLength(55 + 65535 + 32);
			expect(isErc3448(bytecode)).toBe(true);

			const parsed = parseErc3448(bytecode);
			expect(parsed?.metadata).toEqual(metadata);
		});

		test("metadata with all zeros", () => {
			const metadata = new Uint8Array(32);
			const bytecode = generateErc3448(testAddress, metadata);
			const parsed = parseErc3448(bytecode);

			expect(parsed?.metadata).toEqual(metadata);
		});

		test("metadata with all 0xff", () => {
			const metadata = new Uint8Array(32).fill(0xff);
			const bytecode = generateErc3448(testAddress, metadata);
			const parsed = parseErc3448(bytecode);

			expect(parsed?.metadata).toEqual(metadata);
		});

		test("single byte metadata", () => {
			const metadata = new Uint8Array([0x42]);
			const bytecode = generateErc3448(testAddress, metadata);
			const parsed = parseErc3448(bytecode);

			expect(parsed?.metadata).toEqual(metadata);
			expect(bytecode).toHaveLength(88); // 55 + 1 + 32
		});
	});
});

```
