---
title: '[TS/JS] src/primitives/BeaconBlockRoot/BeaconBlockRoot.test.ts'
source: 'src/primitives/BeaconBlockRoot/BeaconBlockRoot.test.ts'
---

> Auto-generated from test file: src/primitives/BeaconBlockRoot/BeaconBlockRoot.test.ts

```typescript
import { describe, expect, it } from "vitest";
import * as BeaconBlockRoot from "./index.js";

describe("BeaconBlockRoot", () => {
	const validHex =
		"0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef";
	const validBytes = new Uint8Array(32);
	validBytes[0] = 0x12;
	validBytes[1] = 0x34;

	describe("from", () => {
		it("creates BeaconBlockRoot from hex string", () => {
			const root = BeaconBlockRoot.from(validHex);
			expect(root.length).toBe(32);
			expect(root[0]).toBe(0x12);
		});

		it("creates BeaconBlockRoot from Uint8Array", () => {
			const root = BeaconBlockRoot.from(validBytes);
			expect(root.length).toBe(32);
			expect(root[0]).toBe(0x12);
		});

		it("rejects wrong length bytes", () => {
			expect(() => BeaconBlockRoot.from(new Uint8Array(31))).toThrow(
				"must be exactly 32 bytes",
			);
		});

		it("rejects wrong length hex", () => {
			expect(() => BeaconBlockRoot.from("0x1234")).toThrow(
				"must be 64 characters",
			);
		});
	});

	describe("fromHex", () => {
		it("creates BeaconBlockRoot from valid hex", () => {
			const root = BeaconBlockRoot.fromHex(validHex);
			expect(root.length).toBe(32);
		});

		it("rejects invalid hex length", () => {
			expect(() => BeaconBlockRoot.fromHex("0x1234")).toThrow(
				"must be 64 characters",
			);
		});
	});

	describe("fromBytes", () => {
		it("creates BeaconBlockRoot from valid bytes", () => {
			const root = BeaconBlockRoot.fromBytes(validBytes);
			expect(root.length).toBe(32);
		});

		it("rejects invalid byte length", () => {
			expect(() => BeaconBlockRoot.fromBytes(new Uint8Array(31))).toThrow(
				"must be exactly 32 bytes",
			);
		});
	});

	describe("toHex", () => {
		it("converts to hex string", () => {
			const root = BeaconBlockRoot.from(validHex);
			const hex = BeaconBlockRoot.toHex(root);
			expect(hex).toBe(validHex.toLowerCase());
		});
	});

	describe("equals", () => {
		it("returns true for equal roots", () => {
			const a = BeaconBlockRoot.from(validHex);
			const b = BeaconBlockRoot.from(validHex);
			expect(BeaconBlockRoot.equals(a, b)).toBe(true);
		});

		it("returns false for unequal roots", () => {
			const a = BeaconBlockRoot.from(validHex);
			const differentBytes = new Uint8Array(32);
			differentBytes[0] = 0xff;
			const b = BeaconBlockRoot.from(differentBytes);
			expect(BeaconBlockRoot.equals(a, b)).toBe(false);
		});
	});
});

```
