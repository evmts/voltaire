---
title: '[TS/JS] src/primitives/Rlp/validate.test.ts'
source: 'src/primitives/Rlp/validate.test.ts'
---

> Auto-generated from test file: src/primitives/Rlp/validate.test.ts

```typescript
/**
 * Tests for Rlp.validate
 */

import { describe, expect, it } from "vitest";
import { encode } from "./encode.js";
import { validate } from "./validate.js";

describe("Rlp.validate", () => {
	it("validates valid single byte < 0x80", () => {
		const data = new Uint8Array([0x7f]);
		expect(validate(data)).toBe(true);
	});

	it("validates valid empty bytes", () => {
		const data = new Uint8Array([0x80]);
		expect(validate(data)).toBe(true);
	});

	it("validates valid short string", () => {
		const data = encode(new Uint8Array([1, 2, 3]));
		expect(validate(data)).toBe(true);
	});

	it("validates valid long string", () => {
		const data = encode(new Uint8Array(60).fill(0x42));
		expect(validate(data)).toBe(true);
	});

	it("validates valid empty list", () => {
		const data = encode([]);
		expect(validate(data)).toBe(true);
	});

	it("validates valid list with items", () => {
		const data = encode([new Uint8Array([1]), new Uint8Array([2])]);
		expect(validate(data)).toBe(true);
	});

	it("validates valid nested list", () => {
		const data = encode([new Uint8Array([1]), [new Uint8Array([2])]]);
		expect(validate(data)).toBe(true);
	});

	it("returns false for empty input", () => {
		const data = new Uint8Array([]);
		expect(validate(data)).toBe(false);
	});

	it("returns false for truncated short string", () => {
		const data = new Uint8Array([0x83, 1, 2]); // Claims 3 bytes, has 2
		expect(validate(data)).toBe(false);
	});

	it("returns false for truncated long string", () => {
		const data = new Uint8Array([0xb8, 60, 1, 2, 3]); // Claims 60 bytes, has 3
		expect(validate(data)).toBe(false);
	});

	it("returns false for non-canonical single byte", () => {
		const data = new Uint8Array([0x81, 0x7f]); // Should be just 0x7f
		expect(validate(data)).toBe(false);
	});

	it("returns false for non-canonical long form", () => {
		const data = new Uint8Array([0xb8, 10, ...new Uint8Array(10)]); // < 56 should use short form
		expect(validate(data)).toBe(false);
	});

	it("returns false for leading zeros in length", () => {
		const data = new Uint8Array([0xb8, 0x00, 0x3c, ...new Uint8Array(60)]); // Leading zero
		expect(validate(data)).toBe(false);
	});

	it("returns false for truncated list", () => {
		const data = new Uint8Array([0xc4, 0x01]); // Claims 4 bytes, has 1
		expect(validate(data)).toBe(false);
	});

	it("returns false for malformed nested structure", () => {
		const data = new Uint8Array([0xc3, 0xc2, 0x01]); // Incomplete nested list
		expect(validate(data)).toBe(false);
	});

	it("validates complex nested structure", () => {
		const data = encode([
			[new Uint8Array([1]), [new Uint8Array([2])]],
			new Uint8Array([3]),
		]);
		expect(validate(data)).toBe(true);
	});

	it("validates large data (1MB+)", () => {
		const data = encode(new Uint8Array(1024 * 1024).fill(0xff));
		expect(validate(data)).toBe(true);
	});
});

```
