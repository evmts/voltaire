---
title: '[TS/JS] src/primitives/TypedData/TypedData.test.ts'
source: 'src/primitives/TypedData/TypedData.test.ts'
---

> Auto-generated from test file: src/primitives/TypedData/TypedData.test.ts

```typescript
import { describe, expect, it } from "vitest";
import * as TypedData from "./index.js";

// Mock keccak256 for testing
function mockKeccak256(data: Uint8Array): Uint8Array {
	// Simple mock - XOR all bytes and repeat
	let hash = 0;
	for (const byte of data) {
		hash ^= byte;
	}
	const result = new Uint8Array(32);
	result.fill(hash);
	return result;
}

describe("TypedData", () => {
	const validTypedData = {
		types: {
			EIP712Domain: [
				{ name: "name", type: "string" },
				{ name: "version", type: "string" },
				{ name: "chainId", type: "uint256" },
			],
			Person: [
				{ name: "name", type: "string" },
				{ name: "wallet", type: "address" },
			],
			Mail: [
				{ name: "from", type: "Person" },
				{ name: "to", type: "Person" },
				{ name: "contents", type: "string" },
			],
		},
		primaryType: "Mail",
		domain: {
			name: "Ether Mail",
			version: "1",
			chainId: 1,
		},
		message: {
			from: {
				name: "Alice",
				wallet: "0x0000000000000000000000000000000000000001",
			},
			to: {
				name: "Bob",
				wallet: "0x0000000000000000000000000000000000000002",
			},
			contents: "Hello, Bob!",
		},
	};

	describe("from", () => {
		it("should create typed data", () => {
			const typedData = TypedData.from(validTypedData);
			expect(typedData.primaryType).toBe("Mail");
			expect(typedData.domain.name).toBe("Ether Mail");
			expect(typedData.message).toBeDefined();
		});

		it("should throw on missing types", () => {
			const invalid = { ...validTypedData, types: undefined };
			try {
				// @ts-expect-error - testing invalid input
				TypedData.from(invalid);
				expect.fail("Should have thrown");
			} catch (e) {
				expect((e as Error).name).toBe("InvalidTypedDataError");
				expect((e as Error).message).toContain("must have types");
			}
		});

		it("should throw on missing primaryType", () => {
			const invalid = { ...validTypedData, primaryType: undefined };
			try {
				// @ts-expect-error - testing invalid input
				TypedData.from(invalid);
				expect.fail("Should have thrown");
			} catch (e) {
				expect((e as Error).name).toBe("InvalidTypedDataError");
				expect((e as Error).message).toContain("must have primaryType");
			}
		});

		it("should throw on missing domain", () => {
			const invalid = { ...validTypedData, domain: undefined };
			try {
				// @ts-expect-error - testing invalid input
				TypedData.from(invalid);
				expect.fail("Should have thrown");
			} catch (e) {
				expect((e as Error).name).toBe("InvalidTypedDataError");
				expect((e as Error).message).toContain("must have domain");
			}
		});

		it("should throw on missing message", () => {
			const invalid = { ...validTypedData, message: undefined };
			try {
				// @ts-expect-error - testing invalid input
				TypedData.from(invalid);
				expect.fail("Should have thrown");
			} catch (e) {
				expect((e as Error).name).toBe("InvalidTypedDataError");
				expect((e as Error).message).toContain("must have message");
			}
		});

		it("should throw on missing EIP712Domain", () => {
			const invalid = {
				...validTypedData,
				types: { Person: validTypedData.types.Person },
			};
			try {
				// @ts-expect-error - testing invalid input
				TypedData.from(invalid);
				expect.fail("Should have thrown");
			} catch (e) {
				expect((e as Error).name).toBe("InvalidTypedDataError");
				expect((e as Error).message).toContain("must include EIP712Domain");
			}
		});

		it("should throw on invalid primaryType", () => {
			const invalid = { ...validTypedData, primaryType: "NonExistent" };
			try {
				TypedData.from(invalid);
				expect.fail("Should have thrown");
			} catch (e) {
				expect((e as Error).name).toBe("InvalidTypedDataError");
				expect((e as Error).message).toContain("not found in types");
			}
		});
	});

	describe("hash", () => {
		it("should compute hash", () => {
			const typedData = TypedData.from(validTypedData);
			const hash = TypedData.hash(typedData, { keccak256: mockKeccak256 });
			expect(hash.length).toBe(32);
		});

		it("should be deterministic", () => {
			const typedData = TypedData.from(validTypedData);
			const hash1 = TypedData.hash(typedData, { keccak256: mockKeccak256 });
			const hash2 = TypedData.hash(typedData, { keccak256: mockKeccak256 });
			expect(hash1).toEqual(hash2);
		});
	});

	describe("encode", () => {
		it("should encode message", () => {
			const typedData = TypedData.from(validTypedData);
			const encoded = TypedData.encode(typedData, { keccak256: mockKeccak256 });
			expect(encoded).toBeInstanceOf(Uint8Array);
			expect(encoded.length).toBeGreaterThan(0);
		});
	});

	describe("validate", () => {
		it("should validate valid typed data", () => {
			const typedData = TypedData.from(validTypedData);
			expect(() => TypedData.validate(typedData)).not.toThrow();
		});

		it("should throw on invalid types", () => {
			const typedData = TypedData.from(validTypedData);
			const invalid = { ...typedData, types: "invalid" };
			try {
				// @ts-expect-error - testing invalid input
				TypedData.validate(invalid);
				expect.fail("Should have thrown");
			} catch (e) {
				expect((e as Error).name).toBe("InvalidTypedDataError");
				expect((e as Error).message).toContain("must be an object");
			}
		});

		it("should throw on missing type dependency", () => {
			const invalid = {
				types: {
					EIP712Domain: [{ name: "name", type: "string" }],
					Mail: [{ name: "from", type: "NonExistent" }],
				},
				primaryType: "Mail",
				domain: { name: "Test" },
				message: {},
			};
			const typedData = TypedData.from(invalid);
			try {
				TypedData.validate(typedData);
				expect.fail("Should have thrown");
			} catch (e) {
				expect((e as Error).name).toBe("InvalidTypedDataError");
				expect((e as Error).message).toContain("not found");
			}
		});

		it("should throw on invalid field definition", () => {
			const invalid = {
				types: {
					EIP712Domain: [{ name: "name", type: "string" }],
					Person: [{ name: "name" }], // missing type
				},
				primaryType: "Person",
				domain: { name: "Test" },
				message: {},
			};
			// @ts-expect-error - testing invalid input
			const typedData = TypedData.from(invalid);
			try {
				TypedData.validate(typedData);
				expect.fail("Should have thrown");
			} catch (e) {
				expect((e as Error).name).toBe("InvalidTypedDataError");
				expect((e as Error).message).toContain("must have a type");
			}
		});
	});

	describe("ERC-20 Permit example", () => {
		it("should handle Permit typed data", () => {
			const permitData = {
				types: {
					EIP712Domain: [
						{ name: "name", type: "string" },
						{ name: "version", type: "string" },
						{ name: "chainId", type: "uint256" },
						{ name: "verifyingContract", type: "address" },
					],
					Permit: [
						{ name: "owner", type: "address" },
						{ name: "spender", type: "address" },
						{ name: "value", type: "uint256" },
						{ name: "nonce", type: "uint256" },
						{ name: "deadline", type: "uint256" },
					],
				},
				primaryType: "Permit",
				domain: {
					name: "USD Coin",
					version: "2",
					chainId: 1,
					verifyingContract: "0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48",
				},
				message: {
					owner: "0x0000000000000000000000000000000000000001",
					spender: "0x0000000000000000000000000000000000000002",
					value: 1000000n,
					nonce: 0n,
					deadline: 1234567890n,
				},
			};

			const typedData = TypedData.from(permitData);
			const hash = TypedData.hash(typedData, { keccak256: mockKeccak256 });
			expect(hash.length).toBe(32);
		});
	});
});

```
