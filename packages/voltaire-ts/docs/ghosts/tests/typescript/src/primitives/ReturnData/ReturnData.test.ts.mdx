---
title: '[TS/JS] src/primitives/ReturnData/ReturnData.test.ts'
source: 'src/primitives/ReturnData/ReturnData.test.ts'
---

> Auto-generated from test file: src/primitives/ReturnData/ReturnData.test.ts

```typescript
import { describe, expect, it } from "vitest";
import * as ReturnData from "./index.js";

describe("ReturnData", () => {
	describe("from", () => {
		it("creates ReturnData from hex string", () => {
			const data = ReturnData.from("0x00000001");
			expect(data).toBeInstanceOf(Uint8Array);
			expect(data.length).toBe(4);
			expect(data[3]).toBe(1);
		});

		it("creates ReturnData from Uint8Array", () => {
			const bytes = new Uint8Array([0, 0, 0, 1]);
			const data = ReturnData.from(bytes);
			expect(data).toBeInstanceOf(Uint8Array);
			expect(data.length).toBe(4);
		});

		it("throws on invalid type", () => {
			// biome-ignore lint/suspicious/noExplicitAny: testing invalid input
			expect(() => ReturnData.from(123 as any)).toThrow(
				"Unsupported ReturnData value type",
			);
		});
	});

	describe("fromHex", () => {
		it("creates ReturnData from hex with 0x prefix", () => {
			const data = ReturnData.fromHex("0x1234567890abcdef");
			expect(data).toBeInstanceOf(Uint8Array);
			expect(data.length).toBe(8);
		});

		it("creates ReturnData from empty hex", () => {
			const data = ReturnData.fromHex("0x");
			expect(data).toBeInstanceOf(Uint8Array);
			expect(data.length).toBe(0);
		});

		it("throws on invalid hex", () => {
			expect(() => ReturnData.fromHex("not-hex")).toThrow();
		});
	});

	describe("fromBytes", () => {
		it("creates ReturnData from bytes", () => {
			const bytes = new Uint8Array([1, 2, 3, 4]);
			const data = ReturnData.fromBytes(bytes);
			expect(data).toBe(bytes);
		});

		it("handles empty bytes", () => {
			const bytes = new Uint8Array(0);
			const data = ReturnData.fromBytes(bytes);
			expect(data.length).toBe(0);
		});
	});

	describe("toHex", () => {
		it("converts ReturnData to hex string", () => {
			const data = ReturnData.fromBytes(new Uint8Array([0, 0, 0, 1]));
			const hex = ReturnData.toHex(data);
			expect(hex).toBe("0x00000001");
		});

		it("handles empty data", () => {
			const data = ReturnData.fromBytes(new Uint8Array(0));
			const hex = ReturnData.toHex(data);
			expect(hex).toBe("0x");
		});
	});

	describe("toBytes", () => {
		it("converts ReturnData to Uint8Array", () => {
			const data = ReturnData.fromBytes(new Uint8Array([1, 2, 3, 4]));
			const bytes = ReturnData.toBytes(data);
			expect(bytes).toBeInstanceOf(Uint8Array);
			expect(bytes).not.toBe(data); // new copy
			expect(Array.from(bytes)).toEqual([1, 2, 3, 4]);
		});
	});

	describe("equals", () => {
		it("returns true for equal data", () => {
			const data1 = ReturnData.fromHex("0x12345678");
			const data2 = ReturnData.fromHex("0x12345678");
			expect(ReturnData.equals(data1, data2)).toBe(true);
		});

		it("returns false for different data", () => {
			const data1 = ReturnData.fromHex("0x12345678");
			const data2 = ReturnData.fromHex("0x87654321");
			expect(ReturnData.equals(data1, data2)).toBe(false);
		});

		it("returns false for different lengths", () => {
			const data1 = ReturnData.fromHex("0x1234");
			const data2 = ReturnData.fromHex("0x123456");
			expect(ReturnData.equals(data1, data2)).toBe(false);
		});

		it("returns true for empty data", () => {
			const data1 = ReturnData.fromHex("0x");
			const data2 = ReturnData.fromHex("0x");
			expect(ReturnData.equals(data1, data2)).toBe(true);
		});
	});

	describe("isEmpty", () => {
		it("returns true for empty data", () => {
			const data = ReturnData.fromHex("0x");
			expect(ReturnData.isEmpty(data)).toBe(true);
		});

		it("returns false for non-empty data", () => {
			const data = ReturnData.fromHex("0x01");
			expect(ReturnData.isEmpty(data)).toBe(false);
		});
	});
});

```
