---
title: '[TS/JS] src/primitives/Abi/error/decodeParams.test.ts'
source: 'src/primitives/Abi/error/decodeParams.test.ts'
---

> Auto-generated from test file: src/primitives/Abi/error/decodeParams.test.ts

```typescript
/**
 * Unit tests for decodeParams function
 */

import { keccak_256 as keccak256 } from "@noble/hashes/sha3.js";
import { describe, expect, it } from "vitest";
import type { BrandedAddress } from "../../Address/AddressType.js";
import { decodeParams } from "./decodeParams.js";
import { encodeParams } from "./encodeParams.js";
import { GetSelector } from "./getSelector.js";

// Create keccak256String function for testing
const keccak256String = (str: string): Uint8Array => {
	const encoder = new TextEncoder();
	return keccak256(encoder.encode(str));
};

const _getSelector = GetSelector({ keccak256String });

describe("decodeParams", () => {
	it("decodes error with no parameters", () => {
		const error = {
			type: "error",
			name: "Unauthorized",
			inputs: [],
		} as const;

		const encoded = encodeParams(error, []);
		const decoded = decodeParams(error, encoded);

		expect(decoded).toEqual([]);
	});

	it("decodes error with single uint256 parameter", () => {
		const error = {
			type: "error",
			name: "InsufficientBalance",
			inputs: [{ type: "uint256", name: "balance" }],
		} as const;

		const encoded = encodeParams(error, [1000n]);
		const decoded = decodeParams(error, encoded);

		expect(decoded).toEqual([1000n]);
	});

	it("decodes error with multiple parameters", () => {
		const error = {
			type: "error",
			name: "TransferFailed",
			inputs: [
				{ type: "address", name: "from" },
				{ type: "address", name: "to" },
				{ type: "uint256", name: "amount" },
			],
		} as const;

		const args = [
			"0x742d35cc6634c0532925a3b844bc9e7595f251e3" as BrandedAddress,
			"0x1234567890123456789012345678901234567890" as BrandedAddress,
			1000n,
			// biome-ignore lint/suspicious/noExplicitAny: test requires type flexibility
		] as any;
		const encoded = encodeParams(error, args);
		const decoded = decodeParams(error, encoded);

		expect(decoded[0]).toBe(args[0]);
		expect(decoded[1]).toBe(args[1]);
		expect(decoded[2]).toBe(args[2]);
	});

	it("decodes error with address parameter", () => {
		const error = {
			type: "error",
			name: "InvalidAddress",
			inputs: [{ type: "address", name: "addr" }],
		} as const;

		const addr = "0x742d35cc6634c0532925a3b844bc9e7595f251e3" as BrandedAddress;
		const encoded = encodeParams(error, [addr]);
		const decoded = decodeParams(error, encoded);

		expect(decoded[0]).toBe(addr);
	});

	it("decodes error with bool parameter (true)", () => {
		const error = {
			type: "error",
			name: "InvalidState",
			inputs: [{ type: "bool", name: "expected" }],
		} as const;

		const encoded = encodeParams(error, [true]);
		const decoded = decodeParams(error, encoded);

		expect(decoded).toEqual([true]);
	});

	it("decodes error with bool parameter (false)", () => {
		const error = {
			type: "error",
			name: "InvalidState",
			inputs: [{ type: "bool", name: "expected" }],
		} as const;

		const encoded = encodeParams(error, [false]);
		const decoded = decodeParams(error, encoded);

		expect(decoded).toEqual([false]);
	});

	it("decodes error with string parameter", () => {
		const error = {
			type: "error",
			name: "InvalidInput",
			inputs: [{ type: "string", name: "reason" }],
		} as const;

		const encoded = encodeParams(error, ["Invalid value"]);
		const decoded = decodeParams(error, encoded);

		expect(decoded).toEqual(["Invalid value"]);
	});

	it("decodes error with empty string parameter", () => {
		const error = {
			type: "error",
			name: "EmptyString",
			inputs: [{ type: "string", name: "value" }],
		} as const;

		const encoded = encodeParams(error, [""]);
		const decoded = decodeParams(error, encoded);

		expect(decoded).toEqual([""]);
	});

	it("decodes error with bytes parameter", () => {
		const error = {
			type: "error",
			name: "InvalidData",
			inputs: [{ type: "bytes", name: "data" }],
		} as const;

		const encoded = encodeParams(error, ["0x123456"]);
		const decoded = decodeParams(error, encoded);

		expect(decoded).toHaveLength(1);
		expect(decoded[0]).toBeInstanceOf(Uint8Array);
	});

	it("decodes error with fixed bytes parameter", () => {
		const error = {
			type: "error",
			name: "InvalidHash",
			inputs: [{ type: "bytes32", name: "hash" }],
		} as const;

		const hash =
			"0x0000000000000000000000000000000000000000000000000000000000000001";
		const encoded = encodeParams(error, [hash]);
		const decoded = decodeParams(error, encoded);

		expect(decoded).toHaveLength(1);
	});

	it("decodes error with array parameter", () => {
		const error = {
			type: "error",
			name: "InvalidArray",
			inputs: [{ type: "uint256[]", name: "values" }],
		} as const;

		const values = [1n, 2n, 3n];
		const encoded = encodeParams(error, [values]);
		const decoded = decodeParams(error, encoded);

		expect(decoded).toEqual([values]);
	});

	it("decodes error with empty array parameter", () => {
		const error = {
			type: "error",
			name: "EmptyArray",
			inputs: [{ type: "uint256[]", name: "values" }],
		} as const;

		const encoded = encodeParams(error, [[]]);
		const decoded = decodeParams(error, encoded);

		expect(decoded).toEqual([[]]);
	});

	it("decodes error with tuple parameter", () => {
		const error = {
			type: "error",
			name: "InvalidTuple",
			inputs: [
				{
					type: "tuple",
					name: "config",
					components: [
						{ type: "address", name: "owner" },
						{ type: "uint256", name: "fee" },
					],
				},
			],
		} as const;

		const config = [
			"0x742d35cc6634c0532925a3b844bc9e7595f251e3" as BrandedAddress,
			100n,
		];
		const encoded = encodeParams(error, [config]);
		const decoded = decodeParams(error, encoded);

		expect(decoded).toHaveLength(1);
		expect(Array.isArray(decoded[0])).toBe(true);
	});

	it("round-trips encoding and decoding", () => {
		const error = {
			type: "error",
			name: "RoundTrip",
			inputs: [
				{ type: "uint256", name: "a" },
				{ type: "address", name: "b" },
				{ type: "bool", name: "c" },
			],
		} as const;

		const args = [
			1000n,
			"0x742d35cc6634c0532925a3b844bc9e7595f251e3",
			true,
			// biome-ignore lint/suspicious/noExplicitAny: test requires type flexibility
		] as any;
		const encoded = encodeParams(error, args);
		const decoded = decodeParams(error, encoded);

		expect(decoded[0]).toBe(args[0]);
		expect(decoded[1]).toBe(args[1]);
		expect(decoded[2]).toBe(args[2]);
	});

	it("decodes ERC20InsufficientBalance error", () => {
		const error = {
			type: "error",
			name: "ERC20InsufficientBalance",
			inputs: [
				{ type: "address", name: "sender" },
				{ type: "uint256", name: "balance" },
				{ type: "uint256", name: "needed" },
			],
		} as const;

		const args = [
			"0x742d35cc6634c0532925a3b844bc9e7595f251e3" as BrandedAddress,
			1000n,
			2000n,
		];
		const encoded = encodeParams(error, args);
		const decoded = decodeParams(error, encoded);

		expect(decoded[0]).toBe(args[0]);
		expect(decoded[1]).toBe(args[1]);
		expect(decoded[2]).toBe(args[2]);
	});

	it("decodes Panic error", () => {
		const error = {
			type: "error",
			name: "Panic",
			inputs: [{ type: "uint256", name: "code" }],
		} as const;

		const encoded = encodeParams(error, [0x11n]);
		const decoded = decodeParams(error, encoded);

		expect(decoded).toEqual([0x11n]);
	});

	it("decodes Error(string) error", () => {
		const error = {
			type: "error",
			name: "Error",
			inputs: [{ type: "string", name: "message" }],
		} as const;

		const encoded = encodeParams(error, ["Something went wrong"]);
		const decoded = decodeParams(error, encoded);

		expect(decoded).toEqual(["Something went wrong"]);
	});

	it("throws error when data is too short", () => {
		const error = {
			type: "error",
			name: "TestError",
			inputs: [],
		} as const;

		const shortData = new Uint8Array([0x12, 0x34]);

		expect(() => decodeParams(error, shortData)).toThrow(
			"Data too short for error selector",
		);
	});

	it("throws error when selector doesn't match", () => {
		const error1 = {
			type: "error",
			name: "Error1",
			inputs: [],
		} as const;

		const error2 = {
			type: "error",
			name: "Error2",
			inputs: [],
		} as const;

		const encoded = encodeParams(error1, []);

		expect(() => decodeParams(error2, encoded)).toThrow(
			"Error selector mismatch",
		);
	});

	it("decodes error with different uint sizes", () => {
		const error = {
			type: "error",
			name: "UintSizes",
			inputs: [
				{ type: "uint8", name: "a" },
				{ type: "uint16", name: "b" },
				{ type: "uint256", name: "c" },
			],
		} as const;

		// biome-ignore lint/suspicious/noExplicitAny: test requires type flexibility
		const args = [1n, 2n, 3n] as any;
		const encoded = encodeParams(error, args);
		const decoded = decodeParams(error, encoded);

		expect(decoded).toEqual(args);
	});

	it("decodes error with nested tuple", () => {
		const error = {
			type: "error",
			name: "NestedTuple",
			inputs: [
				{
					type: "tuple",
					name: "outer",
					components: [
						{ type: "uint256", name: "x" },
						{
							type: "tuple",
							name: "inner",
							components: [
								{ type: "uint256", name: "y" },
								{ type: "uint256", name: "z" },
							],
						},
					],
				},
			],
		} as const;

		const args = [[1n, [2n, 3n]]];
		const encoded = encodeParams(error, args);
		const decoded = decodeParams(error, encoded);

		expect(decoded).toHaveLength(1);
		expect(Array.isArray(decoded[0])).toBe(true);
	});

	it("throws error with empty data", () => {
		const error = {
			type: "error",
			name: "TestError",
			inputs: [],
		} as const;

		const emptyData = new Uint8Array([]);

		expect(() => decodeParams(error, emptyData)).toThrow(
			"Data too short for error selector",
		);
	});

	it("decodes error with multiple string parameters", () => {
		const error = {
			type: "error",
			name: "MultiString",
			inputs: [
				{ type: "string", name: "first" },
				{ type: "string", name: "second" },
			],
		} as const;

		const args = ["Hello", "World"];
		const encoded = encodeParams(error, args);
		const decoded = decodeParams(error, encoded);

		expect(decoded).toEqual(args);
	});
});

```
