---
title: '[TS/JS] src/crypto/Keccak256/index.test.ts'
source: 'src/crypto/Keccak256/index.test.ts'
---

> Auto-generated from test file: src/crypto/Keccak256/index.test.ts

```typescript
import { describe, expect, it } from "vitest";
import * as Keccak256Index from "./index.js";

describe("Keccak256 index exports", () => {
	describe("re-exports from Keccak256.js", () => {
		it("exports all functions", () => {
			expect(Keccak256Index.from).toBeDefined();
			expect(Keccak256Index.hash).toBeDefined();
			expect(Keccak256Index.hashString).toBeDefined();
			expect(Keccak256Index.hashHex).toBeDefined();
			expect(Keccak256Index.hashMultiple).toBeDefined();
			expect(Keccak256Index.selector).toBeDefined();
			expect(Keccak256Index.topic).toBeDefined();
			expect(Keccak256Index.contractAddress).toBeDefined();
			expect(Keccak256Index.create2Address).toBeDefined();
		});

		it("exports constants", () => {
			expect(Keccak256Index.DIGEST_SIZE).toBe(32);
			expect(Keccak256Index.RATE).toBe(136);
			expect(Keccak256Index.STATE_SIZE).toBe(25);
		});

		it("exports Keccak256Hash namespace", () => {
			expect(Keccak256Index.Keccak256Hash).toBeDefined();
		});

		it("exports Keccak256 alias", () => {
			expect(Keccak256Index.Keccak256).toBeDefined();
		});
	});

	describe("type exports", () => {
		it("exports Keccak256Hash type", () => {
			type Test = typeof Keccak256Index extends {
				Keccak256Hash: unknown;
			}
				? true
				: false;
			const _assertion: Test = true;
			_assertion;
		});
	});

	describe("functional verification", () => {
		it("hash function works", () => {
			const result = Keccak256Index.hash(new Uint8Array([1, 2, 3]));
			expect(result.length).toBe(32);
			expect(result).toBeInstanceOf(Uint8Array);
		});

		it("hashString function works", () => {
			const result = Keccak256Index.hashString("hello");
			expect(result.length).toBe(32);
		});

		it("hashHex function works", () => {
			const result = Keccak256Index.hashHex("0x1234");
			expect(result.length).toBe(32);
		});

		it("selector function works", () => {
			const result = Keccak256Index.selector("transfer(address,uint256)");
			expect(result.length).toBe(4);
		});

		it("topic function works", () => {
			const result = Keccak256Index.topic("Transfer(address,address,uint256)");
			expect(result.length).toBe(32);
		});

		it("contractAddress function works", () => {
			const result = Keccak256Index.contractAddress(new Uint8Array(20), 0n);
			expect(result.length).toBe(20);
		});

		it("create2Address function works", () => {
			const result = Keccak256Index.create2Address(
				new Uint8Array(20),
				new Uint8Array(32),
				new Uint8Array(32),
			);
			expect(result.length).toBe(20);
		});

		it("from function works", () => {
			const result = Keccak256Index.from(new Uint8Array([1, 2, 3]));
			expect(result.length).toBe(32);
		});

		it("hashMultiple function works", () => {
			const result = Keccak256Index.hashMultiple([
				new Uint8Array([1, 2]),
				new Uint8Array([3, 4]),
			]);
			expect(result.length).toBe(32);
		});
	});

	describe("namespace accessibility", () => {
		it("Keccak256Hash is callable", () => {
			const result = Keccak256Index.Keccak256Hash(new Uint8Array([1, 2, 3]));
			expect(result.length).toBe(32);
		});

		it("Keccak256Hash has all methods", () => {
			expect(typeof Keccak256Index.Keccak256Hash.hash).toBe("function");
			expect(typeof Keccak256Index.Keccak256Hash.hashString).toBe("function");
			expect(typeof Keccak256Index.Keccak256Hash.hashHex).toBe("function");
			expect(typeof Keccak256Index.Keccak256Hash.selector).toBe("function");
			expect(typeof Keccak256Index.Keccak256Hash.topic).toBe("function");
		});

		it("Keccak256 alias works", () => {
			expect(Keccak256Index.Keccak256).toBe(Keccak256Index.Keccak256Hash);
		});
	});

	describe("constants from namespace", () => {
		it("DIGEST_SIZE is 32", () => {
			expect(Keccak256Index.DIGEST_SIZE).toBe(32);
		});

		it("RATE is 136", () => {
			expect(Keccak256Index.RATE).toBe(136);
		});

		it("STATE_SIZE is 25", () => {
			expect(Keccak256Index.STATE_SIZE).toBe(25);
		});

		it("namespace constants match module constants", () => {
			expect(Keccak256Index.Keccak256Hash.DIGEST_SIZE).toBe(
				Keccak256Index.DIGEST_SIZE,
			);
			expect(Keccak256Index.Keccak256Hash.RATE).toBe(Keccak256Index.RATE);
			expect(Keccak256Index.Keccak256Hash.STATE_SIZE).toBe(
				Keccak256Index.STATE_SIZE,
			);
		});
	});

	describe("single source of truth", () => {
		it("functions are same references", () => {
			expect(Keccak256Index.hash).toBe(Keccak256Index.Keccak256Hash.hash);
			expect(Keccak256Index.hashString).toBe(
				Keccak256Index.Keccak256Hash.hashString,
			);
			expect(Keccak256Index.hashHex).toBe(Keccak256Index.Keccak256Hash.hashHex);
			expect(Keccak256Index.selector).toBe(
				Keccak256Index.Keccak256Hash.selector,
			);
			expect(Keccak256Index.topic).toBe(Keccak256Index.Keccak256Hash.topic);
		});
	});

	describe("import patterns", () => {
		it("supports named imports", () => {
			const { hash, hashString, selector } = Keccak256Index;

			const hash1 = hash(new Uint8Array([1]));
			const hash2 = hashString("test");
			const sel = selector("func()");

			expect(hash1.length).toBe(32);
			expect(hash2.length).toBe(32);
			expect(sel.length).toBe(4);
		});

		it("supports namespace import", () => {
			const data = new Uint8Array([1, 2, 3]);

			const result1 = Keccak256Index.hash(data);
			const result2 = Keccak256Index.Keccak256Hash.hash(data);

			expect(result1).toEqual(result2);
		});

		it("supports Keccak256Hash namespace import", () => {
			const { Keccak256Hash } = Keccak256Index;

			const result = Keccak256Hash.hash(new Uint8Array([1, 2, 3]));
			expect(result.length).toBe(32);
		});
	});

	describe("completeness", () => {
		it("exports all expected functions", () => {
			const expectedFunctions = [
				"from",
				"hash",
				"hashString",
				"hashHex",
				"hashMultiple",
				"selector",
				"topic",
				"contractAddress",
				"create2Address",
			];

			for (const func of expectedFunctions) {
				expect(Keccak256Index).toHaveProperty(func);
				expect(
					typeof (Keccak256Index as unknown as Record<string, unknown>)[func],
				).toBe("function");
			}
		});

		it("exports all expected constants", () => {
			const expectedConstants = ["DIGEST_SIZE", "RATE", "STATE_SIZE"];

			for (const constant of expectedConstants) {
				expect(Keccak256Index).toHaveProperty(constant);
				expect(
					typeof (Keccak256Index as unknown as Record<string, unknown>)[
						constant
					],
				).toBe("number");
			}
		});

		it("exports all expected namespaces", () => {
			const expectedNamespaces = ["Keccak256Hash", "Keccak256"];

			for (const namespace of expectedNamespaces) {
				expect(Keccak256Index).toHaveProperty(namespace);
			}
		});
	});

	describe("Ethereum use cases", () => {
		it("supports computing transaction hash", () => {
			const txData = new Uint8Array([0x60, 0x80, 0x60, 0x40]);
			const txHash = Keccak256Index.hash(txData);

			expect(txHash.length).toBe(32);
		});

		it("supports function selector computation", () => {
			const selector = Keccak256Index.selector("balanceOf(address)");

			expect(selector.length).toBe(4);
			expect(selector[0]).toBe(0x70);
		});

		it("supports event topic computation", () => {
			const topic = Keccak256Index.topic("Transfer(address,address,uint256)");

			expect(topic.length).toBe(32);
			expect(topic[0]).toBe(0xdd);
		});

		it("supports CREATE address derivation", () => {
			const deployer = new Uint8Array(20).fill(0x12);
			const addr = Keccak256Index.contractAddress(deployer, 0n);

			expect(addr.length).toBe(20);
		});

		it("supports CREATE2 address derivation", () => {
			const factory = new Uint8Array(20);
			const salt = new Uint8Array(32);
			const initCodeHash = new Uint8Array(32);

			const addr = Keccak256Index.create2Address(factory, salt, initCodeHash);

			expect(addr.length).toBe(20);
		});
	});

	describe("consistency", () => {
		it("direct function matches namespace function", () => {
			const data = new Uint8Array([1, 2, 3]);

			const direct = Keccak256Index.hash(data);
			const namespace = Keccak256Index.Keccak256Hash.hash(data);

			expect(direct).toEqual(namespace);
		});

		it("all hash variants produce 32 bytes", () => {
			const hash1 = Keccak256Index.hash(new Uint8Array([1]));
			const hash2 = Keccak256Index.hashString("test");
			const hash3 = Keccak256Index.hashHex("0x12");
			const hash4 = Keccak256Index.hashMultiple([new Uint8Array([1])]);
			const hash5 = Keccak256Index.from(new Uint8Array([1]));

			expect(hash1.length).toBe(32);
			expect(hash2.length).toBe(32);
			expect(hash3.length).toBe(32);
			expect(hash4.length).toBe(32);
			expect(hash5.length).toBe(32);
		});
	});

	describe("module structure", () => {
		it("has clean public API", () => {
			const exports = Object.keys(Keccak256Index);

			expect(exports).toContain("hash");
			expect(exports).toContain("hashString");
			expect(exports).toContain("Keccak256Hash");
			expect(exports).toContain("DIGEST_SIZE");
		});

		it("no unexpected exports", () => {
			const expectedExports = [
				"from",
				"hash",
				"hashString",
				"hashHex",
				"hashMultiple",
				"selector",
				"topic",
				"contractAddress",
				"create2Address",
				"Keccak256Hash",
				"Keccak256",
				"Keccak256Error",
				"DIGEST_SIZE",
				"RATE",
				"STATE_SIZE",
			];

			const actualExports = Object.keys(Keccak256Index);

			for (const key of actualExports) {
				expect(expectedExports).toContain(key);
			}
		});
	});
});

```
