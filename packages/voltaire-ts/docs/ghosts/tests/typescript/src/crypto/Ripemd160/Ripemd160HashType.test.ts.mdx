---
title: '[TS/JS] src/crypto/Ripemd160/Ripemd160HashType.test.ts'
source: 'src/crypto/Ripemd160/Ripemd160HashType.test.ts'
---

> Auto-generated from test file: src/crypto/Ripemd160/Ripemd160HashType.test.ts

```typescript
import { describe, expectTypeOf, it } from "vitest";
import type { Ripemd160Hash } from "./Ripemd160HashType.js";
import { SIZE } from "./Ripemd160HashType.js";

type Equals<T, U> =
	(<G>() => G extends T ? 1 : 2) extends <G>() => G extends U ? 1 : 2
		? true
		: false;

describe("Ripemd160HashType", () => {
	describe("type structure", () => {
		it("Ripemd160Hash is Uint8Array with brand", () => {
			expectTypeOf<Ripemd160Hash>().toMatchTypeOf<Uint8Array>();
		});

		it("Ripemd160Hash has readonly brand property", () => {
			type HasBrand = Ripemd160Hash extends {
				readonly [key: symbol]: string;
			}
				? true
				: false;
			const result: HasBrand = true;
			expectTypeOf(result).toEqualTypeOf<true>();
		});

		it("Ripemd160Hash is not plain Uint8Array", () => {
			type NotPlainArray = Equals<Ripemd160Hash, Uint8Array>;
			const result: NotPlainArray = false;
			expectTypeOf(result).toEqualTypeOf<false>();
		});
	});

	describe("SIZE constant", () => {
		it("SIZE is number literal type", () => {
			expectTypeOf<typeof SIZE>().toEqualTypeOf<20>();
		});

		it("SIZE equals 20", () => {
			type Test = typeof SIZE extends 20 ? true : false;
			const result: Test = true;
			expectTypeOf(result).toEqualTypeOf<true>();
		});

		it("SIZE is literal type", () => {
			expectTypeOf(SIZE).toEqualTypeOf<20>();
		});
	});

	describe("branded type safety", () => {
		it("prevents direct assignment from Uint8Array", () => {
			const arr = new Uint8Array(20);
			// @ts-expect-error - Uint8Array cannot be assigned to Ripemd160Hash
			const hash: Ripemd160Hash = arr;
			expectTypeOf(hash).toMatchTypeOf<Uint8Array>();
		});

		it("requires explicit type assertion", () => {
			const arr = new Uint8Array(20);
			const hash = arr as Ripemd160Hash;
			expectTypeOf(hash).toEqualTypeOf<Ripemd160Hash>();
		});

		it("prevents assignment of differently branded types", () => {
			type OtherHash = Uint8Array & { readonly __tag: "OtherHash" };
			const otherHash = new Uint8Array(20) as OtherHash;
			// @ts-expect-error - OtherHash cannot be assigned to Ripemd160Hash
			const ripemd160Hash: Ripemd160Hash = otherHash;
			expectTypeOf(ripemd160Hash).toMatchTypeOf<Uint8Array>();
		});
	});

	describe("usage patterns", () => {
		it("Ripemd160Hash for function parameters", () => {
			function acceptsHash(_value: Ripemd160Hash): void {}
			expectTypeOf(acceptsHash).parameter(0).toMatchTypeOf<Ripemd160Hash>();
		});

		it("Ripemd160Hash for function returns", () => {
			function returnsHash(): Ripemd160Hash {
				return new Uint8Array(20) as Ripemd160Hash;
			}
			expectTypeOf(returnsHash).returns.toEqualTypeOf<Ripemd160Hash>();
		});

		it("Ripemd160Hash in arrays", () => {
			type HashArray = Ripemd160Hash[];
			expectTypeOf<HashArray>().toEqualTypeOf<Ripemd160Hash[]>();
		});

		it("Ripemd160Hash in objects", () => {
			type HashContainer = { hash: Ripemd160Hash };
			expectTypeOf<HashContainer>().toEqualTypeOf<{ hash: Ripemd160Hash }>();
		});

		it("Ripemd160Hash in tuples", () => {
			type HashTuple = [Ripemd160Hash, Ripemd160Hash];
			expectTypeOf<HashTuple>().toEqualTypeOf<[Ripemd160Hash, Ripemd160Hash]>();
		});
	});

	describe("type narrowing", () => {
		it("narrows from Uint8Array to Ripemd160Hash", () => {
			function isRipemd160Hash(value: Uint8Array): value is Ripemd160Hash {
				return value.length === 20;
			}
			expectTypeOf(isRipemd160Hash).returns.toEqualTypeOf<boolean>();
		});

		it("discriminates union types", () => {
			type Result = Ripemd160Hash | Error;
			function isHash(value: Result): value is Ripemd160Hash {
				return value instanceof Uint8Array;
			}
			expectTypeOf(isHash).returns.toEqualTypeOf<boolean>();
		});
	});

	describe("readonly behavior", () => {
		it("brand property is readonly", () => {
			type BrandIsReadonly = Ripemd160Hash extends {
				readonly [key: symbol]: string;
			}
				? true
				: false;
			const result: BrandIsReadonly = true;
			expectTypeOf(result).toEqualTypeOf<true>();
		});

		it("preserves Uint8Array mutability", () => {
			const hash = new Uint8Array(20) as Ripemd160Hash;
			expectTypeOf(hash[0]).toEqualTypeOf<number>();
		});
	});

	describe("compatibility", () => {
		it("accepts as Uint8Array parameter", () => {
			function acceptsUint8Array(_value: Uint8Array): void {}
			const hash = new Uint8Array(20) as Ripemd160Hash;
			expectTypeOf(hash).toMatchTypeOf<
				Parameters<typeof acceptsUint8Array>[0]
			>();
		});

		it("compatible with ArrayLike", () => {
			type IsArrayLike = Ripemd160Hash extends ArrayLike<number> ? true : false;
			const result: IsArrayLike = true;
			expectTypeOf(result).toEqualTypeOf<true>();
		});

		it("has length property", () => {
			const hash = new Uint8Array(20) as Ripemd160Hash;
			expectTypeOf(hash.length).toEqualTypeOf<number>();
		});
	});

	describe("Bitcoin compatibility", () => {
		it("suitable for hash160 output", () => {
			type Hash160 = Ripemd160Hash;
			expectTypeOf<Hash160>().toEqualTypeOf<Ripemd160Hash>();
		});

		it("can represent address hash", () => {
			type AddressHash = Ripemd160Hash;
			const addressHash = new Uint8Array(20) as AddressHash;
			expectTypeOf(addressHash).toEqualTypeOf<Ripemd160Hash>();
		});

		it("compatible with 20-byte buffer operations", () => {
			function process20Bytes(_data: Uint8Array): void {}
			const hash = new Uint8Array(20) as Ripemd160Hash;
			expectTypeOf(hash).toMatchTypeOf<Parameters<typeof process20Bytes>[0]>();
		});
	});

	describe("invalid cases", () => {
		it("rejects plain object", () => {
			// @ts-expect-error - plain object is not Ripemd160Hash
			const test: Ripemd160Hash = {};
			expectTypeOf(test).not.toEqualTypeOf<object>();
		});

		it("rejects number array", () => {
			// @ts-expect-error - number[] is not Ripemd160Hash
			const test: Ripemd160Hash = [1, 2, 3];
			expectTypeOf(test).not.toEqualTypeOf<number[]>();
		});

		it("rejects string", () => {
			// @ts-expect-error - string is not Ripemd160Hash
			const test: Ripemd160Hash = "hash";
			expectTypeOf(test).not.toEqualTypeOf<string>();
		});

		it("rejects null", () => {
			// @ts-expect-error - null is not Ripemd160Hash
			const test: Ripemd160Hash = null;
			expectTypeOf(test).not.toEqualTypeOf<null>();
		});

		it("rejects undefined", () => {
			// @ts-expect-error - undefined is not Ripemd160Hash
			const test: Ripemd160Hash = undefined;
			expectTypeOf(test).not.toEqualTypeOf<undefined>();
		});
	});
});

```
