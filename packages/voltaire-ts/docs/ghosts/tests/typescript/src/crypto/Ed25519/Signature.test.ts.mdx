---
title: '[TS/JS] src/crypto/Ed25519/Signature.test.ts'
source: 'src/crypto/Ed25519/Signature.test.ts'
---

> Auto-generated from test file: src/crypto/Ed25519/Signature.test.ts

```typescript
import { describe, expectTypeOf, it } from "vitest";
import type { Signature } from "./Signature.js";

type Equals<T, U> =
	(<G>() => G extends T ? 1 : 2) extends <G>() => G extends U ? 1 : 2
		? true
		: false;

describe("Ed25519 Signature Type", () => {
	describe("type structure", () => {
		it("Signature is Uint8Array", () => {
			expectTypeOf<Signature>().toEqualTypeOf<Uint8Array>();
		});

		it("Signature matches Uint8Array exactly", () => {
			type Test = Equals<Signature, Uint8Array>;
			const result: Test = true;
			expectTypeOf(result).toEqualTypeOf<true>();
		});

		it("accepts Uint8Array instances", () => {
			const arr = new Uint8Array(64);
			expectTypeOf(arr).toMatchTypeOf<Signature>();
		});

		it("is assignable to Uint8Array", () => {
			type Test = Signature extends Uint8Array ? true : false;
			const result: Test = true;
			expectTypeOf(result).toEqualTypeOf<true>();
		});
	});

	describe("usage patterns", () => {
		it("Signature for function parameters", () => {
			function acceptsSignature(_sig: Signature): void {}
			expectTypeOf(acceptsSignature).parameter(0).toEqualTypeOf<Signature>();
		});

		it("Signature for function returns", () => {
			function returnsSignature(): Signature {
				return new Uint8Array(64);
			}
			expectTypeOf(returnsSignature).returns.toEqualTypeOf<Signature>();
		});

		it("Signature in arrays", () => {
			type SigArray = Signature[];
			expectTypeOf<SigArray>().toEqualTypeOf<Signature[]>();
		});

		it("Signature in verification contexts", () => {
			type VerificationData = {
				signature: Signature;
				message: Uint8Array;
			};
			expectTypeOf<VerificationData>().toEqualTypeOf<{
				signature: Signature;
				message: Uint8Array;
			}>();
		});

		it("Signature with optional metadata", () => {
			type SignatureWithMeta = {
				signature: Signature;
				timestamp?: number;
			};
			expectTypeOf<SignatureWithMeta>().toEqualTypeOf<{
				signature: Signature;
				timestamp?: number;
			}>();
		});
	});

	describe("type compatibility", () => {
		it("compatible with typed arrays", () => {
			const sig: Signature = new Uint8Array(64);
			expectTypeOf(sig).toEqualTypeOf<Signature>();
		});

		it("compatible with ArrayBuffer views", () => {
			const buffer = new ArrayBuffer(64);
			const sig: Signature = new Uint8Array(buffer);
			expectTypeOf(sig).toEqualTypeOf<Signature>();
		});

		it("not compatible with string", () => {
			// @ts-expect-error - string is not Signature
			const sig: Signature = "0x123";
			expectTypeOf(sig).not.toEqualTypeOf<string>();
		});

		it("not compatible with hex string", () => {
			// @ts-expect-error - hex string is not Signature
			const sig: Signature =
				"0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef";
			expectTypeOf(sig).not.toEqualTypeOf<string>();
		});

		it("not compatible with bigint", () => {
			// @ts-expect-error - bigint is not Signature
			const sig: Signature = 123n;
			expectTypeOf(sig).not.toEqualTypeOf<bigint>();
		});

		it("not compatible with object with r,s", () => {
			// @ts-expect-error - object is not Signature
			const sig: Signature = { r: new Uint8Array(32), s: new Uint8Array(32) };
			expectTypeOf(sig).not.toEqualTypeOf<{ r: Uint8Array; s: Uint8Array }>();
		});
	});

	describe("signature components", () => {
		it("represents concatenated R||S format", () => {
			const sig: Signature = new Uint8Array(64);
			const r = sig.slice(0, 32);
			const s = sig.slice(32, 64);
			expectTypeOf(r).toEqualTypeOf<Uint8Array>();
			expectTypeOf(s).toEqualTypeOf<Uint8Array>();
		});

		it("supports extracting components", () => {
			function extractComponents(sig: Signature): {
				r: Uint8Array;
				s: Uint8Array;
			} {
				return { r: sig.slice(0, 32), s: sig.slice(32, 64) };
			}
			expectTypeOf(extractComponents).returns.toEqualTypeOf<{
				r: Uint8Array;
				s: Uint8Array;
			}>();
		});
	});

	describe("type narrowing", () => {
		it("narrows from Uint8Array to Signature", () => {
			function isSignature(value: Uint8Array): value is Signature {
				return value.length === 64;
			}
			expectTypeOf(isSignature).returns.toEqualTypeOf<boolean>();
		});

		it("discriminates union types", () => {
			type Result = Signature | Error;
			function isSig(value: Result): value is Signature {
				return value instanceof Uint8Array;
			}
			expectTypeOf(isSig).returns.toEqualTypeOf<boolean>();
		});

		it("handles optional signatures", () => {
			type MaybeSignature = Signature | undefined;
			function hasSig(value: MaybeSignature): value is Signature {
				return value !== undefined;
			}
			expectTypeOf(hasSig).returns.toEqualTypeOf<boolean>();
		});
	});

	describe("readonly and mutability", () => {
		it("mutable by default", () => {
			const sig: Signature = new Uint8Array(64);
			sig[0] = 1;
			expectTypeOf(sig).toEqualTypeOf<Signature>();
		});

		it("can be made readonly", () => {
			const sig: Readonly<Signature> = new Uint8Array(64);
			expectTypeOf(sig).toEqualTypeOf<Readonly<Signature>>();
		});

		it("readonly prevents modification", () => {
			const sig: Readonly<Signature> = new Uint8Array(64);
			// @ts-expect-error - readonly prevents assignment
			sig[0] = 1;
			expectTypeOf(sig).toMatchTypeOf<Readonly<Uint8Array>>();
		});
	});
});

```
