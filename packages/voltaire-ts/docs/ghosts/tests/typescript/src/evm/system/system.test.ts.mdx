---
title: '[TS/JS] src/evm/system/system.test.ts'
source: 'src/evm/system/system.test.ts'
---

> Auto-generated from test file: src/evm/system/system.test.ts

```typescript
import { describe, expect, test } from "vitest";
import type { BrandedFrame } from "../Frame/FrameType.js";
import { create } from "./0xf0_CREATE.js";
import { call } from "./0xf1_CALL.js";
import { delegatecall } from "./0xf4_DELEGATECALL.js";
import { create2 } from "./0xf5_CREATE2.js";
import { staticcall } from "./0xfa_STATICCALL.js";
import { selfdestruct } from "./0xff_SELFDESTRUCT.js";

/**
 * Create a minimal test frame
 */
function createFrame(overrides?: Partial<BrandedFrame>): BrandedFrame {
	return {
		__tag: "Frame",
		stack: [],
		memory: new Map(),
		memorySize: 0,
		pc: 0,
		gasRemaining: 1000000n,
		bytecode: new Uint8Array(0),
		// biome-ignore lint/suspicious/noExplicitAny: mock Frame for test
		caller: new Uint8Array(20) as any,
		// biome-ignore lint/suspicious/noExplicitAny: mock Frame for test
		address: new Uint8Array(20) as any,
		value: 0n,
		calldata: new Uint8Array(0),
		output: new Uint8Array(0),
		returnData: new Uint8Array(0),
		stopped: false,
		reverted: false,
		isStatic: false,
		authorized: null,
		callDepth: 0,
		...overrides,
	};
}

describe("CREATE (0xf0)", () => {
	test("rejects in static context", () => {
		const frame = createFrame({ isStatic: true });
		frame.stack = [0n, 0n, 0n]; // length, offset, value

		const err = create(frame);

		expect(err).toEqual({ type: "WriteProtection" });
	});

	test("consumes gas correctly for empty init code (before NotImplemented)", () => {
		const frame = createFrame();
		frame.stack = [0n, 0n, 0n]; // length=0, offset=0, value=0
		const initialGas = frame.gasRemaining;

		const err = create(frame);

		// Gas is consumed before NotImplemented check
		// Base cost: 32000
		expect(initialGas - frame.gasRemaining).toBe(32000n);
		expect(err).toEqual({
			type: "NotImplemented",
			message:
				"CREATE requires host.create() - use guillotine or guillotine-mini for full EVM execution",
		});
	});

	test("calculates gas with init code (before NotImplemented)", () => {
		const frame = createFrame();
		// Create 32 bytes of init code (1 word)
		frame.stack = [32n, 0n, 0n]; // length=32, offset=0, value=0
		const initialGas = frame.gasRemaining;

		const err = create(frame);

		// Gas is consumed before NotImplemented check
		// Base: 32000 + init code word cost (1 word * 2 gas) = 32002
		// Memory expansion for 32 bytes: newWords=1, cost = 3*1 + 1^2/512 = 3
		// Total: 32000 + 2 + 3 = 32005
		expect(initialGas - frame.gasRemaining).toBe(32005n);
		expect(err).toEqual({
			type: "NotImplemented",
			message:
				"CREATE requires host.create() - use guillotine or guillotine-mini for full EVM execution",
		});
	});

	test("returns NotImplemented when host.create not provided", () => {
		const frame = createFrame();
		frame.stack = [0n, 0n, 0n]; // length=0, offset=0, value=0

		const err = create(frame);

		expect(err).toEqual({
			type: "NotImplemented",
			message:
				"CREATE requires host.create() - use guillotine or guillotine-mini for full EVM execution",
		});
	});

	test("clears return data before NotImplemented check", () => {
		const frame = createFrame({
			returnData: new Uint8Array([1, 2, 3]),
		});
		frame.stack = [0n, 0n, 0n];

		create(frame);

		// Return data is cleared before the NotImplemented check
		expect(frame.returnData).toHaveLength(0);
	});

	test("fails on stack underflow", () => {
		const frame = createFrame();
		frame.stack = [0n]; // Only 1 item, need 3

		const err = create(frame);

		expect(err).toEqual({ type: "StackUnderflow" });
	});

	test("fails on out of gas", () => {
		const frame = createFrame({ gasRemaining: 100n });
		frame.stack = [0n, 0n, 0n];

		const err = create(frame);

		expect(err).toEqual({ type: "OutOfGas" });
		expect(frame.gasRemaining).toBe(0n);
	});
});

describe("CALL (0xf1)", () => {
	test("rejects value transfer in static context", () => {
		const frame = createFrame({ isStatic: true });
		// Stack: gas, address, value, inOffset, inLength, outOffset, outLength (bottom to top)
		frame.stack = [10000n, 0n, 1n, 0n, 0n, 0n, 0n];

		const err = call(frame);

		expect(err).toEqual({ type: "WriteProtection" });
	});

	test("allows zero value in static context (returns NotImplemented)", () => {
		const frame = createFrame({ isStatic: true });
		// Stack: gas, address, value=0, inOffset, inLength, outOffset, outLength (bottom to top)
		frame.stack = [10000n, 0n, 0n, 0n, 0n, 0n, 0n];

		const err = call(frame);

		// Zero value is allowed in static context, but still needs host.call
		expect(err).toEqual({
			type: "NotImplemented",
			message:
				"CALL requires host.call() - use guillotine or guillotine-mini for full EVM execution",
		});
	});

	test("consumes base gas cost (before NotImplemented)", () => {
		const frame = createFrame();
		// Stack: gas, address, value, inOffset, inLength, outOffset, outLength (bottom to top)
		frame.stack = [10000n, 0n, 0n, 0n, 0n, 0n, 0n];
		const initialGas = frame.gasRemaining;

		const err = call(frame);

		// Gas is consumed before NotImplemented check
		// Base cost: 700 (post-EIP-150) + forwarded gas
		expect(initialGas - frame.gasRemaining).toBeGreaterThan(700n);
		expect(err).toEqual({
			type: "NotImplemented",
			message:
				"CALL requires host.call() - use guillotine or guillotine-mini for full EVM execution",
		});
	});

	test("adds value transfer cost (before NotImplemented)", () => {
		const frame = createFrame();
		// Stack: gas, address, value, inOffset, inLength, outOffset, outLength (bottom to top)
		frame.stack = [10000n, 0n, 1n, 0n, 0n, 0n, 0n];
		const initialGas = frame.gasRemaining;

		const err = call(frame);

		// Gas is consumed before NotImplemented check
		// Base: 700 + value transfer: 9000 + gas forwarded
		expect(initialGas - frame.gasRemaining).toBeGreaterThan(9700n);
		expect(err).toEqual({
			type: "NotImplemented",
			message:
				"CALL requires host.call() - use guillotine or guillotine-mini for full EVM execution",
		});
	});

	test("handles memory expansion (before NotImplemented)", () => {
		const frame = createFrame();
		// Stack: gas, address, value, inOffset, inLength, outOffset, outLength (bottom to top)
		frame.stack = [10000n, 0n, 0n, 0n, 32n, 0n, 0n];
		const initialGas = frame.gasRemaining;

		const err = call(frame);

		// Gas and memory expansion happen before NotImplemented check
		expect(frame.memorySize).toBe(32);
		expect(initialGas - frame.gasRemaining).toBeGreaterThan(700n);
		expect(err).toEqual({
			type: "NotImplemented",
			message:
				"CALL requires host.call() - use guillotine or guillotine-mini for full EVM execution",
		});
	});

	test("returns NotImplemented when host.call not provided", () => {
		const frame = createFrame();
		frame.stack = [10000n, 0n, 0n, 0n, 0n, 0n, 0n];

		const err = call(frame);

		expect(err).toEqual({
			type: "NotImplemented",
			message:
				"CALL requires host.call() - use guillotine or guillotine-mini for full EVM execution",
		});
	});

	test("fails on stack underflow", () => {
		const frame = createFrame();
		frame.stack = [0n, 0n]; // Only 2 items, need 7

		const err = call(frame);

		expect(err).toEqual({ type: "StackUnderflow" });
	});

	test("fails on out of gas", () => {
		const frame = createFrame({ gasRemaining: 100n });
		frame.stack = [10000n, 0n, 0n, 0n, 0n, 0n, 0n];

		const err = call(frame);

		expect(err).toEqual({ type: "OutOfGas" });
		expect(frame.gasRemaining).toBe(0n);
	});
});

describe("CREATE2 (0xf5)", () => {
	test("rejects in static context", () => {
		const frame = createFrame({ isStatic: true });
		frame.stack = [0n, 0n, 0n, 0n]; // salt, length, offset, value

		const err = create2(frame);

		expect(err).toEqual({ type: "WriteProtection" });
	});

	test("consumes gas with keccak256 cost then returns NotImplemented", () => {
		const frame = createFrame();
		// Create 32 bytes of init code (1 word)
		frame.stack = [0n, 32n, 0n, 0n]; // salt=0, length=32, offset=0, value=0
		const initialGas = frame.gasRemaining;

		const err = create2(frame);

		// Gas is consumed before NotImplemented check
		// Base: 32000 + init code (1 word * 2) + keccak256 (1 word * 6) + memory (3)
		// Total: 32000 + 2 + 6 + 3 = 32011
		expect(initialGas - frame.gasRemaining).toBe(32011n);
		expect(err).toEqual({
			type: "NotImplemented",
			message:
				"CREATE2 requires host.create() - use guillotine or guillotine-mini for full EVM execution",
		});
	});
});

describe("DELEGATECALL (0xf4)", () => {
	test("takes 6 arguments and returns NotImplemented", () => {
		const frame = createFrame();
		frame.stack = [0n, 0n, 0n, 0n, 0n, 10000n]; // 6 args

		const err = delegatecall(frame);

		expect(err).toEqual({
			type: "NotImplemented",
			message:
				"DELEGATECALL requires host.call() - use guillotine or guillotine-mini for full EVM execution",
		});
	});
});

describe("STATICCALL (0xfa)", () => {
	test("takes 6 arguments and returns NotImplemented", () => {
		const frame = createFrame();
		frame.stack = [0n, 0n, 0n, 0n, 0n, 10000n]; // 6 args

		const err = staticcall(frame);

		expect(err).toEqual({
			type: "NotImplemented",
			message:
				"STATICCALL requires host.call() - use guillotine or guillotine-mini for full EVM execution",
		});
	});
});

describe("SELFDESTRUCT (0xff)", () => {
	test("rejects in static context after gas charge", () => {
		const frame = createFrame({ isStatic: true });
		frame.stack = [0n]; // beneficiary
		const initialGas = frame.gasRemaining;

		const err = selfdestruct(frame);

		expect(err).toEqual({ type: "WriteProtection" });
		// Gas should have been charged before static check
		expect(frame.gasRemaining).toBeLessThan(initialGas);
	});

	test("consumes base gas", () => {
		const frame = createFrame();
		frame.stack = [0n]; // beneficiary
		const initialGas = frame.gasRemaining;

		const err = selfdestruct(frame);

		expect(err).toBeNull();
		// Base cost: 5000
		expect(initialGas - frame.gasRemaining).toBe(5000n);
	});

	test("sets stopped flag", () => {
		const frame = createFrame();
		frame.stack = [0n];

		const err = selfdestruct(frame);

		expect(err).toBeNull();
		expect(frame.stopped).toBe(true);
	});

	test("does not increment pc (stopped)", () => {
		const frame = createFrame({ pc: 42 });
		frame.stack = [0n];

		selfdestruct(frame);

		expect(frame.pc).toBe(42); // Not incremented
	});

	test("does not push to stack", () => {
		const frame = createFrame();
		frame.stack = [0n];

		selfdestruct(frame);

		expect(frame.stack).toHaveLength(0);
	});

	test("fails on stack underflow", () => {
		const frame = createFrame();
		frame.stack = []; // Empty stack

		const err = selfdestruct(frame);

		expect(err).toEqual({ type: "StackUnderflow" });
	});

	test("fails on out of gas", () => {
		const frame = createFrame({ gasRemaining: 100n });
		frame.stack = [0n];

		const err = selfdestruct(frame);

		expect(err).toEqual({ type: "OutOfGas" });
		expect(frame.gasRemaining).toBe(0n);
	});
});

```
