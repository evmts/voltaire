---
title: '[TS/JS] src/evm/block/0x42_TIMESTAMP.test.ts'
source: 'src/evm/block/0x42_TIMESTAMP.test.ts'
---

> Auto-generated from test file: src/evm/block/0x42_TIMESTAMP.test.ts

```typescript
import { describe, expect, it } from "vitest";
import { Address } from "../../primitives/Address/index.js";
import type { BrandedFrame } from "../Frame/FrameType.js";
import { handler_0x42_TIMESTAMP } from "./0x42_TIMESTAMP.js";

describe("TIMESTAMP (0x42)", () => {
	it("pushes block timestamp to stack", () => {
		const frame: BrandedFrame = {
			__tag: "Frame",
			stack: [],
			memory: new Map(),
			memorySize: 0,
			pc: 0,
			gasRemaining: 1000n,
			bytecode: new Uint8Array([0x42]),
			caller: Address("0x0000000000000000000000000000000000000001"),
			address: Address("0x0000000000000000000000000000000000000002"),
			value: 0n,
			calldata: new Uint8Array(),
			output: new Uint8Array(),
			returnData: new Uint8Array(),
			stopped: false,
			reverted: false,
			isStatic: false,
			authorized: null,
			callDepth: 0,
			blockTimestamp: 1699999999n,
		};

		const error = handler_0x42_TIMESTAMP(frame);

		expect(error).toBe(null);
		expect(frame.stack).toHaveLength(1);
		expect(frame.stack[0]).toBe(1699999999n);
		expect(frame.pc).toBe(1);
		expect(frame.gasRemaining).toBe(998n);
	});

	it("defaults to 0 if frame blockTimestamp not set", () => {
		const frame: BrandedFrame = {
			__tag: "Frame",
			stack: [],
			memory: new Map(),
			memorySize: 0,
			pc: 0,
			gasRemaining: 1000n,
			bytecode: new Uint8Array([0x42]),
			caller: Address("0x0000000000000000000000000000000000000001"),
			address: Address("0x0000000000000000000000000000000000000002"),
			value: 0n,
			calldata: new Uint8Array(),
			output: new Uint8Array(),
			returnData: new Uint8Array(),
			stopped: false,
			reverted: false,
			isStatic: false,
			authorized: null,
			callDepth: 0,
		};

		const error = handler_0x42_TIMESTAMP(frame);

		expect(error).toBe(null);
		expect(frame.stack).toHaveLength(1);
		// Defaults to 0 when blockTimestamp not provided (caller should set it)
		expect(frame.stack[0]).toBe(0n);
		expect(frame.pc).toBe(1);
	});

	it("returns OutOfGas when insufficient gas", () => {
		const frame: BrandedFrame = {
			__tag: "Frame",
			stack: [],
			memory: new Map(),
			memorySize: 0,
			pc: 0,
			gasRemaining: 1n,
			bytecode: new Uint8Array([0x42]),
			caller: Address("0x0000000000000000000000000000000000000001"),
			address: Address("0x0000000000000000000000000000000000000002"),
			value: 0n,
			calldata: new Uint8Array(),
			output: new Uint8Array(),
			returnData: new Uint8Array(),
			stopped: false,
			reverted: false,
			isStatic: false,
			authorized: null,
			callDepth: 0,
			blockTimestamp: 1699999999n,
		};

		const error = handler_0x42_TIMESTAMP(frame);

		expect(error).toEqual({ type: "OutOfGas" });
		expect(frame.gasRemaining).toBe(0n);
		expect(frame.stack).toHaveLength(0);
	});

	it("returns StackOverflow when stack is full", () => {
		const frame: BrandedFrame = {
			__tag: "Frame",
			stack: Array(1024).fill(1n),
			memory: new Map(),
			memorySize: 0,
			pc: 0,
			gasRemaining: 1000n,
			bytecode: new Uint8Array([0x42]),
			caller: Address("0x0000000000000000000000000000000000000001"),
			address: Address("0x0000000000000000000000000000000000000002"),
			value: 0n,
			calldata: new Uint8Array(),
			output: new Uint8Array(),
			returnData: new Uint8Array(),
			stopped: false,
			reverted: false,
			isStatic: false,
			authorized: null,
			callDepth: 0,
			blockTimestamp: 1699999999n,
		};

		const error = handler_0x42_TIMESTAMP(frame);

		expect(error).toEqual({ type: "StackOverflow" });
		expect(frame.stack).toHaveLength(1024);
	});
});

```
