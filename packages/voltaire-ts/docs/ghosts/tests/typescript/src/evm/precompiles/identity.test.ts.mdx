---
title: '[TS/JS] src/evm/precompiles/identity.test.ts'
source: 'src/evm/precompiles/identity.test.ts'
---

> Auto-generated from test file: src/evm/precompiles/identity.test.ts

```typescript
import { describe, expect, it } from "vitest";
import * as Hardfork from "../../primitives/Hardfork/index.js";
import { execute, identity, PrecompileAddress } from "./precompiles.js";

/**
 * Helper: Convert hex string to Uint8Array
 */
function hexToBytes(hex: string): Uint8Array {
	const clean = hex.startsWith("0x") ? hex.slice(2) : hex;
	const bytes = new Uint8Array(clean.length / 2);
	for (let i = 0; i < clean.length; i += 2) {
		bytes[i / 2] = Number.parseInt(clean.slice(i, i + 2), 16);
	}
	return bytes;
}

/**
 * Helper: Convert Uint8Array to hex string
 */
function bytesToHex(bytes: Uint8Array): string {
	return Array.from(bytes)
		.map((b) => b.toString(16).padStart(2, "0"))
		.join("");
}

/**
 * Helper: Check if two Uint8Arrays are equal
 */
function areEqual(a: Uint8Array, b: Uint8Array): boolean {
	if (a.length !== b.length) return false;
	for (let i = 0; i < a.length; i++) {
		if (a[i] !== b[i]) return false;
	}
	return true;
}

describe("Precompile: IDENTITY (0x04)", () => {
	describe("Gas calculation", () => {
		it("should use 15 gas for empty input", () => {
			const input = new Uint8Array(0);
			const result = identity(input, 1000n);

			expect(result.success).toBe(true);
			expect(result.gasUsed).toBe(15n); // 15 + 0 words * 3
		});

		it("should use 18 gas for 1 byte input (1 word)", () => {
			const input = new Uint8Array(1);
			const result = identity(input, 1000n);

			expect(result.success).toBe(true);
			expect(result.gasUsed).toBe(18n); // 15 + 1 word * 3
		});

		it("should use 18 gas for 31 bytes input (1 word)", () => {
			const input = new Uint8Array(31);
			const result = identity(input, 1000n);

			expect(result.success).toBe(true);
			expect(result.gasUsed).toBe(18n);
		});

		it("should use 18 gas for 32 bytes input (1 word)", () => {
			const input = new Uint8Array(32);
			const result = identity(input, 1000n);

			expect(result.success).toBe(true);
			expect(result.gasUsed).toBe(18n);
		});

		it("should use 21 gas for 33 bytes input (2 words)", () => {
			const input = new Uint8Array(33);
			const result = identity(input, 1000n);

			expect(result.success).toBe(true);
			expect(result.gasUsed).toBe(21n); // 15 + 2 words * 3
		});

		it("should use 21 gas for 64 bytes input (2 words)", () => {
			const input = new Uint8Array(64);
			const result = identity(input, 1000n);

			expect(result.success).toBe(true);
			expect(result.gasUsed).toBe(21n);
		});

		it("should calculate gas correctly for large input", () => {
			const input = new Uint8Array(1024); // 32 words
			const result = identity(input, 10000n);

			expect(result.success).toBe(true);
			expect(result.gasUsed).toBe(15n + 32n * 3n); // 111 gas
		});

		it("should verify gas formula: 15 + ceil(len/32) * 3", () => {
			const testCases = [
				{ len: 0, expected: 15n },
				{ len: 1, expected: 18n },
				{ len: 32, expected: 18n },
				{ len: 33, expected: 21n },
				{ len: 64, expected: 21n },
				{ len: 65, expected: 24n },
				{ len: 128, expected: 27n },
				{ len: 256, expected: 39n },
				{ len: 1024, expected: 111n },
			];

			for (const { len, expected } of testCases) {
				const input = new Uint8Array(len);
				const result = identity(input, 10000n);
				expect(result.gasUsed).toBe(expected);
			}
		});
	});

	describe("Out of gas handling", () => {
		it("should fail with insufficient gas (14)", () => {
			const input = new Uint8Array(0);
			const result = identity(input, 14n);

			expect(result.success).toBe(false);
			expect(result.error).toBe("Out of gas");
			expect(result.gasUsed).toBe(15n);
		});

		it("should succeed with exact gas (15)", () => {
			const input = new Uint8Array(0);
			const result = identity(input, 15n);

			expect(result.success).toBe(true);
			expect(result.gasUsed).toBe(15n);
		});

		it("should fail with insufficient gas for 32-byte input", () => {
			const input = new Uint8Array(32);
			const result = identity(input, 17n);

			expect(result.success).toBe(false);
			expect(result.error).toBe("Out of gas");
			expect(result.gasUsed).toBe(18n);
		});

		it("should succeed with exact gas for 32-byte input", () => {
			const input = new Uint8Array(32);
			const result = identity(input, 18n);

			expect(result.success).toBe(true);
			expect(result.gasUsed).toBe(18n);
		});

		it("should handle gas limit edge case for large input", () => {
			const input = new Uint8Array(10000); // 313 words
			const expectedGas = 15n + 313n * 3n; // 954
			const result = identity(input, expectedGas - 1n);

			expect(result.success).toBe(false);
			expect(result.error).toBe("Out of gas");
		});

		it("should protect against gas overflow with very large input", () => {
			// Maximum reasonable input size (100MB)
			const largeSize = 100 * 1024 * 1024;
			const input = new Uint8Array(largeSize);
			const expectedGas = 15n + BigInt(Math.ceil(largeSize / 32)) * 3n;

			// Should not overflow bigint
			expect(expectedGas).toBeGreaterThan(0n);

			const result = identity(input, expectedGas);
			expect(result.success).toBe(true);
			expect(result.gasUsed).toBe(expectedGas);
		});
	});

	describe("Length preservation", () => {
		it("should return empty output for empty input", () => {
			const input = new Uint8Array(0);
			const result = identity(input, 1000n);

			expect(result.success).toBe(true);
			expect(result.output.length).toBe(0);
		});

		it("should preserve length for 1 byte", () => {
			const input = new Uint8Array(1);
			input[0] = 0x42;
			const result = identity(input, 1000n);

			expect(result.success).toBe(true);
			expect(result.output.length).toBe(1);
		});

		it("should preserve length for 32 bytes", () => {
			const input = new Uint8Array(32);
			const result = identity(input, 1000n);

			expect(result.success).toBe(true);
			expect(result.output.length).toBe(32);
		});

		it("should preserve length for 64 bytes", () => {
			const input = new Uint8Array(64);
			const result = identity(input, 1000n);

			expect(result.success).toBe(true);
			expect(result.output.length).toBe(64);
		});

		it("should preserve length for large input", () => {
			const sizes = [100, 1000, 10000, 50000];

			for (const size of sizes) {
				const input = new Uint8Array(size);
				const expectedGas = 15n + BigInt(Math.ceil(size / 32)) * 3n;
				const result = identity(input, expectedGas + 1000n);

				expect(result.success).toBe(true);
				expect(result.output.length).toBe(size);
			}
		});
	});

	describe("Bijection property (output === input)", () => {
		it("should return identical output for empty input", () => {
			const input = new Uint8Array(0);
			const result = identity(input, 1000n);

			expect(result.success).toBe(true);
			expect(areEqual(result.output, input)).toBe(true);
		});

		it("should return identical output for single byte", () => {
			const input = new Uint8Array(1);
			input[0] = 0x42;
			const result = identity(input, 1000n);

			expect(result.success).toBe(true);
			expect(areEqual(result.output, input)).toBe(true);
		});

		it("should return identical output for all zeros", () => {
			const input = new Uint8Array(100).fill(0x00);
			const result = identity(input, 10000n);

			expect(result.success).toBe(true);
			expect(areEqual(result.output, input)).toBe(true);
		});

		it("should return identical output for all ones", () => {
			const input = new Uint8Array(100).fill(0xff);
			const result = identity(input, 10000n);

			expect(result.success).toBe(true);
			expect(areEqual(result.output, input)).toBe(true);
		});

		it("should return identical output for sequential bytes", () => {
			const input = new Uint8Array(256);
			for (let i = 0; i < 256; i++) {
				input[i] = i;
			}
			const result = identity(input, 10000n);

			expect(result.success).toBe(true);
			expect(areEqual(result.output, input)).toBe(true);
		});

		it("should return identical output for random pattern", () => {
			const input = new Uint8Array(1000);
			for (let i = 0; i < input.length; i++) {
				input[i] = (i * 137 + 42) % 256; // Pseudo-random pattern
			}
			const result = identity(input, 10000n);

			expect(result.success).toBe(true);
			expect(areEqual(result.output, input)).toBe(true);
		});

		it("should verify byte-by-byte equality", () => {
			const input = new TextEncoder().encode("Hello, Ethereum Identity!");
			const result = identity(input, 10000n);

			expect(result.success).toBe(true);
			expect(result.output.length).toBe(input.length);

			for (let i = 0; i < input.length; i++) {
				expect(result.output[i]).toBe(input[i]);
			}
		});

		it("should not modify input buffer", () => {
			const input = new Uint8Array(100);
			for (let i = 0; i < 100; i++) {
				input[i] = i;
			}
			const original = new Uint8Array(input); // Copy

			const result = identity(input, 10000n);

			expect(result.success).toBe(true);
			// Input should be unchanged
			expect(areEqual(input, original)).toBe(true);
			// Output should match original
			expect(areEqual(result.output, original)).toBe(true);
		});
	});

	describe("Edge cases", () => {
		it("should handle very large input (10MB)", () => {
			const input = new Uint8Array(10 * 1024 * 1024);
			const expectedGas = 15n + BigInt(Math.ceil(input.length / 32)) * 3n;
			const result = identity(input, expectedGas + 1000n);

			expect(result.success).toBe(true);
			expect(result.output.length).toBe(input.length);
			expect(areEqual(result.output, input)).toBe(true);
		});

		it("should handle maximum EVM calldata size (approximate)", () => {
			// EVM typically limits calldata to a few MB
			const input = new Uint8Array(1024 * 1024); // 1MB
			const expectedGas = 15n + BigInt(Math.ceil(input.length / 32)) * 3n;
			const result = identity(input, expectedGas + 1000n);

			expect(result.success).toBe(true);
			expect(result.output.length).toBe(input.length);
		});

		it("should handle word boundary edge cases", () => {
			const boundaries = [31, 32, 33, 63, 64, 65, 127, 128, 129];

			for (const size of boundaries) {
				const input = new Uint8Array(size).fill(0xaa);
				const expectedGas = 15n + BigInt(Math.ceil(size / 32)) * 3n;
				const result = identity(input, expectedGas + 100n);

				expect(result.success).toBe(true);
				expect(result.output.length).toBe(size);
				expect(areEqual(result.output, input)).toBe(true);
			}
		});

		it("should handle gas limit at exact boundary", () => {
			const input = new Uint8Array(100);
			const exactGas = 15n + BigInt(Math.ceil(100 / 32)) * 3n; // 24
			const result = identity(input, exactGas);

			expect(result.success).toBe(true);
			expect(result.gasUsed).toBe(exactGas);
		});

		it("should fail at gas limit minus one", () => {
			const input = new Uint8Array(100);
			const exactGas = 15n + BigInt(Math.ceil(100 / 32)) * 3n;
			const result = identity(input, exactGas - 1n);

			expect(result.success).toBe(false);
			expect(result.error).toBe("Out of gas");
		});
	});

	describe("Data integrity", () => {
		it("should preserve text data", () => {
			const text = "The quick brown fox jumps over the lazy dog";
			const input = new TextEncoder().encode(text);
			const result = identity(input, 10000n);

			expect(result.success).toBe(true);
			const decoded = new TextDecoder().decode(result.output);
			expect(decoded).toBe(text);
		});

		it("should preserve hex data", () => {
			const hexInput = "deadbeefcafebabe123456789abcdef0";
			const input = hexToBytes(hexInput);
			const result = identity(input, 10000n);

			expect(result.success).toBe(true);
			expect(bytesToHex(result.output)).toBe(hexInput);
		});

		it("should preserve structured data", () => {
			// Simulate ABI-encoded data
			const input = new Uint8Array(128);
			// Function selector (first 4 bytes)
			input.set([0x12, 0x34, 0x56, 0x78], 0);
			// Parameter 1 (32 bytes)
			input.set(new Uint8Array(32).fill(0xaa), 4);
			// Parameter 2 (32 bytes)
			input.set(new Uint8Array(32).fill(0xbb), 36);
			// Parameter 3 (32 bytes)
			input.set(new Uint8Array(32).fill(0xcc), 68);
			// Remaining bytes
			input.set(new Uint8Array(28).fill(0xdd), 100);

			const result = identity(input, 10000n);

			expect(result.success).toBe(true);
			expect(areEqual(result.output, input)).toBe(true);
		});

		it("should preserve binary data patterns", () => {
			const patterns = [
				new Uint8Array(32).fill(0x00), // All zeros
				new Uint8Array(32).fill(0xff), // All ones
				new Uint8Array([0xaa, 0x55]).slice(0, 32), // Alternating bits
				new Uint8Array(32).map((_, i) => i), // Sequential
			];

			for (const pattern of patterns) {
				const result = identity(pattern, 10000n);

				expect(result.success).toBe(true);
				expect(areEqual(result.output, pattern)).toBe(true);
			}
		});
	});

	describe("Integration", () => {
		it("should work via execute function", () => {
			const input = new TextEncoder().encode("integration test");
			const result = execute(
				PrecompileAddress.IDENTITY,
				input,
				10000n,
				Hardfork.FRONTIER,
			);

			expect(result.success).toBe(true);
			expect(areEqual(result.output, input)).toBe(true);
			expect(result.gasUsed).toBeGreaterThanOrEqual(15n);
		});

		it("should be available from all hardforks", () => {
			const input = new TextEncoder().encode("test");

			const hardforks = [
				Hardfork.FRONTIER,
				Hardfork.HOMESTEAD,
				Hardfork.BYZANTIUM,
				Hardfork.CONSTANTINOPLE,
				Hardfork.ISTANBUL,
				Hardfork.BERLIN,
				Hardfork.LONDON,
				Hardfork.PARIS,
				Hardfork.SHANGHAI,
				Hardfork.CANCUN,
				Hardfork.PRAGUE,
			];

			for (const hf of hardforks) {
				const result = execute(PrecompileAddress.IDENTITY, input, 10000n, hf);
				expect(result.success).toBe(true);
				expect(areEqual(result.output, input)).toBe(true);
			}
		});

		it("should chain multiple identity calls", () => {
			const input = new TextEncoder().encode("chain test");

			const result1 = identity(input, 10000n);
			expect(result1.success).toBe(true);

			const result2 = identity(result1.output, 10000n);
			expect(result2.success).toBe(true);

			const result3 = identity(result2.output, 10000n);
			expect(result3.success).toBe(true);

			// All should be identical
			expect(areEqual(result1.output, input)).toBe(true);
			expect(areEqual(result2.output, input)).toBe(true);
			expect(areEqual(result3.output, input)).toBe(true);
		});
	});

	describe("Performance characteristics", () => {
		it("should scale linearly with input size", () => {
			const sizes = [32, 64, 128, 256, 512, 1024];
			const gasPerWord = 3n;
			const baseGas = 15n;

			for (const size of sizes) {
				const input = new Uint8Array(size);
				const expectedWords = BigInt(Math.ceil(size / 32));
				const expectedGas = baseGas + expectedWords * gasPerWord;

				const result = identity(input, expectedGas + 100n);

				expect(result.success).toBe(true);
				expect(result.gasUsed).toBe(expectedGas);
			}
		});

		it("should verify constant per-word cost", () => {
			const baseSize = 32;
			const baseInput = new Uint8Array(baseSize);
			const baseResult = identity(baseInput, 10000n);

			// Each additional 32 bytes should cost exactly 3 more gas
			for (let i = 1; i <= 10; i++) {
				const input = new Uint8Array(baseSize + i * 32);
				const result = identity(input, 10000n);

				expect(result.success).toBe(true);
				expect(result.gasUsed).toBe(baseResult.gasUsed + BigInt(i) * 3n);
			}
		});
	});

	describe("Comparison with hashing precompiles", () => {
		it("should be cheaper than sha256 for same input", () => {
			const input = new Uint8Array(1024);

			const identityResult = identity(input, 10000n);
			// SHA256: 60 + words * 12
			const sha256Gas = 60n + BigInt(Math.ceil(input.length / 32)) * 12n;

			expect(identityResult.success).toBe(true);
			expect(identityResult.gasUsed).toBeLessThan(sha256Gas);
		});

		it("should be much cheaper than ripemd160 for same input", () => {
			const input = new Uint8Array(1024);

			const identityResult = identity(input, 10000n);
			// RIPEMD160: 600 + words * 120
			const ripemd160Gas = 600n + BigInt(Math.ceil(input.length / 32)) * 120n;

			expect(identityResult.success).toBe(true);
			expect(identityResult.gasUsed).toBeLessThan(ripemd160Gas);
		});
	});
});

```
