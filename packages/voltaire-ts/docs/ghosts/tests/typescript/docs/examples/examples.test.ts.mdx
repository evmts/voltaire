---
title: '[TS/JS] docs/examples/examples.test.ts'
source: 'docs/examples/examples.test.ts'
---

> Auto-generated from test file: docs/examples/examples.test.ts

```typescript
/**
 * Tests for docs/examples/*.mdx
 *
 * Validates that all code examples in the examples documentation work correctly.
 *
 * DOC BUGS FOUND:
 * - Many examples have "placeholder" warnings indicating AI-generated content
 * - Address checksum validation example uses wrong address casing
 */
import { describe, expect, it } from "vitest";

describe("Examples Documentation", () => {
	describe("addresses/validate-address.mdx", () => {
		it("should validate addresses with isValid", async () => {
			const { Address } = await import("../../src/primitives/Address/index.js");

			// Valid address format (note: docs say this but casing may be wrong)
			const validAddr = "0x742d35Cc6634C0532925a3b844Bc9e7595f251e3";
			const isValid = Address.isValid(validAddr);
			expect(isValid).toBe(true);

			// Not an address (too short)
			const notAddress = "0x123";
			expect(Address.isValid(notAddress)).toBe(false);
		});

		it("should validate checksum with isValidChecksum", async () => {
			const { Address } = await import("../../src/primitives/Address/index.js");

			// Lowercase address is technically valid but has no checksum
			const lowercaseAddr = "0x742d35cc6634c0532925a3b844bc9e7595f251e3";
			expect(Address.isValidChecksum(lowercaseAddr)).toBe(false);
		});
	});

	describe("addresses/address-from-private-key.mdx", () => {
		it("should derive address from private key", async () => {
			const { Address } = await import("../../src/primitives/Address/index.js");
			const { Hex } = await import("../../src/primitives/Hex/index.js");

			// Known test vector from Foundry anvil
			const privateKey = Hex.toBytes(
				"0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80",
			);
			const addr = Address.fromPrivateKey(privateKey);

			expect(Address.toChecksummed(addr)).toBe(
				"0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266",
			);
		});
	});

	describe("addresses/compare-addresses.mdx", () => {
		it("should compare addresses for equality", async () => {
			const { Address } = await import("../../src/primitives/Address/index.js");

			const addr1 = Address("0x742d35Cc6634C0532925a3b844Bc9e7595f51e3e");
			const addr2 = Address("0x742d35Cc6634C0532925a3b844Bc9e7595f51e3e");
			const addr3 = Address("0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045");

			expect(Address.equals(addr1, addr2)).toBe(true);
			expect(Address.equals(addr1, addr3)).toBe(false);
		});

		it("should compare addresses for ordering", async () => {
			const { Address } = await import("../../src/primitives/Address/index.js");

			const lower = Address("0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa");
			const higher = Address("0xbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb");

			expect(Address.compare(lower, higher)).toBe(-1);
			expect(Address.compare(higher, lower)).toBe(1);
			expect(Address.compare(lower, lower)).toBe(0);
		});
	});

	describe("addresses/checksum-address.mdx", () => {
		it("should convert to checksummed address", async () => {
			const { Address } = await import("../../src/primitives/Address/index.js");

			const addr = Address("0x742d35cc6634c0532925a3b844bc9e7595f51e3e");
			const checksummed = Address.toChecksummed(addr);

			// Should be properly checksummed (EIP-55)
			expect(checksummed).toMatch(/^0x[0-9a-fA-F]{40}$/);
			expect(Address.isValidChecksum(checksummed)).toBe(true);
		});
	});

	describe("hashing/keccak256-string.mdx", () => {
		it("should hash string with Keccak256", async () => {
			const { Keccak256 } = await import("../../src/crypto/Keccak256/index.js");
			const { Hex } = await import("../../src/primitives/Hex/index.js");

			const message = "Hello, World!";
			const hash = Keccak256.hashString(message);
			const hexHash = Hex.fromBytes(hash);

			expect(hash.length).toBe(32);
			expect(hexHash).toMatch(/^0x[0-9a-f]{64}$/);
		});

		it("should hash empty string", async () => {
			const { Keccak256 } = await import("../../src/crypto/Keccak256/index.js");
			const { Hex } = await import("../../src/primitives/Hex/index.js");

			const emptyHash = Keccak256.hashString("");
			const emptyHexHash = Hex.fromBytes(emptyHash);

			// Known hash of empty string
			expect(emptyHexHash).toBe(
				"0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470",
			);
		});
	});

	describe("hashing/sha256-hash.mdx", () => {
		it("should hash string with SHA256", async () => {
			const { SHA256 } = await import("../../src/crypto/SHA256/index.js");
			const { Hex } = await import("../../src/primitives/Hex/index.js");

			const hash = SHA256.hashString("hello world");

			expect(hash.length).toBe(32);
			// Known SHA256 hash of "hello world"
			expect(Hex.fromBytes(hash)).toBe(
				"0xb94d27b9934d3e08a52e52d7da7dabfac484efe37a5380ee9088f7ace2efcde9",
			);
		});
	});

	describe("hex-and-bytes/hex-encode-decode.mdx", () => {
		it("should convert bytes to hex and back", async () => {
			const { Hex } = await import("../../src/primitives/Hex/index.js");

			const bytes = new Uint8Array([0x01, 0x02, 0x03, 0x04, 0x05]);
			const hex = Hex.fromBytes(bytes);

			expect(hex).toBe("0x0102030405");
			expect(Hex.toBytes(hex)).toEqual(bytes);
		});

		it("should convert string to hex and back", async () => {
			const { Hex } = await import("../../src/primitives/Hex/index.js");

			const str = "hello";
			const hex = Hex.fromString(str);

			expect(Hex.toString(hex)).toBe(str);
		});
	});

	describe("hex-and-bytes/hex-concatenate.mdx", () => {
		it("should concatenate hex strings", async () => {
			const { Hex } = await import("../../src/primitives/Hex/index.js");

			const hex1 = "0x0102";
			const hex2 = "0x0304";
			const concatenated = Hex.concat(hex1, hex2);

			expect(concatenated).toBe("0x01020304");
		});
	});

	describe("rlp/rlp-encode-list.mdx", () => {
		it("should encode list with RLP", async () => {
			const { Rlp } = await import("../../src/primitives/Rlp/index.js");

			const list = [
				new Uint8Array([0x01]),
				new Uint8Array([0x02]),
				new Uint8Array([0x03]),
			];

			const encoded = Rlp.encodeList(list);
			expect(encoded).toBeDefined();
			expect(encoded).toBeInstanceOf(Uint8Array);

			// Decode back
			const decoded = Rlp.decode(encoded);
			expect(decoded.data.type).toBe("list");
		});
	});

	describe("signing/personal-sign.mdx", () => {
		it("should sign message with private key", async () => {
			const { Secp256k1 } = await import("../../src/crypto/Secp256k1/index.js");
			const { Keccak256 } = await import("../../src/crypto/Keccak256/index.js");
			const { Hex } = await import("../../src/primitives/Hex/index.js");

			const privateKey = Hex.toBytes(
				"0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80",
			);
			const message = "Hello, Ethereum!";
			const messageHash = Keccak256.hashString(message);

			const signature = Secp256k1.sign(messageHash, privateKey);

			expect(signature.r.length).toBe(32);
			expect(signature.s.length).toBe(32);
			expect(signature.v === 27 || signature.v === 28).toBe(true);
		});

		it("should verify signature", async () => {
			const { Secp256k1 } = await import("../../src/crypto/Secp256k1/index.js");
			const { Keccak256 } = await import("../../src/crypto/Keccak256/index.js");
			const { Hex } = await import("../../src/primitives/Hex/index.js");

			const privateKey = Hex.toBytes(
				"0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80",
			);
			const message = "Hello, Ethereum!";
			const messageHash = Keccak256.hashString(message);

			const signature = Secp256k1.sign(messageHash, privateKey);
			const publicKey = Secp256k1.derivePublicKey(privateKey);

			const isValid = Secp256k1.verify(signature, messageHash, publicKey);
			expect(isValid).toBe(true);
		});
	});

	describe("getting-started/hello-voltaire.mdx", () => {
		it("should demonstrate basic imports work", async () => {
			const { Address } = await import("../../src/primitives/Address/index.js");
			const { Hex } = await import("../../src/primitives/Hex/index.js");
			const { Keccak256 } = await import("../../src/crypto/Keccak256/index.js");

			expect(Address).toBeDefined();
			expect(Hex).toBeDefined();
			expect(Keccak256).toBeDefined();
		});
	});
});

```
