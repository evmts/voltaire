---
title: '[TS/JS] docs/crypto/kzg/commitments.test.ts'
source: 'docs/crypto/kzg/commitments.test.ts'
---

> Auto-generated from test file: docs/crypto/kzg/commitments.test.ts

```typescript
/**
 * Tests for code examples in docs/crypto/kzg/commitments.mdx
 *
 * API Discrepancies documented:
 * - Docs use `Kzg` but actual export is `KZG`
 * - Docs use `Blob(131072)` but actual API is `KZG.createEmptyBlob()` or `KZG.generateRandomBlob()`
 * - Docs show Factory API (`Kzg.CommitmentFactory`) which doesn't exist - use `BlobToKzgCommitment` factory
 * - Docs state blob is "128 KB exactly" but actual size is 131,072 bytes (~128 KiB)
 */

import { afterAll, beforeAll, describe, expect, it } from "vitest";
import { hasNativeKzg, hasCkzg } from "./test-utils.js";

describe.skipIf(!hasNativeKzg)("docs/crypto/kzg/commitments.mdx - KZG Commitments", async () => {
	const {
		KZG,
		BYTES_PER_BLOB,
		BYTES_PER_COMMITMENT,
		BYTES_PER_FIELD_ELEMENT,
		FIELD_ELEMENTS_PER_BLOB,
		KzgError,
		KzgNotInitializedError,
		KzgInvalidBlobError,
		BlobToKzgCommitment,
	} = await import("../../../src/crypto/KZG/index.js");

	beforeAll(() => {
		KZG.loadTrustedSetup();
	});

	afterAll(() => {
		KZG.freeTrustedSetup();
	});

	describe("Standard API", () => {
		/**
		 * From commitments.mdx:
		 * ```typescript
		 * import { Kzg, Blob } from '@tevm/voltaire';
		 *
		 * // Load trusted setup (required once)
		 * Kzg.loadTrustedSetup();
		 *
		 * // Create blob
		 * const blob = Blob(131072); // 131,072 bytes
		 *
		 * // Generate commitment
		 * const commitment = Kzg.Commitment(blob);
		 * // Returns: Uint8Array (48 bytes)
		 * ```
		 *
		 * DISCREPANCY: Docs use `Kzg` but export is `KZG`
		 * DISCREPANCY: Docs use `Blob(131072)` but actual API is `KZG.createEmptyBlob()`
		 */
		it("should create commitment from blob - Standard API", () => {
			// Trusted setup already loaded in beforeAll

			// Create blob - actual API (docs show Blob(131072))
			const blob = KZG.createEmptyBlob();
			expect(blob.length).toBe(131072);

			// Generate commitment - works as documented
			const commitment = KZG.Commitment(blob);
			expect(commitment).toBeInstanceOf(Uint8Array);
			expect(commitment.length).toBe(48);
		});
	});

describe.skipIf(!hasCkzg)("Factory API", () => {
		/**
		 * From commitments.mdx:
		 * ```typescript
		 * import { Kzg, Blob } from '@tevm/voltaire';
		 * import * as ckzg from 'c-kzg';
		 *
		 * // Load trusted setup
		 * Kzg.loadTrustedSetup();
		 *
		 * // Create factory with c-kzg dependency injection
		 * const Commitment = Kzg.CommitmentFactory({
		 *   blobToKzgCommitment: ckzg.blobToKzgCommitment
		 * });
		 *
		 * // Use factory
		 * const blob = Blob(131072);
		 * const commitment = Commitment(blob);
		 * ```
		 *
		 * DISCREPANCY: Docs show `Kzg.CommitmentFactory` but actual API is standalone `BlobToKzgCommitment` factory
		 */
		it("should create commitment using factory pattern", async () => {
			const ckzg = await import("c-kzg");

			// Ensure c-kzg's trusted setup is loaded
			try {
				// @ts-expect-error - loadTrustedSetup signature varies by version
				ckzg.loadTrustedSetup(0);
			} catch {
				// Already loaded
			}

			// Actual factory API (docs show Kzg.CommitmentFactory)
			const Commitment = BlobToKzgCommitment({
				blobToKzgCommitment: ckzg.blobToKzgCommitment,
			});

			const blob = KZG.createEmptyBlob();
			const commitment = Commitment(blob);
			expect(commitment).toBeInstanceOf(Uint8Array);
			expect(commitment.length).toBe(48);
		});

		it("should produce same result as standard API", async () => {
			const ckzg = await import("c-kzg");

			// Ensure c-kzg's trusted setup is loaded
			try {
				// @ts-expect-error - loadTrustedSetup signature varies by version
				ckzg.loadTrustedSetup(0);
			} catch {
				// Already loaded
			}

			const Commitment = BlobToKzgCommitment({
				blobToKzgCommitment: ckzg.blobToKzgCommitment,
			});

			const blob = KZG.generateRandomBlob(42);

			const commitment1 = KZG.Commitment(blob);
			const commitment2 = Commitment(blob);

			// c-kzg returns Buffer, our KZG returns Uint8Array - compare as Uint8Array
			expect(commitment1).toEqual(new Uint8Array(commitment2));
		});
	});

	describe("Blob Format", () => {
		/**
		 * From commitments.mdx:
		 * - Size: 131,072 bytes (128 KB exactly)
		 * - Structure: 4,096 field elements Ã— 32 bytes
		 * - Constraint: Each field element must have top byte = 0 (< BLS12-381 modulus)
		 */
		it("should verify blob size", () => {
			expect(BYTES_PER_BLOB).toBe(131072);
			expect(FIELD_ELEMENTS_PER_BLOB).toBe(4096);
			expect(BYTES_PER_FIELD_ELEMENT).toBe(32);
			expect(FIELD_ELEMENTS_PER_BLOB * BYTES_PER_FIELD_ELEMENT).toBe(
				BYTES_PER_BLOB,
			);
		});

		/**
		 * From commitments.mdx:
		 * ```typescript
		 * // Valid blob
		 * const blob = Blob(131072);
		 * for (let i = 0; i < 4096; i++) {
		 *   blob[i * 32] = 0; // Top byte must be 0
		 *   // ... fill remaining 31 bytes
		 * }
		 * ```
		 */
		it("should create valid blob with field element constraints", () => {
			const blob = new Uint8Array(BYTES_PER_BLOB);

			// Set valid field elements
			for (let i = 0; i < FIELD_ELEMENTS_PER_BLOB; i++) {
				blob[i * 32] = 0; // Top byte must be 0
				// Fill remaining bytes with data
				for (let j = 1; j < 32; j++) {
					blob[i * 32 + j] = j;
				}
			}

			// Should be valid
			expect(() => KZG.validateBlob(blob)).not.toThrow();

			// Should produce commitment
			const commitment = KZG.Commitment(blob);
			expect(commitment.length).toBe(BYTES_PER_COMMITMENT);
		});

		it("should reject blob with invalid field element (top byte != 0)", () => {
			const blob = new Uint8Array(BYTES_PER_BLOB);
			// Set top byte of first field element to non-zero
			blob[0] = 1;

			expect(() => KZG.validateBlob(blob)).toThrow(KzgInvalidBlobError);
		});
	});

	describe("Error Handling", () => {
		/**
		 * From commitments.mdx:
		 * ```typescript
		 * try {
		 *   const commitment = Kzg.Commitment(blob);
		 * } catch (error) {
		 *   if (error instanceof KzgNotInitializedError) {
		 *     // Trusted setup not loaded
		 *     Kzg.loadTrustedSetup();
		 *   } else if (error instanceof KzgInvalidBlobError) {
		 *     // Invalid blob format
		 *     console.error('Blob validation failed:', error.message);
		 *   } else if (error instanceof KzgError) {
		 *     // Commitment computation failed
		 *     console.error('KZG error:', error.message);
		 *   }
		 * }
		 * ```
		 */
		it("should throw KzgInvalidBlobError for invalid blob format", () => {
			// Wrong size
			const wrongSize = new Uint8Array(1000);
			expect(() => KZG.Commitment(wrongSize)).toThrow(KzgInvalidBlobError);
		});

		it("should throw KzgInvalidBlobError for non-Uint8Array", () => {
			expect(() => KZG.Commitment(null as unknown as Uint8Array)).toThrow(
				KzgInvalidBlobError,
			);
			expect(() => KZG.Commitment({} as unknown as Uint8Array)).toThrow(
				KzgInvalidBlobError,
			);
			expect(() => KZG.Commitment("blob" as unknown as Uint8Array)).toThrow(
				KzgInvalidBlobError,
			);
		});

		it("should demonstrate error handling pattern from docs", () => {
			const invalidBlob = new Uint8Array(1000);

			try {
				KZG.Commitment(invalidBlob);
				expect.fail("Should have thrown");
			} catch (error) {
				if (error instanceof KzgNotInitializedError) {
					// Trusted setup not loaded
					KZG.loadTrustedSetup();
				} else if (error instanceof KzgInvalidBlobError) {
					// Invalid blob format - expected path
					expect(error.message).toBeDefined();
				} else if (error instanceof KzgError) {
					// Commitment computation failed
					expect(error.message).toBeDefined();
				}
			}
		});

		// This test must be LAST in this describe block because it frees the setup
		it("should throw KzgNotInitializedError when trusted setup not loaded", () => {
			KZG.freeTrustedSetup();
			const blob = KZG.createEmptyBlob();
			expect(() => KZG.Commitment(blob)).toThrow(KzgNotInitializedError);
			// Note: beforeAll of next test suite will reload trusted setup
		});
	});

	describe("Commitment Properties", () => {
		beforeAll(
			() => {
				if (!KZG.isInitialized()) {
					KZG.loadTrustedSetup();
				}
			},
			{ timeout: 60000 },
		);

		it("should produce 48-byte commitment (BLS12-381 G1 point)", () => {
			const blob = KZG.createEmptyBlob();
			const commitment = KZG.Commitment(blob);
			expect(commitment.length).toBe(48);
		});

		it("should be deterministic - same blob always produces same commitment", () => {
			const blob = KZG.generateRandomBlob(999);

			const commitment1 = KZG.Commitment(blob);
			const commitment2 = KZG.Commitment(blob);

			expect(commitment1).toEqual(commitment2);
		});

		it("should produce different commitments for different blobs", () => {
			const blob1 = KZG.createEmptyBlob();
			const blob2 = KZG.generateRandomBlob();

			const commitment1 = KZG.Commitment(blob1);
			const commitment2 = KZG.Commitment(blob2);

			expect(commitment1).not.toEqual(commitment2);
		});

		it("should produce non-zero commitment even for empty blob", () => {
			const blob = KZG.createEmptyBlob();
			const commitment = KZG.Commitment(blob);

			// Empty blob should still produce a non-trivial commitment
			expect(commitment.some((b) => b !== 0)).toBe(true);
		});
	});

	describe("Legacy API Compatibility", () => {
		beforeAll(
			() => {
				if (!KZG.isInitialized()) {
					KZG.loadTrustedSetup();
				}
			},
			{ timeout: 60000 },
		);

		/**
		 * The module also exports blobToKzgCommitment as legacy API
		 */
		it("should support legacy blobToKzgCommitment API", () => {
			const blob = KZG.generateRandomBlob();

			// New API
			const commitment1 = KZG.Commitment(blob);

			// Legacy API
			const commitment2 = KZG.blobToKzgCommitment(blob);

			expect(commitment1).toEqual(commitment2);
		});
	});
});

```
