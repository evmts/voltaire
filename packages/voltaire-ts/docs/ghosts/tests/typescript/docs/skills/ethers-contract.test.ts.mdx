---
title: '[TS/JS] docs/skills/ethers-contract.test.ts'
source: 'docs/skills/ethers-contract.test.ts'
---

> Auto-generated from test file: docs/skills/ethers-contract.test.ts

```typescript
/**
 * Tests for ethers-style contract playbook
 * @see /docs/playbooks/ethers-contract.mdx
 *
 * Note: The playbook documents a REFERENCE IMPLEMENTATION in examples/ethers-contract/.
 * Tests cover the ABI structures and patterns that ARE available via primitives.
 *
 * API DISCREPANCIES:
 * - EthersContract is in examples/ethers-contract/, not library export
 * - ContractFactory is a reference implementation
 * - Abi primitive IS available for encoding/decoding
 */
import { describe, expect, it } from "vitest";

describe("Ethers Contract Playbook", () => {
	it("should define ERC-20 ABI with view functions", () => {
		// From playbook: ERC-20 ABI structure
		const erc20Abi = [
			{
				type: "function",
				name: "balanceOf",
				stateMutability: "view",
				inputs: [{ name: "account", type: "address" }],
				outputs: [{ name: "", type: "uint256" }],
			},
			{
				type: "function",
				name: "transfer",
				stateMutability: "nonpayable",
				inputs: [
					{ name: "to", type: "address" },
					{ name: "amount", type: "uint256" },
				],
				outputs: [{ name: "", type: "bool" }],
			},
		] as const;

		expect(erc20Abi[0].stateMutability).toBe("view");
		expect(erc20Abi[1].stateMutability).toBe("nonpayable");
	});

	it("should define Transfer event in ABI", () => {
		// From playbook: Event ABI structure
		const transferEvent = {
			type: "event",
			name: "Transfer",
			inputs: [
				{ name: "from", type: "address", indexed: true },
				{ name: "to", type: "address", indexed: true },
				{ name: "value", type: "uint256", indexed: false },
			],
		} as const;

		expect(transferEvent.inputs[0].indexed).toBe(true);
		expect(transferEvent.inputs[2].indexed).toBe(false);
	});

	it("should compute function selectors", async () => {
		const { Keccak256 } = await import("../../src/crypto/index.js");
		const { Hex } = await import("../../src/primitives/Hex/index.js");

		// transfer(address,uint256) selector
		const signature = "transfer(address,uint256)";
		const hash = Keccak256.hash(new TextEncoder().encode(signature));
		const selector = Hex.fromBytes(hash.slice(0, 4));

		expect(selector).toBe("0xa9059cbb");
	});

	it("should handle stateMutability default behavior", () => {
		// From playbook: default behavior based on stateMutability
		const behaviors: Record<string, string> = {
			view: "staticCall",
			pure: "staticCall",
			nonpayable: "send",
			payable: "send",
		};

		expect(behaviors.view).toBe("staticCall");
		expect(behaviors.nonpayable).toBe("send");
		expect(behaviors.payable).toBe("send");
	});

	it("should define function method variants", () => {
		// From playbook: explicit method variants
		const variants = ["staticCall", "send", "estimateGas", "populateTransaction"];

		expect(variants).toContain("staticCall");
		expect(variants).toContain("estimateGas");
	});

	it("should handle transaction overrides", () => {
		// From playbook: overrides as last argument
		const overrides = {
			gasLimit: 100000n,
			maxFeePerGas: 50_000_000_000n,
		};

		expect(overrides.gasLimit).toBe(100000n);
		expect(overrides.maxFeePerGas).toBe(50_000_000_000n);
	});

	it("should define error types", () => {
		// From playbook: error types
		const errorTypes = [
			"UnsupportedOperationError",
			"CallExceptionError",
			"InvalidArgumentError",
			"FunctionNotFoundError",
			"EventNotFoundError",
		];

		expect(errorTypes).toContain("CallExceptionError");
		expect(errorTypes).toContain("FunctionNotFoundError");
	});

	it("should handle contract properties", () => {
		// From playbook: Contract properties
		interface ContractLike {
			target: string;
			interface: unknown; // Abi
			runner: unknown; // Provider or Signer
			filters: Record<string, (...args: unknown[]) => unknown>;
		}

		const contract: ContractLike = {
			target: "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48",
			interface: {},
			runner: null,
			filters: {},
		};

		expect(contract.target).toBe("0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48");
	});

	it("should handle event subscription methods", () => {
		// From playbook: event subscription methods
		const eventMethods = [
			"on",
			"once",
			"off",
			"removeAllListeners",
			"listenerCount",
			"listeners",
		];

		expect(eventMethods).toContain("on");
		expect(eventMethods).toContain("removeAllListeners");
	});

	it("should handle queryFilter with block range", () => {
		// From playbook: queryFilter with fromBlock/toBlock
		const filterParams = {
			fromBlock: 18000000n,
			toBlock: 18100000n,
		};

		const range = filterParams.toBlock - filterParams.fromBlock;
		expect(range).toBe(100000n);
	});

	it("should define ContractFactory properties", () => {
		// From playbook: ContractFactory structure
		interface ContractFactoryLike {
			deploy(...args: unknown[]): Promise<unknown>;
			getDeployTransaction(...args: unknown[]): Promise<unknown>;
			attach(target: string): unknown;
			connect(runner: unknown): unknown;
		}

		const methods: (keyof ContractFactoryLike)[] = [
			"deploy",
			"getDeployTransaction",
			"attach",
			"connect",
		];

		expect(methods).toHaveLength(4);
	});

	it("should work with Abi primitive", async () => {
		const Abi = await import("../../src/primitives/Abi/index.js");

		// Abi module should exist for encoding/decoding
		expect(Abi).toBeDefined();
	});

	it("should handle revert reason decoding", () => {
		// From playbook: CallExceptionError with revert info
		interface CallExceptionError {
			revert?: {
				name: string;
				args: unknown[];
			};
		}

		const error: CallExceptionError = {
			revert: {
				name: "InsufficientBalance",
				args: [100n, 200n],
			},
		};

		expect(error.revert?.name).toBe("InsufficientBalance");
	});
});

```
