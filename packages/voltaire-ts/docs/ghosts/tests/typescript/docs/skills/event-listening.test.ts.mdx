---
title: '[TS/JS] docs/skills/event-listening.test.ts'
source: 'docs/skills/event-listening.test.ts'
---

> Auto-generated from test file: docs/skills/event-listening.test.ts

```typescript
/**
 * Tests for event listening guide
 * @see /docs/guides/event-listening.mdx
 *
 * Note: The guide shows Contract/EventStream patterns which are REFERENCE IMPLEMENTATIONS.
 * Tests cover the primitives and event structures that ARE available.
 *
 * API DISCREPANCIES:
 * - '@voltaire/contract' - DOES NOT EXIST as export
 * - EventStream is a reference implementation pattern, not an exported module
 * - EventLog primitive IS available at src/primitives/EventLog/
 */
import { describe, expect, it } from "vitest";

describe("Event Listening Guide", () => {
	it("should work with ERC-20 Transfer event ABI", () => {
		// Transfer event from guide
		const transferEvent = {
			type: "event" as const,
			name: "Transfer" as const,
			inputs: [
				{ type: "address" as const, name: "from" as const, indexed: true },
				{ type: "address" as const, name: "to" as const, indexed: true },
				{ type: "uint256" as const, name: "value" as const, indexed: false },
			],
		};

		expect(transferEvent.name).toBe("Transfer");
		expect(transferEvent.inputs).toHaveLength(3);
		expect(transferEvent.inputs[0].indexed).toBe(true);
		expect(transferEvent.inputs[2].indexed).toBe(false);
	});

	it("should work with ERC-20 Approval event ABI", () => {
		// Approval event from guide
		const approvalEvent = {
			type: "event" as const,
			name: "Approval" as const,
			inputs: [
				{ type: "address" as const, name: "owner" as const, indexed: true },
				{ type: "address" as const, name: "spender" as const, indexed: true },
				{ type: "uint256" as const, name: "value" as const, indexed: false },
			],
		};

		expect(approvalEvent.name).toBe("Approval");
		expect(approvalEvent.inputs[0].name).toBe("owner");
		expect(approvalEvent.inputs[1].name).toBe("spender");
	});

	it("should compute Transfer event signature hash", async () => {
		const { Keccak256 } = await import("../../src/crypto/index.js");
		const { Hex } = await import("../../src/primitives/Hex/index.js");

		// Transfer(address,address,uint256) topic
		const signature = "Transfer(address,address,uint256)";
		const hash = Keccak256.hash(new TextEncoder().encode(signature));
		const topicHash = Hex.fromBytes(hash);

		expect(topicHash).toBe(
			"0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef",
		);
	});

	it("should compute Approval event signature hash", async () => {
		const { Keccak256 } = await import("../../src/crypto/index.js");
		const { Hex } = await import("../../src/primitives/Hex/index.js");

		// Approval(address,address,uint256) topic
		const signature = "Approval(address,address,uint256)";
		const hash = Keccak256.hash(new TextEncoder().encode(signature));
		const topicHash = Hex.fromBytes(hash);

		expect(topicHash).toBe(
			"0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925",
		);
	});

	it("should work with EventLog primitive", async () => {
		const EventLog = await import("../../src/primitives/EventLog/index.js");

		// EventLog module should exist
		expect(EventLog).toBeDefined();
	});

	it("should work with TopicFilter primitive", async () => {
		const TopicFilter = await import(
			"../../src/primitives/TopicFilter/index.js"
		);

		// TopicFilter module should exist
		expect(TopicFilter).toBeDefined();
	});

	it("should work with LogFilter primitive", async () => {
		const LogFilter = await import("../../src/primitives/LogFilter/index.js");

		// LogFilter module should exist
		expect(LogFilter).toBeDefined();
	});

	it("should handle indexed topics (address)", async () => {
		const { Address } = await import("../../src/primitives/Address/index.js");
		const { Hex } = await import("../../src/primitives/Hex/index.js");

		// Indexed address topics are 32 bytes (padded)
		const address = Address("0x742d35Cc6634C0532925a3b844Bc454e4438f44e");
		const paddedTopic = new Uint8Array(32);
		paddedTopic.set(address, 12); // Left-pad with zeros

		const topicHex = Hex.fromBytes(paddedTopic);
		expect(topicHex).toBe(
			"0x000000000000000000000000742d35cc6634c0532925a3b844bc454e4438f44e",
		);
	});

	it("should handle log data structure", () => {
		// Raw log structure from RPC
		const rawLog = {
			address: "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48",
			topics: [
				"0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef",
				"0x000000000000000000000000742d35cc6634c0532925a3b844bc454e4438f44e",
				"0x0000000000000000000000005fbdb2315678afecb367f032d93f642f64180aa3",
			],
			data: "0x0000000000000000000000000000000000000000000000000000000000989680",
			blockNumber: "0x123456",
			transactionHash:
				"0xabcdef1234567890abcdef1234567890abcdef1234567890abcdef1234567890",
			transactionIndex: "0x0",
			blockHash:
				"0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef",
			logIndex: "0x0",
			removed: false,
		};

		expect(rawLog.topics.length).toBe(3); // event sig + 2 indexed params
		expect(rawLog.topics[0]).toBe(
			"0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef",
		);

		// Decode value from data
		const value = BigInt(rawLog.data);
		expect(value).toBe(10000000n); // 10 USDC
	});

	it("should handle block range structure", () => {
		// From guide: backfill options
		const options = {
			fromBlock: 18000000n,
			toBlock: 18001000n,
			chunkSize: 1000,
			minChunkSize: 50,
		};

		const range = options.toBlock - options.fromBlock;
		expect(range).toBe(1000n);
	});

	it("should handle polling interval", () => {
		// From guide: watch options
		const pollingInterval = 2000; // 2 seconds

		expect(pollingInterval).toBe(2000);
	});

	it("should handle AbortController pattern", () => {
		// From guide: stop watching with AbortSignal
		const controller = new AbortController();

		// Can check if aborted
		expect(controller.signal.aborted).toBe(false);

		// Can abort
		controller.abort();
		expect(controller.signal.aborted).toBe(true);
	});

	it("should handle large transfer detection threshold", () => {
		// From guide: threshold = 1000000n * 10n ** 6n (1M USDC)
		const threshold = 1000000n * 10n ** 6n;

		expect(threshold).toBe(1_000_000_000_000n);

		// Test comparison
		const smallTransfer = 100_000_000n; // 100 USDC
		const largeTransfer = 2_000_000_000_000n; // 2M USDC

		expect(smallTransfer > threshold).toBe(false);
		expect(largeTransfer > threshold).toBe(true);
	});
});

```
