---
title: '[TS/JS] docs/primitives/bytecode/parseInstructions.test.ts'
source: 'docs/primitives/bytecode/parseInstructions.test.ts'
---

> Auto-generated from test file: docs/primitives/bytecode/parseInstructions.test.ts

```typescript
import { describe, expect, it } from "vitest";

describe("Bytecode.parseInstructions (docs/primitives/bytecode/parseInstructions.mdx)", () => {
	describe("Basic Parsing", () => {
		it("should parse bytecode into instructions", async () => {
			const { Bytecode } = await import(
				"../../../src/primitives/Bytecode/index.js"
			);

			// PUSH1 0x01, PUSH1 0x02, ADD
			const code = Bytecode("0x6001600201");
			const instructions = code.parseInstructions();

			expect(instructions.length).toBe(3);
		});

		it("should handle empty bytecode", async () => {
			const { Bytecode } = await import(
				"../../../src/primitives/Bytecode/index.js"
			);

			const code = Bytecode("0x");
			const instructions = code.parseInstructions();

			expect(instructions.length).toBe(0);
		});
	});

	describe("PUSH Instructions", () => {
		it("should parse PUSH1", async () => {
			const { Bytecode } = await import(
				"../../../src/primitives/Bytecode/index.js"
			);

			const code = Bytecode("0x6042"); // PUSH1 0x42
			const instructions = code.parseInstructions();

			expect(instructions[0].opcode).toBe(0x60);
			expect(instructions[0].pushData).toEqual(new Uint8Array([0x42]));
		});

		it("should parse PUSH2", async () => {
			const { Bytecode } = await import(
				"../../../src/primitives/Bytecode/index.js"
			);

			const code = Bytecode("0x611234"); // PUSH2 0x1234
			const instructions = code.parseInstructions();

			expect(instructions[0].opcode).toBe(0x61);
			expect(instructions[0].pushData).toEqual(new Uint8Array([0x12, 0x34]));
		});

		it("should parse PUSH32", async () => {
			const { Bytecode } = await import(
				"../../../src/primitives/Bytecode/index.js"
			);

			// PUSH32 with 32 bytes of 0xff
			const code = Bytecode("0x7f" + "ff".repeat(32));
			const instructions = code.parseInstructions();

			expect(instructions[0].opcode).toBe(0x7f);
			expect(instructions[0].pushData?.length).toBe(32);
		});
	});

	describe("Position Tracking", () => {
		it("should track instruction positions correctly", async () => {
			const { Bytecode } = await import(
				"../../../src/primitives/Bytecode/index.js"
			);

			// PUSH1 0x01 (2 bytes), PUSH1 0x02 (2 bytes), ADD (1 byte)
			const code = Bytecode("0x6001600201");
			const instructions = code.parseInstructions();

			expect(instructions[0].position).toBe(0);
			expect(instructions[1].position).toBe(2);
			expect(instructions[2].position).toBe(4);
		});

		it("should handle variable-size PUSHes", async () => {
			const { Bytecode } = await import(
				"../../../src/primitives/Bytecode/index.js"
			);

			// PUSH1 0x01 (2 bytes), PUSH2 0x0102 (3 bytes), PUSH3 0x010203 (4 bytes)
			const code = Bytecode("0x6001610102620102" + "03");
			const instructions = code.parseInstructions();

			expect(instructions[0].position).toBe(0);
			expect(instructions[1].position).toBe(2);
			expect(instructions[2].position).toBe(5);
		});
	});

	describe("Non-PUSH Opcodes", () => {
		it("should parse non-PUSH opcodes without pushData", async () => {
			const { Bytecode } = await import(
				"../../../src/primitives/Bytecode/index.js"
			);

			// ADD, MUL, SUB
			const code = Bytecode("0x010203");
			const instructions = code.parseInstructions();

			expect(instructions[0].opcode).toBe(0x01); // ADD
			expect(instructions[0].pushData).toBeUndefined();

			expect(instructions[1].opcode).toBe(0x02); // MUL
			expect(instructions[1].pushData).toBeUndefined();

			expect(instructions[2].opcode).toBe(0x03); // SUB
			expect(instructions[2].pushData).toBeUndefined();
		});
	});

	describe("Truncated PUSH", () => {
		it("should handle truncated PUSH1", async () => {
			const { Bytecode } = await import(
				"../../../src/primitives/Bytecode/index.js"
			);

			// PUSH1 with no data
			const code = Bytecode("0x60");
			const instructions = code.parseInstructions();

			expect(instructions.length).toBe(1);
			expect(instructions[0].opcode).toBe(0x60);
			expect(instructions[0].pushData?.length).toBe(0);
		});
	});

	describe("Instruction Type", () => {
		it("should return correct instruction shape", async () => {
			const { Bytecode } = await import(
				"../../../src/primitives/Bytecode/index.js"
			);

			const code = Bytecode("0x6001");
			const instructions = code.parseInstructions();

			// Check instruction shape
			expect(typeof instructions[0].opcode).toBe("number");
			expect(typeof instructions[0].position).toBe("number");
			// pushData is Uint8Array or undefined
			expect(
				instructions[0].pushData === undefined ||
					instructions[0].pushData instanceof Uint8Array,
			).toBe(true);
		});
	});
});

```
