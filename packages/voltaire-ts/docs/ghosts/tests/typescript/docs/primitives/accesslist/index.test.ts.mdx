---
title: '[TS/JS] docs/primitives/accesslist/index.test.ts'
source: 'docs/primitives/accesslist/index.test.ts'
---

> Auto-generated from test file: docs/primitives/accesslist/index.test.ts

```typescript
/**
 * Tests for docs/primitives/accesslist/index.mdx
 *
 * Validates that all code examples in the AccessList documentation work correctly.
 */
import { describe, expect, it } from "vitest";

describe("AccessList Documentation - index.mdx", () => {
	describe("Type Definition", () => {
		it("should create an AccessList with items containing address and storageKeys", async () => {
			const { AccessList } = await import(
				"../../../src/primitives/AccessList/index.js"
			);
			const { Address } = await import(
				"../../../src/primitives/Address/index.js"
			);
			const { Hash } = await import(
				"../../../src/primitives/Hash/index.js"
			);

			// Create address and storage key
			const token = Address.from(
				"0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48",
			);
			const balanceSlot = Hash.from(
				"0x0000000000000000000000000000000000000000000000000000000000000003",
			);

			// Build access list
			let list = AccessList.create();
			list = AccessList.withAddress(list, token);
			list = AccessList.withStorageKey(list, token, balanceSlot);

			expect(AccessList.is(list)).toBe(true);
			expect(AccessList.includesAddress(list, token)).toBe(true);
			expect(AccessList.includesStorageKey(list, token, balanceSlot)).toBe(
				true,
			);
		});
	});

	describe("Constructors", () => {
		it("should create empty access list with create()", async () => {
			const { AccessList } = await import(
				"../../../src/primitives/AccessList/index.js"
			);

			const list = AccessList.create();
			expect(AccessList.isEmpty(list)).toBe(true);
			expect(AccessList.addressCount(list)).toBe(0);
		});

		it("should create access list from items with from()", async () => {
			const { AccessList } = await import(
				"../../../src/primitives/AccessList/index.js"
			);
			const { Address } = await import(
				"../../../src/primitives/Address/index.js"
			);

			const addr = Address.from(
				"0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48",
			);
			const list = AccessList.from([{ address: addr, storageKeys: [] }]);

			expect(AccessList.addressCount(list)).toBe(1);
		});
	});

	describe("Type Guards", () => {
		it("should validate with is()", async () => {
			const { AccessList } = await import(
				"../../../src/primitives/AccessList/index.js"
			);

			const list = AccessList.create();
			expect(AccessList.is(list)).toBe(true);
			expect(AccessList.is([])).toBe(true); // Empty array is valid
			expect(AccessList.is("invalid")).toBe(false);
		});

		it("should validate item structure with isItem()", async () => {
			const { AccessList } = await import(
				"../../../src/primitives/AccessList/index.js"
			);
			const { Address } = await import(
				"../../../src/primitives/Address/index.js"
			);

			const addr = Address.from(
				"0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48",
			);
			const validItem = { address: addr, storageKeys: [] };
			const invalidItem = { address: "not an address" };

			expect(AccessList.isItem(validItem)).toBe(true);
			expect(AccessList.isItem(invalidItem)).toBe(false);
		});
	});

	describe("Queries", () => {
		it("should check if address is in list with includesAddress()", async () => {
			const { AccessList } = await import(
				"../../../src/primitives/AccessList/index.js"
			);
			const { Address } = await import(
				"../../../src/primitives/Address/index.js"
			);

			const addr1 = Address.from(
				"0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48",
			);
			const addr2 = Address.from(
				"0xdAC17F958D2ee523a2206206994597C13D831ec7",
			);

			let list = AccessList.create();
			list = AccessList.withAddress(list, addr1);

			expect(AccessList.includesAddress(list, addr1)).toBe(true);
			expect(AccessList.includesAddress(list, addr2)).toBe(false);
		});

		it("should get storage keys for address with keysFor()", async () => {
			const { AccessList } = await import(
				"../../../src/primitives/AccessList/index.js"
			);
			const { Address } = await import(
				"../../../src/primitives/Address/index.js"
			);
			const { Hash } = await import(
				"../../../src/primitives/Hash/index.js"
			);

			const addr = Address.from(
				"0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48",
			);
			const key = Hash.from(
				"0x0000000000000000000000000000000000000000000000000000000000000001",
			);

			let list = AccessList.create();
			list = AccessList.withAddress(list, addr);
			list = AccessList.withStorageKey(list, addr, key);

			const keys = AccessList.keysFor(list, addr);
			expect(keys).toBeDefined();
			expect(keys?.length).toBe(1);
		});

		it("should count addresses and storage keys", async () => {
			const { AccessList } = await import(
				"../../../src/primitives/AccessList/index.js"
			);
			const { Address } = await import(
				"../../../src/primitives/Address/index.js"
			);
			const { Hash } = await import(
				"../../../src/primitives/Hash/index.js"
			);

			const addr = Address.from(
				"0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48",
			);
			const key1 = Hash.from(
				"0x0000000000000000000000000000000000000000000000000000000000000001",
			);
			const key2 = Hash.from(
				"0x0000000000000000000000000000000000000000000000000000000000000002",
			);

			let list = AccessList.create();
			list = AccessList.withAddress(list, addr);
			list = AccessList.withStorageKey(list, addr, key1);
			list = AccessList.withStorageKey(list, addr, key2);

			expect(AccessList.addressCount(list)).toBe(1);
			expect(AccessList.storageKeyCount(list)).toBe(2);
		});
	});

	describe("Manipulation", () => {
		it("should merge two access lists", async () => {
			const { AccessList } = await import(
				"../../../src/primitives/AccessList/index.js"
			);
			const { Address } = await import(
				"../../../src/primitives/Address/index.js"
			);

			const addr1 = Address.from(
				"0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48",
			);
			const addr2 = Address.from(
				"0xdAC17F958D2ee523a2206206994597C13D831ec7",
			);

			let list1 = AccessList.create();
			list1 = AccessList.withAddress(list1, addr1);

			let list2 = AccessList.create();
			list2 = AccessList.withAddress(list2, addr2);

			const merged = AccessList.merge(list1, list2);
			expect(AccessList.addressCount(merged)).toBe(2);
		});

		it("should deduplicate entries", async () => {
			const { AccessList } = await import(
				"../../../src/primitives/AccessList/index.js"
			);
			const { Address } = await import(
				"../../../src/primitives/Address/index.js"
			);

			const addr = Address.from(
				"0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48",
			);

			// Create list with duplicate address
			let list = AccessList.create();
			list = AccessList.withAddress(list, addr);
			list = AccessList.withAddress(list, addr);

			const deduped = AccessList.deduplicate(list);
			// deduplicate should keep unique entries
			expect(AccessList.includesAddress(deduped, addr)).toBe(true);
		});
	});

	describe("Gas Analysis", () => {
		it("should calculate gas cost", async () => {
			const { AccessList } = await import(
				"../../../src/primitives/AccessList/index.js"
			);
			const { Address } = await import(
				"../../../src/primitives/Address/index.js"
			);
			const { Hash } = await import(
				"../../../src/primitives/Hash/index.js"
			);

			const addr = Address.from(
				"0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48",
			);
			const key = Hash.from(
				"0x0000000000000000000000000000000000000000000000000000000000000001",
			);

			let list = AccessList.create();
			list = AccessList.withAddress(list, addr);
			list = AccessList.withStorageKey(list, addr, key);

			const cost = AccessList.gasCost(list);
			// Gas cost should be > 0 for non-empty list
			expect(cost).toBeGreaterThan(0n);
		});

		it("should calculate gas savings", async () => {
			const { AccessList } = await import(
				"../../../src/primitives/AccessList/index.js"
			);
			const { Address } = await import(
				"../../../src/primitives/Address/index.js"
			);
			const { Hash } = await import(
				"../../../src/primitives/Hash/index.js"
			);

			const addr = Address.from(
				"0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48",
			);
			const key = Hash.from(
				"0x0000000000000000000000000000000000000000000000000000000000000001",
			);

			let list = AccessList.create();
			list = AccessList.withAddress(list, addr);
			list = AccessList.withStorageKey(list, addr, key);

			const savings = AccessList.gasSavings(list);
			expect(typeof savings).toBe("bigint");
		});

		it("should check if access list has savings", async () => {
			const { AccessList } = await import(
				"../../../src/primitives/AccessList/index.js"
			);
			const { Address } = await import(
				"../../../src/primitives/Address/index.js"
			);

			const addr = Address.from(
				"0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48",
			);

			let list = AccessList.create();
			list = AccessList.withAddress(list, addr);

			const hasSavings = AccessList.hasSavings(list);
			expect(typeof hasSavings).toBe("boolean");
		});
	});

	describe("Conversions", () => {
		it("should convert to RLP bytes and back", async () => {
			const { AccessList } = await import(
				"../../../src/primitives/AccessList/index.js"
			);
			const { Address } = await import(
				"../../../src/primitives/Address/index.js"
			);

			const addr = Address.from(
				"0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48",
			);

			let list = AccessList.create();
			list = AccessList.withAddress(list, addr);

			const bytes = AccessList.toBytes(list);
			expect(bytes).toBeInstanceOf(Uint8Array);

			// Round-trip
			const restored = AccessList.fromBytes(bytes);
			expect(AccessList.includesAddress(restored, addr)).toBe(true);
		});
	});

	describe("Constants", () => {
		it("should export gas cost constants", async () => {
			const {
				ADDRESS_COST,
				STORAGE_KEY_COST,
				COLD_ACCOUNT_ACCESS_COST,
				COLD_STORAGE_ACCESS_COST,
				WARM_STORAGE_ACCESS_COST,
			} = await import("../../../src/primitives/AccessList/index.js");

			expect(ADDRESS_COST).toBe(2400n);
			expect(STORAGE_KEY_COST).toBe(1900n);
			expect(COLD_ACCOUNT_ACCESS_COST).toBe(2600n);
			expect(COLD_STORAGE_ACCESS_COST).toBe(2100n);
			expect(WARM_STORAGE_ACCESS_COST).toBe(100n);
		});
	});
});

```
