---
title: '[TS/JS] docs/primitives/eventlog/usage-patterns.test.ts'
source: 'docs/primitives/eventlog/usage-patterns.test.ts'
---

> Auto-generated from test file: docs/primitives/eventlog/usage-patterns.test.ts

```typescript
/**
 * Tests for docs/primitives/eventlog/usage-patterns.mdx
 * Tests the code examples from the EventLog usage patterns documentation
 */

import { describe, expect, it } from "vitest";

describe("EventLog usage-patterns.mdx documentation examples", () => {
	describe("Log Filtering - Filter by Event Signature", () => {
		it("filters logs by event signature", async () => {
			const EventLog = await import(
				"../../../src/primitives/EventLog/index.js"
			);
			const Address = await import("../../../src/primitives/Address/index.js");
			const Hash = await import("../../../src/primitives/Hash/index.js");

			// Transfer event signature
			const TRANSFER_SIG = Hash.from(
				"0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef",
			);

			const allLogs = [
				EventLog.create({
					address: Address.Address.zero(),
					topics: [TRANSFER_SIG],
					data: new Uint8Array([]),
				}),
				EventLog.create({
					address: Address.Address.zero(),
					topics: [Hash.from("0x" + "99".repeat(32))], // Different event
					data: new Uint8Array([]),
				}),
			];

			// Filter for Transfer events
			const transferLogs = EventLog.filterLogs(allLogs, {
				topics: [TRANSFER_SIG],
			});

			expect(transferLogs.length).toBe(1);
		});
	});

	describe("Log Filtering - Filter by Indexed Parameters", () => {
		it("filters Transfer events from specific address", async () => {
			const EventLog = await import(
				"../../../src/primitives/EventLog/index.js"
			);
			const Address = await import("../../../src/primitives/Address/index.js");
			const Hash = await import("../../../src/primitives/Hash/index.js");

			const TRANSFER_SIG = Hash.from(
				"0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef",
			);
			const fromAddressHash = Hash.from(
				"0x000000000000000000000000a1b2c3d4e5f67890abcdef1234567890abcdef12",
			);
			const otherHash = Hash.from("0x" + "99".repeat(32));

			const tokenAddress = Address.Address.zero();

			const allLogs = [
				EventLog.create({
					address: tokenAddress,
					topics: [TRANSFER_SIG, fromAddressHash, otherHash], // From target address
					data: new Uint8Array([]),
				}),
				EventLog.create({
					address: tokenAddress,
					topics: [TRANSFER_SIG, otherHash, fromAddressHash], // To target address
					data: new Uint8Array([]),
				}),
			];

			// Filter by topic0 (event sig) and topic1 (from address)
			const transfersFrom = EventLog.filterLogs(allLogs, {
				address: tokenAddress,
				topics: [TRANSFER_SIG, fromAddressHash],
			});

			expect(transfersFrom.length).toBe(1);
		});
	});

	describe("Log Parsing - Multi-event Parsing", () => {
		it("creates event registry and parses logs", async () => {
			const EventLog = await import(
				"../../../src/primitives/EventLog/index.js"
			);
			const Address = await import("../../../src/primitives/Address/index.js");
			const Hash = await import("../../../src/primitives/Hash/index.js");

			type EventLogType = ReturnType<typeof EventLog.create>;

			const TRANSFER_SIG =
				"0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef";
			const APPROVAL_SIG =
				"0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925";

			// Create event registry
			interface EventRegistry {
				[signature: string]: {
					name: string;
				};
			}

			const registry: EventRegistry = {
				[TRANSFER_SIG]: { name: "Transfer" },
				[APPROVAL_SIG]: { name: "Approval" },
			};

			// Parse with registry
			function parseLog(
				log: EventLogType,
				reg: EventRegistry,
			): { name: string } | null {
				const signature = EventLog.getSignature(log);
				if (!signature) return null;

				const sigHex = Hash.toHex(signature);
				const event = reg[sigHex];

				if (!event) return null;

				return { name: event.name };
			}

			const transferLog = EventLog.create({
				address: Address.Address.zero(),
				topics: [Hash.from(TRANSFER_SIG)],
				data: new Uint8Array([]),
			});

			const parsed = parseLog(transferLog, registry);
			expect(parsed?.name).toBe("Transfer");
		});
	});

	describe("Log Filtering and Sorting", () => {
		it("filters by address and sorts", async () => {
			const EventLog = await import(
				"../../../src/primitives/EventLog/index.js"
			);
			const Address = await import("../../../src/primitives/Address/index.js");
			const Hash = await import("../../../src/primitives/Hash/index.js");

			type EventLogType = ReturnType<typeof EventLog.create>;

			const targetAddress = Address.Address(
				"0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48",
			);

			const allLogs = [
				EventLog.create({
					address: targetAddress,
					topics: [Hash.from("0x" + "00".repeat(32))],
					data: new Uint8Array([]),
					blockNumber: 200n,
				}),
				EventLog.create({
					address: Address.Address.zero(),
					topics: [Hash.from("0x" + "11".repeat(32))],
					data: new Uint8Array([]),
					blockNumber: 100n,
				}),
				EventLog.create({
					address: targetAddress,
					topics: [Hash.from("0x" + "22".repeat(32))],
					data: new Uint8Array([]),
					blockNumber: 150n,
				}),
			];

			// Check if log is from specific address
			// NOTE: Docs show EventLog.matchesAddress(log, address)
			// which is the correct API
			function isFromAddress(log: EventLogType, address: typeof targetAddress): boolean {
				return EventLog.matchesAddress(log, address);
			}

			// Filter logs by address
			function filterByAddress(
				logs: EventLogType[],
				address: typeof targetAddress,
			): EventLogType[] {
				return logs.filter((log) => EventLog.matchesAddress(log, address));
			}

			const filtered = filterByAddress(allLogs, targetAddress);
			expect(filtered.length).toBe(2);

			// Sort by block number and log index
			const sorted = EventLog.sortLogs(filtered);
			expect(sorted[0]?.blockNumber).toBe(150n);
			expect(sorted[1]?.blockNumber).toBe(200n);

			// Check isFromAddress
			expect(isFromAddress(allLogs[0]!, targetAddress)).toBe(true);
			expect(isFromAddress(allLogs[1]!, targetAddress)).toBe(false);
		});

		it("sorts in reverse (newest first)", async () => {
			const EventLog = await import(
				"../../../src/primitives/EventLog/index.js"
			);
			const Address = await import("../../../src/primitives/Address/index.js");
			const Hash = await import("../../../src/primitives/Hash/index.js");

			type EventLogType = ReturnType<typeof EventLog.create>;

			function sortLogsDescending(logs: EventLogType[]): EventLogType[] {
				return EventLog.sortLogs(logs).reverse();
			}

			const logs = [
				EventLog.create({
					address: Address.Address.zero(),
					topics: [Hash.from("0x" + "00".repeat(32))],
					data: new Uint8Array([]),
					blockNumber: 100n,
				}),
				EventLog.create({
					address: Address.Address.zero(),
					topics: [Hash.from("0x" + "11".repeat(32))],
					data: new Uint8Array([]),
					blockNumber: 300n,
				}),
				EventLog.create({
					address: Address.Address.zero(),
					topics: [Hash.from("0x" + "22".repeat(32))],
					data: new Uint8Array([]),
					blockNumber: 200n,
				}),
			];

			const sortedDesc = sortLogsDescending(logs);

			expect(sortedDesc[0]?.blockNumber).toBe(300n);
			expect(sortedDesc[1]?.blockNumber).toBe(200n);
			expect(sortedDesc[2]?.blockNumber).toBe(100n);
		});
	});

	describe("Reorg Handling", () => {
		it("detects removed logs and filters them out", async () => {
			const EventLog = await import(
				"../../../src/primitives/EventLog/index.js"
			);
			const Address = await import("../../../src/primitives/Address/index.js");
			const Hash = await import("../../../src/primitives/Hash/index.js");

			type EventLogType = ReturnType<typeof EventLog.create>;

			// Check for reorgs
			function checkForReorgs(logs: EventLogType[]): {
				valid: EventLogType[];
				removed: EventLogType[];
			} {
				const valid: EventLogType[] = [];
				const removed: EventLogType[] = [];

				for (const log of logs) {
					if (EventLog.isRemoved(log)) {
						removed.push(log);
					} else {
						valid.push(log);
					}
				}

				return { valid, removed };
			}

			// Filter out removed logs
			function filterRemoved(logs: EventLogType[]): EventLogType[] {
				return logs.filter((log) => !EventLog.isRemoved(log));
			}

			const allLogs = [
				EventLog.create({
					address: Address.Address.zero(),
					topics: [Hash.from("0x" + "00".repeat(32))],
					data: new Uint8Array([]),
					removed: false,
				}),
				EventLog.create({
					address: Address.Address.zero(),
					topics: [Hash.from("0x" + "11".repeat(32))],
					data: new Uint8Array([]),
					removed: true,
				}),
				EventLog.create({
					address: Address.Address.zero(),
					topics: [Hash.from("0x" + "22".repeat(32))],
					data: new Uint8Array([]),
					removed: false,
				}),
			];

			const { valid, removed } = checkForReorgs(allLogs);
			expect(valid.length).toBe(2);
			expect(removed.length).toBe(1);

			const filtered = filterRemoved(allLogs);
			expect(filtered.length).toBe(2);
		});
	});

	describe("Aggregation - Track Balances", () => {
		it("builds balance map from Transfer events", async () => {
			const EventLog = await import(
				"../../../src/primitives/EventLog/index.js"
			);
			const Address = await import("../../../src/primitives/Address/index.js");
			const Hash = await import("../../../src/primitives/Hash/index.js");

			type EventLogType = ReturnType<typeof EventLog.create>;

			const TRANSFER_SIG = Hash.from(
				"0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef",
			);

			// Zero address for mints
			const ZERO_HASH = Hash.from("0x" + "00".repeat(32));
			const alice = Hash.from(
				"0x000000000000000000000000a1b2c3d4e5f67890abcdef1234567890abcdef12",
			);
			const bob = Hash.from(
				"0x000000000000000000000000fedcba0987654321fedcba0987654321fedcba09",
			);

			// Create value data (32 bytes for uint256, value = 1000)
			const valueData = new Uint8Array(32);
			new DataView(valueData.buffer).setBigUint64(24, 1000n, false);

			const logs = [
				// Mint to alice
				EventLog.create({
					address: Address.Address.zero(),
					topics: [TRANSFER_SIG, ZERO_HASH, alice],
					data: valueData,
					blockNumber: 100n,
				}),
				// Transfer alice -> bob (500)
				EventLog.create({
					address: Address.Address.zero(),
					topics: [TRANSFER_SIG, alice, bob],
					data: (() => {
						const d = new Uint8Array(32);
						new DataView(d.buffer).setBigUint64(24, 500n, false);
						return d;
					})(),
					blockNumber: 200n,
				}),
			];

			// Simple balance calculation helper
			function parseTransfer(log: EventLogType): {
				from: string;
				to: string;
				value: bigint;
			} {
				const indexed = EventLog.getIndexedTopics(log);
				const fromHash = indexed[0]!;
				const toHash = indexed[1]!;

				const from = Hash.toHex(fromHash);
				const to = Hash.toHex(toHash);

				// Read value from data (last 8 bytes of 32-byte uint256)
				const value = new DataView(log.data.buffer).getBigUint64(24, false);

				return { from, to, value };
			}

			function buildBalanceMap(eventLogs: EventLogType[]): Map<string, bigint> {
				const balances = new Map<string, bigint>();
				const sorted = EventLog.sortLogs(eventLogs);
				const zeroAddr =
					"0x0000000000000000000000000000000000000000000000000000000000000000";

				for (const log of sorted) {
					const { from, to, value } = parseTransfer(log);

					// Debit from sender (if not mint)
					if (from !== zeroAddr) {
						const fromBalance = balances.get(from) ?? 0n;
						balances.set(from, fromBalance - value);
					}

					// Credit to receiver
					const toBalance = balances.get(to) ?? 0n;
					balances.set(to, toBalance + value);
				}

				return balances;
			}

			const balances = buildBalanceMap(logs);

			// Alice received 1000 (mint), sent 500 to bob = 500
			expect(balances.get(Hash.toHex(alice))).toBe(500n);
			// Bob received 500
			expect(balances.get(Hash.toHex(bob))).toBe(500n);
		});
	});

	describe("Testing - Mock Logs", () => {
		it("creates test logs for testing", async () => {
			const EventLog = await import(
				"../../../src/primitives/EventLog/index.js"
			);
			const Address = await import("../../../src/primitives/Address/index.js");
			const Hash = await import("../../../src/primitives/Hash/index.js");

			type EventLogType = ReturnType<typeof EventLog.create>;

			const TRANSFER_SIG = Hash.from(
				"0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef",
			);

			// Create test log
			function createTestLog(overrides?: Partial<{
				address: ReturnType<typeof Address.Address>;
				topics: ReturnType<typeof Hash.from>[];
				data: Uint8Array;
				blockNumber: bigint;
				transactionHash: ReturnType<typeof Hash.from>;
				transactionIndex: number;
				blockHash: ReturnType<typeof Hash.from>;
				logIndex: number;
				removed: boolean;
			}>): EventLogType {
				return EventLog.create({
					address:
						overrides?.address ??
						Address.Address("0x1234567890123456789012345678901234567890"),
					topics: overrides?.topics ?? [TRANSFER_SIG],
					data: overrides?.data ?? new Uint8Array(32),
					blockNumber: overrides?.blockNumber ?? 100n,
					transactionHash:
						overrides?.transactionHash ?? Hash.from("0x" + "ab".repeat(32)),
					transactionIndex: overrides?.transactionIndex ?? 0,
					blockHash: overrides?.blockHash ?? Hash.from("0x" + "cd".repeat(32)),
					logIndex: overrides?.logIndex ?? 0,
					removed: overrides?.removed ?? false,
				});
			}

			// Create batch of test logs
			function createTestLogs(count: number): EventLogType[] {
				return Array.from({ length: count }, (_, i) =>
					createTestLog({
						blockNumber: BigInt(100 + i),
						logIndex: i,
					}),
				);
			}

			const testLog = createTestLog();
			expect(testLog.blockNumber).toBe(100n);
			expect(testLog.removed).toBe(false);

			const customLog = createTestLog({
				blockNumber: 500n,
				removed: true,
			});
			expect(customLog.blockNumber).toBe(500n);
			expect(customLog.removed).toBe(true);

			const batchLogs = createTestLogs(5);
			expect(batchLogs.length).toBe(5);
			expect(batchLogs[0]?.blockNumber).toBe(100n);
			expect(batchLogs[4]?.blockNumber).toBe(104n);
		});
	});
});

```
