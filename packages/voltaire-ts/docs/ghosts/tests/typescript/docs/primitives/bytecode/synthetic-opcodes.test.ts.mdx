---
title: '[TS/JS] docs/primitives/bytecode/synthetic-opcodes.test.ts'
source: 'docs/primitives/bytecode/synthetic-opcodes.test.ts'
---

> Auto-generated from test file: docs/primitives/bytecode/synthetic-opcodes.test.ts

```typescript
import { describe, expect, it } from "vitest";

describe("Bytecode Synthetic Opcodes (docs/primitives/bytecode/synthetic-opcodes.mdx)", () => {
	describe("Synthetic Opcode Concept", () => {
		it("should detect fusion patterns", async () => {
			const { Bytecode } = await import(
				"../../../src/primitives/Bytecode/index.js"
			);

			// PUSH1 0x05, ADD - potential PUSH_ADD fusion
			const code = Bytecode("0x600501");
			const fusions = code.detectFusions();

			expect(Array.isArray(fusions)).toBe(true);
		});
	});

	describe("Arithmetic Fusions", () => {
		it("should detect PUSH + ADD pattern", async () => {
			const { Bytecode } = await import(
				"../../../src/primitives/Bytecode/index.js"
			);

			const code = Bytecode("0x600501"); // PUSH1 5, ADD
			const fusions = code.detectFusions();

			expect(Array.isArray(fusions)).toBe(true);
		});

		it("should detect PUSH + MUL pattern", async () => {
			const { Bytecode } = await import(
				"../../../src/primitives/Bytecode/index.js"
			);

			const code = Bytecode("0x600502"); // PUSH1 5, MUL
			const fusions = code.detectFusions();

			expect(Array.isArray(fusions)).toBe(true);
		});
	});

	describe("Control Flow Fusions", () => {
		it("should detect PUSH + JUMP pattern", async () => {
			const { Bytecode } = await import(
				"../../../src/primitives/Bytecode/index.js"
			);

			const code = Bytecode("0x604256"); // PUSH1 0x42, JUMP
			const fusions = code.detectFusions();

			expect(Array.isArray(fusions)).toBe(true);
		});

		it("should detect PUSH + JUMPI pattern", async () => {
			const { Bytecode } = await import(
				"../../../src/primitives/Bytecode/index.js"
			);

			const code = Bytecode("0x604257"); // PUSH1 0x42, JUMPI
			const fusions = code.detectFusions();

			expect(Array.isArray(fusions)).toBe(true);
		});
	});

	describe("Memory Fusions", () => {
		it("should detect PUSH + MLOAD pattern", async () => {
			const { Bytecode } = await import(
				"../../../src/primitives/Bytecode/index.js"
			);

			const code = Bytecode("0x604051"); // PUSH1 0x40, MLOAD
			const fusions = code.detectFusions();

			expect(Array.isArray(fusions)).toBe(true);
		});

		it("should detect PUSH + MSTORE pattern", async () => {
			const { Bytecode } = await import(
				"../../../src/primitives/Bytecode/index.js"
			);

			const code = Bytecode("0x604052"); // PUSH1 0x40, MSTORE
			const fusions = code.detectFusions();

			expect(Array.isArray(fusions)).toBe(true);
		});
	});

	describe("Scan with Fusion Detection", () => {
		it("should scan with detectFusions option", async () => {
			const { Bytecode } = await import(
				"../../../src/primitives/Bytecode/index.js"
			);

			const code = Bytecode("0x6001600201");

			// Note: scan may or may not support detectFusions option
			// depending on implementation
			const instructions = Array.from(code.scan());

			expect(Array.isArray(instructions)).toBe(true);
		});
	});

	describe("Synthetic Opcode Reference", () => {
		// These tests verify the documented synthetic opcode patterns exist
		it("should handle standard EVM opcodes (0x00-0xFF)", async () => {
			const { Bytecode } = await import(
				"../../../src/primitives/Bytecode/index.js"
			);

			// Standard opcodes
			const code = Bytecode("0x01020304");
			const instructions = Array.from(code.scan());

			for (const inst of instructions) {
				expect(inst.opcode).toBeLessThanOrEqual(0xff);
			}
		});
	});
});

```
