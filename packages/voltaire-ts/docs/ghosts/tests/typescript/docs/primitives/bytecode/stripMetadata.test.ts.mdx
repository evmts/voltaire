---
title: '[TS/JS] docs/primitives/bytecode/stripMetadata.test.ts'
source: 'docs/primitives/bytecode/stripMetadata.test.ts'
---

> Auto-generated from test file: docs/primitives/bytecode/stripMetadata.test.ts

```typescript
import { describe, expect, it } from "vitest";

describe("Bytecode.stripMetadata (docs/primitives/bytecode/stripMetadata.mdx)", () => {
	describe("Basic Usage", () => {
		it("should strip metadata from bytecode", async () => {
			const { Bytecode } = await import(
				"../../../src/primitives/Bytecode/index.js"
			);

			// Bytecode with metadata
			const code = Bytecode(
				new Uint8Array([0x60, 0x01, 0x00, 0xa2, 0x64, 0x00, 0x33]),
			);
			const stripped = code.stripMetadata();

			expect(stripped).toBeInstanceOf(Uint8Array);
			expect(stripped.length).toBeLessThanOrEqual(code.length);
		});

		it("should return same bytecode if no metadata", async () => {
			const { Bytecode } = await import(
				"../../../src/primitives/Bytecode/index.js"
			);

			const code = Bytecode("0x600100");
			const stripped = code.stripMetadata();

			expect(stripped.length).toBe(code.length);
		});

		it("should handle empty bytecode", async () => {
			const { Bytecode } = await import(
				"../../../src/primitives/Bytecode/index.js"
			);

			const code = Bytecode("0x");
			const stripped = code.stripMetadata();

			expect(stripped.length).toBe(0);
		});
	});

	describe("Contract Comparison", () => {
		it("should enable comparing contracts ignoring metadata", async () => {
			const { Bytecode } = await import(
				"../../../src/primitives/Bytecode/index.js"
			);

			// Two contracts with same code but different metadata
			const code1 = Bytecode(
				new Uint8Array([0x60, 0x01, 0x00, 0xa2, 0x64, 0x00, 0x33]),
			);
			const code2 = Bytecode(
				new Uint8Array([0x60, 0x01, 0x00, 0xa2, 0x64, 0x00, 0x34]),
			);

			const stripped1 = code1.stripMetadata();
			const stripped2 = code2.stripMetadata();

			// After stripping, they should have same bytecode
			// (assuming metadata removal works correctly)
			expect(stripped1.length).toBeLessThanOrEqual(code1.length);
			expect(stripped2.length).toBeLessThanOrEqual(code2.length);
		});
	});

	describe("Return Type", () => {
		it("should return Uint8Array", async () => {
			const { Bytecode } = await import(
				"../../../src/primitives/Bytecode/index.js"
			);

			const code = Bytecode("0x600100");
			const stripped = code.stripMetadata();

			expect(stripped).toBeInstanceOf(Uint8Array);
		});
	});
});

```
