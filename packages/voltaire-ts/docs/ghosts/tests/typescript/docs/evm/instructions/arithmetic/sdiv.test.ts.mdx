---
title: '[TS/JS] docs/evm/instructions/arithmetic/sdiv.test.ts'
source: 'docs/evm/instructions/arithmetic/sdiv.test.ts'
---

> Auto-generated from test file: docs/evm/instructions/arithmetic/sdiv.test.ts

```typescript
/**
 * Test file for SDIV (0x05) documentation examples
 * Tests examples from sdiv.mdx
 *
 * NOTE: Stack order is [bottom, ..., top] - pop() returns the last element.
 * For SDIV(a, b): a is popped first (dividend), b second (divisor). Result = a / b.
 * So for a / b, stack should be [b, a].
 */
import { describe, expect, it } from "vitest";

describe("SDIV (0x05) - Documentation Examples", async () => {
	const { sdiv } = await import("../../../../src/evm/arithmetic/index.js");
	const { Frame } = await import("../../../../src/evm/Frame/index.js");

	const MIN_INT = 1n << 255n;
	const MAX_UINT = (1n << 256n) - 1n;

	/** Convert negative bigint to two's complement 256-bit representation */
	const toSigned = (n: bigint) => (n < 0n ? (1n << 256n) + n : n);

	function createFrame(stack: bigint[], gasRemaining = 1000000n) {
		const frame = Frame({ gas: gasRemaining });
		frame.stack = [...stack];
		return frame;
	}

	describe("Basic Signed Division", () => {
		it("10 / 2 = 5", () => {
			const frame = createFrame([2n, 10n]);
			const err = sdiv(frame);

			expect(err).toBeNull();
			expect(frame.stack).toEqual([5n]);
		});
	});

	describe("Negative Dividend", () => {
		it("-10 / 2 = -5", () => {
			const neg10 = toSigned(-10n);
			const frame = createFrame([2n, neg10]);
			sdiv(frame);

			const neg5 = toSigned(-5n);
			expect(frame.stack).toEqual([neg5]);
		});
	});

	describe("Negative Divisor", () => {
		it("10 / -2 = -5", () => {
			const neg2 = toSigned(-2n);
			const frame = createFrame([neg2, 10n]);
			sdiv(frame);

			const neg5 = toSigned(-5n);
			expect(frame.stack).toEqual([neg5]);
		});
	});

	describe("Both Negative", () => {
		it("-10 / -2 = 5 (negative / negative = positive)", () => {
			const neg10 = toSigned(-10n);
			const neg2 = toSigned(-2n);
			const frame = createFrame([neg2, neg10]);
			sdiv(frame);

			expect(frame.stack).toEqual([5n]);
		});
	});

	describe("Truncation Toward Zero", () => {
		it("7 / 2 = 3 (not 4)", () => {
			const frame = createFrame([2n, 7n]);
			sdiv(frame);
			expect(frame.stack).toEqual([3n]);
		});

		it("-7 / 2 = -3 (rounds toward zero, not -4)", () => {
			const neg7 = toSigned(-7n);
			const frame = createFrame([2n, neg7]);
			sdiv(frame);

			const neg3 = toSigned(-3n);
			expect(frame.stack).toEqual([neg3]);
		});
	});

	describe("MIN_INT / -1 Edge Case", () => {
		it("MIN_INT / -1 returns MIN_INT (overflow case)", () => {
			const negOne = MAX_UINT; // -1 in two's complement
			const frame = createFrame([negOne, MIN_INT]);
			sdiv(frame);

			expect(frame.stack).toEqual([MIN_INT]);
		});
	});

	describe("Edge Cases", () => {
		it("division by zero returns 0", () => {
			const neg10 = toSigned(-10n);
			const frame = createFrame([0n, neg10]);
			sdiv(frame);

			expect(frame.stack).toEqual([0n]);
		});

		it("MIN_INT / 1 = MIN_INT", () => {
			const frame = createFrame([1n, MIN_INT]);
			sdiv(frame);
			expect(frame.stack).toEqual([MIN_INT]);
		});

		it("MIN_INT / MIN_INT = 1", () => {
			const frame = createFrame([MIN_INT, MIN_INT]);
			sdiv(frame);
			expect(frame.stack).toEqual([1n]);
		});

		it("0 / -5 = 0", () => {
			const neg5 = toSigned(-5n);
			const frame = createFrame([neg5, 0n]);
			sdiv(frame);

			expect(frame.stack).toEqual([0n]);
		});
	});

	describe("Gas Cost", () => {
		it("consumes 5 gas (GasFastStep)", () => {
			const frame = createFrame([2n, 10n], 100n);
			const err = sdiv(frame);

			expect(err).toBeNull();
			expect(frame.gasRemaining).toBe(95n);
		});
	});
});

```
