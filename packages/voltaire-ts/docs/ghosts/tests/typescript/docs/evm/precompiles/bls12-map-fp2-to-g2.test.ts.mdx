---
title: '[TS/JS] docs/evm/precompiles/bls12-map-fp2-to-g2.test.ts'
source: 'docs/evm/precompiles/bls12-map-fp2-to-g2.test.ts'
---

> Auto-generated from test file: docs/evm/precompiles/bls12-map-fp2-to-g2.test.ts

```typescript
/**
 * Tests for bls12-map-fp2-to-g2.mdx documentation examples
 * Validates code examples work correctly with actual API
 */
import { describe, expect, it } from "vitest";
import { PrecompileAddress, execute, bls12MapFp2ToG2 } from "../../../src/evm/precompiles/precompiles.js";
import * as Hardfork from "../../../src/primitives/Hardfork/index.js";

describe("bls12-map-fp2-to-g2.mdx documentation examples", () => {
	describe("Overview section", () => {
		it("should map Fp2 element to BLS12-381 G2 point", () => {
			// Doc states: maps an element from Fp2 (extension field) to a point in G2
			const input = new Uint8Array(128); // 128-byte Fp2 element (2 x 64-byte)
			const result = bls12MapFp2ToG2(input, 100000n);

			expect(result.success).toBe(true);
			expect(result.output.length).toBe(256);
		});
	});

	describe("Gas Cost section", () => {
		it("should use exactly 75000 gas", () => {
			// Doc states: Fixed: 75000 gas
			const input = new Uint8Array(128);
			const result = bls12MapFp2ToG2(input, 100000n);

			expect(result.success).toBe(true);
			expect(result.gasUsed).toBe(75000n);
		});

		it("should fail with insufficient gas", () => {
			// Doc states: Out of gas: gasLimit < 75000
			const input = new Uint8Array(128);
			const result = bls12MapFp2ToG2(input, 74999n);

			expect(result.success).toBe(false);
			expect(result.error).toBe("Out of gas");
		});
	});

	describe("Input Format section", () => {
		it("should require exactly 128 bytes", () => {
			// Doc states: Total input length: 128 bytes (exactly)
			// Fp2 element: c0 (64 bytes) + c1 (64 bytes) = 128 bytes
			const input = new Uint8Array(128);
			const result = bls12MapFp2ToG2(input, 100000n);

			expect(result.success).toBe(true);
		});

		it("should fail for invalid input length", () => {
			// Doc states: Invalid input length: input.len != 128
			const shortInput = new Uint8Array(127);
			const longInput = new Uint8Array(129);

			const resultShort = bls12MapFp2ToG2(shortInput, 100000n);
			const resultLong = bls12MapFp2ToG2(longInput, 100000n);

			expect(resultShort.success).toBe(false);
			expect(resultLong.success).toBe(false);
		});

		it("should have 64-byte c0 + 64-byte c1 structure", () => {
			// Fp2 element: c0 + c1*u where u^2 + 1 = 0
			const input = new Uint8Array(128);
			// c0: bytes 0-63, c1: bytes 64-127
			const result = bls12MapFp2ToG2(input, 100000n);
			expect(result.success).toBe(true);
		});
	});

	describe("Output Format section", () => {
		it("should return 256 bytes (G2 point)", () => {
			// Doc states: Total output length: 256 bytes (G2 point)
			const input = new Uint8Array(128);
			const result = bls12MapFp2ToG2(input, 100000n);

			expect(result.success).toBe(true);
			expect(result.output.length).toBe(256);
		});

		it("should have 4 x 64-byte Fp2 components", () => {
			// G2 point: x.c0 (64) + x.c1 (64) + y.c0 (64) + y.c1 (64) = 256 bytes
			const input = new Uint8Array(128);
			const result = bls12MapFp2ToG2(input, 100000n);

			expect(result.success).toBe(true);
			const xc0 = result.output.slice(0, 64);
			const xc1 = result.output.slice(64, 128);
			const yc0 = result.output.slice(128, 192);
			const yc1 = result.output.slice(192, 256);

			expect(xc0.length).toBe(64);
			expect(xc1.length).toBe(64);
			expect(yc0.length).toBe(64);
			expect(yc1.length).toBe(64);
		});
	});

	describe("Mapping Properties section", () => {
		it("should produce deterministic output", () => {
			// Same input should produce same output
			const input = new Uint8Array(128);
			input[127] = 42;

			const result1 = bls12MapFp2ToG2(input, 100000n);
			const result2 = bls12MapFp2ToG2(input, 100000n);

			expect(result1.success).toBe(true);
			expect(result2.success).toBe(true);
			expect([...result1.output]).toEqual([...result2.output]);
		});

		it("should produce different outputs for different inputs", () => {
			const input1 = new Uint8Array(128);
			const input2 = new Uint8Array(128);
			input1[127] = 1;
			input2[127] = 2;

			const result1 = bls12MapFp2ToG2(input1, 100000n);
			const result2 = bls12MapFp2ToG2(input2, 100000n);

			expect(result1.success).toBe(true);
			expect(result2.success).toBe(true);
			// Outputs should be different (assuming both inputs are valid)
			if (result1.success && result2.success) {
				expect([...result1.output]).not.toEqual([...result2.output]);
			}
		});
	});

	describe("Integration with execute function", () => {
		it("should work via execute with PrecompileAddress.BLS12_MAP_FP2_TO_G2", () => {
			const input = new Uint8Array(128);
			const result = execute(
				PrecompileAddress.BLS12_MAP_FP2_TO_G2,
				input,
				100000n,
				Hardfork.PRAGUE,
			);

			expect(result.success).toBe(true);
			expect(result.gasUsed).toBe(75000n);
		});

		it("should be available from PRAGUE hardfork", () => {
			// Doc states: Introduced: Prague (EIP-2537)
			const input = new Uint8Array(128);
			const result = execute(
				PrecompileAddress.BLS12_MAP_FP2_TO_G2,
				input,
				100000n,
				Hardfork.PRAGUE,
			);
			expect(result.success).toBe(true);
		});

		it("hardfork availability via isPrecompile function", async () => {
			// NOTE: execute() does not enforce hardfork availability
			// Use isPrecompile() to check availability
			const { isPrecompile } = await import("../../../src/evm/precompiles/precompiles.js");
			expect(isPrecompile(PrecompileAddress.BLS12_MAP_FP2_TO_G2, Hardfork.PRAGUE)).toBe(true);
			expect(isPrecompile(PrecompileAddress.BLS12_MAP_FP2_TO_G2, Hardfork.CANCUN)).toBe(false);
		});
	});

	describe("Gas Comparison section", () => {
		it("should use 75000 gas compared to map-fp-to-g1's 5500", () => {
			// Map to G2 is more expensive due to extension field operations
			const input = new Uint8Array(128);
			const result = bls12MapFp2ToG2(input, 100000n);
			expect(result.gasUsed).toBe(75000n);
		});
	});

	describe("Use Cases section", () => {
		it("should support hash-to-curve operations for G2", () => {
			// Doc states: Used for hash-to-curve operations in BLS signatures (G2 variant)
			// We test that the precompile is callable with arbitrary input
			const arbitraryInput = new Uint8Array(128);
			for (let i = 0; i < 128; i++) {
				arbitraryInput[i] = i;
			}

			const result = bls12MapFp2ToG2(arbitraryInput, 100000n);
			expect(result.success).toBe(true);
			expect(result.output.length).toBe(256);
		});
	});
});

```
