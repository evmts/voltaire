---
title: '[TS/JS] docs/evm/instructions/comparison/sgt.test.ts'
source: 'docs/evm/instructions/comparison/sgt.test.ts'
---

> Auto-generated from test file: docs/evm/instructions/comparison/sgt.test.ts

```typescript
/**
 * Test file for SGT (0x13) documentation examples
 * Tests examples from sgt.mdx
 */
import { describe, expect, it } from "vitest";

describe("SGT (0x13) - Documentation Examples", async () => {
	const { SGT } = await import("../../../../src/evm/comparison/index.js");
	const { Frame } = await import("../../../../src/evm/Frame/index.js");

	/** Convert negative bigint to two's complement 256-bit representation */
	const toSigned = (n: bigint) => (n < 0n ? (1n << 256n) + n : n);

	function createFrame(stack: bigint[], gasRemaining = 1000000n) {
		const frame = Frame({ gas: gasRemaining });
		frame.stack = [...stack];
		return frame;
	}

	describe("Positive Values", () => {
		it("20 > 10 = 1 (both positive)", () => {
			const frame = createFrame([20n, 10n]);
			const err = SGT(frame);

			expect(err).toBeNull();
			expect(frame.stack).toEqual([1n]);
		});
	});

	describe("Positive Greater Than Negative", () => {
		it("10 > -1 = 1 (true)", () => {
			const NEG_1 = toSigned(-1n);
			const frame = createFrame([10n, NEG_1]);
			SGT(frame);

			expect(frame.stack).toEqual([1n]);
		});
	});

	describe("Negative Less Than Positive", () => {
		it("-1 > 10 = 0 (false)", () => {
			const NEG_1 = toSigned(-1n);
			const frame = createFrame([NEG_1, 10n]);
			SGT(frame);

			expect(frame.stack).toEqual([0n]);
		});
	});

	describe("Negative Value Comparison", () => {
		it("-5 > -10 = 1 (true)", () => {
			const NEG_5 = toSigned(-5n);
			const NEG_10 = toSigned(-10n);
			const frame = createFrame([NEG_5, NEG_10]);
			SGT(frame);

			expect(frame.stack).toEqual([1n]);
		});
	});

	describe("Zero Boundary", () => {
		it("0 > -1 = 1 (true)", () => {
			const NEG_1 = toSigned(-1n);
			const frame = createFrame([0n, NEG_1]);
			SGT(frame);

			expect(frame.stack).toEqual([1n]);
		});

		it("1 > 0 = 1 (true)", () => {
			const frame = createFrame([1n, 0n]);
			SGT(frame);
			expect(frame.stack).toEqual([1n]);
		});
	});

	describe("Minimum and Maximum", () => {
		it("MAX_INT256 > MIN_INT256 = 1", () => {
			const MIN_INT256 = 1n << 255n; // -2^255
			const MAX_INT256 = (1n << 255n) - 1n; // 2^255 - 1
			const frame = createFrame([MAX_INT256, MIN_INT256]);
			SGT(frame);

			expect(frame.stack).toEqual([1n]);
		});
	});

	describe("Contrast with Unsigned GT", () => {
		it("SGT: -2^255 > 1 = 0 (signed)", () => {
			const SIGN_BIT = 1n << 255n;
			const frame = createFrame([SIGN_BIT, 1n]);
			SGT(frame);
			expect(frame.stack).toEqual([0n]);
		});
	});

	describe("Edge Cases", () => {
		it("equal values return 0", () => {
			const frame = createFrame([20n, 20n]);
			SGT(frame);
			expect(frame.stack).toEqual([0n]);
		});

		it("-1 < 0 (-1 is not greater than 0)", () => {
			const NEG_1 = toSigned(-1n);
			const frame = createFrame([NEG_1, 0n]);
			SGT(frame);
			expect(frame.stack).toEqual([0n]);
		});

		it("returns StackUnderflow with insufficient stack", () => {
			const frame = createFrame([10n]);
			const err = SGT(frame);

			expect(err).toEqual({ type: "StackUnderflow" });
		});

		it("returns OutOfGas when insufficient gas", () => {
			const frame = createFrame([20n, 10n], 2n);
			const err = SGT(frame);

			expect(err).toEqual({ type: "OutOfGas" });
			expect(frame.gasRemaining).toBe(0n);
		});
	});

	describe("Gas Cost", () => {
		it("consumes 3 gas (GasFastestStep)", () => {
			const frame = createFrame([20n, 10n], 100n);
			const err = SGT(frame);

			expect(err).toBeNull();
			expect(frame.gasRemaining).toBe(97n);
		});
	});
});

```
