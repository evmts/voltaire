---
title: '[TS/JS] docs/evm/precompiles/ripemd160.test.ts'
source: 'docs/evm/precompiles/ripemd160.test.ts'
---

> Auto-generated from test file: docs/evm/precompiles/ripemd160.test.ts

```typescript
/**
 * Tests for ripemd160.mdx documentation examples
 * Validates code examples work correctly with actual API
 */
import { describe, expect, it } from "vitest";
import { PrecompileAddress, execute, ripemd160 } from "../../../src/evm/precompiles/precompiles.js";
import * as Hardfork from "../../../src/primitives/Hardfork/index.js";

/**
 * Helper: Convert Uint8Array to hex string
 */
function bytesToHex(bytes: Uint8Array): string {
	return Array.from(bytes)
		.map((b) => b.toString(16).padStart(2, "0"))
		.join("");
}

describe("ripemd160.mdx documentation examples", () => {
	describe("Overview section", () => {
		it("should produce 20-byte hash padded to 32 bytes", () => {
			// Doc states: producing a 20-byte hash of arbitrary input data
			const input = new TextEncoder().encode("test");
			const result = ripemd160(input, 10000n);

			expect(result.success).toBe(true);
			expect(result.output.length).toBe(32);
		});
	});

	describe("Gas Cost section", () => {
		it("should follow formula: 600 + 120 * ceil(input_length / 32)", () => {
			// Doc states: Base cost: 600 gas, Per-word cost: 120 gas per 32-byte word
			const testCases = [
				{ len: 0, expected: 600n },    // 0 bytes: 600 gas
				{ len: 32, expected: 720n },   // 32 bytes: 720 gas (600 + 120*1)
				{ len: 33, expected: 840n },   // 33 bytes: 840 gas (600 + 120*2)
				{ len: 64, expected: 840n },   // 64 bytes: 840 gas (600 + 120*2)
			];

			for (const { len, expected } of testCases) {
				const input = new Uint8Array(len);
				const result = ripemd160(input, 10000n);
				expect(result.gasUsed).toBe(expected);
			}
		});

		it("should fail with insufficient gas", () => {
			const input = new Uint8Array(0);
			const result = ripemd160(input, 599n); // Need 600
			expect(result.success).toBe(false);
			expect(result.error).toBe("Out of gas");
		});
	});

	describe("Input Format section", () => {
		it("should accept arbitrary-length byte array", () => {
			// Doc states: Accepts arbitrary-length byte array
			const testSizes = [0, 1, 31, 32, 33, 64, 128, 1000];

			for (const size of testSizes) {
				const input = new Uint8Array(size);
				const expectedGas = 600n + BigInt(Math.ceil(size / 32)) * 120n;
				const result = ripemd160(input, expectedGas + 100n);
				expect(result.success).toBe(true);
			}
		});
	});

	describe("Output Format section", () => {
		it("should return 32 bytes with 12 leading zeros", () => {
			// Doc states: Total output length: 32 bytes (20-byte hash + 12 bytes padding)
			// The hash is right-aligned in a 32-byte word with 12 leading zero bytes
			const input = new Uint8Array(0);
			const result = ripemd160(input, 10000n);

			expect(result.success).toBe(true);
			expect(result.output.length).toBe(32);
			// First 12 bytes should be zeros
			expect([...result.output.slice(0, 12)].every((b) => b === 0)).toBe(true);
		});
	});

	describe("Test Vectors from documentation", () => {
		it("should hash empty input correctly", () => {
			// Doc states: Expected: 9c1185a5c5e9fc54612808977ee8f548b2258d31 (20 bytes, padded to 32)
			// Full padded: 0x0000000000000000000000009c1185a5c5e9fc54612808977ee8f548b2258d31
			const input = new Uint8Array(0);
			const result = ripemd160(input, 10000n);

			expect(result.success).toBe(true);
			expect(bytesToHex(result.output)).toBe(
				"0000000000000000000000009c1185a5c5e9fc54612808977ee8f548b2258d31"
			);
		});

		it("should extract 20-byte hash from right side", () => {
			// Doc example shows extracting hash: const hash = result.output.slice(12, 32);
			const input = new TextEncoder().encode("Hello, Bitcoin!");
			const result = ripemd160(input, 10000n);

			expect(result.success).toBe(true);
			const hash = result.output.slice(12, 32);
			expect(hash.length).toBe(20);
		});
	});

	describe("Usage Example from documentation", () => {
		it("should work with TextEncoder input", () => {
			// Doc example: Hash some data with TextEncoder
			const input = new TextEncoder().encode("Hello, Bitcoin!");

			// Calculate required gas as shown in doc
			const words = Math.ceil(input.length / 32);
			const gasNeeded = 600n + 120n * BigInt(words);

			const result = ripemd160(input, gasNeeded);

			expect(result.success).toBe(true);
			expect(result.output.length).toBe(32);
		});
	});

	describe("Bitcoin Address Generation section", () => {
		it("should support Bitcoin address generation pattern", () => {
			// Doc states: Bitcoin P2PKH addresses use RIPEMD-160
			// Step 1: SHA-256 hash of public key (simulated)
			// Step 2: RIPEMD-160 hash of SHA-256 hash
			const sha256Hash = new Uint8Array(32).fill(0xab); // Simulated SHA-256 output

			const result = ripemd160(sha256Hash, 10000n);
			expect(result.success).toBe(true);
			expect(result.output.length).toBe(32);
			// Extract 20-byte hash for address
			const ripemd160Hash = result.output.slice(12, 32);
			expect(ripemd160Hash.length).toBe(20);
		});
	});

	describe("Integration with execute function", () => {
		it("should work via execute with PrecompileAddress.RIPEMD160", () => {
			const input = new TextEncoder().encode("test");
			const result = execute(
				PrecompileAddress.RIPEMD160,
				input,
				10000n,
				Hardfork.CANCUN,
			);

			expect(result.success).toBe(true);
			expect(result.output.length).toBe(32);
		});

		it("should be available in FRONTIER hardfork", () => {
			// Doc states: Introduced: Frontier
			const input = new Uint8Array(0);
			const result = execute(
				PrecompileAddress.RIPEMD160,
				input,
				10000n,
				Hardfork.FRONTIER,
			);
			expect(result.success).toBe(true);
		});
	});
});

```
