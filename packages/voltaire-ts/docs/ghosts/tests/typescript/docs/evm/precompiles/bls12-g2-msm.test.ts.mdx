---
title: '[TS/JS] docs/evm/precompiles/bls12-g2-msm.test.ts'
source: 'docs/evm/precompiles/bls12-g2-msm.test.ts'
---

> Auto-generated from test file: docs/evm/precompiles/bls12-g2-msm.test.ts

```typescript
/**
 * Tests for bls12-g2-msm.mdx documentation examples
 * Validates code examples work correctly with actual API
 */
import { describe, expect, it } from "vitest";
import { PrecompileAddress, execute, bls12G2Msm } from "../../../src/evm/precompiles/precompiles.js";
import * as Hardfork from "../../../src/primitives/Hardfork/index.js";

describe("bls12-g2-msm.mdx documentation examples", () => {
	describe("Overview section", () => {
		it("should perform multi-scalar multiplication on BLS12-381 G2 group", () => {
			// Doc states: computes the sum of multiple G2 points each multiplied by their respective scalars
			const input = new Uint8Array(288); // One pair: 256-byte point + 32-byte scalar
			const result = bls12G2Msm(input, 50000n);

			expect(result.success).toBe(true);
			expect(result.output.length).toBe(256);
		});
	});

	describe("Gas Cost section", () => {
		it("should follow formula: (BASE_GAS * k * discount) / 1000", () => {
			// Doc states: Dynamic with discount: (BASE_GAS * k * discount) / 1000
			// BASE_GAS: 45000, k: Number of pairs
			// For k=1, discount=1000, gas = (45000 * 1 * 1000) / 1000 = 45000
			const input = new Uint8Array(288); // 1 pair
			const result = bls12G2Msm(input, 50000n);

			expect(result.success).toBe(true);
			expect(result.gasUsed).toBe(45000n);
		});

		it("should apply discount for 2 pairs", () => {
			// For k=2, discount=820, gas = (45000 * 2 * 820) / 1000 = 73800
			const input = new Uint8Array(288 * 2); // 2 pairs
			const result = bls12G2Msm(input, 100000n);

			expect(result.success).toBe(true);
			expect(result.gasUsed).toBe(73800n);
		});

		it("should fail with insufficient gas", () => {
			const input = new Uint8Array(288);
			const result = bls12G2Msm(input, 44999n);

			expect(result.success).toBe(false);
			expect(result.error).toBe("Out of gas");
		});
	});

	describe("Input Format section", () => {
		it("should require input length as multiple of 288", () => {
			// Doc states: Total input length: 288 * k bytes (must be exact multiple of 288)
			const validSizes = [288, 576, 864];

			for (const size of validSizes) {
				const input = new Uint8Array(size);
				const result = bls12G2Msm(input, 200000n);
				expect(result.success).toBe(true);
			}
		});

		it("should fail for invalid input length", () => {
			// Doc states: Invalid input length: input.len % 288 != 0 or input.len == 0
			const invalidSizes = [0, 100, 287, 289, 500];

			for (const size of invalidSizes) {
				const input = new Uint8Array(size);
				const result = bls12G2Msm(input, 200000n);
				expect(result.success).toBe(false);
			}
		});
	});

	describe("Output Format section", () => {
		it("should return 256 bytes (single aggregated point)", () => {
			// Doc states: Total output length: 256 bytes (single aggregated G2 point)
			const input = new Uint8Array(288 * 2); // 2 pairs
			const result = bls12G2Msm(input, 100000n);

			expect(result.success).toBe(true);
			expect(result.output.length).toBe(256);
		});
	});

	describe("MSM Properties from documentation", () => {
		it("should return zero for all zero scalars", () => {
			// Doc states: Zero scalars: Points with k=0 contribute nothing to sum
			const input = new Uint8Array(288 * 2); // 2 pairs, all zeros
			const result = bls12G2Msm(input, 100000n);

			expect(result.success).toBe(true);
			// All scalars zero -> result is point at infinity
			expect([...result.output].every((b) => b === 0)).toBe(true);
		});

		it("should return zero for infinity points", () => {
			// Doc states: Point at infinity: Infinity points with any scalar contribute nothing
			const input = new Uint8Array(288);
			input[287] = 42; // scalar = 42, point = infinity
			const result = bls12G2Msm(input, 50000n);

			expect(result.success).toBe(true);
			// Infinity * 42 = Infinity
			expect([...result.output].every((b) => b === 0)).toBe(true);
		});
	});

	describe("Integration with execute function", () => {
		it("should work via execute with PrecompileAddress.BLS12_G2_MSM", () => {
			const input = new Uint8Array(288);
			const result = execute(
				PrecompileAddress.BLS12_G2_MSM,
				input,
				50000n,
				Hardfork.PRAGUE,
			);

			expect(result.success).toBe(true);
			expect(result.gasUsed).toBe(45000n);
		});

		it("should be available from PRAGUE hardfork", () => {
			// Doc states: Introduced: Prague (EIP-2537)
			const input = new Uint8Array(288);
			const result = execute(
				PrecompileAddress.BLS12_G2_MSM,
				input,
				50000n,
				Hardfork.PRAGUE,
			);
			expect(result.success).toBe(true);
		});

		it("hardfork availability via isPrecompile function", async () => {
			// NOTE: execute() does not enforce hardfork availability
			// Use isPrecompile() to check availability
			const { isPrecompile } = await import("../../../src/evm/precompiles/precompiles.js");
			expect(isPrecompile(PrecompileAddress.BLS12_G2_MSM, Hardfork.PRAGUE)).toBe(true);
			expect(isPrecompile(PrecompileAddress.BLS12_G2_MSM, Hardfork.CANCUN)).toBe(false);
		});
	});

	describe("Discount Table from documentation", () => {
		it("should apply correct discount for batch sizes", () => {
			// API DISCREPANCY: Actual implementation uses EIP-2537 multiplier-based formula
			// Similar to G1 MSM, uses multipliers: k=1 -> 1.0, k=2 -> 1.64
			const testCases = [
				{ k: 1, expectedGas: 45000n },  // multiplier=1.0
				{ k: 2, expectedGas: 73800n },  // multiplier=1.64
			];

			for (const { k, expectedGas } of testCases) {
				const input = new Uint8Array(288 * k);
				const result = bls12G2Msm(input, 200000n);
				expect(result.success).toBe(true);
				expect(result.gasUsed).toBe(expectedGas);
			}
		});
	});
});

```
