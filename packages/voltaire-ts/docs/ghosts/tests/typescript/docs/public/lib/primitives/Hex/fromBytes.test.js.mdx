---
title: '[TS/JS] docs/public/lib/primitives/Hex/fromBytes.test.js'
source: 'docs/public/lib/primitives/Hex/fromBytes.test.js'
---

> Auto-generated from test file: docs/public/lib/primitives/Hex/fromBytes.test.js

```javascript
import { describe, it, expect } from "vitest";
import { fromBytes } from "./fromBytes.js";

describe("Hex.fromBytes", () => {
	describe("basic conversion", () => {
		it("converts empty bytes to 0x", () => {
			const bytes = new Uint8Array([]);
			expect(fromBytes(bytes)).toBe("0x");
		});

		it("converts single byte", () => {
			const bytes = new Uint8Array([0x12]);
			expect(fromBytes(bytes)).toBe("0x12");
		});

		it("converts multiple bytes", () => {
			const bytes = new Uint8Array([0x12, 0x34, 0x56, 0x78]);
			expect(fromBytes(bytes)).toBe("0x12345678");
		});

		it("converts large byte array", () => {
			const bytes = new Uint8Array(32);
			for (let i = 0; i < 32; i++) {
				bytes[i] = i;
			}
			expect(fromBytes(bytes)).toBe(
				"0x000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f",
			);
		});
	});

	describe("padding", () => {
		it("pads single digit bytes", () => {
			const bytes = new Uint8Array([0x01, 0x0a, 0x0f]);
			expect(fromBytes(bytes)).toBe("0x010a0f");
		});

		it("pads zero bytes", () => {
			const bytes = new Uint8Array([0x00, 0x00, 0x00]);
			expect(fromBytes(bytes)).toBe("0x000000");
		});

		it("handles mix of padded and unpadded", () => {
			const bytes = new Uint8Array([0x00, 0xff, 0x01, 0xab]);
			expect(fromBytes(bytes)).toBe("0x00ff01ab");
		});
	});

	describe("edge cases", () => {
		it("converts all zeros", () => {
			const bytes = new Uint8Array([0, 0, 0, 0]);
			expect(fromBytes(bytes)).toBe("0x00000000");
		});

		it("converts all ones", () => {
			const bytes = new Uint8Array([255, 255, 255, 255]);
			expect(fromBytes(bytes)).toBe("0xffffffff");
		});

		it("converts max byte value", () => {
			const bytes = new Uint8Array([0xff]);
			expect(fromBytes(bytes)).toBe("0xff");
		});

		it("converts min byte value", () => {
			const bytes = new Uint8Array([0x00]);
			expect(fromBytes(bytes)).toBe("0x00");
		});

		it("converts alternating pattern", () => {
			const bytes = new Uint8Array([0xaa, 0x55, 0xaa, 0x55]);
			expect(fromBytes(bytes)).toBe("0xaa55aa55");
		});
	});

	describe("known encodings", () => {
		it("converts ASCII Hello", () => {
			const bytes = new Uint8Array([0x48, 0x65, 0x6c, 0x6c, 0x6f]);
			expect(fromBytes(bytes)).toBe("0x48656c6c6f");
		});

		it("converts address bytes", () => {
			const bytes = new Uint8Array([
				0xd8, 0xda, 0x6b, 0xf2, 0x69, 0x64, 0xaf, 0x9d, 0x7e, 0xed, 0x9e, 0x03,
				0xe5, 0x34, 0x15, 0xd3, 0x7a, 0xa9, 0x60, 0x45,
			]);
			expect(fromBytes(bytes)).toBe(
				"0xd8da6bf26964af9d7eed9e03e53415d37aa96045",
			);
		});

		it("converts hash bytes", () => {
			const bytes = new Uint8Array([
				0xc5, 0xd2, 0x46, 0x01, 0x86, 0xf7, 0x23, 0x3c, 0x92, 0x7e, 0x7d, 0xb2,
				0xdc, 0xc7, 0x03, 0xc0, 0xe5, 0x00, 0xb6, 0x53, 0xca, 0x82, 0x27, 0x3b,
				0x7b, 0xfa, 0xd8, 0x04, 0x5d, 0x85, 0xa4, 0x70,
			]);
			expect(fromBytes(bytes)).toBe(
				"0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470",
			);
		});
	});

	describe("lowercase output", () => {
		it("produces lowercase hex", () => {
			const bytes = new Uint8Array([0xab, 0xcd, 0xef]);
			const hex = fromBytes(bytes);
			expect(hex).toBe("0xabcdef");
			expect(hex).not.toBe("0xABCDEF");
		});

		it("produces lowercase for all hex digits", () => {
			const bytes = new Uint8Array([0xa, 0xb, 0xc, 0xd, 0xe, 0xf, 0x10, 0xff]);
			expect(fromBytes(bytes)).toBe("0x0a0b0c0d0e0f10ff");
		});
	});

	describe("round-trip compatibility", () => {
		it("produces valid hex string format", () => {
			const bytes = new Uint8Array([0x12, 0x34, 0x56]);
			const hex = fromBytes(bytes);
			expect(hex.startsWith("0x")).toBe(true);
			expect(hex.length % 2).toBe(0); // 0x + even number of chars
		});

		it("maintains byte values", () => {
			const original = new Uint8Array([1, 2, 3, 127, 128, 255]);
			const hex = fromBytes(original);
			expect(hex).toBe("0x0102037f80ff");
		});
	});

	describe("type safety", () => {
		it("returns HexType branded string", () => {
			const bytes = new Uint8Array([0x12]);
			const hex = fromBytes(bytes);
			expect(typeof hex).toBe("string");
			expect(hex.startsWith("0x")).toBe(true);
		});
	});
});

```
