---
title: '[TS/JS] examples/nonce-manager/NonceManager.test.ts'
source: 'examples/nonce-manager/NonceManager.test.ts'
---

> Auto-generated from test file: examples/nonce-manager/NonceManager.test.ts

```typescript
import { beforeEach, describe, expect, it, vi } from "vitest";
import {
	createNonceManager,
	inMemory,
	jsonRpc,
	wrapSigner,
} from "./NonceManager.js";
import { NonceStateError } from "./errors.js";

describe("NonceManager", () => {
	describe("createNonceManager", () => {
		it("creates manager with default JSON-RPC source", () => {
			const manager = createNonceManager();
			expect(manager).toBeDefined();
			expect(typeof manager.consume).toBe("function");
			expect(typeof manager.get).toBe("function");
			expect(typeof manager.increment).toBe("function");
			expect(typeof manager.reset).toBe("function");
			expect(typeof manager.recycle).toBe("function");
			expect(typeof manager.getDelta).toBe("function");
		});

		it("accepts custom source", () => {
			const source = inMemory();
			const manager = createNonceManager({ source });
			expect(manager).toBeDefined();
		});
	});

	describe("inMemory source", () => {
		it("returns 0 for unknown address", async () => {
			const source = inMemory();
			const nonce = await source.get({
				address: "0x1234567890123456789012345678901234567890",
				chainId: 1,
				provider: {},
			});
			expect(nonce).toBe(0);
		});

		it("tracks set nonces", async () => {
			const source = inMemory();
			const params = {
				address: "0x1234567890123456789012345678901234567890",
				chainId: 1,
			};

			source.setNonce(params.address, params.chainId, 5);
			const nonce = await source.get({ ...params, provider: {} });
			expect(nonce).toBe(5);
		});

		it("increments after set", async () => {
			const source = inMemory();
			const params = {
				address: "0x1234567890123456789012345678901234567890",
				chainId: 1,
			};

			source.set(params, 5);
			const nonce = await source.get({ ...params, provider: {} });
			expect(nonce).toBe(6); // set stores nonce + 1
		});
	});

	describe("get", () => {
		it("returns nonce from source", async () => {
			const source = inMemory();
			source.setNonce("0x1234567890123456789012345678901234567890", 1, 5);

			const manager = createNonceManager({ source });
			const nonce = await manager.get({
				address: "0x1234567890123456789012345678901234567890",
				chainId: 1,
				provider: {},
			});

			expect(nonce).toBe(5);
		});

		it("adds delta to fetched nonce", async () => {
			const source = inMemory();
			source.setNonce("0x1234567890123456789012345678901234567890", 1, 5);

			const manager = createNonceManager({ source });
			const params = {
				address: "0x1234567890123456789012345678901234567890",
				chainId: 1,
				provider: {},
			};

			// Increment delta before get
			manager.increment(params);
			manager.increment(params);

			const nonce = await manager.get(params);
			expect(nonce).toBe(7); // 5 + 2
		});

		it("caches promise for concurrent calls", async () => {
			let fetchCount = 0;
			const source = {
				get: vi.fn(async () => {
					fetchCount++;
					await new Promise((r) => setTimeout(r, 10));
					return 5;
				}),
				set: vi.fn(),
			};

			const manager = createNonceManager({ source });
			const params = {
				address: "0x1234567890123456789012345678901234567890",
				chainId: 1,
				provider: {},
			};

			// Call get concurrently
			const [n1, n2, n3] = await Promise.all([
				manager.get(params),
				manager.get(params),
				manager.get(params),
			]);

			// All should get same base nonce
			expect(n1).toBe(5);
			expect(n2).toBe(5);
			expect(n3).toBe(5);

			// But only one fetch should happen
			expect(fetchCount).toBe(1);
		});
	});

	describe("increment", () => {
		it("increments delta", () => {
			const manager = createNonceManager({ source: inMemory() });
			const params = {
				address: "0x1234567890123456789012345678901234567890",
				chainId: 1,
			};

			expect(manager.getDelta(params)).toBe(0);
			manager.increment(params);
			expect(manager.getDelta(params)).toBe(1);
			manager.increment(params);
			expect(manager.getDelta(params)).toBe(2);
		});

		it("tracks separate deltas per address", () => {
			const manager = createNonceManager({ source: inMemory() });
			const addr1 = {
				address: "0x1111111111111111111111111111111111111111",
				chainId: 1,
			};
			const addr2 = {
				address: "0x2222222222222222222222222222222222222222",
				chainId: 1,
			};

			manager.increment(addr1);
			manager.increment(addr1);
			manager.increment(addr2);

			expect(manager.getDelta(addr1)).toBe(2);
			expect(manager.getDelta(addr2)).toBe(1);
		});

		it("tracks separate deltas per chain", () => {
			const manager = createNonceManager({ source: inMemory() });
			const chain1 = {
				address: "0x1234567890123456789012345678901234567890",
				chainId: 1,
			};
			const chain2 = {
				address: "0x1234567890123456789012345678901234567890",
				chainId: 137,
			};

			manager.increment(chain1);
			manager.increment(chain1);
			manager.increment(chain2);

			expect(manager.getDelta(chain1)).toBe(2);
			expect(manager.getDelta(chain2)).toBe(1);
		});
	});

	describe("consume", () => {
		it("returns nonce and increments", async () => {
			const source = inMemory();
			source.setNonce("0x1234567890123456789012345678901234567890", 1, 5);

			const manager = createNonceManager({ source });
			const params = {
				address: "0x1234567890123456789012345678901234567890",
				chainId: 1,
				provider: {},
			};

			const nonce = await manager.consume(params);
			expect(nonce).toBe(5);
			expect(manager.getDelta(params)).toBe(0); // Reset after fetch
		});

		it("returns sequential nonces for concurrent calls", async () => {
			const source = {
				get: vi.fn(async () => {
					await new Promise((r) => setTimeout(r, 10));
					return 5;
				}),
				set: vi.fn(),
			};

			const manager = createNonceManager({ source });
			const params = {
				address: "0x1234567890123456789012345678901234567890",
				chainId: 1,
				provider: {},
			};

			// Concurrent consume calls
			const [n1, n2, n3] = await Promise.all([
				manager.consume(params),
				manager.consume(params),
				manager.consume(params),
			]);

			// Should be sequential
			const nonces = [n1, n2, n3].sort((a, b) => a - b);
			expect(nonces).toEqual([5, 6, 7]);
		});

		it("calls source.set after consuming", async () => {
			const source = {
				get: vi.fn(async () => 5),
				set: vi.fn(),
			};

			const manager = createNonceManager({ source });
			await manager.consume({
				address: "0x1234567890123456789012345678901234567890",
				chainId: 1,
				provider: {},
			});

			expect(source.set).toHaveBeenCalledWith(
				expect.objectContaining({
					address: "0x1234567890123456789012345678901234567890",
					chainId: 1,
				}),
				5,
			);
		});
	});

	describe("reset", () => {
		it("clears delta and promise cache", async () => {
			const source = inMemory();
			source.setNonce("0x1234567890123456789012345678901234567890", 1, 5);

			const manager = createNonceManager({ source });
			const params = {
				address: "0x1234567890123456789012345678901234567890",
				chainId: 1,
				provider: {},
			};

			// Build up some state
			manager.increment(params);
			manager.increment(params);
			expect(manager.getDelta(params)).toBe(2);

			// Reset
			manager.reset(params);
			expect(manager.getDelta(params)).toBe(0);

			// Next get should refetch
			const nonce = await manager.get(params);
			expect(nonce).toBe(5);
		});
	});

	describe("recycle", () => {
		it("decrements delta", () => {
			const manager = createNonceManager({ source: inMemory() });
			const params = {
				address: "0x1234567890123456789012345678901234567890",
				chainId: 1,
			};

			manager.increment(params);
			manager.increment(params);
			expect(manager.getDelta(params)).toBe(2);

			manager.recycle(params);
			expect(manager.getDelta(params)).toBe(1);
		});

		it("throws when delta is 0", () => {
			const manager = createNonceManager({ source: inMemory() });
			const params = {
				address: "0x1234567890123456789012345678901234567890",
				chainId: 1,
			};

			expect(() => manager.recycle(params)).toThrow(NonceStateError);
		});
	});

	describe("reorg handling", () => {
		it("uses previous nonce + 1 when chain nonce goes backwards", async () => {
			let chainNonce = 10;
			const source = {
				get: vi.fn(async () => chainNonce),
				set: vi.fn(),
			};

			const manager = createNonceManager({ source });
			const params = {
				address: "0x1234567890123456789012345678901234567890",
				chainId: 1,
				provider: {},
			};

			// First consume establishes previous nonce
			const nonce1 = await manager.consume(params);
			expect(nonce1).toBe(10);

			// Simulate reorg - chain nonce goes backwards
			chainNonce = 8;

			// Next consume should use previous + 1
			const nonce2 = await manager.consume(params);
			expect(nonce2).toBe(11); // previous (10) + 1
		});
	});

	describe("jsonRpc source", () => {
		it("works with ethers-style provider", async () => {
			const provider = {
				getTransactionCount: vi.fn(async () => 42),
			};

			const source = jsonRpc();
			const nonce = await source.get({
				address: "0x1234567890123456789012345678901234567890",
				chainId: 1,
				provider,
			});

			expect(nonce).toBe(42);
			expect(provider.getTransactionCount).toHaveBeenCalledWith(
				"0x1234567890123456789012345678901234567890",
				"pending",
			);
		});

		it("works with viem-style client", async () => {
			const client = {
				request: vi.fn(async () => "0x2a"), // 42 in hex
			};

			const source = jsonRpc();
			const nonce = await source.get({
				address: "0x1234567890123456789012345678901234567890",
				chainId: 1,
				provider: client,
			});

			expect(nonce).toBe(42);
			expect(client.request).toHaveBeenCalledWith({
				method: "eth_getTransactionCount",
				params: ["0x1234567890123456789012345678901234567890", "pending"],
			});
		});

		it("throws for invalid provider", async () => {
			const source = jsonRpc();

			await expect(
				source.get({
					address: "0x1234567890123456789012345678901234567890",
					chainId: 1,
					provider: {},
				}),
			).rejects.toThrow(
				"Provider must have getTransactionCount or request method",
			);
		});
	});

	describe("wrapSigner", () => {
		it("wraps signer with nonce management", async () => {
			const mockSigner = {
				getAddress: vi.fn(
					async () => "0x1234567890123456789012345678901234567890",
				),
				sendTransaction: vi.fn(async (tx) => ({ hash: "0xabc", ...tx })),
				provider: {
					getTransactionCount: vi.fn(async () => 5),
				},
			};

			const wrapped = wrapSigner(mockSigner, { chainId: 1 });

			expect(wrapped.signer).toBe(mockSigner);
			expect(wrapped.nonceManager).toBeDefined();

			// Send transaction
			const result = await wrapped.sendTransaction({
				to: "0xabc",
				value: 100n,
			});

			// Should have populated nonce
			expect(mockSigner.sendTransaction).toHaveBeenCalledWith(
				expect.objectContaining({ nonce: 5 }),
			);
		});

		it("recycles nonce on send failure", async () => {
			const mockSigner = {
				getAddress: vi.fn(
					async () => "0x1234567890123456789012345678901234567890",
				),
				sendTransaction: vi.fn(async () => {
					throw new Error("tx failed");
				}),
				provider: {
					getTransactionCount: vi.fn(async () => 5),
				},
			};

			const wrapped = wrapSigner(mockSigner, { chainId: 1 });

			await expect(wrapped.sendTransaction({ to: "0xabc" })).rejects.toThrow(
				"tx failed",
			);

			// Delta should be 0 after recycle
			expect(
				wrapped.nonceManager.getDelta({
					address: "0x1234567890123456789012345678901234567890",
					chainId: 1,
				}),
			).toBe(0);
		});

		it("provides resetNonce method", async () => {
			const mockSigner = {
				getAddress: vi.fn(
					async () => "0x1234567890123456789012345678901234567890",
				),
				sendTransaction: vi.fn(),
				provider: {},
			};

			const wrapped = wrapSigner(mockSigner, { chainId: 1 });

			// Increment some nonces
			wrapped.nonceManager.increment({
				address: "0x1234567890123456789012345678901234567890",
				chainId: 1,
			});

			// Reset
			await wrapped.resetNonce();

			expect(
				wrapped.nonceManager.getDelta({
					address: "0x1234567890123456789012345678901234567890",
					chainId: 1,
				}),
			).toBe(0);
		});

		it("throws without getAddress", () => {
			expect(() =>
				wrapSigner({ sendTransaction: vi.fn() }, { chainId: 1 }),
			).toThrow("Signer must have getAddress method");
		});

		it("throws without sendTransaction", () => {
			expect(() => wrapSigner({ getAddress: vi.fn() }, { chainId: 1 })).toThrow(
				"Signer must have sendTransaction method",
			);
		});
	});

	describe("address normalization", () => {
		it("normalizes uppercase addresses", async () => {
			const source = inMemory();
			source.setNonce("0xabcdef1234567890abcdef1234567890abcdef12", 1, 5);

			const manager = createNonceManager({ source });

			// Use uppercase address
			const nonce = await manager.get({
				address: "0xABCDEF1234567890ABCDEF1234567890ABCDEF12",
				chainId: 1,
				provider: {},
			});

			expect(nonce).toBe(5);
		});

		it("normalizes mixed case addresses", async () => {
			const manager = createNonceManager({ source: inMemory() });

			const lower = {
				address: "0xabcdef1234567890abcdef1234567890abcdef12" as const,
				chainId: 1,
			};
			const upper = {
				address: "0xABCDEF1234567890ABCDEF1234567890ABCDEF12" as const,
				chainId: 1,
			};

			manager.increment(lower);
			manager.increment(upper);

			// Both should affect same delta
			expect(manager.getDelta(lower)).toBe(2);
			expect(manager.getDelta(upper)).toBe(2);
		});
	});
});

```
