---
title: '[TS/JS] examples/ethers-contract/EthersContract.test.ts'
source: 'examples/ethers-contract/EthersContract.test.ts'
---

> Auto-generated from test file: examples/ethers-contract/EthersContract.test.ts

```typescript
/**
 * Ethers-style Contract Tests
 *
 * Comprehensive tests for EthersContract and ContractFactory.
 *
 * @module examples/ethers-contract/EthersContract.test
 */

import { beforeEach, describe, expect, it, vi } from "vitest";
import { ContractFactory } from "./ContractFactory.js";
import { EthersContract } from "./EthersContract.js";
import {
	EventNotFoundError,
	FunctionNotFoundError,
	InvalidArgumentError,
	PanicReasons,
	UnsupportedOperationError,
	decodeRevertReason,
} from "./errors.js";

// Test ABI - ERC20
const erc20Abi = [
	{
		type: "function",
		name: "name",
		stateMutability: "view",
		inputs: [],
		outputs: [{ name: "", type: "string" }],
	},
	{
		type: "function",
		name: "symbol",
		stateMutability: "view",
		inputs: [],
		outputs: [{ name: "", type: "string" }],
	},
	{
		type: "function",
		name: "decimals",
		stateMutability: "view",
		inputs: [],
		outputs: [{ name: "", type: "uint8" }],
	},
	{
		type: "function",
		name: "totalSupply",
		stateMutability: "view",
		inputs: [],
		outputs: [{ name: "", type: "uint256" }],
	},
	{
		type: "function",
		name: "balanceOf",
		stateMutability: "view",
		inputs: [{ name: "account", type: "address" }],
		outputs: [{ name: "", type: "uint256" }],
	},
	{
		type: "function",
		name: "transfer",
		stateMutability: "nonpayable",
		inputs: [
			{ name: "to", type: "address" },
			{ name: "amount", type: "uint256" },
		],
		outputs: [{ name: "", type: "bool" }],
	},
	{
		type: "function",
		name: "approve",
		stateMutability: "nonpayable",
		inputs: [
			{ name: "spender", type: "address" },
			{ name: "amount", type: "uint256" },
		],
		outputs: [{ name: "", type: "bool" }],
	},
	{
		type: "function",
		name: "transferFrom",
		stateMutability: "nonpayable",
		inputs: [
			{ name: "from", type: "address" },
			{ name: "to", type: "address" },
			{ name: "amount", type: "uint256" },
		],
		outputs: [{ name: "", type: "bool" }],
	},
	{
		type: "event",
		name: "Transfer",
		inputs: [
			{ name: "from", type: "address", indexed: true },
			{ name: "to", type: "address", indexed: true },
			{ name: "value", type: "uint256", indexed: false },
		],
	},
	{
		type: "event",
		name: "Approval",
		inputs: [
			{ name: "owner", type: "address", indexed: true },
			{ name: "spender", type: "address", indexed: true },
			{ name: "value", type: "uint256", indexed: false },
		],
	},
] as const;

// Mock provider
function createMockProvider() {
	return {
		request: vi.fn(),
	};
}

describe("EthersContract", () => {
	describe("constructor", () => {
		it("creates contract with address and ABI", () => {
			const provider = createMockProvider();
			const contract = EthersContract({
				target: "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48",
				abi: erc20Abi,
				runner: provider,
			});

			expect(contract.target).toBe(
				"0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48",
			);
			expect(contract.runner).toBe(provider);
			expect(contract.interface).toBeDefined();
		});

		it("creates contract without runner", () => {
			const contract = EthersContract({
				target: "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48",
				abi: erc20Abi,
			});

			expect(contract.runner).toBeNull();
		});

		it("normalizes address to lowercase", async () => {
			const contract = EthersContract({
				target: "0xA0B86991C6218B36C1D19D4A2E9EB0CE3606EB48",
				abi: erc20Abi,
			});

			const addr = await contract.getAddress();
			expect(addr).toBe("0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48");
		});
	});

	describe("getAddress", () => {
		it("resolves to contract address", async () => {
			const contract = EthersContract({
				target: "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48",
				abi: erc20Abi,
			});

			const addr = await contract.getAddress();
			expect(addr).toBe("0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48");
		});
	});

	describe("connect", () => {
		it("returns new contract with different runner", () => {
			const provider1 = createMockProvider();
			const provider2 = createMockProvider();

			const contract1 = EthersContract({
				target: "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48",
				abi: erc20Abi,
				runner: provider1,
			});

			const contract2 = contract1.connect(provider2);

			expect(contract2.runner).toBe(provider2);
			expect(contract1.runner).toBe(provider1);
			expect(contract2.target).toBe(contract1.target);
		});
	});

	describe("attach", () => {
		it("returns new contract with different address", () => {
			const provider = createMockProvider();

			const contract1 = EthersContract({
				target: "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48",
				abi: erc20Abi,
				runner: provider,
			});

			const contract2 = contract1.attach(
				"0xdAC17F958D2ee523a2206206994597C13D831ec7",
			);

			expect(contract2.target).toBe(
				"0xdAC17F958D2ee523a2206206994597C13D831ec7",
			);
			expect(contract1.target).toBe(
				"0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48",
			);
			expect(contract2.runner).toBe(provider);
		});
	});

	describe("getFunction", () => {
		it("returns wrapped method for existing function", () => {
			const contract = EthersContract({
				target: "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48",
				abi: erc20Abi,
			});

			const fn = contract.getFunction("balanceOf");

			expect(fn).toBeDefined();
			expect(typeof fn).toBe("function");
			expect(fn.name).toBe("balanceOf");
			expect(fn.staticCall).toBeDefined();
			expect(fn.send).toBeDefined();
			expect(fn.estimateGas).toBeDefined();
			expect(fn.populateTransaction).toBeDefined();
		});

		it("returns wrapped function that throws when called for non-existent function", async () => {
			const provider = createMockProvider();
			const contract = EthersContract({
				target: "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48",
				abi: erc20Abi,
				runner: provider,
			});

			const fn = contract.getFunction("nonExistent");
			// ethers v6 pattern: returns wrapped function that throws when called
			expect(fn).toBeDefined();
			await expect(fn()).rejects.toThrow(FunctionNotFoundError);
		});
	});

	describe("getEvent", () => {
		it("returns wrapped event for existing event", () => {
			const contract = EthersContract({
				target: "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48",
				abi: erc20Abi,
			});

			const event = contract.getEvent("Transfer");

			expect(event).toBeDefined();
			expect(typeof event).toBe("function");
			expect(event.name).toBe("Transfer");
			expect(event.getFragment).toBeDefined();
		});

		it("returns wrapped event that throws when called for non-existent event", () => {
			const contract = EthersContract({
				target: "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48",
				abi: erc20Abi,
			});

			const event = contract.getEvent("NonExistent");
			// ethers v6 pattern: returns wrapped event that throws when called
			expect(event).toBeDefined();
			expect(() => event()).toThrow(EventNotFoundError);
		});
	});

	describe("dynamic method access", () => {
		it("accesses view functions via proxy", async () => {
			const provider = createMockProvider();
			// Return encoded uint256 (1000000)
			provider.request.mockResolvedValue(
				"0x00000000000000000000000000000000000000000000000000000000000f4240",
			);

			const contract = EthersContract({
				target: "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48",
				abi: erc20Abi,
				runner: provider,
			});

			const balance = await contract.balanceOf(
				"0x1234567890123456789012345678901234567890",
			);

			expect(balance).toBe(1000000n);
			expect(provider.request).toHaveBeenCalledWith(
				expect.objectContaining({
					method: "eth_call",
				}),
			);
		});

		it("accesses write functions via proxy", async () => {
			const provider = createMockProvider();
			provider.request.mockResolvedValue(
				"0x1234567890123456789012345678901234567890123456789012345678901234",
			);

			const contract = EthersContract({
				target: "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48",
				abi: erc20Abi,
				runner: provider,
			});

			const tx = await contract.transfer(
				"0x1234567890123456789012345678901234567890",
				1000n,
			);

			expect(tx.hash).toBeDefined();
			expect(provider.request).toHaveBeenCalledWith(
				expect.objectContaining({
					method: "eth_sendTransaction",
				}),
			);
		});

		it("returns wrapped function for non-existent function that throws when called", async () => {
			const provider = createMockProvider();
			const contract = EthersContract({
				target: "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48",
				abi: erc20Abi,
				runner: provider,
			});

			// ethers v6 pattern: proxy returns a function, calling it throws
			const fn = contract.nonExistentFunction;
			expect(fn).toBeDefined();
			await expect(fn()).rejects.toThrow(FunctionNotFoundError);
		});
	});

	describe("staticCall", () => {
		it("calls eth_call for view functions", async () => {
			const provider = createMockProvider();
			provider.request.mockResolvedValue(
				"0x00000000000000000000000000000000000000000000000000000000000f4240",
			);

			const contract = EthersContract({
				target: "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48",
				abi: erc20Abi,
				runner: provider,
			});

			const balance = await contract.balanceOf.staticCall(
				"0x1234567890123456789012345678901234567890",
			);

			expect(balance).toBe(1000000n);
		});

		it("simulates write functions", async () => {
			const provider = createMockProvider();
			// Return encoded bool (true)
			provider.request.mockResolvedValue(
				"0x0000000000000000000000000000000000000000000000000000000000000001",
			);

			const contract = EthersContract({
				target: "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48",
				abi: erc20Abi,
				runner: provider,
			});

			const result = await contract.transfer.staticCall(
				"0x1234567890123456789012345678901234567890",
				1000n,
			);

			expect(result).toBe(true);
		});

		it("throws without provider", async () => {
			const contract = EthersContract({
				target: "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48",
				abi: erc20Abi,
			});

			await expect(
				contract.balanceOf.staticCall(
					"0x1234567890123456789012345678901234567890",
				),
			).rejects.toThrow(UnsupportedOperationError);
		});
	});

	describe("send", () => {
		it("sends transaction for write functions", async () => {
			const provider = createMockProvider();
			provider.request.mockResolvedValue(
				"0x1234567890123456789012345678901234567890123456789012345678901234",
			);

			const contract = EthersContract({
				target: "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48",
				abi: erc20Abi,
				runner: provider,
			});

			const tx = await contract.transfer.send(
				"0x1234567890123456789012345678901234567890",
				1000n,
			);

			expect(tx.hash).toBeDefined();
			expect(provider.request).toHaveBeenCalledWith(
				expect.objectContaining({
					method: "eth_sendTransaction",
				}),
			);
		});

		it("throws without signer", async () => {
			const contract = EthersContract({
				target: "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48",
				abi: erc20Abi,
			});

			await expect(
				contract.transfer.send(
					"0x1234567890123456789012345678901234567890",
					1000n,
				),
			).rejects.toThrow(UnsupportedOperationError);
		});
	});

	describe("estimateGas", () => {
		it("estimates gas for functions", async () => {
			const provider = createMockProvider();
			provider.request.mockResolvedValue("0x5208"); // 21000

			const contract = EthersContract({
				target: "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48",
				abi: erc20Abi,
				runner: provider,
			});

			const gas = await contract.transfer.estimateGas(
				"0x1234567890123456789012345678901234567890",
				1000n,
			);

			expect(gas).toBe(21000n);
			expect(provider.request).toHaveBeenCalledWith(
				expect.objectContaining({
					method: "eth_estimateGas",
				}),
			);
		});
	});

	describe("populateTransaction", () => {
		it("builds transaction without sending", async () => {
			const provider = createMockProvider();

			const contract = EthersContract({
				target: "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48",
				abi: erc20Abi,
				runner: provider,
			});

			const tx = await contract.transfer.populateTransaction(
				"0x1234567890123456789012345678901234567890",
				1000n,
			);

			expect(tx.to).toBe("0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48");
			expect(tx.data).toBeDefined();
			expect(tx.data).toMatch(/^0x/);
		});

		it("includes overrides", async () => {
			const provider = createMockProvider();

			const contract = EthersContract({
				target: "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48",
				abi: erc20Abi,
				runner: provider,
			});

			const tx = await contract.transfer.populateTransaction(
				"0x1234567890123456789012345678901234567890",
				1000n,
				{ gasLimit: 100000n },
			);

			expect(tx.gasLimit).toBe(100000n);
		});
	});

	describe("filters", () => {
		it("creates event filter", () => {
			const contract = EthersContract({
				target: "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48",
				abi: erc20Abi,
			});

			const filter = contract.filters.Transfer();

			expect(filter).toBeDefined();
			expect(filter.fragment).toBeDefined();
			expect(filter.getTopicFilter).toBeDefined();
		});

		it("creates filter with arguments", () => {
			const contract = EthersContract({
				target: "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48",
				abi: erc20Abi,
			});

			const filter = contract.filters.Transfer({
				from: "0x1234567890123456789012345678901234567890",
			});

			expect(filter).toBeDefined();
			expect(filter.fragment.name).toBe("Transfer");
		});

		it("returns wrapped event for non-existent event that throws when called", () => {
			const contract = EthersContract({
				target: "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48",
				abi: erc20Abi,
			});

			// ethers v6 pattern: proxy returns a function, calling it throws
			const event = contract.filters.NonExistent;
			expect(event).toBeDefined();
			expect(() => event()).toThrow(EventNotFoundError);
		});
	});

	describe("queryFilter", () => {
		it("queries historical logs", async () => {
			const provider = createMockProvider();
			provider.request.mockResolvedValue([
				{
					address: "0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48",
					topics: [
						"0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef",
						"0x0000000000000000000000001234567890123456789012345678901234567890",
						"0x0000000000000000000000000987654321098765432109876543210987654321",
					],
					data: "0x00000000000000000000000000000000000000000000000000000000000003e8",
					blockNumber: "0x100",
					blockHash:
						"0xabcdef1234567890abcdef1234567890abcdef1234567890abcdef1234567890",
					transactionHash:
						"0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef",
					logIndex: "0x0",
				},
			]);

			const contract = EthersContract({
				target: "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48",
				abi: erc20Abi,
				runner: provider,
			});

			const logs = await contract.queryFilter("Transfer", 0, "latest");

			expect(logs).toHaveLength(1);
			expect(logs[0].eventName).toBe("Transfer");
			expect(logs[0].args).toBeDefined();
		});

		it("queries with PreparedTopicFilter", async () => {
			const provider = createMockProvider();
			provider.request.mockResolvedValue([]);

			const contract = EthersContract({
				target: "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48",
				abi: erc20Abi,
				runner: provider,
			});

			const filter = contract.filters.Transfer({
				from: "0x1234567890123456789012345678901234567890",
			});
			const logs = await contract.queryFilter(filter);

			expect(logs).toEqual([]);
			expect(provider.request).toHaveBeenCalled();
		});
	});

	describe("event subscriptions", () => {
		it("subscribes with on", async () => {
			const provider = createMockProvider();
			provider.request.mockResolvedValue("0x1234"); // subscription id

			const contract = EthersContract({
				target: "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48",
				abi: erc20Abi,
				runner: provider,
			});

			const listener = vi.fn();
			await contract.on("Transfer", listener);

			const count = await contract.listenerCount("Transfer");
			expect(count).toBe(1);
		});

		it("unsubscribes with off", async () => {
			const provider = createMockProvider();
			provider.request.mockResolvedValue("0x1234");

			const contract = EthersContract({
				target: "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48",
				abi: erc20Abi,
				runner: provider,
			});

			const listener = vi.fn();
			await contract.on("Transfer", listener);
			await contract.off("Transfer", listener);

			const count = await contract.listenerCount("Transfer");
			expect(count).toBe(0);
		});

		it("removeAllListeners clears all", async () => {
			const provider = createMockProvider();
			provider.request.mockResolvedValue("0x1234");

			const contract = EthersContract({
				target: "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48",
				abi: erc20Abi,
				runner: provider,
			});

			await contract.on("Transfer", vi.fn());
			await contract.on("Approval", vi.fn());
			await contract.removeAllListeners();

			const count = await contract.listenerCount();
			expect(count).toBe(0);
		});
	});
});

describe("ContractFactory", () => {
	const simpleBytecode =
		"0x608060405234801561001057600080fd5b50610150806100206000396000f3";

	const abiWithConstructor = [
		{
			type: "constructor",
			inputs: [
				{ name: "name", type: "string" },
				{ name: "symbol", type: "string" },
			],
		},
		{
			type: "function",
			name: "name",
			stateMutability: "view",
			inputs: [],
			outputs: [{ name: "", type: "string" }],
		},
	] as const;

	describe("constructor", () => {
		it("creates factory with abi and bytecode", () => {
			const factory = ContractFactory({
				abi: abiWithConstructor,
				bytecode: simpleBytecode,
			});

			expect(factory.interface).toBeDefined();
			expect(factory.bytecode).toBe(simpleBytecode);
			expect(factory.runner).toBeNull();
		});

		it("normalizes bytecode from Uint8Array", () => {
			const bytes = new Uint8Array([0x60, 0x80, 0x60, 0x40]);
			const factory = ContractFactory({
				abi: erc20Abi,
				bytecode: bytes,
			});

			expect(factory.bytecode).toBe("0x60806040");
		});

		it("normalizes bytecode from object", () => {
			const factory = ContractFactory({
				abi: erc20Abi,
				bytecode: { object: "60806040" },
			});

			expect(factory.bytecode).toBe("0x60806040");
		});

		it("adds 0x prefix if missing", () => {
			const factory = ContractFactory({
				abi: erc20Abi,
				bytecode: "60806040",
			});

			expect(factory.bytecode).toBe("0x60806040");
		});
	});

	describe("attach", () => {
		it("creates contract at address", () => {
			const factory = ContractFactory({
				abi: erc20Abi,
				bytecode: simpleBytecode,
			});

			const contract = factory.attach(
				"0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48",
			);

			expect(contract.target).toBe(
				"0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48",
			);
		});
	});

	describe("connect", () => {
		it("returns new factory with different runner", () => {
			const provider1 = createMockProvider();
			const provider2 = createMockProvider();

			const factory1 = ContractFactory({
				abi: erc20Abi,
				bytecode: simpleBytecode,
				runner: provider1,
			});

			const factory2 = factory1.connect(provider2);

			expect(factory2.runner).toBe(provider2);
			expect(factory1.runner).toBe(provider1);
		});
	});

	describe("getDeployTransaction", () => {
		it("builds deploy transaction without constructor args", async () => {
			const factory = ContractFactory({
				abi: erc20Abi,
				bytecode: simpleBytecode,
			});

			const tx = await factory.getDeployTransaction();

			expect(tx.data).toBe(simpleBytecode);
		});

		it("builds deploy transaction with constructor args", async () => {
			const factory = ContractFactory({
				abi: abiWithConstructor,
				bytecode: simpleBytecode,
			});

			const tx = await factory.getDeployTransaction("MyToken", "MTK");

			expect(tx.data).toBeDefined();
			expect(tx.data?.startsWith(simpleBytecode)).toBe(true);
			expect(tx.data?.length).toBeGreaterThan(simpleBytecode.length);
		});

		it("includes overrides", async () => {
			const factory = ContractFactory({
				abi: abiWithConstructor,
				bytecode: simpleBytecode,
			});

			const tx = await factory.getDeployTransaction("MyToken", "MTK", {
				gasLimit: 1000000n,
			});

			expect(tx.gasLimit).toBe(1000000n);
		});

		it("throws on wrong number of args", async () => {
			const factory = ContractFactory({
				abi: abiWithConstructor,
				bytecode: simpleBytecode,
			});

			await expect(factory.getDeployTransaction("OnlyOneArg")).rejects.toThrow(
				InvalidArgumentError,
			);
		});
	});

	describe("deploy", () => {
		it("deploys contract", async () => {
			const provider = createMockProvider();
			provider.request
				.mockResolvedValueOnce(["0x1234567890123456789012345678901234567890"]) // eth_accounts
				.mockResolvedValueOnce("0x5") // eth_getTransactionCount
				.mockResolvedValueOnce(
					"0xabcdef1234567890abcdef1234567890abcdef1234567890abcdef1234567890",
				); // eth_sendTransaction

			const factory = ContractFactory({
				abi: abiWithConstructor,
				bytecode: simpleBytecode,
				runner: provider,
			});

			const contract = await factory.deploy("MyToken", "MTK");

			expect(contract).toBeDefined();
			expect(provider.request).toHaveBeenCalledWith(
				expect.objectContaining({
					method: "eth_sendTransaction",
				}),
			);
		});

		it("throws without signer", async () => {
			const factory = ContractFactory({
				abi: abiWithConstructor,
				bytecode: simpleBytecode,
			});

			await expect(factory.deploy("MyToken", "MTK")).rejects.toThrow(
				UnsupportedOperationError,
			);
		});
	});

	describe("fromSolidity", () => {
		it("creates from compiler output", () => {
			const output = {
				abi: erc20Abi,
				bytecode: simpleBytecode,
			};

			const factory = ContractFactory.fromSolidity(output);

			expect(factory.interface).toBeDefined();
			expect(factory.bytecode).toBe(simpleBytecode);
		});

		it("creates from evm.bytecode format", () => {
			const output = {
				abi: erc20Abi,
				evm: {
					bytecode: {
						object: simpleBytecode.slice(2),
					},
				},
			};

			const factory = ContractFactory.fromSolidity(output);

			expect(factory.bytecode).toBe(simpleBytecode);
		});

		it("parses JSON string", () => {
			const output = JSON.stringify({
				abi: erc20Abi,
				bytecode: simpleBytecode,
			});

			const factory = ContractFactory.fromSolidity(output);

			expect(factory.interface).toBeDefined();
		});

		it("throws on null output", () => {
			expect(() => ContractFactory.fromSolidity(null)).toThrow(
				InvalidArgumentError,
			);
		});
	});
});

describe("errors", () => {
	describe("decodeRevertReason", () => {
		it("decodes Error(string)", () => {
			// Error("Insufficient balance")
			const data = new Uint8Array([
				0x08,
				0xc3,
				0x79,
				0xa0, // selector
				0x00,
				0x00,
				0x00,
				0x00,
				0x00,
				0x00,
				0x00,
				0x00, // offset = 32
				0x00,
				0x00,
				0x00,
				0x00,
				0x00,
				0x00,
				0x00,
				0x00,
				0x00,
				0x00,
				0x00,
				0x00,
				0x00,
				0x00,
				0x00,
				0x00,
				0x00,
				0x00,
				0x00,
				0x00,
				0x00,
				0x00,
				0x00,
				0x20,
				0x00,
				0x00,
				0x00,
				0x00,
				0x00,
				0x00,
				0x00,
				0x00, // length = 20
				0x00,
				0x00,
				0x00,
				0x00,
				0x00,
				0x00,
				0x00,
				0x00,
				0x00,
				0x00,
				0x00,
				0x00,
				0x00,
				0x00,
				0x00,
				0x00,
				0x00,
				0x00,
				0x00,
				0x00,
				0x00,
				0x00,
				0x00,
				0x14,
				0x49,
				0x6e,
				0x73,
				0x75,
				0x66,
				0x66,
				0x69,
				0x63, // "Insufficient balance"
				0x69,
				0x65,
				0x6e,
				0x74,
				0x20,
				0x62,
				0x61,
				0x6c,
				0x61,
				0x6e,
				0x63,
				0x65,
				0x00,
				0x00,
				0x00,
				0x00,
				0x00,
				0x00,
				0x00,
				0x00,
				0x00,
				0x00,
				0x00,
				0x00,
			]);

			const reason = decodeRevertReason(data);
			expect(reason).toContain("Insufficient balance");
		});

		it("decodes Panic(uint256)", () => {
			// Panic(0x11) - arithmetic overflow
			const data = new Uint8Array([
				0x4e,
				0x48,
				0x7b,
				0x71, // selector
				0x00,
				0x00,
				0x00,
				0x00,
				0x00,
				0x00,
				0x00,
				0x00, // code = 17
				0x00,
				0x00,
				0x00,
				0x00,
				0x00,
				0x00,
				0x00,
				0x00,
				0x00,
				0x00,
				0x00,
				0x00,
				0x00,
				0x00,
				0x00,
				0x00,
				0x00,
				0x00,
				0x00,
				0x00,
				0x00,
				0x00,
				0x00,
				0x11,
			]);

			const reason = decodeRevertReason(data);
			expect(reason).toContain("arithmetic overflow");
		});

		it("returns null for unknown selector", () => {
			const data = new Uint8Array([0x12, 0x34, 0x56, 0x78]);
			expect(decodeRevertReason(data)).toBeNull();
		});

		it("returns null for short data", () => {
			const data = new Uint8Array([0x08, 0xc3]);
			expect(decodeRevertReason(data)).toBeNull();
		});
	});

	describe("PanicReasons", () => {
		it("has known panic codes", () => {
			expect(PanicReasons["0"]).toBe("generic panic");
			expect(PanicReasons["1"]).toBe("assert(false)");
			expect(PanicReasons["17"]).toBe("arithmetic overflow");
			expect(PanicReasons["18"]).toBe("division or modulo by zero");
		});
	});
});

```
