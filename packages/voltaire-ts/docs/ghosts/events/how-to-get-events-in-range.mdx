---
title: How to Get Events in Block Range
description: Fetch all events within a specific block range using EventStream backfill.
---

## Goal

Retrieve all matching events between two block numbers.

## Using EventStream.backfill

```typescript
import { Contract } from '@voltaire/contract';

const usdc = Contract({
  address: '0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48',
  abi: erc20Abi,
  provider
});

const stream = usdc.events.Transfer({});

for await (const { log, metadata } of stream.backfill({
  fromBlock: 18000000n,
  toBlock: 18001000n
})) {
  console.log(`Block ${log.blockNumber}: ${log.args.from} -> ${log.args.to}`);
}
```

## Large Ranges with Auto-Chunking

EventStream handles "block range too large" errors automatically:

```typescript
// Process 1M blocks - chunking handled internally
for await (const { log } of stream.backfill({
  fromBlock: 0n,
  toBlock: 19000000n,
  chunkSize: 1000,     // initial chunk (default: 500)
  minChunkSize: 50     // minimum after reduction (default: 10)
})) {
  processEvent(log);
}
```

Chunking behavior:
- Starts at `chunkSize` blocks per request
- Reduces by 50% on "range too large" errors
- Increases by 25% after 5 consecutive successes
- Never goes below `minChunkSize`

## Collect All Events

```typescript
const events = [];

for await (const { log } of stream.backfill({
  fromBlock: 18000000n,
  toBlock: 18001000n
})) {
  events.push(log);
}

console.log(`Found ${events.length} transfers`);
```

## With Progress Tracking

```typescript
for await (const { log, metadata } of stream.backfill({
  fromBlock: 18000000n,
  toBlock: 19000000n
})) {
  const progress = Number(metadata.toBlock - 18000000n) / Number(19000000n - 18000000n);
  console.log(`Progress: ${(progress * 100).toFixed(1)}%`);
  processEvent(log);
}
```

## Standalone EventStream

```typescript
import { EventStream } from '@voltaire/contract';

const stream = EventStream({
  provider,
  address: '0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48',
  event: {
    type: 'event',
    name: 'Transfer',
    inputs: [
      { type: 'address', name: 'from', indexed: true },
      { type: 'address', name: 'to', indexed: true },
      { type: 'uint256', name: 'value', indexed: false }
    ]
  },
  filter: {}
});

for await (const { log } of stream.backfill({ fromBlock: 18000000n, toBlock: 18001000n })) {
  console.log(log);
}
```
