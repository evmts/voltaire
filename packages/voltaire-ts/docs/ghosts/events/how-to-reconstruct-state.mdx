---
title: How to Reconstruct State from Events
description: Build application state by replaying historical events.
---

## Goal

Reconstruct current state (balances, ownership, etc.) by processing all historical events.

## Basic Pattern: Token Balances

```typescript
import { Contract } from '@voltaire/contract';

const usdc = Contract({ address: usdcAddress, abi: erc20Abi, provider });
const stream = usdc.events.Transfer({});

const balances = new Map<string, bigint>();

for await (const { log } of stream.backfill({
  fromBlock: deployBlock,
  toBlock: 'latest'
})) {
  const { from, to, value } = log.args;

  // Debit sender (skip mint events from zero address)
  if (from !== '0x0000000000000000000000000000000000000000') {
    const prev = balances.get(from) ?? 0n;
    balances.set(from, prev - value);
  }

  // Credit recipient
  const prevTo = balances.get(to) ?? 0n;
  balances.set(to, prevTo + value);
}

console.log(`Tracked ${balances.size} holders`);
```

## NFT Ownership Registry

```typescript
const nft = Contract({ address: nftAddress, abi: erc721Abi, provider });
const stream = nft.events.Transfer({});

const ownership = new Map<bigint, string>();  // tokenId -> owner

for await (const { log } of stream.backfill({ fromBlock: deployBlock, toBlock: 'latest' })) {
  const { to, tokenId } = log.args;
  ownership.set(tokenId, to);
}

// Current owner lookup
const owner = ownership.get(1234n);
```

## With Checkpointing

Persist progress to resume after interruption:

```typescript
interface Checkpoint {
  lastBlock: bigint;
  state: Map<string, bigint>;
}

async function rebuildWithCheckpoint(startCheckpoint?: Checkpoint) {
  const balances = startCheckpoint?.state ?? new Map<string, bigint>();
  const fromBlock = startCheckpoint?.lastBlock ?? deployBlock;

  let lastProcessedBlock = fromBlock;
  let eventCount = 0;

  for await (const { log, metadata } of stream.backfill({
    fromBlock,
    toBlock: 'latest'
  })) {
    const { from, to, value } = log.args;

    if (from !== '0x0000000000000000000000000000000000000000') {
      balances.set(from, (balances.get(from) ?? 0n) - value);
    }
    balances.set(to, (balances.get(to) ?? 0n) + value);

    lastProcessedBlock = log.blockNumber;

    // Checkpoint every 10k events
    if (++eventCount % 10000 === 0) {
      await saveCheckpoint({ lastBlock: lastProcessedBlock, state: balances });
    }
  }

  return balances;
}
```

## Backfill Then Watch

Keep state synced in real-time:

```typescript
const balances = new Map<string, bigint>();

function processTransfer(from: string, to: string, value: bigint) {
  if (from !== '0x0000000000000000000000000000000000000000') {
    balances.set(from, (balances.get(from) ?? 0n) - value);
  }
  balances.set(to, (balances.get(to) ?? 0n) + value);
}

// Phase 1: Historical
const currentBlock = await provider.getBlockNumber();

for await (const { log } of stream.backfill({ fromBlock: deployBlock, toBlock: currentBlock })) {
  processTransfer(log.args.from, log.args.to, log.args.value);
}

console.log('Historical sync complete');

// Phase 2: Real-time
for await (const { log } of stream.watch({ fromBlock: currentBlock })) {
  processTransfer(log.args.from, log.args.to, log.args.value);
  console.log(`Balance updated: ${log.args.to} = ${balances.get(log.args.to)}`);
}
```

## Multiple Event Types

Track complex state across event types:

```typescript
const uniswapPair = Contract({ address: pairAddress, abi: pairAbi, provider });

let reserve0 = 0n;
let reserve1 = 0n;

// Sync events update reserves
for await (const { log } of uniswapPair.events.Sync({}).backfill({ fromBlock: deployBlock, toBlock: 'latest' })) {
  reserve0 = log.args.reserve0;
  reserve1 = log.args.reserve1;
}

console.log(`Current reserves: ${reserve0} / ${reserve1}`);
```
