---
title: How to Handle Event Pagination
description: Handle large event result sets with automatic chunking and manual pagination.
---

## Goal

Process large numbers of events without hitting RPC limits.

## Automatic Chunking (Recommended)

EventStream handles pagination automatically via dynamic chunking:

```typescript
import { Contract } from '@voltaire/contract';

const usdc = Contract({ address: usdcAddress, abi: erc20Abi, provider });
const stream = usdc.events.Transfer({});

// EventStream chunks internally - no manual pagination needed
for await (const { log, metadata } of stream.backfill({
  fromBlock: 0n,
  toBlock: 19000000n
})) {
  // metadata shows current chunk progress
  console.log(`Processing chunk ${metadata.fromBlock}-${metadata.toBlock}`);
  processEvent(log);
}
```

## Custom Chunk Configuration

```typescript
for await (const { log } of stream.backfill({
  fromBlock: 0n,
  toBlock: 19000000n,
  chunkSize: 2000,      // Start with larger chunks
  minChunkSize: 100     // Don't go below 100 blocks
})) {
  processEvent(log);
}
```

## Manual Pagination

For direct RPC calls or custom logic:

```typescript
import * as EventLog from '@voltaire/primitives/EventLog';

async function getAllLogs(filter, chunkSize = 500n) {
  const allLogs = [];
  let fromBlock = filter.fromBlock;
  const toBlock = filter.toBlock;

  while (fromBlock <= toBlock) {
    const chunkEnd = fromBlock + chunkSize - 1n > toBlock
      ? toBlock
      : fromBlock + chunkSize - 1n;

    try {
      const logs = await provider.request({
        method: 'eth_getLogs',
        params: [{ ...filter, fromBlock, toBlock: chunkEnd }]
      });
      allLogs.push(...logs);
      fromBlock = chunkEnd + 1n;
    } catch (error) {
      // Reduce chunk size on "range too large"
      if (error.message?.includes('range')) {
        chunkSize = chunkSize / 2n;
        if (chunkSize < 10n) throw error;
        continue;
      }
      throw error;
    }
  }
  return allLogs;
}
```

## Cancellation

Stop pagination early with AbortSignal:

```typescript
const controller = new AbortController();

// Stop after processing 1000 events
let count = 0;

try {
  for await (const { log } of stream.backfill({
    fromBlock: 0n,
    toBlock: 19000000n,
    signal: controller.signal
  })) {
    processEvent(log);
    if (++count >= 1000) {
      controller.abort();
    }
  }
} catch (error) {
  if (error.name === 'AbortError') {
    console.log('Stopped after 1000 events');
  }
}
```

## Retry Configuration

Handle transient failures during pagination:

```typescript
for await (const { log } of stream.backfill({
  fromBlock: 0n,
  toBlock: 19000000n,
  retry: {
    maxRetries: 5,
    initialDelay: 1000,
    maxDelay: 30000
  }
})) {
  processEvent(log);
}
```
