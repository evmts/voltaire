---
title: How to Sign a UserOperation
description: Compute userOpHash and sign it for ERC-4337 smart account authorization.
---

## Overview

UserOperation signing differs from EOA transaction signing:
1. Compute `userOpHash` over the full operation + entryPoint + chainId
2. Sign the hash using account-specific logic (ECDSA, multisig, etc.)
3. Encode signature in account's expected format

## Computing userOpHash

```typescript
import { UserOperation } from '@tevm/voltaire/primitives/UserOperation';
import { ENTRYPOINT_V06 } from '@tevm/voltaire/primitives/EntryPoint';

const userOp = UserOperation.from({
  sender: smartAccountAddress,
  nonce: 0n,
  initCode: '0x',
  callData: encodedCallData,
  callGasLimit: 100000n,
  verificationGasLimit: 150000n,
  preVerificationGas: 50000n,
  maxFeePerGas: 30000000000n,
  maxPriorityFeePerGas: 1000000000n,
  paymasterAndData: '0x',
  signature: '0x', // Empty before signing
});

// Compute hash for signing
const userOpHash = UserOperation.hash(userOp, ENTRYPOINT_V06, chainId);
```

## userOpHash Formula

```
userOpHash = keccak256(
  abi.encode(
    keccak256(pack(userOp)), // Hash of packed UserOp fields
    entryPointAddress,
    chainId
  )
)
```

The packed UserOp excludes `signature` and hashes dynamic fields (`initCode`, `callData`, `paymasterAndData`).

## ECDSA Signing (Simple Account)

For accounts using single ECDSA signature:

```typescript
import { Secp256k1 } from '@tevm/voltaire/Secp256k1';
import { Hex } from '@tevm/voltaire/Hex';

// Sign the userOpHash
const signature = Secp256k1.sign(userOpHash, privateKey);

// Encode signature (65 bytes: r + s + v)
const encodedSig = Hex.concat([
  signature.r,
  signature.s,
  Hex.fromNumber(signature.recovery + 27), // v
]);

// Add signature to UserOp
const signedUserOp = {
  ...userOp,
  signature: encodedSig,
};
```

## EIP-712 Typed Signing

Many accounts use EIP-712 for better UX:

```typescript
import { EIP712 } from '@tevm/voltaire/EIP712';

const domain = {
  name: 'MySmartAccount',
  version: '1',
  chainId: chainId,
  verifyingContract: smartAccountAddress,
};

const types = {
  UserOperation: [
    { name: 'sender', type: 'address' },
    { name: 'nonce', type: 'uint256' },
    { name: 'initCodeHash', type: 'bytes32' },
    { name: 'callDataHash', type: 'bytes32' },
    // ... other fields
  ],
};

const typedHash = EIP712.hashTypedData(domain, types, userOpData);
const signature = Secp256k1.sign(typedHash, privateKey);
```

## Multisig Signing

For accounts requiring multiple signatures:

```typescript
// Collect signatures from multiple owners
const signatures = await Promise.all(
  owners.map(async (owner) => {
    const sig = await owner.signMessage(userOpHash);
    return { signer: owner.address, signature: sig };
  })
);

// Sort signatures by signer address (ascending)
signatures.sort((a, b) =>
  a.signer.toLowerCase().localeCompare(b.signer.toLowerCase())
);

// Concatenate signatures
const combinedSignature = Hex.concat(
  signatures.map(s => s.signature)
);
```

## Passkey/WebAuthn Signing

For accounts using passkeys:

```typescript
// WebAuthn assertion
const assertion = await navigator.credentials.get({
  publicKey: {
    challenge: userOpHash,
    allowCredentials: [{ id: credentialId, type: 'public-key' }],
  },
});

// Encode WebAuthn signature
const webAuthnSig = encodeWebAuthnSignature({
  authenticatorData: assertion.response.authenticatorData,
  clientDataJSON: assertion.response.clientDataJSON,
  signature: assertion.response.signature,
});
```

## Signature Validation

Accounts implement `validateUserOp` to verify signatures:

```solidity
function validateUserOp(
    UserOperation calldata userOp,
    bytes32 userOpHash,
    uint256 missingAccountFunds
) external returns (uint256 validationData);

// validationData:
// - 0: valid
// - 1: signature failure
// - packed(validAfter, validUntil, aggregator)
```

## Related

- [Create UserOperation](/ghosts/account-abstraction/how-to-create-useroperation)
- [Submit to Bundler](/ghosts/account-abstraction/how-to-submit-to-bundler)
- [Secp256k1 Reference](/crypto/secp256k1)
- [EIP-712 Reference](/crypto/eip712)
