---
title: How to Estimate L1 Data Fee on L2
description: Calculate the L1 data fee component for L2 transactions.
---

## Goal

Estimate the L1 data fee that L2 transactions pay for calldata/blob posting to L1.

## Concepts

L2 transaction fees have two components:

1. **L2 execution fee**: Gas for L2 computation (like L1)
2. **L1 data fee**: Cost to post tx data to L1 (unique to L2s)

The L1 data fee depends on:
- Transaction size (calldata bytes)
- L1 base fee
- L2's fee scalar/overhead parameters

## Example: Optimism/Base (Ecotone)

```typescript
import * as Address from '@voltaire/primitives/Address';
import * as Abi from '@voltaire/primitives/Abi';
import * as Transaction from '@voltaire/primitives/Transaction';
import * as Rlp from '@voltaire/primitives/Rlp';

// GasPriceOracle predeploy on OP Stack
const GAS_PRICE_ORACLE = Address("0x420000000000000000000000000000000000000F");

const GAS_ORACLE_ABI = Abi.from([
  "function getL1Fee(bytes memory _data) view returns (uint256)",
  "function l1BaseFee() view returns (uint256)",
  "function blobBaseFee() view returns (uint256)",
  "function baseFeeScalar() view returns (uint32)",
  "function blobBaseFeeScalar() view returns (uint32)",
]);

// Serialize transaction to get raw bytes
const tx = Transaction.EIP1559({
  chainId: 10n,
  nonce: 5n,
  maxPriorityFeePerGas: 1_000_000n,
  maxFeePerGas: 100_000_000n,
  gasLimit: 21000n,
  to: Address("0x1234567890123456789012345678901234567890"),
  value: 1_000_000_000_000_000_000n,
  data: new Uint8Array(0),
  accessList: [],
});

const serialized = Transaction.serialize(tx);

// Call getL1Fee with serialized tx
const calldata = Abi.encodeFunction(GAS_ORACLE_ABI, "getL1Fee", [serialized]);

// Result is L1 fee in wei
// const l1Fee = await provider.call({ to: GAS_PRICE_ORACLE, data: calldata });
```

## Manual Calculation (Ecotone formula)

```typescript
import * as FeeMarket from '@voltaire/primitives/FeeMarket';

/**
 * Ecotone L1 data fee formula:
 * l1Fee = (baseFeeScalar * l1BaseFee * 16 + blobBaseFeeScalar * blobBaseFee)
 *         * txCompressedSize / 16e6
 */
function calculateL1DataFee(params: {
  txBytes: Uint8Array;
  l1BaseFee: bigint;
  blobBaseFee: bigint;
  baseFeeScalar: bigint;
  blobBaseFeeScalar: bigint;
}): bigint {
  const { txBytes, l1BaseFee, blobBaseFee, baseFeeScalar, blobBaseFeeScalar } = params;

  // Estimate compressed size (~70% of original for typical txs)
  const compressedSize = BigInt(Math.ceil(txBytes.length * 0.7));

  // Ecotone formula
  const scaledL1Fee = baseFeeScalar * l1BaseFee * 16n;
  const scaledBlobFee = blobBaseFeeScalar * blobBaseFee;
  const l1Fee = (scaledL1Fee + scaledBlobFee) * compressedSize / 16_000_000n;

  return l1Fee;
}
```

## Arbitrum L1 Data Fee

```typescript
// Arbitrum NodeInterface precompile
const NODE_INTERFACE = Address("0x00000000000000000000000000000000000000C8");

const NODE_INTERFACE_ABI = Abi.from([
  "function gasEstimateL1Component(address to, bool contractCreation, bytes calldata data) view returns (uint64 gasEstimateForL1, uint256 baseFee, uint256 l1BaseFeeEstimate)",
]);

// Estimate L1 gas component for a call
const calldata = Abi.encodeFunction(NODE_INTERFACE_ABI, "gasEstimateL1Component", [
  "0x1234567890123456789012345678901234567890",
  false,
  "0x",
]);
```

## Total Fee Estimation

```typescript
import * as FeeMarket from '@voltaire/primitives/FeeMarket';
import * as Chain from '@voltaire/primitives/Chain';

async function estimateTotalFee(chainId: bigint, txData: Uint8Array) {
  const chain = Chain.fromId(chainId);

  // L2 execution fee
  const l2GasLimit = 100_000n;
  const l2GasPrice = 1_000_000n; // 0.001 gwei typical on L2
  const l2Fee = l2GasLimit * l2GasPrice;

  if (Chain.isL2(chain)) {
    // Fetch L1 fee from oracle contract
    const l1Fee = 50_000_000_000_000n; // Example: 0.00005 ETH
    return { l2Fee, l1Fee, total: l2Fee + l1Fee };
  }

  return { l2Fee, l1Fee: 0n, total: l2Fee };
}
```

## Key Points

- L1 data fee often dominates total L2 tx cost
- Post-EIP-4844 (Dencun): Blob fees are cheaper than calldata
- Check `blobBaseFee` for current blob pricing
- Fee scalars are L2-specific and can be updated by governance

## Related

- `/primitives/feemarket` - Fee calculation utilities
- `/primitives/blob` - Blob data handling
- `/ghosts/l2/how-to-submit-blob-transaction` - Blob transactions
