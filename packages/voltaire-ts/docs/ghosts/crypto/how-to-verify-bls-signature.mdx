---
title: How to Verify BLS Signature
description: Verify a BLS signature using BLS12-381 pairing check
---

## Goal

Verify a BLS signature against a public key and message using bilinear pairing.

## Example (TypeScript)

```typescript
import { bls12_381 } from '@tevm/voltaire/crypto';

async function verifyBLSSignature(
  signature: Uint8Array,   // G1 point (128 bytes)
  publicKey: Uint8Array,   // G2 point (256 bytes)
  message: Uint8Array
): Promise<boolean> {
  // Hash message to G1 point
  const messagePoint = await hashToG1(message);

  // Negate message point for pairing check
  const negatedMessage = negateG1Point(messagePoint);

  // Pairing check: e(sig, G2) * e(-H(msg), pubkey) = 1
  const pairingInput = new Uint8Array(768);
  pairingInput.set(signature, 0);
  pairingInput.set(G2_GENERATOR, 128);
  pairingInput.set(negatedMessage, 384);
  pairingInput.set(publicKey, 512);

  const output = new Uint8Array(32);
  await bls12_381.pairing(pairingInput, output);

  return output[31] === 0x01;
}

// Usage
const isValid = await verifyBLSSignature(signature, publicKey, message);
console.log(`Signature valid: ${isValid}`);
```

## Hash-to-Curve Helper

```typescript
async function hashToG1(message: Uint8Array): Promise<Uint8Array> {
  const dst = new TextEncoder().encode(
    'BLS_SIG_BLS12381G1_XMD:SHA-256_SSWU_RO_'
  );

  // Map to two field elements, then to curve points
  const point1 = new Uint8Array(128);
  const point2 = new Uint8Array(128);

  await bls12_381.mapFpToG1(hash1, point1);
  await bls12_381.mapFpToG1(hash2, point2);

  // Add points for uniform distribution
  const input = new Uint8Array([...point1, ...point2]);
  const result = new Uint8Array(128);
  await bls12_381.g1Add(input, result);

  return result;
}
```

## Related

- [BLS Signatures](/crypto/bls12-381/signatures)
- [BLS12-381 Pairing](/crypto/bls12-381/pairing)
