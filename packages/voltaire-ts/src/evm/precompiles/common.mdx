---
title: Common Precompile Types
description: Shared types and error handling for EVM precompiled contracts
---

# Common Precompile Types

Shared types, error handling, and result structures used across all precompiled contract implementations.

## Overview

The Common module provides:
- **PrecompileResult**: Standard result type with output and gas usage
- **PrecompileError**: Unified error handling for all precompiles
- **Memory Management**: Allocation and deallocation patterns

**Source**: `src/precompiles/common.zig`

## Key Types

### PrecompileResult

```zig
const precompiles = @import("precompiles");

pub const PrecompileResult = struct {
    output: []u8,
    gas_used: u64,

    pub fn deinit(self: PrecompileResult, allocator: std.mem.Allocator) void {
        allocator.free(self.output);
    }
};
```

**Fields:**
- `output`: Allocated byte slice containing precompile result
- `gas_used`: Actual gas consumed by the precompile execution

**Methods:**
- `deinit`: Frees the allocated output buffer

### PrecompileError

```zig
pub const PrecompileError = error{
    InvalidInput,
    InvalidSignature,
    InvalidPoint,
    InvalidPairing,
    OutOfGas,
    NotImplemented,
    // Keccak errors
    ExecutionError,
    StateError,
    MemoryError,
    InvalidOutputSize,
    Unknown,
} || std.mem.Allocator.Error;
```

**Error Types:**
- `InvalidInput`: Malformed or invalid input data
- `InvalidSignature`: Invalid cryptographic signature (ecrecover)
- `InvalidPoint`: Point not on curve (elliptic curve operations)
- `InvalidPairing`: Pairing check failed (BN254/BLS12-381)
- `OutOfGas`: Insufficient gas provided
- `NotImplemented`: Precompile not yet implemented
- `OutOfMemory`: Memory allocation failed

## Usage Pattern

All precompiles follow this execution pattern:

```zig
const std = @import("std");
const precompiles = @import("precompiles");
const PrecompileResult = precompiles.common.PrecompileResult;
const PrecompileError = precompiles.common.PrecompileError;

pub fn execute(
    allocator: std.mem.Allocator,
    input: []const u8,
    gas_limit: u64,
) PrecompileError!PrecompileResult {
    // 1. Check gas limit
    if (gas_limit < REQUIRED_GAS) {
        return error.OutOfGas;
    }

    // 2. Validate input
    if (input.len != EXPECTED_LENGTH) {
        return error.InvalidInput;
    }

    // 3. Allocate output
    const output = try allocator.alloc(u8, OUTPUT_SIZE);

    // 4. Perform computation
    // ... precompile logic ...

    // 5. Return result
    return PrecompileResult{
        .output = output,
        .gas_used = REQUIRED_GAS,
    };
}
```

## Examples

### Using PrecompileResult

```zig
const std = @import("std");
const precompiles = @import("precompiles");

pub fn callPrecompile() !void {
    const allocator = std.heap.page_allocator;

    // Execute precompile
    const input = &[_]u8{0x01, 0x02, 0x03};
    const result = try precompiles.sha256.execute(
        allocator,
        input,
        100000,
    );
    defer result.deinit(allocator);

    // Use result
    std.debug.print("Gas used: {}\n", .{result.gas_used});
    std.debug.print("Output: {x}\n", .{result.output});
}
```

### Error Handling

```zig
const std = @import("std");
const precompiles = @import("precompiles");

pub fn handlePrecompileErrors(
    allocator: std.mem.Allocator,
    input: []const u8,
) void {
    const result = precompiles.ecrecover.execute(
        allocator,
        input,
        3000,
    );

    if (result) |res| {
        defer res.deinit(allocator);
        // Success - use res.output
    } else |err| switch (err) {
        error.OutOfGas => {
            // Handle insufficient gas
        },
        error.InvalidInput => {
            // Handle invalid input
        },
        error.InvalidSignature => {
            // Handle signature validation failure
        },
        else => {
            // Handle other errors
        },
    }
}
```

## Memory Management

### Allocation Ownership

Precompiles allocate their output buffers. Callers must free them:

```zig
// Caller owns the result and must free it
const result = try precompile.execute(allocator, input, gas);
defer result.deinit(allocator); // MUST call deinit
```

### Input Data

Input buffers are borrowed (not owned):

```zig
// Input is const []const u8 - precompile does not free it
const input = &[_]u8{1, 2, 3};
const result = try precompile.execute(allocator, input, gas);
// input is still valid here
```

## Performance

Precompile overhead is minimal:
- Zero-copy input validation
- Single allocation for output
- No intermediate allocations
- Constant-time gas checks

## Testing

```bash
zig build test -Dtest-filter=common
```

Test coverage includes:
- Result structure creation and cleanup
- Error type conversions
- Memory leak detection
- Thread safety

## Related

- [ECRecover](/zig/precompiles/ecrecover/) - Signature recovery (0x01)
- [SHA256](/zig/precompiles/sha256/) - SHA-256 hash (0x02)
- [BN254 Add](/zig/precompiles/bn254_add/) - BN254 addition (0x06)

## References

- [EVM Precompiles](https://www.evm.codes/precompiled) - Precompile address table
- [Ethereum Yellow Paper](https://ethereum.github.io/yellowpaper/paper.pdf) - Appendix E
