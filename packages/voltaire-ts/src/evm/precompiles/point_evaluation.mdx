---
title: Point Evaluation (0x0A)
description: KZG point evaluation for EIP-4844 blob transactions
---

# Point Evaluation

KZG polynomial commitment point evaluation for EIP-4844 blob verification.

## Overview

The Point Evaluation precompile provides:
- **KZG Verification**: Verify KZG polynomial commitment proofs
- **Blob Transactions**: Core to EIP-4844 proto-danksharding
- **Trusted Setup**: Uses Ethereum KZG trusted setup ceremony
- **Fixed Input**: Requires exactly 192 bytes
- **Address**: 0x000000000000000000000000000000000000000A
- **Since**: Cancun (EIP-4844)

**Source**: `src/precompiles/point_evaluation.zig`

## Key Functions

### execute

```zig
const precompiles = @import("precompiles");

pub fn execute(
    allocator: std.mem.Allocator,
    input: []const u8,
    gas_limit: u64,
) PrecompileError!PrecompileResult
```

**Parameters:**
- `allocator`: Memory allocator for result
- `input`: Exactly 192 bytes (see format below)
- `gas_limit`: Maximum gas available

**Input Format** (192 bytes):
- Bytes 0-31: versioned_hash (commitment hash with version byte)
- Bytes 32-63: z (evaluation point, field element)
- Bytes 64-95: y (claimed evaluation value)
- Bytes 96-143: commitment (KZG commitment, 48 bytes)
- Bytes 144-191: proof (KZG proof, 48 bytes)

**Returns:** 64 bytes
- Bytes 0-31: FIELD_ELEMENTS_PER_BLOB (0x1000 = 4096)
- Bytes 32-63: BLS_MODULUS (BLS12-381 field modulus)

**Errors:** `OutOfGas`, `InvalidInput` (length ≠ 192 or verification fails)

## Gas Costs

**Fixed Cost:** 50000 gas

Constant cost regardless of input validity.

## Examples

### Verify Blob Commitment

```zig
const std = @import("std");
const precompiles = @import("precompiles");
const crypto = @import("crypto");

pub fn verifyBlob(
    allocator: std.mem.Allocator,
    commitment: []const u8,  // 48 bytes
    proof: []const u8,        // 48 bytes
    z: []const u8,            // 32 bytes
    y: []const u8,            // 32 bytes
) !bool {
    // Initialize KZG trusted setup (once)
    try crypto.kzg_setup.init();
    defer crypto.kzg_setup.deinit(allocator);

    // Compute versioned hash
    var versioned_hash: [32]u8 = undefined;
    try crypto.keccak_asm.keccak256(commitment, &versioned_hash);
    versioned_hash[0] = 0x01; // EIP-4844 version byte

    // Build input
    var input: [192]u8 = undefined;
    @memcpy(input[0..32], &versioned_hash);
    @memcpy(input[32..64], z);
    @memcpy(input[64..96], y);
    @memcpy(input[96..144], commitment);
    @memcpy(input[144..192], proof);

    // Verify
    const result = precompiles.point_evaluation.execute(
        allocator,
        &input,
        50000,
    ) catch {
        return false; // Invalid proof
    };
    defer result.deinit(allocator);

    // Check for success output
    return result.output[31] != 0;
}
```

### Invalid Hash Detection

```zig
const std = @import("std");
const precompiles = @import("precompiles");
const crypto = @import("crypto");

test "point_evaluation wrong versioned hash" {
    const allocator = std.testing.allocator;

    try crypto.kzg_setup.init();
    defer crypto.kzg_setup.deinit(allocator);

    var input: [192]u8 = [_]u8{0} ** 192;

    // Set wrong versioned hash
    input[0] = 0xFF;

    // Valid commitment (point at infinity)
    input[96] = 0xc0;

    // Valid proof (point at infinity)
    input[144] = 0xc0;

    const result = precompiles.point_evaluation.execute(
        allocator,
        &input,
        50000,
    );

    try std.testing.expectError(error.InvalidInput, result);
}
```

### Parse Output Constants

```zig
const std = @import("std");
const precompiles = @import("precompiles");
const crypto = @import("crypto");

test "point_evaluation output format" {
    const allocator = std.testing.allocator;

    try crypto.kzg_setup.init();
    defer crypto.kzg_setup.deinit(allocator);

    var input: [192]u8 = [_]u8{0} ** 192;

    // Valid commitment and proof (point at infinity)
    input[96] = 0xc0;
    input[144] = 0xc0;

    // Compute correct versioned hash
    var hash: [32]u8 = undefined;
    try crypto.keccak_asm.keccak256(input[96..144], &hash);
    hash[0] = 0x01;
    @memcpy(input[0..32], &hash);

    const result = try precompiles.point_evaluation.execute(
        allocator,
        &input,
        50000,
    );
    defer result.deinit(allocator);

    // Extract FIELD_ELEMENTS_PER_BLOB
    const field_elements = std.mem.readInt(u256, result.output[0..32], .big);
    try std.testing.expectEqual(0x1000, field_elements); // 4096

    // Extract BLS_MODULUS
    const expected_modulus = [_]u8{
        0x73, 0xed, 0xa7, 0x53, 0x29, 0x9d, 0x7d, 0x48,
        0x33, 0x39, 0xd8, 0x08, 0x09, 0xa1, 0xd8, 0x05,
        0x53, 0xbd, 0xa4, 0x02, 0xff, 0xfe, 0x5b, 0xfe,
        0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x01,
    };
    try std.testing.expectEqualSlices(
        u8,
        &expected_modulus,
        result.output[32..64],
    );
}
```

## KZG Commitments

**Polynomial Commitment Scheme:**
- Commit to polynomial: C = commit(f(x))
- Prove evaluation: π = prove(f, z, y, C)
- Verify: e(C - [y], [1]) = e(π, [τ - z])

**EIP-4844 Usage:**
- Each blob contains 4096 field elements
- Blob committed using KZG
- Versioned hash identifies commitment
- Point evaluation verifies blob availability

## Algorithm

1. **Parse Input**: Extract versioned_hash, z, y, commitment, proof
2. **Verify Versioned Hash**:
   - Compute keccak256(commitment)
   - Set version byte to 0x01
   - Compare with provided versioned_hash
3. **Verify KZG Proof**:
   - Check commitment is valid BLS12-381 G1 point
   - Check proof is valid BLS12-381 G1 point
   - Perform pairing check: e(C - [y], [1]) = e(π, [τ - z])
4. **Return**:
   - Success: [FIELD_ELEMENTS_PER_BLOB, BLS_MODULUS]
   - Failure: All zeros

## BLS12-381 Parameters

**Field Modulus (p):**
```
0x73eda753299d7d483339d80809a1d80553bda402fffe5bfeffffffff00000001
```

**Curve Order (r):**
```
0x73eda753299d7d483339d80809a1d80553bda402fffe5bfeffffffff00000001
```

**Field Elements Per Blob:** 4096

## Performance

**Native (ReleaseFast)**: ~3-7 ms
**WASM (ReleaseFast)**: ~10-20 ms

Uses c-kzg-4844 library with trusted setup loaded at initialization.

## Testing

```bash
zig build test -Dtest-filter=point_evaluation
```

Test coverage includes:
- Valid proof verification
- Invalid proof rejection
- Versioned hash validation
- Wrong version byte
- Invalid commitment format
- Gas cost verification
- EIP-4844 test vectors

## Related

- [BLS12-381 Pairing](/zig/precompiles/bls12_pairing/) - BLS pairing (0x11)
- [KZG](/zig/crypto/kzg/) - KZG commitments
- [Blob](/zig/primitives/blob/) - Blob type

## References

- [EIP-4844](https://eips.ethereum.org/EIPS/eip-4844) - Shard Blob Transactions
- [KZG Ceremony](https://ceremony.ethereum.org/) - Trusted setup
- [c-kzg-4844](https://github.com/ethereum/c-kzg-4844) - Reference implementation
- [KZG Paper](https://www.iacr.org/archive/asiacrypt2010/6477178/6477178.pdf) - Original KZG10 scheme
- [Proto-Danksharding](https://notes.ethereum.org/@vbuterin/proto_danksharding_faq) - EIP-4844 FAQ
