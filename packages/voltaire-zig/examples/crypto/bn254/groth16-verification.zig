const std = @import("std");
const crypto = @import("crypto");

const G1 = crypto.bn254.G1;
const G2 = crypto.bn254.G2;
const Fr = crypto.bn254.Fr;
const FpMont = crypto.bn254.FpMont;
const Fp2Mont = crypto.bn254.Fp2Mont;
const pairing = crypto.bn254.pairing.pairing;

/// Groth16 zkSNARK Verification
///
/// Demonstrates how Groth16 proofs are verified using BN254 pairings.
/// Groth16 is the most widely used zkSNARK system (Tornado Cash, zkSync, etc.)
///
/// Verification equation:
/// e(A, B) = e(α, β) × e(L, γ) × e(C, δ)
///
/// Where:
/// - (A, B, C) are the proof elements
/// - (α, β, γ, δ) are the verification key (public parameters)
/// - L is computed from public inputs
pub fn main() !void {
    const stdout = std.io.getStdOut().writer();

    try stdout.print("=== Groth16 zkSNARK Verification ===\n\n", .{});

    // Initialize generators
    const g1_gen = G1{
        .x = FpMont.init(1),
        .y = FpMont.init(2),
        .z = FpMont.init(1),
    };

    const g2_gen = G2{
        .x = Fp2Mont.initFromInt(
            0x1800deef121f1e76426a00665e5c4479674322d4f75edadd46debd5cd992f6ed,
            0x198e9393920d483a7260bfb731fb5d25f1aa493335a9e71297e485b7aef312c2,
        ),
        .y = Fp2Mont.initFromInt(
            0x12c85ea5db8c6deb4aab71808dcb408fe3d1e7690c43d37b4ce6cc0166fa7daa,
            0x090689d0585ff075ec9e99ad690c3395bc4b313370b38ef355acdadcd122975b,
        ),
        .z = Fp2Mont.initFromInt(1, 0),
    };

    // 1. Setup - Verification Key (Public Parameters)
    try stdout.print("1. Verification Key Setup\n", .{});
    try stdout.print("{s}\n", .{"-" ** 40});

    // In real Groth16, these come from trusted setup ceremony
    const alpha_scalar = Fr.init(12345);
    const beta_scalar = Fr.init(67890);
    const gamma_scalar = Fr.init(11111);
    const delta_scalar = Fr.init(22222);

    // Verification key elements
    const vk_alpha = try g1_gen.mul(&alpha_scalar); // α in G1
    const vk_beta = g2_gen.mul(&beta_scalar); // β in G2
    const vk_gamma = g2_gen.mul(&gamma_scalar); // γ in G2
    const vk_delta = g2_gen.mul(&delta_scalar); // δ in G2

    try stdout.print("Verification key generated:\n", .{});
    try stdout.print("- α (G1 point)\n", .{});
    try stdout.print("- β (G2 point)\n", .{});
    try stdout.print("- γ (G2 point)\n", .{});
    try stdout.print("- δ (G2 point)\n", .{});
    try stdout.print("\nThese would come from trusted setup in production\n\n", .{});

    // 2. Public Inputs
    try stdout.print("2. Public Inputs\n", .{});
    try stdout.print("{s}\n", .{"-" ** 40});

    // In a real zkSNARK, these are the public values
    const public_input1 = Fr.init(42);
    const public_input2 = Fr.init(99);

    try stdout.print("Public input 1: 42\n", .{});
    try stdout.print("Public input 2: 99\n", .{});

    // IC (Input Commitment) points from verification key
    const ic0_scalar = Fr.init(1000);
    const ic1_scalar = Fr.init(2000);
    const ic2_scalar = Fr.init(3000);

    const IC0 = try g1_gen.mul(&ic0_scalar); // Constant offset
    const IC1 = try g1_gen.mul(&ic1_scalar); // Coefficient for input 1
    const IC2 = try g1_gen.mul(&ic2_scalar); // Coefficient for input 2

    // Compute L = IC[0] + Σ(public_input[i] × IC[i])
    const term1 = try IC1.mul(&public_input1);
    const term2 = try IC2.mul(&public_input2);
    const L = IC0.add(&term1).add(&term2);

    try stdout.print("\nComputed L = IC[0] + x₁×IC[1] + x₂×IC[2]\n", .{});
    try stdout.print("L encodes the public inputs in G1\n\n", .{});

    // 3. Proof Elements
    try stdout.print("3. Proof Generation (Simulated)\n", .{});
    try stdout.print("{s}\n", .{"-" ** 40});

    // In real Groth16, prover generates these based on witness
    const r_scalar = Fr.init(777);

    // Construct proof elements
    const proof_A = try g1_gen.mul(&alpha_scalar); // A in G1
    const proof_B = g2_gen.mul(&beta_scalar); // B in G2
    const proof_C = try g1_gen.mul(&r_scalar); // C in G1

    try stdout.print("Proof elements:\n", .{});
    try stdout.print("- A (G1 point)\n", .{});
    try stdout.print("- B (G2 point)\n", .{});
    try stdout.print("- C (G1 point)\n", .{});
    try stdout.print("\nThese would be generated by prover with witness\n\n", .{});

    // 4. Verification Equation
    try stdout.print("4. Verification Equation\n", .{});
    try stdout.print("{s}\n", .{"-" ** 40});

    try stdout.print("Checking: e(A, B) = e(α, β) × e(L, γ) × e(C, δ)\n", .{});
    try stdout.print("Using pairing computation in Fp12\n\n", .{});

    // Convert to affine for pairing
    const proof_A_affine = try proof_A.toAffine();
    const proof_B_affine = proof_B.toAffine();
    const proof_C_affine = try proof_C.toAffine();
    const vk_alpha_affine = try vk_alpha.toAffine();
    const vk_beta_affine = vk_beta.toAffine();
    const vk_gamma_affine = vk_gamma.toAffine();
    const vk_delta_affine = vk_delta.toAffine();
    const L_affine = try L.toAffine();

    // Compute pairings
    const pair_AB = try pairing(&proof_A_affine, &proof_B_affine);
    const pair_alpha_beta = try pairing(&vk_alpha_affine, &vk_beta_affine);
    const pair_L_gamma = try pairing(&L_affine, &vk_gamma_affine);
    const pair_C_delta = try pairing(&proof_C_affine, &vk_delta_affine);

    // Compute right-hand side: e(α, β) × e(L, γ) × e(C, δ)
    const rhs = pair_alpha_beta.mul(&pair_L_gamma).mul(&pair_C_delta);

    // Check if e(A, B) = rhs
    const is_valid = pair_AB.equal(&rhs);

    try stdout.print("Verification result: {s}\n", .{if (is_valid) "VALID ✓" else "INVALID ✗"});
    try stdout.print("\nNote: This simplified example may not pass due to\n", .{});
    try stdout.print("not implementing full Groth16 proof generation.\n\n", .{});

    // 5. Breaking Down the Verification
    try stdout.print("5. Understanding the Verification\n", .{});
    try stdout.print("{s}\n", .{"-" ** 40});

    try stdout.print("Each pairing term has a purpose:\n", .{});
    try stdout.print("- e(A, B): Main proof commitment\n", .{});
    try stdout.print("- e(α, β): Verifies proof structure (from trusted setup)\n", .{});
    try stdout.print("- e(L, γ): Binds public inputs to proof\n", .{});
    try stdout.print("- e(C, δ): Additional proof element for soundness\n\n", .{});

    try stdout.print("The equation ensures:\n", .{});
    try stdout.print("1. Prover knows a valid witness\n", .{});
    try stdout.print("2. Witness satisfies the circuit constraints\n", .{});
    try stdout.print("3. Public inputs are correctly incorporated\n\n", .{});

    // 6. Security Properties
    try stdout.print("6. Groth16 Security Properties\n", .{});
    try stdout.print("{s}\n", .{"-" ** 40});

    try stdout.print("Completeness: Valid proofs always verify\n", .{});
    try stdout.print("Soundness: Invalid proofs fail (with high probability)\n", .{});
    try stdout.print("Zero-knowledge: Proof reveals nothing about witness\n\n", .{});

    // 7. Real-world Usage Pattern
    try stdout.print("7. Real-world Usage Pattern\n", .{});
    try stdout.print("{s}\n", .{"-" ** 40});

    try stdout.print("Tornado Cash example:\n", .{});
    try stdout.print("Public inputs:\n", .{});
    try stdout.print("  - Merkle root (proves deposit exists)\n", .{});
    try stdout.print("  - Nullifier hash (prevents double-spend)\n", .{});
    try stdout.print("  - Recipient address\n", .{});
    try stdout.print("  - Relayer address\n", .{});
    try stdout.print("  - Fee amount\n", .{});
    try stdout.print("\nWitness (private):\n", .{});
    try stdout.print("  - Secret value\n", .{});
    try stdout.print("  - Nullifier\n", .{});
    try stdout.print("  - Merkle path\n\n", .{});

    try stdout.print("The proof proves: \"I know a secret that corresponds to\n", .{});
    try stdout.print("a deposit in the Merkle tree, without revealing which one\"\n\n", .{});

    // 8. Gas Cost Analysis
    try stdout.print("8. Gas Cost (EIP-1108 Istanbul)\n", .{});
    try stdout.print("{s}\n", .{"-" ** 40});

    const pairing_base_gas = 45000;
    const pairing_per_pair_gas = 34000;
    const num_pairs = 4;

    const total_gas = pairing_base_gas + (num_pairs * pairing_per_pair_gas);

    try stdout.print("Base cost: {d} gas\n", .{pairing_base_gas});
    try stdout.print("Per-pair cost: {d} gas × {d} pairs\n", .{ pairing_per_pair_gas, num_pairs });
    try stdout.print("Total: {d} gas\n", .{total_gas});
    try stdout.print("\nThis makes zkSNARK verification affordable on Ethereum!\n\n", .{});

    // 9. Verification Key Structure
    try stdout.print("9. Verification Key Structure\n", .{});
    try stdout.print("{s}\n", .{"-" ** 40});

    try stdout.print("On-chain verification key contains:\n", .{});
    try stdout.print("- α (G1): 64 bytes\n", .{});
    try stdout.print("- β (G2): 128 bytes\n", .{});
    try stdout.print("- γ (G2): 128 bytes\n", .{});
    try stdout.print("- δ (G2): 128 bytes\n", .{});
    try stdout.print("- IC[] (G1 array): 64 bytes × (num_public_inputs + 1)\n", .{});
    try stdout.print("\nTotal for 2 public inputs: 576 bytes\n\n", .{});

    try stdout.print("=== Complete ===\n", .{});
    try stdout.print("\nKey Takeaways:\n", .{});
    try stdout.print("- Groth16 uses 4 pairings for verification\n", .{});
    try stdout.print("- Constant proof size (3 group elements)\n", .{});
    try stdout.print("- Fast verification (~182k gas on Ethereum)\n", .{});
    try stdout.print("- Requires trusted setup per circuit\n", .{});
    try stdout.print("- Most widely deployed zkSNARK (Tornado, zkSync, Aztec)\n", .{});
}
