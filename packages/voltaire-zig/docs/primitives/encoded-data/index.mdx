---
title: "EncodedData"
description: "ABI-encoded hex data"
---

# EncodedData

Branded hex string representing ABI-encoded data. Used for function calls, constructor arguments, and custom error data.

## Type

```zig
const primitives = @import("primitives");
// EncodedData is represented as hex (0x-prefixed) when serialized.
// Use primitives.Hex for hex/bytes conversion and AbiEncoding for calldata.
```

## Construction

```zig
const Hex = @import("primitives").Hex;
const allocator = std.testing.allocator;
const data = try Hex.hexToBytes(allocator, "0x00000001");
defer allocator.free(data);

// From bytes to hex
const hex = try Hex.bytesToHex(allocator, data);
defer allocator.free(hex);
```

## Methods

- `Hex.hexToBytes(allocator, hex)` - Hex → bytes
- `Hex.bytesToHex(allocator, bytes)` - Bytes → hex
- Prefer fixed-size helpers when possible: `Hex.hexToBytesFixed`, `Hex.bytesToHexFixed`

## Example

```zig
const Abi = @import("primitives").AbiEncoding;
const primitives = @import("primitives");
const func = Abi.FunctionDefinition{
    .name = "transfer",
    .inputs = &[_]Abi.AbiType{ .address, .uint256 },
    .outputs = &[_]Abi.AbiType{},
    .state_mutability = .nonpayable,
};
const to = try primitives.Address.fromHex("0x0000000000000000000000000000000000000000");
const args = [_]Abi.AbiValue{ Abi.addressValue(to), Abi.uint256Value(1) };
const calldata = try func.encode_params(std.testing.allocator, &args);
defer std.testing.allocator.free(calldata);
```
