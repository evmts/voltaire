title: ERC-1155
description: ERC-1155 multi-token standard interface
---

# ERC-1155

ERC-1155 is a multi-token standard supporting both fungible and non-fungible tokens in a single contract. It enables efficient batch operations.

<Tip>
Zig uses ABI helpers to build calldata and decode results. Define the function signature with `primitives.AbiEncoding.FunctionDefinition` and use `EventSignature`/`EventLog` for events.
</Tip>

## Function Selectors

```zig
const std = @import("std");
const primitives = @import("primitives");
const Abi = primitives.AbiEncoding;

fn selector(allocator: std.mem.Allocator, name: []const u8, inputs: []const Abi.AbiType) ![4]u8 {
    const f = Abi.FunctionDefinition{
        .name = name,
        .inputs = inputs,
        .outputs = &[_]Abi.AbiType{},
        .state_mutability = .nonpayable,
    };
    return f.get_selector(allocator);
}

pub fn main() !void {
    const gpa = std.heap.page_allocator;
    _ = try selector(gpa, "balanceOf", &[_]Abi.AbiType{ .address, .uint256 });         // 0x00fdd58e
    _ = try selector(gpa, "balanceOfBatch", &[_]Abi.AbiType{ .@"address[]", .@"uint256[]" }); // 0x4e1273f4
    _ = try selector(gpa, "setApprovalForAll", &[_]Abi.AbiType{ .address, .bool });     // 0xa22cb465
    _ = try selector(gpa, "isApprovedForAll", &[_]Abi.AbiType{ .address, .address });   // 0xe985e9c5
    _ = try selector(gpa, "safeTransferFrom", &[_]Abi.AbiType{ .address, .address, .uint256, .uint256, .bytes }); // 0xf242432a
    _ = try selector(gpa, "safeBatchTransferFrom", &[_]Abi.AbiType{ .address, .address, .@"uint256[]", .@"uint256[]", .bytes }); // 0x2eb2c2d6
    _ = try selector(gpa, "uri", &[_]Abi.AbiType{ .uint256 });                           // 0x0e89341c
}
```

## Event Signatures

```zig
const EventSignature = @import("primitives").EventSignature;
const TRANSFER_SINGLE = EventSignature.fromSignature("TransferSingle(address,address,address,uint256,uint256)");
const TRANSFER_BATCH  = EventSignature.fromSignature("TransferBatch(address,address,address,uint256[],uint256[])");
const APPROVAL_FORALL = EventSignature.fromSignature("ApprovalForAll(address,address,bool)");
const URI_TOPIC       = EventSignature.fromSignature("URI(string,uint256)");
```

## Encoding Calldata

### balanceOf

```zig
const primitives = @import("primitives");
const Abi = primitives.AbiEncoding;

pub fn encodeBalanceOf(allocator: std.mem.Allocator, account_hex: []const u8, id: u256) ![]u8 {
    const account = try primitives.Address.fromHex(account_hex);
    const func = Abi.FunctionDefinition{
        .name = "balanceOf",
        .inputs = &[_]Abi.AbiType{ .address, .uint256 },
        .outputs = &[_]Abi.AbiType{ .uint256 },
        .state_mutability = .view,
    };
    const args = [_]Abi.AbiValue{ Abi.addressValue(account), Abi.uint256_value(id) };
    return func.encode_params(allocator, &args);
}
```

### safeTransferFrom

```zig
pub fn encodeSafeTransferFrom(
    allocator: std.mem.Allocator,
    from_hex: []const u8,
    to_hex: []const u8,
    id: u256,
    amount: u256,
    data: []const u8, // callback data
) ![]u8 {
    const from = try primitives.Address.fromHex(from_hex);
    const to = try primitives.Address.fromHex(to_hex);
    const func = Abi.FunctionDefinition{
        .name = "safeTransferFrom",
        .inputs = &[_]Abi.AbiType{ .address, .address, .uint256, .uint256, .bytes },
        .outputs = &[_]Abi.AbiType{},
        .state_mutability = .nonpayable,
    };
    const args = [_]Abi.AbiValue{
        Abi.addressValue(from),
        Abi.addressValue(to),
        Abi.uint256_value(id),
        Abi.uint256_value(amount),
        Abi.bytesValue(data),
    };
    return func.encode_params(allocator, &args);
}
```

### setApprovalForAll

```zig
pub fn encodeSetApprovalForAll(allocator: std.mem.Allocator, operator_hex: []const u8, approved: bool) ![]u8 {
    const operator = try primitives.Address.fromHex(operator_hex);
    const func = Abi.FunctionDefinition{
        .name = "setApprovalForAll",
        .inputs = &[_]Abi.AbiType{ .address, .bool },
        .outputs = &[_]Abi.AbiType{},
        .state_mutability = .nonpayable,
    };
    const args = [_]Abi.AbiValue{ Abi.addressValue(operator), Abi.boolValue(approved) };
    return func.encode_params(allocator, &args);
}
```

### isApprovedForAll

```zig
pub fn encodeIsApprovedForAll(allocator: std.mem.Allocator, account_hex: []const u8, operator_hex: []const u8) ![]u8 {
    const account = try primitives.Address.fromHex(account_hex);
    const operator = try primitives.Address.fromHex(operator_hex);
    const func = Abi.FunctionDefinition{
        .name = "isApprovedForAll",
        .inputs = &[_]Abi.AbiType{ .address, .address },
        .outputs = &[_]Abi.AbiType{ .bool },
        .state_mutability = .view,
    };
    const args = [_]Abi.AbiValue{ Abi.addressValue(account), Abi.addressValue(operator) };
    return func.encode_params(allocator, &args);
}
```

### uri

```zig
pub fn encodeURI(allocator: std.mem.Allocator, id: u256) ![]u8 {
    const func = Abi.FunctionDefinition{
        .name = "uri",
        .inputs = &[_]Abi.AbiType{ .uint256 },
        .outputs = &[_]Abi.AbiType{ .string },
        .state_mutability = .view,
    };
    const args = [_]Abi.AbiValue{ Abi.uint256_value(id) };
    return func.encode_params(allocator, &args);
}
```

## Decoding Events

### TransferSingle Event

```zig
const primitives = @import("primitives");
const EventLog = primitives.EventLog;

const TransferSingleSig = EventLog.EventSignature{
    .name = "TransferSingle",
    .inputs = &[_]EventLog.EventInput{
        .{ .name = "operator", .type = .address, .indexed = true },
        .{ .name = "from", .type = .address, .indexed = true },
        .{ .name = "to", .type = .address, .indexed = true },
        .{ .name = "id", .type = .uint256, .indexed = false },
        .{ .name = "value", .type = .uint256, .indexed = false },
    },
};
```

### ApprovalForAll Event

```zig
const ApprovalForAllSig = EventLog.EventSignature{
    .name = "ApprovalForAll",
    .inputs = &[_]EventLog.EventInput{
        .{ .name = "account", .type = .address, .indexed = true },
        .{ .name = "operator", .type = .address, .indexed = true },
        .{ .name = "approved", .type = .bool, .indexed = false },
    },
};
```

## Complete Example

```zig
// Encode common calls and send via your HTTP client
const bal_call = try encodeBalanceOf(gpa, "0x...", 1);
const xfer_call = try encodeSafeTransferFrom(gpa, "0xFROM", "0xTO", 1, 10, &[_]u8{});
const uri_call = try encodeURI(gpa, 1);
// POST these as eth_call/eth_sendTransaction payloads to your JSON-RPC endpoint.
```

## Batch Operations

ERC-1155's key advantage is efficient batch transfers:

```zig
// Single transaction for multiple tokens using safeBatchTransferFrom
// Build dynamic arrays for ids and amounts:
// const ids: []u256 = ...; const amounts: []u256 = ...;
// Use Abi.AbiValue{ .@"uint256[]" = &ids } and similar for amounts,
// then call encode_params with inputs [address,address,uint256[],uint256[],bytes].
```

## References

- [EIP-1155: Multi Token Standard](https://eips.ethereum.org/EIPS/eip-1155)
- [ERC-165: Interface Detection](/standards/erc165)
