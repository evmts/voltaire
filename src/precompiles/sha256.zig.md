# Review: sha256.zig

## Overview
Implements the SHA256 precompile (0x02) which computes SHA-256 hash of arbitrary input data. This is one of the four original precompiles available since Frontier.

## Code Quality

### Strengths
- Clean, straightforward implementation
- Correct gas calculation with proper rounding
- Good test coverage including known test vectors
- Proper memory management
- Follows Zig naming conventions
- Uses hardware-accelerated SHA256 implementation

### Issues
- **Line 3**: Hardcoded assumption of single thread `SHA256_Accel(1)` - not documented
- No validation that gas calculation doesn't overflow
- No documentation of input/output format
- No maximum input size check

## Completeness

### Complete ✓
- Gas constants (BASE=60, PER_WORD=12) match Ethereum spec
- Input handling (any length supported)
- Output format (always 32 bytes)
- Edge cases (empty input, large input)

### Incomplete/TODOs
- No TODOs found
- Missing: Documentation of why SHA256_Accel(1) is used
- Missing: Maximum input size constant (though u64 size limit is implicit)

## Test Coverage

### Excellent Coverage
- Empty input with known hash (lines 35-52)
- Gas calculation for 1, 2 words (lines 54-76)
- Partial word rounding (lines 78-88)
- Out of gas / exact gas (lines 90-112)
- Gas constants verification (lines 114-119)
- Output size verification (lines 121-130)
- Large input (1000 bytes) (lines 132-143)
- Known test vector "abc" (lines 145-161)

### Missing Test Cases
- No test for maximum input size
- No test for gas calculation overflow (theoretical)
- No test vectors from official Ethereum test suite
- No test comparing against std.crypto.hash.sha2.Sha256
- No test for input length = u64 max (overflow check)

## Gas Calculation

### Formula
```
num_words = (input.len + 31) / 32
gas_cost = BASE_GAS + PER_WORD_GAS * num_words
```

### Verification
Per Ethereum Yellow Paper Appendix E:
- BASE_GAS = 60 ✓
- PER_WORD_GAS = 12 ✓
- Word size = 32 bytes ✓
- Rounding up partial words ✓

### Test Cases Verified
| Input Size | Words | Expected Gas | Test Line |
|------------|-------|--------------|-----------|
| 0 bytes    | 0     | 60           | Implicit in line 39 |
| 32 bytes   | 1     | 72           | Line 62 |
| 64 bytes   | 2     | 84           | Line 74 |
| 33 bytes   | 2     | 84           | Line 86 |
| 1000 bytes | 32    | 444          | Line 141 |

All verified correct ✓

### Potential Issues
- No check for overflow when `num_words` is large
- No check for gas_limit = u64::MAX edge case
- Integer overflow possible if input.len = u64::MAX

## Issues Found

### Medium Priority
1. **No Input Size Limit**: While practically limited by memory, should document max size
   - Ethereum clients typically limit to ~32MB
   - Should add test for reasonable maximum

2. **Undocumented SHA256_Accel Parameter**: Line 3 uses `SHA256_Accel(1)`
   - What does the parameter mean?
   - Why 1? Why not 0 or 2?
   - Should be documented or use named constant

3. **No Overflow Protection**: Gas calculation could theoretically overflow
   ```zig
   // Line 17-18 could overflow if input.len is huge
   const num_words = (input.len + 31) / 32;
   const gas_cost = BASE_GAS + PER_WORD_GAS * num_words;
   ```
   Should use checked arithmetic:
   ```zig
   const num_words = (input.len + 31) / 32;
   const word_gas = std.math.mul(u64, PER_WORD_GAS, num_words) catch return error.OutOfGas;
   const gas_cost = std.math.add(u64, BASE_GAS, word_gas) catch return error.OutOfGas;
   ```

### Low Priority
4. **Missing Test Vector Source**: Line 145 test uses "abc" but no citation
   - Should reference: NIST FIPS 180-4 test vectors
   - Should add more official test vectors

5. **No Comparison Test**: Should verify our SHA256 matches std lib
   ```zig
   test "sha256 - matches std.crypto" {
       const std_sha = std.crypto.hash.sha2.Sha256;
       // Compare outputs
   }
   ```

6. **Magic Number**: Line 140 uses hardcoded 1000 bytes
   - Should use named constant: `const LARGE_INPUT_SIZE = 1000;`

## Recommendations

### High Priority
1. **Add overflow protection**:
   ```zig
   pub fn execute(
       allocator: std.mem.Allocator,
       input: []const u8,
       gas_limit: u64,
   ) PrecompileError!PrecompileResult {
       const num_words = (input.len + 31) / 32;
       const word_gas = std.math.mul(u64, PER_WORD_GAS, num_words)
           catch return error.OutOfGas;
       const gas_cost = std.math.add(u64, BASE_GAS, word_gas)
           catch return error.OutOfGas;

       if (gas_limit < gas_cost) {
           return error.OutOfGas;
       }
       // ... rest of implementation
   }
   ```

2. **Document SHA256_Accel parameter**:
   ```zig
   // SHA256_Accel(1) - Single-threaded hardware-accelerated SHA256
   // Parameter is thread count for parallel hashing (we use 1 for determinism)
   const SHA256 = crypto.SHA256_Accel.SHA256_Accel(1);
   ```

3. **Add overflow test**:
   ```zig
   test "sha256 - gas calculation overflow protection" {
       const testing = std.testing;
       const allocator = testing.allocator;

       // This would overflow u64 in gas calculation
       const huge_size = std.math.maxInt(usize);
       const mock_input = &[_]u8{}; // Can't actually allocate this

       // Should handle gracefully
       // (Implementation detail: may need to check in gas calc before multiply)
   }
   ```

### Medium Priority
4. **Add official test vectors**:
   ```zig
   test "sha256 - NIST test vector 1" {
       // From: NIST FIPS 180-4
       // Input: "" (empty)
       // Output: e3b0c442...
   }

   test "sha256 - NIST test vector 2" {
       // From: NIST FIPS 180-4
       // Input: "abc"
       // Output: ba7816bf...
   }

   test "sha256 - ethereum test vector" {
       // From: ethereum/tests
       // Should test actual precompile format
   }
   ```

5. **Add maximum size test**:
   ```zig
   test "sha256 - reasonable maximum input" {
       const testing = std.testing;
       const allocator = testing.allocator;

       const MAX_REASONABLE_INPUT = 32 * 1024 * 1024; // 32MB
       const input = try allocator.alloc(u8, MAX_REASONABLE_INPUT);
       defer allocator.free(input);

       const result = try execute(allocator, input, std.math.maxInt(u64));
       defer result.deinit(allocator);

       try testing.expectEqual(@as(usize, 32), result.output.len);
   }
   ```

6. **Add comparison test**:
   ```zig
   test "sha256 - matches std.crypto" {
       const testing = std.testing;
       const allocator = testing.allocator;
       const std_sha = std.crypto.hash.sha2.Sha256;

       const input = "test input data";

       // Our implementation
       const result = try execute(allocator, input, 100000);
       defer result.deinit(allocator);

       // Std library
       var expected: [32]u8 = undefined;
       std_sha.hash(input, &expected, .{});

       try testing.expectEqualSlices(u8, &expected, result.output);
   }
   ```

### Low Priority
7. **Add documentation**:
   ```zig
   /// 0x02: SHA256 - SHA-256 hash function
   ///
   /// Computes the SHA-256 cryptographic hash of the input.
   ///
   /// Gas cost: 60 + 12 * (num_words), where num_words = ceil(input.len / 32)
   ///
   /// Input: Arbitrary length byte array
   /// Output: 32-byte hash
   ///
   /// Available since: Frontier (EIP-0)
   ///
   /// References:
   /// - NIST FIPS 180-4: https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf
   /// - Ethereum Yellow Paper: Appendix E
   pub fn execute(...) { ... }
   ```

## Ethereum Specification Compliance

### Fully Compliant ✓
- Gas costs match Yellow Paper exactly
- Input handling correct (any length)
- Output format correct (32 bytes)
- Rounding behavior correct (rounds up partial words)
- Available since Frontier ✓

### Verification Against Spec
| Requirement | Status | Evidence |
|-------------|--------|----------|
| BASE_GAS = 60 | ✓ | Line 8 |
| PER_WORD_GAS = 12 | ✓ | Line 9 |
| Output = 32 bytes | ✓ | Line 24 |
| Rounds up words | ✓ | Line 17, test line 78 |
| Empty input works | ✓ | Test line 35 |

### References
- Ethereum Yellow Paper: Appendix E.1
- EIP-0 (implicit): Original precompiles
- NIST FIPS 180-4: SHA-256 specification

## Security Concerns

### None Critical
- SHA-256 is cryptographically secure hash function
- No timing attack concerns (output is deterministic, non-secret)
- No input validation needed (all inputs valid)
- Hardware acceleration safe (deterministic)

### Low Priority
1. **DoS via Large Input**: Attacker could submit huge input
   - Mitigated by gas cost (prohibitively expensive)
   - 32MB input costs ~12,000,000 gas
   - At 30M gas limit, ~80MB max per block

2. **Memory Allocation**: Large inputs require memory
   - Bounded by gas limit
   - Could add reasonable maximum (e.g., 100MB)

## Code Smells

### None Significant
- Code is clean and readable
- Good separation of concerns
- Tests are well-organized
- No premature optimization

### Minor
- Hardcoded `1` in SHA256_Accel initialization
- Magic number 1000 in test (line 136)
- No named constant for HASH_OUTPUT_SIZE (32)

## Benchmark Review (sha256.bench.zig)

### Coverage ✓
- Empty input (line 7)
- Small input - 4 bytes (line 14)
- Single word - 32 bytes (line 21)
- Two words - 64 bytes (line 28)
- Large - 1KB (line 35)
- Very large - 64KB (line 42)
- Known test vector "abc" (line 49)

### Issues
- Same issue as ecrecover: silent `catch unreachable`
- Lines 9, 16, 23, 30, 37, 44, 51 assume success
- Lines 66-68: Outdated zbench API?

### Strengths
- Good size progression (4, 32, 64, 1024, 65536 bytes)
- Tests realistic scenarios
- Includes edge cases (empty, very large)

### Recommendations
1. Fix error handling (replace `catch unreachable` with validation)
2. Add comparative benchmark vs std.crypto.sha2.Sha256
3. Add benchmark for maximum reasonable input
4. Verify test_input actually produces expected hashes

## Overall Assessment

**Status**: ✅ Production-ready with minor improvements recommended

**Security Rating**: ✅ SECURE - No security concerns identified

**Quality Rating**: ✅ HIGH - Clean code, good tests, correct implementation

**Compliance Rating**: ✅ FULLY COMPLIANT - Matches Ethereum spec exactly

**Priority**: LOW - Works correctly, improvements are optimizations/hardening

**Estimated Work**: 2-3 hours for overflow protection, docs, additional tests

This is one of the highest quality precompile implementations in the codebase. Main recommendations are defensive programming (overflow protection) and additional test coverage.
