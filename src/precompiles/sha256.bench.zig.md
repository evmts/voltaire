# Review: sha256.bench.zig

## Overview
Benchmark suite for SHA256 precompile (0x02) measuring performance across varying input sizes from empty to 64KB.

## Code Quality

### Strengths
- Excellent size progression: 0, 4, 32, 64, 1024, 65536 bytes
- Covers realistic usage patterns
- Clean, readable benchmark functions
- Tests edge cases (empty input, very large input)
- Includes known test vector

### Issues
- **Lines 9, 16, 23, 30, 37, 44, 51**: `catch unreachable` assumes benchmarks never fail
- **Lines 66-68**: Outdated/unusual zbench API usage
- No validation that operations actually succeed
- No comparison with baseline (std.crypto)

## Completeness

### Complete ✓
- Size range well-covered (0 to 64KB)
- Both tiny and huge inputs tested
- Known test vector included

### Missing Benchmarks
- Maximum reasonable input (~32MB)
- Comparison with std.crypto.hash.sha2.Sha256
- Memory allocation overhead separately
- Hardware acceleration vs software fallback
- Batch hashing (multiple inputs)
- Cache effects (hot vs cold)

## Benchmark Scenarios

### 1. benchSha256Empty (line 7)
- **Input**: 0 bytes
- **Measures**: Base overhead (allocation, gas check)
- **Expected**: < 1µs
- **Gas**: 60

### 2. benchSha256Small (line 14)
- **Input**: 4 bytes ("test")
- **Measures**: Minimum practical input
- **Expected**: ~1-2µs
- **Gas**: 72 (60 + 12*1)

### 3. benchSha256SingleWord (line 21)
- **Input**: 32 bytes
- **Measures**: Exactly one word
- **Expected**: ~1-2µs
- **Gas**: 72 (60 + 12*1)

### 4. benchSha256TwoWords (line 28)
- **Input**: 64 bytes
- **Measures**: Two words, single SHA256 block
- **Expected**: ~1-2µs (still one SHA256 block)
- **Gas**: 84 (60 + 12*2)

### 5. benchSha256Large (line 35)
- **Input**: 1KB (1024 bytes)
- **Measures**: Multiple SHA256 blocks (16 blocks)
- **Expected**: ~10-20µs
- **Gas**: 444 (60 + 12*32)

### 6. benchSha256VeryLarge (line 42)
- **Input**: 64KB (65536 bytes)
- **Measures**: Large input handling (1024 blocks)
- **Expected**: ~500-1000µs
- **Gas**: 24,780 (60 + 12*2048)

### 7. benchSha256TestVector (line 49)
- **Input**: "abc" (3 bytes)
- **Measures**: Known test vector performance
- **Expected**: ~1-2µs
- **Gas**: 72 (60 + 12*1)

## Issues Found

### Critical
1. **Silent Failures**: All benchmarks use `catch unreachable`
   - If SHA256 fails, benchmark returns early with no indication
   - Results would be meaninglessly fast (just allocation)
   - Violates CLAUDE.md: "NEVER swallow errors"

### Major
2. **No Validation**: Benchmarks don't verify correct output
   - Could be measuring broken implementation
   - Should at least check output length = 32

3. **Unreachable is Wrong**: Line 37, 44 use `catch unreachable` with large gas limits
   - These *should* never fail, but errors should be reported not assumed impossible
   - If implementation has bug, benchmark silently gives wrong results

### Minor
4. **No Comparative Benchmark**: Should compare against std.crypto baseline
5. **No Cache Testing**: All benchmarks likely hit warm cache after first iteration
6. **No Allocation Overhead Measurement**: Can't separate SHA256 time from allocation time

## Recommendations

### Critical Priority
1. **Fix error handling**:
   ```zig
   fn benchSha256Empty(allocator: std.mem.Allocator) void {
       const input = [_]u8{};
       const result = sha256.execute(allocator, &input, 1_000_000) catch |err| {
           std.debug.panic("SHA256 benchmark failed: {}\n", .{err});
       };
       defer result.deinit(allocator);

       // Validation (in debug mode)
       std.debug.assert(result.output.len == 32);
       std.debug.assert(result.gas_used == 60);
   }
   ```

2. **Add validation to all benchmarks**: At minimum check output length

### High Priority
3. **Add comparative benchmarks**:
   ```zig
   // Benchmark std.crypto for comparison
   fn benchStdSha256Small(allocator: std.mem.Allocator) void {
       const input = "test";
       var output: [32]u8 = undefined;
       std.crypto.hash.sha2.Sha256.hash(input, &output, .{});
       // Note: This doesn't allocate, so not directly comparable
   }

   // Benchmark our implementation with pre-allocated output
   fn benchSha256SmallNoAlloc(allocator: std.mem.Allocator) void {
       // Measure pure SHA256 time without allocation overhead
   }
   ```

4. **Add allocation overhead benchmark**:
   ```zig
   fn benchSha256AllocationOnly(allocator: std.mem.Allocator) void {
       const output = allocator.alloc(u8, 32) catch unreachable;
       defer allocator.free(output);
   }
   ```

5. **Add batch benchmark**:
   ```zig
   fn benchSha256Batch100(allocator: std.mem.Allocator) void {
       const input = "test";
       var i: usize = 0;
       while (i < 100) : (i += 1) {
           const result = sha256.execute(allocator, input, 1_000_000) catch unreachable;
           defer result.deinit(allocator);
       }
   }
   ```

### Medium Priority
6. **Add maximum size benchmark**:
   ```zig
   fn benchSha256Maximum(allocator: std.mem.Allocator) void {
       const MAX_SIZE = 32 * 1024 * 1024; // 32MB
       const input = try allocator.alloc(u8, MAX_SIZE);
       defer allocator.free(input);

       const result = sha256.execute(allocator, input, 10_000_000_000) catch |err| {
           std.debug.panic("Failed: {}\n", .{err});
       };
       defer result.deinit(allocator);
   }
   ```

7. **Add gas overhead benchmark**:
   ```zig
   fn benchSha256GasCheck(allocator: std.mem.Allocator) void {
       // Measure gas calculation overhead
       const input = [_]u8{0} ** 32;
       const num_words = (input.len + 31) / 32;
       const gas_cost = sha256.BASE_GAS + sha256.PER_WORD_GAS * num_words;
       std.mem.doNotOptimizeAway(gas_cost);
   }
   ```

8. **Fix zbench API usage**: Lines 66-68 look incorrect
   ```zig
   pub fn main() !void {
       var gpa = std.heap.GeneralPurposeAllocator(.{}){};
       defer _ = gpa.deinit();
       const allocator = gpa.allocator();

       var bench = zbench.Benchmark.init(allocator, .{});
       defer bench.deinit();

       try bench.add("SHA256 (empty)", benchSha256Empty, .{});
       // ... add all benchmarks

       const stdout = std.io.getStdOut().writer();
       try stdout.writeAll("\n=== SHA256 Precompile Benchmarks ===\n\n");
       try bench.run(stdout);
   }
   ```

### Low Priority
9. **Add documentation**:
   ```zig
   //! Benchmarks for SHA256 precompile (0x02)
   //!
   //! Tests performance across different input sizes:
   //! - Empty (0 bytes)
   //! - Small (4 bytes)
   //! - Single word (32 bytes)
   //! - Two words (64 bytes)
   //! - Large (1KB)
   //! - Very large (64KB)
   //!
   //! Expected performance:
   //! - Empty/Small: < 5µs
   //! - Large (1KB): 10-20µs
   //! - Very large (64KB): 500-1000µs
   //!
   //! Bottlenecks:
   //! - SHA256 computation: 90%
   //! - Memory allocation: 10%
   ```

10. **Add assertions for expected performance**:
    ```zig
    // In debug builds, verify performance is reasonable
    fn benchSha256Small(allocator: std.mem.Allocator) void {
        const timer = std.time.Timer.start() catch unreachable;
        const result = sha256.execute(allocator, "test", 1_000_000) catch unreachable;
        const elapsed = timer.read();
        defer result.deinit(allocator);

        // In debug, verify we're not absurdly slow
        if (@import("builtin").mode == .Debug) {
            std.debug.assert(elapsed < 1_000_000); // < 1ms
        }
    }
    ```

## Performance Expectations

### Hardware Accelerated (x86_64 with SHA extensions)
- Empty: ~0.5µs
- Small (4 bytes): ~1µs
- Single word (32 bytes): ~1µs
- Two words (64 bytes): ~1µs
- Large (1KB): ~10µs
- Very large (64KB): ~500µs

### Software Implementation (no HW acceleration)
- Empty: ~0.5µs
- Small (4 bytes): ~2µs
- Single word (32 bytes): ~2µs
- Two words (64 bytes): ~2µs
- Large (1KB): ~30µs
- Very large (64KB): ~2ms

### Scaling
SHA256 processes 64-byte blocks:
- 0-64 bytes: 1 block
- 65-128 bytes: 2 blocks
- 1KB: 16 blocks
- 64KB: 1024 blocks

Performance should scale linearly with number of blocks.

## Ethereum Specification Compliance

### Not Applicable
Benchmarks test performance, not compliance. However:
- Should verify benchmarks test spec-compliant behavior
- Gas costs should match spec (currently not validated)
- Output should be verified correct

## Security Concerns

### Low Priority
- Silent failures could mask security bugs
- No validation of output correctness
- No timing attack testing (SHA256 should be constant-time-ish but not critical)

## Code Smells

- `catch unreachable` throughout (violates error handling policy)
- No assertions or validation
- Outdated API usage (lines 66-68)
- No comparison baseline
- No documentation

## Overall Assessment

**Status**: ⚠️ Functional but needs fixes

**Quality Rating**: MEDIUM - Good coverage, poor error handling

**Usefulness**: MEDIUM - Provides basic performance data but no validation

**Accuracy**: UNKNOWN - Could be measuring broken implementation

**Priority**: MEDIUM - Important for performance tracking

**Estimated Work**: 2-3 hours to fix error handling, add validation, improve coverage

## Key Takeaway

The benchmark suite has good *coverage* (input sizes) but poor *reliability* (error handling). The silent error handling means we can't trust the results without manual verification that operations succeed.

**Critical Fix**: Replace all `catch unreachable` with proper error handling or at minimum `catch |err| std.debug.panic("Benchmark failed: {}", .{err})`.
