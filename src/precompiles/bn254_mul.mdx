---
title: BN254 Mul (0x07)
description: BN254 elliptic curve scalar multiplication precompile
---

# BN254 Mul

BN254 (alt_bn128) elliptic curve scalar multiplication for zkSNARK verification.

## Overview

The BN254 Mul precompile provides:
- **Scalar Multiplication**: Multiply point by scalar (k * P)
- **zkSNARK Support**: Core operation for zkSNARK verifiers
- **Constant Gas**: Fixed cost regardless of scalar size
- **Pure Zig**: Native implementation without C dependencies
- **Address**: 0x0000000000000000000000000000000000000007
- **Since**: Byzantium (EIP-196)

**Source**: `src/precompiles/bn254_mul.zig`

## Key Functions

### execute

```zig
const precompiles = @import("precompiles");

pub fn execute(
    allocator: std.mem.Allocator,
    input: []const u8,
    gas_limit: u64,
) PrecompileError!PrecompileResult
```

**Parameters:**
- `allocator`: Memory allocator for result
- `input`: 96 bytes (point + scalar)
- `gas_limit`: Maximum gas available

**Input Format** (96 bytes):
- Bytes 0-31: Point x-coordinate (big-endian)
- Bytes 32-63: Point y-coordinate (big-endian)
- Bytes 64-95: Scalar k (big-endian, 32 bytes)

**Returns:** 64 bytes (x, y coordinates of k*P)

**Errors:** `OutOfGas`, `InvalidPoint` (if point not on curve)

## Gas Costs

**Fixed Cost:** 6000 gas

Constant gas regardless of scalar value (even for k=0 or k=1).

Updated from 40000 gas to 6000 gas in Istanbul (EIP-1108).

## Examples

### Scalar Multiplication

```zig
const std = @import("std");
const precompiles = @import("precompiles");

pub fn scalarMul() !void {
    const allocator = std.heap.page_allocator;

    var input: [96]u8 = [_]u8{0} ** 96;

    // Point: G (generator)
    input[31] = 1; // x = 1
    input[63] = 2; // y = 2

    // Scalar: k = 5
    input[95] = 5;

    const result = try precompiles.bn254_mul.execute(
        allocator,
        &input,
        10000,
    );
    defer result.deinit(allocator);

    // Result is 5*G
    std.debug.print("5G: x={x}, y={x}\n", .{
        result.output[0..32],
        result.output[32..64],
    });
}
```

### Multiply by Zero

```zig
const std = @import("std");
const precompiles = @import("precompiles");

test "bn254_mul by zero" {
    const allocator = std.testing.allocator;

    var input: [96]u8 = [_]u8{0} ** 96;

    // Any point: (1, 2)
    input[31] = 1;
    input[63] = 2;

    // Scalar: k = 0
    // (already zero)

    const result = try precompiles.bn254_mul.execute(
        allocator,
        &input,
        6000,
    );
    defer result.deinit(allocator);

    // 0*P = point at infinity
    for (result.output) |byte| {
        try std.testing.expectEqual(0, byte);
    }
}
```

### Multiply by Group Order

```zig
const std = @import("std");
const precompiles = @import("precompiles");

test "bn254_mul by group order" {
    const allocator = std.testing.allocator;

    var input: [96]u8 = [_]u8{0} ** 96;

    // Generator point
    input[31] = 1;
    input[63] = 2;

    // Group order (curve order)
    // n*G = infinity for any point G on the curve
    const group_order = "0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141";
    // ... (parse to bytes) ...

    const result = try precompiles.bn254_mul.execute(
        allocator,
        &input,
        6000,
    );
    defer result.deinit(allocator);

    // Result should be point at infinity
    for (result.output) |byte| {
        try std.testing.expectEqual(0, byte);
    }
}
```

## Algorithm

Uses efficient scalar multiplication:

1. **Parse Input**: Extract point (x, y) and scalar k
2. **Validate Point**: Check point is on curve
3. **Handle Zero**: If k=0, return infinity
4. **Binary Method**: Double-and-add algorithm
   - For each bit of k (from MSB to LSB):
     - Double current result
     - If bit is 1, add base point
5. **Return**: Encoded result

Time complexity: O(log k) point operations

## BN254 Curve Parameters

**Curve Order (n):**
```
0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141
```

**Cofactor:** 1 (prime-order curve)

## Performance

**Native (ReleaseFast)**: ~150-300 μs
**WASM (ReleaseFast)**: ~400-800 μs

Uses windowed NAF (Non-Adjacent Form) for optimization.

## Testing

```bash
zig build test -Dtest-filter=bn254_mul
```

Test coverage includes:
- Multiply by zero (returns infinity)
- Multiply by one (returns same point)
- Multiply by group order (returns infinity)
- Large scalar values
- Invalid point rejection
- Scalar at field/group boundaries
- go-ethereum test vectors

## Related

- [BN254 Add](/zig/precompiles/bn254_add/) - Point addition (0x06)
- [BN254 Pairing](/zig/precompiles/bn254_pairing/) - Pairing check (0x08)
- [BLS12-381 G1 Mul](/zig/precompiles/bls12_g1_mul/) - BLS curve multiplication (0x0C)

## References

- [EIP-196](https://eips.ethereum.org/EIPS/eip-196) - Precompiled contracts for addition and scalar multiplication on the elliptic curve alt_bn128
- [EIP-1108](https://eips.ethereum.org/EIPS/eip-1108) - Reduce alt_bn128 precompile gas costs
- [Double-and-Add](https://en.wikipedia.org/wiki/Elliptic_curve_point_multiplication) - Scalar multiplication algorithm
- [ZCash Protocol](https://zips.z.cash/protocol/protocol.pdf) - Cryptographic primitives
