---
title: Blake2f (0x09)
description: Blake2b compression function precompile
---

# Blake2f

Blake2b compression function F for efficient hash verification.

## Overview

The Blake2f precompile provides:
- **Compression Function**: Blake2b F function (not full hash)
- **Variable Rounds**: Caller specifies number of rounds
- **Equihash Support**: Used in Equihash proof-of-work
- **Exact Input**: Requires precisely 213 bytes
- **Address**: 0x0000000000000000000000000000000000000009
- **Since**: Istanbul (EIP-152)

**Source**: `src/precompiles/blake2f.zig`

## Key Functions

### execute

```zig
const precompiles = @import("precompiles");

pub fn execute(
    allocator: std.mem.Allocator,
    input: []const u8,
    gas_limit: u64,
) PrecompileError!PrecompileResult
```

**Parameters:**
- `allocator`: Memory allocator for result
- `input`: Exactly 213 bytes (see format below)
- `gas_limit`: Maximum gas available

**Input Format** (213 bytes):
- Bytes 0-3: Number of rounds (big-endian u32)
- Bytes 4-67: State vector h (8 × 8 bytes)
- Bytes 68-195: Message block m (16 × 8 bytes)
- Bytes 196-211: Offset counters t (2 × 8 bytes)
- Byte 212: Final block flag f (0 or 1)

**Returns:** 64 bytes (updated state vector)

**Errors:** `OutOfGas`, `InvalidInput` (if length ≠ 213)

## Gas Costs

**Formula:** `rounds * 1 gas`

Where rounds = first 4 bytes of input (big-endian)

**Examples:**
- 0 rounds: 0 gas
- 1 round: 1 gas
- 12 rounds (standard): 12 gas
- 100000 rounds: 100000 gas

Extremely cheap - allows precise gas control.

## Examples

### Single Round Compression

```zig
const std = @import("std");
const precompiles = @import("precompiles");

pub fn compressOnce() !void {
    const allocator = std.heap.page_allocator;

    var input: [213]u8 = [_]u8{0} ** 213;

    // Set rounds = 1
    std.mem.writeInt(u32, input[0..4], 1, .big);

    // State h (64 bytes) - Blake2b IV
    // Message m (128 bytes)
    // Counters t (16 bytes)
    // Final flag f (1 byte)
    // ... (initialize appropriately) ...

    const result = try precompiles.blake2f.execute(
        allocator,
        &input,
        10,
    );
    defer result.deinit(allocator);

    std.debug.print("Compressed state: {x}\n", .{result.output});
}
```

### Full Blake2b (12 rounds)

```zig
const std = @import("std");
const precompiles = @import("precompiles");

pub fn blake2bCompress(
    allocator: std.mem.Allocator,
    h: *const [64]u8,
    m: *const [128]u8,
    t: *const [16]u8,
    f: bool,
) ![]u8 {
    var input: [213]u8 = undefined;

    // Standard Blake2b uses 12 rounds
    std.mem.writeInt(u32, input[0..4], 12, .big);

    @memcpy(input[4..68], h);
    @memcpy(input[68..196], m);
    @memcpy(input[196..212], t);
    input[212] = if (f) 1 else 0;

    const result = try precompiles.blake2f.execute(
        allocator,
        &input,
        12,
    );

    return result.output;
}
```

### Validate Input Length

```zig
const std = @import("std");
const precompiles = @import("precompiles");

test "blake2f exact length required" {
    const allocator = std.testing.allocator;

    // Too short
    {
        const input = [_]u8{0} ** 212;
        const result = precompiles.blake2f.execute(
            allocator,
            &input,
            100,
        );
        try std.testing.expectError(error.InvalidInput, result);
    }

    // Too long
    {
        const input = [_]u8{0} ** 214;
        const result = precompiles.blake2f.execute(
            allocator,
            &input,
            100,
        );
        try std.testing.expectError(error.InvalidInput, result);
    }

    // Exact length OK
    {
        var input = [_]u8{0} ** 213;
        const result = try precompiles.blake2f.execute(
            allocator,
            &input,
            0,
        );
        defer result.deinit(allocator);
        try std.testing.expectEqual(64, result.output.len);
    }
}
```

## Blake2b Compression Function

The F compression function is the core of Blake2b:

```
F(h, m, t, f, rounds) → h'
```

**Parameters:**
- h: 8-word state vector (64 bytes)
- m: 16-word message block (128 bytes)
- t: 2-word offset counter (16 bytes)
- f: Final block flag (1 byte)
- rounds: Number of mixing rounds (typically 12)

**Output:** Updated 8-word state (64 bytes)

## Algorithm

For each round (0 to rounds-1):
1. **G function** applied to columns and diagonals
2. **Message schedule** determines word mixing
3. **XOR operations** mix state with message

Precompile implements F function only - callers must handle:
- Padding
- Multi-block hashing
- Final output extraction

## Performance

**Native (ReleaseFast):**
- 1 round: ~0.5-1 μs
- 12 rounds: ~5-10 μs
- 100000 rounds: ~5-10 ms

**WASM (ReleaseFast):**
- ~2-3x slower than native

Highly optimized with SIMD where available.

## Use Cases

### Equihash Verification

Used in Zcash Equihash proof-of-work:
- Verify PoW solutions
- Compute Blake2b hashes efficiently
- Control gas cost precisely

### Stateless Clients

Allows efficient verification of:
- Merkle proofs
- State roots
- Zcash shielded transactions

## Testing

```bash
zig build test -Dtest-filter=blake2f
```

Test coverage includes:
- Zero rounds (0 gas)
- Standard rounds (12)
- Large round counts
- Input length validation
- Final flag handling

## Related

- [SHA256](/zig/precompiles/sha256/) - SHA-256 hash (0x02)
- [Keccak](/zig/crypto/keccak/) - Keccak-256 hash
- [Blake2](/zig/crypto/blake2/) - Full Blake2b implementation

## References

- [EIP-152](https://eips.ethereum.org/EIPS/eip-152) - Add BLAKE2 compression function F precompile
- [RFC 7693](https://tools.ietf.org/html/rfc7693) - Blake2 specification
- [Equihash](https://www.cryptolux.org/images/b/b9/Equihash.pdf) - Memory-hard PoW
- [Zcash Protocol](https://zips.z.cash/protocol/protocol.pdf) - Uses Blake2b extensively
