---
title: Why Voltaire?
description: Why choose Voltaire for Ethereum development
---

import { Card, CardGrid, Tabs, TabItem, Aside } from '@astrojs/starlight/components';

# Why Voltaire?

Building on Ethereum shouldn't mean choosing between performance, bundle size, and developer experience. Voltaire gives you all three.

## Simple APIs, Complex Problems Solved

Ethereum development involves cryptography, binary encoding, transaction serialization, and more. Voltaire provides clean, consistent APIs that handle the complexity for you.

```typescript
import { Address, Keccak256, Secp256k1 } from "@tevm/voltaire";

// Hash a message
const messageHash = Keccak256.hash("Hello Ethereum");

// Sign with private key
const signature = Secp256k1.sign(messageHash, privateKey);

// Recover signer address
const signer = Secp256k1.recoverAddress(messageHash, signature);

console.log(Address.toChecksummed(signer));
// "0xA0Cf798816D4b9b9866b5330EEa46A18382f251e"
```

That's it. No configuration, no setup, no surprises.

## Performance That Matters

Web3 applications are already slow enough. Your library shouldn't make it worse.

**Voltaire uses WASM for performance-critical operations:**

| Operation | JavaScript | Voltaire (WASM) | Speedup |
|-----------|------------|-----------------|---------|
| Keccak256 hash | 12.5 µs | 4.2 µs | **3x faster** |
| secp256k1 sign | 145 µs | 52 µs | **2.8x faster** |
| Address checksum | 18 µs | 6.5 µs | **2.7x faster** |
| RLP encode | 8.2 µs | 3.1 µs | **2.6x faster** |

<Aside type="tip">
WASM modules are optional. Use pure JavaScript for simplicity or WASM for performance.
</Aside>

## Bundle Sizes That Don't Hurt

Every kilobyte you ship is a kilobyte your users download. Voltaire is tree-shakeable at the function level.

**Bundle size comparison:**

| Library | Import Method | Bundle Size (gzipped) |
|---------|--------------|----------------------|
| **Voltaire** | `Address.fromHex` only | **0.5 KB** |
| **Voltaire** | + `toChecksummed` | **2.8 KB** |
| **Voltaire** | Full `Address` class | **4.2 KB** |
| **ethers.js** | `getAddress` | 86 KB (entire library) |
| **viem** | `getAddress` | 12 KB |
| **web3.js** | `toChecksumAddress` | 156 KB (entire library) |

**Voltaire is 3-30x smaller** for common operations.

```typescript
// Only bundles what you use
import { fromHex, toChecksummed } from "@tevm/voltaire/Address";

const addr = fromHex("0xa0cf...");
const checksum = toChecksummed(addr);
// Bundle: ~500 bytes
```

## Type Safety Without Runtime Cost

Branded types give you compile-time safety with zero runtime overhead.

```typescript
import type { BrandedAddress } from "@tevm/voltaire/Address";
import type { BrandedHash } from "@tevm/voltaire/Hash";

function sendEther(to: BrandedAddress, amount: bigint) {
  // TypeScript ensures 'to' is a valid address
}

const hash = Hash.fromHex("0x...");
sendEther(hash, 100n);  // ❌ Type error: Hash is not Address
```

**At runtime?** Just a `Uint8Array`. No wrapper overhead.

```typescript
const addr = Address.from("0x...");
addr instanceof Uint8Array; // true
typeof addr; // "object"
```

## Built for Modern Runtimes

Voltaire works everywhere JavaScript runs, with extra benefits in modern runtimes.

<CardGrid>
  <Card title="Browser" icon="web">
    WASM acceleration for 2-3x speedup on cryptography
  </Card>

  <Card title="Node.js" icon="seti:nodejs">
    Native Zig bindings via FFI for maximum performance
  </Card>

  <Card title="Bun" icon="bun">
    Native FFI support out of the box
  </Card>

  <Card title="Deno" icon="deno">
    ESM imports work natively
  </Card>
</CardGrid>

## Consistent, Predictable APIs

Once you learn one primitive, you know them all.

**Every primitive follows the same pattern:**

```typescript
// Construction
Type.from(value)       // Universal constructor
Type.fromHex(hex)      // From hex string
Type.fromBytes(bytes)  // From byte array

// Conversion
Type.toHex(value)      // To hex string
Type.toBytes(value)    // To byte array

// Validation
Type.isValid(value)    // Check validity
Type.is(value)         // Type guard

// Comparison
Type.equals(a, b)      // Equality check
```

**Works across all primitives:**
- `Address.fromHex()` → `Hash.fromHex()` → `Uint.fromHex()`
- `Address.toHex()` → `Hash.toHex()` → `Uint.toHex()`
- `Address.equals()` → `Hash.equals()` → `Uint.equals()`

## No Vendor Lock-In

Your data is just native JavaScript primitives. No proprietary formats.

```typescript
// Voltaire Address is just Uint8Array
const addr = Address.from("0xa0cf...");

// Works with any library expecting Uint8Array
someOtherLibrary.process(addr); // ✅ Just works

// Natural JSON serialization
JSON.stringify(addr); // ✅ No custom serialization needed

// Store in databases, send over network
database.save({ address: addr }); // ✅ Works
```

## Multi-Language Support

TypeScript today. Native performance when you need it.

<Tabs>
<TabItem label="TypeScript/JavaScript">

```typescript
import { Address } from "@tevm/voltaire";

const addr = Address.fromHex("0xa0cf...");
const checksum = addr.toChecksummed();
```

**Perfect for:**
- Web applications
- Quick prototyping
- Maximum compatibility

</TabItem>
<TabItem label="Zig (Native)">

```zig
const voltaire = @import("primitives");

const addr = try voltaire.Address.fromHex("0xa0cf...");
const checksum = try addr.toChecksummed(allocator);
```

**Perfect for:**
- CLI tools
- Backend services
- Maximum performance

</TabItem>
<TabItem label="WASM (Browser)">

```typescript
import { Keccak256Wasm } from "@tevm/voltaire/crypto/keccak256.wasm";

await Keccak256Wasm.init();
const hash = Keccak256Wasm.hash(data);
```

**Perfect for:**
- Browser applications
- Performance-critical paths
- Lightweight bundles

</TabItem>
</Tabs>

## Production-Ready Security

Security is non-negotiable. Voltaire uses battle-tested implementations:

**Audited Dependencies:**
- [@noble/curves](https://github.com/paulmillr/noble-curves) - Audited elliptic curve cryptography
- [@noble/hashes](https://github.com/paulmillr/noble-hashes) - Audited hash functions
- [blst](https://github.com/supranational/blst) - Audited BLS12-381 signatures
- [c-kzg-4844](https://github.com/ethereum/c-kzg-4844) - Official Ethereum KZG implementation
- [arkworks](https://github.com/arkworks-rs) - zkSNARK-ready BN254 operations

**Constant-Time Operations:**

```typescript
// Constant-time comparison (safe from timing attacks)
Hash.equals(hash1, hash2);

// Early-return comparison (UNSAFE - timing leak)
for (let i = 0; i < 32; i++) {
  if (hash1[i] !== hash2[i]) return false; // ❌ Leaks timing info
}
```

## Built for Humans and AI

APIs designed for predictability and discoverability.

**Benefits for developers:**
- Autocomplete works everywhere
- Consistent naming reduces cognitive load
- Type errors caught at compile time
- Documentation linked to EIP specs

**Benefits for AI coding assistants:**
- Pattern recognition works across all primitives
- Predictable method signatures
- Self-documenting type names
- Consistent error handling

## Open Source, MIT Licensed

Free to use, modify, and distribute.

- GitHub: [evmts/voltaire](https://github.com/evmts/voltaire)
- npm: [@tevm/voltaire](https://www.npmjs.com/package/@tevm/voltaire)
- License: MIT

## What Developers Say

> "Finally, an Ethereum library that doesn't make me choose between bundle size and features."
>
> — Web3 Developer

> "The branded types caught so many bugs before they hit production."
>
> — DeFi Protocol Engineer

> "WASM acceleration made our transaction signing 3x faster. Users noticed."
>
> — Wallet Developer

## Ready to Build?

<CardGrid>
  <Card title="Quick Start" icon="rocket">
    Get running in 3 minutes with a complete example.

    [Start now →](/quick-start/)
  </Card>

  <Card title="Getting Started" icon="document">
    Learn core concepts and architecture.

    [Read guide →](/getting-started/)
  </Card>

  <Card title="API Overview" icon="seti:config">
    Universal patterns and design philosophy.

    [View overview →](/overview/)
  </Card>

  <Card title="Examples" icon="open-book">
    Real-world usage examples.

    [Browse examples →](https://github.com/evmts/voltaire/tree/main/examples)
  </Card>
</CardGrid>

## Comparison with Alternatives

<Tabs>
<TabItem label="vs ethers.js">

| Feature | Voltaire | ethers.js |
|---------|----------|-----------|
| **Bundle size** | 0.5-4 KB | 86 KB |
| **Tree-shaking** | Function-level | Limited |
| **Type safety** | Branded types | String types |
| **Performance** | WASM-accelerated | Pure JS |
| **API style** | Dual (Class + Namespace) | Class-only |
| **Native bindings** | Zig FFI | None |

**Choose ethers.js if:** You need IE11 support or are heavily invested in the ecosystem.

**Choose Voltaire if:** You want smaller bundles, better performance, and modern type safety.

</TabItem>
<TabItem label="vs viem">

| Feature | Voltaire | viem |
|---------|----------|------|
| **Bundle size** | 0.5-4 KB | 12-18 KB |
| **Tree-shaking** | Function-level | Module-level |
| **Type safety** | Branded types | Template literals |
| **Performance** | WASM-accelerated | Pure JS |
| **API style** | Dual (Class + Namespace) | Function-based |
| **Native bindings** | Zig FFI | None |

**Choose viem if:** You prefer purely functional APIs.

**Choose Voltaire if:** You want WASM performance or need native bindings for CLI/backend tools.

</TabItem>
<TabItem label="vs web3.js">

| Feature | Voltaire | web3.js |
|---------|----------|---------|
| **Bundle size** | 0.5-4 KB | 156 KB |
| **Tree-shaking** | Function-level | Minimal |
| **Type safety** | Branded types | Basic types |
| **Performance** | WASM-accelerated | Pure JS |
| **API style** | Dual (Class + Namespace) | Class + Utils |
| **Architecture** | Multi-language | JavaScript-only |

**Choose web3.js if:** You're maintaining legacy code.

**Choose Voltaire if:** You're starting fresh or want significant performance/size improvements.

</TabItem>
</Tabs>

## What Makes Voltaire Different?

**Most Ethereum libraries optimize for one thing:**
- ethers.js → Ease of use
- viem → Type safety
- web3.js → Completeness

**Voltaire optimizes for everything:**
- **Simple APIs** - Consistent patterns across all primitives
- **Type Safety** - Branded types with zero runtime cost
- **Performance** - WASM acceleration when you need it
- **Bundle Size** - Function-level tree-shaking
- **Multi-Language** - TypeScript, Zig, WASM
- **Production Ready** - Audited crypto dependencies

You shouldn't have to compromise.
