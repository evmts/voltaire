---
title: "0x05 ModExp"
description: Modular exponentiation for RSA and other cryptographic operations
---

## Overview

**Address:** `0x0000000000000000000000000000000000000005`
**Introduced:** Byzantium (EIP-198)
**EIP:** [EIP-198](https://eips.ethereum.org/EIPS/eip-198), [EIP-2565](https://eips.ethereum.org/EIPS/eip-2565)

The ModExp precompile computes modular exponentiation: `(base^exponent) mod modulus`. This enables efficient RSA signature verification, Fermat primality testing, and other advanced cryptographic operations in smart contracts.

EIP-198 introduced ModExp in Byzantium. EIP-2565 (Berlin) reduced gas costs to make RSA verification practical.

## Gas Cost

**Complex formula that varies by hardfork:**

Pre-Berlin: `max(200, complexity * iteration_count / GQUADDIVISOR)`
Berlin+: `max(200, complexity * iteration_count / GQUADDIVISOR_v2)`

Where:
- `complexity = mult_complexity * max(length(base), length(modulus))`
- `mult_complexity = (max(length(base), length(modulus)) / 8)^2` if max > 64, else `mult_complexity = max(length(base), length(modulus))^2 / 4`
- `iteration_count = max(exponent_bitlength - 1, 1)` adjusted for exponent head
- Minimum gas: `200`

The exact calculation is in `src/crypto/ModExp/calculateGas`

**Examples:**
- Small inputs (1-byte each): ~200 gas
- 256-byte RSA (2048-bit): ~50,000+ gas
- 512-byte RSA (4096-bit): ~200,000+ gas

## Input Format

```
Offset | Length | Description
-------|--------|-------------
0      | 32     | base_length (big-endian u256)
32     | 32     | exponent_length (big-endian u256)
64     | 32     | modulus_length (big-endian u256)
96     | base_length | base value (big-endian)
96+base_length | exponent_length | exponent value (big-endian)
96+base_length+exponent_length | modulus_length | modulus value (big-endian)
```

Minimum input length: 96 bytes (length headers only)

## Output Format

Output length equals `modulus_length` specified in input.

```
Offset | Length | Description
-------|--------|-------------
0      | modulus_length | (base^exponent mod modulus) as big-endian
```

Returns empty output if `modulus_length = 0`.

## Usage Example

```typescript
import { execute, PrecompileAddress } from '@tevm/voltaire/precompiles';
import { Hardfork } from '@tevm/voltaire/primitives/Hardfork';

// Compute 2^3 mod 5 = 8 mod 5 = 3
const input = new Uint8Array(99);

// base_length = 1
input[31] = 1;
// exponent_length = 1
input[63] = 1;
// modulus_length = 1
input[95] = 1;
// base = 2
input[96] = 2;
// exponent = 3
input[97] = 3;
// modulus = 5
input[98] = 5;

const result = execute(
  PrecompileAddress.MODEXP,
  input,
  100000n,
  Hardfork.CANCUN
);

if (result.success) {
  console.log('Result:', result.output[0]); // 3
  console.log('Gas used:', result.gasUsed);
} else {
  console.error('Error:', result.error);
}
```

## Error Conditions

- Input length < 96 bytes
- Out of gas (gas cost depends on input sizes)
- Modulus = 0 (returns error)
- Integer overflow in length values

## Use Cases

- **RSA signature verification:** Verify RSA-2048, RSA-4096 signatures on-chain
- **Zero-knowledge proofs:** Perform modular arithmetic for zkSNARKs
- **Cryptographic protocols:** Diffie-Hellman key exchange, ElGamal encryption
- **Primality testing:** Fermat and Miller-Rabin primality tests
- **Number theory:** Modular inverses, Chinese remainder theorem

## Implementation Details

- **Zig:** Uses multi-precision arithmetic from ModExp crypto module
- **TypeScript:** BigInt-based modular exponentiation with square-and-multiply
- **Integration:** Depends on ModExp.calculateGas for hardfork-specific gas calculation
- **Optimization:** Binary exponentiation (square-and-multiply algorithm)

## RSA Verification Example

```typescript
// RSA-2048 verification (256-byte values)
const baseLen = 256;
const expLen = 3;  // Common public exponent: 65537
const modLen = 256;

const input = new Uint8Array(96 + baseLen + expLen + modLen);

// Set lengths
const view = new DataView(input.buffer);
view.setBigUint64(24, BigInt(baseLen), false);
view.setBigUint64(56, BigInt(expLen), false);
view.setBigUint64(88, BigInt(modLen), false);

// Set base (signature), exponent (public key), modulus
// ... (set actual RSA values)

const result = execute(
  PrecompileAddress.MODEXP,
  input,
  1000000n, // RSA needs significant gas
  Hardfork.CANCUN
);

// result.output should equal expected message hash
```

## Gas Cost Reduction (EIP-2565)

Berlin hard fork (EIP-2565) reduced gas costs significantly:

| Input Size | Pre-Berlin | Berlin | Reduction |
|------------|-----------|--------|-----------|
| 2048-bit RSA | ~300,000 | ~50,000 | 83% |
| 4096-bit RSA | ~1,200,000 | ~200,000 | 83% |

This made RSA verification practical for many use cases.

## Edge Cases

- **Zero exponent:** Returns 1 (any number to power 0 is 1)
- **Modulus = 1:** Returns 0 (anything mod 1 is 0)
- **Base > modulus:** Automatically reduced mod modulus
- **Truncated input:** Missing bytes treated as zero
- **Zero modulus:** Returns error (division by zero)

## Test Vectors

```typescript
// Test 1: 2^3 mod 5 = 3
const input1 = new Uint8Array(99);
input1[31] = 1;  // base_len = 1
input1[63] = 1;  // exp_len = 1
input1[95] = 1;  // mod_len = 1
input1[96] = 2;  // base = 2
input1[97] = 3;  // exp = 3
input1[98] = 5;  // mod = 5
// Expected: 0x03

// Test 2: 3^1 mod 5 = 3
const input2 = new Uint8Array(99);
input2[31] = 1;  // base_len = 1
input2[63] = 1;  // exp_len = 1
input2[95] = 1;  // mod_len = 1
input2[96] = 3;  // base = 3
input2[97] = 1;  // exp = 1
input2[98] = 5;  // mod = 5
// Expected: 0x03

// Test 3: 5^0 mod 7 = 1 (zero exponent)
const input3 = new Uint8Array(99);
input3[31] = 1;  // base_len = 1
input3[63] = 1;  // exp_len = 1
input3[95] = 1;  // mod_len = 1
input3[96] = 5;  // base = 5
input3[97] = 0;  // exp = 0
input3[98] = 7;  // mod = 7
// Expected: 0x01

// Test 4: Zero modulus error
const input4 = new Uint8Array(99);
input4[31] = 1;
input4[63] = 1;
input4[95] = 1;
input4[96] = 2;
input4[97] = 3;
input4[98] = 0;  // mod = 0
// Expected: Error (division by zero)
```

## Related

- [Crypto: ModExp](/crypto/modexp)
- [Primitives: GasConstants](/primitives/gasconstants)
- [Yellow Paper](https://ethereum.github.io/yellowpaper/paper.pdf) - Appendix E
- [EIP-198: Big Integer Modular Exponentiation](https://eips.ethereum.org/EIPS/eip-198)
- [EIP-2565: ModExp Gas Cost](https://eips.ethereum.org/EIPS/eip-2565)
