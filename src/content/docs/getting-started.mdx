---
title: Getting Started
description: Learn the core patterns and architecture of Voltaire
---

import { Tabs, TabItem, Code, Steps, Aside, Card, CardGrid } from '@astrojs/starlight/components';

# Getting Started

Voltaire is a modern Ethereum library built with performance, type safety, and tree-shaking as first-class priorities. This guide will teach you the core concepts and patterns that make Voltaire different.

## Prerequisites

- **Node.js:** 18.x or higher (20.x recommended)
- **Package Manager:** npm, bun, pnpm, or yarn
- **Knowledge:** Familiarity with JavaScript/TypeScript and basic Ethereum concepts (addresses, transactions, signatures)

<Aside type="tip">
  New to Ethereum? Check out [ethereum.org/developers](https://ethereum.org/en/developers/) for fundamentals.
</Aside>

## Installation

<Tabs syncKey="pm">
  <TabItem label="npm">
    ```bash
    npm install @tevm/voltaire
    ```
  </TabItem>
  <TabItem label="bun">
    ```bash
    bun add @tevm/voltaire
    ```
  </TabItem>
  <TabItem label="pnpm">
    ```bash
    pnpm add @tevm/voltaire
    ```
  </TabItem>
  <TabItem label="yarn">
    ```bash
    yarn add @tevm/voltaire
    ```
  </TabItem>
</Tabs>

## Quick Start (5 Minutes)

Let's build a simple example that demonstrates Voltaire's core capabilities: hashing, signing, and address validation.

<Steps>

1. **Create a new file** `example.ts`:

   <Tabs syncKey="runtime">
     <TabItem label="Node.js/Bun">
       ```typescript
       import { Keccak256, Secp256k1, Address } from "@tevm/voltaire";

       // Hash a message
       const message = "Welcome to Voltaire";
       const messageHash = Keccak256.hash(message);
       console.log("Message hash:", messageHash);

       // Generate a keypair
       const privateKey = Secp256k1.randomPrivateKey();
       const publicKey = Secp256k1.getPublicKey(privateKey);

       // Sign the hash
       const signature = Secp256k1.sign(messageHash, privateKey);

       // Recover the signer's address
       const signerAddress = Secp256k1.recoverAddress(messageHash, signature);
       console.log("Signer address:", Address.toChecksummed(signerAddress));

       // Verify the signature
       const isValid = Secp256k1.verify(messageHash, signature, publicKey);
       console.log("Signature valid:", isValid);
       ```
     </TabItem>
     <TabItem label="Browser (Vite)">
       ```typescript
       import { Keccak256, Secp256k1, Address } from "@tevm/voltaire";

       // Hash a message
       const message = "Welcome to Voltaire";
       const messageHash = Keccak256.hash(message);
       document.body.innerHTML += `<p>Hash: ${messageHash}</p>`;

       // Generate a keypair
       const privateKey = Secp256k1.randomPrivateKey();
       const publicKey = Secp256k1.getPublicKey(privateKey);

       // Sign and verify
       const signature = Secp256k1.sign(messageHash, privateKey);
       const signerAddress = Secp256k1.recoverAddress(messageHash, signature);

       document.body.innerHTML += `
         <p>Signer: ${Address.toChecksummed(signerAddress)}</p>
         <p>Valid: ${Secp256k1.verify(messageHash, signature, publicKey)}</p>
       `;
       ```
     </TabItem>
   </Tabs>

2. **Run the example:**

   <Tabs syncKey="runtime">
     <TabItem label="Node.js">
       ```bash
       node --loader tsx example.ts
       ```
     </TabItem>
     <TabItem label="Bun">
       ```bash
       bun run example.ts
       ```
     </TabItem>
     <TabItem label="Browser (Vite)">
       ```bash
       npm run dev
       ```
     </TabItem>
   </Tabs>

3. **See the output:**

   ```
   Message hash: Uint8Array(32) [...]
   Signer address: 0xA0Cf798816D4b9b9866b5330EEa46A18382f251e
   Signature valid: true
   ```

</Steps>

Congratulations! You've just hashed data, signed a message, and recovered an Ethereum address using Voltaire.

## Core Architecture

Voltaire uses a **data-first architecture** with two complementary APIs:

1. **Branded Types with Namespaced Methods** — Tree-shakeable, zero-overhead primitives
2. **Class APIs** — Convenient wrappers for familiar OOP patterns

Both APIs operate on the same underlying data, giving you flexibility to choose based on your needs.

## Branded Types Pattern

At the core of Voltaire are **branded primitives** — native JavaScript types (Uint8Array, bigint, string) with TypeScript brands for type safety.

### What is a Branded Type?

A branded type is a primitive with a compile-time tag that prevents mixing incompatible values:

```typescript
// Branded type definition
type Address = Uint8Array & { readonly __tag: "Address" };
type Hash = Uint8Array & { readonly __brand: symbol };
type Uint = bigint & { readonly __brand: symbol };

// These prevent accidents like:
const address: Address = someHash; // ❌ Type error
const hash: Hash = someAddress;     // ❌ Type error
```

**Benefits:**
- **Zero runtime overhead** — Just primitives at runtime
- **Type safety** — Compiler prevents mixing incompatible types
- **Serialization** — Natural JSON serialization (no classes to unwrap)
- **Interop** — Works seamlessly with other libraries

### Namespaced Methods

Methods are organized in namespaces that match the type they operate on:

```typescript
import { BrandedAddress } from "@tevm/voltaire/Address";

// Methods are namespaced by type
const addr = BrandedAddress.fromHex("0xa0cf798816d4b9b9866b5330eea46a18382f251e");
const hex = BrandedAddress.toHex(addr);
const checksummed = BrandedAddress.toChecksummed(addr);
const isZero = BrandedAddress.isZero(addr);
```

**Tree-Shaking:** Only the specific functions you import are bundled.

```typescript
// This bundles ONLY fromHex and toChecksummed
import { BrandedAddress } from "@tevm/voltaire/Address";

const addr = BrandedAddress.fromHex("0x...");
const checksum = BrandedAddress.toChecksummed(addr);
```

## Class API Pattern

For familiar OOP ergonomics, Voltaire provides class wrappers:

```typescript
import { Address } from "@tevm/voltaire";

// Constructor accepts multiple formats
const addr = new Address("0xa0cf798816d4b9b9866b5330eea46a18382f251e");

// Instance methods
addr.toHex();           // "0xa0cf..."
addr.toChecksummed();   // "0xA0Cf..."
addr.isZero();          // false
addr.equals(other);     // boolean

// Static methods
Address.fromHex("0x...");
Address.fromBytes(bytes);
Address.zero();
```

**Under the Hood:** Class instances are just branded Uint8Arrays with methods attached to the prototype. Zero overhead.

## Choosing an API Style

<Tabs syncKey="api-style">
  <TabItem label="Class API">

**Use when:**
- You prefer OOP patterns
- You want familiar method chaining
- Bundle size isn't critical
- You're prototyping quickly

```typescript
import { Address, Hash, Uint } from "@tevm/voltaire";

const addr = new Address("0xa0cf798816d4b9b9866b5330eea46a18382f251e");
const checksum = addr.toChecksummed();

const a = Uint.from(100n);
const b = Uint.from(200n);
const sum = Uint.plus(a, b);
```

  </TabItem>
  <TabItem label="Branded Types">

**Use when:**
- Bundle size matters (tree-shaking)
- You want zero runtime overhead
- You need maximum performance
- You're building a library

```typescript
import { BrandedAddress } from "@tevm/voltaire/Address";
import { BrandedUint } from "@tevm/voltaire/Uint";

const addr = BrandedAddress.fromHex("0xa0cf798816d4b9b9866b5330eea46a18382f251e");
const checksum = BrandedAddress.toChecksummed(addr);

const a = BrandedUint.from(100n);
const b = BrandedUint.from(200n);
const sum = BrandedUint.plus(a, b);
```

  </TabItem>
</Tabs>

**You can mix both styles** — they operate on the same data:

```typescript
import { Address } from "@tevm/voltaire";
import { BrandedAddress } from "@tevm/voltaire/Address";

const addr1 = new Address("0x...");
const addr2 = BrandedAddress.fromHex("0x...");

// Both work together
BrandedAddress.equals(addr1, addr2); // ✅ Works
addr1.equals(addr2);                  // ✅ Works
```

## Method Naming Convention

Voltaire follows consistent naming patterns across all types:

### Construction
- `Type.from(value)` — Universal constructor (accepts multiple formats)
- `Type.fromHex(hex)` — From hex string
- `Type.fromBytes(bytes)` — From byte array
- `Type.fromNumber(n)` — From number/bigint
- `Type.zero()` — Zero value

### Conversion
- `Type.toHex(value)` — To hex string
- `Type.toBytes(value)` — To byte array
- `Type.toNumber(value)` — To number/bigint

### Validation
- `Type.isValid(value)` — Check if value is valid
- `Type.is(value)` — Type guard
- `Type.isZero(value)` — Check if zero

### Comparison
- `Type.equals(a, b)` — Equality check
- `Type.compare(a, b)` — Comparison for sorting

## Quick Examples

### Working with Addresses

```typescript
import { Address } from "@tevm/voltaire";

// Create from hex
const addr = Address.from("0xa0cf798816d4b9b9866b5330eea46a18382f251e");

// EIP-55 checksumming
const checksummed = addr.toChecksummed();
console.log(checksummed); // "0xA0Cf798816D4b9b9866b5330EEa46A18382f251e"

// Check if zero
const isZero = addr.isZero(); // false

// Calculate contract addresses
const deployer = Address.from("0x742d35Cc6634C0532925a3b844Bc9e7595f0bEb2");
const contractAddr = deployer.calculateCreateAddress(0n);
```

### Working with Hashes

```typescript
import { Keccak256, Hash } from "@tevm/voltaire";

// Hash data
const data = new Uint8Array([1, 2, 3]);
const hash = Keccak256.hash(data);

// Convert to hex
const hex = Hash.toHex(hash);

// Constant-time comparison
const hash2 = Keccak256.hash(data);
Hash.equals(hash, hash2); // true
```

### Working with Uint256

```typescript
import { Uint } from "@tevm/voltaire";

// Create from various formats
const a = Uint.from(100n);
const b = Uint.from("0xff");
const c = Uint.fromHex("0x200");

// Arithmetic (wrapping on overflow)
const sum = Uint.plus(a, b);      // 100 + 255 = 355
const product = Uint.times(a, b); // 100 * 255 = 25500
const quotient = Uint.dividedBy(product, b); // 25500 / 255 = 100

// Comparison
Uint.greaterThan(sum, a); // true
Uint.lessThan(a, b);      // true

// Convert to hex
const hex = Uint.toHex(sum); // "0x0000...0163"
```

### Working with Transactions

```typescript
import { Transaction } from "@tevm/voltaire";

// EIP-1559 transaction
const tx: Transaction.EIP1559 = {
  type: 2,
  chainId: 1n,
  nonce: 0n,
  maxFeePerGas: 30000000000n,
  maxPriorityFeePerGas: 1000000000n,
  gasLimit: 21000n,
  to: recipientAddress,
  value: 1000000000000000000n,
  data: new Uint8Array(),
  accessList: [],
  r: signature.r,
  s: signature.s,
  v: signature.v,
};

// Serialize
const serialized = Transaction.serialize(tx);

// Hash
const txHash = Transaction.hash(tx);

// Recover sender
const sender = Transaction.from(tx);
```

## Type Safety

Voltaire provides opt-in type safety through branded types:

```typescript
import type { BrandedAddress } from "@tevm/voltaire/Address";
import type { BrandedHash } from "@tevm/voltaire/Hash";

function processAddress(addr: BrandedAddress) {
  // TypeScript ensures addr is a valid Address
}

function processHash(hash: BrandedHash) {
  // TypeScript ensures hash is a valid Hash
}

// Type errors prevent mistakes
const addr = Address.fromHex("0x...");
const hash = Keccak256.hash(data);

processAddress(addr);  // ✅ OK
processAddress(hash);  // ❌ Type error
processHash(hash);     // ✅ OK
processHash(addr);     // ❌ Type error
```

## Performance

Voltaire is optimized for performance:

- **Zero overhead abstractions** — Branded types compile to primitives
- **Tree-shaking** — Only bundle what you use
- **WASM acceleration** — Optional Zig-compiled WASM for minimal bundle impact and maximum performance
- **Native browser methods** — Uses native toHex/toBase64 when available
- **Constant-time operations** — Security-critical comparisons are constant-time

## First Real Task: Sign a Transaction (15 Minutes)

Now let's build something practical: create and sign an EIP-1559 transaction.

<Steps>

1. **Create a transaction:**

   ```typescript
   import { Transaction, Address, Uint } from "@tevm/voltaire";

   const tx = {
     type: 2, // EIP-1559
     chainId: 1n, // Ethereum mainnet
     nonce: 0n,
     maxFeePerGas: Uint.from("30 gwei"),
     maxPriorityFeePerGas: Uint.from("1 gwei"),
     gasLimit: 21_000n,
     to: Address.from("0x742d35Cc6634C0532925a3b844Bc9e7595f0bEb2"),
     value: Uint.from("1 ether"),
     data: new Uint8Array(),
   };
   ```

2. **Sign the transaction:**

   ```typescript
   import { Secp256k1 } from "@tevm/voltaire";

   // Your private key (NEVER share or commit this!)
   const privateKey = "0x...";

   // Sign
   const signedTx = Transaction.sign(tx, privateKey);
   console.log("Signed transaction:", signedTx);
   ```

3. **Serialize for broadcasting:**

   ```typescript
   // Serialize to RLP-encoded bytes
   const serialized = Transaction.serialize(signedTx);

   // Convert to hex for RPC
   const txHex = Hex.fromBytes(serialized);
   console.log("Transaction hex:", txHex);

   // You can now send this via eth_sendRawTransaction
   ```

4. **Verify the signature:**

   ```typescript
   // Recover the sender address
   const sender = Transaction.recoverSender(signedTx);
   console.log("Sender address:", Address.toChecksummed(sender));

   // Calculate transaction hash
   const txHash = Transaction.hash(signedTx);
   console.log("Transaction hash:", Hash.toHex(txHash));
   ```

</Steps>

<Aside type="caution">
  **Never** use real private keys in test code. Always use test networks (Sepolia, Holesky) or local development chains.
</Aside>

## Troubleshooting

### Common Issues

<details>
<summary>**Import errors: "Cannot find module"**</summary>

Make sure you're using the correct import paths:

```typescript
// ✅ Correct
import { Address } from "@tevm/voltaire";
import { BrandedAddress } from "@tevm/voltaire/Address";

// ❌ Wrong
import { Address } from "@tevm/voltaire/primitives/Address";
```

Check your `tsconfig.json` has `"moduleResolution": "bundler"` or `"node16"`.

</details>

<details>
<summary>**Type errors with branded types**</summary>

If you get type errors like "Type 'Uint8Array' is not assignable to type 'BrandedAddress'", you need to construct the branded type properly:

```typescript
// ❌ Won't work
const addr: BrandedAddress = new Uint8Array(20);

// ✅ Correct
const addr = Address.from("0x...");
// or
const addr = BrandedAddress.fromHex("0x...");
```

</details>

<details>
<summary>**WASM initialization errors**</summary>

If using WASM modules, make sure to await initialization:

```typescript
import { Keccak256Wasm } from "@tevm/voltaire/crypto/keccak256.wasm";

// Must initialize before use
await Keccak256Wasm.init();

// Now you can use it
const hash = Keccak256Wasm.hash(data);
```

</details>

<details>
<summary>**Bundle size is too large**</summary>

Use tree-shakeable imports to reduce bundle size:

```typescript
// ❌ Imports entire Address class (~18 KB)
import { Address } from "@tevm/voltaire";

// ✅ Only imports specific functions (~500 bytes)
import { fromHex, toChecksummed } from "@tevm/voltaire/Address";
```

</details>

## Migration Guides

### From ethers.js

<Tabs>
  <TabItem label="Addresses">
    ```typescript
    // ethers
    import { getAddress } from "ethers";
    const addr = getAddress("0xa0cf...");

    // Voltaire
    import { Address } from "@tevm/voltaire";
    const addr = Address.from("0xa0cf...");
    const checksum = addr.toChecksummed();
    ```
  </TabItem>

  <TabItem label="Hashing">
    ```typescript
    // ethers
    import { keccak256, toUtf8Bytes } from "ethers";
    const hash = keccak256(toUtf8Bytes("hello"));

    // Voltaire
    import { Keccak256 } from "@tevm/voltaire";
    const hash = Keccak256.hash("hello");
    ```
  </TabItem>

  <TabItem label="Signing">
    ```typescript
    // ethers
    import { Wallet } from "ethers";
    const wallet = new Wallet(privateKey);
    const sig = await wallet.signMessage("hello");

    // Voltaire
    import { Keccak256, Secp256k1 } from "@tevm/voltaire";
    const hash = Keccak256.hash("hello");
    const sig = Secp256k1.sign(hash, privateKey);
    ```
  </TabItem>

  <TabItem label="Transactions">
    ```typescript
    // ethers
    import { Wallet } from "ethers";
    const wallet = new Wallet(privateKey);
    const tx = await wallet.signTransaction({
      to: "0x...",
      value: parseEther("1.0"),
      // ...
    });

    // Voltaire
    import { Transaction } from "@tevm/voltaire";
    const signed = Transaction.sign({
      type: 2,
      to: Address.from("0x..."),
      value: Uint.from("1 ether"),
      // ...
    }, privateKey);
    const serialized = Transaction.serialize(signed);
    ```
  </TabItem>
</Tabs>

### From viem

<Tabs>
  <TabItem label="Addresses">
    ```typescript
    // viem
    import { getAddress } from "viem";
    const addr = getAddress("0xa0cf...");

    // Voltaire
    import { Address } from "@tevm/voltaire";
    const addr = Address.from("0xa0cf...");
    ```
  </TabItem>

  <TabItem label="Hashing">
    ```typescript
    // viem
    import { keccak256 } from "viem";
    const hash = keccak256("0x...");

    // Voltaire
    import { Keccak256 } from "@tevm/voltaire";
    const hash = Keccak256.hash("0x...");
    ```
  </TabItem>

  <TabItem label="ABI Encoding">
    ```typescript
    // viem
    import { encodeFunctionData } from "viem";
    const data = encodeFunctionData({
      abi: [...],
      functionName: "transfer",
      args: [address, amount],
    });

    // Voltaire
    import { Abi } from "@tevm/voltaire";
    const data = Abi.encodeFunction(
      { name: "transfer", inputs: [...] },
      [address, amount]
    );
    ```
  </TabItem>
</Tabs>

### From web3.js

<Tabs>
  <TabItem label="Addresses">
    ```typescript
    // web3.js
    import { toChecksumAddress } from "web3-utils";
    const addr = toChecksumAddress("0xa0cf...");

    // Voltaire
    import { Address } from "@tevm/voltaire";
    const addr = Address.from("0xa0cf...");
    const checksum = addr.toChecksummed();
    ```
  </TabItem>

  <TabItem label="Hashing">
    ```typescript
    // web3.js
    import { sha3 } from "web3-utils";
    const hash = sha3("hello");

    // Voltaire
    import { Keccak256 } from "@tevm/voltaire";
    const hash = Keccak256.hash("hello");
    ```
  </TabItem>
</Tabs>

## Next Steps

<CardGrid>
  <Card title="Core Primitives" icon="puzzle">
    Deep dive into Address, Hash, Uint, Transaction, RLP, ABI.

    [Explore primitives →](/primitives/address/)
  </Card>

  <Card title="Cryptography" icon="star">
    Learn Keccak-256, secp256k1, EIP-712, BIP-39, HD Wallets.

    [View crypto docs →](/crypto/keccak256/)
  </Card>

  <Card title="Branded Types" icon="seti:config">
    Understand the branded type pattern for type safety.

    [Read guide →](/primitives/branded-types/)
  </Card>

  <Card title="WASM Acceleration" icon="rocket">
    Optimize performance with Zig-compiled WASM modules.

    [View benchmarks →](/wasm/)
  </Card>

  <Card title="API Overview" icon="document">
    Learn universal patterns and design philosophy.

    [Read overview →](/overview/)
  </Card>

  <Card title="Zig API" icon="setting">
    Use Voltaire in native Zig applications.

    [View Zig docs →](/zig/)
  </Card>
</CardGrid>

## Design Principles

1. **Simple data structures** — Built on native JavaScript primitives (Uint8Array, bigint, string)
2. **Close-to-spec APIs** — Minimal abstraction over Ethereum primitives
3. **Built for humans and LLMs** — APIs and documentation designed for both developers and AI assistants
4. **Performance first** — Zero-overhead abstractions and optional WASM
5. **Type safety** — Branded types prevent common mistakes
6. **Tree-shakeable** — Pay only for what you use
7. **Multi-language** — TypeScript and Zig implementations
