---
title: Architecture
description: Deep dive into Voltaire's multi-language architecture
---

import { Tabs, TabItem, Card, CardGrid, Aside, FileTree } from '@astrojs/starlight/components';

# Architecture

Voltaire combines TypeScript, Zig, Rust, and C to deliver high-performance Ethereum primitives with excellent developer ergonomics.

## Multi-Language Stack

```
┌─────────────────────────────────────────────────┐
│             TypeScript API Layer                │
│   - Branded types (compile-time safety)         │
│   - Dual APIs (namespace + class)               │
│   - Tree-shakeable exports                      │
│   - Type definitions (.d.ts)                    │
├─────────────────────────────────────────────────┤
│              Performance Layers                 │
│  ┌──────────┬──────────┬──────────┬──────────┐ │
│  │   Zig    │   Rust   │     C    │   WASM   │ │
│  │ Primitives│ Crypto  │  Crypto  │ Browser  │ │
│  │  (FFI)   │ (static) │(static)  │  (web)   │ │
│  └──────────┴──────────┴──────────┴──────────┘ │
├─────────────────────────────────────────────────┤
│         Native Libraries & Dependencies         │
│  blst · c-kzg-4844 · libwally · arkworks       │
└─────────────────────────────────────────────────┘
```

### Layer Responsibilities

**TypeScript Layer:**
- API design and developer experience
- Type safety (branded types, generics)
- Pure JavaScript fallback implementations
- Documentation and examples

**Zig Layer:**
- High-performance primitive implementations
- FFI bindings for native libraries
- WASM compilation target
- Memory-efficient data structures

**Rust Layer:**
- Assembly-optimized cryptography (keccak-asm)
- Elliptic curve operations (arkworks)
- Compiled to static library (libcrypto_wrappers.a)

**C Layer:**
- Battle-tested crypto (blst, c-kzg-4844)
- Industry-standard implementations
- Linked as static libraries

**WASM Layer:**
- Browser-optimized builds
- Zero-copy data transfer
- 2-12x performance improvement

## FFI Boundaries

Voltaire uses Foreign Function Interface (FFI) to bridge TypeScript and native code:

```
TypeScript ←→ Bun FFI ←→ Zig ←→ Rust/C

Example: Keccak256 hash

1. TypeScript calls:
   Keccak256.hash(data: Uint8Array)

2. Bun FFI forwards to Zig:
   keccak256_hash(data_ptr, data_len, out_ptr)

3. Zig calls Rust:
   crypto_keccak256(input, output)

4. Rust executes:
   Assembly-optimized keccak implementation

5. Return through FFI:
   Zig ← Rust (status code)
   TypeScript ← Zig (hash bytes)
```

### Data Marshaling

**Zero-copy patterns:**

```typescript
// TypeScript creates buffer
const data = new Uint8Array(1024);
const output = new Uint8Array(32);

// Pass pointers to Zig (no copy)
nativeKeccak256(
  data.buffer,  // Direct memory pointer
  data.length,
  output.buffer
);

// Output written directly by native code
console.log(output); // Hash result
```

**Memory ownership:**
- TypeScript allocates input/output buffers
- Native code writes directly to buffers
- No allocations on native side for simple operations
- Complex operations use arena allocators (freed after call)

## Build System

Voltaire uses Zig's build system (`build.zig`) to orchestrate multi-language compilation:

### Build Targets

```bash
# Core builds
zig build                     # Full build (Zig + TS + C + Rust)
zig build test                # All Zig tests
zig build build-ts-native     # Native FFI (.dylib/.so)
zig build build-ts-wasm       # WASM (ReleaseSmall)
zig build build-ts-wasm-fast  # WASM (ReleaseFast)

# Individual crypto modules
zig build crypto-wasm         # Tree-shakeable WASM modules

# Quality checks
zig build format              # Format all code
zig build lint                # Lint TypeScript
zig build check               # Quick validation
zig build ci                  # Full CI pipeline
```

### Compilation Pipeline

```
1. Rust compilation:
   cargo build --release
   → libcrypto_wrappers.a

2. C library builds:
   - blst (BLS12-381)
   - c-kzg-4844 (KZG commitments)
   - libwally-core (HD wallet utils)

3. Zig compilation:
   - Links Rust + C libraries
   - Builds native shared library (.dylib/.so)
   - Builds WASM modules

4. TypeScript bundling:
   - tsup bundles source
   - tsc generates .d.ts types
   - Copies WASM files to dist/

5. Output:
   dist/
   ├── index.js (ESM)
   ├── index.cjs (CommonJS)
   ├── index.d.ts (Types)
   └── wasm/ (WASM modules)
```

## Module System

Voltaire uses a hierarchical module structure:

<FileTree>

- src/
  - primitives/
    - root.zig (Module entry point)
    - Address/
    - Hash/
    - Uint/
    - ...
  - crypto/
    - root.zig (Module entry point)
    - Keccak256/
    - Secp256k1/
    - ...
  - precompiles/
    - root.zig (Module entry point)
    - ecrecover.zig
    - sha256.zig
    - ...

</FileTree>

### Import Paths

**Zig imports:**
```zig
// Correct: Module imports
const primitives = @import("primitives");
const crypto = @import("crypto");
const Address = primitives.Address;

// Incorrect: Relative paths
// const Address = @import("../primitives/address.zig");
```

**TypeScript imports:**
```typescript
// Tree-shakeable (preferred)
import { fromHex, toChecksummed } from '@tevm/voltaire/Address';

// Class API
import { Address } from '@tevm/voltaire';

// WASM variant
import { Address } from '@tevm/voltaire/Address.wasm';

// Crypto modules
import { Keccak256 } from '@tevm/voltaire/Keccak256';
```

## Branded Type Pattern

Voltaire uses branded types to provide compile-time safety without runtime overhead:

### Type Definition

```typescript
// BrandedAddress.ts
export type BrandedAddress = Uint8Array & {
  readonly __tag: "Address";
};
```

### Internal Methods

```typescript
// toHex.js
/**
 * @param {import('./BrandedAddress.js').BrandedAddress} address
 * @returns {string}
 */
export function toHex(address) {
  return '0x' + Array.from(address)
    .map(b => b.toString(16).padStart(2, '0'))
    .join('');
}
```

### Dual Exports

```typescript
// index.ts
import { BrandedAddress } from './BrandedAddress.js';
import { toHex as _toHex } from './toHex.js';
import { from } from './from.js';

// Internal API (no conversion)
export { _toHex };

// Public API (auto-converts)
export function toHex(value: string | Uint8Array | BrandedAddress): string {
  return _toHex(from(value));
}
```

**Why this pattern?**
- `.js` extension: Better tree-shaking (no transpilation needed)
- JSDoc types: Type safety without TypeScript compilation
- Dual exports: Internal efficiency + public convenience
- Brand at compile-time: Zero runtime overhead

## Namespace Export Pattern

```typescript
// primitives/Address/index.ts
export * as Address from './index.js';

// Usage
import * as Address from '@tevm/voltaire/Address';
Address.fromHex("0x...");
Address.toChecksummed(addr);
```

**Benefits:**
- Tree-shakeable (only used methods bundled)
- Predictable API (Type.method() pattern)
- No class instantiation overhead
- Easy to override individual methods

## Performance Optimization Strategies

### 1. SIMD Instructions

Zig and Rust compilers leverage CPU SIMD instructions:

```zig
// Zig auto-vectorizes loops
for (input, output) |in_byte, *out_byte| {
  out_byte.* = in_byte ^ mask;
}
// Compiles to SIMD on supported platforms
```

### 2. Constant-Time Operations

Security-critical comparisons use constant-time algorithms:

```zig
// Constant-time equality
pub fn equals(a: []const u8, b: []const u8) bool {
  if (a.len != b.len) return false;
  var result: u8 = 0;
  for (a, b) |x, y| {
    result |= x ^ y;  // No early return
  }
  return result == 0;
}
```

### 3. Memory Pooling

Zig uses arena allocators for temporary allocations:

```zig
var arena = std.heap.ArenaAllocator.init(allocator);
defer arena.deinit();
const temp_allocator = arena.allocator();

// All allocations freed at once
const buffer = try temp_allocator.alloc(u8, size);
```

### 4. Zero-Copy Data Transfer

WASM uses linear memory for zero-copy:

```typescript
// TypeScript creates buffer
const buffer = new Uint8Array(32);

// WASM writes directly to buffer
wasmModule.exports.keccak256(
  buffer.byteOffset,  // Pointer to WASM memory
  buffer.length
);

// No copy needed
console.log(buffer);
```

## Dependency Management

### Zig Dependencies (build.zig.zon)

```zig
.{
  .name = "voltaire",
  .version = "0.1.0",
  .dependencies = .{
    .zbench = .{
      .url = "...",
      .hash = "...",
    },
    .clap = .{
      .url = "...",
      .hash = "...",
    },
  },
}
```

### Rust Dependencies (Cargo.toml)

```toml
[dependencies]
keccak-asm = { version = "0.1" }       # Native
tiny-keccak = { version = "2.0" }      # WASM

ark-bn254 = "0.4"
ark-bls12-381 = "0.4"
ark-ec = "0.4"
ark-ff = "0.4"

[features]
default = ["asm"]
asm = ["keccak-asm"]
portable = ["tiny-keccak"]
```

### C Libraries (Git Submodules)

```bash
lib/
├── blst/              # BLS12-381 signatures
├── c-kzg-4844/        # KZG commitments (EIP-4844)
└── libwally-core/     # HD wallet utilities
```

### Node Dependencies (package.json)

```json
{
  "dependencies": {
    "@scure/bip32": "^2.0.1",
    "@scure/bip39": "^2.0.1",
    "c-kzg": "^4.1.0"
  },
  "devDependencies": {
    "@noble/curves": "^2.0.1",
    "@noble/hashes": "^2.0.1",
    "ethers": "^6.13.4",
    "viem": "^2.21.54"
  }
}
```

## Testing Strategy

### Multi-Layer Testing

**Zig tests (inline):**
```zig
test "Address.fromHex" {
  const addr = try Address.fromHex("0x...");
  try testing.expectEqual(20, addr.len);
}
```

**TypeScript tests (separate files):**
```typescript
// Address.test.ts
import { describe, it, expect } from 'vitest';
import { Address } from './Address.js';

describe('Address.fromHex', () => {
  it('parses valid hex', () => {
    const addr = Address.fromHex("0x...");
    expect(addr).toBeInstanceOf(Uint8Array);
  });
});
```

**Cross-validation:**
```typescript
// Validate Zig matches JS
it('Zig and JS produce same result', () => {
  const jsAddr = JsAddress.fromHex("0x...");
  const zigAddr = ZigAddress.fromHex("0x...");
  expect(jsAddr).toEqual(zigAddr);
});
```

**Benchmark tests:**
```typescript
// Address.bench.ts
bench("Address.fromHex - JS", () => {
  JsAddress.fromHex("0x...");
});

bench("Address.fromHex - Zig", () => {
  ZigAddress.fromHex("0x...");
});
```

## Security Considerations

### 1. Constant-Time Comparisons

All security-critical comparisons use constant-time algorithms to prevent timing attacks.

### 2. Memory Sanitization

Sensitive data is zeroed after use:

```zig
defer std.mem.set(u8, private_key, 0);
```

### 3. Input Validation

All inputs validated before processing:

```typescript
if (!isValidHex(input)) {
  throw new InvalidHexError("Invalid hex string");
}
```

### 4. Dependency Auditing

- Regular `bun audit` checks
- Pinned dependency versions
- Known-good crypto libraries (blst, noble)

## Related Documentation

<CardGrid>
  <Card title="Overview" icon="open-book">
    Design philosophy and patterns.

    [View →](/overview/)
  </Card>

  <Card title="WASM Acceleration" icon="star">
    WASM compilation and optimization.

    [View →](/wasm/)
  </Card>

  <Card title="Performance" icon="random">
    Benchmarks and optimization tips.

    [View →](/performance/)
  </Card>

  <Card title="Getting Started" icon="rocket">
    Quick start guide and examples.

    [View →](/getting-started/)
  </Card>
</CardGrid>
