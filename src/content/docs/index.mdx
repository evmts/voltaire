---
title: Voltaire
description: Ethereum primitives and cryptography library for TypeScript and Zig
template: splash
hero:
  tagline: Fast, Type-Safe Ethereum Primitives Built on Simple Data Structures
  actions:
    - text: Quick Start
      link: /quick-start/
      icon: rocket
      variant: primary
    - text: Get Started
      link: /getting-started/
      icon: right-arrow
    - text: View on GitHub
      link: https://github.com/evmts/voltaire
      icon: external
      attrs:
        target: _blank
        rel: noopener noreferrer
---

import { Card, CardGrid, Tabs, TabItem, Aside } from '@astrojs/starlight/components';

## Why Voltaire?

**Simple, standards-based Ethereum library** that works the way you think. Built on native JavaScript primitives (`Uint8Array`, `bigint`, `string`) with zero-overhead abstractions and optional Zig-compiled WASM for performance.

```typescript
import { Keccak256, Secp256k1, Address } from "@tevm/voltaire";

// Hash data
const messageHash = Keccak256.hash("Hello Ethereum");

// Sign with private key
const signature = Secp256k1.sign(messageHash, privateKey);

// Recover signer address
const signer = Secp256k1.recoverAddress(messageHash, signature);
```

## Installation

<Tabs syncKey="pm">
  <TabItem label="npm">
    ```bash
    npm install @tevm/voltaire
    ```
  </TabItem>
  <TabItem label="bun">
    ```bash
    bun add @tevm/voltaire
    ```
  </TabItem>
  <TabItem label="pnpm">
    ```bash
    pnpm add @tevm/voltaire
    ```
  </TabItem>
  <TabItem label="yarn">
    ```bash
    yarn add @tevm/voltaire
    ```
  </TabItem>
</Tabs>

## Features

<CardGrid>
  <Card title="Type-Safe Addresses with Checksumming" icon="approve-check">
    Branded types prevent mixing incompatible values. EIP-55 checksumming built-in.

    ```typescript
    const addr = Address.from("0xa0cf...");
    addr.toChecksummed(); // "0xA0Cf..."
    ```

    [Learn more →](/primitives/address/)
  </Card>

  <Card title="Fast Cryptography (Keccak, secp256k1, BLS)" icon="rocket">
    Native Zig implementations via WASM. 2-3x faster than pure JavaScript.

    ```typescript
    const hash = Keccak256.hash(data);
    const sig = Secp256k1.sign(hash, key);
    ```

    [Learn more →](/crypto/keccak256/)
  </Card>

  <Card title="Tree-Shakeable (Pay for What You Use)" icon="star">
    Import only the functions you need. Unused code automatically excluded.

    ```typescript
    import { fromHex, toChecksummed }
      from "@tevm/voltaire/Address";
    ```

    [Learn more →](/overview/)
  </Card>

  <Card title="Transaction Encoding & Signing (EIP-1559)" icon="pencil">
    Full support for legacy, EIP-2930, EIP-1559, and EIP-4844 transactions.

    ```typescript
    const signed = Transaction.sign(tx, key);
    const sender = Transaction.recoverSender(tx);
    ```

    [Learn more →](/primitives/transaction/)
  </Card>

  <Card title="ABI Encoding & Decoding" icon="seti:config">
    Type-safe ABI encoding with abitype integration.

    ```typescript
    const encoded = Abi.encodeFunction({
      name: "transfer",
      inputs: [address, amount]
    });
    ```

    [Learn more →](/primitives/abi/)
  </Card>

  <Card title="Multi-Language (TypeScript + Zig)" icon="puzzle">
    Use in TypeScript/JavaScript or native Zig. Same API, your choice.

    ```zig
    const addr = try Address.fromHex("0x...");
    ```

    [Learn more →](/zig/)
  </Card>
</CardGrid>

## Performance

Voltaire is built for speed with optional WASM acceleration:

| Operation | JavaScript | Voltaire (WASM) | Speedup |
|-----------|------------|-----------------|---------|
| Keccak256 hash | 12.5 µs | 4.2 µs | **3x faster** |
| secp256k1 sign | 145 µs | 52 µs | **2.8x faster** |
| Address checksum | 18 µs | 6.5 µs | **2.7x faster** |
| RLP encode | 8.2 µs | 3.1 µs | **2.6x faster** |

<Aside type="tip">
  WASM modules are optional. Use pure JavaScript for simplicity or WASM for performance-critical paths.
</Aside>

**Bundle Impact:** Tree-shakeable design keeps bundles small.

```typescript
// Only imports what you use
import { fromHex, toChecksummed } from "@tevm/voltaire/Address";
// Bundle: ~500 bytes (no keccak)

import { Address } from "@tevm/voltaire";
// Bundle: ~18 KB (includes keccak for checksumming)
```

[View detailed benchmarks →](/wasm/)

## Quick Examples

### Working with Addresses

```typescript
import { Address } from "@tevm/voltaire";

// Create from various formats
const addr = Address.from("0xa0cf798816d4b9b9866b5330eea46a18382f251e");

// EIP-55 checksumming
console.log(addr.toChecksummed());
// "0xA0Cf798816D4b9b9866b5330EEa46A18382f251e"

// Calculate contract address
const deployer = Address.from("0x742d35Cc6634C0532925a3b844Bc9e7595f0bEb2");
const contractAddr = deployer.calculateCreateAddress(0n);

// Check validity
Address.isValid("0x..."); // true/false
```

### Hashing & Signatures

```typescript
import { Keccak256, Secp256k1 } from "@tevm/voltaire";

// Hash message
const message = "Sign in to dApp";
const messageHash = Keccak256.hash(message);

// Sign with private key
const privateKey = "0x...";
const signature = Secp256k1.sign(messageHash, privateKey);

// Recover signer
const signer = Secp256k1.recoverAddress(messageHash, signature);

// Verify signature
const isValid = Secp256k1.verify(messageHash, signature, publicKey);
```

### Transaction Handling

```typescript
import { Transaction } from "@tevm/voltaire";

// EIP-1559 transaction
const tx = {
  type: 2,
  chainId: 1n,
  nonce: 0n,
  maxFeePerGas: 30_000_000_000n,
  maxPriorityFeePerGas: 1_000_000_000n,
  gasLimit: 21_000n,
  to: recipientAddress,
  value: 1_000_000_000_000_000_000n, // 1 ETH
  data: new Uint8Array(),
};

// Sign transaction
const signed = Transaction.sign(tx, privateKey);

// Serialize for broadcasting
const serialized = Transaction.serialize(signed);

// Recover sender
const sender = Transaction.recoverSender(signed);
```

### ABI Encoding

```typescript
import { Abi } from "@tevm/voltaire";

// Encode function call
const encoded = Abi.encodeFunction({
  name: "transfer",
  type: "function",
  inputs: [
    { name: "to", type: "address" },
    { name: "amount", type: "uint256" }
  ],
  outputs: [{ type: "bool" }]
}, ["0x...", 1000000000000000000n]);

// Decode function result
const decoded = Abi.decodeFunction(abi, data);
```

## Next Steps

<CardGrid>
  <Card title="Quick Start" icon="rocket">
    Get running in 3 minutes with a complete example.

    [Start now →](/quick-start/)
  </Card>

  <Card title="Getting Started" icon="document">
    Learn core concepts, patterns, and architecture.

    [Read guide →](/getting-started/)
  </Card>

  <Card title="Core Primitives" icon="puzzle">
    Explore Address, Hash, Uint, Transaction, RLP, ABI.

    [Browse primitives →](/primitives/address/)
  </Card>

  <Card title="Cryptography" icon="star">
    Dive into Keccak-256, secp256k1, BLS, HD Wallets.

    [View crypto →](/crypto/keccak256/)
  </Card>
</CardGrid>

## Zig Installation

Use Voltaire in native Zig applications:

<Tabs>
  <TabItem label="Versioned">
    ```bash
    zig fetch --save https://github.com/evmts/voltaire/archive/refs/tags/v0.1.0.tar.gz
    ```
  </TabItem>
  <TabItem label="Latest">
    ```bash
    zig fetch --save git+https://github.com/evmts/voltaire
    ```
  </TabItem>
  <TabItem label="Build from Source">
    ```bash
    git clone https://github.com/evmts/voltaire.git
    cd voltaire
    zig build --help
    ```
  </TabItem>
</Tabs>

[View Zig documentation →](/zig/)
