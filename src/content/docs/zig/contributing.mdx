---
title: Contributing to Zig
description: Code style, patterns, and guidelines for Zig development
---

# Contributing to Voltaire Zig

This guide covers code style, patterns, and best practices for contributing to Voltaire's Zig implementation.

## Philosophy

**Every line correct. No stubs. No commented tests.**

- Simple imperative code over abstractions
- Return memory to caller, minimize allocations
- Self-contained tests, fix failures immediately
- Evidence-based debugging

## Code Style

### Variable Naming

**Single word variables** for simple cases:
```zig
// ✅ Good
const n = data.len;
const result = hash.toHex();

// ❌ Avoid
const numberOfBytes = data.len;
const resultingHashValue = hash.toHex();
```

**Descriptive names** when needed:
```zig
// ✅ Good
const top = stack.pop();
const signature = try secp256k1.sign(message, private_key);

// ❌ Avoid
const a = stack.pop();
const s = try secp256k1.sign(message, private_key);
```

### Function Organization

**Inline code by default** - Don't abstract unless reused:

```zig
// ✅ Good - Simple, clear logic in one place
pub fn validate(address: []const u8) bool {
    if (address.len != 20) return false;
    for (address) |byte| {
        if (byte == 0 and isZeroRestricted()) return false;
    }
    return true;
}

// ❌ Avoid - Unnecessary abstraction
fn isZeroRestricted() bool { return true; }
fn checkLength(addr: []const u8) bool { return addr.len == 20; }
```

**Long imperative function bodies are good** when they tell a clear story.

### Memory Management

Return memory to the caller when possible:

```zig
// ✅ Good - Caller owns memory
pub fn fromHex(allocator: Allocator, hex: []const u8) ![]u8 {
    const result = try allocator.alloc(u8, hex.len / 2);
    // ... populate result
    return result;
}

// ❌ Avoid - Internal allocation without caller control
pub fn fromHex(hex: []const u8) ![]u8 {
    var arena = std.heap.ArenaAllocator.init(std.heap.page_allocator);
    defer arena.deinit();
    // ... result is freed!
}
```

### Cleanup with defer

Always use `defer` and `errdefer` for cleanup:

```zig
pub fn processData(allocator: Allocator, data: []const u8) !Result {
    var list = std.ArrayList(u8){};
    defer list.deinit(allocator);

    const buffer = try allocator.alloc(u8, 1024);
    errdefer allocator.free(buffer);

    // ... process data
    return result;
}
```

## Zig 0.15.1 Patterns

### ArrayList (UNMANAGED in 0.15.1)

```zig
// ✅ Correct for 0.15.1
var list = std.ArrayList(T){};
defer list.deinit(allocator);
try list.append(allocator, item);

// ❌ Wrong - Old API (pre-0.15.1)
var list = std.ArrayList(T).init(allocator);
defer list.deinit();
try list.append(item);
```

**Important**: In Zig 0.15.1, most data structures are unmanaged by default. Always pass allocator to methods.

### Module Imports

```zig
// ✅ Correct - Use module imports
const primitives = @import("primitives");
const crypto = @import("crypto");
const Address = primitives.Address;

// ❌ Wrong - Relative paths
const Address = @import("../primitives/address.zig");
```

### Error Handling

Be specific with error types:

```zig
// ✅ Good
pub const ValidationError = error{
    InvalidLength,
    InvalidChecksum,
    InvalidPrefix,
};

pub fn validate(addr: []const u8) ValidationError!void {
    if (addr.len != 20) return error.InvalidLength;
    // ...
}

// ❌ Avoid generic errors when specific ones clarify intent
pub fn validate(addr: []const u8) !void { ... }
```

## Security Practices

### Constant-Time Operations

Critical for cryptography:

```zig
// ✅ Constant-time comparison
pub fn equals(a: []const u8, b: []const u8) bool {
    if (a.len != b.len) return false;
    var result: u8 = 0;
    for (a, b) |x, y| {
        result |= x ^ y;
    }
    return result == 0;
}

// ❌ NOT constant-time - leaks timing info
pub fn equals(a: []const u8, b: []const u8) bool {
    if (a.len != b.len) return false;
    for (a, b) |x, y| {
        if (x != y) return false;  // Early return!
    }
    return true;
}
```

### Input Validation

Always validate before processing:

```zig
pub fn sign(message: []const u8, private_key: []const u8) !Signature {
    // Validate inputs
    if (message.len == 0) return error.EmptyMessage;
    if (private_key.len != 32) return error.InvalidKeyLength;

    // Validate key is in valid range
    if (!isValidPrivateKey(private_key)) return error.InvalidKey;

    // Process
    // ...
}
```

### Clear Sensitive Data

```zig
pub fn sign(message: []const u8, private_key: []const u8) !Signature {
    var key_copy: [32]u8 = undefined;
    @memcpy(&key_copy, private_key);
    defer @memset(&key_copy, 0);  // Clear after use

    // ... use key_copy
}
```

## Testing

### Inline Tests

Tests live in source files:

```zig
const std = @import("std");

pub fn fromHex(hex: []const u8) ![20]u8 {
    // implementation
}

test "fromHex with valid address" {
    const result = try fromHex("0x742d35Cc6634C0532925a3b844Bc9e7595f0bEb");
    try std.testing.expectEqual(20, result.len);
}

test "fromHex with invalid length" {
    try std.testing.expectError(error.InvalidLength, fromHex("0x123"));
}
```

### Test Patterns

**Self-contained tests**:
```zig
test "complete scenario" {
    const allocator = std.testing.allocator;

    // Setup
    const input = try allocator.alloc(u8, 32);
    defer allocator.free(input);
    @memset(input, 0xFF);

    // Execute
    const result = try process(input);
    defer allocator.free(result);

    // Verify
    try std.testing.expectEqual(32, result.len);
}
```

**Known test vectors** for crypto:
```zig
test "keccak256 with known vector" {
    // From Ethereum Yellow Paper
    const input = "testing";
    const expected = "5f16f4c7f149ac4f9510d9cf8cf384038ad348b3bcdc01915f95de12df9d1b02";

    const result = try keccak256(input);
    const hex = try result.toHex();
    try std.testing.expectEqualStrings(expected, hex);
}
```

### Debug Output

No output = passed. For debugging:

```zig
test "debug example" {
    std.testing.log_level = .debug;
    std.log.debug("value: {}", .{some_value});

    // ... test logic
}
```

## Benchmarking

Use zbench for Zig benchmarks:

```zig
const zbench = @import("zbench");

fn benchKeccak256(allocator: Allocator) void {
    const data = "Hello, World!";
    _ = keccak256(data) catch unreachable;
}

pub fn main() !void {
    const stdout = std.io.getStdOut().writer();

    var bench = zbench.Benchmark.init(allocator, .{});
    defer bench.deinit();

    try bench.add("keccak256", benchKeccak256, .{});
    try stdout.writeAll("\n");
    try bench.run(stdout);
}
```

Run with:
```bash
zig build bench
zig build -Dbench-filter=keccak
```

## Documentation

### Module Documentation

Document modules in `root.zig`:

```zig
//! Address primitive for Ethereum addresses.
//!
//! Provides zero-copy operations for 20-byte Ethereum addresses:
//! - Parsing from hex strings
//! - Checksum validation (EIP-55)
//! - Conversion utilities
//!
//! Example:
//! ```zig
//! const addr = try Address.fromHex("0x742d35Cc...");
//! const checksum = try addr.toChecksum();
//! ```
```

### Function Documentation

```zig
/// Parse address from hexadecimal string.
///
/// Accepts both checksummed and non-checksummed addresses.
/// Validates length and format.
///
/// Returns: 20-byte address array
/// Errors: InvalidLength, InvalidCharacter
pub fn fromHex(hex: []const u8) ![20]u8 {
    // ...
}
```

## Common Patterns

### Ownership Planning

Think about ownership and deallocation:

```zig
// Pattern 1: Caller owns (common)
pub fn create(allocator: Allocator) ![]u8 {
    return try allocator.alloc(u8, 32);  // Caller must free
}

// Pattern 2: No allocation (preferred when possible)
pub fn hash(input: []const u8) [32]u8 {
    var result: [32]u8 = undefined;
    // ... compute hash
    return result;  // No allocation!
}

// Pattern 3: Internal arena (rare, document clearly)
pub fn buildComplex(allocator: Allocator) !Result {
    var arena = std.heap.ArenaAllocator.init(allocator);
    defer arena.deinit();  // Frees all at once
    const arena_alloc = arena.allocator();
    // ... build result using arena_alloc
}
```

### Type Safety

Use distinct types over primitives:

```zig
// ✅ Good - Type safety
pub const Address = struct {
    bytes: [20]u8,

    pub fn fromHex(hex: []const u8) !Address {
        // ...
    }
};

// ❌ Avoid - Easy to mix up
pub fn fromHex(hex: []const u8) ![20]u8 { ... }
```

## Workflow Tips

### Run from Root

```bash
# ✅ Good - Run from repo root
zig build test

# ❌ Avoid - Don't cd unless user requests
cd src/primitives && zig build test
```

### Fix Immediately

**Producing a failing minimal reproduction in a test is the best way to fix a bug.**

```zig
test "reproduce bug #123" {
    // Minimal failing case
    const input = "0x00";
    try std.testing.expectError(error.InvalidInput, process(input));
}
```

### TDD Cycle

1. Write failing test
2. Run `zig build test`
3. Implement feature
4. Run `zig build test`
5. Iterate until green

## Resources

- [Zig 0.15.1 Documentation](https://ziglang.org/documentation/0.15.1/)
- [Ethereum Yellow Paper](https://ethereum.github.io/yellowpaper/paper.pdf)
- [EIPs](https://eips.ethereum.org/)

## Getting Help

- File issues at [github.com/evmts/voltaire](https://github.com/evmts/voltaire/issues)
- Check existing tests for patterns
- Read module documentation in `root.zig` files
