---
title: Hex WASM Implementation
description: WebAssembly-accelerated hex operations
---

# WASM Implementation

WebAssembly-accelerated hex operations compiled from Zig for performance-critical paths.

## Overview

Voltaire includes WASM implementations of core hex operations compiled from Zig. These provide:
- **Performance**: Native speed for hex/bytes conversions
- **Zero-copy**: Direct memory access when possible
- **Compatibility**: Automatic fallback to JavaScript
- **Transparency**: Drop-in replacement for JS implementation

## WASM Module

### Available Functions

```typescript
// WASM exports
export function hexToBytes(hex: string): Uint8Array
export function bytesToHex(data: Uint8Array): string
```

Defined in: [primitives/Hex/Hex.wasm.ts](https://github.com/evmts/primitives/blob/main/src/primitives/Hex/Hex.wasm.ts)

## Usage

### Direct WASM Import

```typescript
import * as HexWasm from '@tevm/voltaire/Hex/Hex.wasm'

// Convert hex to bytes (WASM-accelerated)
const bytes = HexWasm.hexToBytes("0x1234")
console.log(bytes)  // Uint8Array([0x12, 0x34])

// Convert bytes to hex (WASM-accelerated)
const hex = HexWasm.bytesToHex(new Uint8Array([0x12, 0x34]))
console.log(hex)  // "0x1234"
```

### Automatic WASM Usage

The standard `Hex` API automatically uses WASM when available:

```typescript
import { Hex } from '@tevm/voltaire'

// These use WASM internally if loaded
const hex = Hex.fromBytes(new Uint8Array([0x12, 0x34]))
const bytes = Hex.toBytes(hex)
```

## Implementation Details

### hexToBytes(hex)

Converts hex string to byte array using WASM.

```typescript
import { hexToBytes } from '@tevm/voltaire/Hex/Hex.wasm'

const bytes = hexToBytes("0x1234")  // Uint8Array([0x12, 0x34])
const bytes2 = hexToBytes("1234")   // Also accepts without 0x
```

**Parameters:**
- `hex: string` - Hex string (with or without `0x` prefix)

**Returns:** `Uint8Array` - Raw bytes

**Performance:** ~2-3x faster than JavaScript for large hex strings (greater than 1KB)

### bytesToHex(data)

Converts byte array to hex string using WASM.

```typescript
import { bytesToHex } from '@tevm/voltaire/Hex/Hex.wasm'

const hex = bytesToHex(new Uint8Array([0x12, 0x34]))  // "0x1234"
```

**Parameters:**
- `data: Uint8Array` - Raw bytes

**Returns:** `string` - Hex string with `0x` prefix

**Performance:** ~2-3x faster than JavaScript for large arrays (greater than 1KB)

## WASM Loading

### Automatic Loading

WASM module loads automatically on first use:

```typescript
import { Hex } from '@tevm/voltaire'

// First call triggers WASM load (async)
const hex = Hex.fromBytes(bytes)

// Subsequent calls use loaded WASM
const hex2 = Hex.fromBytes(bytes2)
```

### Manual Preloading

```typescript
import * as loader from '@tevm/voltaire/wasm-loader/loader'

// Preload WASM module
await loader.initialize()

// Now WASM is ready
import { Hex } from '@tevm/voltaire'
const hex = Hex.fromBytes(bytes)  // Uses WASM immediately
```

## Performance Characteristics

### When WASM is Faster

WASM provides significant speedup for:
- **Large hex strings** (greater than 1KB): 2-3x faster
- **Repeated conversions**: Amortizes initialization
- **High-throughput**: Processing many values

### When JavaScript is Faster

JavaScript may be faster for:
- **Small strings** (`less than 100 bytes`): WASM overhead dominates
- **One-off conversions**: Initialization cost not amortized
- **Cold starts**: Initial WASM load adds latency

### Benchmark Results

```typescript
// Approximate timings on modern hardware

// Small (20 bytes - address)
JavaScript: 0.001ms
WASM:       0.002ms  // Overhead not worth it

// Medium (256 bytes)
JavaScript: 0.010ms
WASM:       0.008ms  // ~20% faster

// Large (32KB)
JavaScript: 1.2ms
WASM:       0.4ms    // ~3x faster
```

## Environment Support

### Browser

WASM automatically loads in browsers with WebAssembly support:
- Chrome 57+
- Firefox 52+
- Safari 11+
- Edge 16+

### Node.js

WASM works in Node.js 8.0+:

```javascript
// Node.js
import { Hex } from '@tevm/voltaire'
const hex = Hex.fromBytes(bytes)  // Uses WASM
```

### Deno

```typescript
// Deno
import { Hex } from 'npm:@tevm/voltaire'
const hex = Hex.fromBytes(bytes)  // Uses WASM
```

### Bun

```typescript
// Bun
import { Hex } from '@tevm/voltaire'
const hex = Hex.fromBytes(bytes)  // Uses WASM
```

## Fallback Behavior

If WASM fails to load, operations automatically fall back to JavaScript:

```typescript
import { Hex } from '@tevm/voltaire'

// Always works - WASM or JavaScript
const hex = Hex.fromBytes(bytes)
```

Fallback happens when:
- WASM not supported in environment
- WASM file failed to load
- Security policy blocks WASM

## Zig Source

WASM compiled from Zig source in `/src/zig/`:

```zig
// Simplified Zig implementation
pub fn hexToBytes(hex: []const u8) []u8 {
    // Efficient hex parsing in Zig
    // Compiled to WASM
}

pub fn bytesToHex(bytes: []const u8) []u8 {
    // Efficient hex formatting in Zig
    // Compiled to WASM
}
```

Build command:

```bash
zig build -Drelease-fast
```

Output: `/src/wasm-loader/primitives.wasm`

## Memory Management

### Zero-Copy Operations

WASM operations use shared linear memory:

```typescript
const bytes = new Uint8Array(1000)
const hex = bytesToHex(bytes)
// Bytes copied to WASM linear memory
// Hex string copied back to JavaScript
```

**Note:** Small overhead for copying data across boundary. Beneficial for large operations only.

### Memory Limits

WASM module has initial memory allocation:
- Initial: 1MB
- Maximum: 16MB (configurable)

Handles typical Ethereum values (addresses, hashes, transactions).

## Debugging

### Check if WASM Loaded

```typescript
import * as loader from '@tevm/voltaire/wasm-loader/loader'

if (loader.isInitialized()) {
  console.log("WASM is loaded and ready")
} else {
  console.log("Using JavaScript fallback")
}
```

### Force JavaScript Fallback

For testing or debugging:

```typescript
// Set before any imports
globalThis.__VOLTAIRE_FORCE_JS__ = true

import { Hex } from '@tevm/voltaire'
// Now uses JavaScript even if WASM available
```

## Bundle Size Impact

### With WASM

```
primitives.wasm: ~117KB (binary)
WASM loader:     ~2KB (JavaScript)
Total:           ~119KB
```

### Without WASM

```
JavaScript impl: ~3KB
```

**Trade-off:** 116KB additional for 2-3x performance on large operations.

### Tree-Shaking

WASM module is separate import:

```typescript
// Small bundle - no WASM
import { Hex } from '@tevm/voltaire'

// Explicitly include WASM
import '@tevm/voltaire/Hex/Hex.wasm'
```

## Use Cases

### When to Use WASM

- Processing large transaction data
- Batch conversions (greater than 100 values)
- High-throughput applications
- Performance-critical paths

### When to Skip WASM

- Small values only (addresses, selectors)
- Infrequent conversions
- Bundle size constrained
- Serverless/edge functions (cold start penalty)

## Configuration

### Build Options

```json
// tsconfig.json
{
  "compilerOptions": {
    "target": "ES2020",  // Required for WASM
    "module": "ESNext"
  }
}
```

### Webpack

```javascript
// webpack.config.js
module.exports = {
  experiments: {
    asyncWebAssembly: true
  }
}
```

### Vite

```javascript
// vite.config.js
export default {
  optimizeDeps: {
    exclude: ['@tevm/voltaire/wasm-loader/primitives.wasm']
  }
}
```

## Related

- [Constructors](/primitives/hex/constructors) - `fromBytes()` uses WASM
- [Conversions](/primitives/hex/conversions) - `toBytes()` uses WASM
- [BrandedHex](/primitives/hex/branded-hex) - Tree-shakeable API
