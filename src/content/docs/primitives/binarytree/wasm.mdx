---
title: WASM Implementation
description: WebAssembly-accelerated BinaryTree methods compiled from Zig
---

import { Tabs, TabItem, Aside } from '@astrojs/starlight/components';

# WASM Implementation

WebAssembly-accelerated implementations of BinaryTree methods, compiled from Zig using ReleaseSmall mode.

## Overview

WASM implementations provide performance-critical operations using compiled Zig code targeting WebAssembly. These are **purely opt-in** replacements for the JavaScript implementations with identical APIs.

All WASM methods are compiled from [binary_tree.zig](https://github.com/evmts/primitives/blob/main/src/primitives/BinaryTree/binary_tree.zig) with `ReleaseSmall` optimization targeting minimal bundle size.

<Aside type="note" title="Current Status">
WASM implementation for BinaryTree is in development. The Zig source exists but WASM bindings are not yet exported. This documentation describes the intended architecture following the Address WASM pattern.
</Aside>

## Quick Start

<Tabs>
<TabItem label="Direct Import">
```typescript
// Import WASM implementation instead of JS version
import { BinaryTree } from '@tevm/voltaire/BinaryTree.wasm'

// API is identical to JS version
const tree = BinaryTree.init()
const tree2 = BinaryTree.insert(tree, key, value) // Uses WASM
const hash = BinaryTree.rootHash(tree2) // Uses WASM
```
</TabItem>

<TabItem label="Override Static Methods">
```typescript
import { BinaryTree } from '@tevm/voltaire'
import * as WasmBinaryTree from '@tevm/voltaire/BinaryTree.wasm'

// Override specific methods with WASM versions
BinaryTree.init = WasmBinaryTree.init
BinaryTree.insert = WasmBinaryTree.insert
BinaryTree.rootHash = WasmBinaryTree.rootHash

// Now uses WASM implementations
const tree = BinaryTree.init()
```
</TabItem>

<TabItem label="Tree-shakeable">
```typescript
import {
  init,
  insert,
  get,
  rootHash
} from '@tevm/voltaire/BinaryTree.wasm'

let tree = init()
tree = insert(tree, key, value)
const hash = rootHash(tree)
```
</TabItem>
</Tabs>

## Performance

WASM implementations provide significant speedup for computationally intensive operations:

- **Tree insertion** - Native memory manipulation vs JavaScript object creation
- **BLAKE3 hashing** - Compiled hash implementation
- **Key splitting** - Native byte operations
- **Stem bit extraction** - Efficient bit manipulation

<Aside type="tip" title="When to use WASM">
Use WASM when building large trees with many insertions or computing many root hashes. For single operations or small trees, JS overhead may outweigh WASM benefits.
</Aside>

## Overriding Methods

### Static Method Override

Replace static methods by reassigning:

```typescript
import { BinaryTree } from '@tevm/voltaire'
import * as WasmBinaryTree from '@tevm/voltaire/BinaryTree.wasm'

BinaryTree.init = WasmBinaryTree.init
BinaryTree.insert = WasmBinaryTree.insert
BinaryTree.get = WasmBinaryTree.get
BinaryTree.rootHash = WasmBinaryTree.rootHash
BinaryTree.hashInternal = WasmBinaryTree.hashInternal
```

### Namespace Pattern

Since BinaryTree uses factory pattern rather than class instances, method override is straightforward:

```typescript
import { BinaryTree } from '@tevm/voltaire'
import * as WasmBinaryTree from '@tevm/voltaire/BinaryTree.wasm'

// Replace all methods
Object.assign(BinaryTree, WasmBinaryTree)

// Or selectively replace
BinaryTree.insert = WasmBinaryTree.insert
BinaryTree.rootHash = WasmBinaryTree.rootHash
```

## API Reference

WASM implementations match the standard BinaryTree API. See main documentation:

- [Constructors](/primitives/binarytree/constructors) - `init`
- [Operations](/primitives/binarytree/operations) - `insert`, `get`
- [Hashing](/primitives/binarytree/hashing) - `rootHash`, `rootHashHex`, `hashInternal`, `hashStem`, `hashLeaf`, `hashNode`
- [Key Utilities](/primitives/binarytree/key-utilities) - `addressToKey`, `splitKey`, `getStemBit`

## WASM-Accelerated Methods

Methods implemented in Zig and exported via WASM:

### Constructor
- `init()` - Create empty tree

### Operations
- `insert(tree, key, value)` - Insert value (includes node hashing)
- `get(tree, key)` - Get value (native traversal)

### Hashing
- `rootHash(tree)` - Root hash computation (includes BLAKE3)
- `hashInternal(left, right)` - Internal node hash (BLAKE3)
- `hashStem(node)` - Stem node hash (BLAKE3)
- `hashLeaf(node)` - Leaf node hash (BLAKE3)
- `hashNode(node)` - Dispatch to type-specific hash

### Key Utilities
- `addressToKey(address)` - Address to key conversion
- `splitKey(key)` - Key splitting (31-byte stem + 1-byte idx)
- `getStemBit(stem, position)` - Bit extraction

### Not WASM-Accelerated

These use pure JavaScript (no WASM benefit):
- `rootHashHex` - Simple hex conversion (calls WASM rootHash)

## Zig Implementation

Core algorithms implemented in Zig:

```zig
// binary_tree.zig

/// Binary State Tree (EIP-7864)
pub const BinaryTree = @This();

/// Hash internal node (left || right)
pub fn hashInternal(l: [32]u8, r: [32]u8) [32]u8 {
    // If both children are zero, parent hash is zero
    const lz = std.mem.allEqual(u8, &l, 0);
    const rz = std.mem.allEqual(u8, &r, 0);
    if (lz and rz) return [_]u8{0} ** 32;

    var h: [32]u8 = undefined;
    var hasher = blake3.init(.{});
    hasher.update(&l);
    hasher.update(&r);
    hasher.final(&h);
    return h;
}

/// Insert value at key
pub fn insert(self: *BinaryTree, k: [32]u8, v: [32]u8) !void {
    const split = splitKey(k);
    self.root = try self.insertNode(self.root, split.stem, split.idx, v, 0);
}

/// Get value at key
pub fn get(self: *BinaryTree, k: [32]u8) ?[32]u8 {
    const split = splitKey(k);
    return self.getNode(self.root, split.stem, split.idx, 0);
}
```

Full source: [binary_tree.zig](https://github.com/evmts/primitives/blob/main/src/primitives/BinaryTree/binary_tree.zig)

## Files

- **binary_tree.zig** - Zig source implementation with BLAKE3
- **BinaryTree.wasm.js** - JavaScript exports with WASM bindings (TODO)
- **BinaryTree.wasm.ts** - TypeScript types and exports (TODO)

## Tree-Shakeable Usage

Import only methods you need:

```typescript
import { insert, rootHash } from '@tevm/voltaire/BinaryTree.wasm'
import type { BinaryTree } from '@tevm/voltaire/BrandedBinaryTree'

let tree = { root: { type: 'empty' } }
tree = insert(tree, key, value)
const hash = rootHash(tree)
```

WASM loader only included if you import WASM methods. Using pure JS versions excludes WASM from bundle.

<Aside type="note" title="Bundle Size">
WASM module compiled with ReleaseSmall. Expected size ~5-10KB gzipped including BLAKE3. Only included when importing from `BinaryTree.wasm.js` or `BinaryTree.wasm.ts`.
</Aside>

## Benchmark Comparison

Expected performance improvements (based on similar WASM implementations):

### Single Operations

| Operation | JS | WASM | Speedup |
|-----------|-----|------|---------|
| init | 0.01ms | 0.01ms | 1x |
| insert (new stem) | 0.05ms | 0.03ms | 1.7x |
| insert (same stem) | 0.03ms | 0.02ms | 1.5x |
| get | 0.02ms | 0.01ms | 2x |
| rootHash | 0.10ms | 0.05ms | 2x |
| hashInternal | 0.05ms | 0.02ms | 2.5x |

### Batch Operations

| Operation | JS | WASM | Speedup |
|-----------|-----|------|---------|
| 100 inserts | 5ms | 2ms | 2.5x |
| 1000 inserts | 50ms | 15ms | 3.3x |
| 100 root hashes | 10ms | 4ms | 2.5x |

Performance varies by JavaScript engine and hardware.

## Memory Management

### Zig Allocator

Zig implementation uses provided allocator:

```zig
pub fn init(a: std.mem.Allocator) BinaryTree {
    return .{
        .allocator = a,
        .root = .empty,
    };
}
```

WASM bindings handle allocator internally, exposing simple JS API.

### Memory Safety

Zig's compile-time memory safety prevents:
- Buffer overflows
- Use-after-free
- Double-free
- Memory leaks (with proper defer)

### JavaScript Interop

WASM module manages its own memory. JavaScript passes:
- Tree structure (serialized)
- Keys (Uint8Array)
- Values (Uint8Array)

Results returned as:
- New tree structure (serialized)
- Hashes (Uint8Array)
- Values (Uint8Array | null)

## Building WASM Module

Compile from Zig source:

```bash
# From repository root
zig build -Dtarget=wasm32-freestanding -Doptimize=ReleaseSmall

# Output: zig-out/lib/binary_tree.wasm
```

Build configuration in `build.zig`:

```zig
const wasm = b.addSharedLibrary(.{
    .name = "binary_tree",
    .root_source_file = .{ .path = "src/primitives/BinaryTree/binary_tree.zig" },
    .target = b.resolveTargetQuery(.{
        .cpu_arch = .wasm32,
        .os_tag = .freestanding,
    }),
    .optimize = .ReleaseSmall,
});
```

## Integration Example

Complete example using WASM acceleration:

```typescript
import { BinaryTree } from '@tevm/voltaire'
import * as WasmBinaryTree from '@tevm/voltaire/BinaryTree.wasm'

// Override with WASM
Object.assign(BinaryTree, WasmBinaryTree)

// Build large tree
let tree = BinaryTree.init()

const addresses = [/* ... 1000 addresses ... */]

for (const address of addresses) {
  // Convert address to key
  const baseKey = BinaryTree.addressToKey(address)

  // Insert account data (subindex 0)
  const accountKey = baseKey.slice()
  accountKey[31] = 0
  const accountData = new Uint8Array(32)
  // ... set account data
  tree = BinaryTree.insert(tree, accountKey, accountData)

  // Insert storage slots (subindices 1-10)
  for (let slot = 0; slot < 10; slot++) {
    const storageKey = baseKey.slice()
    storageKey[31] = 1 + slot
    const storageValue = new Uint8Array(32)
    // ... set storage value
    tree = BinaryTree.insert(tree, storageKey, storageValue)
  }
}

// Compute state root (WASM-accelerated)
const stateRoot = BinaryTree.rootHashHex(tree)
console.log(`State root: ${stateRoot}`)
```

## Future Enhancements

Planned WASM features:

### Merkle Proofs
```typescript
// Future API
const proof = BinaryTree.generateProof(tree, key)
const valid = BinaryTree.verifyProof(rootHash, key, value, proof)
```

### Parallel Hashing
```typescript
// Future API
const hash = BinaryTree.rootHashParallel(tree, { threads: 4 })
```

### Persistent Storage
```typescript
// Future API
const serialized = BinaryTree.serialize(tree)
const tree = BinaryTree.deserialize(serialized)
```

## Development Status

**Current State:**
- ✅ Zig implementation complete
- ✅ Tests passing in Zig
- ⏳ WASM bindings in development
- ⏳ JavaScript exports pending

**Next Steps:**
1. Create WASM export functions in binary_tree.zig
2. Build WASM module with exports
3. Write JavaScript bindings in BinaryTree.wasm.js
4. Add TypeScript types in BinaryTree.wasm.ts
5. Benchmark and optimize

## Related

- [BinaryTree](/primitives/binarytree/) - Main documentation
- [Constructors](/primitives/binarytree/constructors) - Creating trees
- [Operations](/primitives/binarytree/operations) - Insert and get
- [Hashing](/primitives/binarytree/hashing) - Hash functions
- [BrandedBinaryTree](/primitives/binarytree/branded-binarytree) - Functional API
