---
title: Address Validation
description: Validating address formats and types
---

import { Tabs, TabItem, Aside, Steps, Badge } from '@astrojs/starlight/components';

# Validation

Methods for validating address strings and checking address types.

## String Validation

### `Address.isValid(str)`

Check if string is valid address format. Accepts hex with or without `0x` prefix.

```typescript
Address.isValid("0x742d35Cc6634C0532925a3b844Bc9e7595f251e3") // true
Address.isValid("742d35Cc6634C0532925a3b844Bc9e7595f251e3")   // true (no 0x)
Address.isValid("0x742d35Cc")                                 // false (too short)
Address.isValid("0xGGGG...")                                  // false (invalid chars)

// Use before parsing
if (Address.isValid(input)) {
  const addr = Address.fromHex(input)
}
```

**Parameters:**
- `str: string` - String to validate

**Returns:** `boolean`

Defined in: [primitives/Address/BrandedAddress/isValid.js:16](https://github.com/evmts/voltaire/blob/main/src/primitives/Address/BrandedAddress/isValid.js)
Tests: [isValid.test.ts](https://github.com/evmts/voltaire/blob/main/src/primitives/Address/BrandedAddress/isValid.test.ts)

**Validation rules:**
- With `0x`: exactly 42 characters (0x + 40 hex chars)
- Without `0x`: exactly 40 hex characters
- Only hex chars allowed: `0-9`, `a-f`, `A-F`

### `Address.isValidChecksum(str)` <Badge text="EIP-55" variant="success" />

Check if string has valid EIP-55 checksum.

```typescript
// Valid checksummed addresses
Address.isValidChecksum("0x742d35Cc6634C0532925a3b844Bc9e7595f51e3e") // true

// Invalid checksum (wrong casing)
Address.isValidChecksum("0x742d35cc6634c0532925a3b844bc9e7595f51e3e") // false
Address.isValidChecksum("0x742D35CC6634C0532925A3B844BC9E7595F51E3E") // false

// All lowercase/uppercase passes (no checksum to validate)
Address.isValidChecksum("0x742d35cc6634c0532925a3b844bc9e7595f51e3e") // true
Address.isValidChecksum("0x742D35CC6634C0532925A3B844BC9E7595F51E3E") // true
```

**Parameters:**
- `str: string` - Address string to validate

**Returns:** `boolean`

Defined in: [primitives/Address/BrandedAddress/isValidChecksum.js:16](https://github.com/evmts/voltaire/blob/main/src/primitives/Address/BrandedAddress/isValidChecksum.js)
Tests: [isValidChecksum.test.ts](https://github.com/evmts/voltaire/blob/main/src/primitives/Address/BrandedAddress/isValidChecksum.test.ts)

**Note:** Uses keccak256 internally. When using tree-shakeable imports, including this method adds keccak256 to bundle.

#### EIP-55 Checksum Visualization

How checksumming works - each letter's capitalization is determined by the keccak256 hash of the address:

```
Address:  0x742d35Cc6634C0532925a3b844Bc9e7595f51e3e
Hex data:   7 4 2 d 3 5 c c 6 6 3 4 c 0 5 3 2 9 2 5 a 3 b 8 4 4 b c 9 e 7 5 9 5 f 5 1 e 3 e

Hash data:  k e c c a k 2 5 6 ( a d d r e s s )
Hash bits:  7 4 2 d 3 5 c c 6 6 3 4 c 0 5 3 2 9 2 5 a 3 b 8 4 4 b c 9 e 7 5 9 5 f 5 1 e 3 e
         Bit 4: 7 4 2 d 3 5 ≥8? C(yes) ≥8? C(yes)

Letters use: if hash nibble ≥ 8, uppercase; else lowercase
Digits 0-9: always lowercase (ignored)
```

<details>
<summary>Click to see EIP-55 algorithm details</summary>

1. Take the address (without 0x prefix): `742d35cc6634c0532925a3b844bc9e7595f51e3e`
2. Hash it with keccak256: `...` (produces 32-byte hash)
3. For each hex character in address:
   - If digit (0-9): keep as-is
   - If letter (a-f): check corresponding hex digit in hash
     - If ≥ 8: make uppercase
     - If < 8: make lowercase

Result: `0x742d35Cc6634C0532925a3b844Bc9e7595f51e3e`

This allows wallets to detect typos - mixing case breaks the checksum.
</details>

**EIP-55 validation rules:**
- If all letters are same case (all lowercase or all uppercase), checksum is considered valid (no mixed case = no checksum)
- If mixed case, each letter's case must match keccak256 hash-based checksum

## Type Guards

### `Address.is(value)`

Type guard checking if value is a `BrandedAddress` (20-byte Uint8Array).

```typescript
function processAddress(value: unknown) {
  if (Address.is(value)) {
    // TypeScript knows value is BrandedAddress here
    const hex = Address.toHex(value)
    console.log(hex)
  } else {
    console.error("Not an address")
  }
}

processAddress(new Address(69n))      // ✓ valid
processAddress(new Uint8Array(20))    // ✓ valid (20 bytes)
processAddress(new Uint8Array(32))    // ✗ invalid (wrong length)
processAddress("0x...")               // ✗ invalid (string)
```

**Parameters:**
- `value: unknown` - Value to check

**Returns:** `value is BrandedAddress` (type predicate)

Defined in: [primitives/Address/BrandedAddress/is.js:16](https://github.com/evmts/voltaire/blob/main/src/primitives/Address/BrandedAddress/is.js)
Tests: [is.test.ts](https://github.com/evmts/voltaire/blob/main/src/primitives/Address/BrandedAddress/is.test.ts)

**Checks:**
- `value instanceof Uint8Array`
- `value.length === 20`

### `instance.isZero()`

Check if address is zero address (all bytes are 0).

```typescript
Address.zero().isZero()                                          // true
new Address(0n).isZero()                                         // true
Address.fromHex("0x0000000000000000000000000000000000000000").isZero() // true

new Address(69n).isZero()                                        // false
Address.fromHex("0x742d35Cc6634C0532925a3b844Bc9e7595f51e3e").isZero() // false
```

**Returns:** `boolean`

**Static form:**
```typescript
Address.isZero(addr) // boolean
```

See [Comparisons](/primitives/address/comparisons#iszerо) for more details.

## Usage Patterns

### Safe Parsing

```typescript
function parseAddress(input: string): Address | null {
  if (!Address.isValid(input)) {
    return null
  }
  try {
    return Address.fromHex(input)
  } catch {
    return null
  }
}
```

### Checksum Validation

```typescript
function requireChecksum(input: string): Address {
  if (!Address.isValidChecksum(input)) {
    throw new Error("Address must have valid EIP-55 checksum")
  }
  return Address.fromHex(input)
}
```

### Runtime Type Checking

```typescript
function handleValue(value: unknown) {
  if (Address.is(value)) {
    // Handle as address
    return Address.toHex(value)
  }

  if (typeof value === "string" && Address.isValid(value)) {
    // Parse string to address
    return Address.fromHex(value)
  }

  throw new Error("Invalid address value")
}
```

## Tree-Shakeable Usage

All validation methods available as tree-shakeable imports:

```typescript
import { isValid, isValidChecksum, is, isZero } from '@tevm/voltaire/BrandedAddress'

isValid("0x742d35Cc6634C0532925a3b844Bc9e7595f51e3e")     // boolean
isValidChecksum("0x742d35Cc6634C0532925a3b844Bc9e7595f51e3e") // boolean
is(value)                                                  // type guard
isZero(addr)                                               // boolean
```

**Tree-shaking benefit:** When avoiding `isValidChecksum()`, keccak256 implementation is excluded from bundle.

See [BrandedAddress](/primitives/address/branded-address) for details on tree-shakeable API.

## Validation Quick Reference

<details>
<summary>Validation rules at a glance</summary>

| Method | Purpose | Format | Returns |
|--------|---------|--------|---------|
| `isValid(str)` | Hex format check | `0x` + 40 hex chars, or 40 hex chars | boolean |
| `isValidChecksum(str)` | EIP-55 checksum | Mixed case must match hash, or all same case | boolean |
| `is(value)` | Type guard | 20-byte Uint8Array | boolean |
| `isZero()` | Zero address check | All bytes are 0 | boolean |

</details>

## See Also

- [Address Conversions](/primitives/address/conversions) - Format conversion and checksumming
- [Address Constructors](/primitives/address/constructors) - Create addresses from various inputs
- [EIP-55 Standard](https://eips.ethereum.org/EIPS/eip-55) - Mixed-case checksum specification
- [Hex](/primitives/hex) - Hex validation and conversion utilities
