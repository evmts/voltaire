---
title: Address Validation
description: Validating address formats and types
---

# Validation

Methods for validating address strings and checking address types.

## String Validation

### `Address.isValid(str)`

Check if string is valid address format. Accepts hex with or without `0x` prefix.

```typescript
Address.isValid("0x742d35Cc6634C0532925a3b844Bc9e7595f251e3") // true
Address.isValid("742d35Cc6634C0532925a3b844Bc9e7595f251e3")   // true (no 0x)
Address.isValid("0x742d35Cc")                                 // false (too short)
Address.isValid("0xGGGG...")                                  // false (invalid chars)

// Use before parsing
if (Address.isValid(input)) {
  const addr = Address.fromHex(input)
}
```

**Parameters:**
- `str: string` - String to validate

**Returns:** `boolean`

Defined in: [primitives/Address/BrandedAddress/isValid.js:16](https://github.com/evmts/primitives/blob/main/src/primitives/Address/BrandedAddress/isValid.js)

**Validation rules:**
- With `0x`: exactly 42 characters (0x + 40 hex chars)
- Without `0x`: exactly 40 hex characters
- Only hex chars allowed: `0-9`, `a-f`, `A-F`

### `Address.isValidChecksum(str)`

Check if string has valid EIP-55 checksum.

```typescript
// Valid checksummed addresses
Address.isValidChecksum("0x742d35Cc6634C0532925a3b844Bc9e7595f51e3e") // true

// Invalid checksum (wrong casing)
Address.isValidChecksum("0x742d35cc6634c0532925a3b844bc9e7595f51e3e") // false
Address.isValidChecksum("0x742D35CC6634C0532925A3B844BC9E7595F51E3E") // false

// All lowercase/uppercase passes (no checksum to validate)
Address.isValidChecksum("0x742d35cc6634c0532925a3b844bc9e7595f51e3e") // true
Address.isValidChecksum("0x742D35CC6634C0532925A3B844BC9E7595F51E3E") // true
```

**Parameters:**
- `str: string` - Address string to validate

**Returns:** `boolean`

Defined in: [primitives/Address/BrandedAddress/isValidChecksum.js:16](https://github.com/evmts/primitives/blob/main/src/primitives/Address/BrandedAddress/isValidChecksum.js)

**Note:** Uses keccak256 internally. When using tree-shakeable imports, including this method adds keccak256 to bundle.

**EIP-55 rules:**
- If all letters are same case (all lowercase or all uppercase), checksum is considered valid
- If mixed case, each letter's case must match keccak256 hash-based checksum

## Type Guards

### `Address.is(value)`

Type guard checking if value is a `BrandedAddress` (20-byte Uint8Array).

```typescript
function processAddress(value: unknown) {
  if (Address.is(value)) {
    // TypeScript knows value is BrandedAddress here
    const hex = Address.toHex(value)
    console.log(hex)
  } else {
    console.error("Not an address")
  }
}

processAddress(new Address(69n))      // ✓ valid
processAddress(new Uint8Array(20))    // ✓ valid (20 bytes)
processAddress(new Uint8Array(32))    // ✗ invalid (wrong length)
processAddress("0x...")               // ✗ invalid (string)
```

**Parameters:**
- `value: unknown` - Value to check

**Returns:** `value is BrandedAddress` (type predicate)

Defined in: [primitives/Address/BrandedAddress/is.js:16](https://github.com/evmts/primitives/blob/main/src/primitives/Address/BrandedAddress/is.js)

**Checks:**
- `value instanceof Uint8Array`
- `value.length === 20`

### `instance.isZero()`

Check if address is zero address (all bytes are 0).

```typescript
Address.zero().isZero()                                          // true
new Address(0n).isZero()                                         // true
Address.fromHex("0x0000000000000000000000000000000000000000").isZero() // true

new Address(69n).isZero()                                        // false
Address.fromHex("0x742d35Cc6634C0532925a3b844Bc9e7595f51e3e").isZero() // false
```

**Returns:** `boolean`

**Static form:**
```typescript
Address.isZero(addr) // boolean
```

See [Comparisons](/primitives/address/comparisons#iszerо) for more details.

## Usage Patterns

### Safe Parsing

```typescript
function parseAddress(input: string): Address | null {
  if (!Address.isValid(input)) {
    return null
  }
  try {
    return Address.fromHex(input)
  } catch {
    return null
  }
}
```

### Checksum Validation

```typescript
function requireChecksum(input: string): Address {
  if (!Address.isValidChecksum(input)) {
    throw new Error("Address must have valid EIP-55 checksum")
  }
  return Address.fromHex(input)
}
```

### Runtime Type Checking

```typescript
function handleValue(value: unknown) {
  if (Address.is(value)) {
    // Handle as address
    return Address.toHex(value)
  }

  if (typeof value === "string" && Address.isValid(value)) {
    // Parse string to address
    return Address.fromHex(value)
  }

  throw new Error("Invalid address value")
}
```

## Tree-Shakeable Usage

All validation methods available as tree-shakeable imports:

```typescript
import { isValid, isValidChecksum, is, isZero } from '@tevm/voltaire/BrandedAddress'

isValid("0x742d35Cc6634C0532925a3b844Bc9e7595f51e3e")     // boolean
isValidChecksum("0x742d35Cc6634C0532925a3b844Bc9e7595f51e3e") // boolean
is(value)                                                  // type guard
isZero(addr)                                               // boolean
```

**Tree-shaking benefit:** When avoiding `isValidChecksum()`, keccak256 implementation is excluded from bundle.

See [BrandedAddress](/primitives/address/branded-address) for details on tree-shakeable API.
