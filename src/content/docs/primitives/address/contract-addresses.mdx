---
title: Contract Address Calculation
description: CREATE and CREATE2 address derivation
---

import { Tabs, TabItem, Aside, Steps, Badge } from '@astrojs/starlight/components';

# Contract Address Calculation

Methods for calculating contract addresses from deployer address and deployment parameters.

## Overview

Ethereum provides two opcodes for deploying contracts:
- **CREATE** - Deterministic based on sender address and nonce
- **CREATE2** - Deterministic based on sender address, salt, and init code hash

Both methods produce deterministic 20-byte addresses derived from keccak256 hashing.

## CREATE Address

### `instance.calculateCreateAddress(nonce)`

Calculate CREATE contract address using sender address and transaction nonce.

**Formula:** `keccak256(rlp([sender, nonce]))[12:32]`

```typescript
const deployerAddr = Address.fromHex("0x742d35Cc6634C0532925a3b844Bc9e7595f51e3e")

// First contract deployed (nonce 0)
const contract1 = deployerAddr.calculateCreateAddress(0n)
console.log(contract1.toHex())

// Second contract (nonce 1)
const contract2 = deployerAddr.calculateCreateAddress(1n)
console.log(contract2.toHex())

// Addresses are different for each nonce
contract1.equals(contract2) // false
```

**Parameters:**
- `nonce: bigint` - Transaction nonce (must be ≥ 0)

**Returns:** `Address` - Calculated contract address

**Throws:**
- `InvalidValueError` - If nonce is negative

**Static form:**
```typescript
Address.calculateCreateAddress(deployerAddr, nonce)
```

Defined in: [primitives/Address/BrandedAddress/calculateCreateAddress.js:20](https://github.com/evmts/voltaire/blob/main/src/primitives/Address/BrandedAddress/calculateCreateAddress.js)
Tests: [calculateCreateAddress.test.ts](https://github.com/evmts/voltaire/blob/main/src/primitives/Address/BrandedAddress/calculateCreateAddress.test.ts)

**Note:** Uses keccak256 and RLP encoding internally. When using tree-shakeable imports, including this method adds both keccak256 and RLP to bundle.

### Nonce Behavior

```typescript
const deployer = Address.fromHex("0x742d35Cc6634C0532925a3b844Bc9e7595f51e3e")

// Nonce 0 - first contract
deployer.calculateCreateAddress(0n)

// Nonce increases with each transaction
deployer.calculateCreateAddress(1n)
deployer.calculateCreateAddress(2n)

// Large nonces supported
deployer.calculateCreateAddress(999999n)

// Negative nonce throws
try {
  deployer.calculateCreateAddress(-1n) // ✗ throws InvalidValueError
} catch (e) {
  console.error(e.message) // "Nonce cannot be negative"
}
```

## CREATE2 Address

### `instance.calculateCreate2Address(salt, initCode)`

Calculate CREATE2 contract address using sender address, salt, and initialization code.

**Formula:** `keccak256(0xff ++ sender ++ salt ++ keccak256(initCode))[12:32]`

```typescript
const deployerAddr = Address.fromHex("0x742d35Cc6634C0532925a3b844Bc9e7595f51e3e")

// Salt can be bigint or Uint8Array
const salt1 = 42n
const salt2 = new Uint8Array(32)

// Contract initialization code (constructor + bytecode)
const initCode = Bytes.fromHex("0x608060405234801561001057600080fd5b50...")

const contractAddr1 = deployerAddr.calculateCreate2Address(salt1, initCode)
const contractAddr2 = deployerAddr.calculateCreate2Address(salt2, initCode)
```

**Parameters:**
- `salt: bigint | Uint8Array` - 32-byte salt value
  - If `bigint`: Converted to 32-byte big-endian representation
  - If `Uint8Array`: Must be exactly 32 bytes
- `initCode: Uint8Array` - Contract initialization code

**Returns:** `Address` - Calculated contract address

**Throws:**
- `Error` - If Uint8Array salt is not exactly 32 bytes
- `InvalidValueError` - If bigint salt is negative

**Static form:**
```typescript
Address.calculateCreate2Address(deployerAddr, salt, initCode)
```

Defined in: [primitives/Address/BrandedAddress/calculateCreate2Address.js:24](https://github.com/evmts/voltaire/blob/main/src/primitives/Address/BrandedAddress/calculateCreate2Address.js)
Tests: [calculateCreate2Address.test.ts](https://github.com/evmts/voltaire/blob/main/src/primitives/Address/BrandedAddress/calculateCreate2Address.test.ts)

**Note:** Uses keccak256 internally (twice - once for initCode, once for final address). When using tree-shakeable imports, including this method adds keccak256 to bundle.

### Salt and Determinism

```typescript
const deployer = Address.fromHex("0x742d35Cc6634C0532925a3b844Bc9e7595f51e3e")
const initCode = Bytes.fromHex("0x6080604052...")

// Same salt produces same address (using bigint)
const addr1 = deployer.calculateCreate2Address(42n, initCode)
const addr2 = deployer.calculateCreate2Address(42n, initCode)
addr1.equals(addr2) // true (deterministic)

// Different salt produces different address
const addr3 = deployer.calculateCreate2Address(43n, initCode)
addr1.equals(addr3) // false

// Can also use Uint8Array (must be 32 bytes)
const saltBytes = new Uint8Array(32)
saltBytes[31] = 42
const addr4 = deployer.calculateCreate2Address(saltBytes, initCode)

// Invalid: wrong size Uint8Array
try {
  const shortSalt = new Uint8Array(16)
  deployer.calculateCreate2Address(shortSalt, initCode) // ✗ throws
} catch (e) {
  console.error(e.message) // "Salt must be 32 bytes"
}
```

## Usage Examples

### Predicting Contract Addresses

```typescript
// Before deployment, calculate where contract will be deployed
const deployer = Address.fromHex("0x742d35Cc6634C0532925a3b844Bc9e7595f51e3e")
const currentNonce = 5n

const predictedAddr = deployer.calculateCreateAddress(currentNonce)
console.log(`Contract will deploy to: ${predictedAddr.prettyPrint()}`)

// Deploy contract...
// Verify deployed address matches prediction
```

### CREATE2 Factory Pattern

```typescript
class ContractFactory {
  constructor(public factoryAddr: Address) {}

  predictAddress(salt: bigint, initCode: Uint8Array): Address {
    // Accepts bigint directly - no manual conversion needed
    return this.factoryAddr.calculateCreate2Address(salt, initCode)
  }

  // Use salt for deterministic addresses
  deployTo(targetAddr: Address, initCode: Uint8Array): bigint | null {
    // Search for salt that produces target address
    for (let salt = 0n; salt < 1000000n; salt++) {
      const predicted = this.predictAddress(salt, initCode)
      if (predicted.equals(targetAddr)) {
        return salt
      }
    }
    return null
  }
}
```

### Vanity Address Mining

```typescript
// Find salt that produces address starting with specific bytes
function mineVanityAddress(
  deployer: Address,
  initCode: Uint8Array,
  prefix: Uint8Array
): { address: Address, salt: bigint } {
  for (let salt = 0n; salt < 2n ** 256n; salt++) {
    const addr = deployer.calculateCreate2Address(salt, initCode)

    // Check if address starts with prefix
    if (addr.slice(0, prefix.length).every((b, i) => b === prefix[i])) {
      return { address: addr, salt }
    }

    // Practical limit for demo
    if (salt > 10000000n) break
  }

  throw new Error("Vanity address not found in search space")
}

// Find address starting with 0x0000
const deployer = Address.fromHex("0x742d35Cc6634C0532925a3b844Bc9e7595f51e3e")
const initCode = Bytes.fromHex("0x6080604052...")
const prefix = new Uint8Array([0x00, 0x00])

const { address, salt } = mineVanityAddress(deployer, initCode, prefix)
console.log(`Found: ${address.toChecksummed()}`)
console.log(`Salt: ${salt}`)
```

## CREATE vs CREATE2 <Badge text="EIP-1014" variant="success" />

### Address Derivation Flowchart

```
CREATE:
  deployer address + nonce
           ↓
    RLP-encode
           ↓
   keccak256 hash
           ↓
  take last 20 bytes
           ↓
    contract address

CREATE2:
  deployer address + salt + keccak256(initCode)
                    ↓
              0xff prefix
                    ↓
          combine all bytes
                    ↓
          keccak256 hash
                    ↓
         take last 20 bytes
                    ↓
         contract address
```

### Comparison Table

| Feature | CREATE | CREATE2 |
|---------|--------|---------|
| **Determinism** | Nonce-based (sequential) | Salt-based (arbitrary) |
| **Dependencies** | Keccak256, RLP encoder | Keccak256 only |
| **Parameters** | `(address, nonce)` | `(address, salt, initCode)` |
| **Use case** | Regular deployments | Deterministic/counterfactual deployments |
| **Predictability** | Requires tracking nonce | Fully deterministic always |
| **Redeployment** | Different address each time | Same address if inputs identical |
| **EIP** | Core | [EIP-1014](https://eips.ethereum.org/EIPS/eip-1014) |

### When to Use

<Tabs>
<TabItem label="CREATE">
When deploying contracts in sequence:
- Each deployment increments sender's nonce
- Natural if deploying multiple contracts
- Simple, no salt management needed
- Example: Factory contracts deploying pools
</TabItem>
<TabItem label="CREATE2">
When you need deterministic addresses:
- Predict address before deployment
- Redeploy to exact same address (rare)
- Cross-chain deployment consistency
- Example: Bridges, counterfactual accounts, proxy factories
</TabItem>
</Tabs>

## Tree-Shakeable Usage

Both methods available as tree-shakeable imports:

```typescript
import { calculateCreateAddress, calculateCreate2Address } from '@tevm/voltaire/BrandedAddress'
import type { BrandedAddress } from '@tevm/voltaire/BrandedAddress'

const deployer: BrandedAddress = /* ... */

const createAddr = calculateCreateAddress(deployer, 0n)
const create2Addr = calculateCreate2Address(deployer, salt, initCode)
```

**Tree-shaking consideration:** Both methods include keccak256 in bundle. CREATE also includes RLP encoder.

See [BrandedAddress](/primitives/address/branded-address) for details on tree-shakeable API.

## See Also

- [Address Conversions](/primitives/address/conversions) - Convert addresses to various formats
- [Address Validation](/primitives/address/validation) - Validate addresses and checksums
- [Transaction](/primitives/transaction) - Complete transaction information including nonce
- [RLP Encoding](/primitives/rlp) - RLP encoding used in CREATE calculations
- [EIP-1014: CREATE2](https://eips.ethereum.org/EIPS/eip-1014) - CREATE2 opcode specification
- [Keccak-256](/crypto/keccak256) - Hashing algorithm used in address derivation
