---
title: WASM Implementation
description: WebAssembly-accelerated Address methods compiled from Zig
---

import { Tabs, TabItem, Aside } from '@astrojs/starlight/components';

# WASM Implementation

WebAssembly-accelerated implementations of Address methods, compiled from Zig using ReleaseSmall mode.

## Overview

WASM implementations provide performance-critical operations using compiled Zig code targeting WebAssembly. These are **purely opt-in** replacements for the JavaScript implementations with identical APIs.

All WASM methods are compiled from [address.zig](https://github.com/evmts/voltaire/blob/main/src/primitives/Address/address.zig) with `ReleaseSmall` optimization targeting minimal bundle size.

## Quick Start

<Tabs>
<TabItem label="Direct Import">
```typescript
// Import WASM implementation instead of JS version
import { Address } from '@tevm/voltaire/Address.wasm'

// API is identical to JS version
const addr = Address.fromHex("0x742d35Cc6634C0532925a3b844Bc9e7595f51e3e")
addr.toChecksummed() // Uses WASM acceleration
addr.equals(other)    // Uses WASM acceleration
```
</TabItem>

<TabItem label="Override Static Methods">
```typescript
import { Address } from '@tevm/voltaire'
import * as WasmAddress from '@tevm/voltaire/Address.wasm'

// Override specific methods with WASM versions
Address.fromHex = WasmAddress.fromHex
Address.toChecksummed = WasmAddress.toChecksummed
Address.equals = WasmAddress.equals

// Now uses WASM implementations
const addr = Address.fromHex("0x742d35Cc...")
```
</TabItem>

<TabItem label="Override Instance Methods">
```typescript
import { Address } from '@tevm/voltaire'
import * as WasmAddress from '@tevm/voltaire/Address.wasm'

// Override instance methods on prototype
Address.prototype.toHex = Function.prototype.call.bind(WasmAddress.toHex)
Address.prototype.toChecksummed = Function.prototype.call.bind(WasmAddress.toChecksummed)
Address.prototype.equals = Function.prototype.call.bind(WasmAddress.equals)

// Instance methods now use WASM
const addr = new Address("0x742d35Cc...")
addr.toChecksummed() // WASM-accelerated
```
</TabItem>
</Tabs>

## Performance

WASM implementations provide significant speedup for computationally intensive operations:

- **Hex parsing** - Native byte manipulation vs JavaScript string operations
- **Checksumming** - keccak256 hashing in compiled code
- **Comparisons** - Memory-efficient byte-by-byte comparison
- **Contract address calculation** - RLP encoding and hashing in Zig

<Aside type="tip" title="When to use WASM">
Use WASM when processing large numbers of addresses (bulk validation, sorting, checksum verification). For single operations, JS overhead may outweigh WASM benefits.
</Aside>

## Overriding Methods

### Static Method Override

Replace static methods by reassigning:

```typescript
import { Address } from '@tevm/voltaire'
import * as WasmAddress from '@tevm/voltaire/Address.wasm'

Address.fromHex = WasmAddress.fromHex
Address.toChecksummed = WasmAddress.toChecksummed
```

### Instance Method Override

Instance methods require `Function.prototype.call.bind` to maintain correct `this` context:

```typescript
import { Address } from '@tevm/voltaire'
import * as WasmAddress from '@tevm/voltaire/Address.wasm'

// Correct - binds 'this' context
Address.prototype.toHex = Function.prototype.call.bind(WasmAddress.toHex)

// Incorrect - loses 'this' context
Address.prototype.toHex = WasmAddress.toHex // Don't do this
```

**Why `Function.prototype.call.bind`?**

WASM module exports are standalone functions expecting address as first parameter:
```typescript
// WASM signature
function toHex(address: BrandedAddress): string

// Instance method needs 'this' binding
// Function.prototype.call.bind converts:
//   toHex(address) â†’ address.toHex()
```

## API Reference

WASM implementations match the standard Address API. See main documentation:

- [Constructors](/primitives/address/constructors) - `fromHex`, `fromBytes`, `fromNumber`, `fromPublicKey`, `fromAbiEncoded`
- [Conversions](/primitives/address/conversions) - `toHex`, `toChecksummed`, `toLowercase`, `toUppercase`, `toU256`, `toAbiEncoded`, `toShortHex`
- [Validation](/primitives/address/validation) - `isValid`, `isValidChecksum`, `is`
- [Comparisons](/primitives/address/comparisons) - `equals`, `compare`, `lessThan`, `greaterThan`, `isZero`
- [Contract Addresses](/primitives/address/contract-addresses) - `calculateCreateAddress`, `calculateCreate2Address`

## WASM-Accelerated Methods

Methods implemented in Zig and exported via WASM:

### Constructors
- `fromHex(hex)` - Hex string parsing with validation

### Conversions
- `toHex(address)` - Lowercase hex conversion
- `toChecksummed(address)` - EIP-55 checksumming (includes keccak256)
- `toLowercase(address)` - Lowercase hex (alias for toHex)

### Validation
- `isValidChecksum(hex)` - Checksum verification (includes keccak256)

### Comparisons
- `equals(a, b)` - Byte-by-byte equality
- `isZero(address)` - Zero address check

### Contract Addresses
- `calculateCreateAddress(sender, nonce)` - CREATE address computation (includes RLP + keccak256)
- `calculateCreate2Address(sender, salt, initCode)` - CREATE2 address computation (includes keccak256)

### Not WASM-Accelerated

These use pure JavaScript (no WASM benefit):
- `fromBytes` - Simple Uint8Array copy
- `fromNumber` - Bigint to bytes conversion
- `fromPublicKey` - Uses WASM keccak256 but JS coordinate encoding
- `toU256`, `toAbiEncoded`, `toShortHex` - Simple byte operations
- `compare`, `lessThan`, `greaterThan` - Pure JS byte comparison

## Files

- **[Address.wasm.js](https://github.com/evmts/voltaire/blob/main/src/primitives/Address/Address.wasm.js)** - JavaScript exports with WASM bindings
- **[Address.wasm.ts](https://github.com/evmts/voltaire/blob/main/src/primitives/Address/Address.wasm.ts)** - TypeScript types and exports
- **[address.zig](https://github.com/evmts/voltaire/blob/main/src/primitives/Address/address.zig)** - Zig source implementation

## Tree-Shakeable Usage

Import only methods you need:

```typescript
import { fromHex, toChecksummed, equals } from '@tevm/voltaire/Address.wasm'
import type { BrandedAddress } from '@tevm/voltaire/BrandedAddress'

const addr = fromHex("0x742d35Cc6634C0532925a3b844Bc9e7595f51e3e")
const checksummed = toChecksummed(addr)
const isEqual = equals(addr, addr2)
```

WASM loader only included if you import WASM methods. Using pure JS versions excludes WASM from bundle.

<Aside type="note" title="Bundle Size">
WASM module compiled with ReleaseSmall (~2-4KB gzipped). Only included when importing from `Address.wasm.js` or `Address.wasm.ts`.
</Aside>
