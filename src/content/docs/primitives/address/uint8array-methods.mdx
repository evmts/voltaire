---
title: Uint8Array Methods
description: Inherited methods from Uint8Array prototype
---

# Uint8Array Methods

Address extends `Uint8Array`, inheriting all standard array methods. These methods provide powerful operations for byte manipulation, iteration, and transformation.

## Overview

Because Address is a `Uint8Array` subclass, you get full access to:
- **Array-like operations** - `slice`, `map`, `filter`, `reduce`
- **Byte manipulation** - `set`, `fill`, `copyWithin`
- **Iteration** - `forEach`, `entries`, `keys`, `values`
- **Search** - `find`, `findIndex`, `indexOf`, `includes`
- **Comparison** - `every`, `some`
- **Native hex/base64** - `toHex`, `toBase64`, `setFromHex`, `setFromBase64`

## Static Methods

### `Address.of(...items)`

Creates Address from variable number of byte values.

```typescript
const addr = Address.of(
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 69
)
addr.toU256() // 69n
```

See [Constructors](/primitives/address/constructors#addressofitems) for details.

### `Address.fromBase64(string)`

Creates Address from base64 string (native Uint8Array method).

```typescript
const addr = Address.fromBase64("dC01zGY0wFMpJaO4RLyedZX1Hj4=")
```

See [Constructors](/primitives/address/constructors#addressfrombase64b64) for details.

## Instance Methods

### Hex/Base64 (Native)

Built-in methods from Uint8Array for encoding:

```typescript
const addr = new Address(69n)

// Convert to hex (native Uint8Array method)
addr.toHex() // "0x0000000000000000000000000000000000000045"

// Convert to base64
addr.toBase64() // "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAE"

// Mutate from hex string
addr.setFromHex("0x742d35Cc6634C0532925a3b844Bc9e7595f51e3e")

// Mutate from base64
addr.setFromBase64("dC01zGY0wFMpJaO4RLyedZX1Hj4=")
```

**Note:** Address overrides `toHex()` to return lowercase hex. Use `toChecksummed()` for EIP-55 formatting.

### Array Operations

Standard array methods work on address bytes:

#### `slice(start?, end?)`

Extract portion of address:

```typescript
const addr = Address.fromHex("0x742d35Cc6634C0532925a3b844Bc9e7595f51e3e")

// Get first 4 bytes
addr.slice(0, 4) // Uint8Array [0x74, 0x2d, 0x35, 0xcc]

// Get last 4 bytes
addr.slice(-4) // Uint8Array [0x5f, 0x51, 0xe3, 0xe]

// Returns Address instance (due to Species constructor)
const partial = addr.slice(0, 20)
partial instanceof Address // implementation-dependent
```

#### `subarray(start?, end?)`

Like `slice()` but creates view (no copy):

```typescript
const addr = Address.fromHex("0x742d35Cc6634C0532925a3b844Bc9e7595f51e3e")
const view = addr.subarray(0, 10)

// Modifying view affects original
view[0] = 0xff
addr[0] === 0xff // true
```

#### `map(fn)`

Transform each byte:

```typescript
const addr = Address.fromHex("0x0102030405060708090a0b0c0d0e0f1011121314")

// Double each byte (demo only - result not valid address)
const doubled = addr.map(b => (b * 2) % 256)
```

#### `filter(fn)`

Select bytes matching condition:

```typescript
const addr = Address.fromHex("0x742d35Cc6634C0532925a3b844Bc9e7595f51e3e")

// Find non-zero bytes
const nonZero = Array.from(addr).filter(b => b !== 0)
console.log(nonZero.length) // Count of non-zero bytes
```

#### `reduce(fn, initial)`

Accumulate value from bytes:

```typescript
const addr = Address.fromHex("0x742d35Cc6634C0532925a3b844Bc9e7595f51e3e")

// Sum all bytes
const sum = addr.reduce((acc, b) => acc + b, 0)

// XOR all bytes
const xor = addr.reduce((acc, b) => acc ^ b, 0)
```

### Iteration

#### `forEach(fn)`

Execute function for each byte:

```typescript
const addr = Address.fromHex("0x742d35Cc6634C0532925a3b844Bc9e7595f51e3e")

addr.forEach((byte, index) => {
  console.log(`Byte ${index}: 0x${byte.toString(16).padStart(2, '0')}`)
})
```

#### `entries()`, `keys()`, `values()`

Iterate as [index, value] pairs, indices, or values:

```typescript
const addr = Address.fromHex("0x742d35Cc6634C0532925a3b844Bc9e7595f51e3e")

// Iterate [index, byte] pairs
for (const [i, byte] of addr.entries()) {
  console.log(`${i}: ${byte}`)
}

// Iterate indices
for (const i of addr.keys()) {
  console.log(i)
}

// Iterate values
for (const byte of addr.values()) {
  console.log(byte)
}

// Default iterator is values()
for (const byte of addr) {
  console.log(byte)
}
```

### Search

#### `find(fn)` / `findIndex(fn)`

Find first matching byte:

```typescript
const addr = Address.fromHex("0x742d35Cc6634C0532925a3b844Bc9e7595f51e3e")

// Find first non-zero byte
const firstNonZero = addr.find(b => b !== 0) // 0x74

// Find index of first 0xff byte
const index = addr.findIndex(b => b === 0xff) // -1 (not found)
```

#### `findLast(fn)` / `findLastIndex(fn)`

Find last matching byte:

```typescript
const addr = Address.fromHex("0x000000000000000000000000000000000000003e")

// Find last non-zero byte
const lastNonZero = addr.findLast(b => b !== 0) // 0x3e

// Find index
const index = addr.findLastIndex(b => b !== 0) // 19
```

#### `indexOf(value)` / `lastIndexOf(value)`

Find index of specific byte value:

```typescript
const addr = Address.fromHex("0x742d35Cc6634C0532925a3b844Bc9e7595f51e3e")

addr.indexOf(0x74) // 0 (first byte)
addr.lastIndexOf(0x3e) // 19 (last byte)
addr.indexOf(0xff) // -1 (not found)
```

#### `includes(value)`

Check if byte exists:

```typescript
const addr = Address.fromHex("0x742d35Cc6634C0532925a3b844Bc9e7595f51e3e")

addr.includes(0x74) // true
addr.includes(0xff) // false
```

### Comparison

#### `every(fn)`

Test if all bytes match condition:

```typescript
const zeroAddr = Address.zero()
zeroAddr.every(b => b === 0) // true

const addr = Address.fromHex("0x742d35Cc6634C0532925a3b844Bc9e7595f51e3e")
addr.every(b => `b <= 0`xff) // true (always for Uint8Array)
```

#### `some(fn)`

Test if any byte matches condition:

```typescript
const addr = Address.fromHex("0x000000000000000000000000000000000000003e")
addr.some(b => b !== 0) // true (has non-zero bytes)

const zeroAddr = Address.zero()
zeroAddr.some(b => b !== 0) // false
```

### Manipulation

#### `fill(value, start?, end?)`

Fill bytes with value (mutates):

```typescript
const addr = new Address(0n)

// Fill entire address with 0xff
addr.fill(0xff)

// Fill first 4 bytes
addr.fill(0xaa, 0, 4)

// Fill from byte 10 onwards
addr.fill(0xbb, 10)
```

#### `set(source, offset?)`

Copy bytes from another array (mutates):

```typescript
const addr = Address.zero()

// Copy 4 bytes at start
const bytes = new Uint8Array([0x11, 0x22, 0x33, 0x44])
addr.set(bytes, 0)

// addr is now 0x1122334400000000000000000000000000000000
```

#### `copyWithin(target, start, end?)`

Copy portion of array within itself (mutates):

```typescript
const addr = Address.fromHex("0x742d35Cc6634C0532925a3b844Bc9e7595f51e3e")

// Copy first 4 bytes to position 16
addr.copyWithin(16, 0, 4)
```

### Sorting

#### `sort(compareFn?)`

Sort bytes in-place (mutates):

```typescript
const addr = Address.fromHex("0x742d35Cc6634C0532925a3b844Bc9e7595f51e3e")

// Sort ascending (mutates original)
addr.sort()

// Sort descending
addr.sort((a, b) => b - a)
```

#### `reverse()`

Reverse byte order (mutates):

```typescript
const addr = Address.fromHex("0x742d35Cc6634C0532925a3b844Bc9e7595f51e3e")
addr.reverse()
// addr is now 0x3e1ef595e79ebc44b8a32529350c6334cc352d74
```

#### `toReversed()`

Return reversed copy (non-mutating):

```typescript
const addr = Address.fromHex("0x742d35Cc6634C0532925a3b844Bc9e7595f51e3e")
const reversed = addr.toReversed()
// addr unchanged, reversed is new array
```

#### `toSorted(compareFn?)`

Return sorted copy (non-mutating):

```typescript
const addr = Address.fromHex("0x742d35Cc6634C0532925a3b844Bc9e7595f51e3e")
const sorted = addr.toSorted()
// addr unchanged, sorted is new array
```

### Utility

#### `at(index)`

Access byte at index (supports negative):

```typescript
const addr = Address.fromHex("0x742d35Cc6634C0532925a3b844Bc9e7595f51e3e")

addr.at(0)   // 0x74 (first byte)
addr.at(-1)  // 0x3e (last byte)
addr.at(19)  // 0x3e (last byte)
addr.at(20)  // undefined (out of bounds)
```

#### `with(index, value)`

Return copy with byte replaced (non-mutating):

```typescript
const addr = Address.fromHex("0x742d35Cc6634C0532925a3b844Bc9e7595f51e3e")
const modified = addr.with(0, 0xff)
// addr unchanged, modified[0] === 0xff
```

#### `join(separator?)`

Join bytes as string:

```typescript
const addr = Address.fromHex("0x742d35Cc6634C0532925a3b844Bc9e7595f51e3e")

addr.join(':') // "116:45:53:204:102:52:..."
addr.join(',') // "116,45,53,204,..."
```

#### `toString()`

Convert to string representation:

```typescript
const addr = Address.fromHex("0x742d35Cc6634C0532925a3b844Bc9e7595f51e3e")
addr.toString() // "Address(0x742d35cc6634c0532925a3b844bc9e7595f51e3e)"

// In Node.js with util.inspect
console.log(addr) // Address(0x742d35Cc6634C0532925a3b844Bc9e7595f51e3e) [checksummed]
```

#### `toLocaleString()`

Locale-aware string conversion:

```typescript
const addr = Address.fromHex("0x742d35Cc6634C0532925a3b844Bc9e7595f51e3e")
addr.toLocaleString() // Same as toString() for Uint8Array
```

## Properties

### `length`

Always 20 for valid addresses:

```typescript
const addr = new Address(69n)
addr.length // 20
```

### `buffer`, `byteOffset`, `byteLength`

Access underlying ArrayBuffer:

```typescript
const addr = new Address(69n)
addr.buffer       // ArrayBuffer(20)
addr.byteOffset   // 0
addr.byteLength   // 20
```

## Usage Patterns

### Byte-level Comparison

```typescript
function addressesEqual(a: Address, b: Address): boolean {
  return a.length === b.length && a.every((byte, i) => byte === b[i])
}

// Better: use built-in equals method
addr1.equals(addr2)
```

### Extract Address Prefix

```typescript
// Get first 4 bytes as "selector"
const addr = Address.fromHex("0x742d35Cc6634C0532925a3b844Bc9e7595f51e3e")
const prefix = addr.slice(0, 4)
console.log(Array.from(prefix).map(b => b.toString(16).padStart(2, '0')).join(''))
// "742d35cc"
```

### Count Leading Zeros

```typescript
function countLeadingZeros(addr: Address): number {
  let count = 0
  for (const byte of addr) {
    if (byte === 0) count++
    else break
  }
  return count
}

const addr = Address.fromHex("0x0000000000000000000000000000000000000045")
countLeadingZeros(addr) // 19
```

### Hamming Distance

```typescript
function hammingDistance(a: Address, b: Address): number {
  let distance = 0
  for (let i = 0; i < 20; i++) {
    let xor = a[i] ^ b[i]
    while (xor) {
      distance += xor & 1
      xor >>= 1
    }
  }
  return distance
}
```

## Notes

- Methods returning arrays return `Uint8Array`, not `Address`
- Mutating methods modify the original Address instance
- `toReversed()`, `toSorted()`, `with()` create copies
- Address overrides `toString()` for better display
- Native `toHex()` is overridden - use `toChecksummed()` for EIP-55

## Related

- [Conversions](/primitives/address/conversions) - Address-specific conversion methods
- [Comparisons](/primitives/address/comparisons) - Semantic comparison methods
- [Bytes](/primitives/bytes) - General byte array utilities
