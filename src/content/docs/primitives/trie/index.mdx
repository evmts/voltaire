---
title: Merkle Patricia Trie
description: Ethereum's state storage data structure with cryptographic verification
---

# Merkle Patricia Trie

Modified Merkle Patricia Trie implementation as specified in Ethereum Yellow Paper for cryptographically secure key-value storage with proof generation.

## Overview

Ethereum's Merkle Patricia Trie combines two data structures:
- **Patricia Trie**: Path compression for efficient sparse storage
- **Merkle Tree**: Cryptographic hashing for integrity verification

Used extensively in Ethereum for:
- **State Trie**: Account state commitments
- **Storage Trie**: Per-account storage
- **Transaction Trie**: Block transaction ordering
- **Receipt Trie**: Transaction receipt storage

**Source**: `src/primitives/trie.zig`

## What is a Merkle Patricia Trie?

### Patricia Trie (Radix Tree)

Compact prefix tree where nodes with single children are compressed. Keys split into nibbles (4-bit values):

```
Key 0x1234 → Nibbles [1,2,3,4]
Key 0x1256 → Nibbles [1,2,5,6]

Common prefix [1,2] compressed into single Extension node
```

### Merkle Tree Properties

Every node hashed using Keccak256. Root hash commits to entire trie:
- Change any value → root hash changes
- Prove membership with logarithmic proof size
- Verify proofs without full trie

## Node Types

Four node types optimize different patterns:

### Empty Node
Represents null/empty trie. No storage required.

### Leaf Node
Terminal node storing key-value pair:
```zig
LeafNode {
    nibbles: []u8,  // Remaining path
    value: []u8,    // Stored value
}
```

### Extension Node
Compresses shared path prefix:
```zig
ExtensionNode {
    nibbles: []u8,      // Shared path
    child_hash: [32]u8, // Next node hash
}
```

### Branch Node
Up to 16 children (one per hex digit) plus optional value:
```zig
BranchNode {
    children: [16]?[32]u8,  // Child hashes
    value: ?[]u8,           // Optional value at branch
    mask: TrieMask,         // Child presence bitmap
}
```

## Quick Start

### Basic Operations

```zig
const std = @import("std");
const primitives = @import("primitives");
const Trie = primitives.Trie;

pub fn main() !void {
    var trie = Trie.init(std.heap.page_allocator);
    defer trie.deinit();

    // Insert key-value pairs
    try trie.put(&[_]u8{0x12, 0x34}, "value1");
    try trie.put(&[_]u8{0x12, 0x56}, "value2");
    try trie.put(&[_]u8{0xab, 0xcd}, "value3");

    // Lookup values
    const value = try trie.get(&[_]u8{0x12, 0x34});
    // value = "value1"

    // Delete entries
    try trie.delete(&[_]u8{0xab, 0xcd});

    // Verify deletion
    const deleted = try trie.get(&[_]u8{0xab, 0xcd});
    // deleted = null
}
```

### State Commitment

```zig
pub fn stateRoot() !void {
    var state_trie = primitives.Trie.init(allocator);
    defer state_trie.deinit();

    // Store account states (address → RLP-encoded account)
    try state_trie.put(address1, account_state1);
    try state_trie.put(address2, account_state2);
    try state_trie.put(address3, account_state3);

    // Compute state root (used in block header)
    const state_root = state_trie.root_hash();

    // state_root cryptographically commits to all accounts
    // Any state change → different root hash
}
```

## API Documentation

Detailed documentation organized by operation type:

- **[Operations](/primitives/trie/operations)** - Insert, lookup, delete, clear
- **[Constructors](/primitives/trie/constructors)** - Create and initialize tries
- **[Proof Generation](/primitives/trie/proof-generation)** - Generate Merkle proofs
- **[Verification](/primitives/trie/verification)** - Verify proofs against root
- **[Usage Patterns](/primitives/trie/usage-patterns)** - Common patterns and examples

## Type Reference

### Trie

Main trie structure:

```zig
pub const Trie = struct {
    allocator: Allocator,
    nodes: std.StringHashMap(Node),
    root: ?[32]u8,

    pub fn init(allocator: Allocator) Trie
    pub fn deinit(self: *Trie) void
    pub fn root_hash(self: *const Trie) ?[32]u8
    pub fn put(self: *Trie, key: []const u8, value: []const u8) !void
    pub fn get(self: *const Trie, key: []const u8) !?[]const u8
    pub fn delete(self: *Trie, key: []const u8) !void
    pub fn clear(self: *Trie) void
}
```

### TrieError

Error types for trie operations:

```zig
pub const TrieError = error{
    InvalidNode,      // Node structure corrupted
    InvalidKey,       // Key format invalid
    InvalidProof,     // Proof verification failed
    InvalidPath,      // Path encoding malformed
    NonExistentNode,  // Referenced node missing
    EmptyInput,       // Unexpected empty input
    OutOfMemory,      // Allocation failed
    CorruptedTrie,    // Trie structure corrupted
}
```

### TrieMask

16-bit bitmap for branch children:

```zig
pub const TrieMask = struct {
    mask: u16,

    pub fn init() TrieMask
    pub fn set(self: *TrieMask, index: u4) void
    pub fn unset(self: *TrieMask, index: u4) void
    pub fn is_set(self: TrieMask, index: u4) bool
    pub fn bit_count(self: TrieMask) u5
    pub fn is_empty(self: TrieMask) bool
}
```

## Performance

Benchmarks (Zig 0.15.1, ReleaseFast):

**Native Performance:**
- Insert: ~1-2 μs per key
- Lookup: ~500-800 ns per key
- Delete: ~1-2 μs per key
- Root hash: ~10-50 μs (size-dependent)

**WASM Performance:**
- Insert: ~3-5 μs per key
- Lookup: ~1-2 μs per key
- Delete: ~3-5 μs per key

Performance characteristics:
- O(log n) operations via path compression
- Sparse tries benefit from extension nodes
- Dense tries create more branch nodes
- Root hash requires full serialization

## Implementation Details

### Nibble Encoding

Keys split into 4-bit nibbles for 16-way branching:

```zig
// Byte 0x1A → Nibbles [0x1, 0xA]
pub fn keyToNibbles(allocator: Allocator, key: []const u8) ![]u8 {
    const nibbles = try allocator.alloc(u8, key.len * 2);
    for (key, 0..) |byte, i| {
        nibbles[i * 2] = byte >> 4;      // High nibble
        nibbles[i * 2 + 1] = byte & 0x0F; // Low nibble
    }
    return nibbles;
}
```

### Path Encoding (Hex Prefix)

Encodes path with node type and parity:

```
Even length, extension: [0x00, nibbles packed...]
Odd length, extension:  [0x1X, nibbles packed...] (X = first nibble)
Even length, leaf:      [0x20, nibbles packed...]
Odd length, leaf:       [0x3X, nibbles packed...]
```

### Node Hashing

Nodes RLP-encoded then Keccak256 hashed:

```zig
// Leaf: [encodedPath, value]
// Extension: [encodedPath, childHash]
// Branch: [child1, ..., child16, value]
const encoded = try Rlp.encode(allocator, node_data);
var hash: [32]u8 = undefined;
crypto.Keccak256.hash(encoded, &hash, .{});
```

## Security Considerations

- **Cryptographic Commitment**: Root hash commits to all trie data
- **Proof Verification**: Merkle proofs prevent state manipulation
- **Memory Safety**: Bounds checking prevents buffer overflows
- **Explicit Deallocation**: No garbage collection, manual memory management
- **Constant-Time Traversal**: Path-independent timing

## Testing

Run trie tests:

```bash
zig build test -Dtest-filter=trie
```

Comprehensive test coverage:
- All node types (empty, leaf, extension, branch)
- Path compression and splitting
- Insert, update, delete operations
- Root hash determinism
- Large key/value handling
- Empty key/value edge cases
- Common prefix scenarios
- Branch collapse on deletion
- Memory safety with many operations

## Related

- **[RLP](/primitives/rlp)** - Recursive Length Prefix encoding for node serialization
- **[Keccak256](/crypto/keccak)** - Hash function for node digests
- **[State](/primitives/state)** - Account state structure stored in trie
- **[Hash](/primitives/hash)** - 32-byte hash type for root and node hashes

## References

- [Ethereum Yellow Paper](https://ethereum.github.io/yellowpaper/paper.pdf) - Appendix D: Modified Merkle Patricia Trie
- [Patricia Trie](https://en.wikipedia.org/wiki/Radix_tree) - Original radix tree data structure
- [Merkle Tree](https://en.wikipedia.org/wiki/Merkle_tree) - Cryptographic hash tree
- [EIP-161](https://eips.ethereum.org/EIPS/eip-161) - State trie clearing
