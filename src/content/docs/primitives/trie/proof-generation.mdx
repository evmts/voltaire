---
title: Merkle Proof Generation
description: Generate cryptographic proofs for trie membership
---

# Merkle Proof Generation

Generate cryptographic proofs demonstrating key-value membership in Merkle Patricia Trie.

## Overview

Merkle proofs allow lightweight verification of trie membership without full trie. Proof contains path from root to target node.

**Use Cases:**
- Light client state verification
- Cross-contract state proofs
- Fraud proofs in optimistic rollups
- Historical state verification

## Proof Structure

Proof consists of sibling nodes along path from root to target:

```
Root
  |
Extension [1,2]
  |
Branch (proof includes siblings)
  ├─[3]: Leaf([4], "value1")  ← Target
  ├─[5]: Leaf([6], "value2")  ← Sibling (in proof)
  └─[7]: Leaf([8], "value3")  ← Sibling (in proof)
```

**Proof Path:**
1. Extension node [1,2]
2. Branch node (all children)
3. Leaf node [4]

Verifier reconstructs root hash from proof and compares.

## Implementation Status

Current implementation (`src/primitives/trie.zig`) provides core trie operations but proof generation/verification not yet exposed in public API.

**Available Now:**
- Internal node hashing (`hash_node`)
- Path encoding/decoding
- Tree traversal
- Root hash computation

**Planned API:**

```zig
pub fn prove(self: *const Trie, key: []const u8) !Proof

pub fn verify(
    root: [32]u8,
    key: []const u8,
    value: ?[]const u8,
    proof: Proof
) !bool
```

## Proof Generation Algorithm

Conceptual algorithm (implementation in progress):

```zig
// Pseudocode for proof generation
pub fn prove(self: *const Trie, key: []const u8) !Proof {
    var proof_nodes = std.ArrayList([]const u8){};
    defer proof_nodes.deinit(allocator);

    const nibbles = try keyToNibbles(allocator, key);
    defer allocator.free(nibbles);

    var current_hash = self.root orelse return TrieError.EmptyInput;

    // Traverse path and collect nodes
    while (true) {
        const node = self.get_node(current_hash) orelse
            return TrieError.NonExistentNode;

        // Encode and add node to proof
        const encoded = try encodeNode(allocator, node);
        try proof_nodes.append(allocator, encoded);

        switch (node.*) {
            .Empty => break,
            .Leaf => break,
            .Extension => |ext| {
                current_hash = ext.child_hash;
            },
            .Branch => |branch| {
                if (nibbles.len == 0) break;
                const nibble = nibbles[0];
                current_hash = branch.get_child(nibble) orelse break;
                nibbles = nibbles[1..];
            },
        }
    }

    return Proof{ .nodes = try proof_nodes.toOwnedSlice() };
}
```

## Proof Size

Proof size proportional to trie depth:

**Depth Factors:**
- Sparse trie: Shallower (extension compression)
- Dense trie: Deeper (more branches)
- Balanced trie: ~log₁₆(n) depth

**Size Estimates:**

```
Nodes in proof = Depth
Node size ≈ 32-600 bytes (type dependent)
Proof size ≈ Depth × Avg_Node_Size
```

**Example:**
- 1 million entries
- Depth ≈ log₁₆(1000000) ≈ 5
- Average node: 300 bytes
- Proof size ≈ 1.5 KB

## Usage Examples

### State Proof

Once API available, generate state proof:

```zig
const std = @import("std");
const primitives = @import("primitives");

pub fn stateProof() !void {
    var state_trie = primitives.Trie.init(allocator);
    defer state_trie.deinit();

    // Build state trie
    try state_trie.put(address1, account_state1);
    try state_trie.put(address2, account_state2);
    try state_trie.put(address3, account_state3);

    // Generate proof for address2
    const proof = try state_trie.prove(address2);
    defer proof.deinit(allocator);

    // Get state root
    const state_root = state_trie.root_hash();

    // Proof can be sent to light client for verification
    // Light client verifies without full state trie
}
```

### Storage Proof

Generate proof for contract storage:

```zig
pub fn storageProof(contract_storage: primitives.Trie) !void {
    const storage_key = &[_]u8{0x00, 0x00, 0x00, 0x01}; // Slot 1

    // Generate proof for storage slot
    const proof = try contract_storage.prove(storage_key);
    defer proof.deinit(allocator);

    const storage_root = contract_storage.root_hash();

    // Proof demonstrates value at storage slot
}
```

### Cross-Contract Proof

Prove state from different contract:

```zig
pub fn crossContractProof() !void {
    // Contract A wants to verify data in Contract B
    var contract_b_storage = primitives.Trie.init(allocator);
    defer contract_b_storage.deinit();

    try contract_b_storage.put(key, value);

    // Contract B provides proof to Contract A
    const proof = try contract_b_storage.prove(key);
    defer proof.deinit(allocator);

    const storage_root = contract_b_storage.root_hash();

    // Contract A verifies proof without full storage
    const valid = try primitives.Trie.verify(
        storage_root,
        key,
        value,
        proof
    );
}
```

## Proof Optimization

### Path Compression

Extension nodes reduce proof size:

```
Without compression:
Root → Branch → Branch → Branch → Leaf
Proof: 5 nodes

With compression:
Root → Extension([1,2,3]) → Leaf
Proof: 3 nodes
```

### Node Encoding

RLP encoding optimizes small values:

```zig
// Small leaf (< 32 bytes) embedded directly
LeafNode {
    nibbles: [4],
    value: "small"
}
// Encoded inline in parent

// Large leaf (≥ 32 bytes) referenced by hash
LeafNode {
    nibbles: [4],
    value: "very long value exceeding 32 bytes..."
}
// Stored separately, parent contains hash
```

## Security Considerations

**Proof Integrity**: Hash chain prevents tampering. Modifying any node invalidates proof.

**Existence vs Non-Existence**: Proof can demonstrate key exists OR doesn't exist.

**Proof Size**: Depth limits prevent DoS via deep paths (though path compression helps).

**Deterministic Hashing**: Same trie structure always produces same root hash.

## Testing Proofs

Conceptual test (once API available):

```zig
test "Merkle proof - valid inclusion" {
    const testing = std.testing;
    const allocator = testing.allocator;

    var trie = primitives.Trie.init(allocator);
    defer trie.deinit();

    // Build trie
    try trie.put(&[_]u8{0x12, 0x34}, "value1");
    try trie.put(&[_]u8{0x56, 0x78}, "value2");

    // Generate proof
    const proof = try trie.prove(&[_]u8{0x12, 0x34});
    defer proof.deinit(allocator);

    // Verify proof
    const root = trie.root_hash();
    const valid = try primitives.Trie.verify(
        root.?,
        &[_]u8{0x12, 0x34},
        "value1",
        proof
    );

    try testing.expect(valid);
}

test "Merkle proof - invalid value" {
    const testing = std.testing;
    const allocator = testing.allocator;

    var trie = primitives.Trie.init(allocator);
    defer trie.deinit();

    try trie.put(&[_]u8{0x12, 0x34}, "value1");

    const proof = try trie.prove(&[_]u8{0x12, 0x34});
    defer proof.deinit(allocator);

    const root = trie.root_hash();

    // Wrong value should fail verification
    const valid = try primitives.Trie.verify(
        root.?,
        &[_]u8{0x12, 0x34},
        "wrong_value",
        proof
    );

    try testing.expect(!valid);
}
```

## Performance

Proof generation complexity:

- **Time**: O(depth) - traverse path once
- **Space**: O(depth) - store path nodes
- **Depth**: O(log n) average with path compression

**Benchmarks** (estimated, once implemented):
- Proof generation: 10-50 μs (depth 3-5)
- Proof size: 1-5 KB (depth 3-5)
- Verification: 20-100 μs

## Comparison with Other Tries

**Merkle Patricia Trie** (Ethereum):
- Proof size: O(log₁₆ n)
- Optimized for sparse data
- Path compression reduces depth

**Binary Merkle Tree**:
- Proof size: O(log₂ n)
- Simpler structure
- Larger proof for sparse data

**Verkle Trees** (Ethereum future):
- Proof size: O(1) or O(log n) (smaller constant)
- Quantum-resistant
- More complex cryptography

## Related

- **[Verification](/primitives/trie/verification)** - Verify Merkle proofs
- **[Operations](/primitives/trie/operations)** - Root hash computation
- **[RLP](/primitives/rlp)** - Node encoding format
- **[Keccak256](/crypto/keccak)** - Hash function

## References

- [Ethereum Yellow Paper](https://ethereum.github.io/yellowpaper/paper.pdf) - Appendix D
- [Merkle Patricia Trie Specification](https://ethereum.org/en/developers/docs/data-structures-and-encoding/patricia-merkle-trie/)
- [EIP-1186](https://eips.ethereum.org/EIPS/eip-1186) - eth_getProof RPC method
- [Light Clients](https://ethereum.org/en/developers/docs/nodes-and-clients/light-clients/)
