---
title: Trie Constructors
description: Creating and initializing Merkle Patricia Trie instances
---

# Trie Constructors

Initialize new Merkle Patricia Trie instances.

## init

Create empty trie:

```zig
pub fn init(allocator: Allocator) Trie
```

**Parameters:**
- `allocator`: Memory allocator for node storage

**Returns:**
- `Trie`: Empty trie instance

**Example:**

```zig
const std = @import("std");
const primitives = @import("primitives");

pub fn createTrie() !void {
    // Create with page allocator
    var trie = primitives.Trie.init(std.heap.page_allocator);
    defer trie.deinit();

    // Trie starts empty
    const root = trie.root_hash();
    // root = null

    // Add data
    try trie.put(&[_]u8{0x12, 0x34}, "value");
}
```

## deinit

Free all trie resources:

```zig
pub fn deinit(self: *Trie) void
```

**Parameters:** None

**Example:**

```zig
pub fn cleanup() !void {
    var trie = primitives.Trie.init(allocator);

    try trie.put(&[_]u8{0x12, 0x34}, "value1");
    try trie.put(&[_]u8{0x56, 0x78}, "value2");

    // Free all memory
    trie.deinit();
    // Trie cannot be used after deinit
}
```

### Automatic Cleanup with defer

Use `defer` for automatic cleanup:

```zig
pub fn automaticCleanup() !void {
    var trie = primitives.Trie.init(allocator);
    defer trie.deinit(); // Guaranteed cleanup

    try trie.put(&[_]u8{0xaa}, "data");

    // trie.deinit() called automatically
}
```

## Allocator Selection

### Arena Allocator

Efficient for short-lived tries:

```zig
pub fn arenaExample() !void {
    var arena = std.heap.ArenaAllocator.init(std.heap.page_allocator);
    defer arena.deinit();

    var trie = primitives.Trie.init(arena.allocator());
    // No need to call trie.deinit() - arena frees everything

    try trie.put(&[_]u8{0x12, 0x34}, "value");
}
```

**Benefits:**
- Fast allocation
- Single bulk deallocation
- No fragmentation

**Use Cases:**
- Temporary computations
- Single-use tries
- Batch processing

### General Purpose Allocator

Precise memory tracking:

```zig
pub fn gpaExample() !void {
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer _ = gpa.deinit();

    var trie = primitives.Trie.init(gpa.allocator());
    defer trie.deinit();

    try trie.put(&[_]u8{0xaa}, "data");
}
```

**Benefits:**
- Leak detection
- Memory usage tracking
- Fine-grained deallocation

**Use Cases:**
- Development/debugging
- Long-lived tries
- Memory-constrained environments

### Page Allocator

Direct OS memory:

```zig
pub fn pageExample() !void {
    var trie = primitives.Trie.init(std.heap.page_allocator);
    defer trie.deinit();

    try trie.put(&[_]u8{0xff}, "data");
}
```

**Benefits:**
- Simple interface
- No allocator overhead
- Direct memory mapping

**Use Cases:**
- Simple applications
- Large tries
- Production with known memory needs

### Fixed Buffer Allocator

Stack-allocated buffer:

```zig
pub fn fixedBufferExample() !void {
    var buffer: [1024 * 1024]u8 = undefined; // 1MB stack buffer
    var fba = std.heap.FixedBufferAllocator.init(&buffer);

    var trie = primitives.Trie.init(fba.allocator());
    defer trie.deinit();

    try trie.put(&[_]u8{0x12}, "small_trie");
}
```

**Benefits:**
- No heap allocation
- Predictable memory usage
- Fast allocation

**Use Cases:**
- Embedded systems
- Real-time systems
- Small, bounded tries

## Memory Considerations

### Node Storage

Each trie stores nodes in hash map:

```zig
pub const Trie = struct {
    allocator: Allocator,
    nodes: std.StringHashMap(Node),  // All nodes
    root: ?[32]u8,                   // Root hash
}
```

**Memory Usage:**
- Node hash (key): 64 bytes (hex string)
- Node data (value): Variable per type
- HashMap overhead: ~32 bytes per entry

### Per-Node Memory

**Leaf Node:**
```zig
LeafNode {
    nibbles: []u8,  // Path length
    value: []u8,    // Value length
}
// Total: ~16 bytes + path_len + value_len
```

**Extension Node:**
```zig
ExtensionNode {
    nibbles: []u8,      // Path length
    child_hash: [32]u8, // 32 bytes
}
// Total: ~48 bytes + path_len
```

**Branch Node:**
```zig
BranchNode {
    children: [16]?[32]u8,  // 512 bytes max
    value: ?[]u8,           // Optional value length
    mask: TrieMask,         // 2 bytes
}
// Total: ~514 bytes + optional value_len
```

### Estimating Memory

Rough estimate for trie with N entries:

```
Total ≈ N × (64 + 32 + avg_node_size + avg_value_size)
```

**Example:**
- 1000 entries
- Average key: 32 bytes
- Average value: 64 bytes
- Average node overhead: 100 bytes

```
Memory ≈ 1000 × (64 + 32 + 100 + 64) = 260 KB
```

Add 20-50% overhead for hash map and fragmentation.

## Initialization Patterns

### Preloaded Trie

Build trie with initial data:

```zig
pub fn preloadTrie(allocator: Allocator, data: []const struct { key: []const u8, value: []const u8 }) !primitives.Trie {
    var trie = primitives.Trie.init(allocator);
    errdefer trie.deinit();

    for (data) |entry| {
        try trie.put(entry.key, entry.value);
    }

    return trie;
}

// Usage
const initial_data = [_]struct { key: []const u8, value: []const u8 }{
    .{ .key = &[_]u8{0x12}, .value = "value1" },
    .{ .key = &[_]u8{0x34}, .value = "value2" },
};

var trie = try preloadTrie(allocator, &initial_data);
defer trie.deinit();
```

### Trie from Snapshot

Restore trie from serialized state:

```zig
pub fn fromSnapshot(allocator: Allocator, snapshot: []const u8) !primitives.Trie {
    var trie = primitives.Trie.init(allocator);
    errdefer trie.deinit();

    // Deserialize and rebuild trie
    // (Implementation depends on snapshot format)

    return trie;
}
```

### Temporary Computation

Short-lived trie with arena:

```zig
pub fn computeStateRoot(accounts: []const Account) ![32]u8 {
    var arena = std.heap.ArenaAllocator.init(std.heap.page_allocator);
    defer arena.deinit();

    var trie = primitives.Trie.init(arena.allocator());

    for (accounts) |account| {
        try trie.put(account.address, account.data);
    }

    return trie.root_hash() orelse return error.EmptyTrie;
}
```

## Error Handling

### Allocation Failures

Handle `OutOfMemory`:

```zig
pub fn robustInit() !void {
    var trie = primitives.Trie.init(allocator);
    defer trie.deinit();

    const result = trie.put(&[_]u8{0x12}, "value");
    result catch |err| switch (err) {
        error.OutOfMemory => {
            // Handle memory exhaustion
            std.log.err("Out of memory", .{});
            return err;
        },
        else => return err,
    };
}
```

### Cleanup on Error

Use `errdefer` for partial initialization:

```zig
pub fn initWithData(allocator: Allocator) !primitives.Trie {
    var trie = primitives.Trie.init(allocator);
    errdefer trie.deinit(); // Cleanup if error occurs

    try trie.put(&[_]u8{0x12}, "value1");
    try trie.put(&[_]u8{0x34}, "value2");
    // If second put fails, first allocation cleaned up

    return trie;
}
```

## Best Practices

**Always defer deinit**: Prevent memory leaks with `defer trie.deinit()`.

**Choose right allocator**: Arena for temporary, GPA for debugging, page for production.

**Handle OutOfMemory**: Large tries can exhaust memory; handle gracefully.

**Estimate memory needs**: Size allocator appropriately for expected data.

**Reuse tries**: Call `clear()` instead of deinit/init for multiple computations.

## Related

- **[Operations](/primitives/trie/operations)** - Using trie after initialization
- **[Usage Patterns](/primitives/trie/usage-patterns)** - Common initialization patterns
