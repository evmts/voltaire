---
title: Trie Operations
description: Insert, lookup, delete, and clear operations for Merkle Patricia Trie
---

# Trie Operations

Core operations for manipulating key-value pairs in Merkle Patricia Trie.

## put

Insert or update key-value pair:

```zig
pub fn put(self: *Trie, key: []const u8, value: []const u8) !void
```

**Parameters:**
- `key`: Byte array key (any length)
- `value`: Byte array value (any length)

**Errors:**
- `OutOfMemory`: Allocation failed
- `InvalidKey`: Malformed key

**Example:**

```zig
const std = @import("std");
const primitives = @import("primitives");

pub fn example() !void {
    var trie = primitives.Trie.init(std.heap.page_allocator);
    defer trie.deinit();

    // Insert new entry
    try trie.put(&[_]u8{0x12, 0x34}, "first_value");

    // Update existing entry
    try trie.put(&[_]u8{0x12, 0x34}, "updated_value");

    // Insert with different key
    try trie.put(&[_]u8{0xab, 0xcd}, "another_value");
}
```

### Behavior

**New Key**: Creates leaf node, updates root hash.

**Existing Key**: Replaces value, updates affected nodes and root hash.

**Path Compression**: Shared prefixes compressed into extension nodes.

**Example - Path Splitting:**

```zig
var trie = primitives.Trie.init(allocator);
defer trie.deinit();

// Insert first key: creates single leaf
try trie.put(&[_]u8{0x12, 0x34}, "value1");
// Structure: Leaf([1,2,3,4], "value1")

// Insert key with common prefix: creates extension + branch
try trie.put(&[_]u8{0x12, 0x56}, "value2");
// Structure:
// Extension([1,2]) → Branch {
//     [3]: Leaf([4], "value1")
//     [5]: Leaf([6], "value2")
// }
```

## get

Retrieve value for given key:

```zig
pub fn get(self: *const Trie, key: []const u8) !?[]const u8
```

**Parameters:**
- `key`: Byte array key to lookup

**Returns:**
- `?[]const u8`: Value if found, `null` if not found

**Errors:**
- `OutOfMemory`: Allocation failed during traversal

**Example:**

```zig
pub fn lookup() !void {
    var trie = primitives.Trie.init(allocator);
    defer trie.deinit();

    try trie.put(&[_]u8{0x12, 0x34}, "found_me");

    // Successful lookup
    const value = try trie.get(&[_]u8{0x12, 0x34});
    // value = "found_me"

    // Missing key
    const missing = try trie.get(&[_]u8{0xff, 0xff});
    // missing = null
}
```

### Traversal

Lookup follows path through trie:

1. **Empty**: Return null immediately
2. **Leaf**: Compare nibbles, return value if match
3. **Extension**: Match prefix, continue to child
4. **Branch**: Follow nibble index, recurse into child

**Example - Traversal Path:**

```zig
// Trie structure:
// Extension([1,2]) → Branch {
//     [3]: Leaf([4], "value1")
//     [5]: Leaf([6], "value2")
// }

// Lookup [1,2,3,4]:
// 1. Extension: Match [1,2], continue
// 2. Branch: Follow index 3
// 3. Leaf: Match [4], return "value1"

const value = try trie.get(&[_]u8{0x12, 0x34});
// value = "value1"
```

## delete

Remove key-value pair:

```zig
pub fn delete(self: *Trie, key: []const u8) !void
```

**Parameters:**
- `key`: Byte array key to remove

**Errors:**
- `OutOfMemory`: Allocation failed
- `NonExistentNode`: Internal node missing (corrupted trie)

**Example:**

```zig
pub fn removal() !void {
    var trie = primitives.Trie.init(allocator);
    defer trie.deinit();

    try trie.put(&[_]u8{0x12, 0x34}, "remove_me");

    // Delete entry
    try trie.delete(&[_]u8{0x12, 0x34});

    // Verify deletion
    const value = try trie.get(&[_]u8{0x12, 0x34});
    // value = null

    // Delete non-existent key (no-op)
    try trie.delete(&[_]u8{0xff, 0xff});
}
```

### Branch Collapse

Deleting entry may trigger structural changes:

**Single Entry**: Trie becomes empty (root = null).

**Branch with 1 Child + No Value**: Collapses to leaf or extension.

**Branch with 2+ Children or Value**: Remains branch.

**Example - Collapse Behavior:**

```zig
var trie = primitives.Trie.init(allocator);
defer trie.deinit();

try trie.put(&[_]u8{0x12, 0x34}, "value1");
try trie.put(&[_]u8{0x12, 0x56}, "value2");
try trie.put(&[_]u8{0x12, 0x78}, "value3");

// Structure: Extension([1,2]) → Branch {
//     [3]: Leaf([4], "value1")
//     [5]: Leaf([6], "value2")
//     [7]: Leaf([8], "value3")
// }

try trie.delete(&[_]u8{0x12, 0x34});
try trie.delete(&[_]u8{0x12, 0x56});

// Branch collapses: Extension([1,2]) → Leaf([7,8], "value3")
// Further simplified: Leaf([1,2,7,8], "value3")
```

## clear

Reset trie to empty state:

```zig
pub fn clear(self: *Trie) void
```

**Parameters:** None

**Example:**

```zig
pub fn reset() !void {
    var trie = primitives.Trie.init(allocator);
    defer trie.deinit();

    try trie.put(&[_]u8{0x12, 0x34}, "value1");
    try trie.put(&[_]u8{0x56, 0x78}, "value2");

    // Clear all entries
    trie.clear();

    // Trie now empty
    const root = trie.root_hash();
    // root = null
}
```

### Memory Management

`clear()` frees all nodes and resets internal storage. Trie reusable after clearing.

**Example - Clear and Reuse:**

```zig
var trie = primitives.Trie.init(allocator);
defer trie.deinit();

// First use
try trie.put(&[_]u8{0x11}, "first");
const hash1 = trie.root_hash();

// Clear
trie.clear();

// Reuse with different data
try trie.put(&[_]u8{0x22}, "second");
const hash2 = trie.root_hash();

// Different root hashes
// hash1 != hash2
```

## root_hash

Compute root hash for state commitment:

```zig
pub fn root_hash(self: *const Trie) ?[32]u8
```

**Returns:**
- `?[32]u8`: Keccak256 hash of root node, or `null` if empty

**Example:**

```zig
pub fn stateCommitment() !void {
    var trie = primitives.Trie.init(allocator);
    defer trie.deinit();

    // Empty trie
    const empty_root = trie.root_hash();
    // empty_root = null

    // Add data
    try trie.put(&[_]u8{0x12, 0x34}, "data");

    // Compute commitment
    const root = trie.root_hash();
    // root = [32]u8 (Keccak256 hash)

    // Root changes with data
    try trie.put(&[_]u8{0x56, 0x78}, "more_data");
    const new_root = trie.root_hash();
    // new_root != root
}
```

### Determinism

Root hash deterministic for given trie contents:

```zig
var trie1 = primitives.Trie.init(allocator);
defer trie1.deinit();
var trie2 = primitives.Trie.init(allocator);
defer trie2.deinit();

const keys = [_][]const u8{ &[_]u8{0x12}, &[_]u8{0x34}, &[_]u8{0x56} };

// Insert same data
for (keys) |key| {
    try trie1.put(key, "value");
    try trie2.put(key, "value");
}

const hash1 = trie1.root_hash();
const hash2 = trie2.root_hash();

// Identical hashes
// std.mem.eql(u8, &hash1.?, &hash2.?)
```

## Edge Cases

### Empty Key

Empty keys supported:

```zig
try trie.put(&[_]u8{}, "empty_key_value");
const value = try trie.get(&[_]u8{});
// value = "empty_key_value"
```

### Empty Value

Empty values supported:

```zig
try trie.put(&[_]u8{0x12, 0x34}, "");
const value = try trie.get(&[_]u8{0x12, 0x34});
// value = ""
```

### Large Keys

No length limit on keys:

```zig
var large_key: [256]u8 = undefined;
for (&large_key, 0..) |*byte, i| {
    byte.* = @intCast(i % 256);
}
try trie.put(&large_key, "large_key_value");
```

### Key Prefixes

Keys can be prefixes of other keys:

```zig
try trie.put(&[_]u8{0x12}, "short");
try trie.put(&[_]u8{0x12, 0x34}, "long");

const short = try trie.get(&[_]u8{0x12});
// short = "short"
const long = try trie.get(&[_]u8{0x12, 0x34});
// long = "long"
```

## Performance Tips

**Batch Inserts**: Insert related keys together for better path compression.

**Key Distribution**: Random keys create more branches; sequential keys compress better.

**Update vs Delete+Insert**: Update reuses structure; delete+insert rebuilds.

**Memory Usage**: Large tries hold many nodes; call `clear()` or `deinit()` to free.

## Related

- **[Constructors](/primitives/trie/constructors)** - Creating trie instances
- **[Proof Generation](/primitives/trie/proof-generation)** - Generate Merkle proofs
- **[Verification](/primitives/trie/verification)** - Verify proofs
- **[Usage Patterns](/primitives/trie/usage-patterns)** - Common usage examples
