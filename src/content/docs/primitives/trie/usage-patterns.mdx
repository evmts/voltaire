---
title: Trie Usage Patterns
description: Common patterns and practical examples for Merkle Patricia Trie
---

# Trie Usage Patterns

Common patterns and practical examples for using Merkle Patricia Trie in Ethereum applications.

## State Management

### Account State Trie

Ethereum's global state trie maps addresses to account states:

```zig
const std = @import("std");
const primitives = @import("primitives");
const Rlp = @import("Rlp");

pub const AccountState = struct {
    nonce: u64,
    balance: u256,
    storage_root: [32]u8,
    code_hash: [32]u8,

    pub fn encode(self: AccountState, allocator: Allocator) ![]u8 {
        // RLP encode account
        var list = std.ArrayList([]const u8){};
        defer list.deinit(allocator);

        try list.append(allocator, try Rlp.encode(allocator, self.nonce));
        try list.append(allocator, try Rlp.encode(allocator, self.balance));
        try list.append(allocator, try Rlp.encode(allocator, &self.storage_root));
        try list.append(allocator, try Rlp.encode(allocator, &self.code_hash));

        return try Rlp.encode(allocator, list.items);
    }
};

pub fn buildStateTrie(allocator: Allocator) !primitives.Trie {
    var state_trie = primitives.Trie.init(allocator);
    errdefer state_trie.deinit();

    // Account 1
    const addr1 = &[_]u8{0x12, 0x34, 0x56, 0x78};
    const account1 = AccountState{
        .nonce = 5,
        .balance = 1000000000000000000, // 1 ETH
        .storage_root = [_]u8{0} ** 32,
        .code_hash = [_]u8{0} ** 32,
    };
    const encoded1 = try account1.encode(allocator);
    defer allocator.free(encoded1);
    try state_trie.put(addr1, encoded1);

    // Account 2
    const addr2 = &[_]u8{0xab, 0xcd, 0xef, 0x01};
    const account2 = AccountState{
        .nonce = 0,
        .balance = 500000000000000000, // 0.5 ETH
        .storage_root = [_]u8{0} ** 32,
        .code_hash = [_]u8{0} ** 32,
    };
    const encoded2 = try account2.encode(allocator);
    defer allocator.free(encoded2);
    try state_trie.put(addr2, encoded2);

    return state_trie;
}
```

### Contract Storage Trie

Each contract has storage trie for persistent variables:

```zig
pub fn buildStorageTrie(allocator: Allocator) !primitives.Trie {
    var storage_trie = primitives.Trie.init(allocator);
    errdefer storage_trie.deinit();

    // Storage slot 0: owner address
    const slot0 = &[_]u8{0} ** 32;
    const owner = &[_]u8{0x12, 0x34, 0x56, 0x78};
    try storage_trie.put(slot0, owner);

    // Storage slot 1: total supply
    const slot1 = &[_]u8{0} ** 31 ++ [_]u8{1};
    const supply = std.mem.toBytes(@as(u256, 1000000));
    try storage_trie.put(slot1, &supply);

    // Storage slot for mapping: balances[addr]
    const mapping_key = try computeStorageKey(allocator, 2, owner);
    defer allocator.free(mapping_key);
    const balance = std.mem.toBytes(@as(u256, 100));
    try storage_trie.put(mapping_key, &balance);

    return storage_trie;
}

fn computeStorageKey(allocator: Allocator, slot: u256, key: []const u8) ![]u8 {
    // Keccak256(key || slot) - Solidity mapping storage layout
    var hasher = crypto.Keccak256.init(.{});
    hasher.update(key);
    hasher.update(&std.mem.toBytes(slot));
    var hash: [32]u8 = undefined;
    hasher.final(&hash);
    return try allocator.dupe(u8, &hash);
}
```

## Transaction Processing

### Transaction Trie

Block transaction trie orders transactions by index:

```zig
pub fn buildTransactionTrie(
    allocator: Allocator,
    transactions: []const Transaction
) !primitives.Trie {
    var tx_trie = primitives.Trie.init(allocator);
    errdefer tx_trie.deinit();

    for (transactions, 0..) |tx, index| {
        // Key: RLP-encoded transaction index
        const key = try Rlp.encode(allocator, index);
        defer allocator.free(key);

        // Value: RLP-encoded transaction
        const value = try tx.encode(allocator);
        defer allocator.free(value);

        try tx_trie.put(key, value);
    }

    return tx_trie;
}
```

### Receipt Trie

Transaction receipt trie stores execution results:

```zig
pub const Receipt = struct {
    status: u8,
    cumulative_gas_used: u64,
    logs: []const Log,
    bloom: [256]u8,

    pub fn encode(self: Receipt, allocator: Allocator) ![]u8 {
        // RLP encode receipt
        var list = std.ArrayList([]const u8){};
        defer list.deinit(allocator);

        try list.append(allocator, try Rlp.encode(allocator, self.status));
        try list.append(allocator, try Rlp.encode(allocator, self.cumulative_gas_used));
        try list.append(allocator, try encodeLogList(allocator, self.logs));
        try list.append(allocator, try Rlp.encode(allocator, &self.bloom));

        return try Rlp.encode(allocator, list.items);
    }
};

pub fn buildReceiptTrie(
    allocator: Allocator,
    receipts: []const Receipt
) !primitives.Trie {
    var receipt_trie = primitives.Trie.init(allocator);
    errdefer receipt_trie.deinit();

    for (receipts, 0..) |receipt, index| {
        const key = try Rlp.encode(allocator, index);
        defer allocator.free(key);

        const value = try receipt.encode(allocator);
        defer allocator.free(value);

        try receipt_trie.put(key, value);
    }

    return receipt_trie;
}
```

## State Snapshots

### Checkpoint/Rollback

Save state for potential rollback:

```zig
pub const StateManager = struct {
    current_state: primitives.Trie,
    checkpoints: std.ArrayList([32]u8),
    allocator: Allocator,

    pub fn init(allocator: Allocator) StateManager {
        return StateManager{
            .current_state = primitives.Trie.init(allocator),
            .checkpoints = std.ArrayList([32]u8).init(allocator),
            .allocator = allocator,
        };
    }

    pub fn deinit(self: *StateManager) void {
        self.current_state.deinit();
        self.checkpoints.deinit();
    }

    pub fn checkpoint(self: *StateManager) !void {
        const root = self.current_state.root_hash() orelse
            return error.EmptyState;
        try self.checkpoints.append(self.allocator, root);
    }

    pub fn commit(self: *StateManager) !void {
        // Discard checkpoint
        if (self.checkpoints.items.len > 0) {
            _ = self.checkpoints.pop();
        }
    }

    pub fn rollback(self: *StateManager) !void {
        if (self.checkpoints.items.len == 0) {
            return error.NoCheckpoint;
        }

        const checkpoint_root = self.checkpoints.pop();

        // Restore state to checkpoint
        // (Requires storing nodes by hash for reconstruction)
        // Implementation depends on node persistence strategy
    }
};
```

### State Diff

Compute changes between states:

```zig
pub const StateDiff = struct {
    added: std.StringHashMap([]const u8),
    modified: std.StringHashMap([]const u8),
    deleted: std.StringHashMap(void),

    pub fn init(allocator: Allocator) StateDiff {
        return StateDiff{
            .added = std.StringHashMap([]const u8).init(allocator),
            .modified = std.StringHashMap([]const u8).init(allocator),
            .deleted = std.StringHashMap(void).init(allocator),
        };
    }

    pub fn deinit(self: *StateDiff) void {
        self.added.deinit();
        self.modified.deinit();
        self.deleted.deinit();
    }
};

pub fn computeDiff(
    allocator: Allocator,
    old_state: primitives.Trie,
    new_state: primitives.Trie
) !StateDiff {
    var diff = StateDiff.init(allocator);
    errdefer diff.deinit();

    // Track all keys from both tries
    // Compare values to determine added/modified/deleted
    // (Requires trie iteration - not yet in public API)

    return diff;
}
```

## Batch Operations

### Bulk Insert

Efficiently insert many entries:

```zig
pub fn bulkInsert(
    allocator: Allocator,
    entries: []const struct { key: []const u8, value: []const u8 }
) !primitives.Trie {
    var trie = primitives.Trie.init(allocator);
    errdefer trie.deinit();

    // Sort keys for better path compression
    const sorted = try sortEntries(allocator, entries);
    defer allocator.free(sorted);

    for (sorted) |entry| {
        try trie.put(entry.key, entry.value);
    }

    return trie;
}

fn sortEntries(
    allocator: Allocator,
    entries: []const struct { key: []const u8, value: []const u8 }
) ![]struct { key: []const u8, value: []const u8 } {
    const sorted = try allocator.dupe(@TypeOf(entries[0]), entries);
    std.sort.pdq(@TypeOf(entries[0]), sorted, {}, lessThan);
    return sorted;
}

fn lessThan(
    _: void,
    a: struct { key: []const u8, value: []const u8 },
    b: struct { key: []const u8, value: []const u8 }
) bool {
    return std.mem.lessThan(u8, a.key, b.key);
}
```

### Batch Verification

Verify multiple proofs efficiently:

```zig
pub fn batchVerify(
    allocator: Allocator,
    root: [32]u8,
    entries: []const struct {
        key: []const u8,
        value: []const u8,
        proof: Proof
    }
) !bool {
    for (entries) |entry| {
        const valid = try primitives.Trie.verify(
            root,
            entry.key,
            entry.value,
            entry.proof
        );

        if (!valid) return false;
    }

    return true;
}
```

## Memory Optimization

### Arena for Temporary Tries

Use arena allocator for short-lived tries:

```zig
pub fn processBlock(block: Block) ![32]u8 {
    var arena = std.heap.ArenaAllocator.init(std.heap.page_allocator);
    defer arena.deinit(); // Free all at once

    const allocator = arena.allocator();

    // Build temporary tries
    var tx_trie = try buildTransactionTrie(allocator, block.transactions);
    var receipt_trie = try buildReceiptTrie(allocator, block.receipts);

    // Extract roots
    const tx_root = tx_trie.root_hash() orelse return error.EmptyTxTrie;
    const receipt_root = receipt_trie.root_hash() orelse return error.EmptyReceiptTrie;

    // Compute block hash (includes both roots)
    return computeBlockHash(tx_root, receipt_root);
}
```

### Clear and Reuse

Reuse trie structure for multiple computations:

```zig
pub fn processBatch(batches: []const []const Entry) !void {
    var trie = primitives.Trie.init(allocator);
    defer trie.deinit();

    for (batches) |batch| {
        // Process batch
        for (batch) |entry| {
            try trie.put(entry.key, entry.value);
        }

        // Extract result
        const root = trie.root_hash();
        try storeResult(root);

        // Clear for next batch
        trie.clear();
    }
}
```

## Testing Patterns

### Property-Based Testing

Test trie properties:

```zig
test "Trie - deterministic root hash" {
    const testing = std.testing;
    const allocator = testing.allocator;

    // Generate random data
    var prng = std.Random.DefaultPrng.init(42);
    const random = prng.random();

    const entry_count = 100;
    var entries = std.ArrayList(struct { key: [32]u8, value: [32]u8 }).init(allocator);
    defer entries.deinit();

    var i: usize = 0;
    while (i < entry_count) : (i += 1) {
        var key: [32]u8 = undefined;
        var value: [32]u8 = undefined;
        random.bytes(&key);
        random.bytes(&value);
        try entries.append(.{ .key = key, .value = value });
    }

    // Build trie twice with same data
    var trie1 = primitives.Trie.init(allocator);
    defer trie1.deinit();
    var trie2 = primitives.Trie.init(allocator);
    defer trie2.deinit();

    for (entries.items) |entry| {
        try trie1.put(&entry.key, &entry.value);
        try trie2.put(&entry.key, &entry.value);
    }

    // Same root hash
    const root1 = trie1.root_hash();
    const root2 = trie2.root_hash();
    try testing.expect(root1 != null and root2 != null);
    try testing.expectEqualSlices(u8, &root1.?, &root2.?);
}
```

### Fuzzing

Stress test with random operations:

```zig
test "Trie - fuzz operations" {
    const testing = std.testing;
    const allocator = testing.allocator;

    var trie = primitives.Trie.init(allocator);
    defer trie.deinit();

    var prng = std.Random.DefaultPrng.init(0);
    const random = prng.random();

    var reference = std.StringHashMap([]const u8).init(allocator);
    defer reference.deinit();

    var i: usize = 0;
    while (i < 1000) : (i += 1) {
        const op = random.uintLessThan(u8, 3);

        var key: [8]u8 = undefined;
        random.bytes(&key);

        switch (op) {
            0 => { // Insert
                var value: [16]u8 = undefined;
                random.bytes(&value);
                try trie.put(&key, &value);
            },
            1 => { // Delete
                try trie.delete(&key);
            },
            2 => { // Lookup
                _ = try trie.get(&key);
            },
            else => unreachable,
        }
    }

    // Trie should remain valid
    _ = trie.root_hash();
}
```

## Performance Patterns

### Key Prefixing

Group related data with common prefixes:

```zig
pub fn storageKeyForAccount(account: []const u8, slot: u256) [32]u8 {
    // Prefix: first N bytes of account address
    // Suffix: storage slot
    // Better path compression for same-account storage
    var key: [32]u8 = undefined;
    @memcpy(key[0..20], account[0..20]);
    @memcpy(key[20..], &std.mem.toBytes(slot));
    return key;
}
```

### Lazy Evaluation

Compute root hash only when needed:

```zig
pub const LazyTrie = struct {
    trie: primitives.Trie,
    dirty: bool,
    cached_root: ?[32]u8,

    pub fn put(self: *LazyTrie, key: []const u8, value: []const u8) !void {
        try self.trie.put(key, value);
        self.dirty = true;
    }

    pub fn getRootHash(self: *LazyTrie) ?[32]u8 {
        if (self.dirty) {
            self.cached_root = self.trie.root_hash();
            self.dirty = false;
        }
        return self.cached_root;
    }
};
```

## Related

- **[Operations](/primitives/trie/operations)** - Core trie operations
- **[Constructors](/primitives/trie/constructors)** - Initialization patterns
- **[Proof Generation](/primitives/trie/proof-generation)** - Merkle proofs
- **[Verification](/primitives/trie/verification)** - Proof verification
