---
title: Merkle Proof Verification
description: Verify cryptographic proofs against trie root hash
---

# Merkle Proof Verification

Verify Merkle proofs without full trie access using only root hash.

## Overview

Proof verification enables lightweight state validation. Verifier reconstructs path from proof nodes and compares computed root hash against known root.

**Benefits:**
- No full trie storage required
- Cryptographically secure verification
- Constant-time verification (independent of trie size)
- Enables light clients and layer 2 solutions

## Verification Algorithm

Reconstruct root hash from proof:

```zig
// Conceptual algorithm (implementation in progress)
pub fn verify(
    root: [32]u8,
    key: []const u8,
    value: ?[]const u8,
    proof: Proof
) !bool {
    const nibbles = try keyToNibbles(allocator, key);
    defer allocator.free(nibbles);

    var current_hash: [32]u8 = undefined;
    var nibble_offset: usize = 0;

    // Process proof nodes from leaf to root
    for (proof.nodes) |encoded_node| {
        const node = try decodeNode(allocator, encoded_node);
        defer node.deinit(allocator);

        switch (node) {
            .Leaf => |leaf| {
                // Verify leaf matches key and value
                if (!std.mem.eql(u8, leaf.nibbles, nibbles[nibble_offset..])) {
                    return false;
                }
                if (value) |v| {
                    if (!std.mem.eql(u8, leaf.value, v)) {
                        return false;
                    }
                } else {
                    // Non-existence proof
                    return false;
                }
                current_hash = try hash_node(allocator, &node);
            },
            .Extension => |ext| {
                // Verify extension matches path
                if (!std.mem.eql(u8, ext.nibbles, nibbles[nibble_offset..nibble_offset + ext.nibbles.len])) {
                    return false;
                }
                nibble_offset += ext.nibbles.len;
                current_hash = try hash_node(allocator, &node);
            },
            .Branch => |branch| {
                // Verify branch contains expected child
                const nibble = nibbles[nibble_offset];
                if (branch.get_child(nibble) == null) {
                    return false;
                }
                nibble_offset += 1;
                current_hash = try hash_node(allocator, &node);
            },
            .Empty => return false,
        }
    }

    // Compare reconstructed root with expected
    return std.mem.eql(u8, &current_hash, &root);
}
```

## Verification Process

### Step-by-Step

1. **Decode Proof**: Parse RLP-encoded nodes
2. **Traverse Path**: Follow key nibbles through proof nodes
3. **Validate Nodes**: Check each node matches expected structure
4. **Compute Hashes**: Hash each node bottom-up
5. **Compare Root**: Final hash must match known root

### Example Verification

```zig
const std = @import("std");
const primitives = @import("primitives");

pub fn verifyStateProof() !void {
    // Known state root (from block header)
    const state_root: [32]u8 = block_header.state_root;

    // Account address to verify
    const account_address = &[_]u8{0x12, 0x34, 0x56, 0x78};

    // Claimed account state
    const account_state = "..."; // RLP-encoded account

    // Merkle proof provided by full node
    const proof: Proof = receive_proof_from_full_node();

    // Verify without full state trie
    const valid = try primitives.Trie.verify(
        state_root,
        account_address,
        account_state,
        proof
    );

    if (valid) {
        // Account state verified!
        std.log.info("Account state valid", .{});
    } else {
        // Proof invalid or account doesn't exist
        std.log.err("Invalid proof", .{});
    }
}
```

## Existence vs Non-Existence

### Existence Proof

Proves key-value pair exists in trie:

```zig
// Proof path leads to leaf with matching key and value
const valid = try primitives.Trie.verify(
    root,
    key,
    value,  // Expected value (Some)
    proof
);
// valid = true if key exists with value
```

### Non-Existence Proof

Proves key doesn't exist in trie:

```zig
// Proof path leads to:
// - Different leaf (key mismatch)
// - Branch without child at nibble
// - Empty node

const valid = try primitives.Trie.verify(
    root,
    key,
    null,  // No value expected
    proof
);
// valid = true if key doesn't exist
```

### Example - Both Cases

```zig
pub fn existenceProofs() !void {
    var trie = primitives.Trie.init(allocator);
    defer trie.deinit();

    try trie.put(&[_]u8{0x12, 0x34}, "exists");

    const root = trie.root_hash().?;

    // Existence proof
    const proof1 = try trie.prove(&[_]u8{0x12, 0x34});
    defer proof1.deinit(allocator);
    const valid1 = try primitives.Trie.verify(
        root,
        &[_]u8{0x12, 0x34},
        "exists",
        proof1
    );
    // valid1 = true

    // Non-existence proof
    const proof2 = try trie.prove(&[_]u8{0xff, 0xff});
    defer proof2.deinit(allocator);
    const valid2 = try primitives.Trie.verify(
        root,
        &[_]u8{0xff, 0xff},
        null,
        proof2
    );
    // valid2 = true (key doesn't exist)
}
```

## Light Client Workflow

Typical light client verification:

```zig
pub const LightClient = struct {
    trusted_roots: std.AutoHashMap([32]u8, void),

    pub fn verifyAccountState(
        self: *LightClient,
        block_hash: [32]u8,
        account: []const u8,
        state: []const u8,
        proof: Proof
    ) !bool {
        // 1. Get trusted state root for block
        const header = try self.getBlockHeader(block_hash);
        const state_root = header.state_root;

        // 2. Verify state root is trusted
        if (!self.trusted_roots.contains(state_root)) {
            return error.UntrustedRoot;
        }

        // 3. Verify proof against trusted root
        return try primitives.Trie.verify(
            state_root,
            account,
            state,
            proof
        );
    }

    pub fn verifyStorageSlot(
        self: *LightClient,
        storage_root: [32]u8,
        slot: []const u8,
        value: []const u8,
        proof: Proof
    ) !bool {
        // Verify storage proof against account's storage root
        return try primitives.Trie.verify(
            storage_root,
            slot,
            value,
            proof
        );
    }
};
```

## Verification Security

### Tampering Detection

Any modification invalidates proof:

```zig
// Original proof valid
const valid = try primitives.Trie.verify(root, key, value, proof);
// valid = true

// Tamper with proof
proof.nodes[0][5] ^= 0xFF; // Flip byte

// Verification fails
const tampered = try primitives.Trie.verify(root, key, value, proof);
// tampered = false
```

### Wrong Value Detection

Proof only valid for correct value:

```zig
const proof = try trie.prove(&[_]u8{0x12, 0x34});
const root = trie.root_hash().?;

// Correct value
const valid1 = try primitives.Trie.verify(
    root,
    &[_]u8{0x12, 0x34},
    "correct_value",
    proof
);
// valid1 = true

// Wrong value
const valid2 = try primitives.Trie.verify(
    root,
    &[_]u8{0x12, 0x34},
    "wrong_value",
    proof
);
// valid2 = false
```

### Root Mismatch Detection

Proof invalid for different root:

```zig
var trie1 = primitives.Trie.init(allocator);
defer trie1.deinit();
var trie2 = primitives.Trie.init(allocator);
defer trie2.deinit();

try trie1.put(&[_]u8{0x12}, "value1");
try trie2.put(&[_]u8{0x34}, "value2");

const proof1 = try trie1.prove(&[_]u8{0x12});
defer proof1.deinit(allocator);

const root2 = trie2.root_hash().?;

// Proof from trie1 invalid for root2
const valid = try primitives.Trie.verify(
    root2,
    &[_]u8{0x12},
    "value1",
    proof1
);
// valid = false
```

## Performance

Verification complexity:

- **Time**: O(proof_depth) - hash each node once
- **Space**: O(proof_depth) - decode nodes sequentially
- **Depth**: O(log n) average

**Benchmarks** (estimated, once implemented):
- Verification: 20-100 Î¼s (depth 3-5)
- Memory: 1-5 KB (proof size)
- No trie storage required

## Use Cases

### Light Client State Queries

Verify account balance without full state:

```zig
pub fn getAccountBalance(
    light_client: *LightClient,
    block_hash: [32]u8,
    account: []const u8
) !u256 {
    // Request proof from full node
    const response = try light_client.requestAccountProof(block_hash, account);

    // Verify proof
    const valid = try light_client.verifyAccountState(
        block_hash,
        account,
        response.account_state,
        response.proof
    );

    if (!valid) return error.InvalidProof;

    // Decode verified state
    const account_data = try decodeAccountState(response.account_state);
    return account_data.balance;
}
```

### Cross-Chain Bridges

Verify state on different chain:

```zig
pub fn verifyDepositOnL1(
    l2_contract: *L2Contract,
    l1_state_root: [32]u8,
    deposit_proof: Proof
) !void {
    // Verify deposit exists in L1 state
    const valid = try primitives.Trie.verify(
        l1_state_root,
        deposit_contract_address,
        deposit_data,
        deposit_proof
    );

    if (!valid) return error.InvalidDeposit;

    // Process verified deposit on L2
    try l2_contract.processDeposit(deposit_data);
}
```

### Fraud Proofs

Prove invalid state transition:

```zig
pub fn submitFraudProof(
    l2_contract: *L2Contract,
    claimed_state_root: [32]u8,
    proof: Proof
) !void {
    // Prover claims state root incorrect
    // Provides proof of correct state

    const valid = try primitives.Trie.verify(
        claimed_state_root,
        account_address,
        correct_state,
        proof
    );

    if (!valid) {
        // Proof shows claimed root is wrong
        try l2_contract.slashValidator();
    }
}
```

## Testing Verification

Conceptual tests (once API available):

```zig
test "Trie verify - valid proof" {
    const testing = std.testing;
    const allocator = testing.allocator;

    var trie = primitives.Trie.init(allocator);
    defer trie.deinit();

    try trie.put(&[_]u8{0x12, 0x34}, "value");

    const proof = try trie.prove(&[_]u8{0x12, 0x34});
    defer proof.deinit(allocator);

    const root = trie.root_hash().?;
    const valid = try primitives.Trie.verify(root, &[_]u8{0x12, 0x34}, "value", proof);

    try testing.expect(valid);
}

test "Trie verify - tampered proof" {
    const testing = std.testing;
    const allocator = testing.allocator;

    var trie = primitives.Trie.init(allocator);
    defer trie.deinit();

    try trie.put(&[_]u8{0x12, 0x34}, "value");

    const proof = try trie.prove(&[_]u8{0x12, 0x34});
    defer proof.deinit(allocator);

    // Tamper with proof
    proof.nodes[0][0] ^= 0xFF;

    const root = trie.root_hash().?;
    const valid = try primitives.Trie.verify(root, &[_]u8{0x12, 0x34}, "value", proof);

    try testing.expect(!valid);
}

test "Trie verify - non-existence" {
    const testing = std.testing;
    const allocator = testing.allocator;

    var trie = primitives.Trie.init(allocator);
    defer trie.deinit();

    try trie.put(&[_]u8{0x12, 0x34}, "value");

    const proof = try trie.prove(&[_]u8{0xff, 0xff});
    defer proof.deinit(allocator);

    const root = trie.root_hash().?;
    const valid = try primitives.Trie.verify(root, &[_]u8{0xff, 0xff}, null, proof);

    try testing.expect(valid);
}
```

## Best Practices

**Verify Root First**: Ensure root hash trusted before verification.

**Handle Missing Keys**: Non-existence proofs valid; check `null` value case.

**Validate Proof Size**: Reject unreasonably large proofs (DoS protection).

**Cache Verification**: Cache verified values to avoid repeated proof checks.

**Time Limits**: Set verification timeout for DoS protection.

## Related

- **[Proof Generation](/primitives/trie/proof-generation)** - Generate proofs
- **[Operations](/primitives/trie/operations)** - Root hash computation
- **[RLP](/primitives/rlp)** - Proof encoding format
- **[Keccak256](/crypto/keccak)** - Hash function

## References

- [Ethereum Yellow Paper](https://ethereum.github.io/yellowpaper/paper.pdf) - Appendix D
- [EIP-1186](https://eips.ethereum.org/EIPS/eip-1186) - eth_getProof specification
- [Light Client Protocol](https://ethereum.org/en/developers/docs/nodes-and-clients/light-clients/)
