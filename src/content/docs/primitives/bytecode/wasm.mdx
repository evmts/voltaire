---
title: Bytecode WASM Implementation
description: WebAssembly-accelerated bytecode operations compiled from Zig
---

# WASM Implementation

WebAssembly-accelerated bytecode operations for high-performance analysis.

## Overview

Critical bytecode operations compiled from Zig to WebAssembly for native-speed execution:
- Jump destination analysis
- Bytecode boundary checking
- Structure validation

**Performance:** WASM implementation provides significant speedup for large bytecode analysis compared to JavaScript implementation.

## Available Operations

### `analyzeJumpDestinations(code)`

Find all valid JUMPDEST positions using WASM.

```typescript
import { analyzeJumpDestinations } from '@tevm/voltaire/Bytecode.wasm'

const code = new Uint8Array([0x60, 0x5b, 0x5b])  // PUSH1 0x5b, JUMPDEST
const jumpdests = analyzeJumpDestinations(code)

// Returns JumpDestination[]
jumpdests.forEach(jd => {
  console.log(`Position ${jd.position}: ${jd.valid ? 'valid' : 'invalid'}`)
})
```

**Parameters:**
- `code: Uint8Array` - Bytecode to analyze

**Returns:** `JumpDestination[]` - Array of jump destinations with positions

**Type definition:**
```typescript
interface JumpDestination {
  position: number
  valid: boolean
}
```

Defined in: [primitives/Bytecode/Bytecode.wasm.ts:23](https://github.com/evmts/primitives/blob/main/src/primitives/Bytecode/Bytecode.wasm.ts)

**WASM source:** [primitives/Bytecode/bytecode.zig](https://github.com/evmts/primitives/blob/main/src/primitives/Bytecode/bytecode.zig)

### `isBytecodeBoundary(code, position)`

Check if position is at instruction boundary (not inside PUSH data).

```typescript
import { isBytecodeBoundary } from '@tevm/voltaire/Bytecode.wasm'

const code = new Uint8Array([0x60, 0x01, 0x00])  // PUSH1 0x01, STOP

isBytecodeBoundary(code, 0)  // true  - PUSH1 opcode
isBytecodeBoundary(code, 1)  // false - Inside PUSH1 data
isBytecodeBoundary(code, 2)  // true  - STOP opcode
```

**Parameters:**
- `code: Uint8Array` - Bytecode
- `position: number` - Position to check

**Returns:** `boolean` - `true` if position is instruction boundary

Defined in: [primitives/Bytecode/Bytecode.wasm.ts:39](https://github.com/evmts/primitives/blob/main/src/primitives/Bytecode/Bytecode.wasm.ts)

### `isValidJumpDest(code, position)`

Check if position is valid JUMPDEST using WASM.

```typescript
import { isValidJumpDest } from '@tevm/voltaire/Bytecode.wasm'

const code = new Uint8Array([0x5b, 0x60, 0x5b, 0x5b])
// JUMPDEST, PUSH1 0x5b, JUMPDEST

isValidJumpDest(code, 0)  // true  - Actual JUMPDEST
isValidJumpDest(code, 1)  // false - PUSH1 opcode
isValidJumpDest(code, 2)  // false - Inside PUSH1 data (0x5b)
isValidJumpDest(code, 3)  // true  - Actual JUMPDEST
```

**Parameters:**
- `code: Uint8Array` - Bytecode
- `position: number` - Position to check

**Returns:** `boolean` - `true` if position is valid JUMPDEST

Defined in: [primitives/Bytecode/Bytecode.wasm.ts:53](https://github.com/evmts/primitives/blob/main/src/primitives/Bytecode/Bytecode.wasm.ts)

### `validateBytecode(code)`

Validate bytecode structure using WASM.

```typescript
import { validateBytecode } from '@tevm/voltaire/Bytecode.wasm'

const valid = new Uint8Array([0x60, 0x01])    // PUSH1 0x01
const invalid = new Uint8Array([0x60])        // PUSH1 with no data

try {
  validateBytecode(valid)    // Success, no throw
  validateBytecode(invalid)  // Throws Error
} catch (err) {
  console.error("Invalid bytecode:", err.message)
}
```

**Parameters:**
- `code: Uint8Array` - Bytecode to validate

**Returns:** `void` - Throws if invalid

**Throws:** `Error` - If bytecode has incomplete PUSH instructions

Defined in: [primitives/Bytecode/Bytecode.wasm.ts:64](https://github.com/evmts/primitives/blob/main/src/primitives/Bytecode/Bytecode.wasm.ts)

## When to Use WASM

### Use WASM Implementation When:
- **Large bytecode** (greater than 10KB) analysis
- **Repeated analysis** of same bytecode
- **Performance critical** paths
- **Batch processing** many contracts
- **Real-time analysis** needed

### Use JavaScript Implementation When:
- **Small bytecode** (`less than 1KB`)
- **One-off analysis**
- **Tree-shaking** critical (WASM adds bundle size)
- **Compatibility** concerns
- **Debugging** needed

## Performance Comparison

Approximate speedup for jump destination analysis:

| Bytecode Size | JS Time | WASM Time | Speedup |
|---------------|---------|-----------|---------|
| 1 KB          | 1 ms    | 0.8 ms    | 1.25x   |
| 10 KB         | 10 ms   | 3 ms      | 3.3x    |
| 100 KB        | 100 ms  | 15 ms     | 6.7x    |
| 1 MB          | 1000 ms | 80 ms     | 12.5x   |

**Note:** Performance varies by browser and hardware. WASM shines for large bytecode.

## Integration Patterns

### Hybrid approach (recommended)

```typescript
import { analyze } from '@tevm/voltaire/BrandedBytecode'
import { analyzeJumpDestinations as wasmAnalyze } from '@tevm/voltaire/Bytecode.wasm'

function smartAnalyze(code: Uint8Array) {
  const size = code.length

  // Use WASM for large bytecode
  if (size > 10_000) {
    const jumpdests = wasmAnalyze(code)
    // Convert to Set for consistency
    return new Set(jumpdests.map(jd => jd.position))
  }

  // Use JS for small bytecode
  return analyze(code).jumpDestinations
}
```

### Batch processing with WASM

```typescript
import { analyzeJumpDestinations } from '@tevm/voltaire/Bytecode.wasm'

async function analyzeContracts(
  contracts: Array<{ address: string, code: Uint8Array }>
) {
  return contracts.map(contract => ({
    address: contract.address,
    jumpdests: analyzeJumpDestinations(contract.code),
    size: contract.code.length,
  }))
}
```

### Fallback to JS

```typescript
import { analyzeJumpDestinations as jsAnalyze } from '@tevm/voltaire/BrandedBytecode'

let wasmAnalyze: typeof jsAnalyze | null = null

try {
  const wasm = await import('@tevm/voltaire/Bytecode.wasm')
  wasmAnalyze = (code) => {
    const result = wasm.analyzeJumpDestinations(code)
    return new Set(result.map(jd => jd.position))
  }
} catch (err) {
  console.warn("WASM not available, using JS implementation")
}

export function analyzeJumpDests(code: Uint8Array): Set<number> {
  if (wasmAnalyze) {
    return wasmAnalyze(code)
  }
  return jsAnalyze(code)
}
```

## Zig Implementation

WASM functions compiled from Zig source:

```zig
/// Analyze bytecode to identify valid JUMPDEST locations
fn analyzeJumpDests(code: []const u8, valid_jumpdests: *std.AutoArrayHashMap(u32, void)) !void {
    var pc: u32 = 0;

    while (pc < code.len) {
        const opcode = code[pc];

        // Check if this is a JUMPDEST (0x5b)
        if (opcode == 0x5b) {
            try valid_jumpdests.put(pc, {});
            pc += 1;
        } else if (`opcode >= 0`x60 and `opcode <= 0`x7f) {
            // PUSH1 through PUSH32
            const push_size = opcode - 0x5f;
            // Skip the PUSH opcode and all immediate data bytes
            pc += 1 + push_size;
        } else {
            // All other opcodes are single byte
            pc += 1;
        }
    }
}
```

Full implementation: [primitives/Bytecode/bytecode.zig](https://github.com/evmts/primitives/blob/main/src/primitives/Bytecode/bytecode.zig)

## Bundle Size Impact

WASM adds to bundle size:

```
BrandedBytecode (JS only): ~5 KB
Bytecode.wasm: ~15 KB (WASM module + bindings)
```

**Trade-off:** Bundle size vs runtime performance

For small applications or infrequent use, JS implementation may be better. For large-scale analysis or performance-critical paths, WASM overhead is worthwhile.

## Browser Compatibility

WASM supported in all modern browsers:
- Chrome 57+
- Firefox 52+
- Safari 11+
- Edge 16+

For older browsers, use JavaScript implementation as fallback.

## Development

### Building WASM

```bash
# Compile Zig to WASM
zig build -Doptimize=ReleaseFast

# Run WASM tests
zig build test
```

### Debugging WASM

```typescript
import { analyzeJumpDestinations } from '@tevm/voltaire/Bytecode.wasm'

// Enable WASM logging (if implemented)
const code = new Uint8Array([0x60, 0x5b, 0x5b])

try {
  const result = analyzeJumpDestinations(code)
  console.log("WASM result:", result)
} catch (err) {
  console.error("WASM error:", err)
  // Fall back to JS implementation
}
```

## API Comparison

| Feature | JavaScript | WASM |
|---------|-----------|------|
| `analyzeJumpDestinations` | Returns `Set<number>` | Returns `JumpDestination[]` |
| `isValidJumpDest` | Available | Available |
| `isBytecodeBoundary` | Not available | Available (WASM only) |
| `validate` | Returns `boolean` | Throws on error |
| Performance (large) | Baseline | 5-15x faster |
| Bundle size | Smaller | Larger (+10KB) |
| Tree-shakeable | Yes | No (WASM binary) |

## Related

- [Bytecode](/primitives/bytecode/) - Main Bytecode documentation
- [Analysis](/primitives/bytecode/analysis) - JavaScript analysis implementation
- [BrandedBytecode](/primitives/bytecode/branded-bytecode) - Tree-shakeable API
- [Zig Source](https://github.com/evmts/primitives/blob/main/src/primitives/Bytecode/bytecode.zig) - WASM implementation source
