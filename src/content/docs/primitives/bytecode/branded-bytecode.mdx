---
title: BrandedBytecode
description: Tree-shakeable functional API for Bytecode operations
---

# BrandedBytecode

Tree-shakeable functional API for Bytecode operations with optimal bundle size.

## Overview

`BrandedBytecode` is the functional layer underlying bytecode operations. It provides:
- **Zero-overhead** [branded type](/primitives/branded-types) wrapping `Uint8Array`
- **Tree-shakeable** individual function exports
- **Data-first** unopinionated methods taking bytecode as first parameter
- **Bundle optimization** through selective imports

Primary benefit: When using tree-shakeable imports and avoiding methods that use keccak256, those implementations are excluded from bundle.

## Type Definition

```typescript
export type BrandedBytecode = Uint8Array & {
  readonly __tag: "Bytecode"
}
```

Runtime-validated `Uint8Array` representing EVM bytecode. [Brand](/primitives/branded-types) prevents accidental mixing with other Uint8Arrays.

Defined in: [primitives/Bytecode/BrandedBytecode/BrandedBytecode.ts](https://github.com/evmts/primitives/blob/main/src/primitives/Bytecode/BrandedBytecode/BrandedBytecode.ts)

## Namespace API

All functions exported as both individual exports and namespace:

```typescript
import * as Bytecode from '@tevm/voltaire/BrandedBytecode'

// Namespace usage
const code = Bytecode.from("0x6001")
const analysis = Bytecode.analyze(code)
const hex = Bytecode.toHex(code)
```

## Tree-Shakeable Usage

Import only what you need:

```typescript
import {
  from,
  fromHex,
  analyze,
  validate,
  toHex
} from '@tevm/voltaire/BrandedBytecode'
import type { BrandedBytecode } from '@tevm/voltaire/BrandedBytecode'

const code: BrandedBytecode = fromHex("0x6001")
const valid = validate(code)
const analysis = analyze(code)
const hex = toHex(code)
```

**Bundle impact:** Only `fromHex`, `analyze`, `validate`, and `toHex` included. Methods like `hash` excluded along with keccak256 dependency.

## Available Functions

All Bytecode functionality available as tree-shakeable functions:

### Constructors

```typescript
import { from, fromHex } from '@tevm/voltaire/BrandedBytecode'

const code1 = from("0x6001")
const code2 = from(new Uint8Array([0x60, 0x01]))
const code3 = fromHex("0x6001")
const code4 = fromHex("6001")  // Works without prefix
```

See [Constructors](/primitives/bytecode/constructors) for details.

### Conversions

```typescript
import { toHex } from '@tevm/voltaire/BrandedBytecode'

const hex = toHex(code)          // "0x6001"
const hexNoPrefix = toHex(code, false)  // "6001"
```

See [Conversions](/primitives/bytecode/conversions) for details.

### Validation

```typescript
import { validate } from '@tevm/voltaire/BrandedBytecode'

const valid = validate(code)  // boolean

// Check for incomplete PUSH instructions
const incomplete = fromHex("0x60")  // PUSH1 with no data
validate(incomplete)  // false
```

See [Validation](/primitives/bytecode/validation) for details.

### Analysis

```typescript
import {
  analyze,
  analyzeJumpDestinations,
  isValidJumpDest,
  parseInstructions,
  isPush,
  getPushSize,
  isTerminator
} from '@tevm/voltaire/BrandedBytecode'

// Complete analysis
const analysis = analyze(code)
// {
//   valid: boolean,
//   jumpDestinations: Set<number>,
//   instructions: Instruction[]
// }

// Jump destination analysis
const jumpdests = analyzeJumpDestinations(code)
const isJumpDest = isValidJumpDest(code, position)

// Instruction parsing
const instructions = parseInstructions(code)

// Opcode utilities
isPush(0x60)         // true (PUSH1)
getPushSize(0x60)    // 1
isTerminator(0x00)   // true (STOP)
```

See [Analysis](/primitives/bytecode/analysis) for details.

### Formatting

```typescript
import {
  formatInstructions,
  formatInstruction
} from '@tevm/voltaire/BrandedBytecode'

// Disassemble entire bytecode
const disassembly = formatInstructions(code)
// ["0x0000: PUSH1 0x01", "0x0002: PUSH1 0x02", ...]

// Format single instruction
const inst = { opcode: 0x60, position: 0, pushData: new Uint8Array([0x01]) }
const formatted = formatInstruction(inst)
// "0x0000: PUSH1 0x01"
```

See [Formatting](/primitives/bytecode/formatting) for details.

### Metadata

```typescript
import {
  hasMetadata,
  stripMetadata
} from '@tevm/voltaire/BrandedBytecode'

// Check for Solidity metadata
if (hasMetadata(code)) {
  const stripped = stripMetadata(code)
  console.log("Metadata removed")
}
```

See [Metadata](/primitives/bytecode/metadata) for details.

### Utilities

```typescript
import {
  size,
  equals,
  hash,
  extractRuntime
} from '@tevm/voltaire/BrandedBytecode'

const byteSize = size(code)        // number
const isEqual = equals(code1, code2)  // boolean
const codeHash = hash(code)        // 32-byte keccak256 hash
const runtime = extractRuntime(code, offset)  // Extract runtime code
```

See [Utilities](/primitives/bytecode/utilities) for details.

**Tree-shaking note:** `hash` includes keccak256.

## Data-First Pattern

All BrandedBytecode functions follow data-first pattern:

```typescript
// BrandedBytecode: bytecode is first parameter
toHex(code)
equals(code1, code2)
analyze(code)

// Enables functional composition
const disassemble = (code: BrandedBytecode) =>
  formatInstructions(code).join('\n')
```

This enables functional composition and partial application:

```typescript
import {
  fromHex,
  validate,
  stripMetadata,
  analyze
} from '@tevm/voltaire/BrandedBytecode'

// Function composition
const safeAnalyze = (hex: string) => {
  const code = fromHex(hex)
  if (!validate(code)) throw new Error("Invalid bytecode")
  return analyze(code)
}

// Partial application
const compareStripped = (a: BrandedBytecode) => (b: BrandedBytecode) =>
  equals(stripMetadata(a), stripMetadata(b))

// Array methods
const codes = [code1, code2, code3]
codes.map(toHex)
codes.filter(validate)
codes.map(analyze)
```

## Tree-Shaking Benefits

Primary benefit: **Selective inclusion of crypto dependencies**

### Example 1: Minimal Bundle (No Crypto)

```typescript
import {
  fromHex,
  validate,
  parseInstructions,
  formatInstructions,
  toHex
} from '@tevm/voltaire/BrandedBytecode'

const code = fromHex("0x6001")
if (validate(code)) {
  const instructions = parseInstructions(code)
  const disassembly = formatInstructions(code)
}
```

**Bundle:** No keccak256. Only parsing, validation, and formatting.

### Example 2: With Hashing (Keccak256)

```typescript
import {
  fromHex,
  hash,
  equals
} from '@tevm/voltaire/BrandedBytecode'

const code = fromHex("0x6001")
const codeHash = hash(code)

// Compare by hash
const isEqual = equals(hash(code1), hash(code2))
```

**Bundle:** Includes keccak256 for hashing.

### Example 3: Complete Analysis (No Crypto)

```typescript
import {
  fromHex,
  analyze,
  stripMetadata,
  formatInstructions
} from '@tevm/voltaire/BrandedBytecode'

const code = fromHex(deployedBytecode)
const stripped = stripMetadata(code)
const analysis = analyze(stripped)
const disassembly = formatInstructions(stripped)
```

**Bundle:** No keccak256. Only analysis and formatting utilities.

## Constants

```typescript
import {
  STOP,
  JUMPDEST,
  PUSH1,
  PUSH32,
  RETURN,
  REVERT,
  INVALID
} from '@tevm/voltaire/BrandedBytecode'

STOP       // 0x00
JUMPDEST   // 0x5b
PUSH1      // 0x60
PUSH32     // 0x7f
RETURN     // 0xf3
REVERT     // 0xfd
INVALID    // 0xfe
```

## Dependency Table

| Method/Function | Keccak256 | Notes |
|-----------------|-----------|-------|
| `from`, `fromHex` | ✗ | Pure conversions |
| `toHex` | ✗ | Pure conversion |
| `validate` | ✗ | Structure validation only |
| `analyze`, `analyzeJumpDestinations`, `isValidJumpDest` | ✗ | Parsing and analysis |
| `parseInstructions` | ✗ | Instruction parsing |
| `formatInstructions`, `formatInstruction` | ✗ | String formatting |
| `isPush`, `getPushSize`, `isTerminator` | ✗ | Opcode utilities |
| `hasMetadata`, `stripMetadata` | ✗ | Metadata detection |
| `size`, `equals` | ✗ | Basic utilities |
| `hash` | ✓ | Keccak256 hashing |
| `extractRuntime` | ✗ | Slice operation |

## Common Patterns

### Pipeline processing

```typescript
import {
  fromHex,
  stripMetadata,
  validate,
  analyze,
  formatInstructions
} from '@tevm/voltaire/BrandedBytecode'

function processContract(hex: string) {
  const code = fromHex(hex)
  const stripped = stripMetadata(code)

  if (!validate(stripped)) {
    throw new Error("Invalid bytecode")
  }

  const analysis = analyze(stripped)
  const disassembly = formatInstructions(stripped)

  return { analysis, disassembly }
}
```

### Function composition

```typescript
import {
  fromHex,
  stripMetadata,
  toHex,
  equals
} from '@tevm/voltaire/BrandedBytecode'

// Create reusable pipeline
const normalizeCode = (hex: string) =>
  toHex(stripMetadata(fromHex(hex)))

// Use in comparisons
const code1Normalized = normalizeCode(deployed1)
const code2Normalized = normalizeCode(deployed2)
const identical = code1Normalized === code2Normalized
```

### Filtering and mapping

```typescript
import {
  validate,
  analyze,
  size,
  hasMetadata
} from '@tevm/voltaire/BrandedBytecode'

const codes: BrandedBytecode[] = [...]

// Filter valid bytecode
const validCodes = codes.filter(validate)

// Get sizes
const sizes = codes.map(size)

// Analyze all
const analyses = validCodes.map(analyze)

// Find codes with metadata
const withMetadata = codes.filter(hasMetadata)
```

## When to Use BrandedBytecode

### Use BrandedBytecode When:
- **Bundle size critical** (mobile, embedded)
- **Avoiding crypto** dependencies
- **Functional style** preferred
- **Selective imports** desired
- **Composing functions** heavily
- **Building tools** for bytecode analysis

### Use Direct Uint8Array When:
- **Zero dependencies** needed
- **Raw performance** critical
- **Simple operations** only
- **Type safety** not required

## Type Safety

BrandedBytecode provides runtime and compile-time safety:

```typescript
import { fromHex } from '@tevm/voltaire/BrandedBytecode'
import type { BrandedBytecode } from '@tevm/voltaire/BrandedBytecode'

// Compile-time type safety
function processCode(code: BrandedBytecode) {
  // code is guaranteed to be BrandedBytecode
}

// Cannot pass arbitrary Uint8Array
const bytes = new Uint8Array([0x60, 0x01])
// processCode(bytes)  // ✗ Type error

// Must construct via proper method
const code = fromHex("0x6001")
processCode(code)  // ✓ Works
```

## Related

- [Bytecode](/primitives/bytecode/) - Main Bytecode documentation
- [Constructors](/primitives/bytecode/constructors) - Creating bytecode
- [Conversions](/primitives/bytecode/conversions) - Format conversions
- [Validation](/primitives/bytecode/validation) - Structure validation
- [Analysis](/primitives/bytecode/analysis) - Jump destinations and instructions
- [Formatting](/primitives/bytecode/formatting) - Disassembly
- [Metadata](/primitives/bytecode/metadata) - Metadata operations
- [Utilities](/primitives/bytecode/utilities) - Size, equality, hashing
- [WASM](/primitives/bytecode/wasm) - WebAssembly implementation
