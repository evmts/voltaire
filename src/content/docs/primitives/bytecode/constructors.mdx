---
title: Bytecode Constructors
description: Creating Bytecode instances from various input types
---

# Constructors

Methods for creating Bytecode instances from different input formats.

## Universal Constructor

### `Bytecode.from(value)`

Universal constructor dispatches based on input type.

```typescript
const code1 = Bytecode.from("0x6001")
const code2 = Bytecode.from(new Uint8Array([0x60, 0x01]))
```

**Parameters:**
- `value: string | Uint8Array` - Hex string or byte array

**Returns:** `BrandedBytecode`

Defined in: [primitives/Bytecode/BrandedBytecode/from.js:15](https://github.com/evmts/voltaire/blob/main/src/primitives/Bytecode/BrandedBytecode/from.js)

## Static Constructors

### `Bytecode.fromHex(hex)`

Parse hex string to bytecode. Accepts with or without `0x` prefix.

```typescript
const code1 = Bytecode.fromHex("0x6001")
const code2 = Bytecode.fromHex("6001")  // Works without prefix

// Parse complex bytecode
const deployed = Bytecode.fromHex("0x608060405234801561001057600080fd5b50...")
```

**Parameters:**
- `hex: string` - Hex string (with or without `0x` prefix)

**Returns:** `BrandedBytecode`

**Throws:**
- `Error` - If hex string has odd length or invalid characters

Defined in: [primitives/Bytecode/BrandedBytecode/fromHex.js:8](https://github.com/evmts/voltaire/blob/main/src/primitives/Bytecode/BrandedBytecode/fromHex.js)

**Example - Parse deployed contract:**

```typescript
// Fetch deployed contract bytecode
const deployedHex = await provider.getCode(contractAddress)
const code = Bytecode.fromHex(deployedHex)

// Analyze structure
const analysis = Bytecode.analyze(code)
console.log(`Valid: ${analysis.valid}`)
console.log(`Instructions: ${analysis.instructions.length}`)
```

## Direct Construction

### From Uint8Array

Cast Uint8Array directly to Bytecode for zero-cost conversion.

```typescript
const bytes = new Uint8Array([0x60, 0x01, 0x60, 0x02, 0x01])
const code = bytes as BrandedBytecode

// Or via from()
const code2 = Bytecode.from(bytes)
```

**No validation performed** - Use `Bytecode.validate()` to check structure.

**Example - Construct programmatically:**

```typescript
// Build simple bytecode: PUSH1 0x80, PUSH1 0x40, MSTORE
const bytes = new Uint8Array([
  0x60, 0x80,  // PUSH1 0x80
  0x60, 0x40,  // PUSH1 0x40
  0x52,        // MSTORE
])
const code = Bytecode.from(bytes)

// Validate structure
if (!Bytecode.validate(code)) {
  throw new Error("Invalid bytecode")
}
```

## Tree-Shakeable Usage

All constructors available as tree-shakeable imports:

```typescript
import { from, fromHex } from '@tevm/voltaire/BrandedBytecode'

const code1 = from("0x6001")
const code2 = fromHex("0x6001")
const code3 = from(new Uint8Array([0x60, 0x01]))
```

**Bundle size:** Only imported functions included in bundle.

See [BrandedBytecode](/primitives/bytecode/branded-bytecode) for details on tree-shakeable API.

## Common Patterns

### Parse with validation

```typescript
function safeParse(hex: string): BrandedBytecode {
  const code = Bytecode.fromHex(hex)

  if (!Bytecode.validate(code)) {
    throw new Error("Invalid bytecode: incomplete PUSH instruction")
  }

  return code
}
```

### Parse user input

```typescript
function parseUserBytecode(input: string): BrandedBytecode {
  try {
    // Remove whitespace and normalize
    const cleaned = input.trim().toLowerCase()
    return Bytecode.fromHex(cleaned)
  } catch (err) {
    throw new Error(`Invalid hex string: ${err.message}`)
  }
}
```

### Construct from compilation output

```typescript
interface CompilerOutput {
  bytecode: string
  deployedBytecode: string
}

function extractBytecode(output: CompilerOutput) {
  return {
    creation: Bytecode.fromHex(output.bytecode),
    runtime: Bytecode.fromHex(output.deployedBytecode),
  }
}
```
