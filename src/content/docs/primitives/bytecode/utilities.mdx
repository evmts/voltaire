---
title: Bytecode Utilities
description: Size, equality, hashing, and extraction utilities
---

# Utilities

Utility methods for bytecode operations.

## Size

### `Bytecode.size(code)`

Get bytecode size in bytes.

```typescript
const code = Bytecode.fromHex("0x60016002015b00")
Bytecode.size(code)  // 6

// Equivalent to
code.length  // 6
```

**Parameters:**
- `code: BrandedBytecode` - Bytecode

**Returns:** `number` - Size in bytes

Defined in: [primitives/Bytecode/BrandedBytecode/size.js:13](https://github.com/evmts/voltaire/blob/main/src/primitives/Bytecode/BrandedBytecode/size.js)

## Equality

### `Bytecode.equals(a, b)`

Compare two bytecode arrays for exact byte-by-byte equality.

```typescript
const code1 = Bytecode.fromHex("0x6001")
const code2 = Bytecode.fromHex("0x6001")
const code3 = Bytecode.fromHex("0x6002")

Bytecode.equals(code1, code2)  // true
Bytecode.equals(code1, code3)  // false

// Different lengths
Bytecode.equals(code1, Bytecode.fromHex("0x600100"))  // false
```

**Parameters:**
- `a: BrandedBytecode` - First bytecode
- `b: BrandedBytecode` - Second bytecode

**Returns:** `boolean` - `true` if identical

Defined in: [primitives/Bytecode/BrandedBytecode/equals.js:15](https://github.com/evmts/voltaire/blob/main/src/primitives/Bytecode/BrandedBytecode/equals.js)

**Algorithm:** O(n) comparison with early exit on length mismatch.

## Hashing

### `Bytecode.hash(code)`

Compute keccak256 hash of bytecode.

```typescript
const code = Bytecode.fromHex("0x60016002015b00")
const codeHash = Bytecode.hash(code)

// Returns 32-byte hash
console.log(Bytecode.toHex(codeHash))
// "0x..." (32 bytes)
```

**Parameters:**
- `code: BrandedBytecode` - Bytecode to hash

**Returns:** `BrandedHash` - 32-byte keccak256 hash

Defined in: [primitives/Bytecode/BrandedBytecode/hash.js:15](https://github.com/evmts/voltaire/blob/main/src/primitives/Bytecode/BrandedBytecode/hash.js)

**Use cases:**
- Computing CODEHASH for contracts
- Verifying bytecode integrity
- Creating unique identifiers

## Extraction

### `Bytecode.extractRuntime(code, offset)`

Extract runtime bytecode from creation bytecode.

```typescript
// Creation bytecode = constructor + runtime
const creation = Bytecode.fromHex("0x608060405234801561001057600080fd5b50...")

// Extract runtime starting at offset
const runtimeOffset = 42  // Where runtime code starts
const runtime = Bytecode.extractRuntime(creation, runtimeOffset)

console.log(`Creation: ${Bytecode.size(creation)} bytes`)
console.log(`Runtime: ${Bytecode.size(runtime)} bytes`)
```

**Parameters:**
- `code: BrandedBytecode` - Creation bytecode
- `offset: number` - Start position of runtime code

**Returns:** `BrandedBytecode` - Runtime bytecode from offset to end

Defined in: [primitives/Bytecode/BrandedBytecode/extractRuntime.js:17](https://github.com/evmts/voltaire/blob/main/src/primitives/Bytecode/BrandedBytecode/extractRuntime.js)

**Note:** Determining correct offset requires analyzing constructor execution. This is simplified extraction assuming known offset.

## Common Patterns

### Check bytecode size limits

```typescript
function checkSizeLimit(code: BrandedBytecode): boolean {
  const size = Bytecode.size(code)

  // EIP-170: 24KB limit for deployed code
  const MAX_CODE_SIZE = 24576

  if (size > MAX_CODE_SIZE) {
    console.error(`Bytecode too large: ${size} > ${MAX_CODE_SIZE}`)
    return false
  }

  return true
}
```

### Find duplicate bytecode

```typescript
function findDuplicates(bytecodes: BrandedBytecode[]): number[][] {
  const groups: number[][] = []

  for (let i = 0; i < bytecodes.length; i++) {
    let found = false

    for (const group of groups) {
      if (Bytecode.equals(bytecodes[i], bytecodes[group[0]])) {
        group.push(i)
        found = true
        break
      }
    }

    if (!found) {
      groups.push([i])
    }
  }

  return groups.filter(g => g.length > 1)
}

// Usage
const codes = [
  Bytecode.fromHex("0x6001"),
  Bytecode.fromHex("0x6002"),
  Bytecode.fromHex("0x6001"),  // Duplicate of index 0
]
const dupes = findDuplicates(codes)  // [[0, 2]]
```

### Cache bytecode hashes

```typescript
const hashCache = new WeakMap<BrandedBytecode, BrandedHash>()

function getCachedHash(code: BrandedBytecode): BrandedHash {
  if (!hashCache.has(code)) {
    hashCache.set(code, Bytecode.hash(code))
  }
  return hashCache.get(code)!
}

// Usage - avoid repeated hashing
function compareByHash(codes: BrandedBytecode[]): boolean {
  if (codes.length < 2) return true

  const firstHash = getCachedHash(codes[0])

  for (let i = 1; i < codes.length; i++) {
    const hash = getCachedHash(codes[i])
    if (!Bytecode.equals(firstHash, hash)) {
      return false
    }
  }

  return true
}
```

### Build bytecode index

```typescript
interface BytecodeIndex {
  hash: string
  size: number
  valid: boolean
  hasMetadata: boolean
  addresses: string[]
}

function indexBytecode(
  address: string,
  code: BrandedBytecode
): BytecodeIndex {
  const hash = Bytecode.hash(code)

  return {
    hash: Bytecode.toHex(hash),
    size: Bytecode.size(code),
    valid: Bytecode.validate(code),
    hasMetadata: Bytecode.hasMetadata(code),
    addresses: [address],
  }
}
```

### Compare ignoring metadata

```typescript
function compareIgnoringMetadata(
  a: BrandedBytecode,
  b: BrandedBytecode
): boolean {
  const aStripped = Bytecode.stripMetadata(a)
  const bStripped = Bytecode.stripMetadata(b)

  return Bytecode.equals(aStripped, bStripped)
}

// Or compare hashes for large bytecode
function compareHashIgnoringMetadata(
  a: BrandedBytecode,
  b: BrandedBytecode
): boolean {
  const aStripped = Bytecode.stripMetadata(a)
  const bStripped = Bytecode.stripMetadata(b)

  const hashA = Bytecode.hash(aStripped)
  const hashB = Bytecode.hash(bStripped)

  return Bytecode.equals(hashA, hashB)
}
```

### Analyze contract deployment

```typescript
interface DeploymentInfo {
  creationSize: number
  runtimeSize: number
  runtimeOffset: number
  efficient: boolean
}

function analyzeDeployment(
  creation: BrandedBytecode,
  runtime: BrandedBytecode
): DeploymentInfo {
  const creationSize = Bytecode.size(creation)
  const runtimeSize = Bytecode.size(runtime)

  // Calculate efficiency (how much of creation is runtime)
  const efficiency = runtimeSize / creationSize

  return {
    creationSize,
    runtimeSize,
    runtimeOffset: creationSize - runtimeSize,
    efficient: efficiency > 0.5,  // More than 50% is runtime
  }
}
```

### Bytecode diff summary

```typescript
function bytecodeStats(code: BrandedBytecode) {
  const analysis = Bytecode.analyze(code)

  return {
    size: Bytecode.size(code),
    hash: Bytecode.toHex(Bytecode.hash(code)),
    valid: analysis.valid,
    instructions: analysis.instructions.length,
    jumpDests: analysis.jumpDestinations.size,
    hasMetadata: Bytecode.hasMetadata(code),
  }
}

function compareBytecodeStats(a: BrandedBytecode, b: BrandedBytecode) {
  const statsA = bytecodeStats(a)
  const statsB = bytecodeStats(b)

  return {
    identical: Bytecode.equals(a, b),
    sizeChange: statsB.size - statsA.size,
    instructionChange: statsB.instructions - statsA.instructions,
    jumpDestChange: statsB.jumpDests - statsA.jumpDests,
    hashA: statsA.hash,
    hashB: statsB.hash,
  }
}
```

## Tree-Shakeable Usage

```typescript
import {
  size,
  equals,
  hash,
  extractRuntime
} from '@tevm/voltaire/BrandedBytecode'

const code1 = fromHex("0x6001")
const code2 = fromHex("0x6002")

console.log(size(code1))        // 2
console.log(equals(code1, code2))  // false

const codeHash = hash(code1)
const runtime = extractRuntime(code1, 10)
```

See [BrandedBytecode](/primitives/bytecode/branded-bytecode) for details on tree-shakeable API.

## Performance

Operation complexities:

| Operation | Complexity | Notes |
|-----------|-----------|-------|
| `size` | O(1) | Property access |
| `equals` | O(n) | Early exit on length mismatch |
| `hash` | O(n) | Keccak-256 computation |
| `extractRuntime` | O(1) | Slice creates view (not copy) |

### Optimization tips

**1. Cache expensive operations:**

```typescript
// Cache hashes for repeated comparisons
const hashCache = new WeakMap()

// Cache analyses
const analysisCache = new WeakMap()
```

**2. Compare sizes before bytes:**

```typescript
// Fast rejection for different sizes
if (a.length !== b.length) return false
// Then compare bytes
return Bytecode.equals(a, b)
```

**3. Use hashes for large bytecode:**

```typescript
// For large bytecode, hash comparison is faster
if (Bytecode.size(code) > 10000) {
  return Bytecode.equals(
    Bytecode.hash(a),
    Bytecode.hash(b)
  )
}
```
