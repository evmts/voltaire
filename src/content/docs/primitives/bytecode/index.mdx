---
title: Bytecode
description: EVM bytecode analysis and manipulation
---

import { Tabs, TabItem, Card, CardGrid, Aside } from '@astrojs/starlight/components';

# Bytecode

EVM bytecode type with analysis, validation, and disassembly capabilities

## Overview

[Branded](/primitives/branded-types) `Uint8Array` representing EVM bytecode. Provides methods for analyzing jump destinations, parsing instructions, validating structure, and formatting as disassembly.

## Bytecode Structure

EVM bytecode consists of opcodes interspersed with PUSH data:

```
Offset  Byte    Meaning
──────────────────────────────────────────────
0x0000  0x60    PUSH1 opcode
0x0001  0x01    ← Data pushed by PUSH1
0x0002  0x60    PUSH1 opcode
0x0003  0x02    ← Data pushed by PUSH1
0x0004  0x01    ADD opcode
0x0005  0x5b    JUMPDEST marker
0x0006  0x00    STOP opcode
```

**Key concepts:**
- **Opcode**: Single byte (0x00-0xFF) representing an operation
- **PUSH data**: 1-32 bytes following PUSH1-PUSH32 opcodes (not executable)
- **JUMPDEST (0x5b)**: Markers for valid jump targets
- **Metadata**: Solidity compiler appends ~50-100 bytes at EOF

**Analysis challenge**: Must skip PUSH data to avoid treating data as opcodes:
```typescript
// Wrong approach (treats PUSH data as opcodes)
const instructions = bytecode.map(byte => byte)  // Includes PUSH1 data!

// Correct approach (skips PUSH data)
const analysis = Bytecode.analyze(code)  // Returns valid instructions
const jumpdests = Bytecode.analyzeJumpDestinations(code)  // Finds JUMPDEST markers
```

## Quick Start

<Tabs>
<TabItem label="Namespace API">
```typescript
import { Bytecode } from '@tevm/voltaire'

// Parse from hex (see Constructors)
const code = Bytecode.fromHex("0x60016002015b00")

// Analyze bytecode (see Analysis)
const analysis = Bytecode.analyze(code)
console.log(analysis.valid)                    // true
console.log(analysis.jumpDestinations.size)    // 1
console.log(analysis.instructions.length)      // 4

// Check jump destinations (see Analysis)
const jumpdests = Bytecode.analyzeJumpDestinations(code)
jumpdests.has(4)  // true - JUMPDEST at position 4

// Validate structure (see Validation)
Bytecode.validate(code)  // true

// Disassemble (see Formatting)
const disassembly = Bytecode.formatInstructions(code)
// ["0x0000: PUSH1 0x01", "0x0002: PUSH1 0x02", ...]

// Metadata operations (see Metadata)
if (Bytecode.hasMetadata(code)) {
  const stripped = Bytecode.stripMetadata(code)
}

// Utilities (see Utilities)
Bytecode.size(code)        // Get bytecode size
Bytecode.equals(code1, code2)  // Compare bytecode
```
</TabItem>
<TabItem label="Tree-shakeable">
```typescript
import {
  fromHex,
  analyze,
  analyzeJumpDestinations,
  validate,
  formatInstructions
} from '@tevm/voltaire/BrandedBytecode'

const code = fromHex("0x60016002015b00")
const analysis = analyze(code)
const jumpdests = analyzeJumpDestinations(code)
const valid = validate(code)
const disassembly = formatInstructions(code)
```
</TabItem>
</Tabs>

## Types

<Tabs>
<TabItem label="type BrandedBytecode">
```typescript
export type BrandedBytecode = Uint8Array & {
  readonly __tag: "Bytecode"
}
```

[Branded type](/primitives/branded-types) wrapping `Uint8Array`. Used for all bytecode operations.

Source: [BrandedBytecode/BrandedBytecode.ts:8](https://github.com/evmts/voltaire/blob/main/src/primitives/Bytecode/BrandedBytecode/BrandedBytecode.ts#L8)
</TabItem>
<TabItem label="Opcode">
```typescript
export type Opcode = number
```

Single byte EVM instruction (0x00-0xFF).

Source: [BrandedBytecode/BrandedBytecode.ts:13](https://github.com/evmts/voltaire/blob/main/src/primitives/Bytecode/BrandedBytecode/BrandedBytecode.ts#L13)
</TabItem>
<TabItem label="Instruction">
```typescript
export type Instruction = {
  readonly opcode: Opcode
  readonly position: number
  readonly pushData?: Uint8Array
}
```

Parsed bytecode instruction with position and optional PUSH data.

Source: [BrandedBytecode/BrandedBytecode.ts:28-35](https://github.com/evmts/voltaire/blob/main/src/primitives/Bytecode/BrandedBytecode/BrandedBytecode.ts#L28-L35)
</TabItem>
<TabItem label="Analysis">
```typescript
export type Analysis = {
  readonly jumpDestinations: ReadonlySet<number>
  readonly instructions: readonly Instruction[]
  readonly valid: boolean
}
```

Complete bytecode analysis result with jump destinations, instructions, and validity.

Source: [BrandedBytecode/BrandedBytecode.ts:40-47](https://github.com/evmts/voltaire/blob/main/src/primitives/Bytecode/BrandedBytecode/BrandedBytecode.ts#L40-L47)
</TabItem>
</Tabs>

## Constants

Bytecode module exports common EVM opcode constants:

```typescript
import { Bytecode } from '@tevm/voltaire'

// Opcode constants
Bytecode.STOP       // 0x00
Bytecode.JUMPDEST   // 0x5b
Bytecode.PUSH1      // 0x60
Bytecode.PUSH32     // 0x7f
Bytecode.RETURN     // 0xf3
Bytecode.REVERT     // 0xfd
Bytecode.INVALID    // 0xfe

// Usage
if (opcode === Bytecode.JUMPDEST) {
  console.log("Found jump destination")
}
```

**Available constants:**
- `STOP = 0x00` - Halts execution
- `JUMPDEST = 0x5b` - Jump destination marker
- `PUSH1 = 0x60` - PUSH1 opcode
- `PUSH32 = 0x7f` - PUSH32 opcode
- `RETURN = 0xf3` - Returns from execution
- `REVERT = 0xfd` - Reverts state changes
- `INVALID = 0xfe` - Invalid opcode

Source: [constants.js](https://github.com/evmts/voltaire/blob/main/src/primitives/Bytecode/BrandedBytecode/constants.js)

## API Documentation

<CardGrid>
  <Card title="Constructors" icon="rocket">
    Creating Bytecode instances from hex strings or Uint8Array.

    [View constructors →](/primitives/bytecode/constructors)
  </Card>

  <Card title="Conversions" icon="random">
    Converting between bytecode and hex strings.

    [View conversions →](/primitives/bytecode/conversions)
  </Card>

  <Card title="Validation" icon="warning">
    Validating bytecode structure for incomplete PUSH instructions.

    [View validation →](/primitives/bytecode/validation)
  </Card>

  <Card title="Analysis" icon="magnifier">
    Analyzing jump destinations, parsing instructions, complete analysis.

    [View analysis →](/primitives/bytecode/analysis)
  </Card>

  <Card title="Formatting" icon="document">
    Disassembling bytecode into human-readable instructions.

    [View formatting →](/primitives/bytecode/formatting)
  </Card>

  <Card title="Metadata" icon="puzzle">
    Detecting and stripping Solidity compiler metadata.

    [View metadata →](/primitives/bytecode/metadata)
  </Card>

  <Card title="Utilities" icon="setting">
    Size, equality, hashing, extraction operations.

    [View utilities →](/primitives/bytecode/utilities)
  </Card>

  <Card title="BrandedBytecode" icon="seti:config">
    Tree-shakeable functional API for minimal bundle size.

    [View BrandedBytecode →](/primitives/bytecode/branded-bytecode)
  </Card>

  <Card title="WASM Implementation" icon="rocket">
    WebAssembly-accelerated methods compiled from Zig for performance.

    [View WASM →](/primitives/bytecode/wasm)
  </Card>
</CardGrid>

## Opcode Quick Reference

Essential opcodes for bytecode analysis:

<Tabs>
<TabItem label="Control Flow">
| Opcode | Hex | Stack | Description |
|--------|-----|-------|-------------|
| STOP | 0x00 | - | Halt execution |
| JUMP | 0x56 | (dst) → | Jump to position (must be JUMPDEST) |
| JUMPI | 0x57 | (dst, cond) → | Conditional jump |
| JUMPDEST | 0x5b | - | Valid jump target marker |
| REVERT | 0xfd | (off, len) → | Revert state, return data |
| RETURN | 0xf3 | (off, len) → | Return data, halt |
</TabItem>

<TabItem label="Stack Operations">
| Opcode | Hex | Stack | Description |
|--------|-----|-------|-------------|
| PUSH1-PUSH32 | 0x60-0x7f | - → (value) | Push 1-32 bytes |
| POP | 0x50 | (a) → | Discard top item |
| DUP1-DUP16 | 0x80-0x8f | (n) → (n, n) | Duplicate item |
| SWAP1-SWAP16 | 0x90-0x9f | (a, b) → (b, a) | Swap items |
</TabItem>

<TabItem label="Arithmetic">
| Opcode | Hex | Stack | Description |
|--------|-----|-------|-------------|
| ADD | 0x01 | (a, b) → (a+b) | Addition |
| MUL | 0x02 | (a, b) → (a*b) | Multiplication |
| SUB | 0x03 | (a, b) → (a-b) | Subtraction |
| DIV | 0x04 | (a, b) → (a/b) | Division |
| ADDMOD | 0x08 | (a, b, N) → ((a+b) mod N) | Modular add |
| MULMOD | 0x09 | (a, b, N) → ((a*b) mod N) | Modular mul |
</TabItem>

<TabItem label="Storage & Memory">
| Opcode | Hex | Stack | Description |
|--------|-----|-------|-------------|
| SLOAD | 0x54 | (key) → (value) | Load storage |
| SSTORE | 0x55 | (key, value) → | Store to storage |
| MLOAD | 0x51 | (offset) → (value) | Load from memory |
| MSTORE | 0x52 | (offset, value) → | Store to memory |
| MSTORE8 | 0x53 | (offset, value) → | Store 1 byte |
</TabItem>

<TabItem label="Call & Create">
| Opcode | Hex | Stack | Description |
|--------|-----|-------|-------------|
| CALL | 0xf1 | (gas, addr, val, in, inLen, out, outLen) → | Call contract |
| DELEGATECALL | 0xf4 | (gas, addr, in, inLen, out, outLen) → | Call with sender context |
| STATICCALL | 0xfa | (gas, addr, in, inLen, out, outLen) → | Read-only call |
| CREATE | 0xf0 | (val, in, len) → (addr) | Deploy contract |
| CREATE2 | 0xf5 | (val, in, len, salt) → (addr) | Deterministic deploy |
</TabItem>
</Tabs>

<Aside type="tip" title="Finding PUSH instructions">
Bytes 0x60-0x7f represent PUSH1-PUSH32. Following bytes are data, not opcodes:
- 0x60 = PUSH1 (1 data byte follows)
- 0x7f = PUSH32 (32 data bytes follow)

Use `analyze()` to handle this automatically.
</Aside>

<Aside type="tip" title="Why analyze jump destinations?">
EVM requires JUMP/JUMPI to target valid JUMPDEST opcodes. Analysis must skip PUSH data to avoid treating data bytes as opcodes. Use `analyzeJumpDestinations` to find all valid jump targets.
</Aside>

## Related Types

<CardGrid stagger>
  <Card title="Hex" icon="seti:text">
    Hex string utilities for bytecode encoding (used in [conversions](/primitives/bytecode/conversions)).

    [View Hex →](/primitives/hex)
  </Card>

  <Card title="Hash" icon="document">
    Keccak-256 hashing for bytecode (used in metadata and contract creation).

    [View Hash →](/primitives/hash)
  </Card>

  <Card title="Branded Types" icon="open-book">
    Zero-overhead type branding pattern used throughout primitives.

    [View Branded Types →](/primitives/branded-types)
  </Card>
</CardGrid>
