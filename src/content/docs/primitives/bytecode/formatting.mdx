---
title: Bytecode Formatting
description: Disassembling and formatting bytecode as human-readable instructions
---

# Formatting

Methods for formatting bytecode as human-readable disassembly.

## Disassembly

### `Bytecode.formatInstructions(code)`

Format all instructions as disassembly listing.

```typescript
const code = Bytecode.fromHex("0x600160020155b00")

const disassembly = Bytecode.formatInstructions(code)
// [
//   "0x0000: PUSH1 0x01",
//   "0x0002: PUSH1 0x02",
//   "0x0004: ADD",
//   "0x0005: JUMPDEST",
//   "0x0006: STOP"
// ]

disassembly.forEach(line => console.log(line))
```

**Parameters:**
- `code: BrandedBytecode` - Bytecode to disassemble

**Returns:** `string[]` - Array of formatted instruction strings

Defined in: [primitives/Bytecode/BrandedBytecode/formatInstructions.js:17](https://github.com/evmts/voltaire/blob/main/src/primitives/Bytecode/BrandedBytecode/formatInstructions.js)

### `Bytecode.formatInstruction(instruction)`

Format single instruction as string.

```typescript
const instruction = {
  opcode: 0x60,
  position: 0,
  pushData: new Uint8Array([0x80])
}

const formatted = Bytecode.formatInstruction(instruction)
// "0x0000: PUSH1 0x80"
```

**Parameters:**
- `instruction: Instruction` - Instruction to format

**Returns:** `string` - Formatted instruction string

**Format:** `"0xPOSITION: MNEMONIC [DATA]"`

Defined in: [primitives/Bytecode/BrandedBytecode/formatInstruction.js:8](https://github.com/evmts/voltaire/blob/main/src/primitives/Bytecode/BrandedBytecode/formatInstruction.js)

## Common Formatting Patterns

### Disassemble with line numbers

```typescript
function disassembleWithLines(code: BrandedBytecode): string {
  const lines = Bytecode.formatInstructions(code)

  return lines
    .map((line, i) => `${(i + 1).toString().padStart(4, ' ')}: ${line}`)
    .join('\n')
}

// Usage
const code = Bytecode.fromHex("0x60016002015b00")
console.log(disassembleWithLines(code))
//    1: 0x0000: PUSH1 0x01
//    2: 0x0002: PUSH1 0x02
//    3: 0x0004: ADD
//    4: 0x0005: JUMPDEST
//    5: 0x0006: STOP
```

### Highlight jump destinations

```typescript
function highlightJumpDests(code: BrandedBytecode): string {
  const disassembly = Bytecode.formatInstructions(code)
  const jumpdests = Bytecode.analyzeJumpDestinations(code)
  const instructions = Bytecode.parseInstructions(code)

  return disassembly
    .map((line, i) => {
      const inst = instructions[i]
      const marker = jumpdests.has(inst.position) ? '→' : ' '
      return `${marker} ${line}`
    })
    .join('\n')
}

// Usage
const code = Bytecode.fromHex("0x60056005b00")
console.log(highlightJumpDests(code))
//   0x0000: PUSH1 0x05
//   0x0002: JUMP
//   0x0003: STOP
// → 0x0004: JUMPDEST
//   0x0005: STOP
```

### Annotate with opcode info

```typescript
function annotateInstructions(code: BrandedBytecode): string {
  const instructions = Bytecode.parseInstructions(code)

  return instructions.map(inst => {
    let line = `0x${inst.position.toString(16).padStart(4, '0')}: `
    line += `0x${inst.opcode.toString(16).padStart(2, '0')}`

    // Add annotations
    if (Bytecode.isPush(inst.opcode)) {
      const size = Bytecode.getPushSize(inst.opcode)
      line += ` (PUSH${size})`
      if (inst.pushData) {
        line += ` data=${Bytecode.toHex(inst.pushData)}`
      }
    } else if (inst.opcode === 0x5b) {
      line += ' (JUMPDEST)'
    } else if (Bytecode.isTerminator(inst.opcode)) {
      line += ' (TERMINATOR)'
    }

    return line
  }).join('\n')
}
```

### Export disassembly

```typescript
function exportDisassembly(code: BrandedBytecode, filename: string): void {
  const disassembly = Bytecode.formatInstructions(code)
  const analysis = Bytecode.analyze(code)

  const output = [
    `# Bytecode Disassembly`,
    ``,
    `Size: ${Bytecode.size(code)} bytes`,
    `Valid: ${analysis.valid}`,
    `Instructions: ${analysis.instructions.length}`,
    `Jump Destinations: ${analysis.jumpDestinations.size}`,
    ``,
    `## Disassembly`,
    ``,
    ...disassembly,
  ].join('\n')

  // In Node.js
  // fs.writeFileSync(filename, output)

  console.log(output)
}

// Usage
const code = Bytecode.fromHex("0x608060405234801561001057600080fd5b50")
exportDisassembly(code, 'contract.asm')
```

### Compare two bytecode versions

```typescript
function compareBytecode(
  code1: BrandedBytecode,
  code2: BrandedBytecode
): void {
  const dis1 = Bytecode.formatInstructions(code1)
  const dis2 = Bytecode.formatInstructions(code2)

  const maxLen = Math.max(dis1.length, dis2.length)

  console.log('Version 1 | Version 2')
  console.log(''.padEnd(80, '-'))

  for (let i = 0; i < maxLen; i++) {
    const left = (dis1[i] || '').padEnd(38, ' ')
    const right = dis2[i] || ''
    const marker = dis1[i] === dis2[i] ? ' ' : '≠'

    console.log(`${left} ${marker} ${right}`)
  }
}
```

### Find instruction by position

```typescript
function findInstructionAt(
  code: BrandedBytecode,
  position: number
): string | null {
  const instructions = Bytecode.parseInstructions(code)

  const inst = instructions.find(i => i.position === position)
  if (!inst) return null

  return Bytecode.formatInstruction(inst)
}

// Usage
const code = Bytecode.fromHex("0x60016002015b00")
console.log(findInstructionAt(code, 4))  // "0x0004: ADD"
```

### Interactive disassembler

```typescript
function interactiveDisassemble(code: BrandedBytecode) {
  const analysis = Bytecode.analyze(code)
  const disassembly = Bytecode.formatInstructions(code)

  return {
    // Full disassembly
    full: disassembly,

    // Get specific line
    getLine: (index: number) => disassembly[index],

    // Search for opcode
    findOpcode: (opcode: number) => {
      return analysis.instructions
        .filter(i => i.opcode === opcode)
        .map(i => Bytecode.formatInstruction(i))
    },

    // Get range
    getRange: (start: number, end: number) => {
      return analysis.instructions
        .filter(i => i.position >= start && i.position < end)
        .map(i => Bytecode.formatInstruction(i))
    },

    // Jump destinations only
    jumpDests: () => {
      return analysis.instructions
        .filter(i => analysis.jumpDestinations.has(i.position))
        .map(i => Bytecode.formatInstruction(i))
    },
  }
}

// Usage
const code = Bytecode.fromHex("0x60016002015b605b5b00")
const dis = interactiveDisassemble(code)

console.log(dis.findOpcode(0x60))  // All PUSH1 instructions
console.log(dis.jumpDests())       // All JUMPDEST instructions
console.log(dis.getRange(0, 5))    // Instructions from 0-5
```

## Output Format

Standard disassembly format:

```
0xPOSITION: MNEMONIC [DATA]
```

Examples:
- `0x0000: STOP`
- `0x0001: PUSH1 0xff`
- `0x0003: PUSH2 0x1234`
- `0x0006: JUMPDEST`
- `0x0007: ADD`

For unknown opcodes (not in opcode table), uses hex:
- `0x0000: 0xef` (for undefined opcode)

## Tree-Shakeable Usage

```typescript
import {
  formatInstructions,
  formatInstruction,
  parseInstructions
} from '@tevm/voltaire/BrandedBytecode'

const code = fromHex("0x60016002015b00")
const disassembly = formatInstructions(code)

// Or format manually
const instructions = parseInstructions(code)
const formatted = instructions.map(formatInstruction)
```

See [BrandedBytecode](/primitives/bytecode/branded-bytecode) for details on tree-shakeable API.

## Performance

Formatting operations:

| Operation | Complexity | Notes |
|-----------|-----------|-------|
| `formatInstructions` | O(n) | Parses then formats each instruction |
| `formatInstruction` | O(1) | String formatting only |

For large bytecode, consider streaming output:

```typescript
function* streamDisassembly(code: BrandedBytecode): Generator<string> {
  const instructions = Bytecode.parseInstructions(code)

  for (const inst of instructions) {
    yield Bytecode.formatInstruction(inst)
  }
}

// Usage
for (const line of streamDisassembly(largeBytecode)) {
  console.log(line)
}
```
