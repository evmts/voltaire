---
title: WASM Implementation
description: WebAssembly-accelerated Uint256 methods compiled from Zig
---

import { Tabs, TabItem, Aside } from '@astrojs/starlight/components';

# WASM Implementation

WebAssembly-accelerated implementations of Uint256 methods, compiled from Zig using ReleaseSmall mode.

## Overview

WASM implementations provide performance-critical operations using compiled Zig code targeting WebAssembly. These are **opt-in** replacements for the JavaScript implementations with lower-level byte manipulation.

Currently, Uint256 WASM support focuses on byte-level conversions with the WASM loader infrastructure in place for future expansion.

## Available WASM Methods

### Conversion Methods

#### `u256FromHex(hex)`

Convert hex string to 32-byte U256 representation (big-endian).

```typescript
import { u256FromHex } from '@tevm/voltaire/Uint256.wasm'

// Convert hex to bytes
const bytes = u256FromHex("0xff")
// Uint8Array(32) [0, 0, ..., 0, 255]

const bytes2 = u256FromHex("0x123456")
// Uint8Array(32) [0, 0, ..., 0x12, 0x34, 0x56]

// Works with or without 0x prefix
const bytes3 = u256FromHex("ff")
```

**Parameters:**
- `hex: string` - Hex string (with or without `0x` prefix)

**Returns:** `Uint8Array` - 32-byte array (big-endian)

**Throws:**
- If hex contains invalid characters

Source: [Uint256.wasm.ts:13](https://github.com/evmts/voltaire/blob/main/src/primitives/Uint/Uint256.wasm.ts#L13)

#### `u256ToHex(value)`

Convert 32-byte U256 value to hex string.

```typescript
import { u256ToHex } from '@tevm/voltaire/Uint256.wasm'

const bytes = new Uint8Array(32)
bytes[31] = 0xff

const hex = u256ToHex(bytes)  // "0x00000...00ff"

// Throws if wrong size
const wrong = new Uint8Array(20)
u256ToHex(wrong)  // Error: must be 32 bytes
```

**Parameters:**
- `value: Uint8Array` - 32-byte U256 value (big-endian)

**Returns:** `string` - Hex string with `0x` prefix (padded to 64 characters)

**Throws:**
- If value is not exactly 32 bytes

Source: [Uint256.wasm.ts:22](https://github.com/evmts/voltaire/blob/main/src/primitives/Uint/Uint256.wasm.ts#L22)

#### `u256FromBigInt(value)`

Convert bigint to 32-byte U256 representation.

```typescript
import { u256FromBigInt } from '@tevm/voltaire/Uint256.wasm'

const bytes = u256FromBigInt(255n)
// Uint8Array(32) [0, 0, ..., 0, 255]

const bytes2 = u256FromBigInt(2n ** 255n)
// Uint8Array(32) [0x80, 0, ..., 0]

// Validates range
u256FromBigInt(-1n)          // Error: cannot be negative
u256FromBigInt(2n ** 256n)   // Error: exceeds maximum
```

**Parameters:**
- `value: bigint` - BigInt value

**Returns:** `Uint8Array` - 32-byte array (big-endian)

**Throws:**
- If value is negative
- If value exceeds 2^256 - 1

Source: [Uint256.wasm.ts:34](https://github.com/evmts/voltaire/blob/main/src/primitives/Uint/Uint256.wasm.ts#L34)

#### `u256ToBigInt(value)`

Convert 32-byte U256 value to bigint.

```typescript
import { u256ToBigInt } from '@tevm/voltaire/Uint256.wasm'

const bytes = new Uint8Array(32)
bytes[31] = 0xff

const bigint = u256ToBigInt(bytes)  // 255n

// Throws if wrong size
const wrong = new Uint8Array(20)
u256ToBigInt(wrong)  // Error: must be 32 bytes
```

**Parameters:**
- `value: Uint8Array` - 32-byte U256 value (big-endian)

**Returns:** `bigint`

**Throws:**
- If value is not exactly 32 bytes

Source: [Uint256.wasm.ts:52](https://github.com/evmts/voltaire/blob/main/src/primitives/Uint/Uint256.wasm.ts#L52)

## Usage Patterns

### Using WASM Conversions

```typescript
import { u256FromHex, u256ToHex, u256FromBigInt, u256ToBigInt } from '@tevm/voltaire/Uint256.wasm'

// Hex round-trip
const hex = "0xff"
const bytes = u256FromHex(hex)
const hex2 = u256ToHex(bytes)  // "0x00000...00ff"

// BigInt round-trip
const bigint = 255n
const bytes2 = u256FromBigInt(bigint)
const bigint2 = u256ToBigInt(bytes2)  // 255n

// Convert between formats
const hexInput = "0x123456"
const bytes3 = u256FromHex(hexInput)
const bigint3 = u256ToBigInt(bytes3)
```

### Integration with Uint

```typescript
import { Uint } from '@tevm/voltaire'
import { u256FromHex, u256ToBigInt } from '@tevm/voltaire/Uint256.wasm'

// Parse hex using WASM, then create Uint
const hex = "0xff"
const bytes = u256FromHex(hex)
const bigint = u256ToBigInt(bytes)
const uint = Uint.from(bigint)

// Or use built-in fromHex
const uint2 = Uint.fromHex(hex)  // Equivalent, uses JS implementation
```

### Performance Testing

```typescript
import { u256FromHex, u256ToHex } from '@tevm/voltaire/Uint256.wasm'
import { Uint } from '@tevm/voltaire'

// Benchmark WASM vs JS
const iterations = 10000
const testHex = "0x123456789abcdef"

// WASM version
console.time("WASM")
for (let i = 0; i < iterations; i++) {
  const bytes = u256FromHex(testHex)
  const hex = u256ToHex(bytes)
}
console.timeEnd("WASM")

// JS version
console.time("JS")
for (let i = 0; i < iterations; i++) {
  const uint = Uint.fromHex(testHex)
  const hex = uint.toHex()
}
console.timeEnd("JS")
```

## Performance

WASM implementations provide performance benefits for:
- **Byte-level conversions** - Native memory operations vs JavaScript string manipulation
- **Bulk operations** - Processing many values in tight loops

<Aside type="tip" title="When to use WASM">
Use WASM when processing large batches of conversions (e.g., parsing many hex strings, converting many bigints). For single operations, JavaScript overhead may outweigh WASM benefits.
</Aside>

## Future WASM Operations

The current WASM implementation focuses on byte conversions. Future expansions may include:

- **Arithmetic operations** - Addition, multiplication, division with WASM-optimized algorithms
- **Bitwise operations** - Fast bit manipulation in compiled code
- **Comparison operations** - Memory-efficient comparisons
- **Utility functions** - bitLength, popCount, etc. in native code

Track progress in [Zig implementation](https://github.com/evmts/voltaire/blob/main/src/primitives/Uint/Uint.zig).

## Bundle Size

WASM module compiled with ReleaseSmall targeting minimal bundle size. Only included when importing from `Uint256.wasm.ts`.

```typescript
// Includes WASM module
import { u256FromHex } from '@tevm/voltaire/Uint256.wasm'

// No WASM module
import { fromHex } from '@tevm/voltaire/BrandedUint'
```

WASM loader infrastructure is shared across all primitives, so first WASM import includes loader (~2-4KB gzipped), subsequent WASM primitives add only their specific implementations.

<Aside type="note" title="Bundle Impact">
WASM module adds ~2-4KB gzipped for loader + primitive-specific code. Use when performance benefits outweigh bundle size cost.
</Aside>

## Files

- **[Uint256.wasm.ts](https://github.com/evmts/voltaire/blob/main/src/primitives/Uint/Uint256.wasm.ts)** - TypeScript exports with WASM bindings
- **[Uint.zig](https://github.com/evmts/voltaire/blob/main/src/primitives/Uint/Uint.zig)** - Zig source implementation
- **[loader.js](https://github.com/evmts/voltaire/blob/main/src/wasm-loader/loader.js)** - Shared WASM loader

## Tree-Shakeable Usage

All WASM methods are tree-shakeable:

```typescript
// Import only what you need
import { u256FromHex } from '@tevm/voltaire/Uint256.wasm'

// WASM loader included once
// Only u256FromHex WASM code included
```

## Browser Support

WASM requires WebAssembly support in the JavaScript runtime:
- **Modern browsers** - All major browsers support WebAssembly
- **Node.js** - Version 8.0+ has WebAssembly support
- **Edge runtimes** - Cloudflare Workers, Deno, etc. support WASM

No fallback to JavaScript - WASM import requires WASM support.

## Related

- [Conversions](/primitives/uint/conversions) - JavaScript conversion methods
- [BrandedUint](/primitives/uint/branded-uint) - Tree-shakeable functional API
- [Uint](/primitives/uint/) - Main Uint documentation
