---
title: Uint Arithmetic
description: Arithmetic operations with automatic wrapping
---

import { Aside, Tabs, TabItem } from '@astrojs/starlight/components';

# Arithmetic

Mathematical operations on Uint256 with automatic wrapping on overflow/underflow.

<Aside type="tip" title="Wrapping Behavior">
All arithmetic operations wrap on overflow (mod 2^256), matching Solidity and EVM behavior. There are no checked arithmetic operations - wrapping is always automatic.
</Aside>

## Uint256 Representation

Uint256 is a 256-bit unsigned integer stored as 32 bytes in big-endian format:

```
┌─────────────────────────────────────────────────────────┐
│ Uint256 Value Range: 0 to 2^256 - 1                   │
├─────────────────────────────────────────────────────────┤
│ Byte Layout (32 bytes, big-endian)                     │
│ [Byte 0] [Byte 1] ... [Byte 30] [Byte 31]            │
│  (MSB)                                    (LSB)        │
│                                                         │
│ Max Value: 0xffffffffffffffffffffffffffffffffffffffff   │
│            = 115792089237316195423570985008687907...    │
│            = 2^256 - 1                                  │
│                                                         │
│ Min Value: 0x0000000000000000000000000000000000000000   │
│            = 0                                          │
└─────────────────────────────────────────────────────────┘
```

**Key Facts:**
- 256 bits = 32 bytes = 64 hex digits (+ "0x" prefix)
- Big-endian: most significant byte first
- Range: [0, 2^256 - 1] = [0, 115792089237316195423570985008687907853269984665640564039457584007913129639935]
- EVM word size: 256 bits

## Addition

### `instance.plus(other)`

Add two Uint256 values with wrapping.

```typescript
const a = Uint.from(100n)
const b = Uint.from(50n)

// Basic addition
a.plus(b)  // 150n

// Overflow wraps to zero and continues
const max = Uint.MAX
max.plus(Uint.ONE)      // 0n (wraps around)
max.plus(Uint.from(2n)) // 1n

// Identity
a.plus(Uint.ZERO)  // a

// Commutative
a.plus(b).equals(b.plus(a))  // true
```

**Parameters:**
- `other: BrandedUint` - Value to add

**Returns:** `BrandedUint` - Sum mod 2^256

**Overflow:** Wraps around (result = (a + b) mod 2^256)

**Static form:**
```typescript
Uint.plus(a, b)  // a + b
```

Source: [plus.ts:19](https://github.com/evmts/voltaire/blob/main/src/primitives/Uint/BrandedUint/plus.ts#L19)

## Subtraction

### `instance.minus(other)`

Subtract Uint256 value with wrapping.

```typescript
const a = Uint.from(100n)
const b = Uint.from(50n)

// Basic subtraction
a.minus(b)  // 50n

// Underflow wraps to MAX and continues down
Uint.ZERO.minus(Uint.ONE)      // MAX
Uint.ZERO.minus(Uint.from(2n)) // MAX - 1

const small = Uint.from(10n)
const large = Uint.from(20n)
small.minus(large)  // MAX - 9 (wraps)

// Identity
a.minus(Uint.ZERO)  // a
a.minus(a)          // ZERO
```

**Parameters:**
- `other: BrandedUint` - Value to subtract

**Returns:** `BrandedUint` - Difference mod 2^256

**Underflow:** Wraps around (result = (a - b + 2^256) mod 2^256)

**Static form:**
```typescript
Uint.minus(a, b)  // a - b
```

Source: [minus.ts:19](https://github.com/evmts/voltaire/blob/main/src/primitives/Uint/BrandedUint/minus.ts#L19)

## Multiplication

### `instance.times(other)`

Multiply Uint256 values with wrapping.

```typescript
const a = Uint.from(10n)
const b = Uint.from(5n)

// Basic multiplication
a.times(b)  // 50n

// Overflow wraps
const large = Uint.from(2n ** 200n)
large.times(large)  // Result mod 2^256

// Identity
a.times(Uint.ONE)   // a
a.times(Uint.ZERO)  // ZERO

// Commutative
a.times(b).equals(b.times(a))  // true

// Distributive
a.times(b.plus(c)).equals(a.times(b).plus(a.times(c)))  // true
```

**Parameters:**
- `other: BrandedUint` - Value to multiply

**Returns:** `BrandedUint` - Product mod 2^256

**Overflow:** Wraps around (result = (a * b) mod 2^256)

**Static form:**
```typescript
Uint.times(a, b)  // a * b
```

Source: [times.ts:19](https://github.com/evmts/voltaire/blob/main/src/primitives/Uint/BrandedUint/times.ts#L19)

## Division

### `instance.dividedBy(other)`

Divide Uint256 values (floor division).

```typescript
const a = Uint.from(100n)
const b = Uint.from(10n)

// Basic division
a.dividedBy(b)  // 10n

// Floor division (rounds down)
const c = Uint.from(7n)
const d = Uint.from(2n)
c.dividedBy(d)  // 3n (not 3.5)

// Identity
a.dividedBy(Uint.ONE)  // a

// Division by zero throws
a.dividedBy(Uint.ZERO)  // Error: Division by zero

// MAX divided by 2
Uint.MAX.dividedBy(Uint.from(2n))  // 2^255 - 1 (half of MAX)
```

**Parameters:**
- `other: BrandedUint` - Divisor

**Returns:** `BrandedUint` - Quotient (floor division)

**Throws:**
- If divisor is zero

**Note:** Always rounds down (floor division). No decimal results.

**Static form:**
```typescript
Uint.dividedBy(a, b)  // a / b
```

Source: [dividedBy.ts:19](https://github.com/evmts/voltaire/blob/main/src/primitives/Uint/BrandedUint/dividedBy.ts#L19)

## Modulo

### `instance.modulo(other)`

Get remainder of division.

```typescript
const a = Uint.from(17n)
const b = Uint.from(5n)

// Basic modulo
a.modulo(b)  // 2n (17 = 3*5 + 2)

// Even/odd check
const even = Uint.from(100n)
const odd = Uint.from(101n)
even.modulo(Uint.from(2n))  // 0n
odd.modulo(Uint.from(2n))   // 1n

// Identity
a.modulo(a)  // ZERO
a.modulo(Uint.ONE)  // ZERO

// Modulo by zero throws
a.modulo(Uint.ZERO)  // Error: Division by zero

// Use with division
const quotient = a.dividedBy(b)   // 3
const remainder = a.modulo(b)     // 2
// Verify: a = quotient * b + remainder
quotient.times(b).plus(remainder).equals(a)  // true
```

**Parameters:**
- `other: BrandedUint` - Modulus

**Returns:** `BrandedUint` - Remainder

**Throws:**
- If modulus is zero

**Static form:**
```typescript
Uint.modulo(a, b)  // a % b
```

Source: [modulo.ts](https://github.com/evmts/voltaire/blob/main/src/primitives/Uint/BrandedUint/modulo.ts)

## Exponentiation

### `instance.toPower(exponent)`

Raise to power with wrapping.

```typescript
const base = Uint.from(2n)
const exp = Uint.from(8n)

// Basic exponentiation
base.toPower(exp)  // 256n (2^8)

// Large exponents
Uint.from(2n).toPower(Uint.from(255n))  // 2^255
Uint.from(2n).toPower(Uint.from(256n))  // 0n (wraps)

// Identity
a.toPower(Uint.ZERO)  // ONE
a.toPower(Uint.ONE)   // a
Uint.ONE.toPower(a)   // ONE
Uint.ZERO.toPower(a)  // ZERO (if a > 0)

// Overflow wraps
const large = Uint.from(10n)
large.toPower(Uint.from(77n))  // Wraps (10^77 > 2^256)

// Powers of 2
Uint.from(2n).toPower(Uint.from(0n))   // 1
Uint.from(2n).toPower(Uint.from(1n))   // 2
Uint.from(2n).toPower(Uint.from(2n))   // 4
Uint.from(2n).toPower(Uint.from(10n))  // 1024
```

**Parameters:**
- `exponent: BrandedUint` - Power to raise to

**Returns:** `BrandedUint` - Result mod 2^256

**Overflow:** Wraps around (result = (base ^ exponent) mod 2^256)

**Algorithm:** Exponentiation by squaring with wrapping at each step

**Static form:**
```typescript
Uint.toPower(base, exp)  // base ^ exp
```

Source: [toPower.ts:19](https://github.com/evmts/voltaire/blob/main/src/primitives/Uint/BrandedUint/toPower.ts#L19)

## Overflow/Underflow Behavior

### Overflow Visualization

Addition overflow occurs when result exceeds MAX (2^256 - 1):

```
Addition Overflow (wraps around)
┌──────────────────────────────────┐
│ a = 2^256 - 5                    │
│ b = 10                           │
│ a + b = (2^256 - 5) + 10         │
│       = 2^256 + 5                │
│       = 5 (wraps, mod 2^256)     │
└──────────────────────────────────┘

Value Line:
0 ─────────────────────────────────── MAX (2^256-1)
                                        ↓ +10
                                      (overflow)
                                        ↓
                                    wraps to 5
```

### Underflow Visualization

Subtraction underflow occurs when result goes below MIN (0):

```
Subtraction Underflow (wraps around)
┌──────────────────────────────────┐
│ a = 0                            │
│ b = 1                            │
│ a - b = 0 - 1 = -1               │
│       = MAX (wraps, mod 2^256)   │
└──────────────────────────────────┘

Value Line:
0 ─────────────────────────────────── MAX (2^256-1)
↓ -1 (underflow)
(wraps to MAX)
```

### Overflow Examples

```typescript
// Near MAX
const almostMax = Uint.MAX.minus(Uint.from(5n))
almostMax.plus(Uint.from(3n))   // MAX - 2
almostMax.plus(Uint.from(6n))   // 0n (wraps)
almostMax.plus(Uint.from(10n))  // 4n (wraps)

// Wrapping multiple times
const large = Uint.from(2n ** 255n)
large.plus(large)  // 0n (exactly 2^256)
```

### Subtraction Underflow

```typescript
// Below zero
Uint.from(5n).minus(Uint.from(10n))  // MAX - 4

// Chaining operations
Uint.ZERO
  .minus(Uint.ONE)    // MAX
  .minus(Uint.ONE)    // MAX - 1
  .minus(Uint.ONE)    // MAX - 2
```

### Multiplication Overflow

```typescript
// Large multiplication
const a = Uint.from(2n ** 128n)
const b = Uint.from(2n ** 129n)
a.times(b)  // 0n (2^257 wraps to 0)

// Repeated doubling
let value = Uint.ONE
for (let i = 0; i < 256; i++) {
  value = value.plus(value)  // Double each time
}
// After 256 doublings: wraps back to 0
```

## Usage Patterns

### Avoiding Overflow

```typescript
// Check before operation
function safeAdd(a: BrandedUint, b: BrandedUint): BrandedUint | null {
  // Would overflow if a + b > MAX
  if (a.greaterThan(Uint.MAX.minus(b))) {
    return null  // Would overflow
  }
  return a.plus(b)
}

// Check after operation
function detectOverflow(a: BrandedUint, b: BrandedUint): boolean {
  const sum = a.plus(b)
  return sum.lessThan(a)  // If sum < a, overflow occurred
}
```

### Fixed-Point Arithmetic

```typescript
// 18 decimal places (like Solidity)
const WAD = Uint.from(10n ** 18n)

function wadMul(a: BrandedUint, b: BrandedUint): BrandedUint {
  return a.times(b).dividedBy(WAD)
}

function wadDiv(a: BrandedUint, b: BrandedUint): BrandedUint {
  return a.times(WAD).dividedBy(b)
}

// Example: 2.5 * 1.5 = 3.75
const a = Uint.from(25n * 10n ** 17n)  // 2.5 WAD
const b = Uint.from(15n * 10n ** 17n)  // 1.5 WAD
const result = wadMul(a, b)             // 3.75 WAD
```

### Chaining Operations

```typescript
// Arithmetic expression: (a + b) * c - d
const result = a
  .plus(b)
  .times(c)
  .minus(d)

// With intermediate checks
const sum = a.plus(b)
if (sum.lessThan(a)) {
  throw new Error("Addition overflow")
}
const product = sum.times(c)
const final = product.minus(d)
```

## Arithmetic Operations Reference Table

| Operation | Method | Input | Output | Example | Behavior |
|-----------|--------|-------|--------|---------|----------|
| **Addition** | `plus(b)` | `BrandedUint` | `BrandedUint` | `100 + 50 = 150` | Wraps on overflow |
| **Subtraction** | `minus(b)` | `BrandedUint` | `BrandedUint` | `100 - 50 = 50` | Wraps on underflow |
| **Multiplication** | `times(b)` | `BrandedUint` | `BrandedUint` | `10 * 5 = 50` | Wraps on overflow |
| **Division** | `dividedBy(b)` | `BrandedUint` | `BrandedUint` | `100 / 10 = 10` | Floor division, throws if b=0 |
| **Modulo** | `modulo(b)` | `BrandedUint` | `BrandedUint` | `17 % 5 = 2` | Remainder, throws if b=0 |
| **Exponentiation** | `toPower(exp)` | `BrandedUint` | `BrandedUint` | `2^8 = 256` | Wraps on overflow |

**Wrapping Rules:**
- **Addition**: (a + b) mod 2^256
- **Subtraction**: (a - b + 2^256) mod 2^256
- **Multiplication**: (a * b) mod 2^256
- **Division**: Floor division (no remainder)
- **Modulo**: Remainder of floor division
- **Exponentiation**: (base ^ exp) mod 2^256

## Interactive Examples

<Tabs>
<TabItem label="Basic Operations">
```typescript
import { Uint } from '@tevm/voltaire'

// Addition
const sum = Uint.from(100n).plus(Uint.from(50n))
console.log(sum.toString())  // "150"

// Subtraction
const diff = Uint.from(100n).minus(Uint.from(30n))
console.log(diff.toString())  // "70"

// Multiplication
const product = Uint.from(12n).times(Uint.from(5n))
console.log(product.toString())  // "60"

// Division
const quotient = Uint.from(100n).dividedBy(Uint.from(10n))
console.log(quotient.toString())  // "10"

// Modulo
const remainder = Uint.from(17n).modulo(Uint.from(5n))
console.log(remainder.toString())  // "2"
```
</TabItem>
<TabItem label="Boundary Cases">
```typescript
import { Uint } from '@tevm/voltaire'

// Maximum + 1 wraps to 0
const overflow = Uint.MAX.plus(Uint.ONE)
console.log(overflow.equals(Uint.ZERO))  // true

// Zero - 1 wraps to MAX
const underflow = Uint.ZERO.minus(Uint.ONE)
console.log(underflow.equals(Uint.MAX))  // true

// Large multiplication wraps
const a = Uint.from(2n ** 200n)
const b = Uint.from(2n ** 200n)
const huge = a.times(b)  // (2^400) mod 2^256
console.log(huge.lessThan(a))  // true (wrapped smaller)

// Division by zero throws
try {
  Uint.from(100n).dividedBy(Uint.ZERO)
} catch (e) {
  console.log("Error: Division by zero")
}
```
</TabItem>
<TabItem label="Multi-Step Operations">
```typescript
import { Uint } from '@tevm/voltaire'

// Complex expression: (a + b) * c - d
const a = Uint.from(10n)
const b = Uint.from(20n)
const c = Uint.from(5n)
const d = Uint.from(25n)

const result = a
  .plus(b)          // 30
  .times(c)         // 150
  .minus(d)         // 125

console.log(result.toString())  // "125"

// Detect overflow in addition
function checkAdd(x: BrandedUint, y: BrandedUint): BrandedUint {
  const sum = x.plus(y)
  if (sum.lessThan(x)) {
    console.log("Overflow detected!")
  }
  return sum
}

const overflow = checkAdd(Uint.MAX, Uint.from(5n))
// Logs: "Overflow detected!"
```
</TabItem>
</Tabs>

## Tree-Shakeable Usage

All arithmetic operations available as tree-shakeable imports:

```typescript
import {
  plus,
  minus,
  times,
  dividedBy,
  modulo,
  toPower
} from '@tevm/voltaire/BrandedUint'

const a = Uint.from(100n)
const b = Uint.from(50n)

const sum = plus(a, b)
const diff = minus(a, b)
const product = times(a, b)
const quotient = dividedBy(a, b)
const remainder = modulo(a, b)
const power = toPower(a, Uint.from(2n))
```

See [BrandedUint](/primitives/uint/branded-uint) for details on tree-shakeable API.
