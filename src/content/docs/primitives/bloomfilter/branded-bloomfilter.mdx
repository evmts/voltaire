---
title: BrandedBloomFilter
description: Tree-shakeable functional API for BloomFilter operations
---

# BrandedBloomFilter

Tree-shakeable functional API for BloomFilter operations with optimal bundle size.

## Overview

`BrandedBloomFilter` is the functional layer underlying the `BloomFilter` class. It provides:
- **Zero-overhead** [branded type](/primitives/branded-types) wrapping `Uint8Array`
- **Tree-shakeable** individual function exports
- **Data-first** unopinionated methods taking filter as first parameter
- **Bundle optimization** through selective imports

Primary benefit: Import only the functions you need, excluding unused operations from bundle.

## Type Definition

```typescript
export type BrandedBloomFilter = Uint8Array & {
  readonly __tag: "BloomFilter"
  readonly k: number  // Number of hash functions
  readonly m: number  // Number of bits
}
```

Runtime-validated `Uint8Array` with bloom filter parameters. [Brand](/primitives/branded-types) prevents accidental mixing with other Uint8Arrays.

Defined in: [primitives/BloomFilter/BrandedBloomFilter/BrandedBloomFilter.ts](https://github.com/evmts/primitives/blob/main/src/primitives/BloomFilter/BrandedBloomFilter/BrandedBloomFilter.ts)

## Namespace API

All functions exported as both individual exports and namespace:

```typescript
import * as BrandedBloomFilter from '@tevm/voltaire/BrandedBloomFilter'

// Namespace usage
const filter = BrandedBloomFilter.create(2048, 3)
const item = new TextEncoder().encode("Transfer")
BrandedBloomFilter.add(filter, item)
const hasItem = BrandedBloomFilter.contains(filter, item)
```

## Tree-Shakeable Usage

Import only what you need:

```typescript
import { create, add, contains } from '@tevm/voltaire/BrandedBloomFilter'
import type { BrandedBloomFilter } from '@tevm/voltaire/BrandedBloomFilter'

const filter: BrandedBloomFilter = create(2048, 3)
const item = new TextEncoder().encode("Transfer")
add(filter, item)
const hasItem = contains(filter, item)
```

**Bundle impact:** Only `create`, `add`, and `contains` included. Methods like `merge`, `isEmpty`, `toHex` excluded.

## Available Functions

All BloomFilter functionality available as tree-shakeable functions:

### Constructors

```typescript
import { create, fromHex } from '@tevm/voltaire/BrandedBloomFilter'

// Create new filter
const filter = create(2048, 3)

// Deserialize from hex
const restored = fromHex("0x000...", 2048, 3)
```

See [Constructors](/primitives/bloomfilter/constructors) for details.

### Operations

```typescript
import { add, merge } from '@tevm/voltaire/BrandedBloomFilter'

// Add item (mutates filter)
const item = new TextEncoder().encode("Transfer")
add(filter, item)

// Merge filters (returns new filter)
const filter2 = create(2048, 3)
const merged = merge(filter, filter2)
```

See [Operations](/primitives/bloomfilter/operations) for details.

### Queries

```typescript
import { contains, isEmpty } from '@tevm/voltaire/BrandedBloomFilter'

// Check membership
const hasItem = contains(filter, item)  // boolean

// Check if empty
const empty = isEmpty(filter)  // boolean
```

See [Queries](/primitives/bloomfilter/queries) for details.

### Conversions

```typescript
import { toHex, hash } from '@tevm/voltaire/BrandedBloomFilter'

// Serialize to hex
const hex = toHex(filter)  // "0x000..."

// Compute hash (internal utility)
const h = hash(item, 0, 2048)  // number
```

See [Conversions](/primitives/bloomfilter/conversions) for details.

## Data-First Pattern

All BrandedBloomFilter functions follow data-first pattern:

```typescript
// BrandedBloomFilter: filter is first parameter
add(filter, item)
contains(filter, item)
merge(filter1, filter2)

// vs BloomFilter class: filter is implicit (this)
filter.add(item)
filter.contains(item)
filter1.merge(filter2)
```

This enables functional composition and partial application:

```typescript
import { create, add, contains, isEmpty } from '@tevm/voltaire/BrandedBloomFilter'

// Function composition
const addAndCheck = (filter: BrandedBloomFilter, item: Uint8Array) => {
  add(filter, item)
  return contains(filter, item)
}

// Partial application
const checkFilter = (item: Uint8Array) => contains(filter, item)

// Array methods
const items = [
  new TextEncoder().encode("Transfer"),
  new TextEncoder().encode("Approval"),
  new TextEncoder().encode("Swap")
]

items.forEach(item => add(filter, item))
items.every(item => contains(filter, item))  // true
```

## Tree-Shaking Benefits

Primary benefit: **Only include functions you use**

### Example 1: Minimal Bundle

```typescript
import { create, add, contains } from '@tevm/voltaire/BrandedBloomFilter'

const filter = create(2048, 3)
add(filter, item)
const hasItem = contains(filter, item)
```

**Bundle includes:** `create`, `add`, `contains`, `hash` (used internally)

**Bundle excludes:** `merge`, `isEmpty`, `toHex`, `fromHex`

### Example 2: With Serialization

```typescript
import { create, add, toHex, fromHex } from '@tevm/voltaire/BrandedBloomFilter'

const filter = create(2048, 3)
add(filter, item)
const hex = toHex(filter)

// Later
const restored = fromHex(hex, 2048, 3)
```

**Bundle includes:** `create`, `add`, `toHex`, `fromHex`, `hash`

**Bundle excludes:** `merge`, `isEmpty`, `contains`

### Example 3: BloomFilter Class (Everything)

```typescript
import { BloomFilter } from '@tevm/voltaire'

const filter = BloomFilter.create(2048, 3)
```

**Bundle includes:** All BloomFilter methods (due to prototype methods)

## Function Reference

Complete API reference with type signatures:

### create

```typescript
function create(m: number, k: number): BrandedBloomFilter
```

Creates new empty bloom filter.

**Throws:** `InvalidBloomFilterParameterError` if `m <= 0` or `k <= 0`

### fromHex

```typescript
function fromHex(hex: string, m: number, k: number): BrandedBloomFilter
```

Deserializes bloom filter from hex string.

**Throws:** `InvalidBloomFilterLengthError` if hex length doesn't match m

### add

```typescript
function add(filter: BrandedBloomFilter, item: Uint8Array): void
```

Adds item to bloom filter (mutates in place).

### contains

```typescript
function contains(filter: BrandedBloomFilter, item: Uint8Array): boolean
```

Returns true if item might be in filter (false if definitely not).

### merge

```typescript
function merge(
  filter1: BrandedBloomFilter,
  filter2: BrandedBloomFilter
): BrandedBloomFilter
```

Merges two filters using bitwise OR (returns new filter).

**Throws:** `InvalidBloomFilterParameterError` if filters have different parameters

### isEmpty

```typescript
function isEmpty(filter: BrandedBloomFilter): boolean
```

Returns true if all bits are zero.

### toHex

```typescript
function toHex(filter: BrandedBloomFilter): string
```

Serializes filter to hex string with "0x" prefix.

### hash

```typescript
function hash(item: Uint8Array, seed: number, m: number): number
```

Computes hash value in range [0, m). Internal utility exposed for testing.

## Constants

```typescript
import { SIZE, BITS, DEFAULT_HASH_COUNT } from '@tevm/voltaire/BrandedBloomFilter'

SIZE                 // 256 (bytes)
BITS                 // 2048 (bits)
DEFAULT_HASH_COUNT   // 3 (hash functions)
```

## When to Use BrandedBloomFilter vs BloomFilter

### Use BrandedBloomFilter When:
- **Bundle size critical** (mobile, embedded, edge functions)
- **Using few methods** (only add/contains, not merge/toHex)
- **Functional style** preferred
- **Selective imports** desired
- **Composing functions** heavily

### Use BloomFilter Class When:
- **OOP style** preferred
- **Ergonomics** over bundle size
- **Using many methods** (already in bundle)
- **Type safety** with prototype methods
- **Traditional API** expected

## Interoperability

BrandedBloomFilter and BloomFilter are fully compatible:

```typescript
import { BloomFilter } from '@tevm/voltaire'
import { add, contains } from '@tevm/voltaire/BrandedBloomFilter'

// BloomFilter IS a BrandedBloomFilter
const filter = BloomFilter.create(2048, 3)
add(filter, item)  // ✓ works

// BrandedBloomFilter works with BloomFilter static methods
const branded = create(2048, 3)
BloomFilter.add(branded, item)  // ✓ works
```

## Advanced Patterns

### Pipeline Composition

```typescript
import { create, add, contains } from '@tevm/voltaire/BrandedBloomFilter'

// Build processing pipeline
function processItems(items: Uint8Array[]): BrandedBloomFilter {
  const filter = create(2048, 3)
  items.forEach(item => add(filter, item))
  return filter
}

// Check pipeline
function checkItems(
  filter: BrandedBloomFilter,
  items: Uint8Array[]
): boolean[] {
  return items.map(item => contains(filter, item))
}

// Usage
const items = [
  new TextEncoder().encode("item1"),
  new TextEncoder().encode("item2")
]

const filter = processItems(items)
const results = checkItems(filter, items)
```

### Curried Functions

```typescript
import { contains } from '@tevm/voltaire/BrandedBloomFilter'

// Curry contains for specific item
function containsItem(item: Uint8Array) {
  return (filter: BrandedBloomFilter) => contains(filter, item)
}

// Usage
const hasTransfer = containsItem(new TextEncoder().encode("Transfer"))

const filters = [filter1, filter2, filter3]
const withTransfer = filters.filter(hasTransfer)
```

### Functional Reduce

```typescript
import { create, merge } from '@tevm/voltaire/BrandedBloomFilter'

// Merge multiple filters
function mergeAll(filters: BrandedBloomFilter[]): BrandedBloomFilter {
  return filters.reduce(
    (acc, filter) => merge(acc, filter),
    create(2048, 3)  // Initial empty filter
  )
}

// Usage
const blockFilters = [
  fromHex(block1.logsBloom, 2048, 3),
  fromHex(block2.logsBloom, 2048, 3),
  fromHex(block3.logsBloom, 2048, 3)
]

const rangeFilter = mergeAll(blockFilters)
```

### Type Guards

```typescript
import type { BrandedBloomFilter } from '@tevm/voltaire/BrandedBloomFilter'

// Type guard for BrandedBloomFilter
function isBrandedBloomFilter(value: unknown): value is BrandedBloomFilter {
  return (
    value instanceof Uint8Array &&
    '__tag' in value &&
    value.__tag === "BloomFilter" &&
    'k' in value &&
    'm' in value
  )
}

// Usage
function processFilter(value: unknown) {
  if (!isBrandedBloomFilter(value)) {
    throw new Error("Not a BloomFilter")
  }

  // TypeScript knows value is BrandedBloomFilter
  const hex = toHex(value)
}
```

## Bundle Size Comparison

Approximate bundle sizes (minified + gzipped):

| Import Style | Size | Includes |
|-------------|------|----------|
| `import { create, add, contains }` | ~0.5 KB | Core operations only |
| `import { create, add, contains, toHex }` | ~0.7 KB | + Serialization |
| `import { create, add, merge, toHex }` | ~1.0 KB | + Merge operation |
| `import { BloomFilter }` | ~1.2 KB | All methods |

**Note:** Sizes are estimates. Actual size depends on bundler, minification, and other factors.

## Performance

BrandedBloomFilter functions have identical performance to BloomFilter class methods - same underlying implementation:

```typescript
// Identical performance
const filter1 = BloomFilter.create(2048, 3)
filter1.add(item)

const filter2 = create(2048, 3)
add(filter2, item)
```

Only difference is call style and tree-shaking behavior.

## Related

- [BloomFilter](/primitives/bloomfilter/) - Main BloomFilter class documentation
- [Constructors](/primitives/bloomfilter/constructors) - Creating filters
- [Operations](/primitives/bloomfilter/operations) - Adding and merging
- [Queries](/primitives/bloomfilter/queries) - Membership testing
- [Conversions](/primitives/bloomfilter/conversions) - Serialization
- [Algorithm](/primitives/bloomfilter/algorithm) - Understanding bloom filters
- [Branded Types](/primitives/branded-types) - Zero-overhead type branding
