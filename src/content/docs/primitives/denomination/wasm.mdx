---
title: WASM Implementation
description: WebAssembly-accelerated denomination conversions compiled from Zig
---

import { Tabs, TabItem, Aside } from '@astrojs/starlight/components';

# WASM Implementation

WebAssembly-accelerated implementations of denomination conversions, compiled from Zig using ReleaseSmall mode.

## Overview

WASM implementations provide performance-critical denomination operations using compiled Zig code targeting WebAssembly. These are **purely opt-in** replacements for the JavaScript implementations with identical APIs.

All WASM methods are compiled from [denomination.zig](https://github.com/evmts/voltaire/blob/main/src/primitives/Denomination/denomination.zig) with `ReleaseSmall` optimization targeting minimal bundle size.

## Quick Start

<Tabs>
<TabItem label="Direct Import">
```typescript
// Import WASM implementation instead of JS version
import * as Wei from '@tevm/voltaire/Wei.wasm'
import * as Gwei from '@tevm/voltaire/Gwei.wasm'
import * as Ether from '@tevm/voltaire/Ether.wasm'

// API is identical to JS version
const gwei = Gwei.from(50n)
const wei = Gwei.toWei(gwei)  // Uses WASM acceleration
const ether = Wei.toEther(wei)  // Uses WASM acceleration
```
</TabItem>

<TabItem label="Selective Import">
```typescript
import * as Wei from '@tevm/voltaire/Wei'
import * as WeiWasm from '@tevm/voltaire/Wei.wasm'

// Override specific methods with WASM versions
const weiToGwei = WeiWasm.toGwei
const weiToEther = WeiWasm.toEther

// Use WASM versions
const wei = Wei.from(1_000_000_000n)
const gwei = weiToGwei(wei)
```
</TabItem>
</Tabs>

## Performance

WASM implementations provide significant speedup for:

- **U256 arithmetic** - Compiled Zig multiplication and division
- **Bulk conversions** - Processing many values in tight loops
- **Constant-time operations** - No JavaScript overhead

<Aside type="tip" title="When to use WASM">
Use WASM when processing many denomination conversions (gas calculations, bulk balance conversions). For single operations, JS overhead may outweigh WASM benefits.
</Aside>

## Zig Implementation

The Zig source implements three denomination types:

```zig
// denomination.zig
pub const Wei = struct {
    value: U256,

    pub fn from_u256(v: U256) Wei
    pub fn to_u256(self: Wei) U256
    pub fn to_gwei(self: Wei) Gwei
    pub fn to_ether(self: Wei) Ether
    pub fn from_gwei(g: Gwei) Wei
    pub fn from_ether(e: Ether) Wei
}

pub const Gwei = struct {
    value: U256,

    pub fn from_u256(v: U256) Gwei
    pub fn to_u256(self: Gwei) U256
    pub fn to_wei(self: Gwei) Wei
    pub fn to_ether(self: Gwei) Ether
    pub fn from_wei(w: Wei) Gwei
    pub fn from_ether(e: Ether) Gwei
}

pub const Ether = struct {
    value: U256,

    pub fn from_u256(v: U256) Ether
    pub fn to_u256(self: Ether) U256
    pub fn to_wei(self: Ether) Wei
    pub fn to_gwei(self: Ether) Gwei
    pub fn from_wei(w: Wei) Ether
    pub fn from_gwei(g: Gwei) Ether
}
```

**Conversion constants:**
```zig
pub const WEI_PER_GWEI: U256 = U256.from_u64(1_000_000_000)
pub const WEI_PER_ETHER: U256 = blk: {
    var limbs: [4]u64 = .{ 0xde0b6b3a7640000, 0, 0, 0 }
    break :blk U256.from_limbs(limbs)
}
pub const GWEI_PER_ETHER: U256 = U256.from_u64(1_000_000_000)
```

Defined in: [primitives/Denomination/denomination.zig](https://github.com/evmts/voltaire/blob/main/src/primitives/Denomination/denomination.zig)
Tests: [denomination.zig](https://github.com/evmts/voltaire/blob/main/src/primitives/Denomination/denomination.zig)

## API Reference

WASM implementations match the standard Denomination API. See main documentation:

- [Wei](/primitives/denomination/wei) - `from`, `fromGwei`, `fromEther`, `toGwei`, `toEther`, `toU256`
- [Gwei](/primitives/denomination/gwei) - `from`, `fromWei`, `fromEther`, `toWei`, `toEther`, `toU256`
- [Ether](/primitives/denomination/ether) - `from`, `fromWei`, `fromGwei`, `toWei`, `toGwei`, `toU256`

## WASM-Accelerated Methods

All denomination conversions implemented in Zig:

### Wei

```typescript
import * as WeiWasm from '@tevm/voltaire/Wei.wasm'

// Construction
const wei = WeiWasm.from(1_000_000_000n)

// Conversions
const gwei = WeiWasm.toGwei(wei)      // Wei → Gwei (division)
const ether = WeiWasm.toEther(wei)    // Wei → Ether (division)
const u256 = WeiWasm.toU256(wei)      // Wei → Uint256 (unwrap)

// From other units
const wei2 = WeiWasm.fromGwei(gwei)   // Gwei → Wei (multiplication)
const wei3 = WeiWasm.fromEther(ether) // Ether → Wei (multiplication)
```

### Gwei

```typescript
import * as GweiWasm from '@tevm/voltaire/Gwei.wasm'

// Construction
const gwei = GweiWasm.from(50n)

// Conversions
const wei = GweiWasm.toWei(gwei)      // Gwei → Wei (multiplication)
const ether = GweiWasm.toEther(gwei)  // Gwei → Ether (division)
const u256 = GweiWasm.toU256(gwei)    // Gwei → Uint256 (unwrap)

// From other units
const gwei2 = GweiWasm.fromWei(wei)   // Wei → Gwei (division)
const gwei3 = GweiWasm.fromEther(ether) // Ether → Gwei (multiplication)
```

### Ether

```typescript
import * as EtherWasm from '@tevm/voltaire/Ether.wasm'

// Construction
const ether = EtherWasm.from(1n)

// Conversions
const wei = EtherWasm.toWei(ether)    // Ether → Wei (multiplication)
const gwei = EtherWasm.toGwei(ether)  // Ether → Gwei (multiplication)
const u256 = EtherWasm.toU256(ether)  // Ether → Uint256 (unwrap)

// From other units
const ether2 = EtherWasm.fromWei(wei)   // Wei → Ether (division)
const ether3 = EtherWasm.fromGwei(gwei) // Gwei → Ether (division)
```

## Usage Examples

### Bulk Gas Calculations

```typescript
import * as GweiWasm from '@tevm/voltaire/Gwei.wasm'
import * as Uint from '@tevm/voltaire/Uint'

const gasPrices = [
  GweiWasm.from(10n),
  GweiWasm.from(30n),
  GweiWasm.from(50n),
  GweiWasm.from(100n),
]

const gasUsed = Uint.from(21_000n)

// Process all in WASM (faster for bulk operations)
const costs = gasPrices.map(price => {
  const priceWei = GweiWasm.toWei(price)
  return Uint.times(priceWei, gasUsed)
})
```

### Balance Conversions

```typescript
import * as WeiWasm from '@tevm/voltaire/Wei.wasm'

const balancesWei = [
  WeiWasm.from(1_000_000_000_000_000_000n),
  WeiWasm.from(2_500_000_000_000_000_000n),
  WeiWasm.from(500_000_000_000_000_000n),
]

// Convert all to Ether using WASM
const balancesEther = balancesWei.map(WeiWasm.toEther)
```

### Real-Time Gas Price Tracking

```typescript
import * as GweiWasm from '@tevm/voltaire/Gwei.wasm'
import * as WeiWasm from '@tevm/voltaire/Wei.wasm'

interface GasEstimate {
  fast: bigint
  standard: bigint
  slow: bigint
}

function estimateCost(
  estimate: GasEstimate,
  gasUsed: bigint
): GasEstimate {
  // Convert all Gwei prices to Wei costs using WASM
  const fast = GweiWasm.toWei(GweiWasm.from(estimate.fast))
  const standard = GweiWasm.toWei(GweiWasm.from(estimate.standard))
  const slow = GweiWasm.toWei(GweiWasm.from(estimate.slow))

  return {
    fast: fast * gasUsed,
    standard: standard * gasUsed,
    slow: slow * gasUsed,
  }
}
```

## Performance Characteristics

### Multiplication (Upscaling)

Conversions that multiply are memory-bound:
- `Gwei.toWei` - multiply by 10^9
- `Ether.toWei` - multiply by 10^18
- `Ether.toGwei` - multiply by 10^9

**WASM benefit:** Moderate (10-30% faster) - limited by memory access.

### Division (Downscaling)

Conversions that divide are compute-bound:
- `Wei.toGwei` - divide by 10^9
- `Wei.toEther` - divide by 10^18
- `Gwei.toEther` - divide by 10^9

**WASM benefit:** Significant (2-5x faster) - Zig division highly optimized.

## Files

- **denomination.zig** - Zig source implementation
  - Location: [src/primitives/Denomination/denomination.zig](https://github.com/evmts/voltaire/blob/main/src/primitives/Denomination/denomination.zig)
  - Defines `Wei`, `Gwei`, `Ether` structs
  - Implements all conversion methods
  - Includes test suite

- **Wei.wasm.ts** - TypeScript WASM bindings for Wei
- **Gwei.wasm.ts** - TypeScript WASM bindings for Gwei
- **Ether.wasm.ts** - TypeScript WASM bindings for Ether

## Zig Tests

The Zig implementation includes comprehensive tests:

```zig
test "wei to gwei conversion" {
    const w = Wei.from_u256(U256.from_u64(1_000_000_000))
    const g = w.to_gwei()
    try testing.expect(g.value.eq(U256.from_u64(1)))
}

test "wei to ether conversion" {
    const limbs: [4]u64 = .{ 0xde0b6b3a7640000, 0, 0, 0 }
    const w = Wei.from_u256(U256.from_limbs(limbs))
    const e = w.to_ether()
    try testing.expect(e.value.eq(U256.from_u64(1)))
}

test "round trip conversions" {
    const original = Wei.from_u256(U256.from_u64(5_000_000_000))
    const g = original.to_gwei()
    const back = g.to_wei()
    try testing.expect(back.value.eq(U256.from_u64(5_000_000_000)))
}
```

Run tests:
```bash
zig build test -Dtest-filter="denomination"
```

## Tree-Shakeable Usage

Import only methods you need:

```typescript
import { from, toWei, toEther } from '@tevm/voltaire/Gwei.wasm'
import type { Gwei } from '@tevm/voltaire/Gwei'

const gwei: Gwei.Type = from(50n)
const wei = toWei(gwei)
const ether = toEther(gwei)
```

WASM loader only included if you import WASM methods. Using pure JS versions excludes WASM from bundle.

<Aside type="note" title="Bundle Size">
WASM module compiled with ReleaseSmall (~2-3KB gzipped). Only included when importing from `.wasm.ts` files. Shared across Wei, Gwei, and Ether modules.
</Aside>

## Benchmarking

Compare JS vs WASM performance:

```typescript
import * as Gwei from '@tevm/voltaire/Gwei'
import * as GweiWasm from '@tevm/voltaire/Gwei.wasm'

const iterations = 100_000
const gwei = Gwei.from(50n)

// Benchmark JS
console.time('JS')
for (let i = 0; i < iterations; i++) {
  Gwei.toWei(gwei)
}
console.timeEnd('JS')

// Benchmark WASM
console.time('WASM')
for (let i = 0; i < iterations; i++) {
  GweiWasm.toWei(gwei)
}
console.timeEnd('WASM')
```

## Limitations

WASM implementations have same behavior as JS:
- **Integer division** - Fractional results truncate
- **No overflow checks** - U256 operations wrap
- **Same API** - Drop-in replacement

## Related

- [Wei](/primitives/denomination/wei) - Wei API reference
- [Gwei](/primitives/denomination/gwei) - Gwei API reference
- [Ether](/primitives/denomination/ether) - Ether API reference
- [Conversions](/primitives/denomination/conversions) - Conversion details
- [Uint WASM](/primitives/uint/wasm) - Underlying U256 WASM implementation
