---
title: BrandedHash
description: Tree-shakeable functional API for Hash operations
---

# BrandedHash

Tree-shakeable functional API for Hash operations with optimal bundle size.

## Overview

`BrandedHash` is the functional layer underlying the `Hash` class. It provides:
- **Zero-overhead** [branded type](/primitives/branded-types) wrapping `Uint8Array` (32 bytes)
- **Tree-shakeable** individual function exports
- **Data-first** unopinionated methods taking hash as first parameter
- **Bundle optimization** through selective imports

Primary benefit: When using tree-shakeable imports and avoiding Keccak-256 methods, the crypto implementation is excluded from bundle.

## Type Definition

```typescript
export type BrandedHash = Uint8Array & {
  readonly __tag: "Hash"
}
```

Runtime-validated 32-byte `Uint8Array`. [Brand](/primitives/branded-types) prevents accidental mixing with other Uint8Arrays.

Defined in: [primitives/Hash/BrandedHash/BrandedHash.ts](https://github.com/evmts/primitives/blob/main/src/primitives/Hash/BrandedHash/BrandedHash.ts)

## Namespace API

All functions exported as both individual exports and namespace:

```typescript
import * as BrandedHash from '@tevm/voltaire/BrandedHash'

// Namespace usage
const hash = BrandedHash.from("0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef")
const hex = BrandedHash.toHex(hash)
const dataHash = BrandedHash.keccak256(data)
```

## Tree-Shakeable Usage

Import only what you need:

```typescript
import { from, toHex, equals, keccak256String } from '@tevm/voltaire/BrandedHash'
import type { BrandedHash } from '@tevm/voltaire/BrandedHash'

const hash: BrandedHash = from("0x1234567890abcdef...")
const hex = toHex(hash)
const isEqual = equals(hash, otherHash)
const eventHash = keccak256String("Transfer(address,address,uint256)")
```

**Bundle impact:** Only `from`, `toHex`, `equals`, and `keccak256String` included. Methods like `random`, `clone`, `slice` excluded unless imported.

## Available Functions

All Hash functionality available as tree-shakeable functions:

### Constructors

```typescript
import {
  from,
  fromHex,
  fromBytes,
  keccak256,
  keccak256String,
  keccak256Hex,
  random
} from '@tevm/voltaire/BrandedHash'

const hash1 = from("0x1234567890abcdef...")
const hash2 = fromHex("0x1234567890abcdef...")
const hash3 = fromBytes(new Uint8Array(32))
const dataHash = keccak256(data)
const stringHash = keccak256String("hello")
const hexHash = keccak256Hex("0x1234")
const randomHash = random()
```

See [Constructors](/primitives/hash/constructors) for details.

**Tree-shaking note:** `keccak256`, `keccak256String`, `keccak256Hex` include @noble/hashes (~2-3KB gzipped).

### Conversions

```typescript
import {
  toHex,
  toString,
  toBytes,
  format
} from '@tevm/voltaire/BrandedHash'

const hex = toHex(hash)          // "0x..."
const str = toString(hash)       // "0x..." (same as toHex)
const bytes = toBytes(hash)      // Uint8Array(32)
const display = format(hash)     // "0x1c8aff...eac8"
```

See [Conversions](/primitives/hash/conversions) for details.

### Comparisons

```typescript
import {
  equals,
  isZero
} from '@tevm/voltaire/BrandedHash'

equals(hash1, hash2)  // boolean
isZero(hash)          // boolean
```

See [Comparisons](/primitives/hash/comparisons) for details.

### Validation

```typescript
import {
  isValidHex,
  isHash,
  assert
} from '@tevm/voltaire/BrandedHash'

isValidHex("0x1234567890abcdef...")  // boolean
isHash(value)                         // type guard
assert(value)                         // throws if invalid
```

See [Validation](/primitives/hash/validation) for details.

### Utilities

```typescript
import {
  random,
  clone,
  slice,
  format
} from '@tevm/voltaire/BrandedHash'

const randomHash = random()
const copy = clone(hash)
const selector = slice(hash, 0, 4)
const display = format(hash)
```

See [Utilities](/primitives/hash/utilities) for details.

## Data-First Pattern

All BrandedHash functions follow data-first pattern:

```typescript
// BrandedHash: hash is first parameter
toHex(hash)
equals(hash1, hash2)
keccak256(data)

// vs Hash class: hash is implicit (this)
hash.toHex()
hash1.equals(hash2)
Hash.keccak256(data)
```

This enables functional composition and partial application:

```typescript
import { toHex, equals, isZero, keccak256String } from '@tevm/voltaire/BrandedHash'

// Function composition
const formatHash = (hash: BrandedHash) => toHex(hash).toUpperCase()

// Partial application
const isTransferEvent = (hash: BrandedHash) =>
  equals(hash, keccak256String("Transfer(address,address,uint256)"))

// Array methods
hashes.map(toHex)
hashes.filter(hash => !isZero(hash))
hashes.some(hash => equals(hash, target))
```

## Tree-Shaking Benefits

Primary benefit: **Selective inclusion of crypto dependencies**

### Example 1: Minimal Bundle (No Crypto)

```typescript
import { from, toHex, equals, format } from '@tevm/voltaire/BrandedHash'

const hash = from("0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef")
const hex = toHex(hash)
const display = format(hash)
const isEqual = equals(hash, otherHash)
```

**Bundle:** No @noble/hashes. Only basic conversions and comparisons.

### Example 2: With Hashing (Keccak-256 Only)

```typescript
import { keccak256String, toHex } from '@tevm/voltaire/BrandedHash'

const eventHash = keccak256String("Transfer(address,address,uint256)")
const hex = toHex(eventHash)
```

**Bundle:** Includes @noble/hashes Keccak-256 implementation (~2-3KB gzipped).

### Example 3: Hash Class (Everything)

```typescript
import { Hash } from '@tevm/voltaire'

const hash = new Hash("0x1234567890abcdef...")
```

**Bundle:** Includes all Hash methods and dependencies on prototype.

## Dependency Table

| Method/Function | @noble/hashes | Notes |
|-----------------|---------------|-------|
| `from`, `fromHex`, `fromBytes` | ✗ | Pure conversions |
| `keccak256`, `keccak256String`, `keccak256Hex` | ✓ | Keccak-256 hashing |
| `toHex`, `toString`, `toBytes`, `format` | ✗ | Pure conversions |
| `equals`, `isZero` | ✗ | Byte comparisons |
| `isValidHex`, `isHash`, `assert` | ✗ | Basic validation |
| `random`, `clone`, `slice` | ✗ | Pure utilities |
| **Hash class** | ✓ | All methods on prototype |

## When to Use BrandedHash vs Hash

### Use BrandedHash When:
- **Bundle size critical** (mobile, embedded)
- **Avoiding crypto** dependencies
- **Functional style** preferred
- **Selective imports** desired
- **Composing functions** heavily

### Use Hash Class When:
- **OOP style** preferred
- **Ergonomics** over bundle size
- **Using many methods** (crypto already in bundle)
- **Type safety** with prototype methods
- **Traditional API** expected

## Interoperability

BrandedHash and Hash are fully compatible:

```typescript
import { Hash, BrandedHash } from '@tevm/voltaire'
import { toHex, equals } from '@tevm/voltaire/BrandedHash'

// Hash IS a BrandedHash
const hash = new Hash("0x1234567890abcdef...")
const hex = toHex(hash) // ✓ works

// BrandedHash works with Hash static methods
const branded: BrandedHash = BrandedHash.from("0x...")
const display = Hash.format(branded) // ✓ works
```

## Constants

```typescript
import { SIZE, ZERO } from '@tevm/voltaire/BrandedHash'

SIZE  // 32 (bytes)
ZERO  // Uint8Array(32) [0, 0, 0, ...]
```

## Usage Patterns

### Event Signature Hashing

```typescript
import { keccak256String, equals } from '@tevm/voltaire/BrandedHash'

const TRANSFER_SIG = keccak256String("Transfer(address,address,uint256)")
const APPROVAL_SIG = keccak256String("Approval(address,address,uint256)")

function getEventType(topic0: BrandedHash): string {
  if (equals(topic0, TRANSFER_SIG)) return "Transfer"
  if (equals(topic0, APPROVAL_SIG)) return "Approval"
  return "Unknown"
}
```

### Function Selector Extraction

```typescript
import { keccak256String, slice } from '@tevm/voltaire/BrandedHash'

const transferHash = keccak256String("transfer(address,uint256)")
const selector = slice(transferHash, 0, 4)
// Uint8Array [0xa9, 0x05, 0x9c, 0xbb]
```

### Transaction Hash Display

```typescript
import { from, format } from '@tevm/voltaire/BrandedHash'

function formatTxHash(txHash: string): string {
  const hash = from(txHash)
  return format(hash, 8, 6) // "0x1c8aff95...6deac8"
}
```

### Merkle Proof Verification

```typescript
import { keccak256, equals } from '@tevm/voltaire/BrandedHash'
import type { BrandedHash } from '@tevm/voltaire/BrandedHash'

function verifyProof(
  leaf: BrandedHash,
  proof: BrandedHash[],
  root: BrandedHash
): boolean {
  let hash = leaf

  for (const sibling of proof) {
    const combined = new Uint8Array([...hash, ...sibling])
    hash = keccak256(combined)
  }

  return equals(hash, root)
}
```

## Related

- [Hash](/primitives/hash/) - Main Hash class documentation
- [Constructors](/primitives/hash/constructors) - Creating hashes
- [Conversions](/primitives/hash/conversions) - Format conversions
- [Comparisons](/primitives/hash/comparisons) - Equality testing
- [Validation](/primitives/hash/validation) - Input validation
- [Hashing](/primitives/hash/hashing) - Keccak-256 methods
- [Utilities](/primitives/hash/utilities) - Helper functions
