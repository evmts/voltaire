---
title: Overview
description: Universal patterns and design philosophy of Voltaire
---

import { Tabs, TabItem, Card, CardGrid, Aside, FileTree, Steps } from '@astrojs/starlight/components';

# Overview

Voltaire follows consistent patterns across all primitives, making the API predictable and easy to learn.

## Architecture

Voltaire is built on a multi-language stack combining the ergonomics of TypeScript with the performance of systems programming languages:

```
┌─────────────────────────────────────────────────┐
│             TypeScript API Layer                │
│   (Branded types, dual APIs, tree-shakeable)    │
├─────────────────────────────────────────────────┤
│              Performance Layers                 │
│  ┌──────────┬──────────┬──────────┬──────────┐ │
│  │   Zig    │   Rust   │     C    │ WASM     │ │
│  │ (native) │ (crypto) │ (crypto) │ (web)    │ │
│  └──────────┴──────────┴──────────┴──────────┘ │
├─────────────────────────────────────────────────┤
│         Native Libraries & Dependencies         │
│     blst | c-kzg-4844 | libwally | arkworks   │
└─────────────────────────────────────────────────┘
```

**Layer responsibilities:**

- **TypeScript**: API design, type safety, developer ergonomics
- **Zig**: High-performance primitives, FFI bindings, WASM compilation
- **Rust**: Optimized cryptography (keccak-asm, arkworks)
- **C**: Battle-tested crypto libraries (blst, c-kzg-4844)
- **WASM**: Browser-optimized performance (2-10x speedup)

See [Architecture Deep Dive](/architecture/) for technical details.

## Design Philosophy

### Simple Data Structures

Built on native JavaScript primitives — `Uint8Array`, `bigint`, `string`. No complex wrapper objects at runtime.

```typescript
// Runtime: just a Uint8Array
const addr = Address.from("0xa0cf798816d4b9b9866b5330eea46a18382f251e");
typeof addr; // "object"
addr instanceof Uint8Array; // true
```

**Benefits:**
- Natural JSON serialization
- Works with existing libraries
- Zero overhead
- Direct memory access

### Close-to-Spec APIs

Minimal abstraction over Ethereum primitives. Method names mirror Yellow Paper and EIPs.

```typescript
// EIP-55 checksumming
Address.toChecksummed(addr);

// EIP-1559 transaction fields
const tx: Transaction.EIP1559 = {
  type: 2,
  maxFeePerGas: 30000000000n,
  maxPriorityFeePerGas: 1000000000n,
  // ...
};
```

### Built for Humans and LLMs

APIs designed for predictability:

**Consistent Naming:**
- `Type.from()` — Universal constructor
- `Type.fromHex()` / `Type.toHex()` — Format conversions
- `Type.equals()` — Comparisons
- `Type.isValid()` — Validation

**Documentation:**
- Examples for every method
- Links to EIP specs
- Type signatures in MDX
- Runnable code samples

**Pattern Recognition:**
Once you learn `Address.fromHex()`, you know `Hash.fromHex()`, `Uint.fromHex()` work the same way.

### Why WASM?

Voltaire provides optional WASM implementations for performance-critical operations:

**Performance gains:**
- **Keccak256**: 8-12x faster (3.2µs → 365ns for 32 bytes)
- **Address checksumming**: 2-3x faster
- **Uint256 arithmetic**: 5-8x faster for bulk operations

**Bundle optimization:**
- Tree-shakeable: Only include what you use
- Individual modules: 2-4 KB gzipped per crypto function
- Zero overhead: WASM loader only included when imported

**Browser compatibility:**
- Works in all modern browsers (Chrome 57+, Firefox 52+, Safari 11+)
- Automatic fallback to pure JavaScript when unavailable
- No build configuration required

See [WASM Acceleration](/wasm/) and [Performance](/performance/) for details.

### Why Branded Types?

Branded types provide compile-time safety with zero runtime overhead:

```typescript
// Compile-time error prevents bugs
function sendEther(to: BrandedAddress, amount: BrandedUint) { ... }

const hash = Hash.fromHex("0x...");
sendEther(hash, 100n);  // Error: Hash is not assignable to BrandedAddress
```

**Benefits:**
- Type errors caught at compile time, not runtime
- Zero runtime overhead (brands are TypeScript-only)
- Self-documenting code (types show intent)
- IDE autocomplete and refactoring support

**vs alternatives:**

<Tabs>
<TabItem label="Voltaire">

```typescript
// Type-safe, zero overhead
const addr: BrandedAddress = Address.from("0x...");
const hash: BrandedHash = Hash.from("0x...");
// addr = hash; // Compile error
```

</TabItem>
<TabItem label="ethers.js">

```typescript
// Strings everywhere, no type safety
const addr = "0x...";
const hash = "0x...";
const oops = addr + hash; // Runtime bug
```

</TabItem>
<TabItem label="Class wrappers">

```typescript
// Runtime overhead, no tree-shaking
const addr = new Address("0x...");
typeof addr; // "object" (wrapper overhead)
JSON.stringify(addr); // Needs custom serialization
```

</TabItem>
</Tabs>

## Dual API Pattern

Every primitive has two APIs:

<Tabs syncKey="api-style">
<TabItem label="Class API">

```typescript
import { Address } from "@tevm/voltaire";

const addr = new Address("0x...");
addr.toHex();
addr.toChecksummed();
addr.equals(other);
```

**When to use:**
- OOP patterns familiar
- Method chaining preferred
- Bundle size not critical
- Prototyping

</TabItem>
<TabItem label="Branded Types">

```typescript
import { BrandedAddress } from "@tevm/voltaire/Address";

const addr = BrandedAddress.fromHex("0x...");
BrandedAddress.toHex(addr);
BrandedAddress.toChecksummed(addr);
BrandedAddress.equals(addr, other);
```

**When to use:**
- Tree-shaking required
- Zero overhead critical
- Maximum performance
- Library development

</TabItem>
</Tabs>

**Mix and match:**
```typescript
import { Address } from "@tevm/voltaire";
import { BrandedAddress } from "@tevm/voltaire/Address";

const addr1 = new Address("0x...");
const addr2 = BrandedAddress.fromHex("0x...");

addr1.equals(addr2); // ✅ Works
BrandedAddress.equals(addr1, addr2); // ✅ Works
```

## Method Naming Convention

Universal naming patterns across all types:

### Construction

| Pattern | Purpose | Example |
|---------|---------|---------|
| `Type.from(value)` | Universal constructor (multiple formats) | `Address.from("0x...")` |
| `Type.fromHex(hex)` | From hex string | `Hash.fromHex("0x...")` |
| `Type.fromBytes(bytes)` | From byte array | `Uint.fromBytes(bytes)` |
| `Type.fromNumber(n)` | From number/bigint | `Uint.fromNumber(42n)` |
| `Type.zero()` | Zero value | `Address.zero()` |

### Conversion

| Pattern | Purpose | Example |
|---------|---------|---------|
| `Type.toHex(value)` | To hex string | `Address.toHex(addr)` |
| `Type.toBytes(value)` | To byte array | `Uint.toBytes(u)` |
| `Type.toNumber(value)` | To number/bigint | `Uint.toNumber(u)` |
| `Type.toChecksummed(value)` | EIP-55 checksummed hex | `Address.toChecksummed(addr)` |

### Validation

| Pattern | Purpose | Example |
|---------|---------|---------|
| `Type.isValid(value)` | Check if value valid | `Address.isValid(addr)` |
| `Type.is(value)` | Type guard | `Address.is(value)` |
| `Type.isZero(value)` | Check if zero | `Hash.isZero(hash)` |

### Comparison

| Pattern | Purpose | Example |
|---------|---------|---------|
| `Type.equals(a, b)` | Equality check | `Address.equals(a, b)` |
| `Type.compare(a, b)` | Comparison for sorting | `Uint.compare(a, b)` |
| `Type.greaterThan(a, b)` | Greater than | `Uint.greaterThan(a, b)` |
| `Type.lessThan(a, b)` | Less than | `Uint.lessThan(a, b)` |

## Tree-Shaking First

Import only what you need. Unused methods excluded from bundle.

```typescript
// Only bundles fromHex and toChecksummed
import { fromHex, toChecksummed } from "@tevm/voltaire/BrandedAddress";

const addr = fromHex("0x...");
const checksum = toChecksummed(addr);
```

**Bundle impact comparison:**

| Library | Import Method | Bundle Size (gzipped) |
|---------|--------------|----------------------|
| **Voltaire** | `Address.fromHex` only | 0.5 KB |
| **Voltaire** | + `toChecksummed` | 2.8 KB (includes keccak256) |
| **Voltaire** | Full `Address` class | 4.2 KB |
| **ethers.js** | `getAddress` | 86 KB (entire ethers) |
| **viem** | `getAddress` | 12 KB (tree-shakeable) |
| **web3.js** | `toChecksumAddress` | 156 KB (entire web3) |

Voltaire is **3-30x smaller** than alternatives for common operations.

See [WASM](/wasm/) for performance optimization and [Performance](/performance/) for detailed comparisons.

## Branded Types

Compile-time type safety with zero runtime overhead:

```typescript
type BrandedAddress = Uint8Array & { readonly __tag: "Address" };
type BrandedHash = Uint8Array & { readonly __brand: symbol };
type BrandedUint = bigint & { readonly __brand: symbol };
```

**Prevents mistakes:**
```typescript
function sendEther(to: BrandedAddress, amount: BrandedUint) {
  // TypeScript ensures correct types
}

const addr = Address.from("0x...");
const hash = Keccak256.hash(data);
const amount = Uint.from(100n);

sendEther(addr, amount);  // ✅ OK
sendEther(hash, amount);  // ❌ Type error (Hash not Address)
sendEther(addr, 100n);    // ❌ Type error (bigint not BrandedUint)
```

**Runtime:**
```javascript
// Brands don't exist at runtime
const addr = Address.from("0x...");
addr instanceof Uint8Array; // true
addr.__tag; // undefined (TypeScript only)
```

Learn more: [Branded Types](/primitives/branded-types/)

## Multi-Language Support

TypeScript and Zig implementations, same API:

<Tabs>
<TabItem label="TypeScript">

```typescript
import { Address } from "@tevm/voltaire";

const addr = Address.fromHex("0xa0cf798816d4b9b9866b5330eea46a18382f251e");
const checksum = addr.toChecksummed();
```

**WASM-accelerated:**
```typescript
import { Keccak256Wasm } from "@tevm/voltaire/crypto/keccak256.wasm";

await Keccak256Wasm.init();
const hash = Keccak256Wasm.hash(data);
```

</TabItem>
<TabItem label="Zig">

```zig
const voltaire = @import("primitives");

const addr = try voltaire.Address.fromHex("0xa0cf798816d4b9b9866b5330eea46a18382f251e");
const checksum = try addr.toChecksummed(allocator);
```

**Native performance:**
```zig
const keccak = @import("crypto").Keccak256;

var hash: [32]u8 = undefined;
keccak.hash(data, &hash, .{});
```

</TabItem>
</Tabs>

## Project Structure

<FileTree>

- src/
  - primitives/ (23 primitives)
    - Address/
      - Address.ts (Class API)
      - BrandedAddress.ts (Type definition)
      - from.js (Constructor)
      - toHex.js (Internal method)
      - toChecksummed.js (Internal method)
      - index.ts (Dual exports)
      - address.zig (Native implementation)
      - Address.bench.ts (Benchmarks)
      - Address.test.ts (Tests)
      - index.mdx (Documentation)
    - Hash/
    - Uint/
    - Hex/
    - ... (19 more primitives)
  - crypto/ (13 crypto modules)
    - Keccak256/
    - Secp256k1/
    - Blake2/
    - ... (10 more)
  - precompiles/ (EVM precompiles)
  - wasm-loader/ (WASM infrastructure)
  - content/docs/ (Astro Starlight MDX)
- build.zig (Build system)
- Cargo.toml (Rust crypto dependencies)

</FileTree>

**Key patterns:**
- **Colocated docs**: `src/primitives/{Name}/index.mdx` symlinked to `src/content/docs/primitives/`
- **Dual implementations**: `.ts` (TypeScript) + `.zig` (native) + `.wasm.js` (WASM)
- **Module system**: `@import("primitives")`, `@import("crypto")`, `@import("precompiles")`

## Error Handling

<Tabs syncKey="api-style">
<TabItem label="TypeScript">

**Custom error classes:**
```typescript
import { InvalidAddressError } from "@tevm/voltaire/Address";

try {
  const addr = Address.fromHex("invalid");
} catch (err) {
  if (err instanceof InvalidAddressError) {
    console.error("Invalid address format");
  }
}
```

**Validation before construction:**
```typescript
if (Address.isValid(input)) {
  const addr = Address.from(input);
}
```

</TabItem>
<TabItem label="Zig">

**Error unions:**
```zig
const addr = voltaire.Address.fromHex(hex_str) catch |err| {
    switch (err) {
        error.InvalidHexFormat => std.debug.print("Invalid hex\n", .{}),
        error.InvalidLength => std.debug.print("Wrong length\n", .{}),
        else => return err,
    }
};
```

</TabItem>
</Tabs>

## Performance Patterns

### Constant-Time Operations

Security-critical comparisons use constant-time algorithms:

```typescript
// Constant-time equality (safe)
Hash.equals(hash1, hash2);

// Early-return comparison (UNSAFE - timing leak)
for (let i = 0; i < 32; i++) {
  if (hash1[i] !== hash2[i]) return false; // ❌ Timing leak
}
```

### Reuse Buffers

```typescript
// Allocate once
const buffer = new Uint8Array(32);

// Reuse for multiple operations
Keccak256.hashInto(data1, buffer);
Keccak256.hashInto(data2, buffer);
```

### WASM Acceleration

Use WASM for compute-intensive operations:

```typescript
import { Keccak256Wasm } from "@tevm/voltaire/crypto/keccak256.wasm";

// Init once
await Keccak256Wasm.init();

// 2-3x faster than pure JS
const hash = Keccak256Wasm.hash(data);
```

See [WASM](/wasm/) for details.

## Comparison with Alternatives

<Tabs>
<TabItem label="vs ethers.js">

| Feature | Voltaire | ethers.js |
|---------|----------|-----------|
| **Bundle size** | 0.5-4 KB | 86 KB |
| **Tree-shaking** | Full (method-level) | Limited |
| **Type safety** | Branded types | String types |
| **Performance** | WASM-accelerated | Pure JS |
| **API style** | Namespace + Class | Class-only |
| **WASM support** | Built-in | None |
| **Browser support** | Modern browsers | IE11+ |

</TabItem>
<TabItem label="vs viem">

| Feature | Voltaire | viem |
|---------|----------|------|
| **Bundle size** | 0.5-4 KB | 12-18 KB |
| **Tree-shaking** | Full (method-level) | Full (module-level) |
| **Type safety** | Branded types | Template literals |
| **Performance** | WASM-accelerated | Pure JS |
| **API style** | Namespace + Class | Function-based |
| **WASM support** | Built-in | None |
| **Zig bindings** | Native FFI | None |

</TabItem>
<TabItem label="vs web3.js">

| Feature | Voltaire | web3.js |
|---------|----------|---------|
| **Bundle size** | 0.5-4 KB | 156 KB |
| **Tree-shaking** | Full | Minimal |
| **Type safety** | Branded types | Basic types |
| **Performance** | WASM-accelerated | Pure JS |
| **API style** | Namespace + Class | Class + Utilities |
| **WASM support** | Built-in | None |
| **Architecture** | Multi-language | JavaScript-only |

</TabItem>
</Tabs>

**When to use Voltaire:**
- Building performance-critical dApps
- Need minimal bundle sizes
- Want compile-time type safety
- Developing libraries (tree-shakeable)
- Running in Bun/Node with native FFI

**When to use alternatives:**
- Need IE11 support (ethers.js)
- Prefer function-based APIs (viem)
- Already heavily invested in ecosystem

## Related Documentation

<CardGrid>
  <Card title="Getting Started" icon="rocket">
    Installation, quick examples, core architecture.

    [View →](/getting-started/)
  </Card>

  <Card title="Architecture" icon="seti:config">
    Deep dive into multi-language stack.

    [View →](/architecture/)
  </Card>

  <Card title="WASM Acceleration" icon="star">
    High-performance WASM variants.

    [View →](/wasm/)
  </Card>

  <Card title="Performance" icon="random">
    Comprehensive benchmarks and comparisons.

    [View →](/performance/)
  </Card>

  <Card title="Branded Types" icon="document">
    Type safety pattern explained.

    [View →](/primitives/branded-types/)
  </Card>
</CardGrid>
