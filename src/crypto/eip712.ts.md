# Code Review: eip712.ts

## 1. Overview

This file implements EIP-712 typed structured data hashing and signing in TypeScript. It provides a pure TypeScript implementation of the EIP-712 specification for encoding types, hashing domains, hashing structs, and hashing complete typed data. However, signing and verification operations are stubs that throw errors.

## 2. Code Quality

### Strengths
- **Comprehensive documentation**: Good JSDoc comments on all exported functions
- **Type safety**: Strong TypeScript types for typed data structures
- **Pure TypeScript implementation**: Doesn't rely on FFI for core hashing logic
- **Proper type encoding**: Implements dependency tracking and alphabetical sorting
- **Handles complex cases**: Arrays, nested structs, multiple data types

### Issues

1. **Stub implementations violate CLAUDE.md** (Lines 246-289):
   ```typescript
   export function signTypedData(...): Signature {
       throw new Error("signTypedData not yet implemented - requires secp256k1 C API bindings");
   }
   ```
   CLAUDE.md explicitly bans stubs:
   > ❌ Stub implementations (`error.NotImplemented`)
   > **STOP and ask for help rather than stubbing.**

2. **Type encoding algorithm may not match spec** (Lines 47-76):
   - Uses Set for dependency tracking, then converts to Array and sorts
   - The EIP-712 spec requires alphabetical ordering of dependent types
   - This looks correct, but needs verification against spec test vectors

3. **Incomplete array handling in encodeValue** (Lines 103-110):
   ```typescript
   if (type.endsWith("[]")) {
       const baseType = type.slice(0, -2);
       const encodedArray = (value as unknown[])
           .map((item) => encodeValue(baseType, item, types))
           .join("");
       return keccak256(encodedArray);
   }
   ```
   - This handles dynamic arrays but doesn't handle fixed-size arrays `type[N]`
   - Should validate that value is actually an array

4. **String encoding may be incorrect** (Lines 113-122):
   ```typescript
   if (type === "string") {
       const encoder = new TextEncoder();
       const bytes = encoder.encode(value as string);
       const hexString = `0x${Array.from(bytes)
           .map((b) => b.toString(16).padStart(2, "0"))
           .join("")}`;
       return keccak256(hexString);
   }
   ```
   - Encodes string to UTF-8 bytes, then to hex, then hashes
   - Per EIP-712 spec, strings should be hashed directly: `keccak256(bytes(value))`
   - The intermediate hex conversion may be unnecessary/incorrect

5. **No input validation**:
   - Doesn't validate that types object is well-formed
   - Doesn't validate that primaryType exists in types
   - Doesn't validate that all referenced types exist
   - Doesn't validate that values match their declared types

6. **Type casting instead of validation** (Lines 105, 115, 143, etc.):
   - Uses `as unknown[]`, `as string`, `as number` without validation
   - Could fail silently with wrong types
   - Should validate types match before casting

7. **Duplicate type definitions** (Lines 13-19):
   - Same types defined in eip191.ts
   - Should be in shared types file

8. **No recursion depth limiting**:
   - Deeply nested types could cause stack overflow
   - No protection against malicious inputs

## 3. Completeness

### Implemented
- ✅ Type encoding with dependency tracking and sorting
- ✅ Domain separator hashing
- ✅ Struct hashing
- ✅ Complete typed data hashing
- ✅ Value encoding for most types (string, bytes, bytes32, address, numbers, bool, custom types)
- ✅ Array encoding (dynamic arrays only)

### Missing/Incomplete
- ❌ **signTypedData**: Stub implementation throws error
- ❌ **verifyTypedData**: Stub implementation throws error
- ❌ **recoverTypedDataAddress**: Stub implementation throws error
- ⚠️ **Fixed-size array encoding**: Not implemented (e.g., `uint256[5]`)
- ⚠️ **Type validation**: No validation of type definitions
- ⚠️ **Value validation**: No validation that values match types

## 4. Test Coverage

Looking at eip712.test.ts:

### Test Strengths
- ✅ Comprehensive hashing tests (40+ test cases)
- ✅ Domain hashing tested with various field combinations
- ✅ Nested structures tested (Person, Mail, Address)
- ✅ Multiple data types tested (string, address, uint256, bool, bytes)
- ✅ Edge cases tested (empty strings, zero values, large numbers)
- ✅ Determinism tested
- ✅ Different messages produce different hashes
- ✅ Array handling tested
- ✅ Multiple levels of nesting tested

### Test Gaps
- ❌ **No EIP-712 specification test vectors**: Should include official examples
- ❌ **No cross-validation**: Not compared against ethers.js, viem, or other implementations
- ❌ **No signing/verification tests** (can't test stubs)
- ❌ **No malicious input tests**:
  - Circular type references
  - Extremely deep nesting
  - Type name collisions
  - Malformed type strings
- ❌ **No fixed-size array tests** (because not implemented)
- ❌ **No validation error tests** (because no validation)

## 5. Issues Found

### Critical Issues

1. **Stub implementations violate project requirements** (Lines 246-289)
   - **Severity**: CRITICAL (violates CLAUDE.md)
   - **Impact**: User confusion, project standard violation
   - **Fix**: Remove stubs or implement fully
   - **Rationale**: CLAUDE.md explicitly forbids stub implementations

2. **String encoding may not match EIP-712 spec** (Lines 113-122)
   - **Severity**: CRITICAL (potential spec violation)
   - **Impact**: Incompatible hashes with other implementations
   - **Fix**: Verify against EIP-712 spec and test vectors
   - **Concern**: The hex conversion step may be wrong

### High Priority Issues

3. **No type validation** (Throughout)
   - **Severity**: HIGH
   - **Impact**: Runtime errors, silent failures, security issues
   - **Fix**: Add validation for:
     - Type definitions are well-formed
     - Primary type exists
     - All referenced types exist
     - Values match their declared types
   - **Example**:
   ```typescript
   function validateTypedData(typedData: TypedData): void {
       if (!typedData.types[typedData.primaryType]) {
           throw new Error(`Primary type "${typedData.primaryType}" not found in types`);
       }
       // Validate all type references exist...
   }
   ```

4. **No cross-validation with other implementations** (Testing)
   - **Severity**: HIGH
   - **Impact**: May not be EIP-712 compliant
   - **Fix**: Add tests comparing output with ethers.js or viem
   - **Rationale**: Pure TS implementation needs validation

5. **Fixed-size arrays not supported** (Lines 103-110)
   - **Severity**: HIGH
   - **Impact**: Incomplete EIP-712 implementation
   - **Fix**: Add support for `type[N]` syntax
   ```typescript
   // Match both type[] and type[N]
   const arrayMatch = type.match(/^(.+?)(\[(\d+)?\])$/);
   if (arrayMatch) {
       const baseType = arrayMatch[1];
       const size = arrayMatch[3] ? parseInt(arrayMatch[3]) : undefined;
       // Handle fixed or dynamic array...
   }
   ```

### Medium Priority Issues

6. **Unsafe type casting** (Lines 105, 115, 143, etc.)
   - **Severity**: MEDIUM
   - **Impact**: Could crash with wrong input types
   - **Fix**: Validate types before casting
   ```typescript
   if (type === "string") {
       if (typeof value !== "string") {
           throw new Error(`Expected string but got ${typeof value}`);
       }
       // ... encode string
   }
   ```

7. **No recursion depth limiting** (Lines 47-76, 167-179)
   - **Severity**: MEDIUM
   - **Impact**: Stack overflow with deeply nested types
   - **Fix**: Add max depth parameter
   ```typescript
   function hashStruct(
       primaryType: string,
       data: Record<string, unknown>,
       types: Record<string, TypedDataField[]>,
       depth = 0,
   ): Hex {
       if (depth > 32) {
           throw new Error("Maximum nesting depth exceeded");
       }
       // ... rest with depth + 1 for recursive calls
   }
   ```

8. **Duplicate type definitions** (Lines 13-19)
   - **Severity**: MEDIUM
   - **Impact**: Maintenance burden
   - **Fix**: Extract to shared types.ts

9. **No maximum message size** (Throughout)
   - **Severity**: MEDIUM
   - **Impact**: DoS potential with huge messages
   - **Fix**: Add reasonable limits

### Low Priority Issues

10. **Domain type building is repetitive** (Lines 186-214)
    - **Severity**: LOW
    - **Impact**: Code maintenance
    - **Fix**: Could be refactored to be more DRY

11. **No caching of type hashes** (Line 172)
    - **Severity**: LOW
    - **Impact**: Performance with repeated types
    - **Fix**: Consider caching type hashes

## 6. Recommendations

### Critical Priority (Must Fix)

1. **Remove or implement stub functions** (CRITICAL)
   - **Options**:
     - A) Remove signTypedData, verifyTypedData, recoverTypedDataAddress
     - B) Implement via secp256k1 FFI bindings (like eip191.ts should do)
     - C) Move to separate WIP file
   - **Recommendation**: Option A until ready to implement
   - **Rationale**: Violates CLAUDE.md requirements

2. **Verify string encoding against EIP-712 spec** (CRITICAL)
   - **Action**: Compare with spec section 2.2.2
   - **Test**: Use official EIP-712 test vectors
   - **Fix if wrong**: Remove intermediate hex conversion
   - **Expected**: `keccak256(utf8_bytes(value))` not `keccak256(hex(utf8_bytes(value)))`

### High Priority

3. **Add comprehensive validation** (HIGH)
   ```typescript
   function validateTypedData(typedData: TypedData): void {
       // Check primary type exists
       if (!typedData.types[typedData.primaryType]) {
           throw new Error(`Primary type "${typedData.primaryType}" not found`);
       }

       // Check all type references are valid
       for (const [typeName, fields] of Object.entries(typedData.types)) {
           for (const field of fields) {
               const baseType = field.type.replace(/\[\d*\]$/, '');
               if (!isBuiltinType(baseType) && !typedData.types[baseType]) {
                   throw new Error(`Type "${baseType}" referenced but not defined`);
               }
           }
       }

       // Validate message matches primary type
       validateValue(typedData.message, typedData.types[typedData.primaryType], typedData.types);
   }
   ```

4. **Add EIP-712 specification test vectors** (HIGH)
   - Use official examples from EIP-712
   - Cross-validate with ethers.js or viem
   - Add to eip712.test.ts
   ```typescript
   test("EIP-712 specification example (validated)", () => {
       const typedData = /* example from spec */;
       const hash = hashTypedData(typedData);
       // Compare with known-good hash from spec or other implementation
       expect(hash).toBe("0x...known-good-hash...");
   });
   ```

5. **Implement fixed-size arrays** (HIGH)
   ```typescript
   function encodeValue(type: string, value: unknown, types: Record<string, TypedDataField[]>): Hex {
       // Handle arrays (both dynamic and fixed-size)
       const arrayMatch = type.match(/^(.+?)(\[(\d+)?\])$/);
       if (arrayMatch) {
           const baseType = arrayMatch[1];
           const fixedSize = arrayMatch[3] ? parseInt(arrayMatch[3]) : undefined;

           if (!Array.isArray(value)) {
               throw new Error(`Expected array for type ${type}`);
           }

           if (fixedSize !== undefined && value.length !== fixedSize) {
               throw new Error(`Expected array of length ${fixedSize}, got ${value.length}`);
           }

           const encodedArray = value
               .map((item) => encodeValue(baseType, item, types))
               .join("");
           return keccak256(encodedArray);
       }

       // ... rest of encoding
   }
   ```

### Medium Priority

6. **Add type validation before casting** (MEDIUM)
   - Validate values match their declared types
   - Throw descriptive errors on mismatch
   - Prevents silent failures

7. **Add recursion depth limiting** (MEDIUM)
   - Prevent stack overflow attacks
   - Maximum depth: 32 levels
   - Throw error if exceeded

8. **Share type definitions** (MEDIUM)
   - Create src/crypto/types.ts
   - Import in eip191.ts and eip712.ts
   - Prevents duplication and drift

9. **Add size limits** (MEDIUM)
   - Maximum message fields: 1000
   - Maximum type definitions: 100
   - Maximum nesting depth: 32
   - Maximum string length: 1MB

### Low Priority

10. **Consider performance optimizations** (LOW)
    - Cache type hashes
    - Reuse encoded values
    - Profile and optimize hot paths

11. **Improve error messages** (LOW)
    - Include context in errors
    - Suggest fixes
    - Make debugging easier

## 7. EIP-712 Compliance

### Specification Adherence
- ✅ Type encoding with dependency sorting
- ✅ Domain separator format
- ✅ Struct hash format
- ✅ Final hash format: `keccak256("\x19\x01" ‖ domainSeparator ‖ hashStruct(message))`
- ⚠️ String encoding needs verification
- ⚠️ Dynamic arrays supported
- ❌ Fixed-size arrays not supported
- ❌ Signing not implemented (stub)
- ❌ Verification not implemented (stub)

### Security Considerations
- ⚠️ No input validation (could crash with malicious input)
- ⚠️ No recursion limits (stack overflow potential)
- ⚠️ No size limits (DoS potential)
- ❌ Incomplete without signing/verification

## Summary

This is a **comprehensive pure TypeScript implementation** of EIP-712 hashing with good structure and test coverage. However, it has several critical issues:

**Critical Issues:**
1. **Stub implementations violate CLAUDE.md** - must be removed or implemented
2. **String encoding needs verification** - may not match EIP-712 spec
3. **No validation** - could fail with invalid inputs

**Missing Features:**
- Signing and verification (stubs only)
- Fixed-size array support
- Input validation
- Recursion/size limits

**Positive Aspects:**
- Clean, readable TypeScript implementation
- Good type safety
- Comprehensive test suite for hashing
- Handles nested structures
- Proper type dependency sorting

**Current State:** The hashing implementation appears mostly correct and well-tested, but lacks the signing/verification components needed for production use. The string encoding needs verification against the spec. Input validation is completely missing.

**Overall Grade: C+** (Good hashing implementation, but incomplete and has compliance concerns)

**Must-Do Actions:**
1. Remove stub implementations (violates CLAUDE.md)
2. Verify string encoding against EIP-712 specification
3. Add comprehensive input validation
4. Add official test vectors from EIP-712 spec
5. Either implement signing/verification OR clearly document this is hashing-only
