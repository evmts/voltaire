# Code Review: eip191.ts

## 1. Overview

This file implements EIP-191 (Signed Data Standard) personal message signing in TypeScript. It provides FFI bindings to the Zig/C implementation of EIP-191 message hashing, with stub implementations for signing and verification operations.

## 2. Code Quality

### Strengths
- **Clear documentation**: Good JSDoc comments explaining function purposes
- **Type safety**: Uses TypeScript types (Hex, Address, Signature)
- **FFI integration**: Properly uses Bun's FFI to call C functions
- **Error handling**: Checks return codes and throws descriptive errors
- **Empty message handling**: Handles edge case of empty messages (line 48)

### Issues

1. **Stub implementations violate CLAUDE.md** (Lines 87-130):
   ```typescript
   export function signMessage(...): Signature {
       throw new Error("signMessage not yet implemented - requires secp256k1 C API bindings");
   }
   ```
   This is an explicit placeholder/stub. CLAUDE.md states:
   > ❌ Stub implementations (`error.NotImplemented`)
   > ❌ Any stub/fallback implementations
   > **STOP and ask for help rather than stubbing.**

   **Impact**: Users may attempt to use these functions and get runtime errors
   **Fix**: Either implement the functions or remove them entirely until ready

2. **Inconsistent error messages** (Lines 62, 71):
   - `EIP-191 hash failed with error code: ${result}`
   - `Hash to hex conversion failed with error code: ${hexResult}`
   - Error codes are not documented anywhere
   - Users won't know what the codes mean

3. **No input validation** (Line 42-49):
   - Doesn't validate that `message` is a valid string/Uint8Array
   - Doesn't handle null/undefined inputs
   - Could crash FFI layer with invalid inputs

4. **Hardcoded buffer size** (Line 66):
   ```typescript
   const hexBuffer = new Uint8Array(66); // "0x" + 64 hex chars
   ```
   Magic number should be documented or use a constant

5. **Memory safety concern** (Line 48-49):
   ```typescript
   const messageBytes = bytes.length === 0 ? new Uint8Array(1) : bytes;
   const messageLength = bytes.length; // Use original length
   ```
   This passes a dummy byte to FFI when message is empty, but uses length 0. While clever, this could be fragile if C implementation changes.

6. **Type definitions could be shared** (Lines 28-34):
   Same type definitions appear in eip712.ts. Should be in a shared types file to avoid duplication and drift.

## 3. Completeness

### Implemented
- ✅ Message hashing (hashMessage)
- ✅ FFI bindings for hash operations
- ✅ Type definitions for signatures and addresses

### Missing/Incomplete (Stubs)
- ❌ **signMessage**: Throws error, not implemented
- ❌ **verifyMessage**: Throws error, not implemented
- ❌ **recoverMessageAddress**: Throws error, not implemented

### Why This Matters
EIP-191 is primarily used for signing human-readable messages. Without signing and verification, the implementation is incomplete and not useful for real applications. The hashing function alone is not sufficient.

## 4. Test Coverage

Looking at eip191.test.ts:

### Test Strengths
- ✅ Basic hashing tested
- ✅ String and Uint8Array inputs tested
- ✅ Unicode character handling tested
- ✅ Determinism tested
- ✅ Has expected hash values for validation

### Test Gaps
- ❌ **No tests for signing/verification** (can't test stubs)
- ❌ **No error case tests** (invalid inputs, null, undefined)
- ❌ **No edge case tests**:
  - Very long messages (MB+ size)
  - Binary data with null bytes
  - Invalid UTF-8 sequences
- ❌ **No cross-validation** with other implementations (ethers.js, viem)
- ❌ **No test vectors from EIP-191 specification**

## 5. Issues Found

### Critical Issues

1. **Stub implementations violate project requirements** (Lines 87-130)
   - **Severity**: CRITICAL (violates CLAUDE.md)
   - **Impact**: User confusion, potential misuse, violates project standards
   - **Fix**: Remove stub functions or implement them fully
   - **Rationale**: CLAUDE.md explicitly bans stubs/placeholders

### High Priority Issues

2. **No input validation** (Line 42):
   - **Severity**: HIGH
   - **Impact**: Could crash with invalid inputs, FFI safety issue
   - **Fix**: Validate inputs before FFI call
   ```typescript
   if (message === null || message === undefined) {
       throw new Error("Message cannot be null or undefined");
   }
   ```

3. **Missing signing and verification** (Lines 87-130):
   - **Severity**: HIGH
   - **Impact**: EIP-191 is incomplete without these core functions
   - **Fix**: Implement C API bindings for secp256k1 operations
   - **Note**: This makes the module nearly useless for real applications

### Medium Priority Issues

4. **Duplicate type definitions** (Lines 28-34):
   - **Severity**: MEDIUM
   - **Impact**: Maintenance burden, potential for drift
   - **Fix**: Create shared types.ts file
   ```typescript
   export type { Hex, Address, Signature } from './types.ts';
   ```

5. **Undocumented error codes** (Lines 62, 71):
   - **Severity**: MEDIUM
   - **Impact**: Users can't diagnose errors
   - **Fix**: Document error codes or use descriptive C error messages

6. **No maximum message size** (Line 42):
   - **Severity**: MEDIUM
   - **Impact**: Could allocate huge buffers, DoS potential
   - **Fix**: Add reasonable size limit (e.g., 1MB)

### Low Priority Issues

7. **Magic numbers** (Line 66):
   - **Severity**: LOW
   - **Impact**: Code readability
   - **Fix**: Use named constants

8. **Empty message workaround is fragile** (Line 48):
   - **Severity**: LOW
   - **Impact**: Could break if C implementation changes
   - **Fix**: Properly handle empty messages in C layer

## 6. Recommendations

### Critical Priority (Must Fix)

1. **Remove or implement stub functions** (CRITICAL)
   - **Options**:
     - A) Remove signMessage, verifyMessage, recoverMessageAddress entirely
     - B) Implement them by adding secp256k1 C FFI bindings
     - C) Move to separate file with clear "WIP" naming
   - **Recommendation**: Option A (remove) until ready to implement
   - **Rationale**: Violates CLAUDE.md, misleading to users

### High Priority

2. **Add input validation** (HIGH)
   ```typescript
   export function hashMessage(message: string | Uint8Array): Hex {
       if (message === null || message === undefined) {
           throw new Error("Message cannot be null or undefined");
       }

       // Convert string to bytes
       const bytes = typeof message === "string"
           ? new TextEncoder().encode(message)
           : message;

       // Enforce maximum message size (1MB)
       if (bytes.length > 1024 * 1024) {
           throw new Error("Message too large (max 1MB)");
       }

       // ... rest of implementation
   }
   ```

3. **Implement signing and verification** (HIGH)
   - This is core EIP-191 functionality
   - Requires adding C API bindings for:
     - `primitives_sign_message`
     - `primitives_verify_message`
     - `primitives_recover_address`
   - See crypto.zig for Zig implementations to expose

### Medium Priority

4. **Share type definitions** (MEDIUM)
   - Create `src/crypto/types.ts`:
   ```typescript
   export type Hex = `0x${string}`;
   export type Address = `0x${string}`;
   export type Signature = {
       r: Hex;
       s: Hex;
       v: number;
   };
   ```
   - Import in both eip191.ts and eip712.ts

5. **Document error codes** (MEDIUM)
   - Add comments explaining what each error code means
   - Or modify C API to return error strings

6. **Add comprehensive tests** (MEDIUM)
   - Test invalid inputs (null, undefined, wrong types)
   - Test very long messages
   - Test binary data with null bytes
   - Add EIP-191 specification test vectors
   - Cross-validate with ethers.js or viem

### Low Priority

7. **Use named constants** (LOW)
   ```typescript
   const HEX_PREFIX_LENGTH = 2; // "0x"
   const HASH_HEX_LENGTH = 64;  // 32 bytes = 64 hex chars
   const hexBuffer = new Uint8Array(HEX_PREFIX_LENGTH + HASH_HEX_LENGTH);
   ```

8. **Improve empty message handling** (LOW)
   - Fix in C implementation to accept null pointer with 0 length
   - Remove workaround in TypeScript

## 7. EIP-191 Compliance

### Specification Adherence
- ✅ **Message format**: Correctly implements `"\x19Ethereum Signed Message:\n" + len(message) + message`
- ✅ **Hashing**: Uses Keccak-256 (via C implementation)
- ❌ **Signing**: Not implemented (stub)
- ❌ **Verification**: Not implemented (stub)
- ❌ **Recovery**: Not implemented (stub)

### Security Considerations
- ⚠️ **No input size limits**: Could lead to DoS
- ⚠️ **No validation**: Accepts any input without checking
- ❌ **Incomplete implementation**: Cannot be used for real signing/verification

## Summary

This implementation provides EIP-191 message hashing via FFI to a C/Zig implementation, but is **incomplete and violates project requirements**:

**Critical Issues:**
1. **Stub implementations violate CLAUDE.md** - must be removed or implemented
2. **No signing/verification** - module is essentially unusable for real applications
3. **No input validation** - security and safety concern

**Positive Aspects:**
- Clean FFI integration
- Proper error handling for implemented functions
- Good test coverage for hashing
- Type safety with TypeScript

**Current State:** The module can hash messages per EIP-191, but cannot sign or verify them. This makes it incomplete for production use. The stub implementations violate project requirements and should be removed until they can be properly implemented.

**Overall Grade: D** (Hashing works, but incomplete implementation and project requirement violations)

**Must-Do Actions:**
1. Remove stub implementations (violates CLAUDE.md)
2. Add input validation
3. Either:
   - Implement full EIP-191 signing/verification, OR
   - Document that only hashing is currently supported
