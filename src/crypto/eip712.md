# EIP-712: Typed Structured Data Signing

Complete TypeScript implementation of [EIP-712](https://eips.ethereum.org/EIPS/eip-712) typed structured data hashing and signing.

## Overview

EIP-712 is a standard for hashing and signing typed structured data. It provides a secure way for users to sign complex data structures in a human-readable format, enabling features like:

- Gas-free meta-transactions
- ERC-2612 Permit tokens (gasless approvals)
- DAO voting signatures
- NFT minting signatures
- DeFi protocol interactions

## Features

- **Complete EIP-712 Compliance**: Full implementation of the EIP-712 specification
- **Type Safety**: TypeScript types with full inference
- **Noble Libraries**: Uses `@noble/curves` and `@noble/hashes` for cryptographic operations
- **Zero Dependencies**: Pure TypeScript with minimal external dependencies
- **Comprehensive**: Supports all Solidity types including nested structs and arrays
- **Performance**: Optimized encoding and hashing

## Installation

```typescript
import { Eip712 } from '@tevm/voltaire';
```

## Core Concepts

### Domain Separator

The domain separator is a unique identifier for your application that prevents replay attacks across different contexts:

```typescript
const domain: Eip712.Domain = {
  name: 'MyApp',              // Application name
  version: '1',               // Version string
  chainId: 1n,                // Chain ID (mainnet = 1)
  verifyingContract: address, // Contract address
  salt: hash,                 // Optional salt for uniqueness
};
```

### Type Definitions

Define the structure of your data using Solidity-style types:

```typescript
const types: Eip712.TypeDefinitions = {
  Person: [
    { name: 'name', type: 'string' },
    { name: 'wallet', type: 'address' },
  ],
  Mail: [
    { name: 'from', type: 'Person' },
    { name: 'to', type: 'Person' },
    { name: 'contents', type: 'string' },
  ],
};
```

### Typed Data

Combine domain, types, and message into a complete typed data structure:

```typescript
const typedData: Eip712.TypedData = {
  domain,
  types,
  primaryType: 'Mail',
  message: {
    from: { name: 'Alice', wallet: aliceAddress },
    to: { name: 'Bob', wallet: bobAddress },
    contents: 'Hello!',
  },
};
```

## API Reference

### Domain Operations

#### `Eip712.Domain.hash(domain: Domain): Hash`

Hash the domain separator according to EIP-712.

```typescript
const domainHash = Eip712.Domain.hash({
  name: 'MyApp',
  version: '1',
  chainId: 1n,
});
```

### Type Operations

#### `Eip712.encodeType(primaryType: string, types: TypeDefinitions): string`

Encode type string for EIP-712 (e.g., `"Mail(Person from,Person to,string contents)Person(string name,address wallet)"`).

```typescript
const typeString = Eip712.encodeType('Mail', types);
// "Mail(Person from,Person to,string contents)Person(string name,address wallet)"
```

#### `Eip712.hashType(primaryType: string, types: TypeDefinitions): Hash`

Hash the encoded type string.

```typescript
const typeHash = Eip712.hashType('Mail', types);
```

### Value Operations

#### `Eip712.encodeValue(type: string, value: MessageValue, types: TypeDefinitions): Uint8Array`

Encode a single value to 32 bytes according to EIP-712.

```typescript
const encoded = Eip712.encodeValue('uint256', 42n, types);
```

#### `Eip712.encodeData(primaryType: string, data: Message, types: TypeDefinitions): Uint8Array`

Encode struct data (type hash + encoded values).

```typescript
const encoded = Eip712.encodeData('Person', { name: 'Alice', wallet: address }, types);
```

#### `Eip712.hashStruct(primaryType: string, data: Message, types: TypeDefinitions): Hash`

Hash a struct according to EIP-712.

```typescript
const hash = Eip712.hashStruct('Person', { name: 'Alice', wallet: address }, types);
```

### Main Operations

#### `Eip712.hashTypedData(typedData: TypedData): Hash`

Compute the EIP-712 hash: `keccak256("\x19\x01" ‖ domainSeparator ‖ hashStruct(message))`

```typescript
const hash = Eip712.hashTypedData(typedData);
```

#### `Eip712.signTypedData(typedData: TypedData, privateKey: Uint8Array): Signature`

Sign typed data with a private key.

```typescript
const signature = Eip712.signTypedData(typedData, privateKey);
// { r: Uint8Array, s: Uint8Array, v: number }
```

#### `Eip712.recoverAddress(signature: Signature, typedData: TypedData): Address`

Recover the signer's address from a signature.

```typescript
const address = Eip712.recoverAddress(signature, typedData);
```

#### `Eip712.verifyTypedData(signature: Signature, typedData: TypedData, address: Address): boolean`

Verify that a signature is valid for the given typed data and address.

```typescript
const valid = Eip712.verifyTypedData(signature, typedData, signerAddress);
```

### Utility Operations

#### `Eip712.validate(typedData: TypedData): void`

Validate typed data structure (throws on error).

```typescript
Eip712.validate(typedData); // Throws if invalid
```

#### `Eip712.format(typedData: TypedData): string`

Format typed data for human-readable display.

```typescript
const formatted = Eip712.format(typedData);
console.log(formatted);
```

## Usage Examples

### Basic Signing

```typescript
import { Eip712 } from '@tevm/voltaire';
import { Address } from '@tevm/voltaire';

// Define typed data
const typedData: Eip712.TypedData = {
  domain: {
    name: 'MyApp',
    version: '1',
    chainId: 1n,
  },
  types: {
    Message: [
      { name: 'content', type: 'string' },
    ],
  },
  primaryType: 'Message',
  message: {
    content: 'Hello, World!',
  },
};

// Sign
const signature = Eip712.signTypedData(typedData, privateKey);

// Verify
const address = Eip712.recoverAddress(signature, typedData);
const valid = Eip712.verifyTypedData(signature, typedData, address);
```

### ERC-2612 Permit (Gasless Approvals)

```typescript
const permitData: Eip712.TypedData = {
  domain: {
    name: 'USD Coin',
    version: '1',
    chainId: 1n,
    verifyingContract: usdcAddress,
  },
  types: {
    Permit: [
      { name: 'owner', type: 'address' },
      { name: 'spender', type: 'address' },
      { name: 'value', type: 'uint256' },
      { name: 'nonce', type: 'uint256' },
      { name: 'deadline', type: 'uint256' },
    ],
  },
  primaryType: 'Permit',
  message: {
    owner: ownerAddress,
    spender: spenderAddress,
    value: 1000000n, // 1 USDC
    nonce: 0n,
    deadline: 1700000000n,
  },
};

const signature = Eip712.signTypedData(permitData, privateKey);

// Submit to contract
await contract.permit(
  message.owner,
  message.spender,
  message.value,
  message.deadline,
  signature.v,
  signature.r,
  signature.s
);
```

### Meta-Transactions

```typescript
const metaTxData: Eip712.TypedData = {
  domain: {
    name: 'MinimalForwarder',
    version: '0.0.1',
    chainId: 1n,
    verifyingContract: forwarderAddress,
  },
  types: {
    ForwardRequest: [
      { name: 'from', type: 'address' },
      { name: 'to', type: 'address' },
      { name: 'value', type: 'uint256' },
      { name: 'gas', type: 'uint256' },
      { name: 'nonce', type: 'uint256' },
      { name: 'data', type: 'bytes' },
    ],
  },
  primaryType: 'ForwardRequest',
  message: {
    from: senderAddress,
    to: targetContract,
    value: 0n,
    gas: 100000n,
    nonce: 0n,
    data: calldata,
  },
};

const signature = Eip712.signTypedData(metaTxData, privateKey);

// Relayer submits transaction
await forwarder.execute(message, signature);
```

### DAO Voting

```typescript
const voteData: Eip712.TypedData = {
  domain: {
    name: 'MyDAO',
    version: '1',
    chainId: 1n,
    verifyingContract: daoAddress,
  },
  types: {
    Vote: [
      { name: 'proposalId', type: 'uint256' },
      { name: 'support', type: 'uint8' },
      { name: 'voter', type: 'address' },
      { name: 'nonce', type: 'uint256' },
    ],
  },
  primaryType: 'Vote',
  message: {
    proposalId: 42n,
    support: 1, // 0 = against, 1 = for, 2 = abstain
    voter: voterAddress,
    nonce: 0n,
  },
};

const signature = Eip712.signTypedData(voteData, privateKey);

// Submit vote signature
await dao.castVoteBySig(message, signature);
```

### NFT Minting Signature

```typescript
const mintData: Eip712.TypedData = {
  domain: {
    name: 'MyNFT',
    version: '1',
    chainId: 1n,
    verifyingContract: nftAddress,
  },
  types: {
    MintVoucher: [
      { name: 'tokenId', type: 'uint256' },
      { name: 'uri', type: 'string' },
      { name: 'minPrice', type: 'uint256' },
      { name: 'signature', type: 'bytes' },
    ],
  },
  primaryType: 'MintVoucher',
  message: {
    tokenId: 1n,
    uri: 'ipfs://...',
    minPrice: 1000000000000000000n, // 1 ETH
    signature: new Uint8Array(0), // Placeholder
  },
};

const signature = Eip712.signTypedData(mintData, privateKey);

// User can mint with signature
await nft.redeem(voucher, signature);
```

### Nested Struct Example

```typescript
const nestedData: Eip712.TypedData = {
  domain: {
    name: 'ComplexApp',
    version: '1',
    chainId: 1n,
  },
  types: {
    Asset: [
      { name: 'token', type: 'address' },
      { name: 'amount', type: 'uint256' },
    ],
    Order: [
      { name: 'maker', type: 'address' },
      { name: 'taker', type: 'address' },
      { name: 'makerAsset', type: 'Asset' },
      { name: 'takerAsset', type: 'Asset' },
      { name: 'salt', type: 'uint256' },
    ],
  },
  primaryType: 'Order',
  message: {
    maker: makerAddress,
    taker: takerAddress,
    makerAsset: {
      token: tokenAAddress,
      amount: 100n,
    },
    takerAsset: {
      token: tokenBAddress,
      amount: 200n,
    },
    salt: 12345n,
  },
};

const signature = Eip712.signTypedData(nestedData, privateKey);
```

## Supported Types

### Primitive Types

- `uint8` to `uint256` (in 8-bit increments)
- `int8` to `int256` (in 8-bit increments)
- `address` (20 bytes)
- `bool` (true/false)
- `bytes` (dynamic length)
- `bytes1` to `bytes32` (fixed length)
- `string` (UTF-8 encoded)

### Complex Types

- Arrays: `uint256[]`, `address[]`, etc.
- Nested structs: Custom types referencing other custom types
- Recursive types: Supported (e.g., linked lists, trees)

## Performance

Typical operation times on modern hardware:

| Operation | Time | Ops/sec |
|-----------|------|---------|
| Domain.hash | ~50μs | ~20,000 |
| hashTypedData (simple) | ~100μs | ~10,000 |
| hashTypedData (nested) | ~200μs | ~5,000 |
| signTypedData | ~500μs | ~2,000 |
| verifyTypedData | ~800μs | ~1,250 |
| sign + verify | ~1.3ms | ~770 |

*Run `bun run src/crypto/eip712.bench.ts` for detailed benchmarks on your system.*

## Security Considerations

1. **Private Key Management**: Never expose private keys. Use secure storage (hardware wallets, secure enclaves).

2. **Domain Separator**: Always use a unique domain separator to prevent replay attacks across different applications or chains.

3. **Type Verification**: Validate that the types match what you expect. Malicious applications can present different types to the user.

4. **Message Validation**: Always validate message contents match business logic requirements.

5. **Signature Replay**: Include nonces or timestamps to prevent signature replay attacks.

6. **Chain ID**: Always include chainId in domain to prevent cross-chain replay attacks.

7. **Contract Address**: Include verifyingContract address to bind signatures to specific contract instances.

## EIP-712 Specification

The EIP-712 hash is computed as:

```
keccak256("\x19\x01" ‖ domainSeparator ‖ hashStruct(message))
```

Where:
- `\x19\x01` is the EIP-191 version byte for structured data
- `domainSeparator` = `hashStruct(EIP712Domain, domain)`
- `hashStruct(typeName, data)` = `keccak256(typeHash ‖ encodeData(data))`
- `typeHash` = `keccak256(encodeType(typeName))`

## Testing

Run tests:
```bash
bun test src/crypto/eip712.test.ts
```

Run benchmarks:
```bash
bun run src/crypto/eip712.bench.ts
```

## References

- [EIP-712 Specification](https://eips.ethereum.org/EIPS/eip-712)
- [EIP-191: Signed Data Standard](https://eips.ethereum.org/EIPS/eip-191)
- [ERC-2612: Permit Extension](https://eips.ethereum.org/EIPS/eip-2612)
- [EIP-712 Guide by MetaMask](https://docs.metamask.io/guide/signing-data.html#sign-typed-data-v4)

## License

MIT
