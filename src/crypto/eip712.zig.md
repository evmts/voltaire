# Code Review: eip712.zig

## 1. Overview

This file implements EIP-712 typed structured data hashing and signing in Zig. It provides functionality to hash, sign, and verify typed data according to the EIP-712 specification. The implementation includes type definitions for domains, types, messages, and the core hashing/signing operations.

## 2. Code Quality

### Strengths
- **Comprehensive structure**: Well-organized with clear type definitions (Eip712Domain, TypeProperty, TypeDefinitions, MessageValue, TypedData)
- **Memory management**: Proper `deinit` functions for all complex types with cleanup logic
- **Error handling**: Comprehensive error types covering various failure modes (InvalidDomain, InvalidMessage, TypeNotFound, etc.)
- **Naming conventions**: Follows Zig conventions correctly (snake_case for functions, TitleCase for types)
- **Documentation**: All public functions are marked with unaudited warnings, which is appropriate for cryptographic code
- **Recursive handling**: Handles nested type structures and circular references

### Issues

1. **Memory leak in encode_type_recursive** (Line 229):
   ```zig
   try visited.put(try allocator.dupe(u8, type_name), {});
   ```
   The duplicated type_name is never freed. This creates a memory leak for every type visited.

2. **Incomplete MessageValue.deinit** (Line 110-130):
   The `.object` case properly frees keys and values, but the `.array` case doesn't clean up nested objects properly. Arrays of objects would leak memory.

3. **Non-constant time operations**: The comparison operations in tests use `std.mem.eql` which is not constant-time. For cryptographic operations, this could leak timing information, though it's less critical in hashing.

4. **Missing input validation**:
   - No validation that chain_id fits in expected ranges
   - No validation of address format (should be exactly 20 bytes)
   - No validation that MessageValue.number fits in u256 bounds
   - Fixed bytes validation (line 332-334) doesn't validate max size (bytes32 = 32 bytes max)

5. **Inconsistent ArrayList usage** (Line 5):
   ```zig
   const ArrayList = std.array_list.AlignedManaged;
   ```
   The code uses `ArrayList(T, null)` throughout, which is the managed version. This is correct but the alias naming could be clearer. However, this matches CLAUDE.md requirements.

6. **Domain deinit doesn't free all fields** (Line 42-45):
   Only frees `name` and `version`, but not the duplicated strings in message values when creating domain_data (lines 378, 382, 394).

## 3. Completeness

### Implemented
- Core EIP-712 hashing algorithm
- Type encoding with nested type support
- Domain separator hashing
- Struct hashing with proper field ordering
- Value encoding for all basic types (uint, int, address, bool, bytes, string, custom types)
- Signature creation and verification
- Address recovery from signatures
- Circular reference handling

### Missing/Incomplete
- **Array type encoding**: The encode_value function doesn't handle array types (e.g., `uint256[]`, `Person[]`)
- **Fixed-size array support**: No support for fixed-size arrays like `uint256[5]`
- **Type validation**: No validation that type definitions are well-formed
- **EIP-712 domain encoding order**: The specification requires specific field ordering in EIP712Domain, but the implementation relies on HashMap iteration order (non-deterministic)

### TODOs/Stubs
- No explicit TODOs found
- All planned functionality appears implemented

## 4. Test Coverage

### Strengths
- Comprehensive test suite with 40+ tests
- Tests for basic functionality (hashing, signing, verification)
- Edge case testing (empty strings, zero values, circular references)
- Determinism testing (same input produces same output)
- Type encoding tests (simple, nested, multiple custom types)
- Different data types tested (uint256, address, bool, string, bytes, bytes32)
- Field ordering variations tested
- Large field counts tested (20 fields)
- Deep nesting tested (3 levels)

### Gaps
- **No test vectors from EIP-712 specification**: Should include official test vectors to verify specification compliance
- **No cross-validation**: No tests comparing output with other implementations (e.g., ethers.js, viem)
- **No malicious input testing**: Missing tests for:
  - Extremely long type names
  - Extremely deep nesting (potential stack overflow)
  - Malformed type strings
  - Type name collisions
- **No performance tests**: Missing tests for:
  - Large messages (thousands of fields)
  - Deep recursion limits
- **No signature malleability tests**: The code calls secp256k1 functions but doesn't verify they handle malleability correctly

## 5. Issues Found

### Security Concerns

1. **Critical: Domain field ordering not deterministic** (Lines 167-207, 367-397)
   - The domain type properties are built dynamically based on which fields exist
   - HashMap iteration order is not guaranteed to be deterministic
   - This could lead to different hashes for the same domain across runs or platforms
   - **Impact**: Signatures could be invalid or inconsistent
   - **Fix**: Use explicit field ordering as specified in EIP-712

2. **High: Memory leaks in recursive encoding** (Line 229)
   - Leaked memory in type traversal could accumulate in long-running applications
   - **Impact**: Memory exhaustion in servers/daemons
   - **Fix**: Track allocations and free them in defer/errdefer

3. **Medium: No protection against stack overflow**
   - Deeply nested types could cause stack overflow in recursive functions
   - No depth limit on recursion in encode_type_recursive or hash_struct
   - **Impact**: DoS via malicious typed data
   - **Fix**: Add max depth parameter and check

4. **Medium: Missing constant-time comparisons for sensitive operations**
   - While hashing doesn't require constant-time, signature verification does
   - Tests use non-constant-time comparisons
   - **Impact**: Potential timing side-channels
   - **Fix**: Use constant-time comparison for signature verification

### Bugs

1. **Type encoding may not match EIP-712 spec** (Lines 221-250)
   - The specification requires alphabetical ordering of dependent types
   - Current implementation uses visited tracking which may not preserve order
   - **Fix**: Collect dependencies, sort them, then encode

2. **Fixed bytes size parsing vulnerability** (Line 332)
   - Uses `std.fmt.parseInt` without error handling for malicious input
   - Could panic on "bytes999999999999999999"
   - Returns InvalidMessage but should validate size is <= 32
   - **Fix**: Validate parsed size is in valid range [1, 32]

3. **Array type encoding not implemented**
   - No handling for `type[]` or `type[N]` in encode_value
   - Would return TypeNotFound error instead of proper encoding
   - **Fix**: Implement array encoding per EIP-712 spec

### Code Smells

1. **Repetitive code in encode_value** (Lines 286-348)
   - Large if-else chain could be refactored
   - Consider using a dispatch table or separate functions per type

2. **Complex nested defers in tests**
   - Many tests have deeply nested cleanup logic
   - Could be simplified with helper functions (though CLAUDE.md discourages this)

3. **Inconsistent error propagation**
   - Some functions return `Eip712Error!T`
   - Others return `(Eip712Error || OtherError)!T`
   - Could be more consistent

## 6. Recommendations

### High Priority

1. **Fix domain field ordering** (CRITICAL)
   - Use explicit field ordering: name, version, chainId, verifyingContract, salt
   - Matches EIP-712 specification exactly
   - Add test to verify ordering is deterministic

2. **Fix memory leaks** (HIGH)
   - Add proper cleanup in encode_type_recursive visited HashMap
   - Fix array MessageValue cleanup
   - Use errdefer for all allocations

3. **Add EIP-712 test vectors** (HIGH)
   - Include official test vectors from EIP-712 specification
   - Cross-validate with other implementations
   - Ensures specification compliance

4. **Implement array encoding** (HIGH)
   - Add support for dynamic arrays (`type[]`)
   - Add support for fixed-size arrays (`type[N]`)
   - Add tests for array encoding

### Medium Priority

5. **Add recursion depth limiting** (MEDIUM)
   - Prevent stack overflow attacks
   - Reasonable limit: 32 levels of nesting
   - Return CircularReference error if exceeded

6. **Improve input validation** (MEDIUM)
   - Validate type names are valid identifiers
   - Validate numeric sizes are in valid ranges
   - Validate addresses are exactly 20 bytes
   - Add validation tests

7. **Add performance tests** (MEDIUM)
   - Test with large messages (1000+ fields)
   - Test with deep nesting (10+ levels)
   - Benchmark against other implementations

### Low Priority

8. **Refactor encode_value** (LOW)
   - Split into separate functions per type
   - Reduces complexity and improves maintainability

9. **Add documentation comments** (LOW)
   - Add doc comments explaining EIP-712 format
   - Explain security considerations
   - Add examples for common use cases

10. **Consider creating convenience builders** (LOW)
    - Builder pattern for TypedData construction
    - Reduces boilerplate in tests and usage
    - Type-safe API for common patterns

## 7. EIP-712 Compliance Notes

### Specification Adherence
- ✅ Domain separator format correct
- ✅ Type hash calculation correct
- ✅ Struct encoding correct (mostly)
- ⚠️ Domain field ordering may not be deterministic (needs verification)
- ❌ Array encoding not implemented
- ⚠️ Type dependency ordering may not match spec (needs verification)

### Security Considerations
- ✅ All functions marked as unaudited (appropriate)
- ⚠️ Should verify underlying secp256k1 implementation prevents malleability
- ⚠️ No explicit protection against signature replay attacks (should be handled by application layer with nonces/timestamps)

## Summary

This is a well-structured implementation of EIP-712 with good test coverage. However, it has several critical issues:

1. **Memory leaks** that need immediate fixing
2. **Missing array encoding** which is required by the specification
3. **Potential non-determinism** in domain field ordering
4. **Missing official test vectors** to verify specification compliance

The code demonstrates good understanding of the EIP-712 specification and proper Zig practices for memory management (with the noted leaks). With the recommended fixes, this would be a solid implementation. The "unaudited" warnings are appropriate and should remain until a professional security audit is performed.

**Overall Grade: B-** (Good structure and approach, but critical issues prevent production use)
