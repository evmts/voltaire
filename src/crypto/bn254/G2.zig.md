# Review: bn254/G2.zig

## 1. Overview
Implements G2 elliptic curve group over Fp2 extension field for BN254. Uses Jacobian projective coordinates with twist curve equation y²=x³+3/ξ. Includes 4-dimensional GLV decomposition for efficient scalar multiplication and critical subgroup membership checking.

## 2. Code Quality

### Strengths
- Sophisticated 4-GLV scalar decomposition
- Proper Frobenius endomorphism implementation
- Subgroup membership check (CRITICAL for security)
- Efficient windowing technique for scalar mul
- Good test coverage including subgroup validation

### Issues
- **CRITICAL: Panic in toAffine** (Lines 42-44): Same panic issue as G1.zig
- **CRITICAL: Panic in isOnCurve** (Lines 59-61): Panics if XI inversion fails
- **WARNING in init** (Line 27): Comment admits "DOES NOT CHECK IF POINT IS IN RIGHT SUBGROUP" - this is dangerous
- **Complex decomposition** (Lines 250-278): 4D lattice reduction with no correctness proof

## 3. Completeness

### Complete
- G2 group operations
- Subgroup checking (via isInSubgroup)
- 4-GLV scalar multiplication
- Frobenius maps and endomorphisms

### Incomplete/Missing
- **Subgroup check not in init()**: Line 27-33 - init validates curve but NOT subgroup
- **No point compression**
- **No hash-to-curve for G2**
- **No batch operations**

## 4. Test Coverage

### Adequate
- Basic operations well tested
- **EXCELLENT: Subgroup validation tests** (Lines 413-420) including invalid points
- Endomorphism correctness verified
- Edge cases covered

### Missing
- **No tests for init() accepting wrong-subgroup points** - should test that init() is dangerous without isInSubgroup() check
- **No decomposition edge cases**
- **No comprehensive invalid point tests**

## 5. Security Issues

### CRITICAL
1. **Panic in toAffine** (Lines 42-44): Must fix like G1
   ```zig
   const z_inv = self.z.inv() catch |err| {
       std.debug.panic("G2.toAffine: z inversion failed...", .{err});
   };
   ```

2. **Panic in isOnCurve** (Lines 59-61): XI should never be zero, but panic is wrong pattern
   ```zig
   const xi_inv = xi.inv() catch |err| {
       std.debug.panic("G2.isOnCurve: xi inversion failed...", .{err});
   };
   ```

3. **init() doesn't validate subgroup** (Lines 28-34): This is EXTREMELY DANGEROUS. Comment admits it. An attacker can craft G2 points on curve but wrong subgroup, breaking pairing security:
   ```zig
   // WARNING: DOES NOT CHECK IF POINT IS IN RIGHT SUBGROUP
   pub fn init(x: *const Fp2Mont, y: *const Fp2Mont, z: *const Fp2Mont) !G2 {
       const point = G2{ .x = x.*, .y = y.*, .z = z.* };
       if (!point.isOnCurve()) {
           return error.InvalidPoint;
       }
       // MISSING: if (!point.isInSubgroup()) return error.InvalidSubgroup;
       return point;
   }
   ```

### HIGH
4. **Expensive subgroup check** (Lines 90-115): isInSubgroup() performs multiple point multiplications. If not called at init, it's easy to forget. Every G2 point from untrusted input MUST be validated.

5. **Complex 4D decomposition** (Lines 250-323): If decomposition is incorrect, scalar mul gives wrong results silently.

## 6. Issues Found

### Bugs
- **CRITICAL**: Two panic sites (toAffine, isOnCurve)
- **CRITICAL SECURITY**: init() missing subgroup check despite WARNING comment

### Code Smells
- Comment acknowledging security gap but not fixing it (Line 27)
- Complex decomposition with no correctness proof
- Precomputed point table logic (init_precomputed_points) not documented

## 7. Recommendations

### IMMEDIATE (Critical Security)
1. **Fix all panics** - replace with error propagation

2. **ADD SUBGROUP CHECK TO init()** or rename function:
   ```zig
   // Option A: Add check (RECOMMENDED)
   pub fn init(x: *const Fp2Mont, y: *const Fp2Mont, z: *const Fp2Mont) !G2 {
       const point = G2{ .x = x.*, .y = y.*, .z = z.* };
       if (!point.isOnCurve()) return error.InvalidPoint;
       if (!point.isInSubgroup()) return error.InvalidSubgroup;  // ADD THIS
       return point;
   }

   // Option B: Make danger explicit
   pub fn initUnchecked(...) G2 { ... }  // Fast, no subgroup check
   pub fn initValidated(...) !G2 { ... }  // Full validation including subgroup
   ```

3. **Audit all callers of G2.init()** - ensure every untrusted G2 point is validated:
   ```bash
   grep -rn "G2.init" src/crypto/
   ```

4. **Add test for wrong-subgroup attack**:
   ```zig
   test "G2.init rejects wrong-subgroup points" {
       // Point from test at line 413-420 that's on curve but wrong subgroup
       const bad_point = G2.initUnchecked(&x, &y, &z);
       try std.testing.expect(bad_point.isOnCurve());
       try std.testing.expect(!bad_point.isInSubgroup());

       // Ensure init would reject it (after fix)
       try std.testing.expectError(error.InvalidSubgroup,
           G2.init(&x, &y, &z));
   }
   ```

### HIGH PRIORITY
5. **Document 4D decomposition** with references to literature

6. **Add decomposition correctness tests** verifying reconstruction

7. **Optimize subgroup check** if possible (current method already uses endomorphism trick)

8. **Document computational cost** of operations (especially isInSubgroup which is ~4 point multiplications)

### MEDIUM PRIORITY
9. **Add point compression** for G2
10. **Add batch subgroup checking** if multiple points need validation
11. **Document timing safety** of variable-time operations

## CRITICAL ACTION REQUIRED
1. **Fix panics immediately**
2. **Add subgroup validation to init() or rename function** - This is a **severe security vulnerability**
3. **Audit all code paths** accepting G2 points from external sources

The current init() function is a **security time bomb**. The comment acknowledges the issue but doesn't fix it. Any code accepting G2 points without explicit isInSubgroup() calls is vulnerable to invalid pairing attacks.
