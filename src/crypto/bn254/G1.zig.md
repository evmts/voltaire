# Review: bn254/G1.zig

## 1. Overview
Implements G1 elliptic curve group operations for BN254 using Jacobian projective coordinates. Includes optimized scalar multiplication using GLV-GLS endomorphism with NAF representation. Core component for zkSNARK verification.

## 2. Code Quality

### Strengths
- Efficient Jacobian coordinate formulas minimize inversions
- GLV-GLS endomorphism reduces scalar mul from 256 to 128 bits
- NAF representation minimizes additions
- Comprehensive test suite (40+ tests)
- Mathematical invariants well tested

### Issues
- **Panic in toAffine** (Lines 41-43): Panics on z=0 instead of returning error. Violates CLAUDE.md zero-tolerance for panics.
- **No input validation flag**: `init()` vs `initUnchecked()` but init doesn't document what it validates
- **Complex scalar decomposition** (Lines 221-235): Decomposition correctness not obviously verified
- **Magic lattice constants** (curve_parameters.zig): No documentation of how lattice basis was computed

## 3. Completeness

### Complete
- All group operations (add, double, mul, neg)
- Efficient scalar multiplication
- Point validation
- Coordinate conversion

### Incomplete/Missing
- **No point compression**: Missing compressed point serialization
- **No multi-scalar multiplication**: Batch operations would benefit from Pippenger's algorithm
- **No hash-to-curve**: H2C needed for some protocols
- **No cofactor multiplication**: Though BN254 has cofactor 1

## 4. Test Coverage

### Adequate
- Basic operations thoroughly tested
- Edge cases (infinity, zero, curve order) covered
- Mathematical properties validated
- Known test vectors used

### Missing
- **No invalid point tests**: Need tests with off-curve points beyond basic test at line 64-71
- **No GLV decomposition edge cases**: Boundary values for decomposition not tested
- **No timing attack tests**: Should verify constant-time properties where needed

## 5. Security Issues

### CRITICAL
1. **Panic in toAffine** (Lines 41-43): Library code panics instead of returning error. An attacker could trigger panic with malformed input. VIOLATES CRITICAL RULE.
   ```zig
   // WRONG:
   const z_inv = self.z.inv() catch |err| {
       std.debug.panic("G1.toAffine: z inversion failed...", .{err});
   };

   // CORRECT:
   const z_inv = try self.z.inv();
   ```

### HIGH
2. **No subgroup validation**: G1 has cofactor 1 so all curve points are valid, but this should be documented.

3. **Scalar decomposition correctness** (Lines 221-278): Complex lattice-based decomposition with no proof of correctness in comments. If wrong, could produce incorrect scalar multiplications.

### MEDIUM
4. **Variable-time scalar mul**: NAF and GLV endomorphism are variable-time. Acceptable for public scalars but undocumented.

## 6. Issues Found

### Bugs
- **CRITICAL BUG** (Lines 41-43): Panic instead of error return violates CLAUDE.md

### Code Smells
- Commented test code (Lines 507-512)
- Complex decomposition algorithm needs explanation comments
- Test duplication could use test tables

## 7. Recommendations

### IMMEDIATE (Critical Fix)
1. **Remove panic from toAffine**:
   ```zig
   pub fn toAffine(self: *const G1) !G1 {
       if (self.isInfinity()) return INFINITY;
       const z_inv = try self.z.inv();  // Propagate error instead of panic
       // ...
   }
   ```

2. **Audit all catch blocks** - verify none swallow errors or panic:
   ```bash
   grep -n "catch |" G1.zig
   ```

### HIGH PRIORITY
3. **Document scalar decomposition**:
   ```zig
   // Decomposes scalar k into k1, k2 such that k ≡ k1 + λ*k2 (mod r)
   // where λ is cube root of unity and |k1|, |k2| ≤ √r
   // See: Gallant-Lambert-Vanstone '01, Galbraith-Lin-Scott '09
   ```

4. **Add decomposition correctness test**:
   ```zig
   test "scalar decomposition reconstructs original" {
       const test_scalars = [_]u256{ /* edge cases */ };
       for (test_scalars) |k| {
           const decomp = decomposeScalar(k);
           const reconstructed = k1 + lambda * k2 mod r;
           try std.testing.expectEqual(k, reconstructed);
       }
   }
   ```

5. **Add off-curve point rejection tests**:
   ```zig
   test "G1.init rejects off-curve points" {
       const bad_points = [_]struct{ x: u256, y: u256 }{
           .{ .x = 1, .y = 1 },  // Not on y²=x³+3
           // ... more invalid points
       };
       for (bad_points) |pt| {
           try std.testing.expectError(error.InvalidPoint,
               G1.init(&FpMont.init(pt.x), &FpMont.init(pt.y), &FpMont.ONE));
       }
   }
   ```

### MEDIUM PRIORITY
6. **Add timing-safety documentation**:
   ```zig
   /// WARNING: Scalar multiplication is variable-time and leaks scalar bits
   /// through execution time. Safe for public scalars only.
   pub fn mul(self: *const G1, scalar: *const Fr) G1
   ```

7. **Implement point compression** for efficient serialization

8. **Add multi-scalar multiplication** for batch verification efficiency

## CRITICAL ACTION REQUIRED
**Fix panic in toAffine immediately** - This violates CLAUDE.md's zero-tolerance policy and is a critical security issue. Library code must never panic.

All other issues are lower priority but should be addressed before production use.
