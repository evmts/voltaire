---
title: Base64 Encoding/Decoding
description: Standard and URL-safe Base64 encoding for Ethereum data
---

# Base64 Encoding/Decoding

Zig implementation of RFC 4648 Base64 encoding with both standard and URL-safe variants.

## Overview

The Base64 module provides:
- **Standard Base64**: RFC 4648 alphabet (A-Z, a-z, 0-9, +, /) with padding
- **URL-Safe Base64**: URL-safe alphabet (A-Z, a-z, 0-9, -, _) without padding
- **Size Calculation**: Pre-compute encoded/decoded sizes
- **Zero-Copy**: Efficient memory management

**Source**: `src/primitives/base64.zig`

## Key Functions

### encode

```zig
const primitives = @import("primitives");

/// Encode bytes to standard Base64
pub fn encode(allocator: Allocator, data: []const u8) ![]u8
```

**Parameters:**
- `allocator`: Memory allocator for result
- `data`: Input bytes to encode

**Returns:** Base64-encoded string with standard alphabet and padding

**Errors:** `OutOfMemory`

### decode

```zig
/// Decode standard Base64 to bytes
pub fn decode(allocator: Allocator, encoded: []const u8) ![]u8
```

**Parameters:**
- `allocator`: Memory allocator for result
- `encoded`: Base64 string to decode

**Returns:** Decoded bytes

**Errors:** `InvalidCharacter`, `InvalidPadding`, `OutOfMemory`

### encodeUrlSafe

```zig
/// Encode bytes to URL-safe Base64 (no padding)
pub fn encodeUrlSafe(allocator: Allocator, data: []const u8) ![]u8
```

Uses URL-safe alphabet (-, _) suitable for URLs and filenames.

### decodeUrlSafe

```zig
/// Decode URL-safe Base64 to bytes
pub fn decodeUrlSafe(allocator: Allocator, encoded: []const u8) ![]u8
```

### Size Calculation

```zig
/// Calculate encoded size for data length
pub fn calcEncodedSize(data_len: usize) usize

/// Calculate maximum decoded size for encoded length
pub fn calcDecodedSize(encoded_len: usize) !usize
```

## Examples

### Standard Base64 Encoding

```zig
const std = @import("std");
const base64 = @import("primitives").base64;

pub fn example() !void {
    const allocator = std.heap.page_allocator;

    // Encode data
    const data = "Hello, Ethereum!";
    const encoded = try base64.encode(allocator, data);
    defer allocator.free(encoded);
    // Result: "SGVsbG8sIEV0aGVyZXVtIQ=="

    // Decode back
    const decoded = try base64.decode(allocator, encoded);
    defer allocator.free(decoded);
    // Result: "Hello, Ethereum!"
}
```

### URL-Safe Encoding

```zig
const std = @import("std");
const base64 = @import("primitives").base64;

pub fn urlSafeExample() !void {
    const allocator = std.heap.page_allocator;

    // URL-safe encoding (no padding, -, _ instead of +, /)
    const data = &[_]u8{0xff, 0xfe, 0xfd};
    const encoded = try base64.encodeUrlSafe(allocator, data);
    defer allocator.free(encoded);
    // Safe for URLs and filenames

    const decoded = try base64.decodeUrlSafe(allocator, encoded);
    defer allocator.free(decoded);
}
```

### Pre-calculate Buffer Sizes

```zig
const base64 = @import("primitives").base64;

pub fn preAllocate() void {
    const data_len = 100;

    // Calculate required buffer size before allocating
    const encoded_size = base64.calcEncodedSize(data_len);
    // Can now allocate exact size needed
}
```

## Performance

**Native (ReleaseFast)**:
- Encoding: ~2-3 GB/s
- Decoding: ~1.5-2 GB/s

**WASM (ReleaseFast)**:
- Encoding: ~800-1200 MB/s
- Decoding: ~600-900 MB/s

Uses Zig's optimized std.base64 implementation with SIMD where available.

## Testing

```bash
zig build test -Dtest-filter=base64
```

Test coverage includes:
- Standard alphabet round-trips
- URL-safe alphabet round-trips
- Edge cases (empty input, padding)
- Invalid input handling
- Size calculations

## Related

- [Hex](/zig/primitives/hex/) - Hexadecimal encoding
- [RLP](/zig/primitives/rlp/) - RLP encoding

## References

- [RFC 4648](https://tools.ietf.org/html/rfc4648) - Base64 specification
- [Zig std.base64](https://ziglang.org/documentation/0.15.1/#A;std:base64)
