---
title: Address
description: Ethereum address primitive (20-byte identifier)
---

# Address

20-byte Ethereum address primitive for account and contract identifiers.

## Overview

The Address module provides:
- **Parsing**: Convert hex strings to addresses
- **Checksum**: EIP-55 checksummed address formatting
- **Validation**: Verify address format and checksum
- **Zero-copy operations**: Minimal allocations

**Source**: `src/primitives/address.zig`

## Key Functions

### Parsing

```zig
const primitives = @import("primitives");

// Parse from hex string
pub fn fromHex(hex: []const u8) ![20]u8 {
    return primitives.Address.fromHex(hex);
}

// Parse from hex with validation
pub fn fromHexChecksummed(hex: []const u8) ![20]u8 {
    return primitives.Address.fromHexChecksummed(hex);
}
```

### Formatting

```zig
// Convert to lowercase hex
pub fn toHex(address: [20]u8, allocator: Allocator) ![]u8 {
    return primitives.Address.toHex(address, allocator);
}

// Convert to EIP-55 checksummed hex
pub fn toChecksum(address: [20]u8, allocator: Allocator) ![]u8 {
    return primitives.Address.toChecksum(address, allocator);
}
```

### Validation

```zig
// Validate address format
pub fn isValid(hex: []const u8) bool {
    return primitives.Address.isValid(hex);
}

// Validate EIP-55 checksum
pub fn hasValidChecksum(hex: []const u8) bool {
    return primitives.Address.hasValidChecksum(hex);
}
```

## Examples

### Parse and Format Address

```zig
const std = @import("std");
const primitives = @import("primitives");

pub fn main() !void {
    const allocator = std.heap.page_allocator;

    // Parse address
    const addr = try primitives.Address.fromHex(
        "0x742d35Cc6634C0532925a3b844Bc9e7595f0bEb"
    );

    // Convert to checksummed format
    const checksummed = try primitives.Address.toChecksum(addr, allocator);
    defer allocator.free(checksummed);

    std.debug.print("Checksummed: {s}\n", .{checksummed});
}
```

### Validate Checksum

```zig
pub fn validateAddress(hex: []const u8) !void {
    // Check basic format
    if (!primitives.Address.isValid(hex)) {
        return error.InvalidAddress;
    }

    // Check EIP-55 checksum if mixed case
    const hasMixedCase = blk: {
        var has_upper = false;
        var has_lower = false;
        for (hex[2..]) |c| {
            if (c >= 'A' and c <= 'F') has_upper = true;
            if (c >= 'a' and c <= 'f') has_lower = true;
        }
        break :blk has_upper and has_lower;
    };

    if (hasMixedCase and !primitives.Address.hasValidChecksum(hex)) {
        return error.InvalidChecksum;
    }
}
```

### Derive from Public Key

```zig
const crypto = @import("crypto");

pub fn deriveAddress(public_key: [64]u8) [20]u8 {
    // Hash public key
    const hash = crypto.Hash.keccak256(&public_key);

    // Take last 20 bytes
    var address: [20]u8 = undefined;
    @memcpy(&address, hash[12..32]);

    return address;
}
```

## EIP-55 Checksum

EIP-55 checksumming uses mixed case to encode a checksum:

1. Convert address to lowercase hex (no `0x` prefix)
2. Hash the lowercase hex with Keccak256
3. For each hex character:
   - If hash byte >= 8: uppercase
   - Otherwise: lowercase

```zig
// Example: Valid checksummed address
const addr = "0x5aAeb6053F3E94C9b9A09f33669435E7Ef1BeAed";
//              ^  ^     ^ ^  ^    ^     ^      ^ ^ ^  ^
//              Uppercase based on hash values
```

## Zero Address

The zero address (`0x0000000000000000000000000000000000000000`) has special meaning:
- **Contract creation**: Transaction to zero address creates a contract
- **Null value**: Represents uninitialized or invalid address

## Performance

**Native (ReleaseFast)**:
- fromHex: ~50 ns
- toChecksum: ~1-2 μs (includes Keccak256)
- isValid: ~10 ns

**WASM (ReleaseFast)**:
- fromHex: ~100 ns
- toChecksum: ~3-5 μs
- isValid: ~20 ns

## Memory

All operations are zero-copy or return fixed-size arrays when possible:
- `fromHex`: Returns `[20]u8` (stack-allocated)
- `toHex`/`toChecksum`: Caller provides allocator

## Testing

```bash
zig build test -Dtest-filter=address
```

Test coverage includes:
- Valid addresses (checksummed and non-checksummed)
- Invalid lengths
- Invalid characters
- Zero address
- EIP-55 test vectors

## Related

- [Transaction](/zig/primitives/transaction/) - Using addresses in transactions
- [secp256k1](/zig/crypto/secp256k1/) - Deriving addresses from public keys
- [ecrecover](/zig/precompiles/ecrecover/) - Recovering addresses from signatures

## References

- [EIP-55: Mixed-case checksum address encoding](https://eips.ethereum.org/EIPS/eip-55)
- [Ethereum Yellow Paper](https://ethereum.github.io/yellowpaper/paper.pdf) - Section 4.2
