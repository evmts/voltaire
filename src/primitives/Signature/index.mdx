---
title: "Signature"
---

import { CardGrid, LinkCard } from '@astrojs/starlight/components';

# Signature

Unified cryptographic signature primitive supporting multiple algorithms (secp256k1, P-256, Ed25519).

## Overview

Signature provides algorithm-agnostic signature handling with automatic metadata tracking. Supports ECDSA (secp256k1, P-256) and EdDSA (Ed25519) with format conversions (compact, DER).

**Key Features:**
- Multi-algorithm support (secp256k1, P-256, Ed25519)
- Format conversions (compact, DER, RSV)
- Signature validation and canonicalization
- Public key recovery (secp256k1 only)
- Zero-copy operations where possible
- WASM acceleration available

## Documentation

<CardGrid>
  <LinkCard
    title="Constructors"
    description="Create signatures from components, DER, compact formats, or algorithm-specific constructors"
    href="./constructors"
  />
  <LinkCard
    title="Conversions"
    description="Convert between signature formats: compact, DER, RSV, and raw bytes"
    href="./conversions"
  />
  <LinkCard
    title="Validation"
    description="Validate signatures, check canonicality, and prevent malleability attacks"
    href="./validation"
  />
  <LinkCard
    title="Recovery"
    description="Recover public keys and addresses from secp256k1 signatures using recovery ID"
    href="./recovery"
  />
  <LinkCard
    title="Utilities"
    description="Extract components, compare signatures, and type guards"
    href="./utilities"
  />
  <LinkCard
    title="Formats"
    description="Compare signature formats: compact (64B), DER (variable), RSV, and EIP-2098"
    href="./formats"
  />
  <LinkCard
    title="EIP-2098"
    description="Compact 64-byte format with embedded recovery ID for gas savings"
    href="./eip-2098"
  />
  <LinkCard
    title="Usage Patterns"
    description="Real-world examples: Ethereum transactions, EIP-712, personal_sign"
    href="./usage-patterns"
  />
  <LinkCard
    title="WASM"
    description="WASM-accelerated signature operations for improved performance"
    href="./wasm"
  />
  <LinkCard
    title="Branded Type"
    description="Type definition and metadata structure"
    href="./branded-signature"
  />
</CardGrid>

## Signature Format Comparison

| Format | Size | Recovery | Use Case |
|--------|------|----------|----------|
| **Compact** | 64 bytes | ❌ No | Standard ECDSA storage |
| **Compact+V** | 65 bytes | ✅ Yes | Ethereum transactions |
| **DER** | ~70-72 bytes | ❌ No | Bitcoin, X.509 certificates |
| **EIP-2098** | 64 bytes | ✅ Yes (embedded) | Gas-optimized Ethereum |

See [Signature Formats](./formats.mdx) for detailed comparison.

## Quick Start

```typescript
import { Signature, Hex } from '@tevm/voltaire';

// Create from transaction components
const sig = Signature.fromSecp256k1(
  Hex.toBytes('0x1234...'), // r (32 bytes)
  Hex.toBytes('0x5678...'), // s (32 bytes)
  27                         // v (recovery ID)
);

// Or use universal constructor
const sig2 = Signature.from({
  r: rBytes,
  s: sBytes,
  v: 27,
  algorithm: 'secp256k1'
});

// Ensure canonical form (prevent malleability)
const canonical = Signature.normalize(sig);
console.log(Signature.isCanonical(canonical)); // true

// Convert between formats
const compact = Signature.toCompact(sig);    // 65 bytes (r + s + v)
const der = Signature.toDER(sig);            // ~70 bytes (ASN.1 encoded)

// Extract components
const r = Signature.getR(sig);  // 32 bytes
const s = Signature.getS(sig);  // 32 bytes
const v = Signature.getV(sig);  // 27 or 28
```

## Security Considerations

### Signature Malleability

ECDSA signatures are malleable: both `(r, s)` and `(r, -s mod n)` are valid. Always normalize to prevent attacks:

```typescript
// Wrong: Accept any signature
const address = Secp256k1.recoverAddress(sig, messageHash);

// Right: Normalize first
const canonical = Signature.normalize(sig);
const address = Secp256k1.recoverAddress(canonical, messageHash);
```

**Standards:**
- **Bitcoin BIP-62**: Requires canonical low-s signatures
- **Ethereum**: Enforces low-s in consensus rules
- **Best Practice**: Always normalize before verification or storage

### Recovery ID Validation

```typescript
const v = Signature.getV(sig);

// Validate recovery ID range
if (v !== undefined && v !== 27 && v !== 28) {
  // Handle EIP-155 chain-specific v values
  const chainId = Math.floor((v - 35) / 2);
  const yParity = (v - 35) % 2;
  const standardV = 27 + yParity;
  // Create new signature with standard v...
}
```

### Replay Attack Prevention

Ethereum uses EIP-155 to prevent cross-chain replay attacks:

```typescript
// EIP-155 v encoding: v = chainId * 2 + 35 + yParity
const chainId = 1; // Mainnet
const yParity = v === 27 ? 0 : 1;
const eip155V = chainId * 2 + 35 + yParity; // 37 or 38
```

## Algorithm-Specific Constructors

### [Signature.fromSecp256k1(r, s, v?)](./constructors.mdx#fromsecp256k1)
```typescript
fromSecp256k1(r: Uint8Array, s: Uint8Array, v?: number): BrandedSignature
```
Create secp256k1 ECDSA signature from components.

**Parameters:**
- `r`: r component (32 bytes)
- `s`: s component (32 bytes)
- `v`: Optional recovery ID (27 or 28 for Ethereum)

### [Signature.fromP256(r, s)](./constructors.mdx#fromp256)
```typescript
fromP256(r: Uint8Array, s: Uint8Array): BrandedSignature
```
Create P-256 (NIST P-256) ECDSA signature.

### [Signature.fromEd25519(signature)](./constructors.mdx#fromed25519)
```typescript
fromEd25519(signature: Uint8Array): BrandedSignature
```
Create Ed25519 signature (64 bytes).

### [Signature.fromCompact(bytes, algorithm)](./constructors.mdx#fromcompact)
```typescript
fromCompact(bytes: Uint8Array, algorithm: SignatureAlgorithm): BrandedSignature
```
Create from compact encoding (r + s, 64 bytes).

### [Signature.fromDER(der, algorithm, v?)](./constructors.mdx#fromder)
```typescript
fromDER(der: Uint8Array, algorithm: 'secp256k1' | 'p256', v?: number): BrandedSignature
```
Create from DER-encoded ECDSA signature.

## Conversions

### [Signature.toBytes(signature)](./conversions.mdx#tobytes)
```typescript
toBytes(signature: BrandedSignature): Uint8Array
```
Get raw signature bytes (strips metadata).

### [Signature.toCompact(signature)](./conversions.mdx#tocompact)
```typescript
toCompact(signature: BrandedSignature): Uint8Array
```
Convert to compact format (r + s, 64 bytes).

### [Signature.toDER(signature)](./conversions.mdx#toder)
```typescript
toDER(signature: BrandedSignature): Uint8Array
```
Convert ECDSA signature to DER encoding.

**Throws:** InvalidAlgorithmError if not ECDSA

## Utilities

### Component Extraction

#### [Signature.getAlgorithm(signature)](./utilities.mdx#getalgorithm)
```typescript
getAlgorithm(signature: BrandedSignature): SignatureAlgorithm
```
Get signature algorithm.

#### [Signature.getR(signature)](./utilities.mdx#getr)
```typescript
getR(signature: BrandedSignature): Uint8Array
```
Extract r component (ECDSA only, 32 bytes).

#### [Signature.getS(signature)](./utilities.mdx#gets)
```typescript
getS(signature: BrandedSignature): Uint8Array
```
Extract s component (ECDSA only, 32 bytes).

#### [Signature.getV(signature)](./utilities.mdx#getv)
```typescript
getV(signature: BrandedSignature): number | undefined
```
Get recovery ID (secp256k1 only).

### Canonicalization

#### [Signature.isCanonical(signature)](./validation.mdx#iscanonical)
```typescript
isCanonical(signature: BrandedSignature): boolean
```
Check if ECDSA signature has canonical s-value (s ≤ n/2).

**Returns:** Always true for Ed25519

#### [Signature.normalize(signature)](./validation.mdx#normalize)
```typescript
normalize(signature: BrandedSignature): BrandedSignature
```
Normalize ECDSA signature to canonical form (s = n - s if s > n/2).

### Comparison

#### [Signature.equals(a, b)](./utilities.mdx#equals)
```typescript
equals(a: BrandedSignature, b: BrandedSignature): boolean
```
Compare signatures for equality.

#### [Signature.is(value)](./utilities.mdx#is)
```typescript
is(value: unknown): value is BrandedSignature
```
Type guard for BrandedSignature.

## Verification (Placeholder)

### [Signature.verify(signature, message, publicKey)](./utilities.mdx#verify)
```typescript
verify(signature: BrandedSignature, message: Uint8Array, publicKey: Uint8Array): boolean
```
Verify signature against message and public key.

**Note:** Currently placeholder. Use crypto module functions for actual verification.

**Throws:** InvalidAlgorithmError (requires crypto integration)

## Types

```typescript
type SignatureAlgorithm = "secp256k1" | "p256" | "ed25519";

type BrandedSignature = Uint8Array & {
  readonly __tag: "Signature";
  readonly algorithm: SignatureAlgorithm;
  readonly v?: number; // Recovery ID for secp256k1 (27 or 28)
};
```

## Constants

```typescript
ECDSA_SIZE = 64;           // r + s
ECDSA_WITH_V_SIZE = 65;    // r + s + v
ED25519_SIZE = 64;         // Ed25519 signature
COMPONENT_SIZE = 32;       // r or s component
RECOVERY_ID_MIN = 27;      // Ethereum v value
RECOVERY_ID_MAX = 28;      // Ethereum v value
```

## Errors

- `SignatureError` - Base error class
- `InvalidSignatureLengthError` - Invalid byte length
- `InvalidSignatureFormatError` - Unsupported format
- `InvalidAlgorithmError` - Invalid or unsupported algorithm
- `NonCanonicalSignatureError` - Signature not canonical
- `InvalidDERError` - DER encoding/decoding error

## Structure

### ECDSA (secp256k1, P-256)
```
Bytes: [r (32 bytes)][s (32 bytes)]
Metadata: algorithm, v (optional for secp256k1)
```

### Ed25519
```
Bytes: [signature (64 bytes)]
Metadata: algorithm = 'ed25519'
```

### Recovery ID (v)
- **27**: First recovery attempt (Ethereum standard)
- **28**: Second recovery attempt
- Only applies to secp256k1
- Not stored in signature bytes (metadata only)

## Quick Start

```typescript
import { Signature, Hex } from '@tevm/voltaire';

// Create secp256k1 signature
const sig = Signature.fromSecp256k1(rBytes, sBytes, 27);

// Universal constructor
const sig2 = Signature.from({ r: rBytes, s: sBytes, v: 27 });

// Check algorithm
console.log(Signature.getAlgorithm(sig)); // "secp256k1"

// Normalize to canonical form
const canonical = Signature.normalize(sig);
console.log(Signature.isCanonical(canonical)); // true

// Convert to DER
const der = Signature.toDER(sig);

// Parse from DER
const parsed = Signature.fromDER(der, 'secp256k1', 27);

// Compare signatures
console.log(Signature.equals(sig, parsed)); // true
```

## Common Patterns

### Ethereum Transaction Signature

```typescript
// From transaction signature (r, s, v)
const sig = Signature.fromSecp256k1(
  Hex.toBytes(transaction.r),
  Hex.toBytes(transaction.s),
  transaction.v
);

// Ensure canonical (BIP-62)
const canonical = Signature.normalize(sig);

// Extract recovery ID
const v = Signature.getV(canonical);
console.log(v); // 27 or 28
```

### Multi-Algorithm Support

```typescript
function createSignature(
  algorithm: SignatureAlgorithm,
  data: Uint8Array
): BrandedSignature {
  switch (algorithm) {
    case 'secp256k1':
      // Extract r, s, v from secp256k1 signature
      return Signature.fromSecp256k1(r, s, v);
    case 'p256':
      return Signature.fromP256(r, s);
    case 'ed25519':
      return Signature.fromEd25519(data);
  }
}

// Algorithm preserved in metadata
const sig = createSignature('secp256k1', sigBytes);
console.log(sig.algorithm); // "secp256k1"
```

### DER Encoding/Decoding

```typescript
// Convert to DER for transmission
const sig = Signature.fromSecp256k1(r, s, 27);
const der = Signature.toDER(sig);

// Parse DER back to signature
const parsed = Signature.fromDER(der, 'secp256k1', 27);

// Signatures are equal
console.log(Signature.equals(sig, parsed)); // true
```

### Signature Validation

```typescript
// Check if signature is canonical
if (!Signature.isCanonical(sig)) {
  sig = Signature.normalize(sig);
}

// Verify structure
if (sig.length !== ECDSA_SIZE) {
  throw new Error('Invalid signature length');
}

// Check algorithm
if (Signature.getAlgorithm(sig) !== 'secp256k1') {
  throw new Error('Expected secp256k1 signature');
}
```

## Malleability Prevention

ECDSA signatures have inherent malleability: both (r, s) and (r, -s mod n) are valid for the same message. Bitcoin BIP-62 and Ethereum require canonical form (s ≤ n/2).

```typescript
// Enforce canonical form
function ensureCanonical(sig: BrandedSignature): BrandedSignature {
  if (!Signature.isCanonical(sig)) {
    return Signature.normalize(sig);
  }
  return sig;
}

// Example
const sig = Signature.fromSecp256k1(r, sHigh, 27);
console.log(Signature.isCanonical(sig)); // false (s > n/2)

const canonical = Signature.normalize(sig);
console.log(Signature.isCanonical(canonical)); // true (s ≤ n/2)
console.log(Signature.getV(canonical)); // 28 (v flipped)
```

## Implementation

- Branded Uint8Array with metadata
- Algorithm tracked in non-enumerable property
- Recovery ID (v) stored separately
- Zero-copy conversions where possible
- Constant-time comparisons for security

## References

- [Constructors](./constructors.mdx)
- [Conversions](./conversions.mdx)
- [Validation](./validation.mdx)
- [Utilities](./utilities.mdx)
- [Usage Patterns](./usage-patterns.mdx)
- [WASM](./wasm.mdx)
- [BIP-62: Dealing with Malleability](https://github.com/bitcoin/bips/blob/master/bip-0062.mediawiki)
- [SEC 1: Elliptic Curve Cryptography](https://www.secg.org/sec1-v2.pdf)
