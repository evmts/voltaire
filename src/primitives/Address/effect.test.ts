import * as Effect from "effect/Effect";
import * as Schema from "effect/Schema";
import { describe, expect, it } from "vitest";
import * as BrandedAddress from "./BrandedAddress/index.js";
import {
	Address,
	AddressFromHex,
	AddressFromUnknown,
	ChecksumAddress,
} from "./effect.js";

describe("Address Effect Schema", () => {
	const testAddress = "0x742d35Cc6634C0532925a3b844Bc9e7595f251e3";
	const testAddressLower = testAddress.toLowerCase();

	describe("Address class", () => {
		it("creates Address from hex string", () => {
			const addr = Address.fromHex(testAddress);
			expect(addr.toHex()).toBe(testAddressLower);
		});

		it("creates Address from number", () => {
			const addr = Address.fromNumber(12345n);
			expect(addr.toU256()).toBe(12345n);
		});

		it("creates Address from bytes", () => {
			const bytes = new Uint8Array(20);
			bytes[19] = 0x01;
			const addr = Address.fromBytes(bytes);
			expect(addr.toU256()).toBe(1n);
		});

		it("creates Address from universal input", () => {
			const addr1 = Address.from(testAddress);
			const addr2 = Address.from(12345n);
			const addr3 = Address.from(new Uint8Array(20));

			expect(addr1.toHex()).toBe(testAddressLower);
			expect(addr2.toU256()).toBe(12345n);
			expect(addr3.isZero()).toBe(true);
		});

		it("validates Address schema", () => {
			const validBytes = BrandedAddress.from(testAddress);
			const addr = new Address({ value: validBytes });
			expect(addr.toHex()).toBe(testAddressLower);
		});

		it("rejects invalid bytes length", () => {
			const invalidBytes = new Uint8Array(19);
			expect(() => new Address({ value: invalidBytes })).toThrow();
		});

		it("converts to checksummed address", () => {
			const addr = Address.fromHex(testAddress);
			const checksummed = addr.toChecksummed();
			expect(checksummed).toContain("0x742d35Cc");
		});

		it("checks equality", () => {
			const addr1 = Address.fromHex(testAddress);
			const addr2 = Address.fromHex(testAddress.toLowerCase());
			expect(addr1.equals(addr2)).toBe(true);
		});

		it("compares addresses lexicographically", () => {
			const addr1 = Address.from(10n);
			const addr2 = Address.from(20n);
			const addr3 = Address.from(10n);

			expect(addr1.compare(addr2)).toBe(-1);
			expect(addr2.compare(addr1)).toBe(1);
			expect(addr1.compare(addr3)).toBe(0);
		});

		it("clones address", () => {
			const addr1 = Address.fromHex(testAddress);
			const addr2 = addr1.clone();
			expect(addr1.equals(addr2)).toBe(true);
			expect(addr1.address).not.toBe(addr2.address); // Different instances
		});

		it("calculates CREATE address", () => {
			const deployer = Address.fromHex(testAddress);
			const created = deployer.calculateCreateAddress(0n);
			expect(created.isZero()).toBe(false);
		});

		it("calculates CREATE2 address", () => {
			const deployer = Address.fromHex(testAddress);
			const salt = new Uint8Array(32);
			const initCode = new Uint8Array(0);
			const created = deployer.calculateCreate2Address(salt, initCode);
			expect(created.isZero()).toBe(false);
		});

		it("checks zero address", () => {
			const zero = Address.zero();
			expect(zero.isZero()).toBe(true);
		});
	});

	describe("ChecksumAddress class", () => {
		it("creates ChecksumAddress from hex string", () => {
			const addr = ChecksumAddress.from(testAddress);
			expect(addr.checksummed).toContain("0x742d35Cc");
		});

		it("validates EIP-55 checksum", () => {
			// Correct checksum (generated by the implementation)
			const correctChecksum = "0x742d35Cc6634c0532925a3b844bc9e7595F251E3";
			expect(ChecksumAddress.isValid(correctChecksum)).toBe(true);

			// Wrong checksum fails
			expect(
				ChecksumAddress.isValid("0x742d35Cc6634C0532925a3b844Bc9e7595f251e3"),
			).toBe(false);
			expect(
				ChecksumAddress.isValid("0x742d35CC6634C0532925a3b844Bc9e7595f251e3"),
			).toBe(false);
		});

		it("converts to Address", () => {
			const checksumAddr = ChecksumAddress.from(testAddress);
			const addr = checksumAddr.toAddress();
			expect(addr.toHex()).toBe(testAddressLower);
		});

		it("rejects invalid checksum in schema", () => {
			const wrongChecksum = "0x742d35CC6634C0532925a3b844Bc9e7595f251e3";
			expect(() => new ChecksumAddress({ value: wrongChecksum })).toThrow();
		});
	});

	describe("AddressFromHex transform", () => {
		it("decodes hex string to Address", () => {
			const decode = Schema.decodeUnknownSync(AddressFromHex);
			const addr = decode(testAddress);
			expect(addr).toBeInstanceOf(Address);
			expect(addr.toHex()).toBe(testAddressLower);
		});

		it("encodes Address to hex string", () => {
			const encode = Schema.encodeSync(AddressFromHex);
			const addr = Address.fromHex(testAddress);
			const hex = encode(addr);
			expect(hex).toBe(testAddressLower);
		});

		it("rejects invalid hex strings", () => {
			const decode = Schema.decodeUnknownSync(AddressFromHex);
			expect(() => decode("invalid")).toThrow();
			expect(() => decode("0x123")).toThrow();
		});
	});

	describe("AddressFromUnknown transform", () => {
		it("decodes various input types", () => {
			const decode = Schema.decodeUnknownSync(AddressFromUnknown);

			const fromHex = decode(testAddress);
			expect(fromHex).toBeInstanceOf(Address);
			expect(fromHex.toHex()).toBe(testAddressLower);

			const fromNumber = decode(12345n);
			expect(fromNumber).toBeInstanceOf(Address);
			expect(fromNumber.toU256()).toBe(12345n);

			const fromBytes = decode(new Uint8Array(20));
			expect(fromBytes).toBeInstanceOf(Address);
			expect(fromBytes.isZero()).toBe(true);
		});

		it("encodes Address to bytes", () => {
			const encode = Schema.encodeSync(AddressFromUnknown);
			const addr = Address.fromHex(testAddress);
			const bytes = encode(addr);
			expect(bytes).toBeInstanceOf(Uint8Array);
			expect(bytes.length).toBe(20);
		});
	});

	describe("Effect integration", () => {
		it("works with Effect.gen", async () => {
			const program = Effect.gen(function* () {
				const addr = yield* Effect.sync(() => Address.fromHex(testAddress));
				return addr.toHex();
			});

			const result = await Effect.runPromise(program);
			expect(result).toBe(testAddressLower);
		});

		it("handles validation errors with Effect.try", async () => {
			const program = Effect.try({
				try: () => new Address({ value: new Uint8Array(19) }),
				catch: (error) => new Error(`Validation failed: ${error}`),
			});

			const result = await Effect.runPromise(Effect.either(program));
			expect(result._tag).toBe("Left");
		});

		it("chains Address operations with Effect", async () => {
			const program = Effect.gen(function* () {
				const addr = yield* Effect.sync(() => Address.fromHex(testAddress));
				const checksummed = yield* Effect.sync(() => addr.toChecksummed());
				const checksumAddr = yield* Effect.sync(() =>
					ChecksumAddress.from(checksummed),
				);
				return checksumAddr.checksummed;
			});

			const result = await Effect.runPromise(program);
			expect(result).toContain("0x742d35Cc");
		});

		it("validates with Schema.parseSync", () => {
			const validBytes = BrandedAddress.from(testAddress);
			const addr = Schema.decodeUnknownSync(Schema.instanceOf(Address))(
				new Address({ value: validBytes }),
			);
			expect(addr).toBeInstanceOf(Address);
		});
	});
});
