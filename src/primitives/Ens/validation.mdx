---
title: Validation
description: ENS name validation rules, character sets, and constraints
---

import { Tabs, TabItem, Aside } from '@astrojs/starlight/components';

# ENS Name Validation

ENS names must follow ENSIP-15 validation rules to ensure security, uniqueness, and proper resolution.

## Overview

Validation checks occur during normalization. Invalid names throw specific error types indicating the validation failure.

## Validation Rules

### Character Set

Valid ENS names contain:

- **ASCII lowercase**: `a-z`
- **ASCII digits**: `0-9`
- **Hyphen**: `-` (not at start/end)
- **Unicode letters**: From approved scripts
- **Emoji**: Valid emoji sequences

**Invalid characters:**

- ASCII uppercase (normalized to lowercase)
- Control characters (`\x00-\x1F`)
- Whitespace (except normalized spaces)
- Special symbols (unless part of allowed Unicode)
- Zero-width characters (except ZWJ/ZWNJ in valid sequences)

```typescript
import * as Ens from '@tevm/voltaire/Ens';
import { DisallowedCharacterError } from '@tevm/voltaire/Ens';

// Valid
Ens.normalize('vitalik.eth')      // ‚úì
Ens.normalize('my-name.eth')      // ‚úì
Ens.normalize('123.eth')          // ‚úì
Ens.normalize('caf√©.eth')         // ‚úì
Ens.normalize('üöÄ.eth')           // ‚úì

// Invalid - throws DisallowedCharacterError
Ens.normalize('my name.eth')      // ‚úó space
Ens.normalize('my_name.eth')      // ‚úó underscore
Ens.normalize('my@name.eth')      // ‚úó special char
Ens.normalize('my\x00name.eth')   // ‚úó null byte
```

### Label Length

Each label (segment between dots) has constraints:

- **Minimum**: 1 character (no empty labels)
- **Maximum**: 255 bytes (DNS limit)
- **Total name**: 255 bytes maximum

```typescript
// Valid lengths
Ens.normalize('a.eth')              // 1 char label ‚úì
Ens.normalize('verylongname.eth')   // Long label ‚úì

// Invalid - empty label
try {
  Ens.normalize('..eth')            // ‚úó
} catch (err) {
  // EmptyLabelError
}

try {
  Ens.normalize('.eth')             // ‚úó
} catch (err) {
  // EmptyLabelError
}

try {
  Ens.normalize('name..eth')        // ‚úó
} catch (err) {
  // EmptyLabelError
}
```

### Label Extension Rules

Labels cannot have double-hyphen at positions 2-3 (reserved for punycode):

```typescript
import { InvalidLabelExtensionError } from '@tevm/voltaire/Ens';

// Valid hyphen usage
Ens.normalize('my-name.eth')       // ‚úì
Ens.normalize('a-b-c.eth')         // ‚úì
Ens.normalize('x--y.eth')          // ‚úì (position 1-2)

// Invalid - double-hyphen at positions 2-3
try {
  Ens.normalize('ab--cd.eth')      // ‚úó
} catch (err) {
  // InvalidLabelExtensionError
}

try {
  Ens.normalize('xx--yy.eth')      // ‚úó
} catch (err) {
  // InvalidLabelExtensionError
}
```

### Script Mixing

Names cannot mix incompatible scripts to prevent homograph attacks:

```typescript
import { IllegalMixtureError } from '@tevm/voltaire/Ens';

// Valid - single script
Ens.normalize('hello.eth')         // ‚úì Latin
Ens.normalize('–ø—Ä–∏–≤–µ—Ç.eth')        // ‚úì Cyrillic
Ens.normalize('‰Ω†Â•Ω.eth')          // ‚úì Han

// Invalid - mixed scripts
try {
  Ens.normalize('hello–ø—Ä–∏–≤–µ—Ç.eth') // ‚úó Latin + Cyrillic
} catch (err) {
  // IllegalMixtureError
}

try {
  Ens.normalize('hello‰Ω†Â•Ω.eth')    // ‚úó Latin + Han
} catch (err) {
  // IllegalMixtureError
}
```

**Allowed script combinations:**

- Latin + Common (numbers, punctuation)
- Any script + Emoji
- Han + Hiragana + Katakana (Japanese)

### Confusables

Names that visually resemble different scripts are rejected:

```typescript
import { WholeConfusableError } from '@tevm/voltaire/Ens';

// Invalid - whole confusable
try {
  // "scope" using Cyrillic lookalikes: —ï—Å–æ—Ä–µ
  Ens.normalize('—ï—Å–æ—Ä–µ.eth')       // ‚úó
} catch (err) {
  // WholeConfusableError
}

try {
  // "apple" using Greek omicron: –∞pple
  Ens.normalize('–∞pple.eth')       // ‚úó
} catch (err) {
  // WholeConfusableError
}
```

Common confusables:

| Latin | Confusable | Script |
|-------|------------|--------|
| `a` | `–∞` | Cyrillic |
| `c` | `—Å` | Cyrillic |
| `e` | `–µ` | Cyrillic |
| `o` | `–æ` | Cyrillic |
| `p` | `—Ä` | Cyrillic |
| `x` | `—Ö` | Cyrillic |
| `o` | `Œø` | Greek |
| `l` | `I` (uppercase i) | Latin |

### UTF-8 Encoding

Names must be valid UTF-8:

```typescript
import { InvalidUtf8Error } from '@tevm/voltaire/Ens';

// Valid UTF-8
Ens.normalize('caf√©.eth')          // ‚úì
Ens.normalize('üöÄ.eth')            // ‚úì

// Invalid UTF-8 sequences throw InvalidUtf8Error
// (typically only when reading from binary data)
```

## Validation Functions

### Manual Validation

Check if name is valid without normalizing:

```typescript
import * as Ens from '@tevm/voltaire/Ens';

function isValidEnsName(name: string): boolean {
  try {
    Ens.normalize(name);
    return true;
  } catch {
    return false;
  }
}

isValidEnsName('vitalik.eth')      // true
isValidEnsName('invalid..eth')     // false
isValidEnsName('my_name.eth')      // false
```

### Get Validation Errors

Determine specific validation failure:

```typescript
import * as Ens from '@tevm/voltaire/Ens';
import {
  DisallowedCharacterError,
  EmptyLabelError,
  InvalidLabelExtensionError,
  IllegalMixtureError,
  WholeConfusableError,
  InvalidUtf8Error,
} from '@tevm/voltaire/Ens';

function getValidationError(name: string): string | null {
  try {
    Ens.normalize(name);
    return null; // Valid
  } catch (err) {
    if (err instanceof DisallowedCharacterError) {
      return 'Contains disallowed characters';
    }
    if (err instanceof EmptyLabelError) {
      return 'Contains empty label';
    }
    if (err instanceof InvalidLabelExtensionError) {
      return 'Invalid label extension (-- at positions 2-3)';
    }
    if (err instanceof IllegalMixtureError) {
      return 'Mixes incompatible scripts';
    }
    if (err instanceof WholeConfusableError) {
      return 'Visually confusable with different script';
    }
    if (err instanceof InvalidUtf8Error) {
      return 'Invalid UTF-8 encoding';
    }
    return 'Unknown validation error';
  }
}

getValidationError('vitalik.eth')     // null
getValidationError('..eth')           // "Contains empty label"
getValidationError('my_name.eth')     // "Contains disallowed characters"
```

## Best Practices

### Pre-validation UI

Validate user input before submission:

```typescript
import * as Ens from '@tevm/voltaire/Ens';

function validateEnsInput(input: string): {
  valid: boolean;
  normalized?: string;
  error?: string;
} {
  try {
    const normalized = Ens.normalize(input);
    return { valid: true, normalized };
  } catch (err) {
    return {
      valid: false,
      error: err instanceof Error ? err.message : 'Invalid ENS name',
    };
  }
}

// In React component
const [input, setInput] = useState('');
const validation = validateEnsInput(input);

<input
  value={input}
  onChange={(e) => setInput(e.target.value)}
  className={validation.valid ? 'valid' : 'invalid'}
/>
{!validation.valid && <p>{validation.error}</p>}
```

### Normalized Storage

Always store normalized form:

```typescript
import * as Ens from '@tevm/voltaire/Ens';

// User enters: "MyName.ETH"
const userInput = "MyName.ETH";

// Store normalized
const normalized = Ens.normalize(userInput);
await db.saveEnsName(normalized); // "myname.eth"

// Later lookups use normalized form
const stored = await db.getEnsName();
const address = await registry.resolver(namehash(stored));
```

### Case-Insensitive Search

Search by normalized form:

```typescript
import * as Ens from '@tevm/voltaire/Ens';

function searchEnsNames(query: string, names: string[]): string[] {
  try {
    const normalizedQuery = Ens.normalize(query);
    return names.filter(name => {
      try {
        return Ens.normalize(name) === normalizedQuery;
      } catch {
        return false;
      }
    });
  } catch {
    return [];
  }
}

const names = ['vitalik.eth', 'VITALIK.ETH', 'bob.eth'];
searchEnsNames('VITALIK', names); // ['vitalik.eth', 'VITALIK.ETH']
```

## Common Validation Patterns

### Registration Flow

```typescript
async function registerEnsName(name: string) {
  // 1. Validate and normalize
  let normalized: string;
  try {
    normalized = Ens.normalize(name);
  } catch (err) {
    throw new Error(`Invalid ENS name: ${err.message}`);
  }

  // 2. Check availability
  const node = namehash(normalized);
  const available = await registry.available(node);
  if (!available) {
    throw new Error('Name already registered');
  }

  // 3. Register
  await registry.register(normalized);
}
```

### Resolution Flow

```typescript
async function resolveEnsName(name: string): Promise<Address> {
  // 1. Normalize
  const normalized = Ens.normalize(name);

  // 2. Compute namehash
  const node = namehash(normalized);

  // 3. Resolve
  const resolver = await registry.resolver(node);
  return await resolver.addr(node);
}
```

## References

- [ENSIP-15: Name Normalization](https://docs.ens.domains/ensip/15) - Validation spec
- [Unicode Security](https://www.unicode.org/reports/tr39/) - Confusables and scripts
- [DNS RFC1035](https://datatracker.ietf.org/doc/html/rfc1035) - Label length limits

## See Also

- [Normalization](/primitives/ens/normalization) - Normalization process
- [Security](/primitives/ens/security) - Security considerations
- [Errors](/primitives/ens/errors) - Error types and handling
- [ENSIP Standards](/primitives/ens/ensip-standards) - ENS specifications
