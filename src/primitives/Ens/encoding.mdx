---
title: Encoding
description: Namehash, labelhash, and DNS encoding for ENS names
---

import { Tabs, TabItem, Aside } from '@astrojs/starlight/components';

# ENS Name Encoding

ENS names are encoded using several algorithms for different purposes: namehash for registry lookups, labelhash for label identification, and DNS wire format for efficient on-chain storage.

## Namehash

Namehash is the fundamental algorithm for converting human-readable ENS names into fixed-length 32-byte hashes used by the ENS Registry.

### Algorithm

Namehash recursively hashes name components from right to left:

```
namehash('') = 0x0000000000000000000000000000000000000000000000000000000000000000
namehash(label.parent) = keccak256(namehash(parent) + labelhash(label))
```

### Implementation

```typescript
import * as Hash from '@tevm/voltaire/Hash';
import * as Keccak from '@tevm/voltaire/crypto/Keccak';
import * as Ens from '@tevm/voltaire/Ens';

function namehash(name: string): Hash.Hash {
  // Normalize first (REQUIRED)
  const normalized = Ens.normalize(name);

  // Split into labels
  const labels = normalized.split('.').reverse();

  // Start with zero hash for root
  let node = new Uint8Array(32); // 0x00...00

  // Process each label
  for (const label of labels) {
    const labelHash = labelhash(label);
    const combined = new Uint8Array(64);
    combined.set(node, 0);
    combined.set(labelHash, 32);
    node = Keccak.keccak256(combined);
  }

  return Hash.from(node);
}

function labelhash(label: string): Hash.Hash {
  const bytes = new TextEncoder().encode(label);
  return Hash.from(Keccak.keccak256(bytes));
}
```

### Examples

```typescript
// Root node (empty string)
namehash('')
// 0x0000000000000000000000000000000000000000000000000000000000000000

// TLD: .eth
namehash('eth')
// 0x93cdeb708b7545dc668eb9280176169d1c33cfd8ed6f04690a0bcc88a93fc4ae

// Second-level: vitalik.eth
namehash('vitalik.eth')
// 0xee6c4522aab0003e8d14cd40a6af439055fd2577951148c14b6cea9a53475835

// Subdomain: sub.vitalik.eth
namehash('sub.vitalik.eth')
// Different hash (includes parent hash)
```

### Known Name Hashes

Common ENS names and their namehash values:

| Name | Namehash |
|------|----------|
| `eth` | `0x93cdeb708b7545dc668eb9280176169d1c33cfd8ed6f04690a0bcc88a93fc4ae` |
| `vitalik.eth` | `0xee6c4522aab0003e8d14cd40a6af439055fd2577951148c14b6cea9a53475835` |
| `resolver.eth` | `0xfdd5d5de6dd63db72bbc2d487944ba13bf775b50a80805fe6fcaba9b0fba88f5` |
| `reverse` | `0xa097f6721ce401e757d1223a763fef49b8b5f90bb18567ddb86fd205dff71d34` |
| `addr.reverse` | `0x91d1777781884d03a6757a803996e38de2a42967fb37eeaca72729271025a9e2` |

<Aside type="caution">
Always normalize ENS names before computing namehash. Non-normalized names will produce different hashes:

```typescript
namehash('VITALIK.ETH') !== namehash('vitalik.eth') // WRONG!
```
</Aside>

## Labelhash

Labelhash is the Keccak-256 hash of a single label (segment between dots).

### Usage

```typescript
import * as Keccak from '@tevm/voltaire/crypto/Keccak';
import * as Hash from '@tevm/voltaire/Hash';

function labelhash(label: string): Hash.Hash {
  const bytes = new TextEncoder().encode(label);
  return Hash.from(Keccak.keccak256(bytes));
}

// Examples
labelhash('vitalik')
// 0xaf2caa1c2ca1d027f1ac823b529d0a67cd144264b2789fa2ea4d63a67c7103cc

labelhash('eth')
// 0x4f5b812789fc606be1b3b16908db13fc7a9adf7ca72641f84d75b47069d3d7f0

labelhash('resolver')
// 0xf56fe9e2c7fb03fd79e1e0bc54c6d5c8e0c935c1f6d3a9f0b1e23d4c5a6b7c8d
```

### In ENS Registry

Labelhash is used for:
- Subdomain registration
- Name wrapper token IDs
- Label-based lookups

```solidity
// ENS Registry setSubnodeOwner
function setSubnodeOwner(
    bytes32 node,        // namehash(parent)
    bytes32 labelhash,   // labelhash(label)
    address owner
) external;
```

## DNS Wire Format

DNS wire format provides efficient on-chain storage for ENS names, used by Name Wrapper and ENSIP-10 wildcard resolution.

### Format

Names encoded as length-prefixed labels:

```
<length><label><length><label>...<0x00>
```

### Implementation

```typescript
function dnsEncode(name: string): Uint8Array {
  // Normalize first
  const normalized = Ens.normalize(name);

  // Split into labels
  const labels = normalized.split('.');

  // Calculate total length
  let totalLength = 1; // Trailing 0x00
  for (const label of labels) {
    totalLength += 1 + new TextEncoder().encode(label).length;
  }

  // Encode
  const result = new Uint8Array(totalLength);
  let offset = 0;

  for (const label of labels) {
    const bytes = new TextEncoder().encode(label);
    result[offset] = bytes.length;
    result.set(bytes, offset + 1);
    offset += 1 + bytes.length;
  }

  result[offset] = 0x00; // Null terminator
  return result;
}

function dnsDecode(encoded: Uint8Array): string {
  const labels: string[] = [];
  let offset = 0;

  while (offset < encoded.length) {
    const length = encoded[offset];
    if (length === 0) break; // Null terminator

    const labelBytes = encoded.slice(offset + 1, offset + 1 + length);
    labels.push(new TextDecoder().decode(labelBytes));
    offset += 1 + length;
  }

  return labels.join('.');
}
```

### Examples

```typescript
// vitalik.eth
dnsEncode('vitalik.eth')
// [7, 'v','i','t','a','l','i','k', 3, 'e','t','h', 0]
// Hex: 0x07766974616c696b036574680000

// sub.domain.eth
dnsEncode('sub.domain.eth')
// [3, 's','u','b', 6, 'd','o','m','a','i','n', 3, 'e','t','h', 0]
// Hex: 0x037375620646f6d61696e036574680000

// Decode back
dnsDecode(new Uint8Array([7,118,105,116,97,108,105,107,3,101,116,104,0]))
// 'vitalik.eth'
```

### ENSIP-10 Usage

Wildcard resolution uses DNS encoding for efficient parent lookups:

```typescript
// Resolve *.vitalik.eth
const dnsName = dnsEncode('anything.vitalik.eth');
// Split into labels for parent resolution
const parentDns = removeFirstLabel(dnsName);
// Look up wildcard resolver for vitalik.eth
```

<Aside type="tip">
DNS encoding is more gas-efficient than string manipulation on-chain. Label lengths enable quick parsing without scanning for delimiters.
</Aside>

## Comparison

| Encoding | Output | Use Case |
|----------|--------|----------|
| **Namehash** | 32-byte hash | Registry node lookups |
| **Labelhash** | 32-byte hash | Single label identification |
| **DNS Wire** | Variable bytes | On-chain storage, ENSIP-10 |

### When to Use Each

**Namehash:**
- Registry lookups (getResolver, getOwner)
- Resolver queries (addr, text records)
- Most common encoding

**Labelhash:**
- Subdomain registration
- Name wrapper operations
- Token ID computation

**DNS Wire:**
- Name wrapper wrapping
- ENSIP-10 wildcard resolution
- Efficient on-chain representation

## Complete Example

```typescript
import * as Ens from '@tevm/voltaire/Ens';
import * as Hash from '@tevm/voltaire/Hash';
import * as Keccak from '@tevm/voltaire/crypto/Keccak';

// User input
const userInput = "Vitalik.ETH";

// 1. Normalize
const normalized = Ens.normalize(userInput);
// "vitalik.eth"

// 2. Compute namehash for registry lookup
const node = namehash(normalized);
// 0xee6c4522aab0003e8d14cd40a6af439055fd2577951148c14b6cea9a53475835

// 3. Look up resolver in registry
const resolver = await registry.resolver(node);

// 4. Query address from resolver
const address = await resolver.addr(node);

// 5. For subdomains, compute labelhash
const subLabel = 'sub';
const subLabelHash = labelhash(subLabel);

// 6. For wrapping, use DNS encoding
const dnsEncoded = dnsEncode(normalized);
await nameWrapper.wrap(dnsEncoded, owner, duration);
```

## Zig API

```zig
const primitives = @import("primitives");
const std = @import("std");

// These encodings would be implemented in a separate ENS encoding module
// Currently voltaire focuses on normalization
// Full encoding support coming in future releases
```

## References

- [ENSIP-1: ENS Specification](https://docs.ens.domains/ensip/1) - Namehash definition
- [ENSIP-10: Wildcard Resolution](https://docs.ens.domains/ensip/10) - DNS encoding usage
- [DNS Wire Format RFC1035](https://datatracker.ietf.org/doc/html/rfc1035) - DNS protocol
- [ENS Name Processing](https://docs.ens.domains/resolution/names) - Official docs

## See Also

- [Normalization](/primitives/ens/normalization) - Name normalization (required before encoding)
- [ENSIP Standards](/primitives/ens/ensip-standards) - ENS improvement proposals
- [Usage Patterns](/primitives/ens/usage-patterns) - Real-world integration examples
- [Hash](/primitives/hash) - Hash type for namehash/labelhash results
