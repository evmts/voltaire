---
title: ENSIP Standards
description: ENS Improvement Proposals - ENSIP-1, ENSIP-10, and ENSIP-15
---

import { Tabs, TabItem, Aside, Card, CardGrid } from '@astrojs/starlight/components';

# ENSIP Standards

ENS Improvement Proposals (ENSIPs) define the ENS protocol. Key standards relevant to name handling are ENSIP-1 (namehash), ENSIP-10 (wildcard resolution), and ENSIP-15 (normalization).

## Overview

<CardGrid>
<Card title="ENSIP-1: ENS Specification" icon="document">
Foundational specification defining namehash algorithm, registry interface, and resolver protocol.
</Card>

<Card title="ENSIP-10: Wildcard Resolution" icon="puzzle">
Enables wildcard subdomain resolution using DNS wire format for efficient parent lookups.
</Card>

<Card title="ENSIP-15: Name Normalization" icon="approve-check">
Standardizes name normalization to prevent homograph attacks and ensure name uniqueness.
</Card>
</CardGrid>

## ENSIP-1: ENS Specification

Foundational ENS specification defining core protocols.

### Namehash Algorithm

Recursive hashing algorithm converting names to 32-byte node identifiers:

```
namehash('') = 0x0000000000000000000000000000000000000000000000000000000000000000
namehash(label.parent) = keccak256(namehash(parent) + labelhash(label))
```

**Implementation:**

```typescript
import * as Hash from '@tevm/voltaire/Hash';
import * as Keccak from '@tevm/voltaire/crypto/Keccak';

function namehash(name: string): Hash.Hash {
  const labels = name.split('.').reverse();
  let node = new Uint8Array(32); // Root: 0x00...00

  for (const label of labels) {
    const labelHash = Keccak.keccak256(new TextEncoder().encode(label));
    const combined = new Uint8Array(64);
    combined.set(node, 0);
    combined.set(labelHash, 32);
    node = Keccak.keccak256(combined);
  }

  return Hash.from(node);
}
```

**Examples:**

```typescript
namehash('')
// 0x0000000000000000000000000000000000000000000000000000000000000000

namehash('eth')
// 0x93cdeb708b7545dc668eb9280176169d1c33cfd8ed6f04690a0bcc88a93fc4ae

namehash('vitalik.eth')
// 0xee6c4522aab0003e8d14cd40a6af439055fd2577951148c14b6cea9a53475835
```

### Registry Interface

ENS Registry stores node ownership and resolver addresses:

```solidity
interface ENS {
    function owner(bytes32 node) external view returns (address);
    function resolver(bytes32 node) external view returns (address);
    function ttl(bytes32 node) external view returns (uint64);

    function setOwner(bytes32 node, address owner) external;
    function setSubnodeOwner(bytes32 node, bytes32 label, address owner) external;
    function setResolver(bytes32 node, address resolver) external;
    function setTTL(bytes32 node, uint64 ttl) external;
}
```

**Usage:**

```typescript
import * as Ens from '@tevm/voltaire/Ens';

// Normalize name (ENSIP-15)
const normalized = Ens.normalize('vitalik.eth');

// Compute namehash (ENSIP-1)
const node = namehash(normalized);

// Query registry
const resolverAddress = await registry.resolver(node);
```

### Resolver Interface

Resolvers translate names to addresses and other records:

```solidity
interface Resolver {
    function addr(bytes32 node) external view returns (address);
    function text(bytes32 node, string key) external view returns (string);
    function contenthash(bytes32 node) external view returns (bytes);
}
```

<Aside type="note">
ENSIP-1 requires normalization before namehash computation, but doesn't specify the normalization algorithm. ENSIP-15 fills this gap.
</Aside>

## ENSIP-10: Wildcard Resolution

Enables wildcard subdomain resolution without explicit registration.

### DNS Wire Format

Names encoded as length-prefixed labels for efficient on-chain parsing:

```
<length><label><length><label>...<0x00>
```

**Implementation:**

```typescript
function dnsEncode(name: string): Uint8Array {
  const labels = name.split('.');
  let totalLength = 1; // Trailing 0x00

  for (const label of labels) {
    totalLength += 1 + new TextEncoder().encode(label).length;
  }

  const result = new Uint8Array(totalLength);
  let offset = 0;

  for (const label of labels) {
    const bytes = new TextEncoder().encode(label);
    result[offset] = bytes.length;
    result.set(bytes, offset + 1);
    offset += 1 + bytes.length;
  }

  result[offset] = 0x00;
  return result;
}
```

**Examples:**

```typescript
dnsEncode('vitalik.eth')
// [7, 'v','i','t','a','l','i','k', 3, 'e','t','h', 0]
// Hex: 0x07766974616c696b036574680000

dnsEncode('sub.domain.eth')
// [3, 's','u','b', 6, 'd','o','m','a','i','n', 3, 'e','t','h', 0]
```

### Wildcard Resolution Algorithm

1. Resolve name normally (check if resolver set)
2. If no resolver, strip leftmost label
3. Check parent for resolver
4. If resolver supports ENSIP-10, resolve with full name
5. Repeat up to root if needed

**Example:**

```typescript
// Resolve foo.bar.vitalik.eth

// Step 1: Check foo.bar.vitalik.eth
const node1 = namehash('foo.bar.vitalik.eth');
let resolver = await registry.resolver(node1);

if (!resolver) {
  // Step 2: Strip leftmost label, check bar.vitalik.eth
  const node2 = namehash('bar.vitalik.eth');
  resolver = await registry.resolver(node2);
}

if (!resolver) {
  // Step 3: Check vitalik.eth
  const node3 = namehash('vitalik.eth');
  resolver = await registry.resolver(node3);
}

if (resolver) {
  // Step 4: Query resolver with original full name
  const dnsName = dnsEncode('foo.bar.vitalik.eth');
  const address = await resolver.resolve(dnsName, /* addr selector */);
}
```

### Wildcard Resolver Interface

Extended resolver supporting ENSIP-10:

```solidity
interface IExtendedResolver {
    function resolve(
        bytes calldata name,      // DNS-encoded name
        bytes calldata data       // Resolver function selector + args
    ) external view returns (bytes);
}
```

<Aside type="tip">
ENSIP-10 enables services like ENS subdomains-as-a-service. Users get `user.service.eth` without individual registrations.
</Aside>

## ENSIP-15: Name Normalization

Standardizes normalization to prevent homograph attacks and ensure uniqueness.

### Normalization Steps

1. **Validate**: Check character set, script mixing, confusables
2. **NFC Normalize**: Apply Unicode NFC normalization
3. **Case Fold**: Convert to lowercase
4. **Validate Labels**: Check label constraints (empty, extension)

**Implementation (Voltaire):**

```typescript
import * as Ens from '@tevm/voltaire/Ens';

// User input
const userInput = "Vitalik.ETH";

// Normalize (ENSIP-15)
const normalized = Ens.normalize(userInput);
// "vitalik.eth"

// Now safe to use with namehash (ENSIP-1)
const node = namehash(normalized);
```

### Validation Rules

**Allowed Characters:**
- ASCII lowercase: `a-z`
- ASCII digits: `0-9`
- Hyphen: `-`
- Unicode letters from approved scripts
- Valid emoji sequences

**Rejected Patterns:**
- Empty labels: `..eth`
- Label extension: `ab--cd.eth`
- Mixed scripts: `helloпривет.eth`
- Confusables: `pаypal.eth` (Cyrillic а)
- Zero-width: `vita\u200Blik.eth`

### Security Properties

ENSIP-15 provides critical security guarantees:

1. **Uniqueness**: Each normalized name maps to exactly one node
2. **Homograph prevention**: Visually similar names rejected
3. **Script safety**: Incompatible script mixing blocked
4. **Consistency**: Same normalization across all implementations

```typescript
// All normalize to same value
Ens.normalize('VITALIK.ETH')  === 'vitalik.eth'
Ens.normalize('Vitalik.eth')  === 'vitalik.eth'
Ens.normalize('vitalik.eth')  === 'vitalik.eth'

// Different inputs must produce different outputs
Ens.normalize('alice.eth')    !== Ens.normalize('bob.eth')

// Homographs rejected (throw WholeConfusableError)
Ens.normalize('vіtalik.eth')  // ✗ throws (Cyrillic і)
```

## Standard Interaction

### Full Resolution Flow

Complete name resolution using all three standards:

```typescript
import * as Ens from '@tevm/voltaire/Ens';
import * as Address from '@tevm/voltaire/Address';

async function resolveEnsName(name: string): Promise<Address.Address> {
  // ENSIP-15: Normalize
  const normalized = Ens.normalize(name);

  // ENSIP-1: Compute namehash
  const node = namehash(normalized);

  // ENSIP-1: Query registry
  let resolverAddress = await registry.resolver(node);

  // ENSIP-10: If no resolver, try wildcard
  if (resolverAddress === Address.ZERO) {
    const labels = normalized.split('.');

    for (let i = 1; i < labels.length; i++) {
      const parentName = labels.slice(i).join('.');
      const parentNode = namehash(parentName);
      resolverAddress = await registry.resolver(parentNode);

      if (resolverAddress !== Address.ZERO) {
        // Found wildcard resolver
        const dnsName = dnsEncode(normalized);
        return await resolver.resolve(dnsName);
      }
    }

    throw new Error('No resolver found');
  }

  // ENSIP-1: Query resolver
  const resolver = await getResolverContract(resolverAddress);
  return Address.from(await resolver.addr(node));
}
```

### Registration Flow

```typescript
async function registerEnsName(name: string) {
  // ENSIP-15: Normalize and validate
  const normalized = Ens.normalize(name);

  // ENSIP-1: Compute namehash
  const node = namehash(normalized);

  // Check availability
  const owner = await registry.owner(node);
  if (owner !== Address.ZERO) {
    throw new Error('Name already registered');
  }

  // Register
  const tx = await registrar.register(normalized);
  return tx.hash;
}
```

## References

### Official Specifications

- [ENSIP-1: ENS](https://docs.ens.domains/ensip/1) - ENS Specification
- [ENSIP-10: Wildcard Resolution](https://docs.ens.domains/ensip/10) - Wildcard spec
- [ENSIP-15: Normalization](https://docs.ens.domains/ensip/15) - Normalization spec

### Related Standards

- [ENSIP-7: Contenthash](https://docs.ens.domains/ensip/7) - Content hash records
- [ENSIP-9: Multichain Addresses](https://docs.ens.domains/ensip/9) - Multi-chain address resolution
- [ENSIP-16: Offchain Resolvers](https://docs.ens.domains/ensip/16) - Offchain data resolution

### External References

- [RFC 1035: DNS](https://datatracker.ietf.org/doc/html/rfc1035) - DNS wire format
- [UAX #15: Unicode Normalization](https://unicode.org/reports/tr15/) - NFC normalization
- [UTS #39: Unicode Security](https://www.unicode.org/reports/tr39/) - Confusables

## See Also

- [Encoding](/primitives/ens/encoding) - Namehash and DNS encoding
- [Normalization](/primitives/ens/normalization) - ENSIP-15 implementation
- [Security](/primitives/ens/security) - Security considerations
- [Usage Patterns](/primitives/ens/usage-patterns) - Integration examples
