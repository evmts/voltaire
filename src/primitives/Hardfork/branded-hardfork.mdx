---
title: "BrandedHardfork"
---

# BrandedHardfork

Branded type pattern for type-safe hardfork representation.

## Overview

BrandedHardfork uses TypeScript's branded type pattern to create a distinct type from strings while maintaining runtime string behavior.

```typescript
type BrandedHardfork = string & { readonly __tag: "Hardfork" };
```

## Type Definition

### BrandedHardfork Type

```typescript
/**
 * Branded Hardfork type
 *
 * Hardfork is a branded string type that represents Ethereum protocol upgrades.
 * Each hardfork represents a protocol upgrade that changes EVM behavior,
 * gas costs, or adds new features.
 */
export type BrandedHardfork = string & {
  readonly __tag: "Hardfork";
};
```

**Key Properties:**
- Extends `string` - all string methods available
- Phantom `__tag` property - compile-time only, no runtime overhead
- Readonly - immutable by type system
- Nominal typing - distinct from plain strings

## Branded Type Pattern

### What is Branding?

Branding adds a phantom type property to distinguish similar types at compile time:

```typescript
type UserId = string & { __tag: "UserId" };
type Email = string & { __tag: "Email" };

// Compile error - types are distinct
function sendEmail(email: Email) { }
const userId: UserId = "user123" as UserId;
sendEmail(userId);  // Error: UserId not assignable to Email
```

### Why Use Branding?

**Type Safety:**
```typescript
// Without branding - both are strings
function processNetwork(hardfork: string, chainId: string) {
  // Easy to swap arguments accidentally
}

// With branding - compile-time protection
function processNetwork(hardfork: BrandedHardfork, chainId: ChainId) {
  // Arguments can't be swapped
}
```

**Runtime Behavior:**
```typescript
// Branded types are still strings at runtime
const fork: BrandedHardfork = "cancun" as BrandedHardfork;
console.log(typeof fork);  // "string"
console.log(fork.toUpperCase());  // "CANCUN"
```

**No Runtime Overhead:**
```typescript
// Phantom property doesn't exist at runtime
const fork: BrandedHardfork = "cancun" as BrandedHardfork;
console.log(fork.__tag);  // undefined (not "Hardfork")
```

## Implementation

### Constants

All hardfork constants are branded strings:

```typescript
// From constants.js
export const FRONTIER: BrandedHardfork = "frontier" as BrandedHardfork;
export const HOMESTEAD: BrandedHardfork = "homestead" as BrandedHardfork;
export const CANCUN: BrandedHardfork = "cancun" as BrandedHardfork;
// ...
```

### Factory Function

```typescript
function fromString(name: string): BrandedHardfork | undefined {
  const lower = name.toLowerCase();
  return NAME_TO_HARDFORK[lower];  // Returns branded type or undefined
}
```

### Ordering Array

```typescript
export const HARDFORK_ORDER: BrandedHardfork[] = [
  FRONTIER,
  HOMESTEAD,
  DAO,
  // ...
  OSAKA,
];
```

### Name Lookup

```typescript
export const NAME_TO_HARDFORK: Record<string, BrandedHardfork> = {
  frontier: FRONTIER,
  homestead: HOMESTEAD,
  // ...
  paris: MERGE,  // Alias
};
```

## Usage Patterns

### Type Guards

```typescript
function isBrandedHardfork(value: unknown): value is BrandedHardfork {
  if (typeof value !== "string") return false;
  return Hardfork.isValidName(value);
}

// Usage
const input: unknown = getUserInput();
if (isBrandedHardfork(input)) {
  // input is BrandedHardfork here
  Hardfork.hasEIP1559(input);
}
```

### Type Assertions

```typescript
// Safe - validated first
const fork = Hardfork.fromString("cancun");
if (fork) {
  // fork is BrandedHardfork
}

// Unsafe - skip validation (use carefully)
const fork = "cancun" as BrandedHardfork;
```

### Function Signatures

```typescript
// Clear type requirements
function estimateGas(
  fork: BrandedHardfork,
  bytecode: Uint8Array
): bigint {
  if (Hardfork.hasEIP3855(fork)) {
    // PUSH0 available
  }
  // ...
}

// Can't accidentally pass wrong type
estimateGas("cancun", data);  // Error: string not BrandedHardfork
estimateGas(CANCUN, data);    // OK
```

### Optional Parameters

```typescript
function createConfig(options: {
  hardfork?: BrandedHardfork;
  chainId: number;
}): Config {
  const fork = options.hardfork ?? DEFAULT;
  return { fork, chainId: options.chainId };
}
```

### Union Types

```typescript
type NetworkOrHardfork = Network | BrandedHardfork;

function resolve(input: NetworkOrHardfork): BrandedHardfork {
  if (isNetwork(input)) {
    return input.hardfork;
  }
  return input;
}
```

## Advantages

### 1. Compile-Time Safety

```typescript
// Prevents mixing up similar string parameters
function compare(a: BrandedHardfork, b: BrandedHardfork): number {
  return Hardfork.compare(a, b);
}

// Can't accidentally swap with other strings
const chainId = "1";
compare(CANCUN, chainId);  // Error: string not assignable to BrandedHardfork
```

### 2. Self-Documenting Code

```typescript
// Clear what type of string is expected
function getFeatures(fork: BrandedHardfork): Features {
  // Obviously dealing with hardfork, not just any string
}
```

### 3. IDE Support

```typescript
// Autocomplete knows valid operations
const fork: BrandedHardfork = CANCUN;
fork.has  // IDE suggests: hasEIP1559, hasEIP3855, hasEIP4844, etc.
```

### 4. Zero Runtime Cost

```typescript
// No runtime overhead - still just strings
const fork: BrandedHardfork = "cancun" as BrandedHardfork;
console.log(fork.length);     // 6
console.log(fork[0]);          // "c"
console.log(fork.includes("c")); // true
```

### 5. Prevents Errors

```typescript
// Common error prevention
function process(hardfork: BrandedHardfork, network: string) {
  // ...
}

// Can't swap arguments
const fork = CANCUN;
const net = "mainnet";
process(net, fork);  // Error: caught at compile time
```

## Disadvantages

### 1. Type Assertions Needed

```typescript
// Must use type assertion or factory
const fork: BrandedHardfork = "cancun" as BrandedHardfork;  // Manual
const fork2 = fromString("cancun");  // Preferred - validated
```

### 2. JSON Serialization

```typescript
// Serialized as regular string
const fork: BrandedHardfork = CANCUN;
JSON.stringify({ fork });  // '{"fork":"cancun"}'

// Deserialization loses brand
const parsed = JSON.parse('{"fork":"cancun"}');
const fork2: BrandedHardfork = parsed.fork;  // Error: string not BrandedHardfork

// Solution: validate after parsing
const fork3 = fromString(parsed.fork);  // BrandedHardfork | undefined
```

### 3. External Libraries

```typescript
// External libraries see plain strings
import externalLib from "some-lib";

const fork: BrandedHardfork = CANCUN;
externalLib.process(fork);  // Works but loses type safety inside library
```

## Best Practices

### 1. Use Factory Functions

```typescript
// Good - validated and branded
const fork = Hardfork.fromString(userInput);
if (!fork) throw new Error("Invalid hardfork");

// Bad - unsafe assertion
const fork = userInput as BrandedHardfork;
```

### 2. Type Parameters

```typescript
// Good - generic preserves branding
function map<T extends BrandedHardfork>(
  forks: T[],
  fn: (fork: T) => unknown
): unknown[] {
  return forks.map(fn);
}

// Usage preserves type
const results = map([CANCUN, SHANGHAI], fork => Hardfork.hasEIP4844(fork));
```

### 3. Const Assertions

```typescript
// Good - use exported constants
import { CANCUN } from '@tevm/voltaire';

// Acceptable for tests
const MOCK_FORK = "cancun" as const as BrandedHardfork;

// Bad - magic string
function test() {
  const fork = "cancun" as BrandedHardfork;
}
```

### 4. Validation at Boundaries

```typescript
// Validate at system boundaries
function handleApiRequest(req: Request): Response {
  const hardforkStr = req.body.hardfork;

  // Validate and brand
  const fork = Hardfork.fromString(hardforkStr);
  if (!fork) {
    return badRequest("Invalid hardfork");
  }

  // Now type-safe throughout application
  return processRequest(fork);
}
```

### 5. Documentation

```typescript
/**
 * Estimates gas for operation
 * @param fork - Ethereum hardfork version (e.g., CANCUN, SHANGHAI)
 * @param operation - Operation to estimate
 * @returns Estimated gas cost
 */
function estimateGas(fork: BrandedHardfork, operation: Operation): bigint {
  // ...
}
```

## Comparison with Alternatives

### vs Regular Strings

```typescript
// Regular strings
type Hardfork = string;
const fork: Hardfork = "cancun";
const other: Hardfork = "anything";  // No validation

// Branded strings
type BrandedHardfork = string & { __tag: "Hardfork" };
const fork: BrandedHardfork = CANCUN;
const other: BrandedHardfork = "anything";  // Error
```

### vs String Literals

```typescript
// String literals - finite set, verbose
type Hardfork = "frontier" | "homestead" | "dao" | /* ... 16 more */;

// Branded - simpler, extensible
type BrandedHardfork = string & { __tag: "Hardfork" };
```

### vs Enums

```typescript
// Enum - runtime overhead, non-string
enum Hardfork { FRONTIER, HOMESTEAD, CANCUN }
const fork = Hardfork.CANCUN;  // 2 (number)

// Branded - zero overhead, string
type BrandedHardfork = string & { __tag: "Hardfork" };
const fork: BrandedHardfork = "cancun" as BrandedHardfork;
```

### vs Classes

```typescript
// Class - runtime overhead, complex
class Hardfork {
  constructor(private name: string) {}
  toString(): string { return this.name; }
}

// Branded - zero overhead, simple
type BrandedHardfork = string & { __tag: "Hardfork" };
```

## Advanced Patterns

### Conditional Types

```typescript
type ExtractHardfork<T> = T extends BrandedHardfork ? T : never;

type Mixed = string | BrandedHardfork | number;
type OnlyForks = ExtractHardfork<Mixed>;  // BrandedHardfork
```

### Mapped Types

```typescript
type HardforkConfig<T> = {
  [K in keyof T]: BrandedHardfork;
};

type Config = {
  network: string;
  fork: string;
};

type BrandedConfig = HardforkConfig<Pick<Config, "fork">>;
// { fork: BrandedHardfork }
```

### Template Literals

```typescript
type HardforkMessage = `Hardfork: ${BrandedHardfork}`;

const msg: HardforkMessage = `Hardfork: ${CANCUN}`;  // OK
```

## Related Branded Types

Similar pattern used throughout primitives:

```typescript
// Address primitive
type BrandedAddress = Uint8Array & { __tag: "Address" };

// Hex primitive
type BrandedHex = string & { __tag: "Hex" };

// Hash primitive
type BrandedHash = Uint8Array & { __tag: "Hash" };
```

**Consistency Benefits:**
- Similar API patterns across primitives
- Predictable type safety
- Zero runtime overhead across all types

## Related

- [index.mdx](./index.mdx) - Main documentation
- [usage-patterns.mdx](./usage-patterns.mdx) - Real-world usage
- [utilities.mdx](./utilities.mdx) - Factory and validation functions
