# Utility Functions

Helper functions for hardfork manipulation, validation, and introspection.

## Overview

Utility functions provide string conversion, validation, collection operations, and range generation for hardforks.

```typescript
import { Hardfork } from '@tevm/voltaire';

const names = Hardfork.allNames();
const validated = Hardfork.isValidName("cancun");
```

## String Operations

### fromString

Parse hardfork from string name (case-insensitive).

```typescript
Hardfork.fromString(name: string): BrandedHardfork | undefined
```

**Parameters:**
- `name` - Hardfork name (case-insensitive)

**Returns:**
- Hardfork if valid
- `undefined` if invalid

**Features:**
- Case-insensitive matching
- Supports aliases ("paris" → MERGE, "constantinoplefix" → PETERSBURG)
- Strips comparison operators (">=Cancun" → CANCUN)

**Example:**
```typescript
import { Hardfork } from '@tevm/voltaire';

// Basic parsing
Hardfork.fromString("cancun");      // CANCUN
Hardfork.fromString("Cancun");      // CANCUN (case-insensitive)
Hardfork.fromString("CANCUN");      // CANCUN

// Aliases
Hardfork.fromString("paris");              // MERGE
Hardfork.fromString("constantinoplefix");  // PETERSBURG

// Operator stripping
Hardfork.fromString(">=Cancun");    // CANCUN
Hardfork.fromString(">Shanghai");   // SHANGHAI
Hardfork.fromString("<=Berlin");    // BERLIN

// Invalid
Hardfork.fromString("invalid");     // undefined
Hardfork.fromString("");            // undefined
```

**Use Case:**
```typescript
function parseConfig(config: { hardfork?: string }) {
  const hardforkStr = config.hardfork ?? "prague";
  const fork = Hardfork.fromString(hardforkStr);

  if (!fork) {
    throw new Error(`Invalid hardfork: ${hardforkStr}`);
  }

  return fork;
}
```

**Supported Aliases:**

| Alias | Maps To | Reason |
|-------|---------|--------|
| paris | merge | Consensus layer name |
| constantinoplefix | petersburg | Alternative name |

---

### toString

Convert hardfork to string name.

```typescript
Hardfork.toString(fork: BrandedHardfork): string
```

**Parameters:**
- `fork` - Hardfork to convert

**Returns:**
- Lowercase hardfork name

**Example:**
```typescript
import { CANCUN, MERGE, PETERSBURG } from '@tevm/voltaire';

Hardfork.toString(CANCUN);      // "cancun"
Hardfork.toString(MERGE);       // "merge" (not "paris")
Hardfork.toString(PETERSBURG);  // "petersburg" (not "constantinoplefix")
```

**Note:** Returns canonical name, not aliases.

**Use Case:**
```typescript
function logHardforkInfo(fork: BrandedHardfork) {
  const name = Hardfork.toString(fork);
  console.log(`Current hardfork: ${name}`);
}
```

---

### isValidName

Validate if string is a valid hardfork name.

```typescript
Hardfork.isValidName(name: string): boolean
```

**Parameters:**
- `name` - String to validate

**Returns:**
- `true` if valid hardfork name
- `false` otherwise

**Example:**
```typescript
import { Hardfork } from '@tevm/voltaire';

Hardfork.isValidName("cancun");              // true
Hardfork.isValidName("Cancun");              // true (case-insensitive)
Hardfork.isValidName("paris");               // true (alias)
Hardfork.isValidName("constantinoplefix");   // true (alias)
Hardfork.isValidName("invalid");             // false
Hardfork.isValidName("");                    // false
Hardfork.isValidName(">=Cancun");            // false (operators not stripped)
```

**Use Case:**
```typescript
function validateUserInput(input: string): void {
  if (!Hardfork.isValidName(input)) {
    throw new Error(`Invalid hardfork name: ${input}`);
  }
}
```

---

## Collection Operations

### allNames

Get all hardfork names in chronological order.

```typescript
Hardfork.allNames(): string[]
```

**Returns:**
- Array of all hardfork names (lowercase, chronological order)

**Example:**
```typescript
import { Hardfork } from '@tevm/voltaire';

const names = Hardfork.allNames();
// [
//   "frontier", "homestead", "dao", "tangerinewhistle",
//   "spuriousdragon", "byzantium", "constantinople",
//   "petersburg", "istanbul", "muirglacier", "berlin",
//   "london", "arrowglacier", "grayglacier", "merge",
//   "shanghai", "cancun", "prague", "osaka"
// ]

console.log(`Total hardforks: ${names.length}`);  // 19
```

**Use Case:**
```typescript
function buildHardforkSelector(): string {
  const options = Hardfork.allNames()
    .map(name => `<option value="${name}">${name}</option>`)
    .join('\n');

  return `<select>${options}</select>`;
}
```

---

### allIds

Get all hardfork IDs (same as allNames).

```typescript
Hardfork.allIds(): BrandedHardfork[]
```

**Returns:**
- Array of all hardforks in chronological order

**Example:**
```typescript
import { Hardfork } from '@tevm/voltaire';

const ids = Hardfork.allIds();
// [FRONTIER, HOMESTEAD, ..., OSAKA]

// Iterate over all hardforks
for (const fork of ids) {
  console.log(`${Hardfork.toString(fork)}: EIP-1559 = ${Hardfork.hasEIP1559(fork)}`);
}
```

**Use Case:**
```typescript
function generateFeatureMatrix() {
  const forks = Hardfork.allIds();

  return forks.map(fork => ({
    name: Hardfork.toString(fork),
    eip1559: Hardfork.hasEIP1559(fork),
    push0: Hardfork.hasEIP3855(fork),
    blobs: Hardfork.hasEIP4844(fork),
    transientStorage: Hardfork.hasEIP1153(fork),
    pos: Hardfork.isPostMerge(fork),
  }));
}
```

---

### min

Find earliest (minimum) hardfork from array.

```typescript
Hardfork.min(forks: BrandedHardfork[]): BrandedHardfork
```

**Parameters:**
- `forks` - Array of hardforks

**Returns:**
- Earliest hardfork chronologically

**Example:**
```typescript
import { Hardfork, BERLIN, CANCUN, SHANGHAI } from '@tevm/voltaire';

const oldest = Hardfork.min([CANCUN, BERLIN, SHANGHAI]);
console.log(oldest);  // BERLIN

// Empty array
Hardfork.min([]);  // undefined or error (implementation dependent)
```

**Use Case:**
```typescript
function getMinimumSupportedVersion(clients: Client[]): BrandedHardfork {
  const versions = clients.map(c => c.hardfork);
  return Hardfork.min(versions);
}
```

---

### max

Find latest (maximum) hardfork from array.

```typescript
Hardfork.max(forks: BrandedHardfork[]): BrandedHardfork
```

**Parameters:**
- `forks` - Array of hardforks

**Returns:**
- Latest hardfork chronologically

**Example:**
```typescript
import { Hardfork, BERLIN, CANCUN, SHANGHAI } from '@tevm/voltaire';

const latest = Hardfork.max([BERLIN, SHANGHAI, CANCUN]);
console.log(latest);  // CANCUN
```

**Use Case:**
```typescript
function getLatestNetworkVersion(networks: Network[]): BrandedHardfork {
  const versions = networks.map(n => n.hardfork);
  return Hardfork.max(versions);
}
```

---

## Range Operations

### range

Get array of hardforks between two versions (inclusive).

```typescript
Hardfork.range(start: BrandedHardfork, end: BrandedHardfork): BrandedHardfork[]
```

**Parameters:**
- `start` - Start hardfork
- `end` - End hardfork

**Returns:**
- Array of hardforks from start to end (inclusive)
- Order preserved: if start < end, ascending; if start > end, descending

**Example:**
```typescript
import { Hardfork, BERLIN, CANCUN, SHANGHAI, LONDON } from '@tevm/voltaire';

// Forward range
const forward = Hardfork.range(BERLIN, SHANGHAI);
// [BERLIN, LONDON, ARROW_GLACIER, GRAY_GLACIER, MERGE, SHANGHAI]

// Reverse range
const backward = Hardfork.range(SHANGHAI, BERLIN);
// [SHANGHAI, MERGE, GRAY_GLACIER, ARROW_GLACIER, LONDON, BERLIN]

// Single hardfork
const single = Hardfork.range(LONDON, LONDON);
// [LONDON]
```

**Use Case: Upgrade Path**
```typescript
function getUpgradePath(from: BrandedHardfork, to: BrandedHardfork): BrandedHardfork[] {
  const path = Hardfork.range(from, to);
  return path.slice(1);  // Exclude current version
}

const upgrades = getUpgradePath(BERLIN, CANCUN);
// [LONDON, ARROW_GLACIER, GRAY_GLACIER, MERGE, SHANGHAI, CANCUN]

console.log(`Need to upgrade through ${upgrades.length} hardforks`);
```

**Use Case: Feature Changes**
```typescript
function listFeatureChanges(start: BrandedHardfork, end: BrandedHardfork) {
  const forks = Hardfork.range(start, end);

  return forks.map(fork => ({
    name: Hardfork.toString(fork),
    newFeatures: {
      eip1559: Hardfork.hasEIP1559(fork) && !Hardfork.hasEIP1559(start),
      push0: Hardfork.hasEIP3855(fork) && !Hardfork.hasEIP3855(start),
      blobs: Hardfork.hasEIP4844(fork) && !Hardfork.hasEIP4844(start),
    }
  }));
}
```

**Error Handling:**
```typescript
try {
  const r = Hardfork.range(BERLIN, CANCUN);
} catch (e) {
  console.error("Invalid hardfork range");
}
```

---

## Common Patterns

### Configuration Parsing

```typescript
function parseNetworkConfig(config: Record<string, unknown>) {
  const hardforkStr = String(config.hardfork ?? "prague");

  // Validate
  if (!Hardfork.isValidName(hardforkStr)) {
    throw new Error(`Invalid hardfork: ${hardforkStr}`);
  }

  // Parse
  const fork = Hardfork.fromString(hardforkStr)!;

  // Normalize for storage
  const normalized = Hardfork.toString(fork);

  return { hardfork: fork, hardforkName: normalized };
}
```

### Version Range Validation

```typescript
function isSupportedVersion(fork: BrandedHardfork): boolean {
  const MIN_VERSION = BERLIN;
  const MAX_VERSION = PRAGUE;

  const versions = Hardfork.range(MIN_VERSION, MAX_VERSION);
  return versions.includes(fork);
}
```

### Migration Planning

```typescript
function planMigration(current: BrandedHardfork, target: BrandedHardfork) {
  if (Hardfork.isAtLeast(current, target)) {
    return { needed: false };
  }

  const path = Hardfork.range(current, target).slice(1);

  return {
    needed: true,
    steps: path.length,
    hardforks: path.map(Hardfork.toString),
    features: path.map(fork => ({
      name: Hardfork.toString(fork),
      eip1559: Hardfork.hasEIP1559(fork),
      push0: Hardfork.hasEIP3855(fork),
      blobs: Hardfork.hasEIP4844(fork),
    }))
  };
}
```

### User Input Handling

```typescript
function handleUserInput(input: string): BrandedHardfork {
  // Strip whitespace
  const trimmed = input.trim();

  // Validate
  if (!trimmed) {
    throw new Error("Hardfork name required");
  }

  if (!Hardfork.isValidName(trimmed)) {
    const available = Hardfork.allNames().join(", ");
    throw new Error(
      `Invalid hardfork: ${trimmed}\n` +
      `Available: ${available}`
    );
  }

  // Parse
  return Hardfork.fromString(trimmed)!;
}
```

### Feature Matrix Generation

```typescript
function generateFeatureMatrix() {
  const allForks = Hardfork.allIds();

  return allForks.map(fork => {
    const name = Hardfork.toString(fork);
    return {
      name,
      consensus: Hardfork.isPostMerge(fork) ? "PoS" : "PoW",
      eip1559: Hardfork.hasEIP1559(fork),
      push0: Hardfork.hasEIP3855(fork),
      blobs: Hardfork.hasEIP4844(fork),
      transientStorage: Hardfork.hasEIP1153(fork),
    };
  });
}
```

### Version Selector Component

```typescript
function createVersionSelector(current: BrandedHardfork) {
  const allForks = Hardfork.allNames();
  const currentName = Hardfork.toString(current);

  return allForks.map(name => ({
    value: name,
    label: name.charAt(0).toUpperCase() + name.slice(1),
    selected: name === currentName,
  }));
}
```

---

## Best Practices

### 1. Always Validate User Input

```typescript
// Good
const input = getUserInput();
if (Hardfork.isValidName(input)) {
  const fork = Hardfork.fromString(input)!;
  // Use fork
}

// Bad - no validation
const fork = Hardfork.fromString(getUserInput());
// fork might be undefined!
```

### 2. Normalize for Storage

```typescript
// Good - store canonical name
const fork = Hardfork.fromString(userInput)!;
const normalized = Hardfork.toString(fork);
storage.set("hardfork", normalized);  // "merge" not "paris"

// Bad - store user input
storage.set("hardfork", userInput);  // might be "Paris" or "MERGE"
```

### 3. Handle Aliases Consistently

```typescript
function areHardforksEqual(a: string, b: string): boolean {
  const forkA = Hardfork.fromString(a);
  const forkB = Hardfork.fromString(b);

  if (!forkA || !forkB) return false;

  return Hardfork.isEqual(forkA, forkB);
}

// Correctly handles aliases
areHardforksEqual("merge", "paris");  // true
```

### 4. Use Type-Safe Collections

```typescript
// Good - type-safe
const forks = Hardfork.allIds();
const oldest = Hardfork.min(forks);

// Less type-safe
const names = Hardfork.allNames();
const oldest = Hardfork.fromString(names[0]);  // might be undefined
```

---

## Performance

All utility operations are highly optimized:

| Operation | Time Complexity | Typical Time |
|-----------|----------------|--------------|
| fromString | O(1) | ~50-100ns |
| toString | O(1) | ~20-40ns |
| isValidName | O(1) | ~60-120ns |
| allNames | O(n) | ~100-200ns |
| allIds | O(n) | ~100-200ns |
| min | O(n) | ~50-100ns per item |
| max | O(n) | ~50-100ns per item |
| range | O(n) | ~100-200ns + items |

**Implementation:**
- `fromString`: Hash table lookup (lowercase keys)
- `toString`: Direct return (hardforks are already strings)
- `isValidName`: Calls fromString, checks !== undefined
- Collections: Simple array operations

---

## Related

- [comparisons.mdx](./comparisons.mdx) - min/max use comparison methods
- [features.mdx](./features.mdx) - Feature detection on ranges
- [usage-patterns.mdx](./usage-patterns.mdx) - Real-world utility usage
- [index.mdx](./index.mdx) - Main documentation
