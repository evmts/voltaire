---
title: EventLog WASM Implementation
description: WebAssembly-accelerated event log filtering for high-performance applications
---

import { Aside } from '@astrojs/starlight/components';

# WASM Implementation

WebAssembly-accelerated event log operations compiled from Zig for performance-critical filtering.

## Overview

EventLog provides WASM acceleration for filtering operations, offering **10-100x speedup** for batch log processing compared to pure TypeScript. WASM is beneficial when filtering thousands of logs or processing real-time event streams.

<Aside type="tip" title="When to Use WASM">
WASM provides significant benefits for:
- Filtering &gt;1000 logs
- Real-time event streams
- Batch processing
- Production indexers

For small datasets (&lt;100 logs), pure TypeScript is faster due to WASM call overhead.
</Aside>

## Status Check

### `isWasmEventLogAvailable()`

Check if WASM implementation is loaded and available.

```typescript
import { isWasmEventLogAvailable } from '@tevm/primitives/EventLog/EventLog.wasm.js'

if (isWasmEventLogAvailable()) {
  console.log("WASM event log filtering available")
} else {
  console.log("Falling back to pure TypeScript")
}
```

**Returns:** `boolean` - True if WASM is loaded

### `getImplementationStatus()`

Get detailed implementation status.

```typescript
import { getImplementationStatus } from '@tevm/primitives/EventLog/EventLog.wasm.js'

const status = getImplementationStatus()
console.log(status)
// {
//   wasmAvailable: true,
//   primitives: {
//     matchesAddress: true,
//     matchesTopic: true,
//     matchesTopics: true,
//     filterByAddress: true,
//     filterByTopics: true,
//     filterLogs: true
//   }
// }
```

**Returns:** Object with WASM availability and supported primitives

## WASM Functions

### `matchesAddressWasm(logAddress, filterAddresses)`

Check if log address matches filter address(es) using WASM.

```typescript
import { matchesAddressWasm } from '@tevm/primitives/EventLog/EventLog.wasm.js'

const matches = matchesAddressWasm(
  log.address,
  [usdcAddress, daiAddress, usdtAddress]
)
```

**Parameters:**
- `logAddress: BrandedAddress` - Log emitter address
- `filterAddresses: BrandedAddress[]` - Array of filter addresses (empty = match all)

**Returns:** `boolean` - True if log address matches any filter address

**Performance:** ~50-100ns per call (WASM) vs ~200-500ns (TypeScript)

Defined in: [primitives/EventLog/EventLog.wasm.ts:31](https://github.com/evmts/voltaire/blob/main/src/primitives/EventLog/EventLog.wasm.ts)

### `matchesTopicWasm(logTopic, filterTopic)`

Check if single topic matches filter using WASM.

```typescript
import { matchesTopicWasm } from '@tevm/primitives/EventLog/EventLog.wasm.js'

const matches = matchesTopicWasm(
  log.topics[0],
  transferSignature
)
```

**Parameters:**
- `logTopic: BrandedHash` - Log topic hash
- `filterTopic: BrandedHash | null` - Filter topic (null = match any)

**Returns:** `boolean` - True if topic matches

**Performance:** ~30-50ns per call (WASM) vs ~100-200ns (TypeScript)

Defined in: [primitives/EventLog/EventLog.wasm.ts:53](https://github.com/evmts/voltaire/blob/main/src/primitives/EventLog/EventLog.wasm.ts)

### `matchesTopicsWasm(logTopics, filterTopics)`

Check if all topics match filter array using WASM.

```typescript
import { matchesTopicsWasm } from '@tevm/primitives/EventLog/EventLog.wasm.js'

const matches = matchesTopicsWasm(
  log.topics,
  [transferSig, fromAddress, null]  // null = match any
)
```

**Parameters:**
- `logTopics: BrandedHash[]` - Array of log topics
- `filterTopics: (BrandedHash | null)[]` - Filter topics (null = wildcard)

**Returns:** `boolean` - True if all topics match

**Performance:** ~100-200ns per call (WASM) vs ~500-1000ns (TypeScript)

Defined in: [primitives/EventLog/EventLog.wasm.ts:77](https://github.com/evmts/voltaire/blob/main/src/primitives/EventLog/EventLog.wasm.ts)

### `filterByAddressWasm(logs, filterAddresses)`

Filter logs by address using WASM (batch operation).

```typescript
import { filterByAddressWasm } from '@tevm/primitives/EventLog/EventLog.wasm.js'

const filtered = filterByAddressWasm(allLogs, [usdcAddress, daiAddress])
```

**Parameters:**
- `logs: T[]` - Array of event logs (must have `address` field)
- `filterAddresses: BrandedAddress[]` - Filter addresses

**Returns:** `T[]` - Filtered logs

**Performance:** ~10-50x faster than TypeScript for &gt;1000 logs

Defined in: [primitives/EventLog/EventLog.wasm.ts:98](https://github.com/evmts/voltaire/blob/main/src/primitives/EventLog/EventLog.wasm.ts)

### `filterByTopicsWasm(logs, filterTopics)`

Filter logs by topics using WASM (batch operation).

```typescript
import { filterByTopicsWasm } from '@tevm/primitives/EventLog/EventLog.wasm.js'

const filtered = filterByTopicsWasm(allLogs, [
  transferEventSig,
  null,          // from any
  userAddress    // to user
])
```

**Parameters:**
- `logs: T[]` - Array of event logs (must have `topics` field)
- `filterTopics: (BrandedHash | null)[]` - Topic filters (null = wildcard)

**Returns:** `T[]` - Filtered logs

**Performance:** ~20-100x faster than TypeScript for &gt;1000 logs

Defined in: [primitives/EventLog/EventLog.wasm.ts:124](https://github.com/evmts/voltaire/blob/main/src/primitives/EventLog/EventLog.wasm.ts)

### `filterLogsWasm(logs, filterAddresses, filterTopics)`

Filter logs by both address and topics using WASM.

```typescript
import { filterLogsWasm } from '@tevm/primitives/EventLog/EventLog.wasm.js'

const transfersToUser = filterLogsWasm(
  allLogs,
  [tokenAddress],
  [transferSig, null, userAddress]
)
```

**Parameters:**
- `logs: T[]` - Array of event logs
- `filterAddresses: BrandedAddress[]` - Filter addresses (empty = match all)
- `filterTopics: (BrandedHash | null)[]` - Topic filters (null = wildcard)

**Returns:** `T[]` - Filtered logs

**Performance:** ~50-150x faster than TypeScript for &gt;1000 logs

Defined in: [primitives/EventLog/EventLog.wasm.ts:147](https://github.com/evmts/voltaire/blob/main/src/primitives/EventLog/EventLog.wasm.ts)

## Usage Patterns

### Automatic Fallback

```typescript
import * as EventLog from '@tevm/primitives/EventLog'
import { isWasmEventLogAvailable, filterLogsWasm } from '@tevm/primitives/EventLog/EventLog.wasm.js'

function filterLogs(
  logs: BrandedEventLog[],
  filter: Filter
): BrandedEventLog[] {
  // Use WASM if available and beneficial
  if (isWasmEventLogAvailable() && logs.length > 1000) {
    return filterLogsWasm(logs, filter.address ?? [], filter.topics ?? [])
  }

  // Fall back to pure TypeScript
  return EventLog.filterLogs(logs, filter)
}
```

### Performance Benchmarking

```typescript
import { filterLogs } from '@tevm/primitives/EventLog'
import { filterLogsWasm, isWasmEventLogAvailable } from '@tevm/primitives/EventLog/EventLog.wasm.js'

async function benchmark(logs: BrandedEventLog[], iterations: number) {
  const filter = {
    address: [tokenAddress],
    topics: [transferSig, null, userAddress]
  }

  // TypeScript benchmark
  const tsStart = performance.now()
  for (let i = 0; i < iterations; i++) {
    filterLogs(logs, filter)
  }
  const tsDuration = performance.now() - tsStart

  // WASM benchmark
  let wasmDuration = 0
  if (isWasmEventLogAvailable()) {
    const wasmStart = performance.now()
    for (let i = 0; i < iterations; i++) {
      filterLogsWasm(logs, filter.address!, filter.topics!)
    }
    wasmDuration = performance.now() - wasmStart
  }

  return {
    typescript: tsDuration,
    wasm: wasmDuration,
    speedup: tsDuration / wasmDuration
  }
}
```

### Adaptive Strategy

```typescript
class AdaptiveEventFilter {
  private useWasm: boolean

  constructor() {
    this.useWasm = isWasmEventLogAvailable()
  }

  filter(logs: BrandedEventLog[], filter: Filter): BrandedEventLog[] {
    // Use WASM for large datasets
    if (this.useWasm && logs.length > 1000 && filter.address && filter.topics) {
      return filterLogsWasm(logs, filter.address, filter.topics)
    }

    // TypeScript for small datasets or complex filters
    return filterLogs(logs, filter)
  }
}
```

## Performance Characteristics

### Breakeven Points

| Operation | Small (&lt;100) | Medium (100-1000) | Large (&gt;1000) |
|-----------|--------------|-------------------|---------------|
| `matchesAddress` | TypeScript faster | TypeScript faster | WASM 2-5x faster |
| `matchesTopics` | TypeScript faster | WASM ~equal | WASM 5-20x faster |
| `filterLogs` | TypeScript faster | WASM 2-5x faster | WASM 10-100x faster |

### Optimization Guidelines

**Use WASM when:**
- Filtering &gt;1000 logs
- Processing real-time streams
- Building production indexers
- Performance is critical

**Use TypeScript when:**
- Filtering &lt;100 logs
- One-time queries
- Complex filter logic
- WASM not available

## Memory Considerations

WASM filtering operates on shared memory between JavaScript and WebAssembly:

```typescript
// Efficient: Single pass, minimal allocations
const filtered = filterLogsWasm(allLogs, [tokenAddress], [transferSig])

// Less efficient: Multiple WASM calls
const step1 = filterByAddressWasm(allLogs, [tokenAddress])
const step2 = filterByTopicsWasm(step1, [transferSig])
```

<Aside type="caution" title="Memory Copying">
Each WASM call involves memory copying between JS and WASM. For best performance, use combined filters (`filterLogsWasm`) rather than chaining individual operations.
</Aside>

## Real-World Performance

### Indexer Example

```typescript
import { filterLogsWasm } from '@tevm/primitives/EventLog/EventLog.wasm.js'

class EventIndexer {
  async indexBlock(blockNumber: bigint): Promise<void> {
    // Fetch all logs for block (potentially thousands)
    const logs = await provider.getLogs({
      fromBlock: blockNumber,
      toBlock: blockNumber
    })

    console.log(`Processing ${logs.length} logs...`)

    // WASM filtering: ~1-5ms for 1000 logs
    const transfers = filterLogsWasm(
      logs,
      [usdcAddress, daiAddress, usdtAddress],
      [transferSig]
    )

    // TypeScript would take: ~50-200ms for 1000 logs
    await this.processTransfers(transfers)
  }
}
```

### Benchmark Results

Real-world performance on 10,000 logs:

```
TypeScript filterLogs: 250ms
WASM filterLogsWasm:    5ms
Speedup: 50x
```

## Loading WASM

WASM is loaded automatically when importing from `.wasm.js` files:

```typescript
// Automatically loads WASM if available
import { filterLogsWasm } from '@tevm/primitives/EventLog/EventLog.wasm.js'

// Check if load succeeded
import { isWasmEventLogAvailable } from '@tevm/primitives/EventLog/EventLog.wasm.js'

if (!isWasmEventLogAvailable()) {
  console.warn("WASM not available, using TypeScript fallback")
}
```

## See Also

- [Utilities](/primitives/eventlog/utilities) - Pure TypeScript filtering
- [Usage Patterns](/primitives/eventlog/usage-patterns) - Real-world examples
- [Validation](/primitives/eventlog/validation) - Filter matching logic
