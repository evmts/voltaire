---
title: "FeeMarket WASM"
---

# FeeMarket WASM

WASM implementation status for fee market calculations.

## Status

**WASM NOT IMPLEMENTED (and not needed)**

## Why No WASM?

FeeMarket provides:
- EIP-1559 and EIP-4844 constants (no computation)
- Simple bigint arithmetic (base fee, blob fee formulas)
- Lightweight validation functions

These operations are:
- Already optimal in TypeScript
- Too lightweight for WASM overhead to provide benefit
- Pure calculations with no I/O or complex state

**WASM call overhead (~1-2μs) exceeds calculation time (`<1μs`)**

## Performance Characteristics

Pure TypeScript benchmarks:

```
calculateBaseFee:        ~250ns per call   (~4M ops/sec)
calculateBlobBaseFee:    ~10μs per call    (~100K ops/sec)
calculateTxFee:          ~50ns per call    (~20M ops/sec)
nextState:               ~500ns per call   (~2M ops/sec)
validateState:           ~50ns per call    (~20M ops/sec)
```

WASM overhead:
- Function call: ~1-2μs
- Memory copy: Additional overhead for bigint conversions
- Total: 10-100x slower for these operations

**Verdict: TypeScript is 10-100x faster**

## When WASM Would Help

WASM beneficial for:
- Heavy computation (>10μs per operation)
- Cryptographic operations (hashing, signatures, elliptic curve)
- Large data processing (RLP encoding, ABI encoding)
- Batch operations (processing thousands of items)
- CPU-intensive loops

FeeMarket doesn't fit these criteria:
- Lightweight bigint math
- Simple formulas
- No cryptographic operations
- Typically single-item operations

## Implementation Status

```typescript
import {
  isWasmFeeMarketAvailable,
  getFeeMarketImplementationStatus
} from './FeeMarket.wasm.js';

// Always returns false
isWasmFeeMarketAvailable(); // false

// Get detailed status
const status = getFeeMarketImplementationStatus();
// {
//   available: false,
//   reason: "Pure TS optimal - WASM overhead exceeds benefit",
//   recommendation: "Use pure TypeScript - already optimal",
//   performance: {
//     typescriptAvg: "100-800ns per operation",
//     wasmOverhead: "1-2μs per WASM call",
//     verdict: "TypeScript 10-20x faster"
//   }
// }
```

## FeeMarket.wasm.ts

Re-exports pure TypeScript implementation:

```typescript
// All exports from pure TypeScript
export * from "./FeeMarket.js";

// WASM status functions
export function isWasmFeeMarketAvailable(): boolean {
  return false;
}

export function getFeeMarketImplementationStatus() {
  return {
    available: false,
    reason: "Pure TS optimal - WASM overhead exceeds benefit",
    // ... details
  };
}
```

## Usage

Simply use FeeMarket.js directly:

```typescript
// Optimal - use pure TypeScript
import * as FeeMarket from './FeeMarket.js';

const baseFee = FeeMarket.calculateBaseFee(
  30_000_000n,
  30_000_000n,
  1_000_000_000n
);
```

Don't import from `.wasm.js`:

```typescript
// Unnecessary - same as FeeMarket.js
import * as FeeMarket from './FeeMarket.wasm.js';
```

## Benchmarks

Run benchmarks to verify performance:

```bash
bun run src/primitives/FeeMarket/FeeMarket.bench.ts
```

Results show TypeScript is optimal:
- `calculateBaseFee`: ~4M ops/sec
- `calculateBlobBaseFee`: ~100K ops/sec (Taylor series)
- `calculateTxFee`: ~20M ops/sec
- `nextState`: ~2M ops/sec

See `fee-market-bench-results.json` for detailed results.

## Alternative: Zig Implementation

Fee market calculations implemented in Zig (`fee_market.zig`) for:
- Testing compatibility
- Native performance validation
- Reference implementation

**Zig is NOT faster than TypeScript** for these operations:
- V8 JIT optimizes bigint arithmetic effectively
- Zig-WASM bridge adds overhead
- No performance gain for simple calculations

Zig useful for:
- Native CLI tools
- Testing against reference implementation
- Educational purposes

## Comparison with Other Primitives

| Primitive | WASM? | Reason |
|-----------|-------|--------|
| Address | Yes | Keccak-256 hashing, CREATE/CREATE2 |
| Uint256 | No | Simple bigint operations |
| FeeMarket | No | Simple bigint operations |
| RLP | Yes | Complex encoding/decoding |
| Keccak | Yes | Cryptographic hashing |
| Secp256k1 | Yes | Elliptic curve operations |

FeeMarket similar to Uint256: pure bigint math, no WASM benefit.

## Future Considerations

WASM implementation reconsidered if:
- Batch operations common (thousands of fee calculations)
- Integration with other WASM modules (shared memory)
- Platform with poor bigint performance

Currently: TypeScript optimal for all use cases.

## References

- [FeeMarket.bench.ts](./FeeMarket.bench.ts) - Performance benchmarks
- [fee_market.zig](./fee_market.zig) - Zig reference implementation
- [branded-feemarket.mdx](./branded-feemarket.mdx) - TypeScript implementation

## Related

Primitives with WASM acceleration:
- [Address](../Address/Address.wasm.js.md) - Keccak-256, checksums
- [Keccak](../Keccak/) - Hash computations
- [RLP](../RLP/) - Encoding/decoding
