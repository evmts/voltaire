---
title: secp256k1
description: ECDSA signatures on the secp256k1 curve for Ethereum
---

# secp256k1

Elliptic Curve Digital Signature Algorithm (ECDSA) on the secp256k1 curve, used for Ethereum transaction signing and signature verification.

## Overview

The secp256k1 module provides:
- **Signature creation**: Sign messages with private keys
- **Signature verification**: Verify signatures with public keys
- **Public key recovery**: Recover public keys from signatures (ecrecover)
- **Key derivation**: Derive public keys from private keys

**Source**: `src/crypto/secp256k1.zig`

## Key Functions

### Signing

```zig
const crypto = @import("crypto");

// Sign a message hash
pub fn sign(
    message_hash: [32]u8,
    private_key: [32]u8,
) !Signature {
    return crypto.secp256k1.sign(message_hash, private_key);
}
```

### Verification

```zig
// Verify a signature
pub fn verify(
    message_hash: [32]u8,
    signature: Signature,
    public_key: PublicKey,
) bool {
    return crypto.secp256k1.verify(message_hash, signature, public_key);
}
```

### Public Key Recovery

```zig
// Recover public key from signature (ecrecover)
pub fn recover(
    message_hash: [32]u8,
    signature: Signature,
    recovery_id: u8,
) !PublicKey {
    return crypto.secp256k1.recover(message_hash, signature, recovery_id);
}
```

### Key Derivation

```zig
// Derive public key from private key
pub fn derivePublicKey(private_key: [32]u8) !PublicKey {
    return crypto.secp256k1.derivePublicKey(private_key);
}
```

## Types

### Signature

```zig
pub const Signature = struct {
    r: [32]u8,  // R component
    s: [32]u8,  // S component
    v: u8,      // Recovery ID (0-3)
};
```

### PublicKey

```zig
pub const PublicKey = struct {
    x: [32]u8,  // X coordinate
    y: [32]u8,  // Y coordinate
};
```

## Examples

### Sign and Verify Transaction

```zig
const std = @import("std");
const crypto = @import("crypto");

pub fn signTransaction(tx_hash: [32]u8, private_key: [32]u8) !crypto.secp256k1.Signature {
    // Sign transaction hash
    const signature = try crypto.secp256k1.sign(tx_hash, private_key);

    // Derive public key for verification
    const public_key = try crypto.secp256k1.derivePublicKey(private_key);

    // Verify signature
    const valid = crypto.secp256k1.verify(tx_hash, signature, public_key);
    if (!valid) return error.InvalidSignature;

    return signature;
}
```

### Recover Signer Address

```zig
pub fn recoverSigner(tx_hash: [32]u8, signature: crypto.secp256k1.Signature) !Address {
    // Recover public key from signature
    const public_key = try crypto.secp256k1.recover(
        tx_hash,
        signature,
        signature.v,
    );

    // Hash public key to get address
    const hash = crypto.Hash.keccak256(public_key.toBytes());

    // Take last 20 bytes as address
    var address: [20]u8 = undefined;
    @memcpy(&address, hash[12..32]);

    return address;
}
```

## Security Considerations

### Constant-Time Operations

All cryptographic operations are implemented to be constant-time to prevent timing attacks:
- Signature verification
- Point multiplication
- Private key operations

### Input Validation

The module validates:
- Private keys are in valid range [1, n-1]
- Public keys are on the curve
- Signatures have valid r and s components
- Recovery IDs are in range [0, 3]

### Nonce Generation

Uses deterministic nonce generation (RFC 6979) to prevent nonce reuse attacks.

## Performance

Voltaire's secp256k1 implementation uses optimized field arithmetic for the secp256k1 curve:

**Native (ReleaseFast)**:
- Sign: ~50-100 μs
- Verify: ~150-250 μs
- Recovery: ~200-300 μs

**WASM (ReleaseFast)**:
- Sign: ~100-200 μs
- Verify: ~300-500 μs
- Recovery: ~400-600 μs

## Testing

The module includes comprehensive tests:
- Known test vectors from Ethereum
- Edge cases (zero, max values)
- Invalid inputs
- Cross-validation with reference implementations

```bash
zig build test -Dtest-filter=secp256k1
```

## Related

- [ecrecover precompile](/zig/precompiles/ecrecover/) - EVM precompile using secp256k1
- [Transaction signing](/zig/primitives/transaction/) - Using secp256k1 for transactions
- [Address derivation](/zig/primitives/address/) - Deriving addresses from public keys

## References

- [SEC 2: Recommended Elliptic Curve Domain Parameters](https://www.secg.org/sec2-v2.pdf)
- [RFC 6979: Deterministic Usage of DSA and ECDSA](https://tools.ietf.org/html/rfc6979)
- [Ethereum Yellow Paper](https://ethereum.github.io/yellowpaper/paper.pdf) - Appendix F
