---
title: Opcode
description: EVM opcode utilities for bytecode parsing, disassembly, and instruction analysis
---

import { Tabs, TabItem, Card, CardGrid, Aside } from '@astrojs/starlight/components';

# Opcode

EVM opcode utilities for bytecode parsing, disassembly, and instruction analysis.

## Overview

Opcode provides comprehensive utilities for working with EVM opcodes (0x00-0xFF). Supports opcode validation, instruction parsing, bytecode disassembly, jump destination analysis, and opcode categorization (PUSH, DUP, SWAP, LOG, etc.).

## Quick Start

<Tabs>
<TabItem label="Namespace API (Tree-shakeable)">
```typescript
import * as Opcode from '@tevm/voltaire/Opcode'

// Check opcode validity
const valid = Opcode.isValid(0x60)  // true (PUSH1)

// Get opcode name
const name = Opcode.name(0x60)  // "PUSH1"

// Get opcode info
const info = Opcode.info(0x60)
// { gasCost: 3, stackInputs: 0, stackOutputs: 1, name: "PUSH1" }

// Categorization
Opcode.isPush(0x60)   // true
Opcode.isDup(0x80)    // true (DUP1)
Opcode.isSwap(0x90)   // true (SWAP1)
Opcode.isLog(0xa0)    // true (LOG0)

// Parse bytecode
const instructions = Opcode.parse(bytecode)
const assembly = Opcode.disassemble(bytecode)

// Jump analysis
const jumpDests = Opcode.jumpDests(bytecode)
const isValidJump = Opcode.isValidJumpDest(bytecode, 0x0042)
```
</TabItem>
<TabItem label="Functional API">
```typescript
import {
  isValid,
  name,
  info,
  isPush,
  isDup,
  isSwap,
  isLog,
  parse,
  disassemble,
  jumpDests,
  isValidJumpDest
} from '@tevm/voltaire/Opcode'

// Check opcode validity
const valid = isValid(0x60)  // true (PUSH1)

// Get opcode name
const opName = name(0x60)  // "PUSH1"

// Get opcode info
const opInfo = info(0x60)
// { gasCost: 3, stackInputs: 0, stackOutputs: 1, name: "PUSH1" }

// Categorization
isPush(0x60)   // true
isDup(0x80)    // true (DUP1)
isSwap(0x90)   // true (SWAP1)
isLog(0xa0)    // true (LOG0)

// Parse bytecode
const instructions = parse(bytecode)
const assembly = disassemble(bytecode)

// Jump analysis
const dests = jumpDests(bytecode)
const isValidJump = isValidJumpDest(bytecode, 0x0042)
```
</TabItem>
<TabItem label="Bytecode Parsing">
```typescript
import * as Opcode from '@tevm/voltaire/Opcode'

const bytecode = new Uint8Array([
  0x60, 0x80,           // PUSH1 0x80
  0x60, 0x40,           // PUSH1 0x40
  0x52,                 // MSTORE
  0x60, 0x04,           // PUSH1 0x04
  0x36,                 // CALLDATASIZE
  0x10,                 // LT
])

// Parse into instructions
const instructions = Opcode.parse(bytecode)
// [
//   { offset: 0, opcode: 0x60, immediate: Uint8Array([0x80]) },
//   { offset: 2, opcode: 0x60, immediate: Uint8Array([0x40]) },
//   { offset: 4, opcode: 0x52 },
//   { offset: 5, opcode: 0x60, immediate: Uint8Array([0x04]) },
//   { offset: 7, opcode: 0x36 },
//   { offset: 8, opcode: 0x10 },
// ]
```
</TabItem>
<TabItem label="Disassembly">
```typescript
import * as Opcode from '@tevm/voltaire/Opcode'

const bytecode = new Uint8Array([
  0x60, 0x80,           // PUSH1 0x80
  0x60, 0x40,           // PUSH1 0x40
  0x52,                 // MSTORE
])

// Disassemble to human-readable format
const assembly = Opcode.disassemble(bytecode)
// [
//   "0000: PUSH1 0x80",
//   "0002: PUSH1 0x40",
//   "0004: MSTORE",
// ]

// Format single instruction
const formatted = Opcode.format({
  offset: 0,
  opcode: 0x60,
  immediate: new Uint8Array([0x80])
})
// "0000: PUSH1 0x80"
```
</TabItem>
</Tabs>

## Type Definition

```typescript
/**
 * Branded type for EVM opcodes (number 0x00-0xFF)
 */
export type BrandedOpcode = number & { readonly __tag: "Opcode" }

/**
 * Instruction with opcode and optional immediate data
 */
export type Instruction = {
  /** Program counter offset */
  offset: number
  /** The opcode */
  opcode: BrandedOpcode
  /** Immediate data for PUSH operations */
  immediate?: Uint8Array
}

/**
 * Opcode metadata structure
 */
export type Info = {
  /** Base gas cost (may be dynamic at runtime) */
  gasCost: number
  /** Number of stack items consumed */
  stackInputs: number
  /** Number of stack items produced */
  stackOutputs: number
  /** Opcode name */
  name: string
}
```

Source: [BrandedOpcode.ts:1-31](https://github.com/evmts/primitives/blob/main/src/primitives/Opcode/BrandedOpcode/BrandedOpcode.ts#L1-L31)

## Core Methods

### info()

Get complete opcode metadata.

```typescript
const info = Opcode.info(0x01)  // ADD
// {
//   gasCost: 3,
//   stackInputs: 2,
//   stackOutputs: 1,
//   name: "ADD"
// }
```

### name()

Get opcode mnemonic name.

```typescript
Opcode.name(0x00)  // "STOP"
Opcode.name(0x01)  // "ADD"
Opcode.name(0x60)  // "PUSH1"
Opcode.name(0xFF)  // "SELFDESTRUCT"
```

### isValid()

Check if byte is valid opcode.

```typescript
Opcode.isValid(0x60)  // true (PUSH1)
Opcode.isValid(0x00)  // true (STOP)
Opcode.isValid(0xFF)  // true (SELFDESTRUCT)
Opcode.isValid(0x0C)  // false (undefined opcode)
```

### isPush()

Check if opcode is PUSH1-PUSH32.

```typescript
Opcode.isPush(0x60)  // true (PUSH1)
Opcode.isPush(0x7F)  // true (PUSH32)
Opcode.isPush(0x01)  // false (ADD)
```

### pushBytes()

Get number of immediate bytes for PUSH opcode.

```typescript
Opcode.pushBytes(0x60)  // 1 (PUSH1)
Opcode.pushBytes(0x7F)  // 32 (PUSH32)
Opcode.pushBytes(0x01)  // 0 (not a PUSH)
```

### pushOpcode()

Get PUSH opcode for given byte count.

```typescript
Opcode.pushOpcode(1)   // 0x60 (PUSH1)
Opcode.pushOpcode(32)  // 0x7F (PUSH32)
```

### isDup()

Check if opcode is DUP1-DUP16.

```typescript
Opcode.isDup(0x80)  // true (DUP1)
Opcode.isDup(0x8F)  // true (DUP16)
Opcode.isDup(0x01)  // false
```

### dupPosition()

Get stack position for DUP opcode (1-16).

```typescript
Opcode.dupPosition(0x80)  // 1 (DUP1)
Opcode.dupPosition(0x8F)  // 16 (DUP16)
```

### isSwap()

Check if opcode is SWAP1-SWAP16.

```typescript
Opcode.isSwap(0x90)  // true (SWAP1)
Opcode.isSwap(0x9F)  // true (SWAP16)
```

### swapPosition()

Get stack position for SWAP opcode (1-16).

```typescript
Opcode.swapPosition(0x90)  // 1 (SWAP1)
Opcode.swapPosition(0x9F)  // 16 (SWAP16)
```

### isLog()

Check if opcode is LOG0-LOG4.

```typescript
Opcode.isLog(0xA0)  // true (LOG0)
Opcode.isLog(0xA4)  // true (LOG4)
```

### logTopics()

Get number of topics for LOG opcode (0-4).

```typescript
Opcode.logTopics(0xA0)  // 0 (LOG0)
Opcode.logTopics(0xA4)  // 4 (LOG4)
```

### isTerminating()

Check if opcode terminates execution (STOP, RETURN, REVERT, INVALID, SELFDESTRUCT).

```typescript
Opcode.isTerminating(0x00)  // true (STOP)
Opcode.isTerminating(0xF3)  // true (RETURN)
Opcode.isTerminating(0xFD)  // true (REVERT)
Opcode.isTerminating(0xFE)  // true (INVALID)
Opcode.isTerminating(0xFF)  // true (SELFDESTRUCT)
```

### isJump()

Check if opcode is JUMP or JUMPI.

```typescript
Opcode.isJump(0x56)  // true (JUMP)
Opcode.isJump(0x57)  // true (JUMPI)
```

### parse()

Parse bytecode into instructions.

```typescript
const bytecode = new Uint8Array([0x60, 0x80, 0x60, 0x40, 0x52])

const instructions = Opcode.parse(bytecode)
// [
//   { offset: 0, opcode: 0x60, immediate: Uint8Array([0x80]) },
//   { offset: 2, opcode: 0x60, immediate: Uint8Array([0x40]) },
//   { offset: 4, opcode: 0x52 }
// ]
```

### format()

Format instruction as human-readable string.

```typescript
const instruction = { offset: 0, opcode: 0x60, immediate: new Uint8Array([0x80]) }

const formatted = Opcode.format(instruction)
// "0000: PUSH1 0x80"
```

### disassemble()

Disassemble bytecode into array of formatted strings.

```typescript
const bytecode = new Uint8Array([0x60, 0x80, 0x60, 0x40, 0x52])

const lines = Opcode.disassemble(bytecode)
// [
//   "0000: PUSH1 0x80",
//   "0002: PUSH1 0x40",
//   "0004: MSTORE"
// ]
```

### jumpDests()

Find all valid JUMPDEST positions in bytecode.

```typescript
const bytecode = contractCode

const dests = Opcode.jumpDests(bytecode)
// Set([0x0042, 0x0089, 0x00b3, ...])
```

### isValidJumpDest()

Check if offset is valid JUMPDEST in bytecode.

```typescript
const valid = Opcode.isValidJumpDest(bytecode, 0x0042)  // true if JUMPDEST at offset

// Invalid if:
// - Not JUMPDEST opcode (0x5B)
// - Inside PUSH data
// - Out of bounds
```

## Opcode Constants

All EVM opcodes are exported as constants:

```typescript
import * as Opcode from '@tevm/primitives/Opcode'

// Arithmetic
Opcode.STOP         // 0x00
Opcode.ADD          // 0x01
Opcode.MUL          // 0x02
Opcode.SUB          // 0x03
Opcode.DIV          // 0x04
Opcode.MOD          // 0x05

// Stack operations
Opcode.PUSH1        // 0x60
Opcode.PUSH32       // 0x7F
Opcode.DUP1         // 0x80
Opcode.SWAP1        // 0x90

// Memory/Storage
Opcode.MLOAD        // 0x51
Opcode.MSTORE       // 0x52
Opcode.SLOAD        // 0x54
Opcode.SSTORE       // 0x55

// Flow control
Opcode.JUMP         // 0x56
Opcode.JUMPI        // 0x57
Opcode.JUMPDEST     // 0x5B

// Logs
Opcode.LOG0         // 0xA0
Opcode.LOG1         // 0xA1
Opcode.LOG2         // 0xA2
Opcode.LOG3         // 0xA3
Opcode.LOG4         // 0xA4

// System
Opcode.CREATE       // 0xF0
Opcode.CALL         // 0xF1
Opcode.RETURN       // 0xF3
Opcode.REVERT       // 0xFD
Opcode.INVALID      // 0xFE
Opcode.SELFDESTRUCT // 0xFF
```

## Use Cases

### Bytecode Analysis

```typescript
import * as Opcode from '@tevm/primitives/Opcode'

// Analyze bytecode structure
const instructions = Opcode.parse(bytecode)

let totalGas = 0
for (const inst of instructions) {
  const info = Opcode.info(inst.opcode)
  totalGas += info.gasCost
  console.log(`${Opcode.name(inst.opcode)}: ${info.gasCost} gas`)
}
```

### Jump Validation

```typescript
// Build valid jump destination map
const validDests = Opcode.jumpDests(bytecode)

// During execution, validate jumps
function executeJump(targetOffset: number) {
  if (!validDests.has(targetOffset)) {
    throw new Error("Invalid jump destination")
  }
  // Proceed with jump
}
```

### Disassembler

```typescript
// Create human-readable disassembly
function disassembleContract(bytecode: Uint8Array): string {
  const lines = Opcode.disassemble(bytecode)
  return lines.join('\n')
}

const output = disassembleContract(contractCode)
// 0000: PUSH1 0x80
// 0002: PUSH1 0x40
// 0004: MSTORE
// 0005: CALLVALUE
// ...
```

### Stack Depth Analysis

```typescript
// Track stack depth through execution
let stackDepth = 0

for (const inst of Opcode.parse(bytecode)) {
  const info = Opcode.info(inst.opcode)
  stackDepth -= info.stackInputs
  stackDepth += info.stackOutputs

  if (stackDepth < 0) {
    console.error(`Stack underflow at ${inst.offset}`)
  }
  if (stackDepth > 1024) {
    console.error(`Stack overflow at ${inst.offset}`)
  }
}
```

### Code Coverage

```typescript
// Track which opcodes are executed
const coverage = new Set<number>()

for (const inst of executedInstructions) {
  coverage.add(inst.offset)
}

// Find uncovered code
const allOffsets = Opcode.parse(bytecode).map(i => i.offset)
const uncovered = allOffsets.filter(o => !coverage.has(o))
```

## Tree-Shaking

Import only what you need for optimal bundle size:

```typescript
// Import specific operations
import { parse, disassemble, isPush, isValid } from '@tevm/primitives/Opcode'

// Or import entire namespace
import * as Opcode from '@tevm/primitives/Opcode'

// Selective imports for bytecode analysis
const instructions = parse(bytecode)
const assembly = disassemble(bytecode)
```

Each parser, categorization check, and disassembly function is independently exported. Import only the bytecode analysis utilities you need (e.g., just `parse` without `disassemble` or jump analysis).

## Opcode Categories

### Stack Operations
- **PUSH1-PUSH32** (0x60-0x7F): Push 1-32 bytes onto stack
- **DUP1-DUP16** (0x80-0x8F): Duplicate stack item at position 1-16
- **SWAP1-SWAP16** (0x90-0x9F): Swap top stack item with item at position 1-16
- **POP** (0x50): Remove top stack item

### Arithmetic
- **ADD, MUL, SUB, DIV, MOD** (0x01-0x05)
- **ADDMOD, MULMOD** (0x08-0x09)
- **EXP** (0x0A)
- **SIGNEXTEND** (0x0B)

### Comparison & Logic
- **LT, GT, SLT, SGT, EQ** (0x10-0x14)
- **ISZERO, AND, OR, XOR, NOT** (0x15-0x19)
- **BYTE, SHL, SHR, SAR** (0x1A-0x1D)

### Memory & Storage
- **MLOAD, MSTORE, MSTORE8** (0x51-0x53)
- **SLOAD, SSTORE** (0x54-0x55)
- **MSIZE** (0x59)

### Flow Control
- **JUMP, JUMPI, JUMPDEST** (0x56-0x5B)
- **PC** (0x58)
- **STOP, RETURN, REVERT** (0x00, 0xF3, 0xFD)

### Logging
- **LOG0-LOG4** (0xA0-0xA4): Emit log with 0-4 topics

### System Operations
- **CREATE, CREATE2** (0xF0, 0xF5)
- **CALL, CALLCODE, DELEGATECALL, STATICCALL** (0xF1-0xF4, 0xFA)
- **SELFDESTRUCT** (0xFF)

<Aside type="caution" title="PUSH Data Skipping">
When parsing bytecode, PUSH instructions consume 1-32 immediate bytes. These bytes must be skipped during parsing - they are data, not opcodes. The `parse()` and `jumpDests()` functions handle this correctly.
</Aside>

## Related Types

<CardGrid stagger>
  <Card title="Bytecode" icon="document">
    Contract bytecode representation and manipulation.

    [View Bytecode →](/primitives/bytecode)
  </Card>

  <Card title="Transaction" icon="rocket">
    Transactions that deploy and execute bytecode.

    [View Transaction →](/primitives/transaction)
  </Card>

  <Card title="State" icon="puzzle">
    EVM state operations accessed by opcodes.

    [View State →](/primitives/state)
  </Card>

  <Card title="GasConstants" icon="seti:config">
    Gas costs for EVM operations.

    [View GasConstants →](/primitives/gasconstants)
  </Card>
</CardGrid>

## Specification References

- [EVM Opcodes](https://www.evm.codes/) - Interactive opcode reference
- [Ethereum Yellow Paper](https://ethereum.github.io/yellowpaper/paper.pdf) - Formal EVM specification
- [Solidity Assembly](https://docs.soliditylang.org/en/latest/assembly.html) - Inline assembly documentation
- [EIP-3198](https://eips.ethereum.org/EIPS/eip-3198) - BASEFEE opcode
- [EIP-3855](https://eips.ethereum.org/EIPS/eip-3855) - PUSH0 instruction
