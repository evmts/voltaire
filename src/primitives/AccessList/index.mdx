---
title: "AccessList"
---

import { Tabs, TabItem } from '@astrojs/starlight/components';

# AccessList

EIP-2930 access list primitive for gas-optimized Ethereum transactions.

## Overview

Access lists (EIP-2930) allow transactions to pre-declare addresses and storage slots they will access. This converts expensive "cold" storage accesses into cheaper "warm" accesses, reducing gas costs.

**Key Benefits:**
- Reduces gas costs for storage-heavy transactions
- Makes transaction costs predictable
- Required for some cross-contract interactions
- Enables EIP-1559 transaction types

**When to Use:**
- Multi-contract transactions
- DeFi operations (swaps, liquidity)
- Contract deployments with storage initialization
- Cross-contract state reads

## Quick Start

<Tabs>
<TabItem label="Class API">
```typescript
import { AccessList, Address, Hash } from '@tevm/voltaire';

// Create addresses and keys
const token = Address.fromHex('0x...');
const balanceSlot = Hash.fromHex('0x...');

// Build access list
let list = AccessList.create();
list = list.withAddress(token);
list = list.withStorageKey(token, balanceSlot);

// Check if beneficial
if (list.hasSavings()) {
  transaction.accessList = list;
}

// Instance methods
list.gasCost()                  // Total cost
list.hasSavings()               // Cost < savings?
list.includesAddress(token)     // Has address?
list.isEmpty()                  // Is empty?
```
</TabItem>
<TabItem label="Namespace API (Tree-shakeable)">
```typescript
import * as AccessList from '@tevm/voltaire/AccessList';
import { Address, Hash } from '@tevm/voltaire';

// Create addresses and keys
const token = Address.fromHex('0x...');
const balanceSlot = Hash.fromHex('0x...');

// Build access list with functional API
let list = AccessList.create();
list = AccessList.withAddress(list, token);
list = AccessList.withStorageKey(list, token, balanceSlot);

// Check if beneficial
if (AccessList.hasSavings(list)) {
  transaction.accessList = list;
}

// Functional API
AccessList.gasCost(list)                      // Total cost
AccessList.hasSavings(list)                   // Cost < savings?
AccessList.includesAddress(list, token)       // Has address?
AccessList.isEmpty(list)                      // Is empty?
```
</TabItem>
</Tabs>

## Structure

```typescript
type AccessList = readonly Item[];

type Item = {
  address: BrandedAddress;              // 20-byte contract address
  storageKeys: readonly BrandedHash[];  // 32-byte storage keys
};
```

## Gas Economics (EIP-2930)

**Costs to Include in Transaction:**
- Address: 2,400 gas each
- Storage key: 1,900 gas each

**Savings per Access (vs cold access):**
- Cold account access: 2,600 → 2,400 gas (200 saved per address)
- Cold storage access: 2,100 → 1,900 gas (200 saved per key)

**Break-Even Analysis:**

For access list to be beneficial, potential savings must exceed cost:

```
Net Savings = (addresses × 200) + (keys × 200) - Cost
Cost = (addresses × 2,400) + (keys × 1,900)

Example: 2 addresses with 3 total storage keys
Cost: (2 × 2,400) + (3 × 1,900) = 10,700 gas
Savings: (2 × 200) + (3 × 200) = 1,000 gas
Net: -9,700 gas (NOT beneficial unless accessed 5+ times)
```

**Visual Gas Comparison:**

| Scenario | Address Cost | Keys Cost | Address Savings | Keys Savings | Net Gain? |
|----------|-------------|----------|-----------------|--------------|-----------|
| 1 addr, 1 key | 2,400 | 1,900 | 200 | 200 | ❌ -3,900 |
| 1 addr, 3 keys | 2,400 | 5,700 | 200 | 600 | ❌ -6,900 |
| 2 addr, 2 keys | 4,800 | 3,800 | 400 | 400 | ❌ -7,600 |
| 3 addr, 4 keys | 7,200 | 7,600 | 600 | 800 | ❌ -13,200 |

**Key Insight:** Access lists rarely break even for single-access scenarios. They're most valuable for:
- Repeated accesses within same transaction loop
- Strategic warm-up before expensive operations
- Batch operations accessing same slots

## Core API

See [AccessList.js.md](./AccessList.js.md) for complete API reference.

### Constructors

```typescript
AccessList.create()                     // Empty list
AccessList.from(items | bytes)          // From items or RLP
AccessList.fromBytes(bytes)             // From RLP bytes
```

### Type Guards

```typescript
AccessList.is(value)                    // Check if AccessList
AccessList.isItem(value)                // Check if Item
AccessList.assertValid(list)            // Validate (throws)
```

### Queries

```typescript
AccessList.includesAddress(list, addr)           // Has address?
AccessList.includesStorageKey(list, addr, key)   // Has key?
AccessList.keysFor(list, addr)                   // Get keys
AccessList.addressCount(list)                    // Count addresses
AccessList.storageKeyCount(list)                 // Count keys
AccessList.isEmpty(list)                         // Is empty?
```

### Manipulation

```typescript
AccessList.withAddress(list, addr)               // Add address
AccessList.withStorageKey(list, addr, key)       // Add key
AccessList.merge(...lists)                       // Combine lists
AccessList.deduplicate(list)                     // Remove duplicates
```

### Gas Analysis

```typescript
AccessList.gasCost(list)                // Total cost
AccessList.gasSavings(list)             // Potential savings
AccessList.hasSavings(list)             // Cost < savings?
```

### Conversions

```typescript
AccessList.toBytes(list)                // To RLP bytes
```

## Documentation

- [Constructors](./constructors.mdx) - Creating access lists
- [Validation](./validation.mdx) - Type guards and validation
- [Queries](./queries.mdx) - Inspecting access lists
- [Manipulation](./manipulation.mdx) - Modifying access lists
- [Gas Optimization](./gas-optimization.mdx) - Gas cost analysis
- [Conversions](./conversions.mdx) - Encoding/decoding
- [BrandedAccessList](./branded-accesslist.mdx) - Type system
- [WASM](./wasm.mdx) - WebAssembly bindings
- [Usage Patterns](./usage-patterns.mdx) - Common patterns

## Example: DeFi Swap with Analysis

```typescript
// Setup
const router = Address.fromHex('0xE592427A0AEce92De3Edee1F18E0157C05861564');
const token0 = Address.fromHex('0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2');
const token1 = Address.fromHex('0xA0b86991d4C137282C01B19e27F0f0751D85f469e');
const balanceSlot = 0n; // ERC20 balance mapping
const allowanceSlot = 1n; // ERC20 allowance mapping

// Build access list
let list = AccessList.create();
list = list.withAddress(router);                    // Router address
list = list.withStorageKey(token0, balanceSlot);    // Token 0 balance
list = list.withStorageKey(token0, allowanceSlot);  // Token 0 allowance
list = list.withStorageKey(token1, balanceSlot);    // Token 1 balance

// Analyze cost vs benefit
const cost = list.gasCost();
const savings = list.gasSavings();
const net = savings - cost;

console.log('Access List Analysis:');
console.log(`  Cost to include: ${cost} gas`);       // (3 × 2400) + (3 × 1900) = 12,900
console.log(`  Potential savings: ${savings} gas`);  // (3 × 200) + (3 × 200) = 1,200
console.log(`  Net impact: ${net} gas`);             // -11,700 (loses gas)

// Only include if beneficial
if (list.hasSavings()) {
  tx.accessList = list;
  console.log('✓ Access list included - saves gas');
} else {
  tx.accessList = [];
  console.log('✗ Access list omitted - costs gas');
}

// For repeated swaps in a batch, recalculate with multi-access savings
// Each additional swap saves ~2,300 gas (warm read cost)
const batchSize = 5;
const multiAccessSavings = savings + (2300n * BigInt(batchSize - 1));
console.log(`\nFor ${batchSize}-swap batch:`);
console.log(`  Total savings: ${multiAccessSavings} gas`);
console.log(`  Net: ${multiAccessSavings - cost} gas - ${multiAccessSavings > cost ? '✓ beneficial' : '✗ not beneficial'}`);
```

## Performance

| Operation | Complexity | Notes |
|-----------|-----------|-------|
| gasCost | O(n) | n = items |
| gasSavings | O(n) | n = items |
| includesAddress | O(n) | n = addresses |
| includesStorageKey | O(n×m) | Byte comparison |
| deduplicate | O(n²×m) | Full deduplication |
| withAddress | O(n) | Check + copy |
| withStorageKey | O(n×m) | Check + copy |
| merge | O(k×n²×m) | k lists |

**Optimization Tips:**
- Deduplicate once at end, not after each addition
- Check `includesAddress` before `withAddress`
- Keep lists small - large lists may not benefit
- Cache gas calculations for repeated analysis

## Best Practices

1. **Always deduplicate** before using
2. **Check savings** before including in transaction
3. **Build incrementally** with `withAddress`/`withStorageKey`
4. **Validate external data** with `assertValid`
5. **Use type guards** for runtime safety

## References

- [EIP-2930: Optional Access Lists](https://eips.ethereum.org/EIPS/eip-2930)
- [EIP-2929: Gas Cost Increases](https://eips.ethereum.org/EIPS/eip-2929)
- [EIP-1559: Fee Market](https://eips.ethereum.org/EIPS/eip-1559)

## Gas Optimization Checklist

When optimizing transaction gas costs with access lists:

- [ ] **Is the transaction accessing multiple storage slots?**
  - Access lists only save gas with repeated accesses
  - Single-shot accesses almost always lose gas

- [ ] **Will the same slots be accessed multiple times?**
  - Count intended accesses per slot
  - Each additional access saves ~2,000 gas
  - Break-even typically requires 5+ accesses

- [ ] **Have you deduplicated the access list?**
  - Always call `deduplicate()` before analysis
  - Duplicates waste gas (paid twice for same slot)
  - `withAddress`/`withStorageKey` don't prevent duplicates

- [ ] **Are you only including addresses/keys actually accessed?**
  - Every unnecessary entry costs 2,400/1,900 gas
  - No savings for warm accounts/slots already warm from prior access
  - Verify with contract execution trace

- [ ] **Is this a supported transaction type?**
  - Type 0 (Legacy): ❌ No access list support
  - Type 1 (EIP-2930): ✓ Access lists supported
  - Type 2 (EIP-1559): ✓ Access lists supported
  - Type 3 (EIP-4844 Blob): ✓ Access lists supported

- [ ] **Have you compared with/without access list?**
  - Use `estimateGas()` with and without list
  - Actual gas usage trumps theoretical calculations
  - Some accesses may already be warm from prior calls

## Real-World Optimal Use Cases

**Access lists save gas when:**
1. Batch operations (10+ transactions with same contract)
2. Flashloan liquidations (multiple reads before writes)
3. MEV-related transactions (sandwich trades with repeated accesses)
4. Contract upgrades (many repeated storage reads)

**Access lists waste gas when:**
1. Simple transfers or single-slot operations
2. Already-warm storage (previous operations in same block)
3. External calls that warm accounts automatically
4. Transactions with few storage accesses

## See Also

- [Address](../Address/index.mdx) - Ethereum addresses
- [Hash](../Hash/index.mdx) - 32-byte hashes
- [RLP](../Rlp/index.mdx) - RLP encoding
- [GasConstants](../../GasConstants/) - Cold/warm access costs
- [State](../../State/) - Warm/cold slot tracking
