# Manipulation

Operations for modifying AccessList instances (immutable).

## AccessList.withAddress()

Add address to access list if not already present.

```typescript
AccessList.withAddress(
  list: BrandedAccessList,
  address: BrandedAddress
): BrandedAccessList
```

**Parameters:**
- `list`: Original access list
- `address`: Address to add

**Returns:** New access list with address added

**Example:**
```typescript
let list = AccessList.create();
list = list.withAddress(routerAddress);
list = list.withAddress(tokenAddress);
```

**Behavior:**
- Returns new list (immutable)
- No-op if address already exists
- Adds with empty storageKeys array
- O(n) operation (includes check)

## AccessList.withStorageKey()

Add storage key for address (adds address if needed).

```typescript
AccessList.withStorageKey(
  list: BrandedAccessList,
  address: BrandedAddress,
  key: BrandedHash
): BrandedAccessList
```

**Parameters:**
- `list`: Original access list
- `address`: Address to add key for
- `key`: Storage key to add

**Returns:** New access list with key added

**Example:**
```typescript
let list = AccessList.create();
list = list.withStorageKey(tokenAddress, balanceSlot);
list = list.withStorageKey(tokenAddress, allowanceSlot);
```

**Behavior:**
- Returns new list (immutable)
- Adds address if not present
- No-op if key already exists for address
- O(n×m) operation

## AccessList.deduplicate()

Remove duplicate addresses and storage keys.

```typescript
AccessList.deduplicate(list: BrandedAccessList): BrandedAccessList
```

**Parameters:**
- `list`: Access list to deduplicate

**Returns:** New access list with duplicates removed

**Example:**
```typescript
const list = AccessList.from([
  { address: token, storageKeys: [key1, key2] },
  { address: token, storageKeys: [key2, key3] },  // Duplicate address
  { address: router, storageKeys: [key1] }
]);

const deduped = list.deduplicate();
// Result: [
//   { address: token, storageKeys: [key1, key2, key3] },
//   { address: router, storageKeys: [key1] }
// ]
```

**Behavior:**
- Merges duplicate addresses
- Removes duplicate storage keys within merged addresses
- Preserves original item order (first occurrence)
- O(n²×m) operation (byte-by-byte comparison)

## AccessList.merge()

Combine multiple access lists with automatic deduplication.

```typescript
AccessList.merge(...lists: readonly BrandedAccessList[]): BrandedAccessList
```

**Parameters:**
- `...lists`: Access lists to merge

**Returns:** New merged and deduplicated access list

**Example:**
```typescript
const list1 = AccessList.from([
  { address: token1, storageKeys: [key1] }
]);
const list2 = AccessList.from([
  { address: token2, storageKeys: [key2] }
]);
const list3 = AccessList.from([
  { address: token1, storageKeys: [key3] }
]);

const merged = AccessList.merge(list1, list2, list3);
// Result: [
//   { address: token1, storageKeys: [key1, key3] },
//   { address: token2, storageKeys: [key2] }
// ]
```

**Behavior:**
- Concatenates all lists
- Automatically deduplicates result
- Empty lists are ignored
- O(k×n²×m) operation (k = number of lists)

## Patterns

### Incremental Building

```typescript
let list = AccessList.create();

// Add contracts
list = list.withAddress(routerAddress);
list = list.withAddress(factoryAddress);
list = list.withAddress(tokenAddress);

// Add storage keys
list = list.withStorageKey(tokenAddress, balanceSlot);
list = list.withStorageKey(tokenAddress, allowanceSlot);
list = list.withStorageKey(tokenAddress, totalSupplySlot);

// Deduplicate at end
list = list.deduplicate();
```

### Conditional Addition

```typescript
function addIfMissing(
  list: BrandedAccessList,
  address: BrandedAddress
): BrandedAccessList {
  if (list.includesAddress(address)) {
    return list;
  }
  return list.withAddress(address);
}
```

### Bulk Addition

```typescript
function withAddresses(
  list: BrandedAccessList,
  addresses: BrandedAddress[]
): BrandedAccessList {
  let result = list;
  for (const addr of addresses) {
    result = result.withAddress(addr);
  }
  return result.deduplicate();
}

function withKeys(
  list: BrandedAccessList,
  address: BrandedAddress,
  keys: BrandedHash[]
): BrandedAccessList {
  let result = list;
  for (const key of keys) {
    result = result.withStorageKey(address, key);
  }
  return result;
}
```

### Merge Transaction Lists

```typescript
function combineTransactionLists(
  ...txs: Transaction[]
): BrandedAccessList {
  const lists = txs.map(tx => tx.accessList);
  return AccessList.merge(...lists);
}
```

### Optimize After Building

```typescript
function buildOptimized(): BrandedAccessList {
  let list = AccessList.create();

  // Build without worrying about duplicates
  list = list.withAddress(addr1);
  list = list.withAddress(addr1);  // Duplicate
  list = list.withStorageKey(addr1, key1);
  list = list.withStorageKey(addr1, key1);  // Duplicate

  // Deduplicate once at end
  return list.deduplicate();
}
```

### Builder Pattern

```typescript
class AccessListBuilder {
  private list: BrandedAccessList;

  constructor() {
    this.list = AccessList.create();
  }

  addAddress(address: BrandedAddress): this {
    this.list = this.list.withAddress(address);
    return this;
  }

  addKey(address: BrandedAddress, key: BrandedHash): this {
    this.list = this.list.withStorageKey(address, key);
    return this;
  }

  build(): BrandedAccessList {
    return this.list.deduplicate();
  }
}

const list = new AccessListBuilder()
  .addAddress(router)
  .addKey(token, balanceSlot)
  .addKey(token, allowanceSlot)
  .build();
```

### Safe Merge

```typescript
function safeMerge(
  ...lists: (BrandedAccessList | undefined)[]
): BrandedAccessList {
  const valid = lists.filter(
    (l): l is BrandedAccessList => l !== undefined && !l.isEmpty()
  );

  if (valid.length === 0) {
    return AccessList.create();
  }

  return AccessList.merge(...valid);
}
```

### Immutable Updates

```typescript
// All operations return new lists
const list1 = AccessList.create();
const list2 = list1.withAddress(addr);
const list3 = list2.withStorageKey(addr, key);

// Original unchanged
console.log(list1.isEmpty());  // true
console.log(list2.addressCount());  // 1
console.log(list3.storageKeyCount());  // 1
```

## Performance Considerations

| Operation | Complexity | Notes |
|-----------|-----------|-------|
| withAddress | O(n) | Check + copy array |
| withStorageKey | O(n×m) | Check + copy nested |
| deduplicate | O(n²×m) | Byte comparison |
| merge | O(k×n²×m) | k lists merged |

**Optimization Strategies:**

1. **Deduplicate once at end**
   ```typescript
   // Good: O(n²×m) once
   list = list.withAddress(a1);
   list = list.withAddress(a2);
   list = list.deduplicate();

   // Bad: O(n²×m) twice
   list = list.withAddress(a1).deduplicate();
   list = list.withAddress(a2).deduplicate();
   ```

2. **Check before adding**
   ```typescript
   // Good: Avoid unnecessary copy
   if (!list.includesAddress(addr)) {
     list = list.withAddress(addr);
   }

   // Bad: Always copies even if present
   list = list.withAddress(addr);
   ```

3. **Batch operations**
   ```typescript
   // Good: Build then deduplicate
   for (const addr of addresses) {
     list = list.withAddress(addr);
   }
   list = list.deduplicate();

   // Bad: Deduplicate each time
   for (const addr of addresses) {
     list = list.withAddress(addr).deduplicate();
   }
   ```

4. **Merge once instead of repeated withAddress**
   ```typescript
   // Good: O(k×n²×m) once
   const merged = AccessList.merge(...lists);

   // Bad: O(n) per addition
   let combined = lists[0];
   for (let i = 1; i < lists.length; i++) {
     for (const item of lists[i]) {
       combined = combined.withAddress(item.address);
     }
   }
   ```

## Best Practices

1. **Always deduplicate before using**
   ```typescript
   const list = buildAccessList();
   const optimized = list.deduplicate();
   tx.accessList = optimized;
   ```

2. **Use immutable pattern**
   ```typescript
   // Good: Reassign
   list = list.withAddress(addr);

   // Bad: Ignoring return value
   list.withAddress(addr);  // Original unchanged!
   ```

3. **Build incrementally, optimize once**
   ```typescript
   let list = AccessList.create();
   list = list.withAddress(a1);
   list = list.withAddress(a2);
   list = list.withStorageKey(a1, k1);
   list = list.deduplicate();  // Once at end
   ```

4. **Merge before deduplicating**
   ```typescript
   // Good: Merge handles deduplication
   const list = AccessList.merge(l1, l2, l3);

   // Unnecessary: merge already deduplicates
   const list = AccessList.merge(l1, l2, l3).deduplicate();
   ```

5. **Check before expensive operations**
   ```typescript
   if (!list.isEmpty()) {
     list = list.deduplicate();
   }
   ```

## See Also

- [Constructors](./constructors.mdx) - Creating lists
- [Queries](./queries.mdx) - Inspecting lists
- [Gas Optimization](./gas-optimization.mdx) - Cost analysis
