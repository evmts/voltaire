---
title: BrandedRlp Functional API
description: Tree-shakeable functional API for minimal bundle size
---

import { Tabs, TabItem, Aside } from '@astrojs/starlight/components';

# BrandedRlp Functional API

Tree-shakeable functional API providing data-first methods for minimal bundle size.

## Overview

BrandedRlp exports individual functions that operate on RLP data structures. Each function is independently importable for optimal tree-shaking.

**Benefits:**
- **Tree-shakeable** - Import only needed functions
- **Data-first** - Functions take data as first argument
- **Composable** - Easy to chain and combine
- **Type-safe** - Full TypeScript support

## Import Patterns

### Individual Imports

Import specific functions for maximum tree-shaking:

```typescript
import {
  encode,
  decode,
  from,
  flatten,
  equals
} from '@tevm/voltaire/BrandedRlp'

const data = from(new Uint8Array([1, 2, 3]))
const encoded = encode(data)
const decoded = decode(encoded)
```

### Namespace Import

Import namespace for convenience:

```typescript
import { BrandedRlp } from '@tevm/voltaire/BrandedRlp'

const data = BrandedRlp.from(new Uint8Array([1, 2, 3]))
const encoded = BrandedRlp.encode(data)
```

### Via Main Export

Access through Rlp class static methods:

```typescript
import { Rlp } from '@tevm/voltaire'

const data = Rlp.from(new Uint8Array([1, 2, 3]))
const encoded = Rlp.encode(data)
```

## Available Functions

### Construction

```typescript
import { from } from '@tevm/voltaire/BrandedRlp'

// Create RLP data from various inputs
const bytes = from(new Uint8Array([1, 2, 3]))
const list = from([new Uint8Array([1]), new Uint8Array([2])])
```

Source: [from.js](https://github.com/evmts/voltaire/blob/main/src/primitives/Rlp/BrandedRlp/from.js)

### Type Guards

```typescript
import { isData, isBytesData, isListData } from '@tevm/voltaire/BrandedRlp'

// Check if value is RLP data
if (isData(value)) {
  console.log('Valid RLP data')
}

// Check specific type
if (isBytesData(value)) {
  console.log('Bytes:', value.value)
}

if (isListData(value)) {
  console.log('List with', value.value.length, 'items')
}
```

Source: [isData.js](https://github.com/evmts/voltaire/blob/main/src/primitives/Rlp/BrandedRlp/isData.js), [isBytesData.js](https://github.com/evmts/voltaire/blob/main/src/primitives/Rlp/BrandedRlp/isBytesData.js), [isListData.js](https://github.com/evmts/voltaire/blob/main/src/primitives/Rlp/BrandedRlp/isListData.js)

### Encoding

```typescript
import { encode, encodeBytes, encodeList } from '@tevm/voltaire/BrandedRlp'

// Encode any data
const encoded = encode(new Uint8Array([1, 2, 3]))

// Encode bytes specifically
const bytesEncoded = encodeBytes(new Uint8Array([1, 2, 3]))

// Encode list specifically
const listEncoded = encodeList([new Uint8Array([1]), new Uint8Array([2])])
```

Source: [encode.js](https://github.com/evmts/voltaire/blob/main/src/primitives/Rlp/BrandedRlp/encode.js), [encodeBytes.js](https://github.com/evmts/voltaire/blob/main/src/primitives/Rlp/BrandedRlp/encodeBytes.js), [encodeList.js](https://github.com/evmts/voltaire/blob/main/src/primitives/Rlp/BrandedRlp/encodeList.js)

### Decoding

```typescript
import { decode } from '@tevm/voltaire/BrandedRlp'

// Decode RLP bytes
const result = decode(new Uint8Array([0x83, 1, 2, 3]))
// => { data: { type: 'bytes', value: Uint8Array([1, 2, 3]) }, remainder: Uint8Array([]) }

// Stream decoding
const result = decode(bytes, true)
```

Source: [decode.js](https://github.com/evmts/voltaire/blob/main/src/primitives/Rlp/BrandedRlp/decode.js)

### Utilities

```typescript
import { getEncodedLength, flatten, equals } from '@tevm/voltaire/BrandedRlp'

// Get encoded size
const size = getEncodedLength(data)

// Flatten nested structure
const flattened = flatten(data)

// Compare structures
const equal = equals(data1, data2)
```

Source: [getEncodedLength.js](https://github.com/evmts/voltaire/blob/main/src/primitives/Rlp/BrandedRlp/getEncodedLength.js), [flatten.js](https://github.com/evmts/voltaire/blob/main/src/primitives/Rlp/BrandedRlp/flatten.js), [equals.js](https://github.com/evmts/voltaire/blob/main/src/primitives/Rlp/BrandedRlp/equals.js)

### Serialization

```typescript
import { toJSON, fromJSON } from '@tevm/voltaire/BrandedRlp'

// Convert to JSON
const json = toJSON(data)

// Restore from JSON
const restored = fromJSON(json)
```

Source: [toJSON.js](https://github.com/evmts/voltaire/blob/main/src/primitives/Rlp/BrandedRlp/toJSON.js), [fromJSON.js](https://github.com/evmts/voltaire/blob/main/src/primitives/Rlp/BrandedRlp/fromJSON.js)

## Data-First Design

All functions take data as first argument for easy composition:

```typescript
import { from, encode, decode, flatten } from '@tevm/voltaire/BrandedRlp'

// Pipeline style
const result = flatten(
  decode(
    encode(
      from(new Uint8Array([1, 2, 3]))
    )
  ).data
)

// Or with intermediate variables
const data = from(new Uint8Array([1, 2, 3]))
const encoded = encode(data)
const decoded = decode(encoded)
const flattened = flatten(decoded.data)
```

## Tree-Shaking Benefits

Import only what you need to minimize bundle:

```typescript
// Only includes encode function
import { encode } from '@tevm/voltaire/BrandedRlp'
const encoded = encode(data)

// Includes encode + decode
import { encode, decode } from '@tevm/voltaire/BrandedRlp'

// Full namespace (includes all functions)
import { BrandedRlp } from '@tevm/voltaire/BrandedRlp'
```

**Bundle Size Comparison:**

| Import | Functions | Approx Size |
|--------|-----------|-------------|
| `encode` only | 1 | ~2 KB |
| `encode, decode` | 2 | ~5 KB |
| `BrandedRlp` namespace | All (13) | ~8 KB |
| `Rlp` class | All + class | ~10 KB |

## Composing Functions

Build complex operations from simple functions:

```typescript
import {
  from,
  encode,
  decode,
  flatten,
  equals,
  getEncodedLength
} from '@tevm/voltaire/BrandedRlp'

// Custom utility: encode and measure
function encodeWithSize(input: Uint8Array) {
  const data = from(input)
  const size = getEncodedLength(data)
  const encoded = encode(data)
  return { encoded, size }
}

// Custom utility: decode and flatten
function decodeAndFlatten(bytes: Uint8Array) {
  const result = decode(bytes)
  return flatten(result.data)
}

// Custom utility: encode if changed
let cachedData: BrandedRlp | null = null
function encodeIfChanged(data: BrandedRlp): Uint8Array | null {
  if (cachedData && equals(data, cachedData)) {
    return null  // No change
  }
  cachedData = data
  return encode(data)
}
```

## Functional Patterns

### Partial Application

Create specialized functions:

```typescript
import { encode, decode } from '@tevm/voltaire/BrandedRlp'

// Create specialized encoder
const encodeTransaction = (tx: Transaction) => {
  const data = transactionToRlp(tx)
  return encode(data)
}

// Create specialized decoder
const decodeTransaction = (bytes: Uint8Array) => {
  const result = decode(bytes)
  return rlpToTransaction(result.data)
}
```

### Higher-Order Functions

Wrap functions for additional behavior:

```typescript
import { encode, decode } from '@tevm/voltaire/BrandedRlp'

// Add logging
function withLogging<T extends (...args: any[]) => any>(fn: T): T {
  return ((...args: any[]) => {
    console.log(`Calling ${fn.name} with:`, args)
    const result = fn(...args)
    console.log(`Result:`, result)
    return result
  }) as T
}

const loggedEncode = withLogging(encode)
const loggedDecode = withLogging(decode)
```

### Pipeline Operations

Chain operations fluently:

```typescript
import { from, encode, decode, flatten } from '@tevm/voltaire/BrandedRlp'

// Create pipeline helper
function pipe<T>(...fns: Array<(arg: any) => any>) {
  return (initial: T) => fns.reduce((acc, fn) => fn(acc), initial)
}

// Build pipeline
const processRlp = pipe(
  from,
  encode,
  (encoded) => decode(encoded),
  (decoded) => flatten(decoded.data)
)

const result = processRlp(new Uint8Array([1, 2, 3]))
```

## Type Safety

Full TypeScript support with type inference:

```typescript
import { from, encode, decode, flatten, isBytesData } from '@tevm/voltaire/BrandedRlp'

// Type inference works correctly
const data = from(new Uint8Array([1, 2, 3]))
// data: BrandedRlp

const encoded = encode(data)
// encoded: Uint8Array

const decoded = decode(encoded)
// decoded: { data: BrandedRlp, remainder: Uint8Array }

const flattened = flatten(decoded.data)
// flattened: BytesData[]

// Type guards narrow types
if (isBytesData(data)) {
  // data.value is Uint8Array here
  const bytes: Uint8Array = data.value
}
```

## Error Handling

Functions throw typed errors:

```typescript
import { decode, fromJSON } from '@tevm/voltaire/BrandedRlp'

try {
  const result = decode(new Uint8Array([]))
} catch (error) {
  if (error instanceof Error) {
    console.error('Decode error:', error.message)
  }
}

try {
  const data = fromJSON({ invalid: 'format' })
} catch (error) {
  if (error instanceof Error) {
    console.error('JSON error:', error.message)
  }
}
```

## Performance Tips

### Prefer Specific Functions

Use specific functions when type is known:

```typescript
import { encode, encodeBytes, encodeList } from '@tevm/voltaire/BrandedRlp'

// Less efficient: type dispatch
const encoded = encode(data)

// More efficient: direct call
const encoded = encodeBytes(new Uint8Array([1, 2, 3]))
const encoded = encodeList([bytes1, bytes2])
```

### Batch Operations

Process multiple items efficiently:

```typescript
import { encode, getEncodedLength } from '@tevm/voltaire/BrandedRlp'

// Calculate total size first
const items = [data1, data2, data3]
const totalSize = items.reduce((sum, item) => sum + getEncodedLength(item), 0)

// Allocate single buffer
const buffer = new Uint8Array(totalSize)

// Encode into buffer (conceptual)
let offset = 0
for (const item of items) {
  const encoded = encode(item)
  buffer.set(encoded, offset)
  offset += encoded.length
}
```

<Aside type="tip">
The functional API is ideal for applications that need minimal bundle size or prefer functional programming patterns. Use class API if you prefer object-oriented style.
</Aside>

## Namespace Export

All functions available on namespace:

```typescript
import { BrandedRlp } from '@tevm/voltaire/BrandedRlp'

// Construction
BrandedRlp.from()

// Type guards
BrandedRlp.isData()
BrandedRlp.isBytesData()
BrandedRlp.isListData()

// Encoding
BrandedRlp.encode()
BrandedRlp.encodeBytes()
BrandedRlp.encodeList()

// Decoding
BrandedRlp.decode()

// Utilities
BrandedRlp.getEncodedLength()
BrandedRlp.flatten()
BrandedRlp.equals()

// Serialization
BrandedRlp.toJSON()
BrandedRlp.fromJSON()
```

Source: [index.ts:38-52](https://github.com/evmts/voltaire/blob/main/src/primitives/Rlp/BrandedRlp/index.ts#L38-L52)

## Related

- [Types](/primitives/rlp/types) - RLP type system
- [Encoding](/primitives/rlp/encoding) - Encoding methods
- [Decoding](/primitives/rlp/decoding) - Decoding methods
- [Utilities](/primitives/rlp/utilities) - Helper functions
- [Branded Types](/primitives/branded-types) - Type branding pattern
