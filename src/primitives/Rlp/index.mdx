---
title: Rlp (Recursive Length Prefix)
description: Ethereum's canonical serialization format for encoding nested data structures
---

import { Tabs, TabItem, Card, CardGrid, Aside } from '@astrojs/starlight/components';

# Rlp (Recursive Length Prefix)

Ethereum's canonical serialization format for encoding arbitrarily nested arrays of binary data.

## Overview

[Branded](/primitives/branded-types) type representing RLP (Recursive Length Prefix) encoded data structures. RLP is Ethereum's primary encoding method, providing deterministic serialization for transactions, blocks, state tries, and network protocols.

## Quick Start

<Tabs>
<TabItem label="Class API">
```typescript
import { Rlp } from '@tevm/voltaire'

// Encode bytes
const bytes = new Uint8Array([1, 2, 3])
const encoded = Rlp.encode(bytes)
// => Uint8Array([0x83, 1, 2, 3])

// Encode list
const list = [
  new Uint8Array([0x01]),
  new Uint8Array([0x02])
]
const encodedList = Rlp.encode(list)
// => Uint8Array([0xc4, 0x01, 0x02])

// Encode nested structures
const nested = [
  new Uint8Array([1]),
  [new Uint8Array([2]), new Uint8Array([3])]
]
const encodedNested = Rlp.encode(nested)

// Decode RLP data
const decoded = Rlp.decode(encoded)
// => { data: { type: 'bytes', value: Uint8Array([1, 2, 3]) }, remainder: Uint8Array([]) }

// Work with RLP data structures
const rlpData = Rlp.from(new Uint8Array([1, 2, 3]))
const encodedData = Rlp.encode(rlpData)
const length = Rlp.getEncodedLength(rlpData)

// Type guards
if (Rlp.isBytesData(rlpData)) {
  console.log('Bytes:', rlpData.value)
}
if (Rlp.isListData(rlpData)) {
  console.log('List with', rlpData.value.length, 'items')
}

// Utilities
const flattened = Rlp.flatten(nested)
const equal = Rlp.equals(rlpData, rlpData)

// Serialization
const json = Rlp.toJSON(rlpData)
const restored = Rlp.fromJSON(json)
```
</TabItem>
<TabItem label="Namespace API (Tree-shakeable)">
```typescript
import { Rlp } from '@tevm/voltaire'

// Tree-shakeable imports minimize bundle size
const bytes = new Uint8Array([1, 2, 3])
const encoded = Rlp.encode(bytes)
const decoded = Rlp.decode(encoded)

// Each function imported independently
Rlp.encodeBytes(new Uint8Array([1, 2, 3]))
Rlp.encodeList([new Uint8Array([1]), new Uint8Array([2])])
Rlp.getEncodedLength(bytes)
Rlp.flatten(decoded.data)

// Or import specific functions
import {
  encode,
  decode,
  encodeBytes,
  encodeList,
  from,
  getEncodedLength
} from '@tevm/voltaire/BrandedRlp'

const data = encode(new Uint8Array([1, 2, 3]))
const result = decode(data)
const rlpData = from(new Uint8Array([1, 2, 3]))
const length = getEncodedLength(rlpData)

// See BrandedRlp for complete functional API
```
</TabItem>
</Tabs>

## What is RLP?

RLP (Recursive Length Prefix) encodes arbitrarily nested arrays of binary data with a compact, deterministic representation.

**Key Properties:**
- **Deterministic** - Same input always produces same output
- **Space-efficient** - Minimal overhead for encoding
- **Simple** - Only encodes structure, not types
- **Fast** - Optimized for performance-critical operations
- **Canonical** - Ensures unique serialization of data

**Common Uses:**
- Transaction encoding for signing and broadcast
- Block and block header serialization
- State trie node encoding
- Network protocol message encoding
- Receipt and log serialization

## Types

<Tabs>
<TabItem label="class Rlp">
```typescript
class Rlp {
  // Constructor
  constructor(value: Uint8Array | BrandedRlp | BrandedRlp[]): BrandedRlp

  // Static methods
  static from(value: Uint8Array | BrandedRlp | BrandedRlp[]): BrandedRlp

  // Type guards (→ /primitives/rlp/types)
  static isData(value: unknown): value is BrandedRlp
  static isBytesData(value: unknown): boolean
  static isListData(value: unknown): boolean

  // Encoding (→ /primitives/rlp/encoding)
  static encode(data: Encodable): Uint8Array
  static encodeBytes(bytes: Uint8Array): Uint8Array
  static encodeList(items: Encodable[]): Uint8Array

  // Decoding (→ /primitives/rlp/decoding)
  static decode(bytes: Uint8Array, stream?: boolean): Decoded

  // Utilities (→ /primitives/rlp/utilities)
  static getEncodedLength(data: Encodable): number
  static flatten(data: BrandedRlp): BytesData[]
  static equals(data: BrandedRlp, other: BrandedRlp): boolean

  // Serialization (→ /primitives/rlp/serialization)
  static toJSON(data: BrandedRlp): unknown
  static fromJSON(json: unknown): BrandedRlp

  // Instance methods
  encode(): Uint8Array
  flatten(): BytesData[]
  equals(other: BrandedRlp): boolean
  getEncodedLength(): number
  toJSON(): unknown
}
```

Source: [RlpConstructor.ts:24-40](https://github.com/evmts/voltaire/blob/main/src/primitives/Rlp/RlpConstructor.ts#L24-L40)
</TabItem>
<TabItem label="type BrandedRlp">
```typescript
export type BrandedRlp =
  | { type: "bytes"; value: Uint8Array }
  | { type: "list"; value: BrandedRlp[] }
```

[Branded type](/primitives/branded-types) representing RLP data structures. Union of bytes data (leaf nodes) and list data (nested arrays). Used as underlying type for Rlp class and tree-shakeable functions.

**BytesData:** Leaf node containing raw bytes
```typescript
{ type: "bytes", value: Uint8Array }
```

**ListData:** Nested array of RLP data
```typescript
{ type: "list", value: BrandedRlp[] }
```

Source: [BrandedRlp.ts:4-6](https://github.com/evmts/voltaire/blob/main/src/primitives/Rlp/BrandedRlp/BrandedRlp.ts#L4-L6)
</TabItem>
<TabItem label="type Encodable">
```typescript
export type Encodable =
  | Uint8Array
  | BrandedRlp
  | Array<Uint8Array | BrandedRlp | any>
```

Input type for encoding methods. Accepts raw bytes, RLP data structures, or nested arrays.

Source: [encode.js:7](https://github.com/evmts/voltaire/blob/main/src/primitives/Rlp/BrandedRlp/encode.js#L7)
</TabItem>
<TabItem label="type Decoded">
```typescript
export type Decoded = {
  data: BrandedRlp
  remainder: Uint8Array
}
```

Return type for decode operations. Contains decoded RLP data and any remaining bytes (for stream decoding).

Source: [decode.js:6-9](https://github.com/evmts/voltaire/blob/main/src/primitives/Rlp/BrandedRlp/decode.js#L6-L9)
</TabItem>
</Tabs>

## RLP Encoding Rules

RLP uses prefix bytes to indicate data type and length:

### Single Bytes (0x00-0x7f)
Bytes with values less than 0x80 encode as themselves (no prefix).

```typescript
const input = new Uint8Array([0x7f])
const encoded = Rlp.encode(input)
// => Uint8Array([0x7f])
```

### Short Strings (0-55 bytes)
Strings of 0-55 bytes: `[0x80 + length, ...bytes]`

```typescript
const input = new Uint8Array([1, 2, 3])  // 3 bytes
const encoded = Rlp.encode(input)
// => Uint8Array([0x83, 1, 2, 3])
// 0x83 = 0x80 + 3
```

### Long Strings (56+ bytes)
Strings of 56+ bytes: `[0xb7 + length_of_length, ...length_bytes, ...bytes]`

```typescript
const input = new Uint8Array(60).fill(0x42)  // 60 bytes
const encoded = Rlp.encode(input)
// => Uint8Array([0xb8, 60, ...bytes])
// 0xb8 = 0xb7 + 1 (length needs 1 byte)
```

### Short Lists (0-55 bytes total)
Lists with total payload < 56 bytes: `[0xc0 + length, ...encoded_items]`

```typescript
const list = [new Uint8Array([0x01]), new Uint8Array([0x02])]
const encoded = Rlp.encode(list)
// => Uint8Array([0xc4, 0x01, 0x02, 0x02])
// 0xc4 = 0xc0 + 4
```

### Long Lists (56+ bytes total)
Lists with total payload >= 56 bytes: `[0xf7 + length_of_length, ...length_bytes, ...encoded_items]`

```typescript
const longList = Array.from({ length: 60 }, () => new Uint8Array([0x01]))
const encoded = Rlp.encode(longList)
// First byte will be 0xf8 or higher
```

See [Algorithm](/primitives/rlp/algorithm) for complete specification.

## API Documentation

<CardGrid>
  <Card title="Encoding" icon="rocket">
    Encode bytes, lists, and nested structures using RLP format.

    [View encoding →](/primitives/rlp/encoding)
  </Card>

  <Card title="Decoding" icon="document">
    Decode RLP-encoded bytes back to data structures with stream support.

    [View decoding →](/primitives/rlp/decoding)
  </Card>

  <Card title="Types" icon="seti:config">
    RlpData type system with bytes and list variants, plus type guards.

    [View types →](/primitives/rlp/types)
  </Card>

  <Card title="Utilities" icon="puzzle">
    Helper methods: from, getEncodedLength, flatten, equals for working with RLP data.

    [View utilities →](/primitives/rlp/utilities)
  </Card>

  <Card title="Serialization" icon="random">
    JSON serialization with toJSON and fromJSON for persistence and debugging.

    [View serialization →](/primitives/rlp/serialization)
  </Card>

  <Card title="BrandedRlp" icon="seti:config">
    Tree-shakeable functional API for minimal bundle size.

    [View BrandedRlp →](/primitives/rlp/branded-rlp)
  </Card>

  <Card title="Algorithm" icon="open-book">
    Deep dive into RLP encoding algorithm and Ethereum Yellow Paper specification.

    [View algorithm →](/primitives/rlp/algorithm)
  </Card>

  <Card title="WASM Implementation" icon="rocket">
    WebAssembly-accelerated encoding compiled from Zig for performance.

    [View WASM →](/primitives/rlp/wasm)
  </Card>

  <Card title="Usage Patterns" icon="list-format">
    Common RLP usage patterns in Ethereum transactions, blocks, and receipts.

    [View patterns →](/primitives/rlp/usage-patterns)
  </Card>
</CardGrid>

<Aside type="tip" title="Canonical Encoding">
RLP enforces canonical encoding rules to ensure deterministic serialization. For example, single bytes < 0x80 must not have a length prefix, and length encodings must use the minimum number of bytes.
</Aside>

## Error Handling

RLP operations throw typed errors for invalid inputs:

```typescript
import { Rlp } from '@tevm/voltaire'

try {
  // Empty input
  Rlp.decode(new Uint8Array([]))
} catch (error) {
  console.error('InputTooShort: Cannot decode empty input')
}

try {
  // Extra data without stream mode
  const bytes = new Uint8Array([0x01, 0x02])
  Rlp.decode(bytes, false)
} catch (error) {
  console.error('InvalidRemainder: Extra data after decoded value')
}

try {
  // Non-canonical encoding
  const nonCanonical = new Uint8Array([0x81, 0x7f])
  Rlp.decode(nonCanonical)
} catch (error) {
  console.error('NonCanonicalSize: Single byte < 0x80 should not be prefixed')
}

try {
  // Leading zeros in length encoding
  const leadingZeros = new Uint8Array([0xb8, 0x00, 0x01])
  Rlp.decode(leadingZeros)
} catch (error) {
  console.error('LeadingZeros: Length encoding has leading zeros')
}
```

**Error Types:**
- `InputTooShort` - Unexpected end of input
- `InvalidRemainder` - Extra data after decoded value
- `NonCanonicalSize` - Non-minimal length encoding
- `LeadingZeros` - Invalid number encoding
- `InvalidLength` - Malformed length field
- `RecursionDepthExceeded` - Nested too deeply (max 32)
- `UnexpectedInput` - Invalid data format

Source: [errors.js](https://github.com/evmts/voltaire/blob/main/src/primitives/Rlp/BrandedRlp/errors.js)

## Related Types

<CardGrid stagger>
  <Card title="Hex" icon="seti:text">
    Hex string utilities for encoding RLP data as strings.

    [View Hex →](/primitives/hex)
  </Card>

  <Card title="Bytes" icon="document">
    Byte array operations for binary data handling.

    [View Bytes →](/primitives/bytes)
  </Card>

  <Card title="Transaction" icon="list-format">
    Uses RLP encoding for transaction serialization.

    [View Transaction →](/primitives/transaction)
  </Card>

  <Card title="Branded Types" icon="open-book">
    Zero-overhead type branding pattern used throughout primitives.

    [View Branded Types →](/primitives/branded-types)
  </Card>
</CardGrid>
