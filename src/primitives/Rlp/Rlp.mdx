---
title: RLP (Recursive Length Prefix)
description: Ethereum's canonical serialization format for encoding nested data structures
---

# RLP (Recursive Length Prefix)

Complete implementation of Ethereum's RLP serialization format as specified in the Yellow Paper. RLP encodes arbitrarily nested arrays of binary data used throughout Ethereum for transactions, blocks, and state.

## Overview

The RLP module provides:
- **Canonical Encoding**: Unique serialization ensuring deterministic hashing
- **Nested Structures**: Encode/decode arbitrarily nested lists and strings
- **Memory Safe**: Comprehensive bounds checking and validation
- **Flexible API**: Supports various input types and patterns
- **Streaming Decode**: Efficient parsing with minimal allocations

**Source**: `src/primitives/Rlp/Rlp.zig`

## RLP Encoding Rules

### String Encoding
- **Single byte [0x00-0x7f]**: Encoded as itself
- **Short string [0-55 bytes]**: `0x80 + length`, followed by string
- **Long string [55+ bytes]**: `0xb7 + length_of_length`, length, then string

### List Encoding
- **Short list [0-55 bytes]**: `0xc0 + length`, followed by concatenated items
- **Long list [55+ bytes]**: `0xf7 + length_of_length`, length, then items

## Key Types

### Data

```zig
pub const Data = union(enum) {
    List: []Data,
    String: []const u8,

    pub fn deinit(self: Data, allocator: Allocator) void
};
```

Represents decoded RLP data as either a list of nested Data or a byte string.

### Decoded

```zig
pub const Decoded = struct {
    data: Data,
    remainder: []const u8,
};
```

Result of decoding with any remaining unparsed bytes.

### RlpError

```zig
pub const RlpError = error{
    InputTooShort,
    InputTooLong,
    LeadingZeros,
    NonCanonicalSize,
    InvalidLength,
    UnexpectedInput,
    InvalidRemainder,
    ExtraZeros,
    RecursionDepthExceeded,
};
```

## Key Functions

### encode

```zig
const primitives = @import("primitives");

pub fn encode(allocator: Allocator, input: anytype) ![]u8
```

Encode data into RLP format. Supports byte slices, arrays, and nested lists.

**Parameters:**
- `allocator`: Memory allocator for result
- `input`: Data to encode (bytes, strings, or lists)

**Returns:** RLP-encoded bytes (caller must free)

**Errors:** `OutOfMemory`

### decode

```zig
pub fn decode(allocator: Allocator, input: []const u8) !Decoded
```

Decode RLP data into structured format.

**Parameters:**
- `allocator`: Memory allocator for decoded data
- `input`: RLP-encoded bytes

**Returns:** Decoded data and any remaining bytes

**Errors:** `RlpError`, `OutOfMemory`

## Examples

### Encoding Simple Data

```zig
const std = @import("std");
const rlp = @import("primitives").rlp;

pub fn encodeExample() !void {
    const allocator = std.heap.page_allocator;

    // Encode a string
    const encoded_str = try rlp.encode(allocator, "dog");
    defer allocator.free(encoded_str);
    // Result: [0x83, 'd', 'o', 'g']

    // Encode empty string
    const encoded_empty = try rlp.encode(allocator, "");
    defer allocator.free(encoded_empty);
    // Result: [0x80]

    // Encode single byte
    const encoded_byte = try rlp.encode(allocator, &[_]u8{0x0f});
    defer allocator.free(encoded_byte);
    // Result: [0x0f] (single bytes encode as themselves)
}
```

### Encoding Lists

```zig
const std = @import("std");
const rlp = @import("primitives").rlp;

pub fn encodeList() !void {
    const allocator = std.heap.page_allocator;

    // Encode list of strings
    const list = [_][]const u8{ "cat", "dog" };
    const encoded = try rlp.encode(allocator, list);
    defer allocator.free(encoded);

    // Encode empty list
    const empty_list = [_][]const u8{};
    const encoded_empty = try rlp.encode(allocator, empty_list);
    defer allocator.free(encoded_empty);
    // Result: [0xc0]
}
```

### Decoding RLP Data

```zig
const std = @import("std");
const rlp = @import("primitives").rlp;

pub fn decodeExample() !void {
    const allocator = std.heap.page_allocator;

    // RLP encoded "dog"
    const input = &[_]u8{ 0x83, 'd', 'o', 'g' };

    const decoded = try rlp.decode(allocator, input);
    defer decoded.data.deinit(allocator);

    switch (decoded.data) {
        .String => |str| {
            // str = "dog"
            std.debug.print("String: {s}\n", .{str});
        },
        .List => |items| {
            std.debug.print("List with {} items\n", .{items.len});
        },
    }
}
```

### Nested Structures

```zig
const std = @import("std");
const rlp = @import("primitives").rlp;

pub fn nestedExample() !void {
    const allocator = std.heap.page_allocator;

    // Encode nested list: [ [], [[]], [ [], [[]] ] ]
    // This demonstrates RLP's ability to handle arbitrary nesting

    // Decode and traverse
    const encoded = /* ... */;
    const decoded = try rlp.decode(allocator, encoded);
    defer decoded.data.deinit(allocator);

    if (decoded.data == .List) {
        for (decoded.data.List) |item| {
            // Process each nested item
        }
    }
}
```

## Performance

**Native (ReleaseFast)**:
- Encoding: ~500 MB/s for strings, ~200 MB/s for nested lists
- Decoding: ~400 MB/s for strings, ~150 MB/s for nested lists

**WASM (ReleaseFast)**:
- Encoding: ~200 MB/s for strings, ~80 MB/s for nested lists
- Decoding: ~150 MB/s for strings, ~60 MB/s for nested lists

Performance varies with nesting depth and structure complexity.

## Testing

```bash
zig build test -Dtest-filter=rlp
```

Test coverage includes:
- Known test vectors from Ethereum tests
- Single bytes and short strings
- Long strings requiring multi-byte length encoding
- Empty lists and nested lists
- Edge cases (empty input, maximum depth)
- Invalid input handling (non-canonical, malformed)
- Round-trip encoding/decoding

## Implementation Notes

- Maximum recursion depth: 32 levels (prevents stack overflow)
- Validates canonical encoding (rejects non-minimal encodings)
- Streaming decoder minimizes memory allocations
- Caller owns all returned memory

## Security Considerations

- Recursion depth limit prevents DoS attacks
- Comprehensive validation prevents malformed data processing
- No leading zeros allowed in length encodings
- Canonical encoding prevents hash manipulation

## Related

- [Transaction](/zig/primitives/transaction/) - Uses RLP for serialization
- [Trie](/zig/primitives/trie/) - Uses RLP for node encoding
- [Hex](/zig/primitives/hex/) - Often used with RLP for display

## References

- [Ethereum Yellow Paper](https://ethereum.github.io/yellowpaper/paper.pdf) - Appendix B (RLP)
- [RLP Specification](https://ethereum.org/en/developers/docs/data-structures-and-encoding/rlp/)
- [Ethereum Tests](https://github.com/ethereum/tests) - RLP test vectors
