---
title: State
description: EVM storage key representation for contract state tracking
---

import { Tabs, TabItem, Card, CardGrid, Aside } from '@astrojs/starlight/components';

# State

EVM storage key representation combining contract addresses with storage slots for state tracking.

## Overview

State provides StorageKey primitive for uniquely identifying storage locations in the EVM. Each StorageKey combines a 20-byte contract address with a 256-bit storage slot number, enabling efficient tracking of contract state across multiple contracts in a single VM instance.

## Quick Start

<Tabs>
<TabItem label="Basic Usage">
```typescript
import * as State from '@tevm/primitives/State'
import * as Address from '@tevm/primitives/Address'

// Create storage key
const key = State.StorageKey(
  Address.from("0x742d35Cc6634C0532925a3b844Bc9e7595f51e3e"),
  0n  // First storage slot
)

// Create using from()
const key2 = State.StorageKey.from({
  address: contractAddress,
  slot: 42n
})

// Create directly
const key3 = State.StorageKey.create(contractAddress, 100n)
```
</TabItem>
<TabItem label="String Serialization">
```typescript
import * as State from '@tevm/primitives/State'

const key = State.StorageKey(contractAddress, 42n)

// Convert to string for map keys
const keyStr = State.StorageKey.toString(key)
// "0x742d35cc6634c0532925a3b844bc9e7595f51e3e:42"

// Parse from string
const parsed = State.StorageKey.fromString(keyStr)
// { address: BrandedAddress(...), slot: 42n }

// Use in Maps
const storage = new Map<string, bigint>()
storage.set(State.StorageKey.toString(key), 1000n)
```
</TabItem>
<TabItem label="Comparison">
```typescript
import * as State from '@tevm/primitives/State'

const key1 = State.StorageKey(addr, 42n)
const key2 = State.StorageKey(addr, 42n)
const key3 = State.StorageKey(addr, 100n)

// Check equality
State.StorageKey.equals(key1, key2)  // true
State.StorageKey.equals(key1, key3)  // false

// Type guard
State.StorageKey.is(key1)  // true
State.StorageKey.is({ address: addr, slot: 42n })  // true
```
</TabItem>
<TabItem label="Hash Codes">
```typescript
import * as State from '@tevm/primitives/State'

const key = State.StorageKey(contractAddress, 42n)

// Get numeric hash code for hash maps
const hash = State.StorageKey.hashCode(key)
// Deterministic number derived from address + slot

// Use in hash-based data structures
const bucketIndex = hash % numBuckets
```
</TabItem>
</Tabs>

## Type Definition

```typescript
/**
 * Composite key for EVM storage operations combining address and slot.
 */
export type BrandedStorageKey = {
  /**
   * The contract address that owns this storage slot.
   * Standard 20-byte Ethereum address.
   */
  readonly address: BrandedAddress

  /**
   * The 256-bit storage slot number within the contract's storage space.
   * Slots are sparsely allocated - most remain at zero value.
   */
  readonly slot: bigint
}
```

Source: [BrandedStorageKey.ts:35-47](https://github.com/evmts/primitives/blob/main/src/primitives/State/BrandedState/BrandedStorageKey.ts#L35-L47)

## Storage Model

In the EVM:
- Each contract has 2^256 storage slots (340 undecillion slots)
- Each slot stores a 256-bit value (32 bytes)
- Slots are initially zero and only consume gas when first written (SSTORE)
- Storage is persistent across transactions
- Storage slots are addressed by position (0, 1, 2, ..., 2^256-1)

```solidity
contract Example {
  uint256 public value;        // slot 0
  address public owner;        // slot 1
  mapping(address => uint256) public balances;  // keccak256(key, slot) for slot 2
}
```

## Core Methods

### StorageKey() / create()

Create new StorageKey.

```typescript
// Factory function
const key = State.StorageKey(contractAddress, 42n)

// Static method (same)
const key2 = State.StorageKey.create(contractAddress, 42n)
```

### from()

Flexible constructor accepting various formats.

```typescript
// From object
const key = State.StorageKey.from({
  address: contractAddress,
  slot: 42n
})

// From existing StorageKey (no-op)
const key2 = State.StorageKey.from(key)
```

### is()

Type guard checking if value is StorageKey.

```typescript
State.StorageKey.is(key)  // true
State.StorageKey.is({ address: addr, slot: 0n })  // true
State.StorageKey.is({ address: addr })  // false (missing slot)
State.StorageKey.is(null)  // false
```

### equals()

Check equality between two StorageKeys.

```typescript
const key1 = State.StorageKey(addr1, 42n)
const key2 = State.StorageKey(addr1, 42n)
const key3 = State.StorageKey(addr2, 42n)

State.StorageKey.equals(key1, key2)  // true (same address & slot)
State.StorageKey.equals(key1, key3)  // false (different address)
```

### toString()

Serialize to string format.

```typescript
const key = State.StorageKey(addr, 42n)

const str = State.StorageKey.toString(key)
// "0x742d35cc6634c0532925a3b844bc9e7595f51e3e:42"
```

Format: `{address}:{slot}` where address is lowercase hex without 0x prefix in the implementation.

### fromString()

Parse StorageKey from string.

```typescript
const str = "0x742d35cc6634c0532925a3b844bc9e7595f51e3e:42"

const key = State.StorageKey.fromString(str)
// { address: BrandedAddress(...), slot: 42n }
```

### hashCode()

Generate numeric hash for hash-based data structures.

```typescript
const key = State.StorageKey(addr, 42n)

const hash = State.StorageKey.hashCode(key)
// Deterministic number based on address + slot

// Use for bucketing
const bucket = hash % buckets.length
```

## Use Cases

### State Tracking

```typescript
import * as State from '@tevm/primitives/State'

// Track storage state across contracts
const storage = new Map<string, bigint>()

function setStorage(address: BrandedAddress, slot: bigint, value: bigint) {
  const key = State.StorageKey(address, slot)
  const keyStr = State.StorageKey.toString(key)
  storage.set(keyStr, value)
}

function getStorage(address: BrandedAddress, slot: bigint): bigint {
  const key = State.StorageKey(address, slot)
  const keyStr = State.StorageKey.toString(key)
  return storage.get(keyStr) ?? 0n
}
```

### Storage Diff Tracking

```typescript
// Track state changes during transaction execution
const changes = new Map<string, { before: bigint, after: bigint }>()

function recordChange(key: BrandedStorageKey, before: bigint, after: bigint) {
  const keyStr = State.StorageKey.toString(key)
  changes.set(keyStr, { before, after })
}

// Revert changes
function revert() {
  for (const [keyStr, { before }] of changes) {
    const key = State.StorageKey.fromString(keyStr)
    storage.set(keyStr, before)
  }
  changes.clear()
}
```

### Access Lists (EIP-2930)

```typescript
// Track accessed storage slots for gas calculation
const accessedSlots = new Set<string>()

function accessSlot(address: BrandedAddress, slot: bigint): boolean {
  const key = State.StorageKey(address, slot)
  const keyStr = State.StorageKey.toString(key)

  const wasAccessed = accessedSlots.has(keyStr)
  accessedSlots.add(keyStr)

  // Return true if first access (warm vs cold gas cost)
  return !wasAccessed
}
```

### State Root Calculation

```typescript
// Build Merkle Patricia Trie for state root
import { MerklePatriciaTrie } from '@ethereumjs/trie'

const trie = new MerklePatriciaTrie()

for (const [keyStr, value] of storage) {
  const key = State.StorageKey.fromString(keyStr)

  // Key: keccak256(address || slot)
  const trieKey = keccak256(
    concat([key.address, toBytes32(key.slot)])
  )

  // Value: RLP-encoded
  await trie.put(trieKey, rlpEncode(value))
}

const stateRoot = await trie.root()
```

### Storage Slot Calculation

```typescript
// Calculate mapping slot: keccak256(key || slot)
function getMappingSlot(key: Uint8Array, baseSlot: bigint): bigint {
  const hash = keccak256(concat([key, toBytes32(baseSlot)]))
  return bytesToBigInt(hash)
}

// Example: balances[addr] at slot 2
const balanceSlot = getMappingSlot(
  Address.toBytes(userAddress),
  2n  // mapping base slot
)

const balanceKey = State.StorageKey(tokenContract, balanceSlot)
const balance = storage.get(State.StorageKey.toString(balanceKey)) ?? 0n
```

## Storage Constants

```typescript
// Common storage slot patterns
export const SLOT_0 = 0n                    // First slot
export const SLOT_IMPLEMENTATION = 0n       // Proxy implementation slot (EIP-1967: 0x360...)
export const SLOT_BEACON = 1n               // Beacon proxy slot
export const SLOT_ADMIN = 2n                // Admin slot

// EIP-1967: Standard proxy storage slots
export const EIP1967_IMPLEMENTATION_SLOT =
  0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbcn

export const EIP1967_BEACON_SLOT =
  0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50n

export const EIP1967_ADMIN_SLOT =
  0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103n
```

## Storage Layout

Solidity storage layout rules:

1. **State variables**: Packed sequentially starting at slot 0
2. **Mappings**: `keccak256(h(key) || baseSlot)` where h() is padding function
3. **Dynamic arrays**: Length at baseSlot, elements at `keccak256(baseSlot) + index`
4. **Structs**: Members packed into consecutive slots
5. **Inheritance**: Base contract variables first, then derived

```solidity
contract StorageExample {
  uint256 a;           // slot 0
  uint256 b;           // slot 1
  mapping(address => uint256) balances;  // slot 2 (base), actual at keccak256(key || 2)
  uint256[] array;     // slot 3 (length), elements at keccak256(3) + index
}
```

<Aside type="tip" title="Storage Optimization">
Solidity packs variables smaller than 32 bytes into the same slot. Order state variables by size to minimize gas costs.

```solidity
// Inefficient: 3 slots
uint256 a;  // slot 0
uint8 b;    // slot 1
uint256 c;  // slot 2

// Efficient: 2 slots
uint256 a;  // slot 0
uint256 c;  // slot 1
uint8 b;    // slot 1 (packed with c)
```
</Aside>

## Related Types

<CardGrid stagger>
  <Card title="Address" icon="document">
    20-byte contract addresses used in storage keys.

    [View Address →](/primitives/address)
  </Card>

  <Card title="Hash" icon="seti:text">
    Keccak256 hashing for storage slot calculations.

    [View Hash →](/primitives/hash)
  </Card>

  <Card title="Rlp" icon="puzzle">
    RLP encoding for state trie values.

    [View Rlp →](/primitives/rlp)
  </Card>

  <Card title="Transaction" icon="rocket">
    Transactions that modify contract storage.

    [View Transaction →](/primitives/transaction)
  </Card>
</CardGrid>

## Specification References

- [Ethereum Yellow Paper](https://ethereum.github.io/yellowpaper/paper.pdf) - Section 4.1: World State
- [Solidity Storage Layout](https://docs.soliditylang.org/en/latest/internals/layout_in_storage.html) - Storage slot allocation rules
- [EIP-1967](https://eips.ethereum.org/EIPS/eip-1967) - Proxy storage slots
- [EIP-2930](https://eips.ethereum.org/EIPS/eip-2930) - Access lists for storage
- [Merkle Patricia Trie](https://ethereum.org/en/developers/docs/data-structures-and-encoding/patricia-merkle-trie/) - State storage structure
