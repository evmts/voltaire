---
title: State
description: EVM storage key representation for contract state tracking
---

import { Tabs, TabItem, Card, CardGrid, Aside } from '@astrojs/starlight/components';

# State

Composite key primitive for uniquely identifying storage locations in the Ethereum Virtual Machine

## Overview

StorageKey combines a 20-byte contract address with a 256-bit storage slot number, enabling efficient tracking of contract state across multiple contracts in a single VM instance.

## Quick Start

<Tabs>
<TabItem label="Basic Usage">
```typescript
import * as State from '@tevm/primitives/State'
import * as Address from '@tevm/primitives/Address'

// Create storage key
const key = State.StorageKey(
  Address.from("0x742d35Cc6634C0532925a3b844Bc9e7595f51e3e"),
  0n  // First storage slot
)

// Use in storage maps
const storage = new Map<string, bigint>()
storage.set(State.StorageKey.toString(key), 1000n)

// Retrieve value
const value = storage.get(State.StorageKey.toString(key))  // 1000n
```
</TabItem>

<TabItem label="String Serialization">
```typescript
import * as State from '@tevm/primitives/State'

const key = State.StorageKey(contractAddress, 42n)

// Convert to string for map keys
const keyStr = State.StorageKey.toString(key)
// "0x742d35cc6634c0532925a3b844bc9e7595f51e3e:42"

// Parse from string
const parsed = State.StorageKey.fromString(keyStr)
// { address: BrandedAddress(...), slot: 42n }

// Round-trip conversion
State.StorageKey.equals(key, parsed)  // true
```
</TabItem>

<TabItem label="Type Guards">
```typescript
import * as State from '@tevm/primitives/State'

const key = State.StorageKey(addr, 42n)

// Type guard
if (State.StorageKey.is(key)) {
  console.log(`Slot: ${key.slot}`)
}

// Check plain objects
const obj = { address: contractAddr, slot: 42n }
State.StorageKey.is(obj)  // true

// Equality
const key2 = State.StorageKey(addr, 42n)
State.StorageKey.equals(key, key2)  // true
```
</TabItem>

<TabItem label="Hash Codes">
```typescript
import * as State from '@tevm/primitives/State'

const key = State.StorageKey(contractAddress, 42n)

// Get numeric hash code for hash maps
const hash = State.StorageKey.hashCode(key)

// Use in hash-based data structures
const bucketIndex = hash % numBuckets

// Bloom filter integration
bloomFilter.add(hash)
```
</TabItem>
</Tabs>

## Types

```typescript
/**
 * Composite key for EVM storage operations
 */
export type BrandedStorageKey = {
  /**
   * Contract address (20 bytes)
   */
  readonly address: BrandedAddress

  /**
   * Storage slot number (0 to 2^256-1)
   * Sparsely allocated - most slots remain zero
   */
  readonly slot: bigint
}
```

Source: [BrandedStorageKey.ts](https://github.com/evmts/voltaire/blob/main/src/primitives/State/BrandedState/BrandedStorageKey.ts)

## EVM Storage Model

<Aside type="note" title="Storage Architecture">
Each contract has 2^256 storage slots (340 undecillion slots). Each slot stores a 256-bit value (32 bytes). Slots are initially zero and only consume gas when first written via SSTORE.
</Aside>

### Storage Layout

```solidity
contract Example {
  uint256 public value;        // slot 0
  address public owner;        // slot 1
  mapping(address => uint256) public balances;  // keccak256(key, 2) for slot 2
  uint256[] public array;      // length at slot 3, elements at keccak256(3) + index
}
```

### Slot Calculation

**Simple variables**: Sequential slots starting at 0

**Mappings**: `slot = keccak256(h(key) || baseSlot)`

**Dynamic arrays**: Length at baseSlot, elements at `keccak256(baseSlot) + index`

**Packed storage**: Variables &lt;32 bytes packed into same slot (right to left)

## API Documentation

<CardGrid stagger>
  <Card title="Storage Examples" icon="open-book">
    Practical examples of Solidity storage layouts, slot calculations, and patterns.

    [View storage examples →](/primitives/state/storage-examples)
  </Card>

  <Card title="Constructors" icon="rocket">
    Create StorageKey from addresses and slot numbers. Supports factory function, static methods, and string parsing.

    [View constructors →](/primitives/state/constructors)
  </Card>

  <Card title="Conversions" icon="random">
    Serialize to strings for Map keys, databases, and caching. Hash codes for hash-based data structures.

    [View conversions →](/primitives/state/conversions)
  </Card>

  <Card title="Validation" icon="approve-check">
    Type guards, equality checking, and input validation for safe storage operations.

    [View validation →](/primitives/state/validation)
  </Card>

  <Card title="Utilities" icon="puzzle">
    Helper functions for batch operations, iteration, snapshots, and statistics.

    [View utilities →](/primitives/state/utilities)
  </Card>

  <Card title="Usage Patterns" icon="document">
    Complete examples: EVM state managers, transaction tracking, block state, caching.

    [View usage patterns →](/primitives/state/usage-patterns)
  </Card>

  <Card title="Merkle Trees" icon="seti:config">
    Merkle Patricia Trie implementation for state root calculation and storage proofs.

    [View merkle trees →](/primitives/state/merkle-trees)
  </Card>

  <Card title="BrandedState" icon="seti:text">
    Tree-shakeable functional API for minimal bundle size.

    [View BrandedState →](/primitives/state/branded-state)
  </Card>

  <Card title="WASM Implementation" icon="rocket">
    WebAssembly-accelerated operations compiled from Zig for performance.

    [View WASM →](/primitives/state/wasm)
  </Card>
</CardGrid>

## Core Methods

### StorageKey(address, slot) / create()

Create new StorageKey.

```typescript
// Factory function
const key = State.StorageKey(contractAddress, 42n)

// Static method (same)
const key2 = State.StorageKey.create(contractAddress, 42n)
```

Source: [create.js](https://github.com/evmts/voltaire/blob/main/src/primitives/State/BrandedState/create.js)

### from()

Flexible constructor accepting StorageKey-like objects.

```typescript
// From object
const key = State.StorageKey.from({
  address: contractAddress,
  slot: 42n
})

// From existing StorageKey (no-op)
const key2 = State.StorageKey.from(key)
```

Source: [from.js](https://github.com/evmts/voltaire/blob/main/src/primitives/State/BrandedState/from.js)

### is()

Type guard checking if value is StorageKey.

```typescript
State.StorageKey.is(key)  // true
State.StorageKey.is({ address: addr, slot: 0n })  // true
State.StorageKey.is({ address: addr })  // false (missing slot)
State.StorageKey.is(null)  // false
```

Source: [is.js](https://github.com/evmts/voltaire/blob/main/src/primitives/State/BrandedState/is.js)

### equals()

Check equality between two StorageKeys.

```typescript
const key1 = State.StorageKey(addr1, 42n)
const key2 = State.StorageKey(addr1, 42n)
const key3 = State.StorageKey(addr2, 42n)

State.StorageKey.equals(key1, key2)  // true (same address & slot)
State.StorageKey.equals(key1, key3)  // false (different address)
```

Source: [equals.js](https://github.com/evmts/voltaire/blob/main/src/primitives/State/BrandedState/equals.js)

### toString()

Serialize to string format for map keys.

```typescript
const key = State.StorageKey(addr, 42n)
const str = State.StorageKey.toString(key)
// "0x742d35cc6634c0532925a3b844bc9e7595f51e3e:42"
```

Format: `{address}:{slot}` where address is lowercase hex with 0x prefix, slot is decimal.

Source: [toString.js](https://github.com/evmts/voltaire/blob/main/src/primitives/State/BrandedState/toString.js)

### fromString()

Parse StorageKey from string representation.

```typescript
const str = "0x742d35cc6634c0532925a3b844bc9e7595f51e3e:42"
const key = State.StorageKey.fromString(str)
// { address: BrandedAddress(...), slot: 42n }
```

Source: [fromString.js](https://github.com/evmts/voltaire/blob/main/src/primitives/State/BrandedState/fromString.js)

### hashCode()

Generate numeric hash for hash-based data structures.

```typescript
const key = State.StorageKey(addr, 42n)
const hash = State.StorageKey.hashCode(key)

// Use for bucketing
const bucket = hash % buckets.length
```

Source: [hashCode.js](https://github.com/evmts/voltaire/blob/main/src/primitives/State/BrandedState/hashCode.js)

## Common Patterns

### Map-Based Storage

```typescript
import * as State from '@tevm/primitives/State'

// Track storage state across contracts
const storage = new Map<string, bigint>()

function setStorage(address: BrandedAddress, slot: bigint, value: bigint) {
  const key = State.StorageKey(address, slot)
  const keyStr = State.StorageKey.toString(key)
  storage.set(keyStr, value)
}

function getStorage(address: BrandedAddress, slot: bigint): bigint {
  const key = State.StorageKey(address, slot)
  const keyStr = State.StorageKey.toString(key)
  return storage.get(keyStr) ?? 0n
}
```

### Warm/Cold Access Tracking (EIP-2929)

```typescript
import * as GasConstants from '@tevm/primitives/GasConstants'

// Track accessed storage slots for gas calculation
const accessedSlots = new Set<string>()

function accessSlot(address: BrandedAddress, slot: bigint): bigint {
  const key = State.StorageKey(address, slot)
  const keyStr = State.StorageKey.toString(key)

  const wasAccessed = accessedSlots.has(keyStr)
  accessedSlots.add(keyStr)

  // Return gas cost (warm vs cold)
  return wasAccessed
    ? GasConstants.Sload
    : GasConstants.ColdSload
}
```

### Storage Slot Calculation

```typescript
import * as Hash from '@tevm/primitives/Hash'
import * as Hex from '@tevm/primitives/Hex'

// Calculate mapping slot: keccak256(abi.encode(key, baseSlot))
function getMappingSlot(key: Uint8Array, baseSlot: bigint): bigint {
  const encoded = new Uint8Array(64)
  encoded.set(Hex.padLeft(key, 32), 0)
  encoded.set(Hex.padLeft(Hex.fromBigInt(baseSlot), 32), 32)

  const hash = Hash.keccak256(encoded)
  return Hex.toBigInt(hash)
}

// Example: balances[userAddr] at slot 2
const userBalanceSlot = getMappingSlot(
  Address.toBytes(userAddr),
  2n  // mapping base slot
)

const key = State.StorageKey(tokenContract, userBalanceSlot)
const balance = storage.get(State.StorageKey.toString(key)) ?? 0n
```

### State Root Calculation

```typescript
import { Trie } from '@ethereumjs/trie'

// Build Merkle Patricia Trie for state root
const trie = new Trie()

for (const [keyStr, value] of storage) {
  const key = State.StorageKey.fromString(keyStr)

  // Trie key: keccak256(slot)
  const slotBytes = Hex.padLeft(Hex.fromBigInt(key.slot), 32)
  const trieKey = Hash.keccak256(slotBytes)

  // Trie value: RLP(value)
  const valueBytes = Hex.padLeft(Hex.fromBigInt(value), 32)
  const trieValue = Rlp.encode(valueBytes)

  await trie.put(trieKey, trieValue)
}

const stateRoot = await trie.root()
```

## EIP-1967 Proxy Slots

Standard proxy storage slots (non-overlapping with contract storage):

```typescript
// EIP-1967: Proxy Storage Slots
export const EIP1967_IMPLEMENTATION_SLOT =
  0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbcn

export const EIP1967_BEACON_SLOT =
  0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50n

export const EIP1967_ADMIN_SLOT =
  0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103n

// Get proxy implementation address
const implKey = State.StorageKey(proxyAddr, EIP1967_IMPLEMENTATION_SLOT)
const implValue = storage.get(State.StorageKey.toString(implKey))
```

## Storage Constants

```typescript
// Common storage slot patterns
export const SLOT_0 = 0n                    // First slot
export const SLOT_IMPLEMENTATION = 0n       // Proxy implementation (non-EIP-1967)
export const SLOT_BEACON = 1n               // Beacon proxy slot
export const SLOT_ADMIN = 2n                // Admin slot
```

## Tree-Shaking

Import only what you need for optimal bundle size:

```typescript
// Import specific methods
import { StorageKey, toString, fromString } from '@tevm/primitives/State'

// Or import entire namespace
import * as State from '@tevm/primitives/State'

// Selective imports for state tracking
const key = StorageKey(address, slot)
const keyStr = toString(key)
```

Each StorageKey method is independently exported, allowing bundlers to eliminate unused functionality.

## Solidity Storage Layout

<Aside type="tip" title="Storage Optimization">
Solidity packs variables smaller than 32 bytes into the same slot. Order state variables by size to minimize gas costs.

```solidity
// Inefficient: 3 slots
uint256 a;  // slot 0
uint8 b;    // slot 1
uint256 c;  // slot 2

// Efficient: 2 slots
uint256 a;  // slot 0
uint256 c;  // slot 1
uint8 b;    // slot 1 (packed with c)
```
</Aside>

### Layout Rules

1. **State variables**: Packed sequentially starting at slot 0
2. **Mappings**: `keccak256(h(key) || baseSlot)` where h() pads to 32 bytes
3. **Dynamic arrays**: Length at baseSlot, elements at `keccak256(baseSlot) + index`
4. **Structs**: Members packed into consecutive slots
5. **Inheritance**: Base contract variables first, then derived

```solidity
contract StorageExample {
  uint256 a;           // slot 0
  uint256 b;           // slot 1
  mapping(address => uint256) balances;  // slot 2 (base), actual at keccak256(key || 2)
  uint256[] array;     // slot 3 (length), elements at keccak256(3) + index
}
```

## Performance

| Operation | Time | Notes |
|-----------|------|-------|
| Create | ~10ns | Zero allocations |
| toString | ~80ns | Hex encoding + concatenation |
| fromString | ~100ns | Parsing address + slot |
| equals | ~20ns | Address + slot comparison |
| hashCode | ~15ns | XOR-based hash |

*Benchmarks using WASM on M1 Mac. TypeScript 2-3x slower.*

## Related Types

<CardGrid stagger>
  <Card title="Address" icon="document">
    20-byte contract addresses used in storage keys.

    [View Address →](/primitives/address)
  </Card>

  <Card title="Hash" icon="seti:text">
    Keccak256 hashing for storage slot calculations.

    [View Hash →](/primitives/hash)
  </Card>

  <Card title="Rlp" icon="puzzle">
    RLP encoding for state trie values.

    [View Rlp →](/primitives/rlp)
  </Card>

  <Card title="Transaction" icon="rocket">
    Transactions that modify contract storage.

    [View Transaction →](/primitives/transaction)
  </Card>

  <Card title="GasConstants" icon="seti:config">
    Storage operation gas costs (SLOAD, SSTORE).

    [View GasConstants →](/primitives/gas-constants)
  </Card>
</CardGrid>

## State Trie Visualization

### Merkle Patricia Trie Structure

The EVM state is organized in a Merkle Patricia Trie (sparse Merkle tree) where:

```
               State Root Hash
                     |
         __________ | __________
        /           |            \
    Account A    Account B     Account C
    (Address)    (Address)     (Address)
        |
        ├─ Storage Trie Root
        |        |
        |    ____|____
        |   /    |    \
        |  Slot 0  Slot 1  Slot 42
        |   |       |        |
        |  Value  Value    Value
```

**Key Points:**
- Accounts indexed by: keccak256(address)
- Storage slots indexed by: keccak256(slot number)
- Each node is a hash of its children
- Changes to any slot affect the entire state root

### Account State Components

```typescript
type Account = {
  nonce: bigint                    // Transaction count
  balance: bigint                  // ETH balance
  storageRoot: Hash                // Merkle Patricia Trie root
  codeHash: Hash                   // keccak256(code)
}
```

### Storage Layout Examples

**Example 1: Simple State Variables**
```solidity
contract Simple {
  uint256 public a;     // slot 0
  address public owner; // slot 1
  bool public active;   // slot 2
}
```

Storage layout:
```
Account: 0x742d35Cc...
├─ Storage Root Hash
   ├─ slot[0] → value for 'a'
   ├─ slot[1] → value for 'owner'
   └─ slot[2] → value for 'active'
```

**Example 2: Mapping Storage**
```solidity
contract Mapping {
  mapping(address => uint256) public balances;  // base slot 0
}
```

Storage calculation:
```
balances[0x1234...] stored at:
  keccak256(
    abi.encode(0x1234..., 0)  // key concatenated with slot
  )
  = 0xabcd...  (some hash)

Account: 0x9876...
├─ Storage Root Hash
   ├─ slot[0xabcd...] → balance amount
   ├─ slot[0xef01...] → another balance
   └─ slot[0x2345...] → another balance
```

**Example 3: Dynamic Arrays**
```solidity
contract Arrays {
  uint256[] public items;  // base slot 0
}
```

Storage layout:
```
items.length stored at: slot[0]
items[0] stored at:     slot[keccak256(0)]
items[1] stored at:     slot[keccak256(0)] + 1
items[2] stored at:     slot[keccak256(0)] + 2
...
```

### Solidity Storage Packing

```solidity
// Inefficient (3 slots)
contract Inefficient {
  uint256 a;  // 32 bytes - slot 0
  uint8 b;    // 1 byte   - slot 1 (wastes 31 bytes!)
  uint256 c;  // 32 bytes - slot 2
}

// Efficient (2 slots)
contract Efficient {
  uint256 a;  // 32 bytes - slot 0
  uint256 c;  // 32 bytes - slot 1
  uint8 b;    // 1 byte   - slot 1 (packed with c)
}
```

## Gas Costs for Storage Operations

| Operation | Condition | Gas | Notes |
|-----------|-----------|-----|-------|
| SLOAD | First access (cold) | 2100 | EIP-2929 |
| SLOAD | Already accessed (warm) | 100 | Access list |
| SSTORE | Zero → nonzero | 20000 | Write to empty slot |
| SSTORE | Nonzero → different nonzero | 5000 | Modify existing |
| SSTORE | Nonzero → zero | 5000 - refund | Delete (refund up to 15000) |
| SSTORE | Nonzero → same value | 100 | Warm access, no change |

**EIP-2929 Access List:**
- First touch of (address, slot) pair: cold (expensive)
- Subsequent touches in same transaction: warm (cheap)
- Access lists can be pre-declared to optimize gas

## Storage Slot Calculator

### For Mappings

```typescript
// Solidity: mapping(address => uint256) balances
// Declaration at storage slot: 0

// Get slot for balances[userAddr]:
const baseSlot = 0n
const key = userAddr  // BrandedAddress

// Slot = keccak256(abi.encode(key, baseSlot))
// In TypeScript:
const keyBytes = Address.toBytes(key)
const slotBytes = Hex.fromBigInt(baseSlot, 32)
const combined = new Uint8Array([...keyBytes, ...slotBytes])
const slotHash = Keccak.hash(combined)
const slotNumber = Hex.toBigInt(slotHash)
```

### For Nested Mappings

```typescript
// Solidity: mapping(address => mapping(address => uint256)) nested
// Declaration at slot: 0

// Get slot for nested[addr1][addr2]:
const slot1 = keccak256(abi.encode(addr1, 0n))
const slot2 = keccak256(abi.encode(addr2, slot1))
```

### For Arrays

```typescript
// Solidity: uint256[] items
// Declaration at slot: 0

// Array length at slot[0]
// Element 0 at: keccak256(0n) + 0
// Element 1 at: keccak256(0n) + 1
// Element i at: keccak256(baseSlot) + i
```

## State Root Calculation

```typescript
// Build storage trie for account
function buildStorageTrie(storage: Map<string, bigint>): Hash {
  const trie = new Map<Hash, Uint8Array>()

  for (const [keyStr, value] of storage) {
    const key = State.StorageKey.fromString(keyStr)
    const slotHash = Keccak.hash(Hex.fromBigInt(key.slot, 32))
    const valueEncoded = Rlp.encode(Hex.fromBigInt(value, 32))
    trie.set(slotHash, valueEncoded)
  }

  // Compute Merkle root
  return computeMerkleRoot(trie)
}

// Build account trie for state
function buildAccountTrie(
  accounts: Map<Address, Account>
): Hash {
  const trie = new Map<Hash, Uint8Array>()

  for (const [addr, account] of accounts) {
    const addrHash = Keccak.hash(Address.toBytes(addr))
    const accountEncoded = Rlp.encode([
      account.nonce,
      account.balance,
      account.storageRoot,
      account.codeHash
    ])
    trie.set(addrHash, accountEncoded)
  }

  // Compute Merkle root
  return computeMerkleRoot(trie)
}
```

## State Proof Verification

**Merkle Proof Structure:**
```
// To prove slot[X] = value in storage:
proof = [
  sibling1,  // Hash of sibling node at depth 1
  sibling2,  // Hash of sibling node at depth 2
  ...
  storageRoot  // Final root to verify against
]

// Reconstruct tree:
hash0 = leaf(X, value)
hash1 = parent(hash0, sibling1)
hash2 = parent(hash1, sibling2)
...
assert(hashN == stateRoot)  // Proof verified
```

**RLP Encoding:**
```
AccountData = RLP([
  nonce,
  balance,
  storageRoot,
  codeHash
])

StorageValue = RLP(uint256Value)
```

## Related Types

<CardGrid stagger>
  <Card title="Address" icon="document">
    20-byte contract addresses used in storage keys.

    [View Address →](/primitives/address)
  </Card>

  <Card title="Hash" icon="seti:text">
    Keccak256 hashing for storage slot calculations.

    [View Hash →](/primitives/hash)
  </Card>

  <Card title="Rlp" icon="puzzle">
    RLP encoding for state trie values.

    [View Rlp →](/primitives/rlp)
  </Card>

  <Card title="Transaction" icon="rocket">
    Transactions that modify contract storage.

    [View Transaction →](/primitives/transaction)
  </Card>

  <Card title="GasConstants" icon="seti:config">
    Storage operation gas costs (SLOAD, SSTORE).

    [View GasConstants →](/primitives/gas-constants)
  </Card>
</CardGrid>

## Specification References

- [Ethereum Yellow Paper](https://ethereum.github.io/yellowpaper/paper.pdf) - Section 4.1: World State
- [Solidity Storage Layout](https://docs.soliditylang.org/en/latest/internals/layout_in_storage.html) - Storage slot allocation rules
- [EIP-1967](https://eips.ethereum.org/EIPS/eip-1967) - Proxy storage slots
- [EIP-2929](https://eips.ethereum.org/EIPS/eip-2929) - Access lists for storage (warm/cold)
- [Merkle Patricia Trie](https://ethereum.org/en/developers/docs/data-structures-and-encoding/patricia-merkle-trie/) - State storage structure
- [Merkle Proofs](https://ethereum.org/en/developers/tutorials/merkle-proofs-for-offline-data-integrity/) - State proof verification
