---
title: "BrandedState"
description: Tree-shakeable functional API for EVM state operations
---

# BrandedState

Tree-shakeable functional API for EVM state and storage operations with optimal bundle size.

## Overview

`BrandedState` provides:
- **Zero-overhead** state operations
- **Tree-shakeable** individual function exports
- **Data-first** unopinionated methods
- **Bundle optimization** through selective imports
- **Type-safe** storage key handling

Primary benefit: Import only what you need, minimize bundle size.

## Type Definition

```typescript
/**
 * Composite key for EVM storage operations combining address and slot
 */
export type BrandedStorageKey = {
  /** The contract address that owns this storage slot */
  readonly address: BrandedAddress;
  /** The 256-bit storage slot number within the contract's storage space */
  readonly slot: bigint;
};

/**
 * Inputs that can be converted to StorageKey
 */
export type StorageKeyLike =
  | BrandedStorageKey
  | {
      address: BrandedAddress;
      slot: bigint;
    };
```

`BrandedStorageKey` uniquely identifies a storage location within the EVM by combining a contract address with a 256-bit storage slot number.

## EVM Storage Model

In the EVM:
- Each contract has 2^256 storage slots
- Each slot can store a 256-bit value
- Slots are initially zero and only consume gas when first written
- Storage is persistent across transactions

To track storage across multiple contracts in a single VM instance, we need a composite key that includes both the contract address and the slot number.

## Namespace API

```typescript
import * as BrandedState from '@tevm/primitives/State/BrandedState'

// Create storage key
const key = BrandedState.create({
  address: contractAddress,
  slot: 0n
})

// Convert to string (for Map keys)
const keyStr = BrandedState.toString(key)

// Convert from string
const parsedKey = BrandedState.fromString(keyStr)

// Check equality
const areEqual = BrandedState.equals(key1, key2)

// Type guard
const isKey = BrandedState.is(value)

// Hash code for Map usage
const hash = BrandedState.hashCode(key)
```

## Tree-Shaking Benefits

### Minimal Bundle - Creation Only

```typescript
import { create } from '@tevm/primitives/State/BrandedState'

const key = create({ address: addr, slot: 0n })
```

**Bundle:** Only create function. No serialization or comparison.

### Serialization Only

```typescript
import { toString, fromString } from '@tevm/primitives/State/BrandedState'

const keyStr = toString(key)
const parsed = fromString(keyStr)
```

**Bundle:** Serialization only. No creation or equality checks.

### Equality Only

```typescript
import { equals } from '@tevm/primitives/State/BrandedState'

const areEqual = equals(key1, key2)
```

**Bundle:** Equality check only. No other operations.

## Data-First Pattern

All functions follow data-first pattern:

```typescript
// Data is first parameter
create(keyData)
toString(key)
fromString(str)
equals(key1, key2)
is(value)
```

This enables functional composition:

```typescript
import { create, toString, equals } from '@tevm/primitives/State/BrandedState'

// Composition
const serializeKey = (keyData) => toString(create(keyData))

// Array methods
const keys = keyDataArray.map(create)
const uniqueKeys = keys.filter((key, i, arr) =>
  arr.findIndex(k => equals(k, key)) === i
)
```

## Type Safety

Branded type prevents mixing with plain objects:

```typescript
function getStorage(key: BrandedStorageKey): bigint { ... }

const plainObject = { address: addr, slot: 0n }
getStorage(plainObject) // Type error!

// Must use constructor
const key = State.create(plainObject)
getStorage(key) // OK
```

## Usage Examples

### Creating Storage Keys

```typescript
import * as BrandedState from '@tevm/primitives/State/BrandedState'

// Create storage key
const key = BrandedState.create({
  address: contractAddress,
  slot: 0n
})

// Accessing different slots
const slot0 = BrandedState.create({ address: addr, slot: 0n })
const slot1 = BrandedState.create({ address: addr, slot: 1n })
const slot42 = BrandedState.create({ address: addr, slot: 42n })
```

### Using as Map Keys

```typescript
import { create, toString } from '@tevm/primitives/State/BrandedState'

// Storage as Map
const storage = new Map<string, bigint>()

// Set storage values
const key1 = create({ address: addr, slot: 0n })
storage.set(toString(key1), 100n)

const key2 = create({ address: addr, slot: 1n })
storage.set(toString(key2), 200n)

// Get storage values
const value = storage.get(toString(key1)) // 100n
```

### Serialization

```typescript
import { toString, fromString } from '@tevm/primitives/State/BrandedState'

// Serialize to string
const key = BrandedState.create({ address: addr, slot: 42n })
const keyStr = toString(key)
// Format: "0x742d35Cc6634C0532925a3b844Bc9e7595f51e3e:42"

// Deserialize from string
const parsed = fromString(keyStr)
console.log(parsed.address) // BrandedAddress
console.log(parsed.slot)    // 42n
```

### Equality Checking

```typescript
import { create, equals } from '@tevm/primitives/State/BrandedState'

const key1 = create({ address: addr1, slot: 0n })
const key2 = create({ address: addr1, slot: 0n })
const key3 = create({ address: addr2, slot: 0n })

equals(key1, key2) // true (same address and slot)
equals(key1, key3) // false (different address)
```

### Type Guards

```typescript
import { is } from '@tevm/primitives/State/BrandedState'

function processUnknown(value: unknown) {
  if (is(value)) {
    // value is BrandedStorageKey
    console.log(`Address: ${Address.toHex(value.address)}`)
    console.log(`Slot: ${value.slot}`)
  }
}
```

### Tracking Storage Changes

```typescript
import { create, toString, equals } from '@tevm/primitives/State/BrandedState'

class StateTracker {
  private storage = new Map<string, bigint>()
  private changes = new Map<string, { old: bigint; new: bigint }>()

  get(address: BrandedAddress, slot: bigint): bigint {
    const key = create({ address, slot })
    return this.storage.get(toString(key)) ?? 0n
  }

  set(address: BrandedAddress, slot: bigint, value: bigint): void {
    const key = create({ address, slot })
    const keyStr = toString(key)
    const oldValue = this.storage.get(keyStr) ?? 0n

    this.storage.set(keyStr, value)
    this.changes.set(keyStr, { old: oldValue, new: value })
  }

  getChanges(): Map<string, { old: bigint; new: bigint }> {
    return new Map(this.changes)
  }

  reset(): void {
    this.changes.clear()
  }
}
```

### Building Storage Merkle Tree

```typescript
import { create, hashCode, toString } from '@tevm/primitives/State/BrandedState'

// Sort storage keys for Merkle tree construction
function sortStorageKeys(keys: BrandedStorageKey[]): BrandedStorageKey[] {
  return keys.sort((a, b) => {
    const hashA = hashCode(a)
    const hashB = hashCode(b)
    return hashA - hashB
  })
}

// Group by address
function groupByAddress(
  keys: BrandedStorageKey[]
): Map<string, BrandedStorageKey[]> {
  const groups = new Map<string, BrandedStorageKey[]>()

  for (const key of keys) {
    const addrStr = Address.toHex(key.address)
    const group = groups.get(addrStr) || []
    group.push(key)
    groups.set(addrStr, group)
  }

  return groups
}
```

### Cache Implementation

```typescript
import { create, toString, equals } from '@tevm/primitives/State/BrandedState'

class StorageCache {
  private cache = new Map<string, { value: bigint; dirty: boolean }>()

  get(address: BrandedAddress, slot: bigint): bigint | undefined {
    const key = create({ address, slot })
    return this.cache.get(toString(key))?.value
  }

  set(address: BrandedAddress, slot: bigint, value: bigint, dirty = true): void {
    const key = create({ address, slot })
    this.cache.set(toString(key), { value, dirty })
  }

  getDirty(): Map<BrandedStorageKey, bigint> {
    const dirty = new Map<BrandedStorageKey, bigint>()

    for (const [keyStr, entry] of this.cache) {
      if (entry.dirty) {
        const key = fromString(keyStr)
        dirty.set(key, entry.value)
      }
    }

    return dirty
  }

  flush(): void {
    for (const entry of this.cache.values()) {
      entry.dirty = false
    }
  }
}
```

## Benefits

### Type Safety

```typescript
type BrandedStorageKey = {
  readonly address: BrandedAddress;
  readonly slot: bigint;
};

function readStorage(key: BrandedStorageKey): bigint { ... }

const key = State.create({ address: addr, slot: 0n })
readStorage(key)    // OK

const plain = { address: addr, slot: 0n }
readStorage(plain)  // Type error
```

### Self-Documenting

```typescript
// Clear what's expected
function updateStorage(key: BrandedStorageKey, value: bigint): void { ... }

// vs unclear plain object
function updateStorage(key: { address: any; slot: any }, value: bigint): void { ... }
```

### Zero Runtime Cost

```typescript
const key: BrandedStorageKey = State.create({ address: addr, slot: 0n })
// key is plain object at runtime
console.log(key) // { address: Uint8Array(...), slot: 0n }
```

### Composite Key Pattern

Combining address and slot in a single type:
- Prevents mixing up addresses and slots
- Ensures storage operations have both components
- Simplifies Map usage with toString()
- Type-safe equality checking

## Storage Slots

Common storage slot patterns:

```typescript
// Simple state variables (sequential slots)
const ownerSlot = 0n      // address public owner
const balanceSlot = 1n    // uint256 public balance
const nameSlot = 2n       // string public name

// Mapping slots (keccak256 hash)
function mappingSlot(key: BrandedAddress, baseSlot: bigint): bigint {
  // keccak256(abi.encode(key, baseSlot))
  const encoded = Abi.encode(['address', 'uint256'], [key, baseSlot])
  const hash = Keccak.hash(encoded)
  return Hash.toBigInt(hash)
}

// Nested mapping slots
function nestedMappingSlot(
  key1: BrandedAddress,
  key2: BrandedAddress,
  baseSlot: bigint
): bigint {
  const innerSlot = mappingSlot(key1, baseSlot)
  return mappingSlot(key2, innerSlot)
}
```

## Patterns

### Type-Safe Storage Access

```typescript
function createStorageKey(
  address: BrandedAddress,
  slot: bigint
): BrandedStorageKey {
  if (slot < 0n) {
    throw new Error('Storage slot cannot be negative')
  }
  return State.create({ address, slot })
}
```

### Efficient Map Keys

```typescript
// Use toString() for Map keys
const storage = new Map<string, bigint>()

function setStorage(key: BrandedStorageKey, value: bigint): void {
  storage.set(toString(key), value)
}

function getStorage(key: BrandedStorageKey): bigint {
  return storage.get(toString(key)) ?? 0n
}
```

## Related

- [State](/primitives/state) - Main State documentation
- [Address](/primitives/address) - Address type used in storage keys
- [Hash](/primitives/hash) - Hash type for slot calculations
- [Abi](/primitives/abi) - ABI encoding for storage layouts
- [Branded Types](/primitives/branded-types) - Type-level branding pattern
