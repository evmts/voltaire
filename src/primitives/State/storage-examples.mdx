---
title: Storage Examples
description: Practical examples of Solidity storage layouts and calculations
---

import { Tabs, TabItem, Aside } from '@astrojs/starlight/components';

# Storage Examples

Practical examples of calculating storage slots for various Solidity patterns.

## Simple State Variables

### Sequential Slots

```solidity
contract SimpleStorage {
  uint256 public a;           // slot 0
  address public owner;       // slot 1
  bool public active;         // slot 2
  string public name;         // slot 3 (only stores length, data elsewhere)
  bytes public data;          // slot 4
  uint256[] public array;     // slot 5
}
```

**Storage layout:**
```
Slot 0: 0x0000000000000000000000000000000000000000000000000000000000000000 (a)
Slot 1: 0x000000000000000000000000742d35Cc6634C0532925a3b844Bc9e7595f51e3e (owner)
Slot 2: 0x0000000000000000000000000000000000000000000000000000000000000001 (active = true)
Slot 3: 0x... (string length * 2 + 0)
Slot 4: 0x... (bytes length * 2 + 1)
Slot 5: 0x... (array length * 2 + 2)
```

### Packed Storage

```solidity
// INEFFICIENT: Wastes space
contract Inefficient {
  uint256 a;      // 32 bytes - slot 0
  uint8 b;        // 1 byte   - slot 1 (wastes 31 bytes!)
  uint256 c;      // 32 bytes - slot 2
}

// EFFICIENT: Pack variables
contract Efficient {
  uint256 a;      // 32 bytes - slot 0
  uint256 c;      // 32 bytes - slot 1
  uint8 b;        // 1 byte   - slot 1 (packed with c, right-aligned)
}
```

**Packed slot layout (slot 1 in Efficient):**
```
Slot 1:
┌─────────────────────────────────────────┬─────┐
│  uint256 c (left-aligned, 31 bytes)     │  b  │ (1 byte)
└─────────────────────────────────────────┴─────┘
 0                                      31  32
```

## Mapping Storage

### Basic Mapping

```solidity
contract Mapping {
  mapping(address => uint256) public balances;  // slot 0
  mapping(address => bool) public admins;       // slot 1
}
```

**Storage calculation:**
```typescript
import * as Address from '@tevm/primitives/Address'
import * as Hash from '@tevm/primitives/Hash'
import * as Hex from '@tevm/primitives/Hex'

// Get slot for balances[userAddr]
function getBalanceSlot(userAddr: Address): bigint {
  // Slot = keccak256(abi.encode(userAddr, 0))
  const addrBytes = Address.toBytes(userAddr)
  const slotBytes = Hex.fromBigInt(0n, 32)
  const combined = new Uint8Array(64)
  combined.set(addrBytes, 0)
  combined.set(slotBytes, 20)  // Address is 20 bytes

  const hash = Hash.keccak256(combined)
  return Hex.toBigInt(hash)
}

const userAddr = Address.from("0x1234567890123456789012345678901234567890")
const slot = getBalanceSlot(userAddr)
// Example: slot = 0x9e8cd8d3ba18f4b1b2e0c7c7c7c7c7c7c7c7c7c7
```

### Nested Mappings

```solidity
contract NestedMapping {
  mapping(address => mapping(address => uint256)) public allowed;  // slot 0
}

// Get slot for allowed[from][to]
function getAllowedSlot(from: Address, to: Address): bigint {
  // First level: keccak256(abi.encode(from, 0))
  const slot1 = getSlotForKey(from, 0n)

  // Second level: keccak256(abi.encode(to, slot1))
  const slot2 = getSlotForKey(to, slot1)

  return slot2
}

function getSlotForKey(key: Address, baseSlot: bigint): bigint {
  const keyBytes = Address.toBytes(key)
  const slotBytes = Hex.fromBigInt(baseSlot, 32)
  const combined = new Uint8Array(64)
  combined.set(keyBytes, 0)
  combined.set(slotBytes, 20)

  return Hex.toBigInt(Hash.keccak256(combined))
}
```

### Complex Key Types

```solidity
contract ComplexMapping {
  // Mapping with multiple keys
  mapping(address => mapping(uint256 => mapping(bytes32 => uint256))) data;
}

// For data[addr][num][hash]
function getSlot(addr: Address, num: bigint, hash: Uint8Array): bigint {
  // First level
  const slot1 = getSlotForKey(addr, 0n)

  // Second level: num is uint256
  const numBytes = Hex.fromBigInt(num, 32)
  const combined1 = new Uint8Array(64)
  combined1.set(numBytes, 0)
  combined1.set(Hex.fromBigInt(slot1, 32), 32)
  const slot2 = Hex.toBigInt(Hash.keccak256(combined1))

  // Third level: hash is bytes32
  const combined2 = new Uint8Array(64)
  combined2.set(hash, 0)
  combined2.set(Hex.fromBigInt(slot2, 32), 32)
  const slot3 = Hex.toBigInt(Hash.keccak256(combined2))

  return slot3
}
```

## Array Storage

### Dynamic Arrays

```solidity
contract ArrayStorage {
  uint256[] public numbers;    // slot 0
  address[] public users;      // slot 1
  bytes32[] public hashes;     // slot 2
}
```

**Storage layout:**
```
Slot 0: Array length (e.g., 3)
Slot keccak256(0) + 0: numbers[0]
Slot keccak256(0) + 1: numbers[1]
Slot keccak256(0) + 2: numbers[2]

Slot 1: Array length
Slot keccak256(1) + 0: users[0]
Slot keccak256(1) + 1: users[1]
...
```

**Access example:**
```typescript
function getArrayElement(baseSlot: bigint, index: bigint): bigint {
  // Calculate position: keccak256(baseSlot) + index
  const hashSlot = Hash.keccak256(Hex.fromBigInt(baseSlot, 32))
  const slotNumber = Hex.toBigInt(hashSlot) + index
  return slotNumber
}

// Get numbers[2]
const slot = getArrayElement(0n, 2n)
// slot = keccak256(0) + 2
```

### Packed Dynamic Arrays

```solidity
contract PackedArrays {
  uint8[] public bytes8Array;    // slot 0
}

// If array contains uint8, multiple values pack in one slot
// 32 bytes per slot = 32 uint8 values per slot

// uint8[32] in one slot
// Index 0-31 packed in slot keccak256(0)
```

## Struct Storage

### Simple Structs

```solidity
struct Account {
  address owner;       // 20 bytes
  uint96 balance;      // 12 bytes
  bool active;         // 1 byte
  // Total: 33 bytes (packed into 2 slots)
}

contract StructStorage {
  Account public account;  // slot 0, slot 1
}

// Slot 0: owner (20 bytes) + balance (12 bytes) = 32 bytes
// Slot 1: active (1 byte) + padding (31 bytes)
```

### Structs in Arrays

```solidity
struct Transaction {
  address sender;      // 20 bytes
  uint96 amount;       // 12 bytes
  uint64 timestamp;    // 8 bytes
  bool confirmed;      // 1 byte
  // Total: 41 bytes (packed into 2 slots per struct)
}

contract TransactionStorage {
  Transaction[] public txs;  // slot 0
}

// Slot 0: Array length
// Slot keccak256(0) + 0: txs[0] part 1 (owner + amount)
// Slot keccak256(0) + 1: txs[0] part 2 (timestamp + confirmed)
// Slot keccak256(0) + 2: txs[1] part 1
// ...
```

## Inheritance Storage

```solidity
contract Base {
  uint256 a;           // slot 0
  address owner;       // slot 1
}

contract Derived is Base {
  uint256 b;           // slot 2 (continues from base)
  string name;         // slot 3
}

// Storage layout (all in same contract):
// Slot 0: Base.a
// Slot 1: Base.owner
// Slot 2: Derived.b
// Slot 3: Derived.name
```

## Proxy Patterns

### EIP-1967 Proxy Slots

```solidity
contract Proxy {
  // Implementation slot (EIP-1967)
  bytes32 internal constant IMPLEMENTATION_SLOT =
    0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;

  // Beacon slot (EIP-1967)
  bytes32 internal constant BEACON_SLOT =
    0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;

  // Admin slot (EIP-1967)
  bytes32 internal constant ADMIN_SLOT =
    0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;
}
```

**Access pattern:**
```typescript
import * as State from '@tevm/primitives/State'
import * as Address from '@tevm/primitives/Address'

const proxyAddr = Address.from("0x...")
const IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbcn

// Create storage key
const key = State.StorageKey(proxyAddr, IMPLEMENTATION_SLOT)
const keyStr = State.StorageKey.toString(key)

// Look up implementation address
const storage = new Map<string, bigint>()
const implValue = storage.get(keyStr) // Returns address as bigint
```

## Diamond Pattern (Multi-facet)

```solidity
contract Diamond {
  struct FacetAddressAndPosition {
    address facetAddress;
    uint16 functionSelectorPosition;
  }

  mapping(bytes4 => FacetAddressAndPosition) internal facets;  // slot 0
}

// Get facet for selector
function getFacetSlot(selector: Uint8Array): bigint {
  // selector is 4 bytes (packed from left)
  const slot = getSlotForKey(selector, 0n)
  return slot
}
```

## Example: ERC20 Token Storage

```solidity
contract ERC20 {
  uint256 public totalSupply;           // slot 0
  string public name;                   // slot 1
  string public symbol;                 // slot 2
  uint8 public decimals;                // slot 3
  mapping(address => uint256) balances; // slot 4
  mapping(address => mapping(address => uint256)) allowance;  // slot 5
}
```

**Access patterns:**
```typescript
// Get balance of user
function getBalance(userAddr: Address): bigint {
  const baseSlot = 4n
  const addrBytes = Address.toBytes(userAddr)
  const slotBytes = Hex.fromBigInt(baseSlot, 32)
  const combined = new Uint8Array(64)
  combined.set(addrBytes, 0)
  combined.set(slotBytes, 20)

  const slot = Hex.toBigInt(Hash.keccak256(combined))
  return storage.get(State.StorageKey.toString(State.StorageKey(userAddr, slot))) ?? 0n
}

// Get allowance for (owner, spender)
function getAllowance(owner: Address, spender: Address): bigint {
  // First level: keccak256(owner, 5)
  const slot1 = getSlot(owner, 5n)

  // Second level: keccak256(spender, slot1)
  const spenderBytes = Address.toBytes(spender)
  const slotBytes = Hex.fromBigInt(slot1, 32)
  const combined = new Uint8Array(64)
  combined.set(spenderBytes, 0)
  combined.set(slotBytes, 20)

  const slot2 = Hex.toBigInt(Hash.keccak256(combined))
  return storage.get(State.StorageKey.toString(State.StorageKey(owner, slot2))) ?? 0n
}
```

## Storage Analysis Tools

### Calculate Storage Layout

```typescript
// Tool to determine slot for any path
function calculateSlot(path: string[]): bigint {
  let slot = 0n
  let depth = 0

  for (const component of path) {
    if (component.startsWith('0x')) {
      // Address/bytes32 key
      const value = Hex.fromHex(component)
      slot = computeSlot(value, slot)
    } else {
      // Decimal or state variable name
      slot = BigInt(component)
    }
    depth++
  }

  return slot
}

// Trace storage access
function traceStorageAccess(path: string[]): string {
  let trace = ''
  let slot = 0n

  for (const component of path) {
    trace += `Component: ${component}\n`
    if (component.startsWith('0x')) {
      slot = computeSlot(Hex.fromHex(component), slot)
      trace += `  Computed slot: 0x${slot.toString(16)}\n`
    } else {
      slot = BigInt(component)
      trace += `  Slot: ${slot}\n`
    }
  }

  return trace
}
```

## Common Mistakes

### Mistake 1: Wrong Slot Ordering

```solidity
// WRONG: Different storage layouts in different contracts
contract A {
  uint256 a;
  address owner;
}

contract B {
  address owner;  // Different slot!
  uint256 a;
}

// A.a at slot 0, B.owner at slot 0 (collision risk in proxies)
```

### Mistake 2: Forgetting to Hash Keys

```typescript
// WRONG: Using key directly as slot
const badSlot = userAddr  // Should be hash!

// RIGHT: Hash the key
const goodSlot = Hash.keccak256(
  new Uint8Array([
    ...Address.toBytes(userAddr),
    ...Hex.fromBigInt(0n, 32)
  ])
)
```

### Mistake 3: Incorrect Padding

```typescript
// WRONG: Variables not right-aligned in slot
// LEFT: 0x1234000000... (missing padding)

// RIGHT: Variables right-aligned with left padding
// RIGHT: 0x0000000012340000...
```

## Related Documentation

- [State](/primitives/state) - Main State reference
- [Address](/primitives/address) - Address type
- [Hash](/primitives/hash) - Keccak256 hashing
- [Solidity Storage Layout](https://docs.soliditylang.org/en/latest/internals/layout_in_storage.html)
