---
title: State Usage Patterns
description: Common patterns for EVM state management and storage tracking
---

# Usage Patterns

Real-world patterns for managing EVM storage state in clients, indexers, and applications.

## EVM State Manager

Complete state manager with warm/cold tracking (EIP-2929):

```typescript
import * as State from '@tevm/primitives/State'
import * as Address from '@tevm/primitives/Address'
import * as GasConstants from '@tevm/primitives/GasConstants'

class EVMStateManager {
  private storage = new Map<string, bigint>()
  private accessedSlots = new Set<string>()
  private accessedAddresses = new Set<string>()
  private hardfork: Hardfork

  constructor(hardfork: Hardfork = 'cancun') {
    this.hardfork = hardfork
  }

  // SLOAD with gas calculation
  sload(address: BrandedAddress, slot: bigint): {
    value: bigint
    gasCost: bigint
  } {
    const key = State.StorageKey(address, slot)
    const keyStr = State.StorageKey.toString(key)

    const isWarm = this.accessedSlots.has(keyStr)
    this.accessedSlots.add(keyStr)

    const value = this.storage.get(keyStr) ?? 0n
    const gasCost = isWarm
      ? GasConstants.Sload
      : GasConstants.getColdSloadCost(this.hardfork)

    return { value, gasCost }
  }

  // SSTORE with gas and refund calculation
  sstore(address: BrandedAddress, slot: bigint, value: bigint): {
    gasCost: bigint
    refund: bigint
  } {
    const key = State.StorageKey(address, slot)
    const keyStr = State.StorageKey.toString(key)

    const isWarm = this.accessedSlots.has(keyStr)
    this.accessedSlots.add(keyStr)

    const currentValue = this.storage.get(keyStr) ?? 0n
    const result = GasConstants.calculateSstoreCost(isWarm, currentValue, value)

    if (value === 0n) {
      this.storage.delete(keyStr)
    } else {
      this.storage.set(keyStr, value)
    }

    return { gasCost: result.cost, refund: result.refund }
  }

  // Warm address for CALL operations
  warmAddress(address: BrandedAddress): bigint {
    const addrHex = Address.toHex(address)
    const isWarm = this.accessedAddresses.has(addrHex)
    this.accessedAddresses.add(addrHex)

    return isWarm ? 0n : GasConstants.ColdAccountAccess
  }

  // Reset access lists (new transaction)
  clearAccessLists(): void {
    this.accessedSlots.clear()
    this.accessedAddresses.clear()
  }

  // Get all storage for contract
  getContractState(address: BrandedAddress): Map<bigint, bigint> {
    const addrHex = Address.toHex(address).toLowerCase()
    const state = new Map<bigint, bigint>()

    for (const [keyStr, value] of this.storage) {
      const key = State.StorageKey.fromString(keyStr)
      if (Address.toHex(key.address).toLowerCase() === addrHex) {
        state.set(key.slot, value)
      }
    }

    return state
  }
}
```

## Transaction State Tracking

Track storage changes during transaction execution:

```typescript
class TransactionStateTracker {
  private originalState: Map<string, bigint>
  private currentState: Map<string, bigint>
  private journal: Array<{ key: string; oldValue: bigint; newValue: bigint }> = []

  constructor(baseState: Map<string, bigint>) {
    this.originalState = new Map(baseState)
    this.currentState = new Map(baseState)
  }

  set(key: BrandedStorageKey, value: bigint): void {
    const keyStr = State.StorageKey.toString(key)
    const oldValue = this.currentState.get(keyStr) ?? 0n

    if (oldValue !== value) {
      this.journal.push({ key: keyStr, oldValue, newValue: value })
      this.currentState.set(keyStr, value)
    }
  }

  get(key: BrandedStorageKey): bigint {
    const keyStr = State.StorageKey.toString(key)
    return this.currentState.get(keyStr) ?? 0n
  }

  commit(): Map<string, bigint> {
    // Merge changes into original
    for (const entry of this.journal) {
      if (entry.newValue === 0n) {
        this.originalState.delete(entry.key)
      } else {
        this.originalState.set(entry.key, entry.newValue)
      }
    }

    this.journal = []
    return this.originalState
  }

  revert(): void {
    // Undo all changes
    for (let i = this.journal.length - 1; i >= 0; i--) {
      const entry = this.journal[i]
      if (entry.oldValue === 0n) {
        this.currentState.delete(entry.key)
      } else {
        this.currentState.set(entry.key, entry.oldValue)
      }
    }

    this.journal = []
  }

  getChanges(): Map<BrandedStorageKey, { before: bigint; after: bigint }> {
    const changes = new Map<BrandedStorageKey, { before: bigint; after: bigint }>()

    for (const entry of this.journal) {
      const key = State.StorageKey.fromString(entry.key)
      changes.set(key, {
        before: entry.oldValue,
        after: entry.newValue
      })
    }

    return changes
  }
}
```

## Block State Manager

Manage state across blocks with rollback capability:

```typescript
class BlockStateManager {
  private states = new Map<bigint, Map<string, bigint>>()
  private latestBlock = 0n

  saveBlockState(blockNumber: bigint, state: Map<string, bigint>): void {
    this.states.set(blockNumber, new Map(state))
    if (blockNumber > this.latestBlock) {
      this.latestBlock = blockNumber
    }
  }

  getStateAtBlock(blockNumber: bigint): Map<string, bigint> | null {
    return this.states.get(blockNumber) ?? null
  }

  rollbackToBlock(blockNumber: bigint): boolean {
    if (!this.states.has(blockNumber)) {
      return false
    }

    // Remove all blocks after target
    for (const block of this.states.keys()) {
      if (block > blockNumber) {
        this.states.delete(block)
      }
    }

    this.latestBlock = blockNumber
    return true
  }

  pruneOldBlocks(keepLast: number): void {
    if (this.states.size <= keepLast) return

    const blocks = Array.from(this.states.keys()).sort((a, b) =>
      a < b ? -1 : a > b ? 1 : 0
    )

    const toPrune = blocks.slice(0, -keepLast)
    for (const block of toPrune) {
      this.states.delete(block)
    }
  }
}
```

## Storage Proof Generation

Generate and verify storage proofs:

```typescript
import * as Hash from '@tevm/primitives/Hash'
import * as Rlp from '@tevm/primitives/Rlp'

class StorageProofGenerator {
  private trie: MerklePatriciaTrie

  constructor() {
    this.trie = new MerklePatriciaTrie()
  }

  async addStorageSlot(key: BrandedStorageKey, value: bigint): Promise<void> {
    // Compute trie key: keccak256(address || slot)
    const keyBytes = new Uint8Array(52)
    keyBytes.set(key.address, 0)
    keyBytes.set(Hex.padLeft(Hex.fromBigInt(key.slot), 32), 20)
    const trieKey = Hash.keccak256(keyBytes)

    // RLP encode value
    const valueBytes = Hex.padLeft(Hex.fromBigInt(value), 32)
    const encoded = Rlp.encode(valueBytes)

    await this.trie.put(trieKey, encoded)
  }

  async generateProof(key: BrandedStorageKey): Promise<Uint8Array[]> {
    const keyBytes = new Uint8Array(52)
    keyBytes.set(key.address, 0)
    keyBytes.set(Hex.padLeft(Hex.fromBigInt(key.slot), 32), 20)
    const trieKey = Hash.keccak256(keyBytes)

    const proof = await this.trie.createProof(trieKey)
    return proof
  }

  async getStateRoot(): Promise<Uint8Array> {
    return this.trie.root()
  }
}
```

## Cache Layer

Implement LRU cache for storage:

```typescript
class StorageLRUCache {
  private cache = new Map<string, { value: bigint; lastAccess: number }>()
  private accessOrder: string[] = []
  private maxSize: number

  constructor(maxSize = 10000) {
    this.maxSize = maxSize
  }

  get(key: BrandedStorageKey): bigint | null {
    const keyStr = State.StorageKey.toString(key)
    const entry = this.cache.get(keyStr)

    if (!entry) return null

    // Update access time
    entry.lastAccess = Date.now()
    this.moveToFront(keyStr)

    return entry.value
  }

  set(key: BrandedStorageKey, value: bigint): void {
    const keyStr = State.StorageKey.toString(key)

    if (this.cache.size >= this.maxSize && !this.cache.has(keyStr)) {
      this.evictOldest()
    }

    this.cache.set(keyStr, { value, lastAccess: Date.now() })
    this.moveToFront(keyStr)
  }

  private moveToFront(keyStr: string): void {
    const index = this.accessOrder.indexOf(keyStr)
    if (index > -1) {
      this.accessOrder.splice(index, 1)
    }
    this.accessOrder.unshift(keyStr)
  }

  private evictOldest(): void {
    const oldest = this.accessOrder.pop()
    if (oldest) {
      this.cache.delete(oldest)
    }
  }

  clear(): void {
    this.cache.clear()
    this.accessOrder = []
  }
}
```

## Related

- [Constructors](/primitives/state/constructors) - Create storage keys
- [Conversions](/primitives/state/conversions) - Serialize keys
- [Utilities](/primitives/state/utilities) - Helper functions
- [Merkle Trees](/primitives/state/merkle-trees) - State root calculation
