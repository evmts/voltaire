---
title: State Constructors
description: Creating StorageKey instances for EVM state tracking
---

# Constructors

Methods for creating StorageKey instances from addresses and storage slot numbers.

## Primary Constructor

### `StorageKey(address, slot)`

Create StorageKey from contract address and slot number.

```typescript
import * as State from '@tevm/primitives/State'
import * as Address from '@tevm/primitives/Address'

// Basic construction
const key = State.StorageKey(
  Address.from("0x742d35Cc6634C0532925a3b844Bc9e7595f51e3e"),
  0n
)

// Different slots
const slot0 = State.StorageKey(contractAddr, 0n)    // First slot
const slot1 = State.StorageKey(contractAddr, 1n)    // Second slot
const slot42 = State.StorageKey(contractAddr, 42n)  // Arbitrary slot

// Large slot numbers (mapping slots)
const mappingSlot = State.StorageKey(
  contractAddr,
  0x290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e563n
)
```

**Parameters:**
- `address: BrandedAddress` - Contract address (20 bytes)
- `slot: bigint` - Storage slot number (0 to 2^256-1)

**Returns:** `BrandedStorageKey`

**Never throws** - All bigint values and valid addresses are accepted

Source: [create.js](https://github.com/evmts/primitives/blob/main/src/primitives/State/BrandedState/create.js)

## Static Constructors

### `StorageKey.create(address, slot)`

Static method alias for constructor.

```typescript
const key = State.StorageKey.create(contractAddr, 0n)

// Identical to:
const key2 = State.StorageKey(contractAddr, 0n)
```

**Parameters:**
- `address: BrandedAddress` - Contract address
- `slot: bigint` - Storage slot number

**Returns:** `BrandedStorageKey`

**Static form:**
```typescript
import { create } from '@tevm/primitives/State'
const key = create(contractAddr, 0n)
```

### `StorageKey.from(value)`

Create from StorageKey-like object.

```typescript
// From plain object
const key = State.StorageKey.from({
  address: contractAddr,
  slot: 42n
})

// From existing StorageKey (no-op)
const existing = State.StorageKey(contractAddr, 42n)
const copy = State.StorageKey.from(existing)  // Returns same structure
```

**Parameters:**
- `value: StorageKeyLike` - Object with address and slot properties

**Returns:** `BrandedStorageKey`

**Static form:**
```typescript
import { from } from '@tevm/primitives/State'
const key = from({ address: contractAddr, slot: 42n })
```

Source: [from.js](https://github.com/evmts/primitives/blob/main/src/primitives/State/BrandedState/from.js)

### `StorageKey.fromString(str)`

Parse from string representation.

```typescript
// Parse string format "address:slot"
const str = "0x742d35cc6634c0532925a3b844bc9e7595f51e3e:42"
const key = State.StorageKey.fromString(str)

// Result
// {
//   address: BrandedAddress(0x742d35Cc...),
//   slot: 42n
// }

// Works with or without 0x prefix
const key2 = State.StorageKey.fromString("742d35cc...e3e:100")

// Parse from Map keys
const storage = new Map<string, bigint>()
storage.set(State.StorageKey.toString(someKey), value)

// Later, parse it back
for (const [keyStr, value] of storage) {
  const key = State.StorageKey.fromString(keyStr)
  console.log(`Address: ${Address.toHex(key.address)}, Slot: ${key.slot}`)
}
```

**Parameters:**
- `str: string` - String in format `"address:slot"`

**Returns:** `BrandedStorageKey`

**Format:** `{address}:{slot}` where:
- Address is hex string (with or without 0x prefix)
- Slot is decimal number (converted to bigint)

**Static form:**
```typescript
import { fromString } from '@tevm/primitives/State'
const key = fromString("0x742d35cc...e3e:42")
```

Source: [fromString.js](https://github.com/evmts/primitives/blob/main/src/primitives/State/BrandedState/fromString.js)

## Usage Patterns

### Constructor Selection

```typescript
// Known address and slot - use primary constructor
const key = State.StorageKey(contractAddr, 0n)

// From object (API response, JSON) - use from
const apiResponse = { address: "0x...", slot: 42n }
const key2 = State.StorageKey.from(apiResponse)

// From serialized string (database key) - use fromString
const dbKey = "0x742d35cc6634c0532925a3b844bc9e7595f51e3e:42"
const key3 = State.StorageKey.fromString(dbKey)
```

### Solidity Storage Slot Calculation

```typescript
import * as Hash from '@tevm/primitives/Hash'
import * as Hex from '@tevm/primitives/Hex'

// Simple storage variable at known slot
const ownerSlot = State.StorageKey(contractAddr, 0n)
const balanceSlot = State.StorageKey(contractAddr, 1n)

// Mapping slot: keccak256(abi.encode(key, baseSlot))
function getMappingSlot(
  key: Uint8Array,
  baseSlot: bigint
): bigint {
  // Concatenate key (32 bytes) + slot (32 bytes)
  const encoded = new Uint8Array(64)
  encoded.set(Hex.padLeft(key, 32), 0)
  encoded.set(Hex.padLeft(Hex.fromBigInt(baseSlot), 32), 32)

  const hash = Hash.keccak256(encoded)
  return Hex.toBigInt(hash)
}

// Example: balances[userAddr] at slot 2
const userBalanceSlot = getMappingSlot(
  Address.toBytes(userAddr),
  2n  // mapping base slot
)
const key = State.StorageKey(tokenContract, userBalanceSlot)
```

### Dynamic Array Slot Calculation

```typescript
// Array length stored at baseSlot
// Elements stored at keccak256(baseSlot) + index

function getArraySlot(baseSlot: bigint, index: bigint): bigint {
  const baseSlotBytes = Hex.padLeft(Hex.fromBigInt(baseSlot), 32)
  const arrayBase = Hash.keccak256(baseSlotBytes)
  return Hex.toBigInt(arrayBase) + index
}

// Example: myArray[5] at slot 3
const elementSlot = getArraySlot(3n, 5n)
const key = State.StorageKey(contractAddr, elementSlot)
```

### Nested Mapping Slots

```typescript
// mapping(address => mapping(address => uint256)) allowances at slot 4

function getNestedMappingSlot(
  outerKey: Uint8Array,
  innerKey: Uint8Array,
  baseSlot: bigint
): bigint {
  // First level: keccak256(outerKey || baseSlot)
  const firstLevel = getMappingSlot(outerKey, baseSlot)

  // Second level: keccak256(innerKey || firstLevel)
  return getMappingSlot(innerKey, firstLevel)
}

// Example: allowances[owner][spender] at slot 4
const allowanceSlot = getNestedMappingSlot(
  Address.toBytes(ownerAddr),
  Address.toBytes(spenderAddr),
  4n
)
const key = State.StorageKey(tokenContract, allowanceSlot)
```

### Batch Construction

```typescript
// Create multiple storage keys efficiently
function getContractState(
  contractAddr: BrandedAddress,
  slots: bigint[]
): Map<string, BrandedStorageKey> {
  const keys = new Map<string, BrandedStorageKey>()

  for (const slot of slots) {
    const key = State.StorageKey(contractAddr, slot)
    const keyStr = State.StorageKey.toString(key)
    keys.set(keyStr, key)
  }

  return keys
}

// Usage
const stateKeys = getContractState(contractAddr, [0n, 1n, 2n, 3n])
```

### Working with EIP-1967 Proxy Slots

```typescript
// EIP-1967 standard proxy storage slots
const EIP1967_IMPLEMENTATION_SLOT =
  0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbcn

const EIP1967_ADMIN_SLOT =
  0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103n

const EIP1967_BEACON_SLOT =
  0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50n

// Get proxy implementation address
const implKey = State.StorageKey(proxyAddr, EIP1967_IMPLEMENTATION_SLOT)
const implValue = await storage.get(State.StorageKey.toString(implKey))
// implValue contains implementation address (right-aligned in 32 bytes)
```

## Tree-Shakeable Usage

All constructors available as tree-shakeable imports:

```typescript
import {
  create,
  from,
  fromString
} from '@tevm/primitives/State'

const key1 = create(contractAddr, 0n)
const key2 = from({ address: contractAddr, slot: 42n })
const key3 = fromString("0x742d35cc...e3e:100")
```

See [BrandedState](/primitives/state/branded-state) for details on tree-shakeable API.

## Related

- [Conversions](/primitives/state/conversions) - Serialize keys to strings
- [Validation](/primitives/state/validation) - Type guards and checking
- [Usage Patterns](/primitives/state/usage-patterns) - State tracking examples
