---
title: BinaryTree
description: Binary State Tree (EIP-7864) for unified Ethereum state
---

## Overview

The BinaryTree module implements the Binary State Tree proposed in EIP-7864, a unified tree structure for Ethereum state. Uses 32-byte keys (31-byte stem + 1-byte subindex), four node types, and BLAKE3 hashing for efficient state representation.

## Key Functions

### `init`
```zig
pub fn init(a: std.mem.Allocator) BinaryTree
```
Creates empty binary tree.

### `deinit`
```zig
pub fn deinit(self: *BinaryTree) void
```
Frees tree memory.

### `insert`
```zig
pub fn insert(self: *BinaryTree, k: [32]u8, v: [32]u8) !void
```
Inserts value at 32-byte key.

### `get`
```zig
pub fn get(self: *BinaryTree, k: [32]u8) ?[32]u8
```
Retrieves value at key, or null if not found.

### `rootHash`
```zig
pub fn rootHash(self: *BinaryTree) [32]u8
```
Computes root hash of entire tree (BLAKE3).

### Utility Functions

#### `addressToKey`
```zig
pub fn addressToKey(addr: [20]u8) [32]u8
```
Converts 20-byte address to 32-byte key (prepends 12 zero bytes).

#### `splitKey`
```zig
pub fn splitKey(k: [32]u8) struct { stem: Stem, idx: u8 }
```
Splits 32-byte key into 31-byte stem and 1-byte subindex.

## Types

### BinaryTree Structure

```zig
pub const BinaryTree = struct {
    allocator: std.mem.Allocator,
    root: Node,
};
```

### Node Types

```zig
pub const Node = union(enum) {
    empty: void,
    internal: InternalNode,
    stem: StemNode,
    leaf: LeafNode,
};

pub const InternalNode = struct {
    left: [32]u8,
    right: [32]u8,
};

pub const StemNode = struct {
    stem: Stem,
    values: [256]?[32]u8,
};

pub const LeafNode = struct {
    value: [32]u8,
};
```

### Key Structure

```zig
pub const Stem = [31]u8;

// 32-byte key = 31-byte stem + 1-byte subindex
// Stem defines tree path (31 bytes = 248 bits)
// Subindex defines slot within stem (256 possible values)
```

### Account Data Layout

```zig
pub const AccountData = packed struct {
    version: u8,
    code_size: u24,
    nonce: u64,
    balance: u128,
};
```

## Examples

### Creating and using tree
```zig
const allocator = std.heap.page_allocator;
var tree = BinaryTree.init(allocator);
defer tree.deinit();

// Insert value
var key: [32]u8 = undefined;
@memset(&key, 0);
key[31] = 5; // Subindex 5

var value: [32]u8 = undefined;
@memset(&value, 0);
value[31] = 0x42;

try tree.insert(key, value);

// Compute root hash
const root = tree.rootHash();
```

### Address-based storage
```zig
// Convert Ethereum address to tree key
const addr = [_]u8{0xf3, 0x9f} ++ [_]u8{0} ** 18;
const key = BinaryTree.addressToKey(addr);

// First 12 bytes are zero (padding)
// Last 20 bytes are address
try testing.expectEqual(@as(u8, 0), key[0]);
try testing.expectEqual(@as(u8, 0xf3), key[12]);
try testing.expectEqual(@as(u8, 0x9f), key[13]);
```

### Stem and subindex
```zig
// 32-byte key structure
var k: [32]u8 = undefined;
@memset(&k, 0xaa);
k[31] = 0x42; // Subindex

const split = BinaryTree.splitKey(k);
// split.stem: [31]u8 all 0xaa
// split.idx: 0x42

// Stem defines path through tree (31 bytes = 248 bits)
// Each bit determines left (0) or right (1) traversal
// Subindex selects one of 256 values at stem node
```

### Internal node hashing
```zig
// Empty children hash to zero
const zero = [_]u8{0} ** 32;
const h1 = BinaryTree.hashInternal(zero, zero);
try testing.expectEqualSlices(u8, &zero, &h1);

// Non-empty children hash with BLAKE3
const left = [_]u8{0x01} ++ [_]u8{0} ** 31;
const right = [_]u8{0x02} ++ [_]u8{0} ** 31;
const h2 = BinaryTree.hashInternal(left, right);
// h2 is BLAKE3(left || right)
```

### Account data at index 0
```zig
// Account basic data stored at subindex 0
const acc = BinaryTree.AccountData{
    .version = 1,
    .code_size = 1024,
    .nonce = 42,
    .balance = 1000000000000000000, // 1 ETH in wei
};

// Total size: 1 + 3 + 8 + 16 = 28 bytes (packed)
try testing.expectEqual(@as(u8, 1), acc.version);
try testing.expectEqual(@as(u24, 1024), acc.code_size);
try testing.expectEqual(@as(u64, 42), acc.nonce);
try testing.expectEqual(@as(u128, 1000000000000000000), acc.balance);
```

## Performance

- Insert: ~XXX µs (tree traversal + hashing)
- Get: ~XXX µs (tree traversal)
- Root hash: ~XXX ms (full tree hashing)
- BLAKE3 hashing: ~XXX ns per 64 bytes
- Memory: Depends on tree size (sparse allocation)

## Testing

```bash
zig build test -Dtest-filter=BinaryTree
```

Test coverage:
- Tree initialization
- Single/multiple insertions
- Key splitting (stem + subindex)
- Address to key conversion
- Internal node hashing (zero optimization)
- Stem bit extraction
- Account data layout
- Root hash computation

## Related

- [State](/primitives/state) - Uses tree for state representation
- Replaces Merkle Patricia Trie (MPT) with simpler binary structure
- BLAKE3 instead of Keccak256 for performance

## References

- [EIP-7864: Binary State Tree](https://eips.ethereum.org/EIPS/eip-7864)
- Verkle Trees precursor concept
- Simplifies state proofs and synchronization
- 31-byte stem + 1-byte subindex enables efficient grouping
