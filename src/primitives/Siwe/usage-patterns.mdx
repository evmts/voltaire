---
title: "Usage Patterns"
---

# Usage Patterns

Production patterns for SIWE authentication.

## Complete Authentication Flow

### Frontend Implementation

```typescript
// 1. Request nonce from backend
async function startAuth() {
  const response = await fetch('/auth/start', {
    method: 'POST',
  });
  const { nonce } = await response.json();
  return nonce;
}

// 2. Create SIWE message
async function createMessage(address: string, nonce: string) {
  const chainId = await ethereum.request({ method: 'eth_chainId' });

  return Siwe.create({
    domain: window.location.host,
    address: Address.fromHex(address),
    uri: window.location.origin,
    chainId: Number(chainId),
    statement: 'Sign in to Example App',
    nonce,
  });
}

// 3. Sign message
async function signMessage(message: BrandedMessage) {
  const text = Siwe.format(message);
  const signature = await ethereum.request({
    method: 'personal_sign',
    params: [text, message.address],
  });
  return signature;
}

// 4. Complete auth flow
async function authenticate() {
  try {
    // Get user address
    const [address] = await ethereum.request({
      method: 'eth_requestAccounts',
    });

    // Start authentication
    const nonce = await startAuth();

    // Create and sign message
    const message = await createMessage(address, nonce);
    const signature = await signMessage(message);

    // Send to backend
    const response = await fetch('/auth/verify', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        message: Siwe.format(message),
        signature,
      }),
    });

    if (!response.ok) {
      throw new Error('Authentication failed');
    }

    const { token } = await response.json();
    localStorage.setItem('authToken', token);

    return { success: true };
  } catch (err) {
    console.error('Auth failed:', err);
    return { success: false, error: err.message };
  }
}
```

### Backend Implementation

```typescript
import { Redis } from 'ioredis';
import { Siwe, Address } from '@tevm/voltaire';

const redis = new Redis();

// 1. Start authentication endpoint
app.post('/auth/start', async (req, res) => {
  try {
    // Generate nonce
    const nonce = Siwe.generateNonce();
    const expiresAt = Date.now() + 300000; // 5 minutes

    // Store nonce
    await redis.set(
      `nonce:${nonce}`,
      JSON.stringify({
        createdAt: Date.now(),
        expiresAt,
      }),
      'EX',
      300
    );

    res.json({ nonce });
  } catch (err) {
    res.status(500).json({ error: 'Failed to start authentication' });
  }
});

// 2. Verify authentication endpoint
app.post('/auth/verify', async (req, res) => {
  try {
    const { message: messageText, signature: signatureHex } = req.body;

    // Parse message
    const message = Siwe.parse(messageText);

    // Verify domain
    if (message.domain !== req.hostname) {
      return res.status(400).json({ error: 'Domain mismatch' });
    }

    // Verify nonce
    const nonceData = await redis.get(`nonce:${message.nonce}`);
    if (!nonceData) {
      return res.status(400).json({ error: 'Invalid or expired nonce' });
    }

    const { expiresAt } = JSON.parse(nonceData);
    if (Date.now() > expiresAt) {
      return res.status(400).json({ error: 'Nonce expired' });
    }

    // Consume nonce (single use)
    await redis.del(`nonce:${message.nonce}`);

    // Validate message
    const validationResult = Siwe.validate(message);
    if (!validationResult.valid) {
      return res.status(400).json({ error: validationResult.error.message });
    }

    // Verify signature
    const signature = hexToBytes(signatureHex);
    const verifyResult = Siwe.verifyMessage(message, signature);
    if (!verifyResult.valid) {
      return res.status(401).json({ error: verifyResult.error.message });
    }

    // Create session
    const sessionToken = generateSessionToken();
    await redis.set(
      `session:${sessionToken}`,
      JSON.stringify({
        address: Address.toHex(message.address),
        chainId: message.chainId,
        createdAt: Date.now(),
      }),
      'EX',
      86400 // 24 hours
    );

    res.json({ token: sessionToken });
  } catch (err) {
    console.error('Auth verification failed:', err);
    res.status(400).json({ error: 'Authentication failed' });
  }
});

// Helper functions
function hexToBytes(hex: string): Uint8Array {
  const bytes = new Uint8Array(hex.length / 2);
  for (let i = 0; i < bytes.length; i++) {
    bytes[i] = parseInt(hex.substr(i * 2, 2), 16);
  }
  return bytes;
}

function generateSessionToken(): string {
  return crypto.randomUUID();
}
```

## Session Management

### Expiring Sessions

```typescript
const message = Siwe.create({
  domain: "example.com",
  address: userAddress,
  uri: "https://example.com",
  chainId: 1,
  expirationTime: new Date(Date.now() + 3600000).toISOString(), // 1 hour
});

// Middleware to check session validity
app.use((req, res, next) => {
  const token = req.headers.authorization?.replace('Bearer ', '');
  if (!token) {
    return res.status(401).json({ error: 'No token' });
  }

  redis.get(`session:${token}`).then(data => {
    if (!data) {
      return res.status(401).json({ error: 'Invalid session' });
    }

    const session = JSON.parse(data);
    req.session = session;
    next();
  });
});
```

### Sliding Sessions

```typescript
// Extend session on each request
app.use(async (req, res, next) => {
  if (req.session) {
    const token = req.headers.authorization?.replace('Bearer ', '');
    await redis.expire(`session:${token}`, 86400); // Reset to 24 hours
  }
  next();
});
```

### Session Invalidation

```typescript
// Logout endpoint
app.post('/auth/logout', async (req, res) => {
  const token = req.headers.authorization?.replace('Bearer ', '');
  if (token) {
    await redis.del(`session:${token}`);
  }
  res.json({ success: true });
});
```

## Multi-Chain Authentication

### Support Multiple Chains

```typescript
const supportedChains = [1, 137, 42161]; // Ethereum, Polygon, Arbitrum

async function authenticateMultiChain(address: string) {
  const nonce = await startAuth();

  const messages = await Promise.all(
    supportedChains.map(async (chainId) => {
      return Siwe.create({
        domain: window.location.host,
        address: Address.fromHex(address),
        uri: window.location.origin,
        chainId,
        nonce,
      });
    })
  );

  // User selects chain and signs
  const selectedChainId = await promptChainSelection();
  const message = messages.find(m => m.chainId === selectedChainId);
  const signature = await signMessage(message);

  // Backend verifies and stores chain preference
}
```

### Chain-Specific Sessions

```typescript
app.post('/auth/verify', async (req, res) => {
  // ... verification ...

  // Store chain in session
  await redis.set(
    `session:${sessionToken}`,
    JSON.stringify({
      address: Address.toHex(message.address),
      chainId: message.chainId,
      createdAt: Date.now(),
    }),
    'EX',
    86400
  );

  res.json({ token: sessionToken, chainId: message.chainId });
});

// Middleware to verify chain matches
app.use((req, res, next) => {
  const requiredChainId = getRequiredChainId(req.path);
  if (req.session.chainId !== requiredChainId) {
    return res.status(400).json({ error: 'Wrong chain' });
  }
  next();
});
```

## Resource-Based Authorization

### Define Permissions

```typescript
const ADMIN_RESOURCES = [
  "https://example.com/api/admin/users",
  "https://example.com/api/admin/settings",
];

const USER_RESOURCES = [
  "https://example.com/api/user/profile",
  "https://example.com/api/user/data",
];

function createAuthMessage(address: string, role: 'admin' | 'user') {
  const resources = role === 'admin' ? ADMIN_RESOURCES : USER_RESOURCES;

  return Siwe.create({
    domain: "example.com",
    address,
    uri: "https://example.com",
    chainId: 1,
    statement: `Grant ${role} access`,
    resources,
  });
}
```

### Verify Resource Access

```typescript
function hasResourceAccess(message: BrandedMessage, resource: string): boolean {
  return message.resources?.includes(resource) ?? false;
}

// Middleware
app.use('/api/admin/*', (req, res, next) => {
  const requestedResource = `https://example.com${req.path}`;

  if (!hasResourceAccess(req.session.message, requestedResource)) {
    return res.status(403).json({ error: 'Insufficient permissions' });
  }

  next();
});
```

## Nonce Management

### Database Nonce Store

```typescript
// Store nonces in database
interface Nonce {
  value: string;
  userId?: string;
  createdAt: Date;
  expiresAt: Date;
  used: boolean;
}

async function generateAndStoreNonce(userId?: string): Promise<string> {
  const nonce = Siwe.generateNonce();

  await db.nonces.create({
    value: nonce,
    userId,
    createdAt: new Date(),
    expiresAt: new Date(Date.now() + 300000), // 5 minutes
    used: false,
  });

  return nonce;
}

async function verifyAndConsumeNonce(nonce: string): Promise<boolean> {
  const record = await db.nonces.findOne({ value: nonce });

  if (!record || record.used || new Date() > record.expiresAt) {
    return false;
  }

  await db.nonces.update({ value: nonce }, { used: true });
  return true;
}
```

### Cleanup Expired Nonces

```typescript
// Periodic cleanup job
setInterval(async () => {
  await db.nonces.deleteMany({
    expiresAt: { $lt: new Date() },
  });
}, 60000); // Every minute
```

### Rate Limiting Nonce Generation

```typescript
const nonceRateLimiter = new Map<string, number[]>();

function checkNonceRateLimit(ip: string): boolean {
  const now = Date.now();
  const requests = nonceRateLimiter.get(ip) || [];

  // Remove requests older than 1 minute
  const recent = requests.filter(time => now - time < 60000);

  if (recent.length >= 10) {
    return false; // Too many requests
  }

  recent.push(now);
  nonceRateLimiter.set(ip, recent);
  return true;
}

app.post('/auth/start', (req, res) => {
  if (!checkNonceRateLimit(req.ip)) {
    return res.status(429).json({ error: 'Rate limit exceeded' });
  }

  // Generate nonce...
});
```

## Error Handling

### Frontend Error Handling

```typescript
async function authenticateWithRetry(maxRetries = 3) {
  for (let i = 0; i < maxRetries; i++) {
    try {
      const result = await authenticate();
      if (result.success) {
        return result;
      }
    } catch (err) {
      if (err.code === 4001) {
        // User rejected
        return { success: false, error: 'User rejected' };
      }

      if (i === maxRetries - 1) {
        return { success: false, error: 'Authentication failed' };
      }

      // Wait before retry
      await new Promise(resolve => setTimeout(resolve, 1000 * (i + 1)));
    }
  }
}
```

### Backend Error Handling

```typescript
function handleAuthError(err: unknown): { status: number; error: string } {
  if (err instanceof SyntaxError) {
    return { status: 400, error: 'Invalid message format' };
  }

  if (err.type === 'expired') {
    return { status: 401, error: 'Message expired' };
  }

  if (err.type === 'signature_mismatch') {
    return { status: 401, error: 'Invalid signature' };
  }

  console.error('Unexpected auth error:', err);
  return { status: 500, error: 'Authentication failed' };
}

app.post('/auth/verify', async (req, res) => {
  try {
    // Verification logic...
  } catch (err) {
    const { status, error } = handleAuthError(err);
    res.status(status).json({ error });
  }
});
```

## Security Best Practices

### Clock Skew Handling

```typescript
const CLOCK_SKEW_MS = 30000; // 30 seconds

function validateWithSkew(message: BrandedMessage): ValidationResult {
  const now = new Date(Date.now() - CLOCK_SKEW_MS);
  return Siwe.validate(message, { now });
}
```

### HTTPS Only

```typescript
// Middleware to enforce HTTPS
app.use((req, res, next) => {
  if (!req.secure && process.env.NODE_ENV === 'production') {
    return res.status(403).json({ error: 'HTTPS required' });
  }
  next();
});
```

### Domain Validation

```typescript
const ALLOWED_DOMAINS = ['example.com', 'www.example.com'];

function validateDomain(message: BrandedMessage, requestHost: string): boolean {
  return ALLOWED_DOMAINS.includes(message.domain) &&
         message.domain === requestHost;
}
```

### Audit Logging

```typescript
async function logAuthAttempt(
  address: string,
  success: boolean,
  reason?: string
) {
  await db.auditLog.create({
    type: 'auth_attempt',
    address,
    success,
    reason,
    timestamp: new Date(),
    ip: req.ip,
    userAgent: req.get('user-agent'),
  });
}

// Use in auth endpoint
const verifyResult = Siwe.verifyMessage(message, signature);
await logAuthAttempt(
  Address.toHex(message.address),
  verifyResult.valid,
  verifyResult.valid ? undefined : verifyResult.error.message
);
```

## Testing

### Mock Authentication

```typescript
// Test helper
function createTestMessage(): BrandedMessage {
  return Siwe.create({
    domain: "test.example.com",
    address: Address.fromHex("0x742d35Cc6634C0532925a3b844Bc9e7595f251e3"),
    uri: "https://test.example.com",
    chainId: 1,
    nonce: "testnonce123",
  });
}

// Test
describe('Authentication', () => {
  it('accepts valid message', async () => {
    const message = createTestMessage();
    const text = Siwe.format(message);
    const signature = await testWallet.signMessage(text);

    const response = await request(app)
      .post('/auth/verify')
      .send({ message: text, signature });

    expect(response.status).toBe(200);
    expect(response.body.token).toBeDefined();
  });
});
```

## See Also

- [Siwe.create](./constructors.mdx) - Create messages
- [Siwe.verify](./verification.mdx) - Verify signatures
- [Validation](./validation.mdx) - Validate messages
- [EIP-4361](https://eips.ethereum.org/EIPS/eip-4361) - Specification
