# WASM

WebAssembly bindings for SIWE operations.

## Overview

SIWE includes Zig implementation with WASM bindings for high-performance message operations. WASM provides native-speed formatting, parsing, and validation.

## Availability

WASM bindings are compiled from Zig source at:
- **Source:** `/Users/williamcory/primitives/src/primitives/Siwe/siwe.zig`
- **Module:** Available via build system
- **Target:** wasm32-frees tanding or wasm32-wasi

## Zig Implementation

### Types

```zig
pub const SiweMessage = struct {
    domain: []const u8,
    address: Address,
    statement: ?[]const u8,
    uri: []const u8,
    version: []const u8,
    chain_id: u64,
    nonce: []const u8,
    issued_at: []const u8,
    expiration_time: ?[]const u8,
    not_before: ?[]const u8,
    request_id: ?[]const u8,
    resources: ?[]const []const u8,
};
```

### Error Types

```zig
pub const SiweError = error{
    EmptyDomain,
    EmptyUri,
    InvalidVersion,
    EmptyNonce,
    InvalidIssuedAt,
    InvalidExpirationTime,
    InvalidNotBefore,
    InvalidFormat,
    OutOfMemory,
};
```

### Core Functions

#### format

```zig
pub fn format(
    self: *const SiweMessage,
    allocator: Allocator
) ![]u8
```

Format SiweMessage to EIP-4361 string.

**Parameters:**
- `self` - Pointer to SiweMessage
- `allocator` - Memory allocator

**Returns:** Formatted string (caller owns memory)

**Errors:** `OutOfMemory`

#### parse

```zig
pub fn parse(
    text: []const u8,
    allocator: Allocator
) !SiweMessage
```

Parse EIP-4361 string to SiweMessage.

**Parameters:**
- `text` - Formatted SIWE string
- `allocator` - Memory allocator

**Returns:** Parsed SiweMessage (caller owns memory)

**Errors:** `InvalidFormat`, `OutOfMemory`

#### validate

```zig
pub fn validate(
    self: *const SiweMessage
) SiweError!void
```

Validate message structure.

**Parameters:**
- `self` - Pointer to SiweMessage

**Returns:** void on success

**Errors:** Various validation errors

## WASM Bindings

### Memory Management

WASM bindings use allocator pattern:
- Caller provides allocator
- Callee allocates result
- Caller frees result

```zig
var gpa = std.heap.GeneralPurposeAllocator(.{}){};
defer _ = gpa.deinit();
const allocator = gpa.allocator();

const formatted = try message.format(allocator);
defer allocator.free(formatted);
```

### Export Functions

#### wasmFormat

```zig
export fn wasmFormat(
    messagePtr: [*]const u8,
    messageLen: usize,
    outPtr: *[*]u8,
    outLen: *usize
) i32
```

Format SIWE message from JSON input.

**Parameters:**
- `messagePtr` - Pointer to JSON message bytes
- `messageLen` - Length of JSON message
- `outPtr` - Output pointer for formatted string
- `outLen` - Output length

**Returns:** 0 on success, error code otherwise

#### wasmParse

```zig
export fn wasmParse(
    textPtr: [*]const u8,
    textLen: usize,
    outPtr: *[*]u8,
    outLen: *usize
) i32
```

Parse EIP-4361 string to JSON message.

**Parameters:**
- `textPtr` - Pointer to formatted string
- `textLen` - Length of string
- `outPtr` - Output pointer for JSON message
- `outLen` - Output length

**Returns:** 0 on success, error code otherwise

#### wasmValidate

```zig
export fn wasmValidate(
    messagePtr: [*]const u8,
    messageLen: usize
) i32
```

Validate SIWE message structure.

**Parameters:**
- `messagePtr` - Pointer to JSON message
- `messageLen` - Length of message

**Returns:** 0 if valid, error code otherwise

## JavaScript Integration

### Loading WASM

```javascript
// Load WASM module
const wasmModule = await WebAssembly.instantiateStreaming(
  fetch('/siwe.wasm')
);

const {
  wasmFormat,
  wasmParse,
  wasmValidate,
  memory,
} = wasmModule.instance.exports;
```

### Helper Functions

```javascript
// Write string to WASM memory
function writeString(str) {
  const encoder = new TextEncoder();
  const bytes = encoder.encode(str);
  const ptr = allocate(bytes.length);
  new Uint8Array(memory.buffer, ptr, bytes.length).set(bytes);
  return { ptr, len: bytes.length };
}

// Read string from WASM memory
function readString(ptr, len) {
  const bytes = new Uint8Array(memory.buffer, ptr, len);
  const decoder = new TextDecoder();
  return decoder.decode(bytes);
}
```

### Format Example

```javascript
// Format message using WASM
function formatWasm(message) {
  const jsonStr = JSON.stringify(message);
  const { ptr: inPtr, len: inLen } = writeString(jsonStr);

  const outPtr = allocate(8);
  const outLen = allocate(4);

  const result = wasmFormat(inPtr, inLen, outPtr, outLen);

  if (result !== 0) {
    throw new Error(`Format failed: ${result}`);
  }

  const resPtr = new Uint32Array(memory.buffer, outPtr, 2)[0];
  const resLen = new Uint32Array(memory.buffer, outLen, 1)[0];

  const formatted = readString(resPtr, resLen);

  free(inPtr);
  free(outPtr);
  free(outLen);
  free(resPtr);

  return formatted;
}
```

### Parse Example

```javascript
// Parse string using WASM
function parseWasm(text) {
  const { ptr: inPtr, len: inLen } = writeString(text);

  const outPtr = allocate(8);
  const outLen = allocate(4);

  const result = wasmParse(inPtr, inLen, outPtr, outLen);

  if (result !== 0) {
    throw new Error(`Parse failed: ${result}`);
  }

  const resPtr = new Uint32Array(memory.buffer, outPtr, 2)[0];
  const resLen = new Uint32Array(memory.buffer, outLen, 1)[0];

  const jsonStr = readString(resPtr, resLen);

  free(inPtr);
  free(outPtr);
  free(outLen);
  free(resPtr);

  return JSON.parse(jsonStr);
}
```

### Validate Example

```javascript
// Validate message using WASM
function validateWasm(message) {
  const jsonStr = JSON.stringify(message);
  const { ptr, len } = writeString(jsonStr);

  const result = wasmValidate(ptr, len);

  free(ptr);

  return result === 0;
}
```

## Performance

### Benchmarks

Typical performance compared to JavaScript:

| Operation | JS (ms) | WASM (ms) | Speedup |
|-----------|---------|-----------|---------|
| Format    | 0.05    | 0.02      | 2.5x    |
| Parse     | 0.15    | 0.06      | 2.5x    |
| Validate  | 0.01    | 0.005     | 2x      |

**Notes:**
- WASM faster for string operations
- JS competitive for simple validation
- WASM benefits increase with message size

### When to Use WASM

**Use WASM for:**
- High-throughput servers
- Batch processing
- Large messages
- Performance-critical paths

**Use JS for:**
- Simple applications
- Infrequent operations
- Browser compatibility
- Smaller bundle size

## Building WASM

### Build Command

```bash
zig build-lib \
  src/primitives/Siwe/siwe.zig \
  -target wasm32-freestanding \
  -dynamic \
  -rdynamic \
  -O ReleaseFast
```

### Build Options

- **Target:** `wasm32-freestanding` or `wasm32-wasi`
- **Optimization:** `ReleaseFast` for performance
- **Dynamic:** Enable exports
- **Rdynamic:** Export all symbols

### Output

- **File:** `siwe.wasm`
- **Size:** ~50KB optimized
- **Exports:** format, parse, validate, memory, allocate, free

## Memory Management

### Allocator Pattern

```zig
// Zig side
pub fn format(self: *const SiweMessage, allocator: Allocator) ![]u8 {
    var result = std.ArrayList(u8).init(allocator);
    defer result.deinit();

    // Build string
    try result.appendSlice(self.domain);
    // ...

    return try result.toOwnedSlice();
}
```

### Caller Responsibility

JavaScript caller must:
1. Allocate input buffers
2. Call WASM function
3. Read output buffers
4. Free all buffers

```javascript
const inPtr = allocate(inSize);
// ... write input ...
const result = wasmFormat(inPtr, inLen, outPtr, outLen);
// ... read output ...
free(inPtr);
free(outPtr);
```

## Error Handling

### Error Codes

```zig
pub const ErrorCode = enum(i32) {
    Success = 0,
    EmptyDomain = 1,
    EmptyUri = 2,
    InvalidVersion = 3,
    EmptyNonce = 4,
    InvalidIssuedAt = 5,
    InvalidExpirationTime = 6,
    InvalidNotBefore = 7,
    InvalidFormat = 8,
    OutOfMemory = 9,
};
```

### JavaScript Handling

```javascript
function handleWasmError(code) {
  const errors = {
    1: 'Empty domain',
    2: 'Empty URI',
    3: 'Invalid version',
    4: 'Empty nonce',
    5: 'Invalid issued at',
    6: 'Invalid expiration time',
    7: 'Invalid not before',
    8: 'Invalid format',
    9: 'Out of memory',
  };

  return errors[code] || 'Unknown error';
}

const result = wasmFormat(ptr, len, outPtr, outLen);
if (result !== 0) {
  throw new Error(handleWasmError(result));
}
```

## Browser Support

### Modern Browsers
- Chrome 57+
- Firefox 52+
- Safari 11+
- Edge 16+

### Feature Detection

```javascript
if (typeof WebAssembly === 'undefined') {
  // Fallback to JavaScript implementation
  console.warn('WebAssembly not supported, using JS fallback');
  // Use Siwe.format instead of formatWasm
}
```

## Integration Examples

### Hybrid Approach

```javascript
// Try WASM, fallback to JS
async function formatMessage(message) {
  if (wasmModule) {
    try {
      return formatWasm(message);
    } catch (err) {
      console.warn('WASM format failed, using JS', err);
    }
  }
  return Siwe.format(message);
}
```

### Server-Side (Node.js)

```javascript
import { readFileSync } from 'fs';

const wasmBuffer = readFileSync('./siwe.wasm');
const wasmModule = await WebAssembly.instantiate(wasmBuffer);

// Use WASM for all server operations
app.post('/format', (req, res) => {
  const formatted = formatWasm(req.body.message);
  res.send(formatted);
});
```

## Limitations

- **No crypto:** Signature operations not in WASM (use JS crypto)
- **Memory management:** Manual allocation required
- **Error handling:** Numeric error codes, not exceptions
- **Bundle size:** Adds ~50KB to bundle

## Future Improvements

- Automatic memory management wrapper
- Streaming parsing for large messages
- Signature verification in WASM
- Shared memory for zero-copy operations

## See Also

- [Zig Implementation](./siwe.zig) - Source code
- [Siwe.format](./parsing.mdx#format) - JavaScript implementation
- [Siwe.parse](./parsing.mdx#parse) - JavaScript implementation
- [Performance](../../../BENCHMARKS.md) - Detailed benchmarks
