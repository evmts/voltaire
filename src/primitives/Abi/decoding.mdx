---
title: ABI Decoding
description: Low-level ABI decoding algorithms and implementation
---

import { Tabs, TabItem, Aside } from '@astrojs/starlight/components';

# ABI Decoding

Low-level ABI decoding implementation following the Ethereum ABI specification.

## Overview

The ABI decoding module provides low-level functions for decoding Solidity types according to the [Solidity ABI specification](https://docs.soliditylang.org/en/latest/abi-spec.html). These functions are used internally by Function, Event, Error, and Constructor decoders.

## Core Functions

### decodeParameters

Decode multiple parameters from ABI-encoded data.

```typescript
function decodeParameters<const TParams extends readonly Parameter[]>(
  params: TParams,
  data: Uint8Array
): ParametersToPrimitiveTypes<TParams>
```

**Parameters:**
- `params` - Array of parameter definitions
- `data` - ABI-encoded data

**Returns:** Array of decoded values

**Example:**
```typescript
import { decodeParameters } from '@tevm/primitives/Abi'

const params = [
  { type: "address" },
  { type: "uint256" },
  { type: "string" }
]

const decoded = decodeParameters(params, encodedData)
// ["0x742d35Cc6634C0532925a3b844Bc9e7595f51e3e", 1000n, "Hello"]
```

Source: [Encoding.ts:356-370](https://github.com/evmts/primitives/blob/main/src/primitives/Abi/Encoding.ts#L356-L370)

### decodeValue

Decode a single value from data.

```typescript
function decodeValue(
  type: Parameter["type"],
  data: Uint8Array,
  offset: number
): { value: unknown; newOffset: number }
```

**Parameters:**
- `type` - Solidity type string
- `data` - Encoded data
- `offset` - Starting position in data

**Returns:** Decoded value and new offset

**Example:**
```typescript
import { decodeValue } from '@tevm/primitives/Abi'

const { value, newOffset } = decodeValue("uint256", data, 0)
// value: 1000n, newOffset: 32
```

Source: [Encoding.ts:176-303](https://github.com/evmts/primitives/blob/main/src/primitives/Abi/Encoding.ts#L176-L303)

## Type-Specific Decoding

### Unsigned Integers

```typescript
import { decodeUint256 } from '@tevm/primitives/Abi'

// Decode uint256 from 32 bytes
const value = decodeUint256(data, 0)
// bigint

// Smaller uints decoded to number (< 64 bits) or bigint (≥ 64 bits)
const { value: uint8 } = decodeValue("uint8", data, 0)
// number (0-255)

const { value: uint256 } = decodeValue("uint256", data, 0)
// bigint
```

**Implementation:**
- Read 32 bytes from offset
- Convert to bigint
- Validate against type range
- Return number for small types, bigint for large

Source: [Encoding.ts:213-224](https://github.com/evmts/primitives/blob/main/src/primitives/Abi/Encoding.ts#L213-L224)

### Signed Integers

```typescript
// Decode signed integers (two's complement)
const { value: int8 } = decodeValue("int8", data, 0)
// number (-128 to 127)

const { value: int256 } = decodeValue("int256", data, 0)
// bigint

// Negative numbers converted from two's complement
const { value: negative } = decodeValue("int256", negativeData, 0)
// -1000n
```

**Implementation:**
- Read 32 bytes as unsigned
- Mask to type bit width
- Check sign bit and convert to negative if needed

Source: [Encoding.ts:226-244](https://github.com/evmts/primitives/blob/main/src/primitives/Abi/Encoding.ts#L226-L244)

### Address

```typescript
// Decode address from 32 bytes (last 20 bytes)
const { value: address } = decodeValue("address", data, 0)
// "0x742d35cc6634c0532925a3b844bc9e7595f51e3e"
```

Source: [Encoding.ts:246-254](https://github.com/evmts/primitives/blob/main/src/primitives/Abi/Encoding.ts#L246-L254)

### Boolean

```typescript
// Decode bool (any non-zero value is true)
const { value: bool } = decodeValue("bool", data, 0)
// true or false
```

Source: [Encoding.ts:256-268](https://github.com/evmts/primitives/blob/main/src/primitives/Abi/Encoding.ts#L256-L268)

### Fixed-Size Bytes

```typescript
// bytes1 to bytes32: extract N bytes from start
const { value: bytes4 } = decodeValue("bytes4", data, 0)
// Uint8Array(4)
```

Source: [Encoding.ts:270-279](https://github.com/evmts/primitives/blob/main/src/primitives/Abi/Encoding.ts#L270-L279)

### Dynamic Bytes

```typescript
// bytes: read offset, then length, then data
const { value: bytes } = decodeValue("bytes", data, 0)
// Uint8Array with actual data length
```

**Implementation:**
1. Read offset pointer from current position
2. Read length from offset position
3. Read data bytes
4. Return Uint8Array

Source: [Encoding.ts:281-289](https://github.com/evmts/primitives/blob/main/src/primitives/Abi/Encoding.ts#L281-L289)

### String

```typescript
// string: same as bytes, then UTF-8 decode
const { value: str } = decodeValue("string", data, 0)
// "Hello"
```

Source: [Encoding.ts:291-300](https://github.com/evmts/primitives/blob/main/src/primitives/Abi/Encoding.ts#L291-L300)

### Dynamic Arrays

```typescript
// type[]: read offset, length, then elements
const params = [{ type: "uint256[]" }]
const [array] = decodeParameters(params, data)
// [1n, 2n, 3n]
```

Source: [Encoding.ts:181-192](https://github.com/evmts/primitives/blob/main/src/primitives/Abi/Encoding.ts#L181-L192)

### Fixed Arrays

```typescript
// type[n]: decode n elements inline or via offset
const params = [{ type: "uint256[3]" }]
const [array] = decodeParameters(params, data)
// [1n, 2n, 3n]
```

Source: [Encoding.ts:194-211](https://github.com/evmts/primitives/blob/main/src/primitives/Abi/Encoding.ts#L194-L211)

## Decoding Algorithm

### Head-Tail Structure

Decoding follows the inverse of encoding:

1. **Parse head section** (32 bytes per parameter)
   - Static types: decode value directly
   - Dynamic types: read offset pointer

2. **Follow offset pointers to tail section**
   - Read length (if applicable)
   - Decode dynamic data

**Example:**
```typescript
// Encoded data layout:
// HEAD (96 bytes):
//   [0-31]:   uint256(1000)
//   [32-63]:  offset(96) to string
//   [64-95]:  bool(true)
// TAIL (64 bytes):
//   [96-127]:  string length(5)
//   [128-159]: "Hello" + padding

const params = [
  { type: "uint256" },
  { type: "string" },
  { type: "bool" }
]

const [num, str, flag] = decodeParameters(params, data)
// [1000n, "Hello", true]
```

### Offset Calculation

For dynamic types, offset is relative to start of encoding:

```typescript
// Offset 96 means data starts at byte 96
const offset = Number(decodeUint256(data, 32))  // Read offset at position 32
const dynamicData = data.slice(offset)          // Jump to offset
```

## Complex Examples

### Mixed Static and Dynamic

```typescript
const params = [
  { type: "address" },
  { type: "uint256" },
  { type: "string" },
  { type: "bytes32" },
  { type: "bytes" }
]

const [addr, num, str, hash, bytes] = decodeParameters(params, data)
```

### Nested Arrays

```typescript
// Array of arrays
const params = [{ type: "uint256[][]" }]

const [nested] = decodeParameters(params, data)
// [[1n, 2n], [3n, 4n, 5n]]
```

### Tuples

```typescript
const params = [{
  type: "tuple",
  components: [
    { type: "address", name: "owner" },
    { type: "uint256", name: "balance" },
    { type: "string", name: "name" }
  ]
}]

const [tuple] = decodeParameters(params, data)
// { owner: "0x...", balance: 1000n, name: "Alice" }
```

## Error Handling

```typescript
import { AbiDecodingError } from '@tevm/primitives/Abi'

try {
  decodeParameters(params, data)
} catch (error) {
  if (error instanceof AbiDecodingError) {
    console.error("Decoding failed:", error.message)
    // "Data too small for uint256"
    // "Value out of range for uint8"
    // "Unsupported type: custom"
  }
}
```

Common errors:
- `"Data too small for {type}"` - Insufficient data
- `"Value {value} out of range for {type}"` - Value exceeds type limits
- `"Unsupported type: {type}"` - Unknown type
- `"Data too small for bytes"` - Dynamic data truncated

## Type Coercion

### Number vs BigInt

Small integers decoded to `number`, large to `bigint`:

```typescript
// uint8-uint64 → number (if fits in safe integer range)
const { value: uint8 } = decodeValue("uint8", data, 0)
// number

// uint64-uint256 → bigint
const { value: uint256 } = decodeValue("uint256", data, 0)
// bigint

// int8-int32 → number
const { value: int32 } = decodeValue("int32", data, 0)
// number

// int64-int256 → bigint
const { value: int256 } = decodeValue("int256", data, 0)
// bigint
```

### Address Format

Addresses decoded to lowercase hex strings:

```typescript
const { value: addr } = decodeValue("address", data, 0)
// "0x742d35cc6634c0532925a3b844bc9e7595f51e3e"
// (lowercase, no checksum)
```

## Validation

Decoded values are validated during decoding:

```typescript
// Range checking
const { value } = decodeValue("uint8", data, 0)
if (value > 255) throw new AbiDecodingError("Value out of range")

// Length validation
const { value: addr } = decodeValue("address", data, 0)
// Only last 20 bytes used, first 12 must be zero (not enforced)

// Fixed-size bytes
const { value: bytes4 } = decodeValue("bytes4", data, 0)
// Exactly 4 bytes extracted
```

## Performance Considerations

**Static types:**
- Fast, fixed-offset decoding
- No additional memory allocation

**Dynamic types:**
- Requires offset following
- Memory allocation for strings/bytes/arrays

**Optimization tips:**
- Read only needed data (avoid decoding entire response)
- Cache decoded values
- Use typed arrays for better performance

## Partial Decoding

Decode only specific parameters:

```typescript
// Only decode first parameter
const params = [{ type: "uint256" }]
const [value] = decodeParameters(params, data)
// Ignores rest of data

// Decode specific range
const { value: secondParam } = decodeValue("address", data, 32)
// Start at offset 32
```

## Related

- [Abi](/primitives/abi) - Main ABI documentation
- [Encoding](/primitives/abi/encoding) - Encoding implementation
- [Types](/primitives/abi/types) - ABI type system
- [Function](/primitives/abi/function) - Function decoding
- [Event](/primitives/abi/event) - Event log decoding

## Specification

- [Solidity ABI Specification](https://docs.soliditylang.org/en/latest/abi-spec.html) - Official decoding rules
- [Formal Encoding](https://docs.soliditylang.org/en/latest/abi-spec.html#formal-specification-of-the-encoding) - Formal specification
