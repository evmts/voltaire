---
title: Constructor Encoding
description: Constructor parameter encoding for contract deployment
---

import { Tabs, TabItem, Aside } from '@astrojs/starlight/components';

# Constructor Encoding

Constructor parameter encoding for Ethereum smart contract deployment.

## Overview

Constructor encoding prepares constructor parameters for contract deployment transactions. The encoded data is appended to the contract bytecode.

## Constructor Type

```typescript
export type BrandedConstructor<
  TStateMutability extends StateMutability = StateMutability,
  TInputs extends readonly Parameter[] = readonly Parameter[]
> = {
  type: "constructor"
  stateMutability: TStateMutability
  inputs: TInputs
}
```

Source: [BrandedConstructor.ts:4-11](https://github.com/evmts/primitives/blob/main/src/primitives/Abi/constructor/BrandedConstructor.ts#L4-L11)

## Quick Start

```typescript
import { Constructor } from '@tevm/primitives/Abi'

// Define constructor
const constructor = {
  type: "constructor",
  stateMutability: "nonpayable",
  inputs: [
    { type: "string", name: "name" },
    { type: "string", name: "symbol" },
    { type: "uint8", name: "decimals" }
  ]
}

// Encode constructor parameters
const encodedParams = Constructor.encodeParams(constructor, [
  "MyToken",
  "MTK",
  18
])

// Deploy: concatenate bytecode + encodedParams
const deployData = bytecode + encodedParams
```

## API Reference

### encodeParams

Encode constructor parameters for deployment.

```typescript
function encodeParams<TInputs extends readonly Parameter[]>(
  constructor: BrandedConstructor<StateMutability, TInputs>,
  args: ParametersToPrimitiveTypes<TInputs>
): Uint8Array
```

**Parameters:**
- `constructor: BrandedConstructor` - Constructor ABI item
- `args` - Array of parameter values matching constructor inputs

**Returns:** `Uint8Array` - ABI-encoded constructor parameters

**Example:**
```typescript
const constructor = {
  type: "constructor",
  stateMutability: "nonpayable",
  inputs: [
    { type: "address", name: "owner" },
    { type: "uint256", name: "initialSupply" }
  ]
}

const encodedParams = Constructor.encodeParams(constructor, [
  "0x742d35Cc6634C0532925a3b844Bc9e7595f51e3e",
  1000000n
])
```

**Note:** No selector prefix (unlike functions). Just ABI-encoded parameters.

Source: [encodeParams.js:20-22](https://github.com/evmts/primitives/blob/main/src/primitives/Abi/constructor/encodeParams.js#L20-L22)

### decodeParams

Decode constructor parameters.

```typescript
function decodeParams<TInputs extends readonly Parameter[]>(
  constructor: BrandedConstructor<StateMutability, TInputs>,
  data: Uint8Array
): ParametersToPrimitiveTypes<TInputs>
```

**Parameters:**
- `constructor: BrandedConstructor` - Constructor ABI item
- `data: Uint8Array` - Encoded constructor parameters

**Returns:** Decoded parameter values

**Example:**
```typescript
const constructor = {
  type: "constructor",
  stateMutability: "nonpayable",
  inputs: [
    { type: "string", name: "name" },
    { type: "uint256", name: "supply" }
  ]
}

const [name, supply] = Constructor.decodeParams(constructor, encodedData)
// name: "MyToken"
// supply: 1000000n
```

Source: [decodeParams.js:20-22](https://github.com/evmts/primitives/blob/main/src/primitives/Abi/constructor/decodeParams.js#L20-L22)

## Deployment Workflow

<Tabs>
<TabItem label="Basic Deployment">
```typescript
import { Constructor } from '@tevm/primitives/Abi'

// Contract bytecode (from solc)
const bytecode = "0x608060405234801561001057..."

// Constructor definition
const constructor = {
  type: "constructor",
  stateMutability: "nonpayable",
  inputs: [
    { type: "string", name: "name" },
    { type: "string", name: "symbol" }
  ]
}

// Encode constructor params
const params = Constructor.encodeParams(constructor, [
  "MyToken",
  "MTK"
])

// Concatenate bytecode and params
const deployData = new Uint8Array([
  ...bytecode,
  ...params
])

// Deploy transaction
const tx = {
  data: deployData,
  // no 'to' field for deployment
}

const receipt = await provider.sendTransaction(tx)
const contractAddress = receipt.contractAddress
```
</TabItem>
<TabItem label="Payable Constructor">
```typescript
const payableConstructor = {
  type: "constructor",
  stateMutability: "payable",
  inputs: [
    { type: "uint256", name: "initialDeposit" }
  ]
}

const params = Constructor.encodeParams(payableConstructor, [
  1000n
])

// Deploy with value
const tx = {
  data: bytecode + params,
  value: parseEther("1.0")  // Send ETH to constructor
}
```
</TabItem>
<TabItem label="No Constructor">
```typescript
// Contract with no constructor or default constructor
const deployData = bytecode  // Just bytecode, no params

const tx = {
  data: deployData
}

const receipt = await provider.sendTransaction(tx)
```
</TabItem>
</Tabs>

## State Mutability

Constructors can be `nonpayable` or `payable`:

```typescript
// Non-payable (default)
const constructor1 = {
  type: "constructor",
  stateMutability: "nonpayable",
  inputs: [{ type: "address", name: "owner" }]
}

// Payable (accepts ETH during deployment)
const constructor2 = {
  type: "constructor",
  stateMutability: "payable",
  inputs: [{ type: "uint256", name: "price" }]
}
```

## Examples

### ERC20 Token Deployment

```typescript
import { Constructor } from '@tevm/primitives/Abi'

const erc20Constructor = {
  type: "constructor",
  stateMutability: "nonpayable",
  inputs: [
    { type: "string", name: "name" },
    { type: "string", name: "symbol" },
    { type: "uint8", name: "decimals" },
    { type: "uint256", name: "initialSupply" }
  ]
}

const params = Constructor.encodeParams(erc20Constructor, [
  "MyToken",
  "MTK",
  18,
  1000000n * 10n ** 18n  // 1 million tokens with 18 decimals
])

const deployData = erc20Bytecode + params
```

### Proxy Contract

```typescript
const proxyConstructor = {
  type: "constructor",
  stateMutability: "nonpayable",
  inputs: [
    { type: "address", name: "implementation" },
    { type: "bytes", name: "data" }
  ]
}

const initData = encodeFunctionCall(...)  // Initialization call

const params = Constructor.encodeParams(proxyConstructor, [
  implementationAddress,
  initData
])
```

### Complex Parameters

```typescript
const complexConstructor = {
  type: "constructor",
  stateMutability: "nonpayable",
  inputs: [
    { type: "address[]", name: "owners" },
    { type: "uint256", name: "threshold" },
    {
      type: "tuple",
      name: "config",
      components: [
        { type: "bool", name: "paused" },
        { type: "uint256", name: "fee" }
      ]
    }
  ]
}

const params = Constructor.encodeParams(complexConstructor, [
  ["0x...", "0x...", "0x..."],  // owners
  2,  // threshold
  { paused: false, fee: 100n }  // config
])
```

## Decoding Constructor Parameters

Extract constructor parameters from deployment transaction:

```typescript
import { Constructor } from '@tevm/primitives/Abi'

// Get deployment transaction
const tx = await provider.getTransaction(deployTxHash)

// Extract constructor params (after bytecode)
const bytecodeLength = contractBytecode.length
const constructorData = tx.data.slice(bytecodeLength)

// Decode
const constructor = {
  type: "constructor",
  stateMutability: "nonpayable",
  inputs: [
    { type: "string", name: "name" },
    { type: "string", name: "symbol" }
  ]
}

const [name, symbol] = Constructor.decodeParams(
  constructor,
  constructorData
)
```

## Factory Patterns

### Simple Factory

```typescript
// Factory deploys contracts with constructor params
async function deployToken(name: string, symbol: string) {
  const params = Constructor.encodeParams(tokenConstructor, [name, symbol])
  const deployData = tokenBytecode + params

  return await signer.sendTransaction({ data: deployData })
}

const tx = await deployToken("MyToken", "MTK")
```

### CREATE2 Deployment

```typescript
// CREATE2 requires deterministic salt
import { keccak256 } from '@tevm/primitives'

const params = Constructor.encodeParams(constructor, [...])
const initCode = bytecode + params

const salt = keccak256(Buffer.from("my-salt"))

// Deploy via CREATE2
const address = await factory.deploy(salt, initCode)
```

## Verification

When verifying contracts on Etherscan, provide constructor arguments:

```typescript
// Encode constructor args for verification
const constructor = {
  type: "constructor",
  stateMutability: "nonpayable",
  inputs: [
    { type: "address", name: "owner" },
    { type: "uint256", name: "supply" }
  ]
}

const encodedArgs = Constructor.encodeParams(constructor, [
  "0x742d35Cc6634C0532925a3b844Bc9e7595f51e3e",
  1000000n
])

// Submit to Etherscan verification:
// - Contract source
// - Compiler version
// - Optimization settings
// - Constructor arguments: encodedArgs (hex string)
```

<Aside type="tip" title="Constructor vs Initializer">
For upgradeable contracts using proxies, use an initializer function instead of constructor. Constructors only run on implementation contracts, not proxies.
</Aside>

## Related

- [Abi](/primitives/abi) - Main ABI documentation
- [Types](/primitives/abi/types) - ABI type system
- [Function](/primitives/abi/function) - Function encoding
- [Encoding](/primitives/abi/encoding) - Low-level encoding
- [Usage Patterns](/primitives/abi/usage-patterns) - Common patterns

## Specification

- [Solidity Constructor](https://docs.soliditylang.org/en/latest/contracts.html#constructors) - Constructor specification
- [Contract Creation](https://ethereum.org/en/developers/docs/evm/) - Deployment process
