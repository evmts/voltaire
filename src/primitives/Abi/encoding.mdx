---
title: ABI Encoding
description: Low-level ABI encoding algorithms and implementation
---

import { Tabs, TabItem, Aside } from '@astrojs/starlight/components';

# ABI Encoding

Low-level ABI encoding implementation following the Ethereum ABI specification.

## Overview

The ABI encoding module provides low-level functions for encoding Solidity types according to the [Solidity ABI specification](https://docs.soliditylang.org/en/latest/abi-spec.html). These functions are used internally by Function, Event, Error, and Constructor encoders.

## Core Functions

### encodeParameters

Encode multiple parameters according to ABI spec.

```typescript
function encodeParameters<const TParams extends readonly Parameter[]>(
  params: TParams,
  values: ParametersToPrimitiveTypes<TParams>
): Uint8Array
```

**Parameters:**
- `params` - Array of parameter definitions
- `values` - Array of values matching parameter types

**Returns:** `Uint8Array` - ABI-encoded data

**Example:**
```typescript
import { encodeParameters } from '@tevm/primitives/Abi'

const params = [
  { type: "address" },
  { type: "uint256" },
  { type: "string" }
]

const encoded = encodeParameters(params, [
  "0x742d35Cc6634C0532925a3b844Bc9e7595f51e3e",
  1000n,
  "Hello"
])
```

Source: [Encoding.ts:305-354](https://github.com/evmts/primitives/blob/main/src/primitives/Abi/Encoding.ts#L305-L354)

### encodeValue

Encode a single value.

```typescript
function encodeValue(
  type: Parameter["type"],
  value: unknown
): { encoded: Uint8Array; isDynamic: boolean }
```

**Parameters:**
- `type` - Solidity type string
- `value` - Value to encode

**Returns:** Object with encoded bytes and dynamic flag

**Example:**
```typescript
import { encodeValue } from '@tevm/primitives/Abi'

// Static type
const { encoded, isDynamic } = encodeValue("uint256", 1000n)
// isDynamic: false, encoded: 32 bytes

// Dynamic type
const result = encodeValue("string", "Hello")
// isDynamic: true, encoded: length + padded data
```

Source: [Encoding.ts:60-166](https://github.com/evmts/primitives/blob/main/src/primitives/Abi/Encoding.ts#L60-L166)

## Type-Specific Encoding

### Unsigned Integers

```typescript
import { encodeUint, encodeUint256 } from '@tevm/primitives/Abi'

// Encode uint256 (always 32 bytes)
const encoded = encodeUint256(1000n)

// Encode smaller uints with range checking
const encoded8 = encodeUint(255, 8)    // uint8
const encoded16 = encodeUint(1000, 16) // uint16
```

**Implementation:**
- All uints encoded as 32 bytes (left-padded with zeros)
- Values validated against type range
- Out of range throws `AbiEncodingError`

Source: [Encoding.ts:11-24](https://github.com/evmts/primitives/blob/main/src/primitives/Abi/Encoding.ts#L11-L24)

### Signed Integers

```typescript
import { encodeInt } from '@tevm/primitives/Abi'

// Encode signed integers
const encoded = encodeInt(-1000n, 256)  // int256
const encoded8 = encodeInt(-128, 8)     // int8

// Negative numbers use two's complement
const encodedNeg = encodeInt(-1n, 256)
// 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
```

**Implementation:**
- Negative numbers converted to two's complement
- Range validation: -(2^(bits-1)) to 2^(bits-1)-1
- Encoded as 32 bytes (left-padded)

Source: [Encoding.ts:26-37](https://github.com/evmts/primitives/blob/main/src/primitives/Abi/Encoding.ts#L26-L37)

### Address

```typescript
// Address encoded as 32 bytes (left-padded with zeros)
const addr = Address.fromHex("0x742d35Cc6634C0532925a3b844Bc9e7595f51e3e")
const encoded = Address.toAbiEncoded(addr)
// 32 bytes: 12 zeros + 20 address bytes
```

Source: [Encoding.ts:93-103](https://github.com/evmts/primitives/blob/main/src/primitives/Abi/Encoding.ts#L93-L103)

### Boolean

```typescript
// Bool encoded as 32 bytes (0 or 1 in last byte)
const { encoded } = encodeValue("bool", true)
// 32 bytes: 31 zeros + 1

const { encoded: falseEncoded } = encodeValue("bool", false)
// 32 bytes: all zeros
```

Source: [Encoding.ts:105-109](https://github.com/evmts/primitives/blob/main/src/primitives/Abi/Encoding.ts#L105-L109)

### Fixed-Size Bytes

```typescript
// bytes1 to bytes32: right-padded to 32 bytes
const bytes4 = new Uint8Array([0xa9, 0x05, 0x9c, 0xbb])
const { encoded } = encodeValue("bytes4", bytes4)
// 32 bytes: 4 data bytes + 28 zeros
```

Source: [Encoding.ts:111-124](https://github.com/evmts/primitives/blob/main/src/primitives/Abi/Encoding.ts#L111-L124)

### Dynamic Bytes

```typescript
// bytes: length (32 bytes) + data (padded to 32-byte multiple)
const data = new Uint8Array([1, 2, 3, 4, 5])
const { encoded } = encodeValue("bytes", data)
// [length: 5][data: 1,2,3,4,5 + 27 padding bytes]
```

Source: [Encoding.ts:126-134](https://github.com/evmts/primitives/blob/main/src/primitives/Abi/Encoding.ts#L126-L134)

### String

```typescript
// string: UTF-8 bytes with length prefix
const { encoded } = encodeValue("string", "Hello")
// [length: 5][UTF-8 bytes + padding]
```

Source: [Encoding.ts:136-145](https://github.com/evmts/primitives/blob/main/src/primitives/Abi/Encoding.ts#L136-L145)

### Dynamic Arrays

```typescript
// type[]: length + encoded elements
const params = [{ type: "uint256[]" }]
const encoded = encodeParameters(params, [[1n, 2n, 3n]])
// [length: 3][elem1: 32 bytes][elem2: 32 bytes][elem3: 32 bytes]
```

Source: [Encoding.ts:64-79](https://github.com/evmts/primitives/blob/main/src/primitives/Abi/Encoding.ts#L64-L79)

### Fixed Arrays

```typescript
// type[n]: n encoded elements (no length prefix)
const params = [{ type: "uint256[3]" }]
const encoded = encodeParameters(params, [[1n, 2n, 3n]])
// [elem1: 32 bytes][elem2: 32 bytes][elem3: 32 bytes]
```

Source: [Encoding.ts:147-163](https://github.com/evmts/primitives/blob/main/src/primitives/Abi/Encoding.ts#L147-L163)

## Encoding Algorithm

### Static vs Dynamic Types

**Static types** (fixed size, encoded inline):
- `uint<N>`, `int<N>` (N ≤ 256, multiple of 8)
- `address` (20 bytes, padded to 32)
- `bool`
- `bytes<N>` (N ≤ 32)
- Fixed arrays of static types: `type[n]`

**Dynamic types** (variable size, encoded via offset):
- `bytes`
- `string`
- Dynamic arrays: `type[]`
- Fixed arrays of dynamic types
- Tuples containing dynamic types

```typescript
import { isDynamicType } from '@tevm/primitives/Abi'

isDynamicType("uint256")    // false
isDynamicType("string")     // true
isDynamicType("bytes")      // true
isDynamicType("uint256[]")  // true
isDynamicType("bytes32")    // false
```

Source: [Encoding.ts:47-58](https://github.com/evmts/primitives/blob/main/src/primitives/Abi/Encoding.ts#L47-L58)

### Head-Tail Encoding

Parameters are encoded in two sections:

**Head** (static part, 32 bytes per parameter):
- Static types: actual encoded value
- Dynamic types: offset pointer to tail

**Tail** (dynamic part):
- Dynamic type data

**Example:**
```typescript
const params = [
  { type: "uint256" },  // static
  { type: "string" },   // dynamic
  { type: "bool" }      // static
]

const encoded = encodeParameters(params, [
  1000n,
  "Hello",
  true
])

// Layout:
// HEAD (96 bytes):
//   [0-31]:   uint256(1000)
//   [32-63]:  offset to string (96)
//   [64-95]:  bool(true)
// TAIL (64 bytes):
//   [96-127]:  string length (5)
//   [128-159]: "Hello" + padding
```

Source: [Encoding.ts:315-351](https://github.com/evmts/primitives/blob/main/src/primitives/Abi/Encoding.ts#L315-L351)

## Utility Functions

### padRight

Right-pad data to 32-byte multiple.

```typescript
import { padRight } from '@tevm/primitives/Abi'

const data = new Uint8Array([1, 2, 3])
const padded = padRight(data)
// 32 bytes: [1, 2, 3, 0, 0, ..., 0]
```

Source: [Encoding.ts:39-45](https://github.com/evmts/primitives/blob/main/src/primitives/Abi/Encoding.ts#L39-L45)

## Complex Examples

### Mixed Static and Dynamic

```typescript
const params = [
  { type: "address" },      // static
  { type: "uint256" },      // static
  { type: "string" },       // dynamic
  { type: "bytes32" },      // static
  { type: "uint256[]" }     // dynamic
]

const encoded = encodeParameters(params, [
  "0x742d35Cc6634C0532925a3b844Bc9e7595f51e3e",
  1000n,
  "Hello",
  new Uint8Array(32).fill(0xff),
  [1n, 2n, 3n]
])
```

### Nested Arrays

```typescript
// Array of arrays
const params = [{ type: "uint256[][]" }]

const encoded = encodeParameters(params, [
  [[1n, 2n], [3n, 4n, 5n]]
])
// Nested head-tail encoding
```

### Tuples (Structs)

```typescript
const params = [{
  type: "tuple",
  components: [
    { type: "address", name: "owner" },
    { type: "uint256", name: "balance" },
    { type: "string", name: "name" }
  ]
}]

const encoded = encodeParameters(params, [{
  owner: "0x742d35Cc6634C0532925a3b844Bc9e7595f51e3e",
  balance: 1000n,
  name: "Alice"
}])
```

## Error Handling

```typescript
import {
  AbiEncodingError,
  AbiParameterMismatchError
} from '@tevm/primitives/Abi'

try {
  // Out of range for uint8
  encodeUint(256, 8)
} catch (error) {
  // AbiEncodingError: Value 256 out of range for uint8
}

try {
  // Wrong number of parameters
  encodeParameters([{ type: "uint256" }], [1n, 2n])
} catch (error) {
  // AbiParameterMismatchError: Parameter count mismatch
}
```

## Performance Considerations

**Static types:**
- Fast, fixed-size encoding
- No memory allocation for offsets

**Dynamic types:**
- Two-pass encoding (measure then write)
- Extra memory for offset calculation

**Best practices:**
- Prefer static types when possible
- Group static parameters together
- Minimize dynamic arrays in hot paths

## Related

- [Abi](/primitives/abi) - Main ABI documentation
- [Decoding](/primitives/abi/decoding) - Decoding implementation
- [Types](/primitives/abi/types) - ABI type system
- [Function](/primitives/abi/function) - Function encoding
- [WASM](/primitives/abi/wasm) - WASM acceleration

## Specification

- [Solidity ABI Specification](https://docs.soliditylang.org/en/latest/abi-spec.html) - Official encoding rules
- [Formal Encoding](https://docs.soliditylang.org/en/latest/abi-spec.html#formal-specification-of-the-encoding) - Formal specification
