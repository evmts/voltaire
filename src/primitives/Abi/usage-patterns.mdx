---
title: ABI Usage Patterns
description: Common patterns for contract calls, log parsing, and type inference
---

import { Tabs, TabItem, Aside } from '@astrojs/starlight/components';

# ABI Usage Patterns

Common patterns and best practices for using ABI encoding and decoding.

## Contract Calls

### Read-Only Calls (eth_call)

```typescript
import { Function } from '@tevm/primitives/Abi'

// Define view function
const balanceOfFn = {
  type: "function",
  name: "balanceOf",
  stateMutability: "view",
  inputs: [{ type: "address", name: "account" }],
  outputs: [{ type: "uint256" }]
}

// Encode call
const calldata = Function.encodeParams(balanceOfFn, [userAddress])

// Execute eth_call
const result = await provider.call({
  to: contractAddress,
  data: calldata
})

// Decode result
const [balance] = Function.decodeResult(balanceOfFn, result)
console.log("Balance:", balance)
```

### State-Changing Transactions

```typescript
import { Function } from '@tevm/primitives/Abi'

// Define function
const transferFn = {
  type: "function",
  name: "transfer",
  stateMutability: "nonpayable",
  inputs: [
    { type: "address", name: "to" },
    { type: "uint256", name: "amount" }
  ],
  outputs: [{ type: "bool" }]
}

// Encode transaction
const calldata = Function.encodeParams(transferFn, [
  recipientAddress,
  amount
])

// Send transaction
const tx = await signer.sendTransaction({
  to: contractAddress,
  data: calldata,
  gasLimit: 100000
})

// Wait for confirmation
const receipt = await tx.wait()

// Check success
if (receipt.status === 1) {
  console.log("Transfer successful")
}
```

### Multicall Pattern

Batch multiple calls into one:

```typescript
import { Function } from '@tevm/primitives/Abi'

const balanceOfFn = {...}
const allowanceFn = {...}

// Encode multiple calls
const calls = [
  {
    target: tokenAddress,
    callData: Function.encodeParams(balanceOfFn, [user1])
  },
  {
    target: tokenAddress,
    callData: Function.encodeParams(balanceOfFn, [user2])
  },
  {
    target: tokenAddress,
    callData: Function.encodeParams(allowanceFn, [user1, spender])
  }
]

// Execute multicall
const results = await multicall.aggregate(calls)

// Decode results
const [balance1] = Function.decodeResult(balanceOfFn, results[0])
const [balance2] = Function.decodeResult(balanceOfFn, results[1])
const [allowance] = Function.decodeResult(allowanceFn, results[2])
```

## Event Log Parsing

### Single Event Type

```typescript
import { Event } from '@tevm/primitives/Abi'

const transferEvent = {
  type: "event",
  name: "Transfer",
  inputs: [
    { type: "address", name: "from", indexed: true },
    { type: "address", name: "to", indexed: true },
    { type: "uint256", name: "value" }
  ]
}

// Get logs
const logs = await provider.getLogs({
  address: contractAddress,
  topics: [Event.getSelector(transferEvent)],
  fromBlock: startBlock,
  toBlock: endBlock
})

// Decode all logs
const transfers = logs.map(log => ({
  ...Event.decodeLog(transferEvent, log.data, log.topics),
  blockNumber: log.blockNumber,
  transactionHash: log.transactionHash
}))
```

### Multiple Event Types

```typescript
import { Event } from '@tevm/primitives/Abi'

// Define events
const transferEvent = {...}
const approvalEvent = {...}

// Create selector map
const eventMap = new Map([
  [Event.getSelector(transferEvent).toString(), transferEvent],
  [Event.getSelector(approvalEvent).toString(), approvalEvent]
])

// Get all logs
const logs = await provider.getLogs({
  address: contractAddress,
  fromBlock: startBlock,
  toBlock: endBlock
})

// Decode with type discrimination
const events = logs
  .map(log => {
    const selector = log.topics[0]?.toString()
    const event = eventMap.get(selector)

    if (!event) return null

    return {
      name: event.name,
      args: Event.decodeLog(event, log.data, log.topics),
      log
    }
  })
  .filter(Boolean)

// Process by type
events.forEach(event => {
  if (event.name === "Transfer") {
    console.log(`Transfer: ${event.args.from} → ${event.args.to}`)
  } else if (event.name === "Approval") {
    console.log(`Approval: ${event.args.owner} → ${event.args.spender}`)
  }
})
```

### Filtered Event Queries

```typescript
import { Event } from '@tevm/primitives/Abi'

const transferEvent = {...}

// Filter for specific sender
const topics = Event.encodeTopics(transferEvent, {
  from: senderAddress
})

// Filter for specific recipient
const topics2 = Event.encodeTopics(transferEvent, {
  to: recipientAddress
})

// Filter for specific sender AND recipient
const topics3 = Event.encodeTopics(transferEvent, {
  from: senderAddress,
  to: recipientAddress
})

// Get filtered logs
const logs = await provider.getLogs({
  address: contractAddress,
  topics: topics,
  fromBlock: startBlock,
  toBlock: endBlock
})
```

### Real-Time Event Monitoring

```typescript
import { Event } from '@tevm/primitives/Abi'

const transferEvent = {...}

// Subscribe to events
const filter = {
  address: contractAddress,
  topics: [Event.getSelector(transferEvent)]
}

provider.on(filter, (log) => {
  const decoded = Event.decodeLog(
    transferEvent,
    log.data,
    log.topics
  )

  console.log(`Transfer: ${decoded.from} → ${decoded.to}: ${decoded.value}`)
})

// Unsubscribe
provider.off(filter)
```

## Error Handling

### Decoding Revert Errors

```typescript
import { Error } from '@tevm/primitives/Abi'

// Define possible errors
const errors = [
  {
    type: "error",
    name: "InsufficientBalance",
    inputs: [
      { type: "uint256", name: "balance" },
      { type: "uint256", name: "required" }
    ]
  },
  {
    type: "error",
    name: "Unauthorized",
    inputs: [{ type: "address", name: "sender" }]
  }
]

// Create selector map
const errorMap = new Map(
  errors.map(err => [
    Error.getSelector(err).toString(),
    err
  ])
)

// Handle transaction error
try {
  await contract.transfer(to, amount)
} catch (error) {
  const revertData = error.data

  if (!revertData) {
    console.error("Transaction failed (no revert data)")
    return
  }

  const selector = revertData.slice(0, 4).toString()
  const customError = errorMap.get(selector)

  if (customError) {
    const params = Error.decodeParams(customError, revertData)

    if (customError.name === "InsufficientBalance") {
      const [balance, required] = params
      console.error(`Insufficient balance: ${balance} < ${required}`)
    } else if (customError.name === "Unauthorized") {
      const [sender] = params
      console.error(`Unauthorized: ${sender}`)
    }
  } else {
    // Check for Panic(uint256)
    console.error("Unknown error or panic")
  }
}
```

### Graceful Error Recovery

```typescript
// Try multiple error types
async function safeCall(contract, method, ...args) {
  try {
    return await contract[method](...args)
  } catch (error) {
    // Try decoding known errors
    for (const errorDef of knownErrors) {
      try {
        const params = Error.decodeParams(errorDef, error.data)
        throw new CustomError(errorDef.name, params)
      } catch {
        continue
      }
    }

    // Unknown error
    throw error
  }
}
```

## Contract Deployment

### Standard Deployment

```typescript
import { Constructor } from '@tevm/primitives/Abi'

const constructor = {
  type: "constructor",
  stateMutability: "nonpayable",
  inputs: [
    { type: "string", name: "name" },
    { type: "string", name: "symbol" },
    { type: "uint8", name: "decimals" }
  ]
}

// Encode constructor params
const params = Constructor.encodeParams(constructor, [
  "MyToken",
  "MTK",
  18
])

// Deploy
const deployData = contractBytecode + params

const tx = await signer.sendTransaction({
  data: deployData,
  gasLimit: 3000000
})

const receipt = await tx.wait()
const contractAddress = receipt.contractAddress
```

### Factory Pattern

```typescript
import { Constructor, Function } from '@tevm/primitives/Abi'

// Factory function that deploys via factory contract
async function deployToken(name: string, symbol: string) {
  const constructor = {...}

  // Encode constructor params
  const initCode = contractBytecode + Constructor.encodeParams(
    constructor,
    [name, symbol]
  )

  // Call factory
  const createFn = {
    type: "function",
    name: "createToken",
    inputs: [{ type: "bytes", name: "initCode" }],
    outputs: [{ type: "address" }]
  }

  const calldata = Function.encodeParams(createFn, [initCode])

  const tx = await signer.sendTransaction({
    to: factoryAddress,
    data: calldata
  })

  const receipt = await tx.wait()

  // Decode deployed address from event or return value
  const [newTokenAddress] = Function.decodeResult(createFn, receipt.returnData)

  return newTokenAddress
}
```

## Type Inference

### Generic Contract Interface

```typescript
import { Function, Event } from '@tevm/primitives/Abi'
import type { Abi } from '@tevm/primitives'

class Contract<TAbi extends Abi> {
  constructor(
    private address: string,
    private abi: TAbi,
    private provider: Provider
  ) {}

  async call<TName extends string>(
    functionName: TName,
    args: any[]
  ) {
    const fn = this.abi.find(
      item => item.type === "function" && item.name === functionName
    )

    if (!fn) throw new Error(`Function ${functionName} not found`)

    const calldata = Function.encodeParams(fn, args)

    const result = await this.provider.call({
      to: this.address,
      data: calldata
    })

    return Function.decodeResult(fn, result)
  }

  async getLogs<TName extends string>(
    eventName: TName,
    filter?: any,
    fromBlock?: number,
    toBlock?: number
  ) {
    const event = this.abi.find(
      item => item.type === "event" && item.name === eventName
    )

    if (!event) throw new Error(`Event ${eventName} not found`)

    const topics = filter
      ? Event.encodeTopics(event, filter)
      : [Event.getSelector(event)]

    const logs = await this.provider.getLogs({
      address: this.address,
      topics,
      fromBlock,
      toBlock
    })

    return logs.map(log =>
      Event.decodeLog(event, log.data, log.topics)
    )
  }
}

// Usage with full type inference
const erc20 = new Contract(address, erc20Abi, provider)

const balance = await erc20.call("balanceOf", [userAddress])
const transfers = await erc20.getLogs("Transfer", { from: userAddress })
```

### Typed ABI Wrapper

```typescript
type ExtractFunctions<T extends Abi> = Extract<
  T[number],
  { type: "function" }
>

type ExtractEvents<T extends Abi> = Extract<
  T[number],
  { type: "event" }
>

function createTypedContract<TAbi extends Abi>(
  abi: TAbi,
  address: string,
  provider: Provider
) {
  return {
    functions: new Proxy({}, {
      get(_, name: string) {
        return async (...args: any[]) => {
          const fn = abi.find(
            item => item.type === "function" && item.name === name
          )
          if (!fn) throw new Error(`Function ${name} not found`)

          const calldata = Function.encodeParams(fn, args)
          const result = await provider.call({ to: address, data: calldata })

          return Function.decodeResult(fn, result)
        }
      }
    }),

    events: new Proxy({}, {
      get(_, name: string) {
        return async (filter?: any) => {
          const event = abi.find(
            item => item.type === "event" && item.name === name
          )
          if (!event) throw new Error(`Event ${name} not found`)

          const topics = filter
            ? Event.encodeTopics(event, filter)
            : [Event.getSelector(event)]

          const logs = await provider.getLogs({ address, topics })

          return logs.map(log =>
            Event.decodeLog(event, log.data, log.topics)
          )
        }
      }
    })
  }
}

// Usage
const contract = createTypedContract(erc20Abi, address, provider)

const balance = await contract.functions.balanceOf(userAddress)
const transfers = await contract.events.Transfer({ from: userAddress })
```

## Performance Optimization

### Selector Caching

```typescript
// Compute selectors once
const functionSelectors = new Map(
  functions.map(fn => [
    fn.name,
    Function.getSelector(fn)
  ])
)

const eventSelectors = new Map(
  events.map(evt => [
    evt.name,
    Event.getSelector(evt)
  ])
)

// Reuse cached selectors
function encodeCall(name: string, args: any[]) {
  const selector = functionSelectors.get(name)
  // ... encode with cached selector
}
```

### Batch Decoding

```typescript
// Decode multiple logs efficiently
const transferEvent = {...}

const decodedLogs = logs.map(log => {
  try {
    return Event.decodeLog(transferEvent, log.data, log.topics)
  } catch {
    return null
  }
}).filter(Boolean)
```

### Lazy ABI Loading

```typescript
// Load ABI on demand
const abiCache = new Map()

async function getContractAbi(address: string) {
  if (abiCache.has(address)) {
    return abiCache.get(address)
  }

  const abi = await fetch(`/api/abi/${address}`).then(r => r.json())
  abiCache.set(address, abi)

  return abi
}
```

## Testing Patterns

### Mock Contract Calls

```typescript
import { Function } from '@tevm/primitives/Abi'

// Mock provider
class MockProvider {
  mockReturnValue(fn: any, returnValue: any) {
    const encoded = Function.encodeResult(fn, returnValue)
    // Store for later call
  }
}

// Test
const balanceOfFn = {...}
const mockProvider = new MockProvider()

mockProvider.mockReturnValue(balanceOfFn, [1000n])

const result = await contract.balanceOf(userAddress)
// result === 1000n
```

### Event Testing

```typescript
import { Event } from '@tevm/primitives/Abi'

// Generate test event log
function createMockLog(event: any, args: any) {
  const topics = Event.encodeTopics(event, args)
  const data = encodeNonIndexedParams(event, args)

  return {
    topics,
    data,
    address: contractAddress,
    blockNumber: 123,
    transactionHash: "0x..."
  }
}

// Test
const transferEvent = {...}
const mockLog = createMockLog(transferEvent, {
  from: alice,
  to: bob
})

const decoded = Event.decodeLog(
  transferEvent,
  mockLog.data,
  mockLog.topics
)
```

## Related

- [Abi](/primitives/abi) - Main ABI documentation
- [Function](/primitives/abi/function) - Function operations
- [Event](/primitives/abi/event) - Event operations
- [Error](/primitives/abi/error) - Error handling
- [Constructor](/primitives/abi/constructor) - Contract deployment
- [BrandedAbi](/primitives/abi/branded-abi) - Functional API
