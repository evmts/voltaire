/**
 * Bytecode analyzeBlocks Benchmarks
 *
 * Measures performance of basic block analysis with various complexity levels
 */

import { bench, run } from "mitata";
import * as Bytecode from "./index.js";

// ============================================================================
// Test Data Generation
// ============================================================================

/**
 * Generate bytecode with controlled block structure
 * @param blockCount Target number of basic blocks
 * @param instructionsPerBlock Average instructions per block
 * @returns Generated bytecode
 */
function generateBytecodeWithBlocks(
	blockCount: number,
	instructionsPerBlock: number,
): Uint8Array {
	const bytecode: number[] = [];

	for (let b = 0; b < blockCount; b++) {
		// Add JUMPDEST to start block (except entry)
		if (b > 0) {
			bytecode.push(0x5b); // JUMPDEST
		}

		// Add instructions within block
		const instCount = instructionsPerBlock + Math.floor(Math.random() * 3);
		for (let i = 0; i < instCount; i++) {
			const rand = Math.random();

			if (rand < 0.3) {
				// PUSH1 + value
				bytecode.push(0x60);
				bytecode.push(Math.floor(Math.random() * 256));
			} else if (rand < 0.5) {
				// Arithmetic (ADD, SUB, MUL, DIV)
				const ops = [0x01, 0x03, 0x02, 0x04];
				bytecode.push(ops[Math.floor(Math.random() * ops.length)] ?? 0x01);
			} else if (rand < 0.65) {
				// Stack (DUP, SWAP)
				const ops = [
					0x80, 0x81, 0x82, 0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96,
				];
				bytecode.push(ops[Math.floor(Math.random() * ops.length)] ?? 0x80);
			} else if (rand < 0.75) {
				// Memory (MLOAD, MSTORE)
				const ops = [0x51, 0x52];
				bytecode.push(ops[Math.floor(Math.random() * ops.length)] ?? 0x51);
			} else if (rand < 0.85) {
				// Storage (SLOAD, SSTORE)
				const ops = [0x54, 0x55];
				bytecode.push(ops[Math.floor(Math.random() * ops.length)] ?? 0x54);
			} else {
				// Other opcodes
				const ops = [0x50, 0x5a, 0x09, 0x0a, 0x0b];
				bytecode.push(ops[Math.floor(Math.random() * ops.length)] ?? 0x50);
			}
		}

		// Terminate block (except last)
		if (b < blockCount - 1) {
			bytecode.push(0x60); // PUSH1
			bytecode.push((b + 1) * 10); // Jump target (simplified)
			bytecode.push(0x56); // JUMP
		}
	}

	// Final STOP
	bytecode.push(0x00);

	return new Uint8Array(bytecode);
}

/**
 * Generate complex bytecode with jump instructions
 * @param size Target bytecode size
 * @returns Generated bytecode
 */
function generateComplexBytecode(size: number): Uint8Array {
	const bytecode: number[] = [];
	let pos = 0;

	while (pos < size) {
		const rand = Math.random();

		if (rand < 0.15 && pos + 5 < size) {
			// JUMPDEST
			bytecode.push(0x5b);
			pos += 1;
		} else if (rand < 0.3 && pos + 3 < size) {
			// PUSH1 + JUMP pattern
			bytecode.push(0x60);
			bytecode.push(Math.floor(Math.random() * 256));
			bytecode.push(0x56);
			pos += 3;
		} else if (rand < 0.45 && pos + 3 < size) {
			// PUSH1 + JUMPI pattern
			bytecode.push(0x60);
			bytecode.push(Math.floor(Math.random() * 256));
			bytecode.push(0x57);
			pos += 3;
		} else if (rand < 0.6) {
			// Regular opcodes
			const ops = [0x01, 0x03, 0x02, 0x04, 0x51, 0x52, 0x54, 0x55];
			bytecode.push(ops[Math.floor(Math.random() * ops.length)] ?? 0x01);
			pos += 1;
		} else if (rand < 0.75) {
			// PUSH with variable size
			const pushSize = Math.floor(Math.random() * 32) + 1;
			const pushOpcode = Math.min(0x60 + pushSize - 1, 0x7f);
			bytecode.push(pushOpcode);
			for (let i = 0; i < pushSize && pos + 1 + i < size; i++) {
				bytecode.push(Math.floor(Math.random() * 256));
			}
			pos += 1 + pushSize;
		} else {
			// Stack operations
			const ops = [0x80, 0x81, 0x82, 0x90, 0x91, 0x5a];
			bytecode.push(ops[Math.floor(Math.random() * ops.length)] ?? 0x80);
			pos += 1;
		}
	}

	// Ensure valid terminator
	bytecode[bytecode.length - 1] = 0x00; // STOP

	return new Uint8Array(bytecode.slice(0, size));
}

// ============================================================================
// Benchmark Data
// ============================================================================

// Simple: 3 blocks, ~12 instructions per block
const simpleBytecode = generateBytecodeWithBlocks(3, 4);

// Medium: 50 blocks, ~8 instructions per block
const mediumBytecode = generateBytecodeWithBlocks(50, 8);

// Complex: 200+ blocks, ~6 instructions per block
const complexBytecode = generateBytecodeWithBlocks(250, 6);

// Size-based variants
const small100b = generateComplexBytecode(100);
const medium1kb = generateComplexBytecode(1024);
const large10kb = generateComplexBytecode(10240);
const huge50kb = generateComplexBytecode(51200);

// ============================================================================
// Benchmarks
// ============================================================================

bench("analyzeBlocks() - simple (3 blocks)", () => {
	const code = Bytecode.from(simpleBytecode);
	Bytecode.analyzeBlocks(code);
});

bench("analyzeBlocks() - medium (50 blocks)", () => {
	const code = Bytecode.from(mediumBytecode);
	Bytecode.analyzeBlocks(code);
});

bench("analyzeBlocks() - complex (250+ blocks)", () => {
	const code = Bytecode.from(complexBytecode);
	Bytecode.analyzeBlocks(code);
});

// Size scaling
bench("analyzeBlocks() - 100b", () => {
	const code = Bytecode.from(small100b);
	Bytecode.analyzeBlocks(code);
});

bench("analyzeBlocks() - 1kb", () => {
	const code = Bytecode.from(medium1kb);
	Bytecode.analyzeBlocks(code);
});

bench("analyzeBlocks() - 10kb", () => {
	const code = Bytecode.from(large10kb);
	Bytecode.analyzeBlocks(code);
});

bench("analyzeBlocks() - 50kb", () => {
	const code = Bytecode.from(huge50kb);
	Bytecode.analyzeBlocks(code);
});

// With CFG building
bench("analyzeBlocks() with CFG - simple", () => {
	const code = Bytecode.from(simpleBytecode);
	Bytecode.analyzeBlocks(code, { buildCFG: true });
});

bench("analyzeBlocks() with CFG - medium", () => {
	const code = Bytecode.from(mediumBytecode);
	Bytecode.analyzeBlocks(code, { buildCFG: true });
});

bench("analyzeBlocks() with CFG - complex", () => {
	const code = Bytecode.from(complexBytecode);
	Bytecode.analyzeBlocks(code, { buildCFG: true });
});

// With reachability analysis
bench("analyzeBlocks() with reachability - simple", () => {
	const code = Bytecode.from(simpleBytecode);
	Bytecode.analyzeBlocks(code, { computeReachability: true, buildCFG: true });
});

bench("analyzeBlocks() with reachability - medium", () => {
	const code = Bytecode.from(mediumBytecode);
	Bytecode.analyzeBlocks(code, { computeReachability: true, buildCFG: true });
});

bench("analyzeBlocks() with reachability - complex", () => {
	const code = Bytecode.from(complexBytecode);
	Bytecode.analyzeBlocks(code, { computeReachability: true, buildCFG: true });
});

// All options enabled
bench("analyzeBlocks() full analysis - simple", () => {
	const code = Bytecode.from(simpleBytecode);
	Bytecode.analyzeBlocks(code, {
		buildCFG: true,
		computeReachability: true,
		includeUnreachable: false,
	});
});

bench("analyzeBlocks() full analysis - medium", () => {
	const code = Bytecode.from(mediumBytecode);
	Bytecode.analyzeBlocks(code, {
		buildCFG: true,
		computeReachability: true,
		includeUnreachable: false,
	});
});

bench("analyzeBlocks() full analysis - complex", () => {
	const code = Bytecode.from(complexBytecode);
	Bytecode.analyzeBlocks(code, {
		buildCFG: true,
		computeReachability: true,
		includeUnreachable: false,
	});
});

await run();
