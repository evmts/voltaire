---
title: Bytecode
description: EVM bytecode representation and analysis
---

## Overview

The Bytecode module provides structures and utilities for EVM bytecode, including EOF (EIP-3540/EIP-3670) container format validation, bytecode analysis, and legacy/modern bytecode handling.

## Key Functions

### `fromBytes`
```zig
pub fn fromBytes(bytes: []const u8) Bytecode
```
Creates bytecode from raw byte slice.

### `isEof`
```zig
pub fn isEof(self: *const Bytecode) bool
```
Checks if bytecode uses EOF container format (starts with 0xEF00).

### `validate`
```zig
pub fn validate(self: *const Bytecode) !void
```
Validates bytecode structure (EOF header, section sizes, termination).

### `getCodeSection`
```zig
pub fn getCodeSection(self: *const Bytecode, index: usize) ![]const u8
```
Extracts code section from EOF container.

### `getDataSection`
```zig
pub fn getDataSection(self: *const Bytecode) ![]const u8
```
Extracts data section from EOF container.

## Types

### Bytecode Structure

```zig
pub const Bytecode = struct {
    bytes: []const u8,
    format: Format,
};

pub const Format = enum {
    legacy,
    eof,
};
```

### EOF Container

```zig
pub const EofHeader = struct {
    version: u8,
    types_size: u16,
    code_sizes: []u16,
    container_sizes: []u16,
    data_size: u16,
};
```

## Examples

### Creating and validating bytecode
```zig
// Legacy bytecode
const legacy = Bytecode.fromBytes(&[_]u8{
    0x60, 0x42, // PUSH1 0x42
    0x60, 0x00, // PUSH1 0x00
    0x52,       // MSTORE
    0x00,       // STOP
});
try legacy.validate();

// EOF bytecode (EIP-3540)
const eof = Bytecode.fromBytes(&[_]u8{
    0xEF, 0x00, // Magic
    0x01,       // Version
    // ... section headers
});
try eof.validate();
```

### Analyzing bytecode structure
```zig
if (bytecode.isEof()) {
    const code = try bytecode.getCodeSection(0);
    const data = try bytecode.getDataSection();

    // EOF bytecode has explicit code/data separation
    // Validates at deploy time, no invalid jumps
} else {
    // Legacy bytecode, dynamic jump validation needed
}
```

### EOF sections
```zig
// EOF container structure:
// [magic: 0xEF00][version][types_section][code_section(s)][data_section]

const eof_bytecode = Bytecode.fromBytes(eof_bytes);
try eof_bytecode.validate(); // Validates:
// - Magic bytes correct
// - Version supported
// - Section sizes consistent
// - Code terminates properly (no dangling bytes)
// - No invalid opcodes in body
```

## Performance

- Bytecode creation: ~XXX ns (zero-copy)
- EOF validation: ~XXX µs
- Section extraction: ~XXX ns
- Jump analysis: ~XXX µs (legacy bytecode)

## Testing

```bash
zig build test -Dtest-filter=Bytecode
```

Test coverage:
- Legacy bytecode validation
- EOF container parsing
- Section size validation
- Magic byte detection
- Invalid bytecode rejection
- Edge cases (empty code, max size, malformed EOF)

## Related

- [Opcode](/primitives/opcode) - EVM instruction definitions
- [Transaction](/primitives/transaction) - Contract deployment bytecode

## References

- [EIP-3540: EVM Object Format (EOF) v1](https://eips.ethereum.org/EIPS/eip-3540)
- [EIP-3670: EOF - Code Validation](https://eips.ethereum.org/EIPS/eip-3670)
- [EIP-4200: EOF - Static Relative Jumps](https://eips.ethereum.org/EIPS/eip-4200)
- EOF enables ahead-of-time validation and optimizations
