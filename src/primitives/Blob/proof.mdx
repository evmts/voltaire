# Blob.Proof

Nested namespace for KZG proof validation.

## Type

```typescript
type Proof = Uint8Array & { readonly __proof: unique symbol };
```

48-byte KZG proof (BLS12-381 G1 point).

## Namespace

```typescript
Blob.Proof.isValid(proof: Uint8Array): proof is Proof
```

---

## isValid

Validates proof size.

### Signature

```typescript
function isValid(proof: Uint8Array): proof is Proof
```

### Parameters

- `proof` - Uint8Array to validate

### Returns

`boolean` - `true` if exactly 48 bytes

### Type Guard

TypeScript type guard. Narrows type to `Proof`.

### Example

```typescript
const data = new Uint8Array(48);

if (Blob.Proof.isValid(data)) {
  // data is now Proof type
  const isValid = Blob.verify(blob, commitment, data);
}

// Invalid sizes
Blob.Proof.isValid(new Uint8Array(32));  // false
Blob.Proof.isValid(new Uint8Array(47));  // false
Blob.Proof.isValid(new Uint8Array(48));  // true
Blob.Proof.isValid(new Uint8Array(64));  // false
```

### Implementation

```javascript
export const Proof = {
  isValid: (proof) => {
    return proof.length === 48;
  },
};
```

### KZG Proof Size

48 bytes = BLS12-381 G1 point:
- Curve: BLS12-381
- Group: G1
- Encoding: Compressed form
- Size: 48 bytes (381 bits compressed)

### Validation Level

**Size only** - does not validate:
- Point is on curve
- Point is in correct subgroup
- Point encoding is valid
- Proof correctness

For cryptographic validation, use:
- `Blob.verify()` - single proof
- `Blob.verifyBatch()` - multiple proofs

### See Also

- [Blob.toProof](./conversions.mdx#toproof) - Generate proof
- [Blob.verify](./validation.mdx#verify) - Verify proof
- [Blob.verifyBatch](./validation.mdx#verifybatch) - Batch verification

---

## Usage Patterns

### Type-Safe Proof Handling

```typescript
function verifyBlobWithProof(
  blob: BrandedBlob,
  commitment: Commitment,
  proofData: Uint8Array
): boolean {
  if (!Blob.Proof.isValid(proofData)) {
    throw new Error("Invalid proof");
  }

  // proofData now typed as Proof
  return Blob.verify(blob, commitment, proofData);
}
```

### Validation Pipeline

```typescript
interface BlobPackage {
  blob: BrandedBlob;
  commitment: Commitment;
  proof: Uint8Array;
}

function validatePackage(pkg: BlobPackage): void {
  // Validate all components
  if (!Blob.isValid(pkg.blob)) {
    throw new Error("Invalid blob");
  }
  if (!Blob.Commitment.isValid(pkg.commitment)) {
    throw new Error("Invalid commitment");
  }
  if (!Blob.Proof.isValid(pkg.proof)) {
    throw new Error("Invalid proof");
  }

  // All valid
  console.log("Package valid");
}
```

### Transaction Validation

```typescript
interface BlobTransaction {
  blobs: BrandedBlob[];
  commitments: Commitment[];
  proofs: Uint8Array[];
}

function validateBlobTx(tx: BlobTransaction): boolean {
  // Array lengths match
  if (tx.blobs.length !== tx.commitments.length ||
      tx.blobs.length !== tx.proofs.length) {
    throw new Error("Array length mismatch");
  }

  // Validate all proofs
  for (const proof of tx.proofs) {
    if (!Blob.Proof.isValid(proof)) {
      throw new Error("Invalid proof in transaction");
    }
  }

  // Verify batch
  return Blob.verifyBatch(tx.blobs, tx.commitments, tx.proofs);
}
```

### Proof Generation

```typescript
function generateProofs(
  blobs: BrandedBlob[],
  commitments: Commitment[]
): Proof[] {
  const proofs: Proof[] = [];

  for (let i = 0; i < blobs.length; i++) {
    const proof = Blob.toProof(blobs[i], commitments[i]);

    // Validate generated proof
    if (!Blob.Proof.isValid(proof)) {
      throw new Error("Generated invalid proof");
    }

    proofs.push(proof);
  }

  return proofs;
}
```

### Safe Proof Array Processing

```typescript
function processProofs(proofs: Uint8Array[]): Proof[] {
  return proofs.filter(Blob.Proof.isValid);
}

// Or throw on invalid
function requireValidProofs(proofs: Uint8Array[]): Proof[] {
  const valid: Proof[] = [];

  for (let i = 0; i < proofs.length; i++) {
    if (!Blob.Proof.isValid(proofs[i])) {
      throw new Error(`Invalid proof at index ${i}`);
    }
    valid.push(proofs[i]);
  }

  return valid;
}
```

### Generic Proof Handler

```typescript
type ProofHandler = (p: Proof) => void;

function withValidProof(
  data: Uint8Array,
  handler: ProofHandler
): void {
  if (Blob.Proof.isValid(data)) {
    handler(data); // Type-safe: data is Proof
  } else {
    throw new Error("Invalid proof");
  }
}

// Usage
withValidProof(myData, (proof) => {
  console.log(`Valid proof: ${proof.length} bytes`);
});
```

---

## Related

### Other Namespaces

- [Blob.Commitment](./commitment.mdx) - Commitment validation
- [Blob.VersionedHash](./versioned-hash.mdx) - Hash operations

### Proof Operations

- [Blob.toProof](./conversions.mdx#toproof) - Generate proof
- [Blob.verify](./validation.mdx#verify) - Verify single proof
- [Blob.verifyBatch](./validation.mdx#verifybatch) - Verify multiple proofs

### Constants

- 48 bytes = BLS12-381 G1 point compressed
- Same size as Commitment

### KZG Proofs

KZG (Kate-Zaverucha-Goldberg) proofs:
- Polynomial opening proofs
- 48 bytes (BLS12-381 G1 point)
- Proves commitment correctness
- Verifiable with trusted setup

### References

- [EIP-4844 Specification](https://eips.ethereum.org/EIPS/eip-4844)
- [KZG Commitments](https://dankradfeist.de/ethereum/2020/06/16/kate-polynomial-commitments.html)
- [BLS12-381 Curve](https://hackmd.io/@benjaminion/bls12-381)
