# Blob Validation

Methods for validating blobs, commitments, proofs, and versioned hashes.

## isValid

Validates blob has correct size.

### Signature

```typescript
function isValid(blob: Uint8Array): boolean
```

### Parameters

- `blob` - Uint8Array to validate

### Returns

`boolean` - `true` if blob is exactly 131072 bytes

### Example

```typescript
const blob = new Uint8Array(131072);
if (Blob.isValid(blob)) {
  // blob is correct size
  const data = Blob.toData(blob);
}

// Too small
Blob.isValid(new Uint8Array(1000)); // false

// Too large
Blob.isValid(new Uint8Array(200000)); // false

// Exact size
Blob.isValid(new Uint8Array(131072)); // true
```

### Type Guard

Not a type guard. For type narrowing, use TypeScript type assertion after validation.

```typescript
if (!Blob.isValid(blob)) {
  throw new Error("Invalid blob size");
}
// Can safely cast to BrandedBlob if needed
const validBlob = blob as BrandedBlob;
```

### Performance

~10M+ ops/sec (simple length check)

### Implementation

```javascript
export function isValid(blob) {
  return blob.length === SIZE;
}
```

### See Also

- [constants.mdx](./constants.mdx#size) - SIZE constant (131072)
- [from](./constructors.mdx#from) - Uses isValid internally

---

## verify

Verifies KZG proof for single blob.

### Signature

```typescript
function verify(blob: BrandedBlob, commitment: Commitment, proof: Proof): boolean
```

### Parameters

- `blob` - Blob data (131072 bytes)
- `commitment` - KZG commitment (48 bytes)
- `proof` - KZG proof (48 bytes)

### Returns

`boolean` - `true` if proof is valid

### Status

**Not implemented** - requires c-kzg-4844 library

### Throws

- `Error` - Invalid blob size (not 131072 bytes)
- `Error` - Invalid commitment size (not 48 bytes)
- `Error` - Invalid proof size (not 48 bytes)
- `Error` - "Not implemented: requires c-kzg-4844 library"

### Example (Future)

```typescript
// When implemented:
const blob = Blob.fromData(data);
const commitment = Blob.toCommitment(blob);
const proof = Blob.toProof(blob, commitment);

const isValid = Blob.verify(blob, commitment, proof);
if (!isValid) {
  throw new Error("Invalid proof");
}
```

### Current Behavior

```typescript
try {
  Blob.verify(blob, commitment, proof);
} catch (err) {
  console.error(err.message); // "Not implemented: requires c-kzg-4844 library"
}
```

### Implementation Plan

Will use c-kzg-4844's `verifyBlobKzgProof`:

```javascript
// TODO:
export function verify(blob, commitment, proof) {
  if (blob.length !== SIZE) {
    throw new Error(`Invalid blob size: ${blob.length}`);
  }
  if (commitment.length !== 48) {
    throw new Error(`Invalid commitment size: ${commitment.length}`);
  }
  if (proof.length !== 48) {
    throw new Error(`Invalid proof size: ${proof.length}`);
  }
  return verifyBlobKzgProof(blob, commitment, proof);
}
```

### See Also

- [verifyBatch](#verifybatch) - Batch verification (more efficient)
- [toProof](./conversions.mdx#toproof) - Generate proof
- [EIP-4844 Specification](https://eips.ethereum.org/EIPS/eip-4844)

---

## verifyBatch

Verifies multiple blob proofs in batch (more efficient than individual verification).

### Signature

```typescript
function verifyBatch(
  blobs: readonly BrandedBlob[],
  commitments: readonly Commitment[],
  proofs: readonly Proof[]
): boolean
```

### Parameters

- `blobs` - Array of blobs (each 131072 bytes)
- `commitments` - Array of commitments (each 48 bytes)
- `proofs` - Array of proofs (each 48 bytes)

### Returns

`boolean` - `true` if all proofs are valid

### Status

**Not implemented** - requires c-kzg-4844 library

### Throws

- `Error` - Arrays have different lengths
- `Error` - Too many blobs (> MAX_PER_TRANSACTION = 6)
- `Error` - "Not implemented: requires c-kzg-4844 library"

### Example (Future)

```typescript
// When implemented:
const data = new Uint8Array(400000);
const blobs = Blob.splitData(data); // [blob1, blob2, blob3]
const commitments = blobs.map(b => Blob.toCommitment(b));
const proofs = blobs.map((b, i) => Blob.toProof(b, commitments[i]));

// Batch verification (more efficient)
const isValid = Blob.verifyBatch(blobs, commitments, proofs);

// vs individual (less efficient)
const individualResults = blobs.map((blob, i) =>
  Blob.verify(blob, commitments[i], proofs[i])
);
const allValid = individualResults.every(v => v);
```

### Current Behavior

```typescript
try {
  Blob.verifyBatch(blobs, commitments, proofs);
} catch (err) {
  console.error(err.message); // "Not implemented: requires c-kzg-4844 library"
}
```

### Validation

```typescript
// Array length mismatch
Blob.verifyBatch(
  [blob1, blob2],
  [commitment1],
  [proof1]
); // throws "Arrays must have same length"

// Too many blobs
const tooManyBlobs = new Array(7).fill(blob);
const tooManyCommitments = new Array(7).fill(commitment);
const tooManyProofs = new Array(7).fill(proof);
Blob.verifyBatch(tooManyBlobs, tooManyCommitments, tooManyProofs);
// throws "Too many blobs: 7 (max 6)"
```

### Implementation Plan

Will use c-kzg-4844's `verifyBlobKzgProofBatch`:

```javascript
// TODO:
export function verifyBatch(blobs, commitments, proofs) {
  if (blobs.length !== commitments.length || blobs.length !== proofs.length) {
    throw new Error("Arrays must have same length");
  }
  if (blobs.length > MAX_PER_TRANSACTION) {
    throw new Error(`Too many blobs: ${blobs.length} (max ${MAX_PER_TRANSACTION})`);
  }
  return verifyBlobKzgProofBatch(blobs, commitments, proofs);
}
```

### Performance Benefits

Batch verification significantly faster than individual verification:

- **Individual**: O(n) - verify each blob separately
- **Batch**: O(1) amortized - single verification operation

Expected speedup: 2-5x for typical transaction sizes (2-6 blobs)

### See Also

- [verify](#verify) - Single blob verification
- [constants.mdx](./constants.mdx#max_per_transaction) - MAX_PER_TRANSACTION constant

---

## isValidVersion

Validates versioned hash version byte.

### Signature

```typescript
function isValidVersion(hash: VersionedHash): boolean
```

### Parameters

- `hash` - Versioned hash (32 bytes)

### Returns

`boolean` - `true` if hash is 32 bytes with correct version byte (0x01)

### Version

Current version: `COMMITMENT_VERSION_KZG = 0x01`

### Example

```typescript
// Valid versioned hash
const commitment = getCommitment();
const hash = Blob.toVersionedHash(commitment);
Blob.isValidVersion(hash); // true (32 bytes, version 0x01)

// Invalid - wrong size
const wrongSize = new Uint8Array(31);
Blob.isValidVersion(wrongSize); // false

// Invalid - wrong version
const wrongVersion = new Uint8Array(32);
wrongVersion[0] = 0x02; // Future version
Blob.isValidVersion(wrongVersion); // false

// Valid version byte
const validHash = new Uint8Array(32);
validHash[0] = 0x01;
Blob.isValidVersion(validHash); // true
```

### Implementation

```javascript
export function isValidVersion(hash) {
  return hash.length === 32 && hash[0] === COMMITMENT_VERSION_KZG;
}
```

### Type Guard

Not a TypeScript type guard. Use manual type assertion after validation.

```typescript
if (!Blob.isValidVersion(hash)) {
  throw new Error("Invalid versioned hash version");
}
const validHash = hash as VersionedHash;
```

### Future Versions

If EIP-4844 introduces new commitment schemes, version byte will change. Current implementation only accepts 0x01.

### See Also

- [toVersionedHash](./conversions.mdx#toversionedhash) - Create versioned hash
- [VersionedHash.isValid](./versioned-hash.mdx#isvalid) - Full validation
- [VersionedHash.getVersion](./versioned-hash.mdx#getversion) - Extract version
- [constants.mdx](./constants.mdx#commitment_version_kzg) - Version constant

---

## Usage Patterns

### Pre-flight Validation

```typescript
function processBlob(blob: Uint8Array): Uint8Array {
  if (!Blob.isValid(blob)) {
    throw new Error(`Invalid blob size: ${blob.length}`);
  }
  return Blob.toData(blob);
}
```

### Transaction Validation

```typescript
interface BlobTransaction {
  blobs: Uint8Array[];
  commitments: Uint8Array[];
  proofs: Uint8Array[];
  blobVersionedHashes: Uint8Array[];
}

function validateBlobTransaction(tx: BlobTransaction): void {
  // Size limits
  if (tx.blobs.length > Blob.MAX_PER_TRANSACTION) {
    throw new Error(`Too many blobs: ${tx.blobs.length}`);
  }

  // Array lengths match
  if (tx.blobs.length !== tx.commitments.length ||
      tx.blobs.length !== tx.proofs.length ||
      tx.blobs.length !== tx.blobVersionedHashes.length) {
    throw new Error("Array length mismatch");
  }

  // Validate each blob
  for (const blob of tx.blobs) {
    if (!Blob.isValid(blob)) {
      throw new Error("Invalid blob size");
    }
  }

  // Validate versioned hashes
  for (const hash of tx.blobVersionedHashes) {
    if (!Blob.isValidVersion(hash)) {
      throw new Error("Invalid versioned hash");
    }
  }

  // Verify proofs (when implemented)
  // const isValid = Blob.verifyBatch(tx.blobs, tx.commitments, tx.proofs);
  // if (!isValid) throw new Error("Invalid proofs");
}
```

### Size Validation Before Encoding

```typescript
function safeBlobCreation(data: Uint8Array): BrandedBlob {
  const maxSize = Blob.SIZE - 8;
  if (data.length > maxSize) {
    throw new Error(
      `Data too large: ${data.length} bytes (max ${maxSize})`
    );
  }
  return Blob.fromData(data);
}
```
