---
title: "Blob.Commitment"
---

# Blob.Commitment

Nested namespace for KZG commitment validation and operations.

## Type

```typescript
type Commitment = Uint8Array & { readonly __commitment: unique symbol };
```

48-byte KZG commitment (BLS12-381 G1 point).

## Namespace

```typescript
Blob.Commitment.isValid(commitment: Uint8Array): commitment is Commitment
Blob.Commitment.toVersionedHash(commitment: Commitment): VersionedHash
```

---

## isValid

Validates commitment size.

### Signature

```typescript
function isValid(commitment: Uint8Array): commitment is Commitment
```

### Parameters

- `commitment` - Uint8Array to validate

### Returns

`boolean` - `true` if exactly 48 bytes

### Type Guard

TypeScript type guard. Narrows type to `Commitment`.

### Example

```typescript
const data = new Uint8Array(48);

if (Blob.Commitment.isValid(data)) {
  // data is now Commitment type
  const hash = Blob.Commitment.toVersionedHash(data);
}

// Invalid sizes
Blob.Commitment.isValid(new Uint8Array(32));  // false
Blob.Commitment.isValid(new Uint8Array(47));  // false
Blob.Commitment.isValid(new Uint8Array(48));  // true
Blob.Commitment.isValid(new Uint8Array(64));  // false
```

### Implementation

```javascript
export const Commitment = {
  isValid: (commitment) => {
    return commitment.length === 48;
  },
  // ...
};
```

### KZG Commitment Size

48 bytes = BLS12-381 G1 point:
- Curve: BLS12-381
- Group: G1
- Encoding: Compressed form
- Size: 48 bytes (381 bits compressed)

### Validation Level

**Size only** - does not validate:
- Point is on curve
- Point is in correct subgroup
- Point encoding is valid

For cryptographic validation, use c-kzg-4844 library.

### See Also

- [toVersionedHash](#toversionedhash) - Create hash from commitment
- [toCommitment](./conversions.mdx#tocommitment) - Generate commitment

---

## toVersionedHash

Creates versioned hash from commitment.

### Signature

```typescript
function toVersionedHash(commitment: Commitment): VersionedHash
```

### Parameters

- `commitment` - KZG commitment (48 bytes)

### Returns

`VersionedHash` - 32-byte versioned hash

### Convenience

Convenience method. Equivalent to:

```typescript
Blob.Commitment.toVersionedHash(commitment)
// Same as:
Blob.toVersionedHash(commitment)
```

### Example

```typescript
const commitment = getCommitment(); // 48 bytes

// Using Commitment namespace
const hash1 = Blob.Commitment.toVersionedHash(commitment);

// Using Blob namespace
const hash2 = Blob.toVersionedHash(commitment);

// hash1 equals hash2
```

### Formula

```
COMMITMENT_VERSION_KZG || SHA-256(commitment)[1:]
```

- Byte 0: Version (0x01)
- Bytes 1-31: Last 31 bytes of SHA-256 hash

### Implementation

Delegates to `Blob.toVersionedHash`:

```javascript
export const Commitment = {
  // ...
  toVersionedHash: (commitment) => {
    return toVersionedHash(commitment);
  },
};
```

### See Also

- [Blob.toVersionedHash](./conversions.mdx#toversionedhash) - Main implementation
- [VersionedHash namespace](./versioned-hash.mdx) - Hash operations

---

## Usage Patterns

### Type-Safe Commitment Handling

```typescript
function processCommitment(data: Uint8Array): VersionedHash {
  if (!Blob.Commitment.isValid(data)) {
    throw new Error("Invalid commitment");
  }

  // data now typed as Commitment
  return Blob.Commitment.toVersionedHash(data);
}
```

### Validation Pipeline

```typescript
interface BlobData {
  blob: BrandedBlob;
  commitment: Uint8Array;
  proof: Uint8Array;
}

function validateBlobData(data: BlobData): boolean {
  // Validate all components
  if (!Blob.isValid(data.blob)) {
    throw new Error("Invalid blob");
  }
  if (!Blob.Commitment.isValid(data.commitment)) {
    throw new Error("Invalid commitment");
  }
  if (!Blob.Proof.isValid(data.proof)) {
    throw new Error("Invalid proof");
  }

  // All valid
  return true;
}
```

### Transaction Building

```typescript
function createBlobTransaction(blobs: BrandedBlob[]) {
  // Generate commitments
  const commitments = blobs.map(b => Blob.toCommitment(b));

  // Validate all commitments
  for (const commitment of commitments) {
    if (!Blob.Commitment.isValid(commitment)) {
      throw new Error("Generated invalid commitment");
    }
  }

  // Create versioned hashes
  const hashes = commitments.map(c =>
    Blob.Commitment.toVersionedHash(c)
  );

  return { blobs, commitments, hashes };
}
```

### Generic Commitment Handler

```typescript
type CommitmentHandler = (c: Commitment) => void;

function withValidCommitment(
  data: Uint8Array,
  handler: CommitmentHandler
): void {
  if (Blob.Commitment.isValid(data)) {
    handler(data); // Type-safe: data is Commitment
  } else {
    throw new Error("Invalid commitment");
  }
}

// Usage
withValidCommitment(myData, (commitment) => {
  const hash = Blob.Commitment.toVersionedHash(commitment);
  console.log(hash);
});
```

---

## Related

### Other Namespaces

- [Blob.Proof](./proof.mdx) - Proof validation
- [Blob.VersionedHash](./versioned-hash.mdx) - Hash operations

### Commitment Operations

- [Blob.toCommitment](./conversions.mdx#tocommitment) - Generate commitment
- [Blob.toVersionedHash](./conversions.mdx#toversionedhash) - Create hash
- [Blob.verify](./validation.mdx#verify) - Verify with proof

### Constants

- 48 bytes = BLS12-381 G1 point compressed
- Version: 0x01 (KZG)

### References

- [EIP-4844 Specification](https://eips.ethereum.org/EIPS/eip-4844)
- [KZG Commitments](https://dankradfeist.de/ethereum/2020/06/16/kate-polynomial-commitments.html)
- [BLS12-381 Curve](https://hackmd.io/@benjaminion/bls12-381)
