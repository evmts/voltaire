# Blob Constructors

Methods for creating BrandedBlob instances from various input formats.

## from

Universal constructor accepting Uint8Array.

### Signature

```typescript
function from(value: Uint8Array): BrandedBlob
```

### Parameters

- `value` - Uint8Array (either exact 131072-byte blob or data to encode)

### Returns

`BrandedBlob` - 131072-byte blob

### Behavior

- If `value.length === 131072`: returns value as BrandedBlob (no encoding)
- Otherwise: encodes using `fromData()` with length prefix

### Throws

- `Error` - Data too large (exceeds SIZE - 8 bytes)

### Example

```typescript
// Raw blob (exact size)
const rawBlob = new Uint8Array(131072);
const blob1 = Blob.from(rawBlob); // No encoding

// Small data (will be encoded)
const data = new TextEncoder().encode("Hello");
const blob2 = Blob.from(data); // Encoded with length prefix

// Large data (will fail)
try {
  const tooLarge = new Uint8Array(131065);
  Blob.from(tooLarge); // Throws
} catch (err) {
  console.error(err.message); // "Data too large: 131065 bytes (max 131064)"
}
```

### Implementation

```javascript
export function from(value) {
  if (isValid(value)) {
    return value;
  }
  return fromData(value);
}
```

### See Also

- [fromData](#fromdata) - Explicit data encoding
- [isValid](./validation.mdx#isvalid) - Size validation

---

## fromData

Encodes arbitrary data as blob with length prefix.

### Signature

```typescript
function fromData(data: Uint8Array): BrandedBlob
```

### Parameters

- `data` - Uint8Array to encode (max 131064 bytes)

### Returns

`BrandedBlob` - 131072-byte blob containing encoded data

### Encoding Format

```
[0-7]:    Length prefix (8 bytes, little-endian uint64)
[8-N]:    Data (N bytes)
[N+8-..]: Zero padding to 131072 bytes
```

### Maximum Data Size

```typescript
const maxDataSize = Blob.SIZE - 8; // 131064 bytes
```

Length prefix (8 bytes) reduces usable space to 131064 bytes per blob.

### Throws

- `Error` - Data exceeds SIZE - 8 bytes (131064)

### Example

```typescript
// Small data
const text = new TextEncoder().encode("Hello, blob!");
const blob = Blob.fromData(text);
// blob.length === 131072
// blob[0-7]: length = 12
// blob[8-19]: "Hello, blob!"
// blob[20-131071]: zeros

// Maximum size data
const maxData = new Uint8Array(131064);
const maxBlob = Blob.fromData(maxData); // OK

// Too large
const tooLarge = new Uint8Array(131065);
try {
  Blob.fromData(tooLarge);
} catch (err) {
  console.error(err); // "Data too large: 131065 bytes (max 131064)"
}

// Roundtrip
const original = new TextEncoder().encode("Test data");
const encoded = Blob.fromData(original);
const decoded = Blob.toData(encoded);
// decoded equals original
```

### Implementation

```javascript
export function fromData(data) {
  if (data.length > SIZE - 8) {
    throw new Error(`Data too large: ${data.length} bytes (max ${SIZE - 8})`);
  }

  const blob = new Uint8Array(SIZE);
  const view = new DataView(blob.buffer);

  // Length prefix (8 bytes, little-endian)
  view.setBigUint64(0, BigInt(data.length), true);

  // Copy data
  blob.set(data, 8);

  return blob;
}
```

### Performance

- Small data (< 1KB): ~500k ops/sec
- Medium data (~64KB): ~100k ops/sec
- Large data (~130KB): ~50k ops/sec

Scales linearly with data size.

### See Also

- [toData](./conversions.mdx#todata) - Decode blob to data
- [splitData](./utilities.mdx#splitdata) - Handle data > 131064 bytes
- [constants.mdx](./constants.mdx#size) - SIZE constant

---

## Usage Patterns

### Small Data

```typescript
// Single message or small payload
const message = new TextEncoder().encode("Transaction data");
const blob = Blob.fromData(message);
```

### Size Checking

```typescript
function encodeData(data: Uint8Array): BrandedBlob {
  const maxSize = Blob.SIZE - 8;
  if (data.length > maxSize) {
    throw new Error(`Data too large for single blob: ${data.length} bytes`);
  }
  return Blob.fromData(data);
}
```

### Large Data Handling

```typescript
// Automatic splitting for large data
const largeData = new Uint8Array(300000);

if (largeData.length > Blob.SIZE - 8) {
  // Use splitData for automatic multi-blob handling
  const blobs = Blob.splitData(largeData);
  console.log(`Split into ${blobs.length} blobs`);
} else {
  const blob = Blob.fromData(largeData);
}
```

### Raw Blob Creation

```typescript
// When you already have exact blob format
const rawBlob = new Uint8Array(131072);
// ... fill with proper blob data ...

// No encoding needed
const blob = Blob.from(rawBlob);
```
