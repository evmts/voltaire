# Blob Conversions

Methods for converting between blobs, data, commitments, proofs, and versioned hashes.

## toData

Extracts original data from encoded blob.

### Signature

```typescript
function toData(blob: BrandedBlob): Uint8Array
```

### Parameters

- `blob` - Encoded blob (131072 bytes)

### Returns

`Uint8Array` - Original data (without length prefix or padding)

### Decoding Format

Reads blob encoded by `fromData`:

```
[0-7]:    Length prefix (8 bytes, little-endian uint64)
[8-N]:    Data (N bytes)
[N+8-..]: Padding (ignored)
```

### Throws

- `Error` - Invalid blob size (not 131072 bytes)
- `Error` - Invalid length prefix (exceeds SIZE - 8)

### Example

```typescript
// Encode then decode
const original = new TextEncoder().encode("Hello, blob!");
const blob = Blob.fromData(original);
const recovered = Blob.toData(blob);
// recovered equals original

const text = new TextDecoder().decode(recovered);
console.log(text); // "Hello, blob!"

// Invalid blob size
try {
  Blob.toData(new Uint8Array(1000));
} catch (err) {
  console.error(err); // "Invalid blob size: 1000 (expected 131072)"
}

// Corrupted length prefix
const corrupted = new Uint8Array(131072);
const view = new DataView(corrupted.buffer);
view.setBigUint64(0, 999999n, true); // Invalid length
try {
  Blob.toData(corrupted);
} catch (err) {
  console.error(err); // "Invalid length prefix: 999999"
}
```

### Implementation

```javascript
export function toData(blob) {
  if (blob.length !== SIZE) {
    throw new Error(`Invalid blob size: ${blob.length} (expected ${SIZE})`);
  }

  const view = new DataView(blob.buffer, blob.byteOffset, blob.byteLength);
  const length = Number(view.getBigUint64(0, true));

  if (length > SIZE - 8) {
    throw new Error(`Invalid length prefix: ${length}`);
  }

  return blob.slice(8, 8 + length);
}
```

### Performance

- Small data (< 1KB): ~800k ops/sec
- Medium data (~64KB): ~200k ops/sec
- Large data (~130KB): ~100k ops/sec

Scales linearly with decoded data size.

### See Also

- [fromData](./constructors.mdx#fromdata) - Encode data to blob
- [joinData](./utilities.mdx#joindata) - Decode multiple blobs

---

## toCommitment

Generates KZG commitment for blob.

### Signature

```typescript
function toCommitment(blob: BrandedBlob): Commitment
```

### Parameters

- `blob` - Blob data (131072 bytes)

### Returns

`Commitment` - 48-byte KZG commitment

### Status

**Not implemented** - requires c-kzg-4844 library

### Throws

- `Error` - Invalid blob size (not 131072 bytes)
- `Error` - "Not implemented: requires c-kzg-4844 library"

### Example (Future)

```typescript
// When implemented:
const data = new TextEncoder().encode("Hello");
const blob = Blob.fromData(data);
const commitment = Blob.toCommitment(blob);
// commitment.length === 48
```

### Current Behavior

```typescript
try {
  const commitment = Blob.toCommitment(blob);
} catch (err) {
  console.error(err.message); // "Not implemented: requires c-kzg-4844 library"
}
```

### Implementation Plan

Will use c-kzg-4844's `blobToKzgCommitment`:

```javascript
// TODO:
export function toCommitment(blob) {
  if (blob.length !== SIZE) {
    throw new Error(`Invalid blob size: ${blob.length}`);
  }
  const commitment = blobToKzgCommitment(blob);
  return commitment;
}
```

### KZG Commitments

KZG (Kate-Zaverucha-Goldberg) commitments:
- Polynomial commitment scheme
- 48 bytes (BLS12-381 G1 point)
- Binding: cannot create two valid openings
- Hiding: commitment reveals nothing about polynomial

### See Also

- [toProof](#toproof) - Generate proof from commitment
- [toVersionedHash](#toversionedhash) - Hash commitment for transaction
- [Commitment.isValid](./commitment.mdx#isvalid) - Validate commitment
- [EIP-4844 Specification](https://eips.ethereum.org/EIPS/eip-4844)

---

## toProof

Generates KZG proof for blob and commitment.

### Signature

```typescript
function toProof(blob: BrandedBlob, commitment: Commitment): Proof
```

### Parameters

- `blob` - Blob data (131072 bytes)
- `commitment` - KZG commitment for the blob (48 bytes)

### Returns

`Proof` - 48-byte KZG proof

### Status

**Not implemented** - requires c-kzg-4844 library

### Throws

- `Error` - Invalid blob size (not 131072 bytes)
- `Error` - Invalid commitment size (not 48 bytes)
- `Error` - "Not implemented: requires c-kzg-4844 library"

### Example (Future)

```typescript
// When implemented:
const blob = Blob.fromData(data);
const commitment = Blob.toCommitment(blob);
const proof = Blob.toProof(blob, commitment);
// proof.length === 48

// Verify proof
const isValid = Blob.verify(blob, commitment, proof);
```

### Current Behavior

```typescript
try {
  const proof = Blob.toProof(blob, commitment);
} catch (err) {
  console.error(err.message); // "Not implemented: requires c-kzg-4844 library"
}
```

### Implementation Plan

Will use c-kzg-4844's `computeBlobKzgProof`:

```javascript
// TODO:
export function toProof(blob, commitment) {
  if (blob.length !== SIZE) {
    throw new Error(`Invalid blob size: ${blob.length}`);
  }
  if (commitment.length !== 48) {
    throw new Error(`Invalid commitment size: ${commitment.length}`);
  }
  const proof = computeBlobKzgProof(blob, commitment);
  return proof;
}
```

### KZG Proofs

- Proves correctness of commitment
- 48 bytes (BLS12-381 G1 point)
- Verifiable by anyone with trusted setup
- Required for blob transactions

### Workflow

```typescript
// 1. Create commitment
const commitment = Blob.toCommitment(blob);

// 2. Generate proof
const proof = Blob.toProof(blob, commitment);

// 3. Verify proof
const isValid = Blob.verify(blob, commitment, proof);

// 4. Include in transaction
const tx = {
  // ...
  blobs: [blob],
  commitments: [commitment],
  proofs: [proof],
};
```

### See Also

- [toCommitment](#tocommitment) - Generate commitment first
- [verify](./validation.mdx#verify) - Verify proof
- [Proof.isValid](./proof.mdx#isvalid) - Validate proof format
- [EIP-4844 Specification](https://eips.ethereum.org/EIPS/eip-4844)

---

## toVersionedHash

Creates versioned hash from commitment for use in transaction.

### Signature

```typescript
function toVersionedHash(commitment: Commitment): VersionedHash
```

### Parameters

- `commitment` - KZG commitment (48 bytes)

### Returns

`VersionedHash` - 32-byte versioned hash

### Formula

```
COMMITMENT_VERSION_KZG || sha256(commitment)[1:]
```

- Byte 0: Version byte (0x01)
- Bytes 1-31: Last 31 bytes of SHA-256 hash

### Throws

- `Error` - Invalid commitment size (not 48 bytes)

### Example

```typescript
// Create versioned hash
const commitment = getCommitment(); // 48 bytes
const hash = Blob.toVersionedHash(commitment);
// hash.length === 32
// hash[0] === 0x01

// Validate
if (Blob.VersionedHash.isValid(hash)) {
  console.log("Valid versioned hash");
}

// Get version
const version = Blob.VersionedHash.getVersion(hash); // 0x01

// Use in transaction
const tx = {
  // ...
  blobVersionedHashes: [hash],
};
```

### Implementation

```javascript
export function toVersionedHash(commitment) {
  if (commitment.length !== 48) {
    throw new Error(`Invalid commitment size: ${commitment.length}`);
  }

  // Hash the commitment with SHA-256
  const hash = SHA256.hash(commitment);

  // Create versioned hash: version byte + hash[1:32]
  const versionedHash = new Uint8Array(32);
  versionedHash[0] = COMMITMENT_VERSION_KZG;
  versionedHash.set(hash.slice(1), 1);

  return versionedHash;
}
```

### Why Versioned?

Version byte allows future upgrades:
- 0x01: KZG commitments (current)
- Future: Other commitment schemes

### Transaction Usage

Versioned hashes go in `blobVersionedHashes` field:

```typescript
// Full workflow
const blobs = Blob.splitData(data);
const commitments = blobs.map(b => Blob.toCommitment(b));
const proofs = blobs.map((b, i) => Blob.toProof(b, commitments[i]));
const hashes = commitments.map(c => Blob.toVersionedHash(c));

const tx = {
  type: 0x03, // EIP-4844
  // ... standard fields ...
  blobVersionedHashes: hashes,
  // Network layer includes:
  blobs: blobs,
  commitments: commitments,
  proofs: proofs,
};
```

### Performance

~10k-50k ops/sec (depends on SHA-256 implementation)

### See Also

- [toCommitment](#tocommitment) - Generate commitment first
- [VersionedHash namespace](./versioned-hash.mdx) - Validation and utilities
- [constants.mdx](./constants.mdx#commitment_version_kzg) - Version constant
- [EIP-4844 Specification](https://eips.ethereum.org/EIPS/eip-4844)

---

## Usage Patterns

### Complete Conversion Workflow

```typescript
// 1. Data → Blob
const data = new TextEncoder().encode("Message");
const blob = Blob.fromData(data);

// 2. Blob → Commitment (when implemented)
// const commitment = Blob.toCommitment(blob);

// 3. Blob + Commitment → Proof (when implemented)
// const proof = Blob.toProof(blob, commitment);

// 4. Commitment → Versioned Hash
// const hash = Blob.toVersionedHash(commitment);

// 5. Blob → Data (decode)
const recovered = Blob.toData(blob);
```

### Multi-Blob Transaction

```typescript
// Split large data
const largeData = new Uint8Array(400000);
const blobs = Blob.splitData(largeData);

// Generate all components (when implemented)
const commitments = blobs.map(b => Blob.toCommitment(b));
const proofs = blobs.map((b, i) => Blob.toProof(b, commitments[i]));
const hashes = commitments.map(c => Blob.toVersionedHash(c));

// Verify all proofs
const isValid = Blob.verifyBatch(blobs, commitments, proofs);

// Build transaction
const tx = {
  blobVersionedHashes: hashes,
  // Network layer:
  blobs: blobs,
  commitments: commitments,
  proofs: proofs,
};
```

### Roundtrip Validation

```typescript
function roundtripTest(original: Uint8Array): boolean {
  const blob = Blob.fromData(original);
  const recovered = Blob.toData(blob);

  // Compare byte-by-byte
  if (original.length !== recovered.length) return false;
  for (let i = 0; i < original.length; i++) {
    if (original[i] !== recovered[i]) return false;
  }
  return true;
}
```
